  RFC 9002          QUIC Loss Detection   May 2021
  ----------------- --------------------- ----------
  Iyengar & Swett   Standards Track       \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9002](https://www.rfc-editor.org/rfc/rfc9002){.eref}

Category:
:   Standards Track

Published:
:   May 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    J. Iyengar, [Ed.]{.editor}
    :::

    ::: org
    Fastly
    :::
    :::

    ::: author
    ::: author-name
    I. Swett, [Ed.]{.editor}
    :::

    ::: org
    Google
    :::
    :::
:::

# RFC 9002 {#rfcnum}

# QUIC Loss Detection and Congestion Control {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes loss detection and congestion control mechanisms
for QUIC.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9002>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Conventions and
    Definitions](#name-conventions-and-definitions){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Design of the QUIC Transmission
    Machinery](#name-design-of-the-quic-transmis){.xref}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Relevant Differences between QUIC and
    TCP](#name-relevant-differences-betwee){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Separate Packet Number
        Spaces](#name-separate-packet-number-spac){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Monotonically Increasing Packet
        Numbers](#name-monotonically-increasing-pa){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Clearer Loss
        Epoch](#name-clearer-loss-epoch){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [No
        Reneging](#name-no-reneging){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [More ACK
        Ranges](#name-more-ack-ranges){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.6}
        [4.6](#section-4.6){.xref}.  [Explicit Correction for Delayed
        Acknowledgments](#name-explicit-correction-for-del){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.7}
        [4.7](#section-4.7){.xref}.  [Probe Timeout Replaces RTO and
        TLP](#name-probe-timeout-replaces-rto-){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.8}
        [4.8](#section-4.8){.xref}.  [The Minimum Congestion Window Is
        Two Packets](#name-the-minimum-congestion-wind){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.9}
        [4.9](#section-4.9){.xref}.  [Handshake Packets Are Not
        Special](#name-handshake-packets-are-not-s){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Estimating the Round-Trip
    Time](#name-estimating-the-round-trip-t){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Generating RTT
        Samples](#name-generating-rtt-samples){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Estimating
        min_rtt](#name-estimating-min_rtt){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Estimating smoothed_rtt and
        rttvar](#name-estimating-smoothed_rtt-and){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Loss
    Detection](#name-loss-detection){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Acknowledgment-Based
        Detection](#name-acknowledgment-based-detect){.xref}

        -   ::: {#section-toc.1-1.6.2.1.2.1}
            [6.1.1](#section-6.1.1){.xref}.  [Packet
            Threshold](#name-packet-threshold){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.1.2.2}
            [6.1.2](#section-6.1.2){.xref}.  [Time
            Threshold](#name-time-threshold){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Probe
        Timeout](#name-probe-timeout){.xref}

        -   ::: {#section-toc.1-1.6.2.2.2.1}
            [6.2.1](#section-6.2.1){.xref}.  [Computing
            PTO](#name-computing-pto){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.2.2.2}
            [6.2.2](#section-6.2.2){.xref}.  [Handshakes and New
            Paths](#name-handshakes-and-new-paths){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.2.2.3}
            [6.2.3](#section-6.2.3){.xref}.  [Speeding up Handshake
            Completion](#name-speeding-up-handshake-compl){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.2.2.4}
            [6.2.4](#section-6.2.4){.xref}.  [Sending Probe
            Packets](#name-sending-probe-packets){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Handling Retry
        Packets](#name-handling-retry-packets){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [Discarding Keys and Packet
        State](#name-discarding-keys-and-packet-){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Congestion
    Control](#name-congestion-control){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Explicit Congestion
        Notification](#name-explicit-congestion-notific){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Initial and Minimum Congestion
        Window](#name-initial-and-minimum-congest){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Congestion Control
        States](#name-congestion-control-states){.xref}

        -   ::: {#section-toc.1-1.7.2.3.2.1}
            [7.3.1](#section-7.3.1){.xref}.  [Slow
            Start](#name-slow-start){.xref}
            :::

        -   ::: {#section-toc.1-1.7.2.3.2.2}
            [7.3.2](#section-7.3.2){.xref}.  [Recovery](#name-recovery){.xref}
            :::

        -   ::: {#section-toc.1-1.7.2.3.2.3}
            [7.3.3](#section-7.3.3){.xref}.  [Congestion
            Avoidance](#name-congestion-avoidance){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [Ignoring Loss of Undecryptable
        Packets](#name-ignoring-loss-of-undecrypta){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.5}
        [7.5](#section-7.5){.xref}.  [Probe
        Timeout](#name-probe-timeout-2){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.6}
        [7.6](#section-7.6){.xref}.  [Persistent
        Congestion](#name-persistent-congestion){.xref}

        -   ::: {#section-toc.1-1.7.2.6.2.1}
            [7.6.1](#section-7.6.1){.xref}.  [Duration](#name-duration){.xref}
            :::

        -   ::: {#section-toc.1-1.7.2.6.2.2}
            [7.6.2](#section-7.6.2){.xref}.  [Establishing Persistent
            Congestion](#name-establishing-persistent-con){.xref}
            :::

        -   ::: {#section-toc.1-1.7.2.6.2.3}
            [7.6.3](#section-7.6.3){.xref}.  [Example](#name-example){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.7.2.7}
        [7.7](#section-7.7){.xref}.  [Pacing](#name-pacing){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.8}
        [7.8](#section-7.8){.xref}.  [Underutilizing the Congestion
        Window](#name-underutilizing-the-congesti){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Loss and Congestion
        Signals](#name-loss-and-congestion-signals){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Traffic
        Analysis](#name-traffic-analysis){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [8.3](#section-8.3){.xref}.  [Misreporting ECN
        Markings](#name-misreporting-ecn-markings){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [Appendix A](#section-appendix.a){.xref}.  [Loss Recovery
    Pseudocode](#name-loss-recovery-pseudocode){.xref}

    -   ::: {#section-toc.1-1.10.2.1}
        [A.1](#section-a.1){.xref}.  [Tracking Sent
        Packets](#name-tracking-sent-packets){.xref}

        -   ::: {#section-toc.1-1.10.2.1.2.1}
            [A.1.1](#section-a.1.1){.xref}.  [Sent Packet
            Fields](#name-sent-packet-fields){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [A.2](#section-a.2){.xref}.  [Constants of
        Interest](#name-constants-of-interest){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.3}
        [A.3](#section-a.3){.xref}.  [Variables of
        Interest](#name-variables-of-interest){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.4}
        [A.4](#section-a.4){.xref}.  [Initialization](#name-initialization){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.5}
        [A.5](#section-a.5){.xref}.  [On Sending a
        Packet](#name-on-sending-a-packet){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.6}
        [A.6](#section-a.6){.xref}.  [On Receiving a
        Datagram](#name-on-receiving-a-datagram){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.7}
        [A.7](#section-a.7){.xref}.  [On Receiving an
        Acknowledgment](#name-on-receiving-an-acknowledgm){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.8}
        [A.8](#section-a.8){.xref}.  [Setting the Loss Detection
        Timer](#name-setting-the-loss-detection-){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.9}
        [A.9](#section-a.9){.xref}.  [On
        Timeout](#name-on-timeout){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.10}
        [A.10](#section-a.10){.xref}. [Detecting Lost
        Packets](#name-detecting-lost-packets){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.11}
        [A.11](#section-a.11){.xref}. [Upon Dropping Initial or
        Handshake Keys](#name-upon-dropping-initial-or-ha){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [Appendix B](#section-appendix.b){.xref}.  [Congestion Control
    Pseudocode](#name-congestion-control-pseudoco){.xref}

    -   ::: {#section-toc.1-1.11.2.1}
        [B.1](#section-b.1){.xref}.  [Constants of
        Interest](#name-constants-of-interest-2){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [B.2](#section-b.2){.xref}.  [Variables of
        Interest](#name-variables-of-interest-2){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.3}
        [B.3](#section-b.3){.xref}.  [Initialization](#name-initialization-2){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.4}
        [B.4](#section-b.4){.xref}.  [On Packet
        Sent](#name-on-packet-sent){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.5}
        [B.5](#section-b.5){.xref}.  [On Packet
        Acknowledgment](#name-on-packet-acknowledgment){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.6}
        [B.6](#section-b.6){.xref}.  [On New Congestion
        Event](#name-on-new-congestion-event){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.7}
        [B.7](#section-b.7){.xref}.  [Process ECN
        Information](#name-process-ecn-information){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.8}
        [B.8](#section-b.8){.xref}.  [On Packets
        Lost](#name-on-packets-lost){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.9}
        [B.9](#section-b.9){.xref}.  [Removing Discarded Packets from
        Bytes in Flight](#name-removing-discarded-packets-){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [](#section-appendix.c){.xref}[Contributors](#name-contributors){.xref}
    :::

-   ::: {#section-toc.1-1.13}
    [](#section-appendix.d){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

QUIC is a secure, general-purpose transport protocol, described in
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]. This document describes
loss detection and congestion control mechanisms for
QUIC.[¶](#section-1-1){.pilcrow}
:::
:::

::: {#conventions-and-definitions}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Conventions and Definitions](#name-conventions-and-definitions){.section-name .selfRef} {#name-conventions-and-definitions}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}

Definitions of terms that are used in this
document:[¶](#section-2-2){.pilcrow}

[]{.break}

Ack-eliciting frames:

:   All frames other than ACK, PADDING, and CONNECTION_CLOSE are
    considered ack-eliciting.[¶](#section-2-3.2.1){.pilcrow}

:   

Ack-eliciting packets:

:   Packets that contain ack-eliciting frames elicit an ACK from the
    receiver within the maximum acknowledgment delay and are called
    ack-eliciting packets.[¶](#section-2-3.4.1){.pilcrow}

:   

In-flight packets:

:   Packets are considered in flight when they are ack-eliciting or
    contain a PADDING frame, and they have been sent but are not
    acknowledged, declared lost, or discarded along with old
    keys.[¶](#section-2-3.6.1){.pilcrow}

:   
:::
:::

::: {#design-of-the-quic-transmission-machinery}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Design of the QUIC Transmission Machinery](#name-design-of-the-quic-transmis){.section-name .selfRef} {#name-design-of-the-quic-transmis}

All transmissions in QUIC are sent with a packet-level header, which
indicates the encryption level and includes a packet sequence number
(referred to below as a packet number). The encryption level indicates
the packet number space, as described in [Section
12.3](https://www.rfc-editor.org/rfc/rfc9000#section-12.3){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]. Packet numbers never
repeat within a packet number space for the lifetime of a connection.
Packet numbers are sent in monotonically increasing order within a
space, preventing ambiguity. It is permitted for some packet numbers to
never be used, leaving intentional gaps.[¶](#section-3-1){.pilcrow}

This design obviates the need for disambiguating between transmissions
and retransmissions; this eliminates significant complexity from QUIC\'s
interpretation of TCP loss detection
mechanisms.[¶](#section-3-2){.pilcrow}

QUIC packets can contain multiple frames of different types. The
recovery mechanisms ensure that data and frames that need reliable
delivery are acknowledged or declared lost and sent in new packets as
necessary. The types of frames contained in a packet affect recovery and
congestion control logic:[¶](#section-3-3){.pilcrow}

-   [All packets are acknowledged, though packets that contain no
    ack-eliciting frames are only acknowledged along with ack-eliciting
    packets.[¶](#section-3-4.1){.pilcrow}]{#section-3-4.1}
-   [Long header packets that contain CRYPTO frames are critical to the
    performance of the QUIC handshake and use shorter timers for
    acknowledgment.[¶](#section-3-4.2){.pilcrow}]{#section-3-4.2}
-   [Packets containing frames besides ACK or CONNECTION_CLOSE frames
    count toward congestion control limits and are considered to be in
    flight.[¶](#section-3-4.3){.pilcrow}]{#section-3-4.3}
-   [PADDING frames cause packets to contribute toward bytes in flight
    without directly causing an acknowledgment to be
    sent.[¶](#section-3-4.4){.pilcrow}]{#section-3-4.4}
:::
:::

::: {#relevant-differences-between-quic-and-tcp}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Relevant Differences between QUIC and TCP](#name-relevant-differences-betwee){.section-name .selfRef} {#name-relevant-differences-betwee}

Readers familiar with TCP\'s loss detection and congestion control will
find algorithms here that parallel well-known TCP ones. However,
protocol differences between QUIC and TCP contribute to algorithmic
differences. These protocol differences are briefly described
below.[¶](#section-4-1){.pilcrow}

::: {#separate-packet-number-spaces}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Separate Packet Number Spaces](#name-separate-packet-number-spac){.section-name .selfRef} {#name-separate-packet-number-spac}

QUIC uses separate packet number spaces for each encryption level,
except 0-RTT and all generations of 1-RTT keys use the same packet
number space. Separate packet number spaces ensures that the
acknowledgment of packets sent with one level of encryption will not
cause spurious retransmission of packets sent with a different
encryption level. Congestion control and round-trip time (RTT)
measurement are unified across packet number
spaces.[¶](#section-4.1-1){.pilcrow}
:::
:::

::: {#monotonically-increasing-packet-numbers}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Monotonically Increasing Packet Numbers](#name-monotonically-increasing-pa){.section-name .selfRef} {#name-monotonically-increasing-pa}

TCP conflates transmission order at the sender with delivery order at
the receiver, resulting in the retransmission ambiguity problem
\[[RETRANSMISSION](#RETRANSMISSION){.xref}\]. QUIC separates
transmission order from delivery order: packet numbers indicate
transmission order, and delivery order is determined by the stream
offsets in STREAM frames.[¶](#section-4.2-1){.pilcrow}

QUIC\'s packet number is strictly increasing within a packet number
space and directly encodes transmission order. A higher packet number
signifies that the packet was sent later, and a lower packet number
signifies that the packet was sent earlier. When a packet containing
ack-eliciting frames is detected lost, QUIC includes necessary frames in
a new packet with a new packet number, removing ambiguity about which
packet is acknowledged when an ACK is received. Consequently, more
accurate RTT measurements can be made, spurious retransmissions are
trivially detected, and mechanisms such as Fast Retransmit can be
applied universally, based only on packet
number.[¶](#section-4.2-2){.pilcrow}

This design point significantly simplifies loss detection mechanisms for
QUIC. Most TCP mechanisms implicitly attempt to infer transmission
ordering based on TCP sequence numbers \-- a nontrivial task, especially
when TCP timestamps are not available.[¶](#section-4.2-3){.pilcrow}
:::
:::

::: {#clearer-loss-epoch}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Clearer Loss Epoch](#name-clearer-loss-epoch){.section-name .selfRef} {#name-clearer-loss-epoch}

QUIC starts a loss epoch when a packet is lost. The loss epoch ends when
any packet sent after the start of the epoch is acknowledged. TCP waits
for the gap in the sequence number space to be filled, and so if a
segment is lost multiple times in a row, the loss epoch may not end for
several round trips. Because both should reduce their congestion windows
only once per epoch, QUIC will do it once for every round trip that
experiences loss, while TCP may only do it once across multiple round
trips.[¶](#section-4.3-1){.pilcrow}
:::
:::

::: {#no-reneging}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [No Reneging](#name-no-reneging){.section-name .selfRef} {#name-no-reneging}

QUIC ACK frames contain information similar to that in TCP Selective
Acknowledgments (SACKs) \[[RFC2018](#RFC2018){.xref}\]. However, QUIC
does not allow a packet acknowledgment to be reneged, greatly
simplifying implementations on both sides and reducing memory pressure
on the sender.[¶](#section-4.4-1){.pilcrow}
:::
:::

::: {#more-ack-ranges}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [More ACK Ranges](#name-more-ack-ranges){.section-name .selfRef} {#name-more-ack-ranges}

QUIC supports many ACK ranges, as opposed to TCP\'s three SACK ranges.
In high-loss environments, this speeds recovery, reduces spurious
retransmits, and ensures forward progress without relying on
timeouts.[¶](#section-4.5-1){.pilcrow}
:::
:::

::: {#explicit-correction-for-delayed-acknowledgments}
::: {#section-4.6 .section}
### [4.6.](#section-4.6){.section-number .selfRef} [Explicit Correction for Delayed Acknowledgments](#name-explicit-correction-for-del){.section-name .selfRef} {#name-explicit-correction-for-del}

QUIC endpoints measure the delay incurred between when a packet is
received and when the corresponding acknowledgment is sent, allowing a
peer to maintain a more accurate RTT estimate; see [Section
13.2](https://www.rfc-editor.org/rfc/rfc9000#section-13.2){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-4.6-1){.pilcrow}
:::
:::

::: {#probe-timeout-replaces-rto-and-tlp}
::: {#section-4.7 .section}
### [4.7.](#section-4.7){.section-number .selfRef} [Probe Timeout Replaces RTO and TLP](#name-probe-timeout-replaces-rto-){.section-name .selfRef} {#name-probe-timeout-replaces-rto-}

QUIC uses a probe timeout (PTO; see [Section 6.2](#pto){.xref}), with a
timer based on TCP\'s retransmission timeout (RTO) computation; see
\[[RFC6298](#RFC6298){.xref}\]. QUIC\'s PTO includes the peer\'s maximum
expected acknowledgment delay instead of using a fixed minimum
timeout.[¶](#section-4.7-1){.pilcrow}

Similar to the RACK-TLP loss detection algorithm for TCP
\[[RFC8985](#RFC8985){.xref}\], QUIC does not collapse the congestion
window when the PTO expires, since a single packet loss at the tail does
not indicate persistent congestion. Instead, QUIC collapses the
congestion window when persistent congestion is declared; see [Section
7.6](#persistent-congestion){.xref}. In doing this, QUIC avoids
unnecessary congestion window reductions, obviating the need for
correcting mechanisms such as Forward RTO-Recovery (F-RTO)
\[[RFC5682](#RFC5682){.xref}\]. Since QUIC does not collapse the
congestion window on a PTO expiration, a QUIC sender is not limited from
sending more in-flight packets after a PTO expiration if it still has
available congestion window. This occurs when a sender is application
limited and the PTO timer expires. This is more aggressive than TCP\'s
RTO mechanism when application limited, but identical when not
application limited.[¶](#section-4.7-2){.pilcrow}

QUIC allows probe packets to temporarily exceed the congestion window
whenever the timer expires.[¶](#section-4.7-3){.pilcrow}
:::
:::

::: {#the-minimum-congestion-window-is-two-packets}
::: {#section-4.8 .section}
### [4.8.](#section-4.8){.section-number .selfRef} [The Minimum Congestion Window Is Two Packets](#name-the-minimum-congestion-wind){.section-name .selfRef} {#name-the-minimum-congestion-wind}

TCP uses a minimum congestion window of one packet. However, loss of
that single packet means that the sender needs to wait for a PTO to
recover ([Section 6.2](#pto){.xref}), which can be much longer than an
RTT. Sending a single ack-eliciting packet also increases the chances of
incurring additional latency when a receiver delays its
acknowledgment.[¶](#section-4.8-1){.pilcrow}

QUIC therefore recommends that the minimum congestion window be two
packets. While this increases network load, it is considered safe since
the sender will still reduce its sending rate exponentially under
persistent congestion ([Section
6.2](#pto){.xref}).[¶](#section-4.8-2){.pilcrow}
:::
:::

::: {#handshake-packets-are-not-special}
::: {#section-4.9 .section}
### [4.9.](#section-4.9){.section-number .selfRef} [Handshake Packets Are Not Special](#name-handshake-packets-are-not-s){.section-name .selfRef} {#name-handshake-packets-are-not-s}

TCP treats the loss of SYN or SYN-ACK packet as persistent congestion
and reduces the congestion window to one packet; see
\[[RFC5681](#RFC5681){.xref}\]. QUIC treats loss of a packet containing
handshake data the same as other losses.[¶](#section-4.9-1){.pilcrow}
:::
:::
:::
:::

::: {#compute-rtt}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Estimating the Round-Trip Time](#name-estimating-the-round-trip-t){.section-name .selfRef} {#name-estimating-the-round-trip-t}

At a high level, an endpoint measures the time from when a packet was
sent to when it is acknowledged as an RTT sample. The endpoint uses RTT
samples and peer-reported host delays (see [Section
13.2](https://www.rfc-editor.org/rfc/rfc9000#section-13.2){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]) to generate a statistical
description of the network path\'s RTT. An endpoint computes the
following three values for each path: the minimum value over a period of
time (min_rtt), an exponentially weighted moving average (smoothed_rtt),
and the mean deviation (referred to as \"variation\" in the rest of this
document) in the observed RTT samples
(rttvar).[¶](#section-5-1){.pilcrow}

::: {#latest-rtt}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Generating RTT Samples](#name-generating-rtt-samples){.section-name .selfRef} {#name-generating-rtt-samples}

An endpoint generates an RTT sample on receiving an ACK frame that meets
the following two conditions:[¶](#section-5.1-1){.pilcrow}

-   [the largest acknowledged packet number is newly acknowledged,
    and[¶](#section-5.1-2.1){.pilcrow}]{#section-5.1-2.1}
-   [at least one of the newly acknowledged packets was
    ack-eliciting.[¶](#section-5.1-2.2){.pilcrow}]{#section-5.1-2.2}

The RTT sample, latest_rtt, is generated as the time elapsed since the
largest acknowledged packet was sent:[¶](#section-5.1-3){.pilcrow}

::: {#section-5.1-4}
``` {.sourcecode .lang-pseudocode}
latest_rtt = ack_time - send_time_of_largest_acked
```

[¶](#section-5.1-4){.pilcrow}
:::

An RTT sample is generated using only the largest acknowledged packet in
the received ACK frame. This is because a peer reports acknowledgment
delays for only the largest acknowledged packet in an ACK frame. While
the reported acknowledgment delay is not used by the RTT sample
measurement, it is used to adjust the RTT sample in subsequent
computations of smoothed_rtt and rttvar ([Section
5.3](#smoothed-rtt){.xref}).[¶](#section-5.1-5){.pilcrow}

To avoid generating multiple RTT samples for a single packet, an ACK
frame [SHOULD NOT]{.bcp14} be used to update RTT estimates if it does
not newly acknowledge the largest acknowledged
packet.[¶](#section-5.1-6){.pilcrow}

An RTT sample [MUST NOT]{.bcp14} be generated on receiving an ACK frame
that does not newly acknowledge at least one ack-eliciting packet. A
peer usually does not send an ACK frame when only non-ack-eliciting
packets are received. Therefore, an ACK frame that contains
acknowledgments for only non-ack-eliciting packets could include an
arbitrarily large ACK Delay value. Ignoring such ACK frames avoids
complications in subsequent smoothed_rtt and rttvar
computations.[¶](#section-5.1-7){.pilcrow}

A sender might generate multiple RTT samples per RTT when multiple ACK
frames are received within an RTT. As suggested in
\[[RFC6298](#RFC6298){.xref}\], doing so might result in inadequate
history in smoothed_rtt and rttvar. Ensuring that RTT estimates retain
sufficient history is an open research
question.[¶](#section-5.1-8){.pilcrow}
:::
:::

::: {#min-rtt}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Estimating min_rtt](#name-estimating-min_rtt){.section-name .selfRef} {#name-estimating-min_rtt}

min_rtt is the sender\'s estimate of the minimum RTT observed for a
given network path over a period of time. In this document, min_rtt is
used by loss detection to reject implausibly small RTT
samples.[¶](#section-5.2-1){.pilcrow}

min_rtt [MUST]{.bcp14} be set to the latest_rtt on the first RTT sample.
min_rtt [MUST]{.bcp14} be set to the lesser of min_rtt and latest_rtt
([Section 5.1](#latest-rtt){.xref}) on all other
samples.[¶](#section-5.2-2){.pilcrow}

An endpoint uses only locally observed times in computing the min_rtt
and does not adjust for acknowledgment delays reported by the peer.
Doing so allows the endpoint to set a lower bound for the smoothed_rtt
based entirely on what it observes (see [Section
5.3](#smoothed-rtt){.xref}) and limits potential underestimation due to
erroneously reported delays by the peer.[¶](#section-5.2-3){.pilcrow}

The RTT for a network path may change over time. If a path\'s actual RTT
decreases, the min_rtt will adapt immediately on the first low sample.
If the path\'s actual RTT increases, however, the min_rtt will not adapt
to it, allowing future RTT samples that are smaller than the new RTT to
be included in smoothed_rtt.[¶](#section-5.2-4){.pilcrow}

Endpoints [SHOULD]{.bcp14} set the min_rtt to the newest RTT sample
after persistent congestion is established. This avoids repeatedly
declaring persistent congestion when the RTT increases. This also allows
a connection to reset its estimate of min_rtt and smoothed_rtt after a
disruptive network event; see [Section
5.3](#smoothed-rtt){.xref}.[¶](#section-5.2-5){.pilcrow}

Endpoints [MAY]{.bcp14} reestablish the min_rtt at other times in the
connection, such as when traffic volume is low and an acknowledgment is
received with a low acknowledgment delay. Implementations [SHOULD
NOT]{.bcp14} refresh the min_rtt value too often since the actual
minimum RTT of the path is not frequently
observable.[¶](#section-5.2-6){.pilcrow}
:::
:::

::: {#smoothed-rtt}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Estimating smoothed_rtt and rttvar](#name-estimating-smoothed_rtt-and){.section-name .selfRef} {#name-estimating-smoothed_rtt-and}

smoothed_rtt is an exponentially weighted moving average of an
endpoint\'s RTT samples, and rttvar estimates the variation in the RTT
samples using a mean variation.[¶](#section-5.3-1){.pilcrow}

The calculation of smoothed_rtt uses RTT samples after adjusting them
for acknowledgment delays. These delays are decoded from the ACK Delay
field of ACK frames as described in [Section
19.3](https://www.rfc-editor.org/rfc/rfc9000#section-19.3){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-5.3-2){.pilcrow}

The peer might report acknowledgment delays that are larger than the
peer\'s max_ack_delay during the handshake ([Section
13.2.1](https://www.rfc-editor.org/rfc/rfc9000#section-13.2.1){.relref}
of \[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]). To account for this,
the endpoint [SHOULD]{.bcp14} ignore max_ack_delay until the handshake
is confirmed, as defined in [Section
4.1.2](https://www.rfc-editor.org/rfc/rfc9001#section-4.1.2){.relref} of
\[[QUIC-TLS](#QUIC-TLS){.xref}\]. When they occur, these large
acknowledgment delays are likely to be non-repeating and limited to the
handshake. The endpoint can therefore use them without limiting them to
the max_ack_delay, avoiding unnecessary inflation of the RTT
estimate.[¶](#section-5.3-3){.pilcrow}

Note that a large acknowledgment delay can result in a substantially
inflated smoothed_rtt if there is an error either in the peer\'s
reporting of the acknowledgment delay or in the endpoint\'s min_rtt
estimate. Therefore, prior to handshake confirmation, an endpoint
[MAY]{.bcp14} ignore RTT samples if adjusting the RTT sample for
acknowledgment delay causes the sample to be less than the
min_rtt.[¶](#section-5.3-4){.pilcrow}

After the handshake is confirmed, any acknowledgment delays reported by
the peer that are greater than the peer\'s max_ack_delay are attributed
to unintentional but potentially repeating delays, such as scheduler
latency at the peer or loss of previous acknowledgments. Excess delays
could also be due to a noncompliant receiver. Therefore, these extra
delays are considered effectively part of path delay and incorporated
into the RTT estimate.[¶](#section-5.3-5){.pilcrow}

Therefore, when adjusting an RTT sample using peer-reported
acknowledgment delays, an endpoint:[¶](#section-5.3-6){.pilcrow}

-   [[MAY]{.bcp14} ignore the acknowledgment delay for Initial packets,
    since these acknowledgments are not delayed by the peer ([Section
    13.2.1](https://www.rfc-editor.org/rfc/rfc9000#section-13.2.1){.relref}
    of
    \[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]);[¶](#section-5.3-7.1){.pilcrow}]{#section-5.3-7.1}
-   [[SHOULD]{.bcp14} ignore the peer\'s max_ack_delay until the
    handshake is
    confirmed;[¶](#section-5.3-7.2){.pilcrow}]{#section-5.3-7.2}
-   [[MUST]{.bcp14} use the lesser of the acknowledgment delay and the
    peer\'s max_ack_delay after the handshake is confirmed;
    and[¶](#section-5.3-7.3){.pilcrow}]{#section-5.3-7.3}
-   [[MUST NOT]{.bcp14} subtract the acknowledgment delay from the RTT
    sample if the resulting value is smaller than the min_rtt. This
    limits the underestimation of the smoothed_rtt due to a misreporting
    peer.[¶](#section-5.3-7.4){.pilcrow}]{#section-5.3-7.4}

Additionally, an endpoint might postpone the processing of
acknowledgments when the corresponding decryption keys are not
immediately available. For example, a client might receive an
acknowledgment for a 0-RTT packet that it cannot decrypt because 1-RTT
packet protection keys are not yet available to it. In such cases, an
endpoint [SHOULD]{.bcp14} subtract such local delays from its RTT sample
until the handshake is confirmed.[¶](#section-5.3-8){.pilcrow}

Similar to \[[RFC6298](#RFC6298){.xref}\], smoothed_rtt and rttvar are
computed as follows.[¶](#section-5.3-9){.pilcrow}

An endpoint initializes the RTT estimator during connection
establishment and when the estimator is reset during connection
migration; see [Section
9.4](https://www.rfc-editor.org/rfc/rfc9000#section-9.4){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]. Before any RTT samples are
available for a new path or when the estimator is reset, the estimator
is initialized using the initial RTT; see [Section
6.2.2](#pto-handshake){.xref}.[¶](#section-5.3-10){.pilcrow}

smoothed_rtt and rttvar are initialized as follows, where kInitialRtt
contains the initial RTT value:[¶](#section-5.3-11){.pilcrow}

::: {#section-5.3-12}
``` {.sourcecode .lang-pseudocode}
smoothed_rtt = kInitialRtt
rttvar = kInitialRtt / 2
```

[¶](#section-5.3-12){.pilcrow}
:::

RTT samples for the network path are recorded in latest_rtt; see
[Section 5.1](#latest-rtt){.xref}. On the first RTT sample after
initialization, the estimator is reset using that sample. This ensures
that the estimator retains no history of past samples. Packets sent on
other paths do not contribute RTT samples to the current path, as
described in [Section
9.4](https://www.rfc-editor.org/rfc/rfc9000#section-9.4){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-5.3-13){.pilcrow}

On the first RTT sample after initialization, smoothed_rtt and rttvar
are set as follows:[¶](#section-5.3-14){.pilcrow}

::: {#section-5.3-15}
``` {.sourcecode .lang-pseudocode}
smoothed_rtt = latest_rtt
rttvar = latest_rtt / 2
```

[¶](#section-5.3-15){.pilcrow}
:::

On subsequent RTT samples, smoothed_rtt and rttvar evolve as
follows:[¶](#section-5.3-16){.pilcrow}

::: {#section-5.3-17}
``` {.sourcecode .lang-pseudocode}
ack_delay = decoded acknowledgment delay from ACK frame
if (handshake confirmed):
  ack_delay = min(ack_delay, max_ack_delay)
adjusted_rtt = latest_rtt
if (latest_rtt >= min_rtt + ack_delay):
  adjusted_rtt = latest_rtt - ack_delay
smoothed_rtt = 7/8 * smoothed_rtt + 1/8 * adjusted_rtt
rttvar_sample = abs(smoothed_rtt - adjusted_rtt)
rttvar = 3/4 * rttvar + 1/4 * rttvar_sample
```

[¶](#section-5.3-17){.pilcrow}
:::
:::
:::
:::
:::

::: {#loss-detection}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Loss Detection](#name-loss-detection){.section-name .selfRef} {#name-loss-detection}

QUIC senders use acknowledgments to detect lost packets and a PTO to
ensure acknowledgments are received; see [Section 6.2](#pto){.xref}.
This section provides a description of these
algorithms.[¶](#section-6-1){.pilcrow}

If a packet is lost, the QUIC transport needs to recover from that loss,
such as by retransmitting the data, sending an updated frame, or
discarding the frame. For more information, see [Section
13.3](https://www.rfc-editor.org/rfc/rfc9000#section-13.3){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-6-2){.pilcrow}

Loss detection is separate per packet number space, unlike RTT
measurement and congestion control, because RTT and congestion control
are properties of the path, whereas loss detection also relies upon key
availability.[¶](#section-6-3){.pilcrow}

::: {#ack-loss-detection}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Acknowledgment-Based Detection](#name-acknowledgment-based-detect){.section-name .selfRef} {#name-acknowledgment-based-detect}

Acknowledgment-based loss detection implements the spirit of TCP\'s Fast
Retransmit \[[RFC5681](#RFC5681){.xref}\], Early Retransmit
\[[RFC5827](#RFC5827){.xref}\], Forward Acknowledgment
\[[FACK](#FACK){.xref}\], SACK loss recovery
\[[RFC6675](#RFC6675){.xref}\], and RACK-TLP
\[[RFC8985](#RFC8985){.xref}\]. This section provides an overview of how
these algorithms are implemented in QUIC.[¶](#section-6.1-1){.pilcrow}

A packet is declared lost if it meets all of the following
conditions:[¶](#section-6.1-2){.pilcrow}

-   [The packet is unacknowledged, in flight, and was sent prior to an
    acknowledged
    packet.[¶](#section-6.1-3.1){.pilcrow}]{#section-6.1-3.1}
-   [The packet was sent kPacketThreshold packets before an acknowledged
    packet ([Section 6.1.1](#packet-threshold){.xref}), or it was sent
    long enough in the past ([Section
    6.1.2](#time-threshold){.xref}).[¶](#section-6.1-3.2){.pilcrow}]{#section-6.1-3.2}

The acknowledgment indicates that a packet sent later was delivered, and
the packet and time thresholds provide some tolerance for packet
reordering.[¶](#section-6.1-4){.pilcrow}

Spuriously declaring packets as lost leads to unnecessary
retransmissions and may result in degraded performance due to the
actions of the congestion controller upon detecting loss.
Implementations can detect spurious retransmissions and increase the
packet or time reordering threshold to reduce future spurious
retransmissions and loss events. Implementations with adaptive time
thresholds [MAY]{.bcp14} choose to start with smaller initial reordering
thresholds to minimize recovery latency.[¶](#section-6.1-5){.pilcrow}

::: {#packet-threshold}
::: {#section-6.1.1 .section}
#### [6.1.1.](#section-6.1.1){.section-number .selfRef} [Packet Threshold](#name-packet-threshold){.section-name .selfRef} {#name-packet-threshold}

The [RECOMMENDED]{.bcp14} initial value for the packet reordering
threshold (kPacketThreshold) is 3, based on best practices for TCP loss
detection \[[RFC5681](#RFC5681){.xref}\] \[[RFC6675](#RFC6675){.xref}\].
In order to remain similar to TCP, implementations [SHOULD NOT]{.bcp14}
use a packet threshold less than 3; see
\[[RFC5681](#RFC5681){.xref}\].[¶](#section-6.1.1-1){.pilcrow}

Some networks may exhibit higher degrees of packet reordering, causing a
sender to detect spurious losses. Additionally, packet reordering could
be more common with QUIC than TCP because network elements that could
observe and reorder TCP packets cannot do that for QUIC and also because
QUIC packet numbers are encrypted. Algorithms that increase the
reordering threshold after spuriously detecting losses, such as RACK
\[[RFC8985](#RFC8985){.xref}\], have proven to be useful in TCP and are
expected to be at least as useful in
QUIC.[¶](#section-6.1.1-2){.pilcrow}
:::
:::

::: {#time-threshold}
::: {#section-6.1.2 .section}
#### [6.1.2.](#section-6.1.2){.section-number .selfRef} [Time Threshold](#name-time-threshold){.section-name .selfRef} {#name-time-threshold}

Once a later packet within the same packet number space has been
acknowledged, an endpoint [SHOULD]{.bcp14} declare an earlier packet
lost if it was sent a threshold amount of time in the past. To avoid
declaring packets as lost too early, this time threshold [MUST]{.bcp14}
be set to at least the local timer granularity, as indicated by the
kGranularity constant. The time threshold
is:[¶](#section-6.1.2-1){.pilcrow}

::: {#section-6.1.2-2}
``` {.sourcecode .lang-pseudocode}
max(kTimeThreshold * max(smoothed_rtt, latest_rtt), kGranularity)
```

[¶](#section-6.1.2-2){.pilcrow}
:::

If packets sent prior to the largest acknowledged packet cannot yet be
declared lost, then a timer [SHOULD]{.bcp14} be set for the remaining
time.[¶](#section-6.1.2-3){.pilcrow}

Using max(smoothed_rtt, latest_rtt) protects from the two following
cases:[¶](#section-6.1.2-4){.pilcrow}

-   [the latest RTT sample is lower than the smoothed RTT, perhaps due
    to reordering where the acknowledgment encountered a shorter
    path;[¶](#section-6.1.2-5.1){.pilcrow}]{#section-6.1.2-5.1}
-   [the latest RTT sample is higher than the smoothed RTT, perhaps due
    to a sustained increase in the actual RTT, but the smoothed RTT has
    not yet caught
    up.[¶](#section-6.1.2-5.2){.pilcrow}]{#section-6.1.2-5.2}

The [RECOMMENDED]{.bcp14} time threshold (kTimeThreshold), expressed as
an RTT multiplier, is 9/8. The [RECOMMENDED]{.bcp14} value of the timer
granularity (kGranularity) is 1
millisecond.[¶](#section-6.1.2-6){.pilcrow}

Note: TCP\'s RACK \[[RFC8985](#RFC8985){.xref}\] specifies a slightly
larger threshold, equivalent to 5/4, for a similar purpose. Experience
with QUIC shows that 9/8 works well.[¶](#section-6.1.2-7.1){.pilcrow}

Implementations [MAY]{.bcp14} experiment with absolute thresholds,
thresholds from previous connections, adaptive thresholds, or the
including of RTT variation. Smaller thresholds reduce reordering
resilience and increase spurious retransmissions, and larger thresholds
increase loss detection delay.[¶](#section-6.1.2-8){.pilcrow}
:::
:::
:::
:::

::: {#pto}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Probe Timeout](#name-probe-timeout){.section-name .selfRef} {#name-probe-timeout}

A Probe Timeout (PTO) triggers the sending of one or two probe datagrams
when ack-eliciting packets are not acknowledged within the expected
period of time or the server may not have validated the client\'s
address. A PTO enables a connection to recover from loss of tail packets
or acknowledgments.[¶](#section-6.2-1){.pilcrow}

As with loss detection, the PTO is per packet number space. That is, a
PTO value is computed per packet number
space.[¶](#section-6.2-2){.pilcrow}

A PTO timer expiration event does not indicate packet loss and [MUST
NOT]{.bcp14} cause prior unacknowledged packets to be marked as lost.
When an acknowledgment is received that newly acknowledges packets, loss
detection proceeds as dictated by the packet and time threshold
mechanisms; see [Section
6.1](#ack-loss-detection){.xref}.[¶](#section-6.2-3){.pilcrow}

The PTO algorithm used in QUIC implements the reliability functions of
Tail Loss Probe \[[RFC8985](#RFC8985){.xref}\], RTO
\[[RFC5681](#RFC5681){.xref}\], and F-RTO algorithms for TCP
\[[RFC5682](#RFC5682){.xref}\]. The timeout computation is based on
TCP\'s RTO period
\[[RFC6298](#RFC6298){.xref}\].[¶](#section-6.2-4){.pilcrow}

::: {#computing-pto}
::: {#section-6.2.1 .section}
#### [6.2.1.](#section-6.2.1){.section-number .selfRef} [Computing PTO](#name-computing-pto){.section-name .selfRef} {#name-computing-pto}

When an ack-eliciting packet is transmitted, the sender schedules a
timer for the PTO period as follows:[¶](#section-6.2.1-1){.pilcrow}

::: {#section-6.2.1-2}
``` {.sourcecode .lang-pseudocode}
PTO = smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay
```

[¶](#section-6.2.1-2){.pilcrow}
:::

The PTO period is the amount of time that a sender ought to wait for an
acknowledgment of a sent packet. This time period includes the estimated
network RTT (smoothed_rtt), the variation in the estimate (4\*rttvar),
and max_ack_delay, to account for the maximum time by which a receiver
might delay sending an acknowledgment.[¶](#section-6.2.1-3){.pilcrow}

When the PTO is armed for Initial or Handshake packet number spaces, the
max_ack_delay in the PTO period computation is set to 0, since the peer
is expected to not delay these packets intentionally; see [Section
13.2.1](https://www.rfc-editor.org/rfc/rfc9000#section-13.2.1){.relref}
of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-6.2.1-4){.pilcrow}

The PTO period [MUST]{.bcp14} be at least kGranularity to avoid the
timer expiring immediately.[¶](#section-6.2.1-5){.pilcrow}

When ack-eliciting packets in multiple packet number spaces are in
flight, the timer [MUST]{.bcp14} be set to the earlier value of the
Initial and Handshake packet number
spaces.[¶](#section-6.2.1-6){.pilcrow}

An endpoint [MUST NOT]{.bcp14} set its PTO timer for the Application
Data packet number space until the handshake is confirmed. Doing so
prevents the endpoint from retransmitting information in packets when
either the peer does not yet have the keys to process them or the
endpoint does not yet have the keys to process their acknowledgments.
For example, this can happen when a client sends 0-RTT packets to the
server; it does so without knowing whether the server will be able to
decrypt them. Similarly, this can happen when a server sends 1-RTT
packets before confirming that the client has verified the server\'s
certificate and can therefore read these 1-RTT
packets.[¶](#section-6.2.1-7){.pilcrow}

A sender [SHOULD]{.bcp14} restart its PTO timer every time an
ack-eliciting packet is sent or acknowledged, or when Initial or
Handshake keys are discarded ([Section
4.9](https://www.rfc-editor.org/rfc/rfc9001#section-4.9){.relref} of
\[[QUIC-TLS](#QUIC-TLS){.xref}\]). This ensures the PTO is always set
based on the latest estimate of the RTT and for the correct packet
across packet number spaces.[¶](#section-6.2.1-8){.pilcrow}

When a PTO timer expires, the PTO backoff [MUST]{.bcp14} be increased,
resulting in the PTO period being set to twice its current value. The
PTO backoff factor is reset when an acknowledgment is received, except
in the following case. A server might take longer to respond to packets
during the handshake than otherwise. To protect such a server from
repeated client probes, the PTO backoff is not reset at a client that is
not yet certain that the server has finished validating the client\'s
address. That is, a client does not reset the PTO backoff factor on
receiving acknowledgments in Initial
packets.[¶](#section-6.2.1-9){.pilcrow}

This exponential reduction in the sender\'s rate is important because
consecutive PTOs might be caused by loss of packets or acknowledgments
due to severe congestion. Even when there are ack-eliciting packets in
flight in multiple packet number spaces, the exponential increase in PTO
occurs across all spaces to prevent excess load on the network. For
example, a timeout in the Initial packet number space doubles the length
of the timeout in the Handshake packet number
space.[¶](#section-6.2.1-10){.pilcrow}

The total length of time over which consecutive PTOs expire is limited
by the idle timeout.[¶](#section-6.2.1-11){.pilcrow}

The PTO timer [MUST NOT]{.bcp14} be set if a timer is set for time
threshold loss detection; see [Section 6.1.2](#time-threshold){.xref}. A
timer that is set for time threshold loss detection will expire earlier
than the PTO timer in most cases and is less likely to spuriously
retransmit data.[¶](#section-6.2.1-12){.pilcrow}
:::
:::

::: {#pto-handshake}
::: {#section-6.2.2 .section}
#### [6.2.2.](#section-6.2.2){.section-number .selfRef} [Handshakes and New Paths](#name-handshakes-and-new-paths){.section-name .selfRef} {#name-handshakes-and-new-paths}

Resumed connections over the same network [MAY]{.bcp14} use the previous
connection\'s final smoothed RTT value as the resumed connection\'s
initial RTT. When no previous RTT is available, the initial RTT
[SHOULD]{.bcp14} be set to 333 milliseconds. This results in handshakes
starting with a PTO of 1 second, as recommended for TCP\'s initial RTO;
see [Section
2](https://www.rfc-editor.org/rfc/rfc6298#section-2){.relref} of
\[[RFC6298](#RFC6298){.xref}\].[¶](#section-6.2.2-1){.pilcrow}

A connection [MAY]{.bcp14} use the delay between sending a
PATH_CHALLENGE and receiving a PATH_RESPONSE to set the initial RTT (see
kInitialRtt in [Appendix A.2](#constants-of-interest){.xref}) for a new
path, but the delay [SHOULD NOT]{.bcp14} be considered an RTT
sample.[¶](#section-6.2.2-2){.pilcrow}

When the Initial keys and Handshake keys are discarded (see [Section
6.4](#discarding-packets){.xref}), any Initial packets and Handshake
packets can no longer be acknowledged, so they are removed from bytes in
flight. When Initial or Handshake keys are discarded, the PTO and loss
detection timers [MUST]{.bcp14} be reset, because discarding keys
indicates forward progress and the loss detection timer might have been
set for a now-discarded packet number
space.[¶](#section-6.2.2-3){.pilcrow}

::: {#before-address-validation}
::: {#section-6.2.2.1 .section}
##### [6.2.2.1.](#section-6.2.2.1){.section-number .selfRef} [Before Address Validation](#name-before-address-validation){.section-name .selfRef} {#name-before-address-validation}

Until the server has validated the client\'s address on the path, the
amount of data it can send is limited to three times the amount of data
received, as specified in [Section
8.1](https://www.rfc-editor.org/rfc/rfc9000#section-8.1){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]. If no additional data can
be sent, the server\'s PTO timer [MUST NOT]{.bcp14} be armed until
datagrams have been received from the client because packets sent on PTO
count against the anti-amplification
limit.[¶](#section-6.2.2.1-1){.pilcrow}

When the server receives a datagram from the client, the amplification
limit is increased and the server resets the PTO timer. If the PTO timer
is then set to a time in the past, it is executed immediately. Doing so
avoids sending new 1-RTT packets prior to packets critical to the
completion of the handshake. In particular, this can happen when 0-RTT
is accepted but the server fails to validate the client\'s
address.[¶](#section-6.2.2.1-2){.pilcrow}

Since the server could be blocked until more datagrams are received from
the client, it is the client\'s responsibility to send packets to
unblock the server until it is certain that the server has finished its
address validation (see [Section
8](https://www.rfc-editor.org/rfc/rfc9000#section-8){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]). That is, the client
[MUST]{.bcp14} set the PTO timer if the client has not received an
acknowledgment for any of its Handshake packets and the handshake is not
confirmed (see [Section
4.1.2](https://www.rfc-editor.org/rfc/rfc9001#section-4.1.2){.relref} of
\[[QUIC-TLS](#QUIC-TLS){.xref}\]), even if there are no packets in
flight. When the PTO fires, the client [MUST]{.bcp14} send a Handshake
packet if it has Handshake keys, otherwise it [MUST]{.bcp14} send an
Initial packet in a UDP datagram with a payload of at least 1200
bytes.[¶](#section-6.2.2.1-3){.pilcrow}
:::
:::
:::
:::

::: {#speeding-up-handshake-completion}
::: {#section-6.2.3 .section}
#### [6.2.3.](#section-6.2.3){.section-number .selfRef} [Speeding up Handshake Completion](#name-speeding-up-handshake-compl){.section-name .selfRef} {#name-speeding-up-handshake-compl}

When a server receives an Initial packet containing duplicate CRYPTO
data, it can assume the client did not receive all of the server\'s
CRYPTO data sent in Initial packets, or the client\'s estimated RTT is
too small. When a client receives Handshake or 1-RTT packets prior to
obtaining Handshake keys, it may assume some or all of the server\'s
Initial packets were lost.[¶](#section-6.2.3-1){.pilcrow}

To speed up handshake completion under these conditions, an endpoint
[MAY]{.bcp14}, for a limited number of times per connection, send a
packet containing unacknowledged CRYPTO data earlier than the PTO
expiry, subject to the address validation limits in [Section
8.1](https://www.rfc-editor.org/rfc/rfc9000#section-8.1){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]. Doing so at most once for
each connection is adequate to quickly recover from a single packet
loss. An endpoint that always retransmits packets in response to
receiving packets that it cannot process risks creating an infinite
exchange of packets.[¶](#section-6.2.3-2){.pilcrow}

Endpoints can also use coalesced packets (see [Section
12.2](https://www.rfc-editor.org/rfc/rfc9000#section-12.2){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]) to ensure that each
datagram elicits at least one acknowledgment. For example, a client can
coalesce an Initial packet containing PING and PADDING frames with a
0-RTT data packet, and a server can coalesce an Initial packet
containing a PING frame with one or more packets in its first
flight.[¶](#section-6.2.3-3){.pilcrow}
:::
:::

::: {#sending-probe-packets}
::: {#section-6.2.4 .section}
#### [6.2.4.](#section-6.2.4){.section-number .selfRef} [Sending Probe Packets](#name-sending-probe-packets){.section-name .selfRef} {#name-sending-probe-packets}

When a PTO timer expires, a sender [MUST]{.bcp14} send at least one
ack-eliciting packet in the packet number space as a probe. An endpoint
[MAY]{.bcp14} send up to two full-sized datagrams containing
ack-eliciting packets to avoid an expensive consecutive PTO expiration
due to a single lost datagram or to transmit data from multiple packet
number spaces. All probe packets sent on a PTO [MUST]{.bcp14} be
ack-eliciting.[¶](#section-6.2.4-1){.pilcrow}

In addition to sending data in the packet number space for which the
timer expired, the sender [SHOULD]{.bcp14} send ack-eliciting packets
from other packet number spaces with in-flight data, coalescing packets
if possible. This is particularly valuable when the server has both
Initial and Handshake data in flight or when the client has both
Handshake and Application Data in flight because the peer might only
have receive keys for one of the two packet number
spaces.[¶](#section-6.2.4-2){.pilcrow}

If the sender wants to elicit a faster acknowledgment on PTO, it can
skip a packet number to eliminate the acknowledgment
delay.[¶](#section-6.2.4-3){.pilcrow}

An endpoint [SHOULD]{.bcp14} include new data in packets that are sent
on PTO expiration. Previously sent data [MAY]{.bcp14} be sent if no new
data can be sent. Implementations [MAY]{.bcp14} use alternative
strategies for determining the content of probe packets, including
sending new or retransmitted data based on the application\'s
priorities.[¶](#section-6.2.4-4){.pilcrow}

It is possible the sender has no new or previously sent data to send. As
an example, consider the following sequence of events: new application
data is sent in a STREAM frame, deemed lost, then retransmitted in a new
packet, and then the original transmission is acknowledged. When there
is no data to send, the sender [SHOULD]{.bcp14} send a PING or other
ack-eliciting frame in a single packet, rearming the PTO
timer.[¶](#section-6.2.4-5){.pilcrow}

Alternatively, instead of sending an ack-eliciting packet, the sender
[MAY]{.bcp14} mark any packets still in flight as lost. Doing so avoids
sending an additional packet but increases the risk that loss is
declared too aggressively, resulting in an unnecessary rate reduction by
the congestion controller.[¶](#section-6.2.4-6){.pilcrow}

Consecutive PTO periods increase exponentially, and as a result,
connection recovery latency increases exponentially as packets continue
to be dropped in the network. Sending two packets on PTO expiration
increases resilience to packet drops, thus reducing the probability of
consecutive PTO events.[¶](#section-6.2.4-7){.pilcrow}

When the PTO timer expires multiple times and new data cannot be sent,
implementations must choose between sending the same payload every time
or sending different payloads. Sending the same payload may be simpler
and ensures the highest priority frames arrive first. Sending different
payloads each time reduces the chances of spurious
retransmission.[¶](#section-6.2.4-8){.pilcrow}
:::
:::
:::
:::

::: {#handling-retry-packets}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Handling Retry Packets](#name-handling-retry-packets){.section-name .selfRef} {#name-handling-retry-packets}

A Retry packet causes a client to send another Initial packet,
effectively restarting the connection process. A Retry packet indicates
that the Initial packet was received but not processed. A Retry packet
cannot be treated as an acknowledgment because it does not indicate that
a packet was processed or specify the packet
number.[¶](#section-6.3-1){.pilcrow}

Clients that receive a Retry packet reset congestion control and loss
recovery state, including resetting any pending timers. Other connection
state, in particular cryptographic handshake messages, is retained; see
[Section
17.2.5](https://www.rfc-editor.org/rfc/rfc9000#section-17.2.5){.relref}
of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-6.3-2){.pilcrow}

The client [MAY]{.bcp14} compute an RTT estimate to the server as the
time period from when the first Initial packet was sent to when a Retry
or a Version Negotiation packet is received. The client [MAY]{.bcp14}
use this value in place of its default for the initial RTT
estimate.[¶](#section-6.3-3){.pilcrow}
:::
:::

::: {#discarding-packets}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [Discarding Keys and Packet State](#name-discarding-keys-and-packet-){.section-name .selfRef} {#name-discarding-keys-and-packet-}

When Initial and Handshake packet protection keys are discarded (see
[Section
4.9](https://www.rfc-editor.org/rfc/rfc9001#section-4.9){.relref} of
\[[QUIC-TLS](#QUIC-TLS){.xref}\]), all packets that were sent with those
keys can no longer be acknowledged because their acknowledgments cannot
be processed. The sender [MUST]{.bcp14} discard all recovery state
associated with those packets and [MUST]{.bcp14} remove them from the
count of bytes in flight.[¶](#section-6.4-1){.pilcrow}

Endpoints stop sending and receiving Initial packets once they start
exchanging Handshake packets; see [Section
17.2.2.1](https://www.rfc-editor.org/rfc/rfc9000#section-17.2.2.1){.relref}
of \[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]. At this point, recovery
state for all in-flight Initial packets is
discarded.[¶](#section-6.4-2){.pilcrow}

When 0-RTT is rejected, recovery state for all in-flight 0-RTT packets
is discarded.[¶](#section-6.4-3){.pilcrow}

If a server accepts 0-RTT, but does not buffer 0-RTT packets that arrive
before Initial packets, early 0-RTT packets will be declared lost, but
that is expected to be infrequent.[¶](#section-6.4-4){.pilcrow}

It is expected that keys are discarded at some time after the packets
encrypted with them are either acknowledged or declared lost. However,
Initial and Handshake secrets are discarded as soon as Handshake and
1-RTT keys are proven to be available to both client and server; see
[Section
4.9.1](https://www.rfc-editor.org/rfc/rfc9001#section-4.9.1){.relref} of
\[[QUIC-TLS](#QUIC-TLS){.xref}\].[¶](#section-6.4-5){.pilcrow}
:::
:::
:::
:::

::: {#congestion-control}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Congestion Control](#name-congestion-control){.section-name .selfRef} {#name-congestion-control}

This document specifies a sender-side congestion controller for QUIC
similar to TCP NewReno
\[[RFC6582](#RFC6582){.xref}\].[¶](#section-7-1){.pilcrow}

The signals QUIC provides for congestion control are generic and are
designed to support different sender-side algorithms. A sender can
unilaterally choose a different algorithm to use, such as CUBIC
\[[RFC8312](#RFC8312){.xref}\].[¶](#section-7-2){.pilcrow}

If a sender uses a different controller than that specified in this
document, the chosen controller [MUST]{.bcp14} conform to the congestion
control guidelines specified in [Section
3.1](https://www.rfc-editor.org/rfc/rfc8085#section-3.1){.relref} of
\[[RFC8085](#RFC8085){.xref}\].[¶](#section-7-3){.pilcrow}

Similar to TCP, packets containing only ACK frames do not count toward
bytes in flight and are not congestion controlled. Unlike TCP, QUIC can
detect the loss of these packets and [MAY]{.bcp14} use that information
to adjust the congestion controller or the rate of ACK-only packets
being sent, but this document does not describe a mechanism for doing
so.[¶](#section-7-4){.pilcrow}

The congestion controller is per path, so packets sent on other paths do
not alter the current path\'s congestion controller, as described in
[Section
9.4](https://www.rfc-editor.org/rfc/rfc9000#section-9.4){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-7-5){.pilcrow}

The algorithm in this document specifies and uses the controller\'s
congestion window in bytes.[¶](#section-7-6){.pilcrow}

An endpoint [MUST NOT]{.bcp14} send a packet if it would cause
bytes_in_flight (see [Appendix B.2](#vars-of-interest){.xref}) to be
larger than the congestion window, unless the packet is sent on a PTO
timer expiration (see [Section 6.2](#pto){.xref}) or when entering
recovery (see [Section
7.3.2](#recovery-period){.xref}).[¶](#section-7-7){.pilcrow}

::: {#congestion-ecn}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Explicit Congestion Notification](#name-explicit-congestion-notific){.section-name .selfRef} {#name-explicit-congestion-notific}

If a path has been validated to support Explicit Congestion Notification
(ECN) \[[RFC3168](#RFC3168){.xref}\] \[[RFC8311](#RFC8311){.xref}\],
QUIC treats a Congestion Experienced (CE) codepoint in the IP header as
a signal of congestion. This document specifies an endpoint\'s response
when the peer-reported ECN-CE count increases; see [Section
13.4.2](https://www.rfc-editor.org/rfc/rfc9000#section-13.4.2){.relref}
of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-7.1-1){.pilcrow}
:::
:::

::: {#initial-cwnd}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Initial and Minimum Congestion Window](#name-initial-and-minimum-congest){.section-name .selfRef} {#name-initial-and-minimum-congest}

QUIC begins every connection in slow start with the congestion window
set to an initial value. Endpoints [SHOULD]{.bcp14} use an initial
congestion window of ten times the maximum datagram size
(max_datagram_size), while limiting the window to the larger of 14,720
bytes or twice the maximum datagram size. This follows the analysis and
recommendations in \[[RFC6928](#RFC6928){.xref}\], increasing the byte
limit to account for the smaller 8-byte overhead of UDP compared to the
20-byte overhead for TCP.[¶](#section-7.2-1){.pilcrow}

If the maximum datagram size changes during the connection, the initial
congestion window [SHOULD]{.bcp14} be recalculated with the new size. If
the maximum datagram size is decreased in order to complete the
handshake, the congestion window [SHOULD]{.bcp14} be set to the new
initial congestion window.[¶](#section-7.2-2){.pilcrow}

Prior to validating the client\'s address, the server can be further
limited by the anti-amplification limit as specified in [Section
8.1](https://www.rfc-editor.org/rfc/rfc9000#section-8.1){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]. Though the
anti-amplification limit can prevent the congestion window from being
fully utilized and therefore slow down the increase in congestion
window, it does not directly affect the congestion
window.[¶](#section-7.2-3){.pilcrow}

The minimum congestion window is the smallest value the congestion
window can attain in response to loss, an increase in the peer-reported
ECN-CE count, or persistent congestion. The [RECOMMENDED]{.bcp14} value
is 2 \* max_datagram_size.[¶](#section-7.2-4){.pilcrow}
:::
:::

::: {#congestion-control-states}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Congestion Control States](#name-congestion-control-states){.section-name .selfRef} {#name-congestion-control-states}

The NewReno congestion controller described in this document has three
distinct states, as shown in [Figure
1](#fig-cc-fsm){.xref}.[¶](#section-7.3-1){.pilcrow}

[]{#name-congestion-control-states-a}

::: {#fig-cc-fsm}
::: {#section-7.3-2.1 .artwork .art-text .alignLeft}
                     New path or      +------------+
                persistent congestion |   Slow     |
            (O)---------------------->|   Start    |
                                      +------------+
                                            |
                                    Loss or |
                            ECN-CE increase |
                                            v
     +------------+     Loss or       +------------+
     | Congestion |  ECN-CE increase  |  Recovery  |
     | Avoidance  |------------------>|   Period   |
     +------------+                   +------------+
               ^                            |
               |                            |
               +----------------------------+
                  Acknowledgment of packet
                    sent during recovery
:::

[Figure 1](#figure-1){.selfRef}: [Congestion Control States and
Transitions](#name-congestion-control-states-a){.selfRef}
:::

These states and the transitions between them are described in
subsequent sections.[¶](#section-7.3-3){.pilcrow}

::: {#slow-start}
::: {#section-7.3.1 .section}
#### [7.3.1.](#section-7.3.1){.section-number .selfRef} [Slow Start](#name-slow-start){.section-name .selfRef} {#name-slow-start}

A NewReno sender is in slow start any time the congestion window is
below the slow start threshold. A sender begins in slow start because
the slow start threshold is initialized to an infinite
value.[¶](#section-7.3.1-1){.pilcrow}

While a sender is in slow start, the congestion window increases by the
number of bytes acknowledged when each acknowledgment is processed. This
results in exponential growth of the congestion
window.[¶](#section-7.3.1-2){.pilcrow}

The sender [MUST]{.bcp14} exit slow start and enter a recovery period
when a packet is lost or when the ECN-CE count reported by its peer
increases.[¶](#section-7.3.1-3){.pilcrow}

A sender reenters slow start any time the congestion window is less than
the slow start threshold, which only occurs after persistent congestion
is declared.[¶](#section-7.3.1-4){.pilcrow}
:::
:::

::: {#recovery-period}
::: {#section-7.3.2 .section}
#### [7.3.2.](#section-7.3.2){.section-number .selfRef} [Recovery](#name-recovery){.section-name .selfRef} {#name-recovery}

A NewReno sender enters a recovery period when it detects the loss of a
packet or when the ECN-CE count reported by its peer increases. A sender
that is already in a recovery period stays in it and does not reenter
it.[¶](#section-7.3.2-1){.pilcrow}

On entering a recovery period, a sender [MUST]{.bcp14} set the slow
start threshold to half the value of the congestion window when loss is
detected. The congestion window [MUST]{.bcp14} be set to the reduced
value of the slow start threshold before exiting the recovery
period.[¶](#section-7.3.2-2){.pilcrow}

Implementations [MAY]{.bcp14} reduce the congestion window immediately
upon entering a recovery period or use other mechanisms, such as
Proportional Rate Reduction \[[PRR](#PRR){.xref}\], to reduce the
congestion window more gradually. If the congestion window is reduced
immediately, a single packet can be sent prior to reduction. This speeds
up loss recovery if the data in the lost packet is retransmitted and is
similar to TCP as described in [Section
5](https://www.rfc-editor.org/rfc/rfc6675#section-5){.relref} of
\[[RFC6675](#RFC6675){.xref}\].[¶](#section-7.3.2-3){.pilcrow}

The recovery period aims to limit congestion window reduction to once
per round trip. Therefore, during a recovery period, the congestion
window does not change in response to new losses or increases in the
ECN-CE count.[¶](#section-7.3.2-4){.pilcrow}

A recovery period ends and the sender enters congestion avoidance when a
packet sent during the recovery period is acknowledged. This is slightly
different from TCP\'s definition of recovery, which ends when the lost
segment that started recovery is acknowledged
\[[RFC5681](#RFC5681){.xref}\].[¶](#section-7.3.2-5){.pilcrow}
:::
:::

::: {#congestion-avoidance}
::: {#section-7.3.3 .section}
#### [7.3.3.](#section-7.3.3){.section-number .selfRef} [Congestion Avoidance](#name-congestion-avoidance){.section-name .selfRef} {#name-congestion-avoidance}

A NewReno sender is in congestion avoidance any time the congestion
window is at or above the slow start threshold and not in a recovery
period.[¶](#section-7.3.3-1){.pilcrow}

A sender in congestion avoidance uses an Additive Increase
Multiplicative Decrease (AIMD) approach that [MUST]{.bcp14} limit the
increase to the congestion window to at most one maximum datagram size
for each congestion window that is
acknowledged.[¶](#section-7.3.3-2){.pilcrow}

The sender exits congestion avoidance and enters a recovery period when
a packet is lost or when the ECN-CE count reported by its peer
increases.[¶](#section-7.3.3-3){.pilcrow}
:::
:::
:::
:::

::: {#ignoring-loss-of-undecryptable-packets}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [Ignoring Loss of Undecryptable Packets](#name-ignoring-loss-of-undecrypta){.section-name .selfRef} {#name-ignoring-loss-of-undecrypta}

During the handshake, some packet protection keys might not be available
when a packet arrives, and the receiver can choose to drop the packet.
In particular, Handshake and 0-RTT packets cannot be processed until the
Initial packets arrive, and 1-RTT packets cannot be processed until the
handshake completes. Endpoints [MAY]{.bcp14} ignore the loss of
Handshake, 0-RTT, and 1-RTT packets that might have arrived before the
peer had packet protection keys to process those packets. Endpoints
[MUST NOT]{.bcp14} ignore the loss of packets that were sent after the
earliest acknowledged packet in a given packet number
space.[¶](#section-7.4-1){.pilcrow}
:::
:::

::: {#probe-timeout}
::: {#section-7.5 .section}
### [7.5.](#section-7.5){.section-number .selfRef} [Probe Timeout](#name-probe-timeout-2){.section-name .selfRef} {#name-probe-timeout-2}

Probe packets [MUST NOT]{.bcp14} be blocked by the congestion
controller. A sender [MUST]{.bcp14} however count these packets as being
additionally in flight, since these packets add network load without
establishing packet loss. Note that sending probe packets might cause
the sender\'s bytes in flight to exceed the congestion window until an
acknowledgment is received that establishes loss or delivery of
packets.[¶](#section-7.5-1){.pilcrow}
:::
:::

::: {#persistent-congestion}
::: {#section-7.6 .section}
### [7.6.](#section-7.6){.section-number .selfRef} [Persistent Congestion](#name-persistent-congestion){.section-name .selfRef} {#name-persistent-congestion}

When a sender establishes loss of all packets sent over a long enough
duration, the network is considered to be experiencing persistent
congestion.[¶](#section-7.6-1){.pilcrow}

::: {#pc-duration}
::: {#section-7.6.1 .section}
#### [7.6.1.](#section-7.6.1){.section-number .selfRef} [Duration](#name-duration){.section-name .selfRef} {#name-duration}

The persistent congestion duration is computed as
follows:[¶](#section-7.6.1-1){.pilcrow}

::: {#section-7.6.1-2}
``` {.sourcecode .lang-pseudocode}
(smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay) *
    kPersistentCongestionThreshold
```

[¶](#section-7.6.1-2){.pilcrow}
:::

Unlike the PTO computation in [Section 6.2](#pto){.xref}, this duration
includes the max_ack_delay irrespective of the packet number spaces in
which losses are established.[¶](#section-7.6.1-3){.pilcrow}

This duration allows a sender to send as many packets before
establishing persistent congestion, including some in response to PTO
expiration, as TCP does with Tail Loss Probes
\[[RFC8985](#RFC8985){.xref}\] and an RTO
\[[RFC5681](#RFC5681){.xref}\].[¶](#section-7.6.1-4){.pilcrow}

Larger values of kPersistentCongestionThreshold cause the sender to
become less responsive to persistent congestion in the network, which
can result in aggressive sending into a congested network. Too small a
value can result in a sender declaring persistent congestion
unnecessarily, resulting in reduced throughput for the
sender.[¶](#section-7.6.1-5){.pilcrow}

The [RECOMMENDED]{.bcp14} value for kPersistentCongestionThreshold is 3,
which results in behavior that is approximately equivalent to a TCP
sender declaring an RTO after two TLPs.[¶](#section-7.6.1-6){.pilcrow}

This design does not use consecutive PTO events to establish persistent
congestion, since application patterns impact PTO expiration. For
example, a sender that sends small amounts of data with silence periods
between them restarts the PTO timer every time it sends, potentially
preventing the PTO timer from expiring for a long period of time, even
when no acknowledgments are being received. The use of a duration
enables a sender to establish persistent congestion without depending on
PTO expiration.[¶](#section-7.6.1-7){.pilcrow}
:::
:::

::: {#establishing-persistent-congestion}
::: {#section-7.6.2 .section}
#### [7.6.2.](#section-7.6.2){.section-number .selfRef} [Establishing Persistent Congestion](#name-establishing-persistent-con){.section-name .selfRef} {#name-establishing-persistent-con}

A sender establishes persistent congestion after the receipt of an
acknowledgment if two packets that are ack-eliciting are declared lost,
and:[¶](#section-7.6.2-1){.pilcrow}

-   [across all packet number spaces, none of the packets sent between
    the send times of these two packets are
    acknowledged;[¶](#section-7.6.2-2.1){.pilcrow}]{#section-7.6.2-2.1}
-   [the duration between the send times of these two packets exceeds
    the persistent congestion duration ([Section
    7.6.1](#pc-duration){.xref});
    and[¶](#section-7.6.2-2.2){.pilcrow}]{#section-7.6.2-2.2}
-   [a prior RTT sample existed when these two packets were
    sent.[¶](#section-7.6.2-2.3){.pilcrow}]{#section-7.6.2-2.3}

These two packets [MUST]{.bcp14} be ack-eliciting, since a receiver is
required to acknowledge only ack-eliciting packets within its maximum
acknowledgment delay; see [Section
13.2](https://www.rfc-editor.org/rfc/rfc9000#section-13.2){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-7.6.2-3){.pilcrow}

The persistent congestion period [SHOULD NOT]{.bcp14} start until there
is at least one RTT sample. Before the first RTT sample, a sender arms
its PTO timer based on the initial RTT ([Section
6.2.2](#pto-handshake){.xref}), which could be substantially larger than
the actual RTT. Requiring a prior RTT sample prevents a sender from
establishing persistent congestion with potentially too few
probes.[¶](#section-7.6.2-4){.pilcrow}

Since network congestion is not affected by packet number spaces,
persistent congestion [SHOULD]{.bcp14} consider packets sent across
packet number spaces. A sender that does not have state for all packet
number spaces or an implementation that cannot compare send times across
packet number spaces [MAY]{.bcp14} use state for just the packet number
space that was acknowledged. This might result in erroneously declaring
persistent congestion, but it will not lead to a failure to detect
persistent congestion.[¶](#section-7.6.2-5){.pilcrow}

When persistent congestion is declared, the sender\'s congestion window
[MUST]{.bcp14} be reduced to the minimum congestion window
(kMinimumWindow), similar to a TCP sender\'s response on an RTO
\[[RFC5681](#RFC5681){.xref}\].[¶](#section-7.6.2-6){.pilcrow}
:::
:::

::: {#example}
::: {#section-7.6.3 .section}
#### [7.6.3.](#section-7.6.3){.section-number .selfRef} [Example](#name-example){.section-name .selfRef} {#name-example}

The following example illustrates how a sender might establish
persistent congestion. Assume:[¶](#section-7.6.3-1){.pilcrow}

::: {#section-7.6.3-2}
``` {.sourcecode .lang-pseudocode}
smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay = 2
kPersistentCongestionThreshold = 3
```

[¶](#section-7.6.3-2){.pilcrow}
:::

Consider the following sequence of
events:[¶](#section-7.6.3-3){.pilcrow}

  Time     Action
  -------- -----------------------------------
  t=0      Send packet #1 (application data)
  t=1      Send packet #2 (application data)
  t=1.2    Receive acknowledgment of #1
  t=2      Send packet #3 (application data)
  t=3      Send packet #4 (application data)
  t=4      Send packet #5 (application data)
  t=5      Send packet #6 (application data)
  t=6      Send packet #7 (application data)
  t=8      Send packet #8 (PTO 1)
  t=12     Send packet #9 (PTO 2)
  t=12.2   Receive acknowledgment of #9

  : [Table 1](#table-1){.selfRef}

Packets 2 through 8 are declared lost when the acknowledgment for packet
9 is received at `t = 12.2`.[¶](#section-7.6.3-5){.pilcrow}

The congestion period is calculated as the time between the oldest and
newest lost packets: `8 - 1 = 7`. The persistent congestion duration is
`2 * 3 = 6`. Because the threshold was reached and because none of the
packets between the oldest and the newest lost packets were
acknowledged, the network is considered to have experienced persistent
congestion.[¶](#section-7.6.3-6){.pilcrow}

While this example shows PTO expiration, they are not required for
persistent congestion to be established.[¶](#section-7.6.3-7){.pilcrow}
:::
:::
:::
:::

::: {#pacing}
::: {#section-7.7 .section}
### [7.7.](#section-7.7){.section-number .selfRef} [Pacing](#name-pacing){.section-name .selfRef} {#name-pacing}

A sender [SHOULD]{.bcp14} pace sending of all in-flight packets based on
input from the congestion controller.[¶](#section-7.7-1){.pilcrow}

Sending multiple packets into the network without any delay between them
creates a packet burst that might cause short-term congestion and
losses. Senders [MUST]{.bcp14} either use pacing or limit such bursts.
Senders [SHOULD]{.bcp14} limit bursts to the initial congestion window;
see [Section 7.2](#initial-cwnd){.xref}. A sender with knowledge that
the network path to the receiver can absorb larger bursts [MAY]{.bcp14}
use a higher limit.[¶](#section-7.7-2){.pilcrow}

An implementation should take care to architect its congestion
controller to work well with a pacer. For instance, a pacer might wrap
the congestion controller and control the availability of the congestion
window, or a pacer might pace out packets handed to it by the congestion
controller.[¶](#section-7.7-3){.pilcrow}

Timely delivery of ACK frames is important for efficient loss recovery.
To avoid delaying their delivery to the peer, packets containing only
ACK frames [SHOULD]{.bcp14} therefore not be
paced.[¶](#section-7.7-4){.pilcrow}

Endpoints can implement pacing as they choose. A perfectly paced sender
spreads packets exactly evenly over time. For a window-based congestion
controller, such as the one in this document, that rate can be computed
by averaging the congestion window over the RTT. Expressed as a rate in
units of bytes per time, where congestion_window is in
bytes:[¶](#section-7.7-5){.pilcrow}

::: {#section-7.7-6}
``` {.sourcecode .lang-pseudocode}
rate = N * congestion_window / smoothed_rtt
```

[¶](#section-7.7-6){.pilcrow}
:::

Or expressed as an inter-packet interval in units of
time:[¶](#section-7.7-7){.pilcrow}

::: {#section-7.7-8}
``` {.sourcecode .lang-pseudocode}
interval = ( smoothed_rtt * packet_size / congestion_window ) / N
```

[¶](#section-7.7-8){.pilcrow}
:::

Using a value for `N` that is small, but at least 1 (for example, 1.25)
ensures that variations in RTT do not result in underutilization of the
congestion window.[¶](#section-7.7-9){.pilcrow}

Practical considerations, such as packetization, scheduling delays, and
computational efficiency, can cause a sender to deviate from this rate
over time periods that are much shorter than an
RTT.[¶](#section-7.7-10){.pilcrow}

One possible implementation strategy for pacing uses a leaky bucket
algorithm, where the capacity of the \"bucket\" is limited to the
maximum burst size and the rate the \"bucket\" fills is determined by
the above function.[¶](#section-7.7-11){.pilcrow}
:::
:::

::: {#underutilizing-the-congestion-window}
::: {#section-7.8 .section}
### [7.8.](#section-7.8){.section-number .selfRef} [Underutilizing the Congestion Window](#name-underutilizing-the-congesti){.section-name .selfRef} {#name-underutilizing-the-congesti}

When bytes in flight is smaller than the congestion window and sending
is not pacing limited, the congestion window is underutilized. This can
happen due to insufficient application data or flow control limits. When
this occurs, the congestion window [SHOULD NOT]{.bcp14} be increased in
either slow start or congestion avoidance.[¶](#section-7.8-1){.pilcrow}

A sender that paces packets (see [Section 7.7](#pacing){.xref}) might
delay sending packets and not fully utilize the congestion window due to
this delay. A sender [SHOULD NOT]{.bcp14} consider itself application
limited if it would have fully utilized the congestion window without
pacing delay.[¶](#section-7.8-2){.pilcrow}

A sender [MAY]{.bcp14} implement alternative mechanisms to update its
congestion window after periods of underutilization, such as those
proposed for TCP in
\[[RFC7661](#RFC7661){.xref}\].[¶](#section-7.8-3){.pilcrow}
:::
:::
:::
:::

::: {#security-considerations}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

::: {#loss-and-congestion-signals}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Loss and Congestion Signals](#name-loss-and-congestion-signals){.section-name .selfRef} {#name-loss-and-congestion-signals}

Loss detection and congestion control fundamentally involve the
consumption of signals, such as delay, loss, and ECN markings, from
unauthenticated entities. An attacker can cause endpoints to reduce
their sending rate by manipulating these signals: by dropping packets,
by altering path delay strategically, or by changing ECN
codepoints.[¶](#section-8.1-1){.pilcrow}
:::
:::

::: {#traffic-analysis}
::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Traffic Analysis](#name-traffic-analysis){.section-name .selfRef} {#name-traffic-analysis}

Packets that carry only ACK frames can be heuristically identified by
observing packet size. Acknowledgment patterns may expose information
about link characteristics or application behavior. To reduce leaked
information, endpoints can bundle acknowledgments with other frames, or
they can use PADDING frames at a potential cost to
performance.[¶](#section-8.2-1){.pilcrow}
:::
:::

::: {#misreporting-ecn-markings}
::: {#section-8.3 .section}
### [8.3.](#section-8.3){.section-number .selfRef} [Misreporting ECN Markings](#name-misreporting-ecn-markings){.section-name .selfRef} {#name-misreporting-ecn-markings}

A receiver can misreport ECN markings to alter the congestion response
of a sender. Suppressing reports of ECN-CE markings could cause a sender
to increase their send rate. This increase could result in congestion
and loss.[¶](#section-8.3-1){.pilcrow}

A sender can detect suppression of reports by marking occasional packets
that it sends with an ECN-CE marking. If a packet sent with an ECN-CE
marking is not reported as having been CE marked when the packet is
acknowledged, then the sender can disable ECN for that path by not
setting ECN-Capable Transport (ECT) codepoints in subsequent packets
sent on that path
\[[RFC3168](#RFC3168){.xref}\].[¶](#section-8.3-2){.pilcrow}

Reporting additional ECN-CE markings will cause a sender to reduce their
sending rate, which is similar in effect to advertising reduced
connection flow control limits and so no advantage is gained by doing
so.[¶](#section-8.3-3){.pilcrow}

Endpoints choose the congestion controller that they use. Congestion
controllers respond to reports of ECN-CE by reducing their rate, but the
response may vary. Markings can be treated as equivalent to loss
\[[RFC3168](#RFC3168){.xref}\], but other responses can be specified,
such as \[[RFC8511](#RFC8511){.xref}\] or
\[[RFC8311](#RFC8311){.xref}\].[¶](#section-8.3-4){.pilcrow}
:::
:::
:::
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[QUIC-TLS\]
:   [Thomson, M., Ed.]{.refAuthor} and [S. Turner, Ed.]{.refAuthor},
    [\"Using TLS to Secure QUIC\"]{.refTitle}, [RFC 9001]{.seriesInfo},
    [DOI 10.17487/RFC9001]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc9001>\>.
:   

\[QUIC-TRANSPORT\]
:   [Iyengar, J., Ed.]{.refAuthor} and [M. Thomson, Ed.]{.refAuthor},
    [\"QUIC: A UDP-Based Multiplexed and Secure Transport\"]{.refTitle},
    [RFC 9000]{.seriesInfo}, [DOI 10.17487/RFC9000]{.seriesInfo}, May
    2021, \<<https://www.rfc-editor.org/info/rfc9000>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC3168\]
:   [Ramakrishnan, K.]{.refAuthor}, [Floyd, S.]{.refAuthor}, and [D.
    Black]{.refAuthor}, [\"The Addition of Explicit Congestion
    Notification (ECN) to IP\"]{.refTitle}, [RFC 3168]{.seriesInfo},
    [DOI 10.17487/RFC3168]{.seriesInfo}, September 2001,
    \<<https://www.rfc-editor.org/info/rfc3168>\>.
:   

\[RFC8085\]
:   [Eggert, L.]{.refAuthor}, [Fairhurst, G.]{.refAuthor}, and [G.
    Shepherd]{.refAuthor}, [\"UDP Usage Guidelines\"]{.refTitle}, [BCP
    145]{.seriesInfo}, [RFC 8085]{.seriesInfo}, [DOI
    10.17487/RFC8085]{.seriesInfo}, March 2017,
    \<<https://www.rfc-editor.org/info/rfc8085>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   
:::

::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[FACK\]
:   [Mathis, M.]{.refAuthor} and [J. Mahdavi]{.refAuthor}, [\"Forward
    acknowledgement: Refining TCP Congestion Control\"]{.refTitle}, [ACM
    SIGCOMM Computer Communication Review]{.refContent}, [DOI
    10.1145/248157.248181]{.seriesInfo}, August 1996,
    \<<https://doi.org/10.1145/248157.248181>\>.
:   

\[PRR\]
:   [Mathis, M.]{.refAuthor}, [Dukkipati, N.]{.refAuthor}, and [Y.
    Cheng]{.refAuthor}, [\"Proportional Rate Reduction for
    TCP\"]{.refTitle}, [RFC 6937]{.seriesInfo}, [DOI
    10.17487/RFC6937]{.seriesInfo}, May 2013,
    \<<https://www.rfc-editor.org/info/rfc6937>\>.
:   

\[RETRANSMISSION\]
:   [Karn, P.]{.refAuthor} and [C. Partridge]{.refAuthor}, [\"Improving
    Round-Trip Time Estimates in Reliable Transport
    Protocols\"]{.refTitle}, [ACM Transactions on Computer
    Systems]{.refContent}, [DOI 10.1145/118544.118549]{.seriesInfo},
    November 1991, \<<https://doi.org/10.1145/118544.118549>\>.
:   

\[RFC2018\]
:   [Mathis, M.]{.refAuthor}, [Mahdavi, J.]{.refAuthor},
    [Floyd, S.]{.refAuthor}, and [A. Romanow]{.refAuthor}, [\"TCP
    Selective Acknowledgment Options\"]{.refTitle}, [RFC
    2018]{.seriesInfo}, [DOI 10.17487/RFC2018]{.seriesInfo}, October
    1996, \<<https://www.rfc-editor.org/info/rfc2018>\>.
:   

\[RFC3465\]
:   [Allman, M.]{.refAuthor}, [\"TCP Congestion Control with Appropriate
    Byte Counting (ABC)\"]{.refTitle}, [RFC 3465]{.seriesInfo}, [DOI
    10.17487/RFC3465]{.seriesInfo}, February 2003,
    \<<https://www.rfc-editor.org/info/rfc3465>\>.
:   

\[RFC5681\]
:   [Allman, M.]{.refAuthor}, [Paxson, V.]{.refAuthor}, and [E.
    Blanton]{.refAuthor}, [\"TCP Congestion Control\"]{.refTitle}, [RFC
    5681]{.seriesInfo}, [DOI 10.17487/RFC5681]{.seriesInfo}, September
    2009, \<<https://www.rfc-editor.org/info/rfc5681>\>.
:   

\[RFC5682\]
:   [Sarolahti, P.]{.refAuthor}, [Kojo, M.]{.refAuthor},
    [Yamamoto, K.]{.refAuthor}, and [M. Hata]{.refAuthor}, [\"Forward
    RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious
    Retransmission Timeouts with TCP\"]{.refTitle}, [RFC
    5682]{.seriesInfo}, [DOI 10.17487/RFC5682]{.seriesInfo}, September
    2009, \<<https://www.rfc-editor.org/info/rfc5682>\>.
:   

\[RFC5827\]
:   [Allman, M.]{.refAuthor}, [Avrachenkov, K.]{.refAuthor},
    [Ayesta, U.]{.refAuthor}, [Blanton, J.]{.refAuthor}, and [P.
    Hurtig]{.refAuthor}, [\"Early Retransmit for TCP and Stream Control
    Transmission Protocol (SCTP)\"]{.refTitle}, [RFC 5827]{.seriesInfo},
    [DOI 10.17487/RFC5827]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5827>\>.
:   

\[RFC6298\]
:   [Paxson, V.]{.refAuthor}, [Allman, M.]{.refAuthor},
    [Chu, J.]{.refAuthor}, and [M. Sargent]{.refAuthor}, [\"Computing
    TCP\'s Retransmission Timer\"]{.refTitle}, [RFC 6298]{.seriesInfo},
    [DOI 10.17487/RFC6298]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6298>\>.
:   

\[RFC6582\]
:   [Henderson, T.]{.refAuthor}, [Floyd, S.]{.refAuthor},
    [Gurtov, A.]{.refAuthor}, and [Y. Nishida]{.refAuthor}, [\"The
    NewReno Modification to TCP\'s Fast Recovery
    Algorithm\"]{.refTitle}, [RFC 6582]{.seriesInfo}, [DOI
    10.17487/RFC6582]{.seriesInfo}, April 2012,
    \<<https://www.rfc-editor.org/info/rfc6582>\>.
:   

\[RFC6675\]
:   [Blanton, E.]{.refAuthor}, [Allman, M.]{.refAuthor},
    [Wang, L.]{.refAuthor}, [Jarvinen, I.]{.refAuthor},
    [Kojo, M.]{.refAuthor}, and [Y. Nishida]{.refAuthor}, [\"A
    Conservative Loss Recovery Algorithm Based on Selective
    Acknowledgment (SACK) for TCP\"]{.refTitle}, [RFC
    6675]{.seriesInfo}, [DOI 10.17487/RFC6675]{.seriesInfo}, August
    2012, \<<https://www.rfc-editor.org/info/rfc6675>\>.
:   

\[RFC6928\]
:   [Chu, J.]{.refAuthor}, [Dukkipati, N.]{.refAuthor},
    [Cheng, Y.]{.refAuthor}, and [M. Mathis]{.refAuthor}, [\"Increasing
    TCP\'s Initial Window\"]{.refTitle}, [RFC 6928]{.seriesInfo}, [DOI
    10.17487/RFC6928]{.seriesInfo}, April 2013,
    \<<https://www.rfc-editor.org/info/rfc6928>\>.
:   

\[RFC7661\]
:   [Fairhurst, G.]{.refAuthor}, [Sathiaseelan, A.]{.refAuthor}, and [R.
    Secchi]{.refAuthor}, [\"Updating TCP to Support Rate-Limited
    Traffic\"]{.refTitle}, [RFC 7661]{.seriesInfo}, [DOI
    10.17487/RFC7661]{.seriesInfo}, October 2015,
    \<<https://www.rfc-editor.org/info/rfc7661>\>.
:   

\[RFC8311\]
:   [Black, D.]{.refAuthor}, [\"Relaxing Restrictions on Explicit
    Congestion Notification (ECN) Experimentation\"]{.refTitle}, [RFC
    8311]{.seriesInfo}, [DOI 10.17487/RFC8311]{.seriesInfo}, January
    2018, \<<https://www.rfc-editor.org/info/rfc8311>\>.
:   

\[RFC8312\]
:   [Rhee, I.]{.refAuthor}, [Xu, L.]{.refAuthor}, [Ha, S.]{.refAuthor},
    [Zimmermann, A.]{.refAuthor}, [Eggert, L.]{.refAuthor}, and [R.
    Scheffenegger]{.refAuthor}, [\"CUBIC for Fast Long-Distance
    Networks\"]{.refTitle}, [RFC 8312]{.seriesInfo}, [DOI
    10.17487/RFC8312]{.seriesInfo}, February 2018,
    \<<https://www.rfc-editor.org/info/rfc8312>\>.
:   

\[RFC8511\]
:   [Khademi, N.]{.refAuthor}, [Welzl, M.]{.refAuthor},
    [Armitage, G.]{.refAuthor}, and [G. Fairhurst]{.refAuthor}, [\"TCP
    Alternative Backoff with ECN (ABE)\"]{.refTitle}, [RFC
    8511]{.seriesInfo}, [DOI 10.17487/RFC8511]{.seriesInfo}, December
    2018, \<<https://www.rfc-editor.org/info/rfc8511>\>.
:   

\[RFC8985\]
:   [Cheng, Y.]{.refAuthor}, [Cardwell, N.]{.refAuthor},
    [Dukkipati, N.]{.refAuthor}, and [P. Jha]{.refAuthor}, [\"The
    RACK-TLP Loss Detection Algorithm for TCP\"]{.refTitle}, [RFC
    8985]{.seriesInfo}, [DOI 10.17487/RFC8985]{.seriesInfo}, February
    2021, \<<https://www.rfc-editor.org/info/rfc8985>\>.
:   
:::
:::

::: {#loss-recovery-pseudocode}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Loss Recovery Pseudocode](#name-loss-recovery-pseudocode){.section-name .selfRef} {#name-loss-recovery-pseudocode}

We now describe an example implementation of the loss detection
mechanisms described in [Section
6](#loss-detection){.xref}.[¶](#section-appendix.a-1){.pilcrow}

The pseudocode segments in this section are licensed as Code Components;
see the copyright notice.[¶](#section-appendix.a-2){.pilcrow}

::: {#tracking-sent-packets}
::: {#section-a.1 .section}
## [A.1.](#section-a.1){.section-number .selfRef} [Tracking Sent Packets](#name-tracking-sent-packets){.section-name .selfRef} {#name-tracking-sent-packets}

To correctly implement congestion control, a QUIC sender tracks every
ack-eliciting packet until the packet is acknowledged or lost. It is
expected that implementations will be able to access this information by
packet number and crypto context and store the per-packet fields
([Appendix A.1.1](#sent-packets-fields){.xref}) for loss recovery and
congestion control.[¶](#section-a.1-1){.pilcrow}

After a packet is declared lost, the endpoint can still maintain state
for it for an amount of time to allow for packet reordering; see
[Section
13.3](https://www.rfc-editor.org/rfc/rfc9000#section-13.3){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]. This enables a sender to
detect spurious retransmissions.[¶](#section-a.1-2){.pilcrow}

Sent packets are tracked for each packet number space, and ACK
processing only applies to a single space.[¶](#section-a.1-3){.pilcrow}

::: {#sent-packets-fields}
::: {#section-a.1.1 .section}
### [A.1.1.](#section-a.1.1){.section-number .selfRef} [Sent Packet Fields](#name-sent-packet-fields){.section-name .selfRef} {#name-sent-packet-fields}

[]{.break}

packet_number:

:   The packet number of the sent
    packet.[¶](#section-a.1.1-1.2.1){.pilcrow}

:   

ack_eliciting:

:   A Boolean that indicates whether a packet is ack-eliciting. If true,
    it is expected that an acknowledgment will be received, though the
    peer could delay sending the ACK frame containing it by up to the
    max_ack_delay.[¶](#section-a.1.1-1.4.1){.pilcrow}

:   

in_flight:

:   A Boolean that indicates whether the packet counts toward bytes in
    flight.[¶](#section-a.1.1-1.6.1){.pilcrow}

:   

sent_bytes:

:   The number of bytes sent in the packet, not including UDP or IP
    overhead, but including QUIC framing
    overhead.[¶](#section-a.1.1-1.8.1){.pilcrow}

:   

time_sent:

:   The time the packet was sent.[¶](#section-a.1.1-1.10.1){.pilcrow}

:   
:::
:::
:::
:::

::: {#constants-of-interest}
::: {#section-a.2 .section}
## [A.2.](#section-a.2){.section-number .selfRef} [Constants of Interest](#name-constants-of-interest){.section-name .selfRef} {#name-constants-of-interest}

Constants used in loss recovery are based on a combination of RFCs,
papers, and common practice.[¶](#section-a.2-1){.pilcrow}

[]{.break}

kPacketThreshold:

:   Maximum reordering in packets before packet threshold loss detection
    considers a packet lost. The value recommended in [Section
    6.1.1](#packet-threshold){.xref} is
    3.[¶](#section-a.2-2.2.1){.pilcrow}

:   

kTimeThreshold:

:   Maximum reordering in time before time threshold loss detection
    considers a packet lost. Specified as an RTT multiplier. The value
    recommended in [Section 6.1.2](#time-threshold){.xref} is
    9/8.[¶](#section-a.2-2.4.1){.pilcrow}

:   

kGranularity:

:   Timer granularity. This is a system-dependent value, and [Section
    6.1.2](#time-threshold){.xref} recommends a value of 1
    ms.[¶](#section-a.2-2.6.1){.pilcrow}

:   

kInitialRtt:

:   The RTT used before an RTT sample is taken. The value recommended in
    [Section 6.2.2](#pto-handshake){.xref} is 333
    ms.[¶](#section-a.2-2.8.1){.pilcrow}

:   

kPacketNumberSpace:

:   An enum to enumerate the three packet number
    spaces:[¶](#section-a.2-2.10.1){.pilcrow}

:   

::: {#section-a.2-3 .artwork .art-text .alignLeft}
    enum kPacketNumberSpace {
      Initial,
      Handshake,
      ApplicationData,
    }

[¶](#section-a.2-3){.pilcrow}
:::
:::
:::

::: {#ld-vars-of-interest}
::: {#section-a.3 .section}
## [A.3.](#section-a.3){.section-number .selfRef} [Variables of Interest](#name-variables-of-interest){.section-name .selfRef} {#name-variables-of-interest}

Variables required to implement the congestion control mechanisms are
described in this section.[¶](#section-a.3-1){.pilcrow}

[]{.break}

latest_rtt:

:   The most recent RTT measurement made when receiving an
    acknowledgment for a previously unacknowledged
    packet.[¶](#section-a.3-2.2.1){.pilcrow}

:   

smoothed_rtt:

:   The smoothed RTT of the connection, computed as described in
    [Section
    5.3](#smoothed-rtt){.xref}.[¶](#section-a.3-2.4.1){.pilcrow}

:   

rttvar:

:   The RTT variation, computed as described in [Section
    5.3](#smoothed-rtt){.xref}.[¶](#section-a.3-2.6.1){.pilcrow}

:   

min_rtt:

:   The minimum RTT seen over a period of time, ignoring acknowledgment
    delay, as described in [Section
    5.2](#min-rtt){.xref}.[¶](#section-a.3-2.8.1){.pilcrow}

:   

first_rtt_sample:

:   The time that the first RTT sample was
    obtained.[¶](#section-a.3-2.10.1){.pilcrow}

:   

max_ack_delay:

:   The maximum amount of time by which the receiver intends to delay
    acknowledgments for packets in the Application Data packet number
    space, as defined by the eponymous transport parameter ([Section
    18.2](https://www.rfc-editor.org/rfc/rfc9000#section-18.2){.relref}
    of \[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]). Note that the
    actual ack_delay in a received ACK frame may be larger due to late
    timers, reordering, or loss.[¶](#section-a.3-2.12.1){.pilcrow}

:   

loss_detection_timer:

:   Multi-modal timer used for loss
    detection.[¶](#section-a.3-2.14.1){.pilcrow}

:   

pto_count:

:   The number of times a PTO has been sent without receiving an
    acknowledgment.[¶](#section-a.3-2.16.1){.pilcrow}

:   

time_of_last_ack_eliciting_packet\[kPacketNumberSpace\]:

:   The time the most recent ack-eliciting packet was
    sent.[¶](#section-a.3-2.18.1){.pilcrow}

:   

largest_acked_packet\[kPacketNumberSpace\]:

:   The largest packet number acknowledged in the packet number space so
    far.[¶](#section-a.3-2.20.1){.pilcrow}

:   

loss_time\[kPacketNumberSpace\]:

:   The time at which the next packet in that packet number space can be
    considered lost based on exceeding the reordering window in
    time.[¶](#section-a.3-2.22.1){.pilcrow}

:   

sent_packets\[kPacketNumberSpace\]:

:   An association of packet numbers in a packet number space to
    information about them. Described in detail above in [Appendix
    A.1](#tracking-sent-packets){.xref}.[¶](#section-a.3-2.24.1){.pilcrow}

:   
:::
:::

::: {#initialization}
::: {#section-a.4 .section}
## [A.4.](#section-a.4){.section-number .selfRef} [Initialization](#name-initialization){.section-name .selfRef} {#name-initialization}

At the beginning of the connection, initialize the loss detection
variables as follows:[¶](#section-a.4-1){.pilcrow}

::: {#section-a.4-2}
``` {.sourcecode .lang-pseudocode}
loss_detection_timer.reset()
pto_count = 0
latest_rtt = 0
smoothed_rtt = kInitialRtt
rttvar = kInitialRtt / 2
min_rtt = 0
first_rtt_sample = 0
for pn_space in [ Initial, Handshake, ApplicationData ]:
  largest_acked_packet[pn_space] = infinite
  time_of_last_ack_eliciting_packet[pn_space] = 0
  loss_time[pn_space] = 0
```

[¶](#section-a.4-2){.pilcrow}
:::
:::
:::

::: {#on-sending-a-packet}
::: {#section-a.5 .section}
## [A.5.](#section-a.5){.section-number .selfRef} [On Sending a Packet](#name-on-sending-a-packet){.section-name .selfRef} {#name-on-sending-a-packet}

After a packet is sent, information about the packet is stored. The
parameters to OnPacketSent are described in detail above in [Appendix
A.1.1](#sent-packets-fields){.xref}.[¶](#section-a.5-1){.pilcrow}

Pseudocode for OnPacketSent follows:[¶](#section-a.5-2){.pilcrow}

::: {#section-a.5-3}
``` {.sourcecode .lang-pseudocode}
OnPacketSent(packet_number, pn_space, ack_eliciting,
             in_flight, sent_bytes):
  sent_packets[pn_space][packet_number].packet_number =
                                           packet_number
  sent_packets[pn_space][packet_number].time_sent = now()
  sent_packets[pn_space][packet_number].ack_eliciting =
                                           ack_eliciting
  sent_packets[pn_space][packet_number].in_flight = in_flight
  sent_packets[pn_space][packet_number].sent_bytes = sent_bytes
  if (in_flight):
    if (ack_eliciting):
      time_of_last_ack_eliciting_packet[pn_space] = now()
    OnPacketSentCC(sent_bytes)
    SetLossDetectionTimer()
```

[¶](#section-a.5-3){.pilcrow}
:::
:::
:::

::: {#on-receiving-a-datagram}
::: {#section-a.6 .section}
## [A.6.](#section-a.6){.section-number .selfRef} [On Receiving a Datagram](#name-on-receiving-a-datagram){.section-name .selfRef} {#name-on-receiving-a-datagram}

When a server is blocked by anti-amplification limits, receiving a
datagram unblocks it, even if none of the packets in the datagram are
successfully processed. In such a case, the PTO timer will need to be
rearmed.[¶](#section-a.6-1){.pilcrow}

Pseudocode for OnDatagramReceived follows:[¶](#section-a.6-2){.pilcrow}

::: {#section-a.6-3}
``` {.sourcecode .lang-pseudocode}
OnDatagramReceived(datagram):
  // If this datagram unblocks the server, arm the
  // PTO timer to avoid deadlock.
  if (server was at anti-amplification limit):
    SetLossDetectionTimer()
    if loss_detection_timer.timeout < now():
      // Execute PTO if it would have expired
      // while the amplification limit applied.
      OnLossDetectionTimeout()
```

[¶](#section-a.6-3){.pilcrow}
:::
:::
:::

::: {#on-receiving-an-acknowledgment}
::: {#section-a.7 .section}
## [A.7.](#section-a.7){.section-number .selfRef} [On Receiving an Acknowledgment](#name-on-receiving-an-acknowledgm){.section-name .selfRef} {#name-on-receiving-an-acknowledgm}

When an ACK frame is received, it may newly acknowledge any number of
packets.[¶](#section-a.7-1){.pilcrow}

Pseudocode for OnAckReceived and UpdateRtt
follow:[¶](#section-a.7-2){.pilcrow}

::: {#section-a.7-3}
``` {.sourcecode .lang-pseudocode}
IncludesAckEliciting(packets):
  for packet in packets:
    if (packet.ack_eliciting):
      return true
  return false

OnAckReceived(ack, pn_space):
  if (largest_acked_packet[pn_space] == infinite):
    largest_acked_packet[pn_space] = ack.largest_acked
  else:
    largest_acked_packet[pn_space] =
        max(largest_acked_packet[pn_space], ack.largest_acked)

  // DetectAndRemoveAckedPackets finds packets that are newly
  // acknowledged and removes them from sent_packets.
  newly_acked_packets =
      DetectAndRemoveAckedPackets(ack, pn_space)
  // Nothing to do if there are no newly acked packets.
  if (newly_acked_packets.empty()):
    return

  // Update the RTT if the largest acknowledged is newly acked
  // and at least one ack-eliciting was newly acked.
  if (newly_acked_packets.largest().packet_number ==
          ack.largest_acked &&
      IncludesAckEliciting(newly_acked_packets)):
    latest_rtt =
      now() - newly_acked_packets.largest().time_sent
    UpdateRtt(ack.ack_delay)

  // Process ECN information if present.
  if (ACK frame contains ECN information):
      ProcessECN(ack, pn_space)

  lost_packets = DetectAndRemoveLostPackets(pn_space)
  if (!lost_packets.empty()):
    OnPacketsLost(lost_packets)
  OnPacketsAcked(newly_acked_packets)

  // Reset pto_count unless the client is unsure if
  // the server has validated the client's address.
  if (PeerCompletedAddressValidation()):
    pto_count = 0
  SetLossDetectionTimer()


UpdateRtt(ack_delay):
  if (first_rtt_sample == 0):
    min_rtt = latest_rtt
    smoothed_rtt = latest_rtt
    rttvar = latest_rtt / 2
    first_rtt_sample = now()
    return

  // min_rtt ignores acknowledgment delay.
  min_rtt = min(min_rtt, latest_rtt)
  // Limit ack_delay by max_ack_delay after handshake
  // confirmation.
  if (handshake confirmed):
    ack_delay = min(ack_delay, max_ack_delay)

  // Adjust for acknowledgment delay if plausible.
  adjusted_rtt = latest_rtt
  if (latest_rtt >= min_rtt + ack_delay):
    adjusted_rtt = latest_rtt - ack_delay

  rttvar = 3/4 * rttvar + 1/4 * abs(smoothed_rtt - adjusted_rtt)
  smoothed_rtt = 7/8 * smoothed_rtt + 1/8 * adjusted_rtt
```

[¶](#section-a.7-3){.pilcrow}
:::
:::
:::

::: {#setting-the-loss-detection-timer}
::: {#section-a.8 .section}
## [A.8.](#section-a.8){.section-number .selfRef} [Setting the Loss Detection Timer](#name-setting-the-loss-detection-){.section-name .selfRef} {#name-setting-the-loss-detection-}

QUIC loss detection uses a single timer for all timeout loss detection.
The duration of the timer is based on the timer\'s mode, which is set in
the packet and timer events further below. The function
SetLossDetectionTimer defined below shows how the single timer is
set.[¶](#section-a.8-1){.pilcrow}

This algorithm may result in the timer being set in the past,
particularly if timers wake up late. Timers set in the past fire
immediately.[¶](#section-a.8-2){.pilcrow}

Pseudocode for SetLossDetectionTimer follows (where the \"\^\" operator
represents exponentiation):[¶](#section-a.8-3){.pilcrow}

::: {#section-a.8-4}
``` {.sourcecode .lang-pseudocode}
GetLossTimeAndSpace():
  time = loss_time[Initial]
  space = Initial
  for pn_space in [ Handshake, ApplicationData ]:
    if (time == 0 || loss_time[pn_space] < time):
      time = loss_time[pn_space];
      space = pn_space
  return time, space

GetPtoTimeAndSpace():
  duration = (smoothed_rtt + max(4 * rttvar, kGranularity))
      * (2 ^ pto_count)
  // Anti-deadlock PTO starts from the current time
  if (no ack-eliciting packets in flight):
    assert(!PeerCompletedAddressValidation())
    if (has handshake keys):
      return (now() + duration), Handshake
    else:
      return (now() + duration), Initial
  pto_timeout = infinite
  pto_space = Initial
  for space in [ Initial, Handshake, ApplicationData ]:
    if (no ack-eliciting packets in flight in space):
        continue;
    if (space == ApplicationData):
      // Skip Application Data until handshake confirmed.
      if (handshake is not confirmed):
        return pto_timeout, pto_space
      // Include max_ack_delay and backoff for Application Data.
      duration += max_ack_delay * (2 ^ pto_count)

    t = time_of_last_ack_eliciting_packet[space] + duration
    if (t < pto_timeout):
      pto_timeout = t
      pto_space = space
  return pto_timeout, pto_space

PeerCompletedAddressValidation():
  // Assume clients validate the server's address implicitly.
  if (endpoint is server):
    return true
  // Servers complete address validation when a
  // protected packet is received.
  return has received Handshake ACK ||
       handshake confirmed

SetLossDetectionTimer():
  earliest_loss_time, _ = GetLossTimeAndSpace()
  if (earliest_loss_time != 0):
    // Time threshold loss detection.
    loss_detection_timer.update(earliest_loss_time)
    return

  if (server is at anti-amplification limit):
    // The server's timer is not set if nothing can be sent.
    loss_detection_timer.cancel()
    return

  if (no ack-eliciting packets in flight &&
      PeerCompletedAddressValidation()):
    // There is nothing to detect lost, so no timer is set.
    // However, the client needs to arm the timer if the
    // server might be blocked by the anti-amplification limit.
    loss_detection_timer.cancel()
    return

  timeout, _ = GetPtoTimeAndSpace()
  loss_detection_timer.update(timeout)
```

[¶](#section-a.8-4){.pilcrow}
:::
:::
:::

::: {#on-timeout}
::: {#section-a.9 .section}
## [A.9.](#section-a.9){.section-number .selfRef} [On Timeout](#name-on-timeout){.section-name .selfRef} {#name-on-timeout}

When the loss detection timer expires, the timer\'s mode determines the
action to be performed.[¶](#section-a.9-1){.pilcrow}

Pseudocode for OnLossDetectionTimeout
follows:[¶](#section-a.9-2){.pilcrow}

::: {#section-a.9-3}
``` {.sourcecode .lang-pseudocode}
OnLossDetectionTimeout():
  earliest_loss_time, pn_space = GetLossTimeAndSpace()
  if (earliest_loss_time != 0):
    // Time threshold loss Detection
    lost_packets = DetectAndRemoveLostPackets(pn_space)
    assert(!lost_packets.empty())
    OnPacketsLost(lost_packets)
    SetLossDetectionTimer()
    return

  if (no ack-eliciting packets in flight):
    assert(!PeerCompletedAddressValidation())
    // Client sends an anti-deadlock packet: Initial is padded
    // to earn more anti-amplification credit,
    // a Handshake packet proves address ownership.
    if (has Handshake keys):
      SendOneAckElicitingHandshakePacket()
    else:
      SendOneAckElicitingPaddedInitialPacket()
  else:
    // PTO. Send new data if available, else retransmit old data.
    // If neither is available, send a single PING frame.
    _, pn_space = GetPtoTimeAndSpace()
    SendOneOrTwoAckElicitingPackets(pn_space)

  pto_count++
  SetLossDetectionTimer()
```

[¶](#section-a.9-3){.pilcrow}
:::
:::
:::

::: {#detecting-lost-packets}
::: {#section-a.10 .section}
## [A.10.](#section-a.10){.section-number .selfRef} [Detecting Lost Packets](#name-detecting-lost-packets){.section-name .selfRef} {#name-detecting-lost-packets}

DetectAndRemoveLostPackets is called every time an ACK is received or
the time threshold loss detection timer expires. This function operates
on the sent_packets for that packet number space and returns a list of
packets newly detected as lost.[¶](#section-a.10-1){.pilcrow}

Pseudocode for DetectAndRemoveLostPackets
follows:[¶](#section-a.10-2){.pilcrow}

::: {#section-a.10-3}
``` {.sourcecode .lang-pseudocode}
DetectAndRemoveLostPackets(pn_space):
  assert(largest_acked_packet[pn_space] != infinite)
  loss_time[pn_space] = 0
  lost_packets = []
  loss_delay = kTimeThreshold * max(latest_rtt, smoothed_rtt)

  // Minimum time of kGranularity before packets are deemed lost.
  loss_delay = max(loss_delay, kGranularity)

  // Packets sent before this time are deemed lost.
  lost_send_time = now() - loss_delay

  foreach unacked in sent_packets[pn_space]:
    if (unacked.packet_number > largest_acked_packet[pn_space]):
      continue

    // Mark packet as lost, or set time when it should be marked.
    // Note: The use of kPacketThreshold here assumes that there
    // were no sender-induced gaps in the packet number space.
    if (unacked.time_sent <= lost_send_time ||
        largest_acked_packet[pn_space] >=
          unacked.packet_number + kPacketThreshold):
      sent_packets[pn_space].remove(unacked.packet_number)
      lost_packets.insert(unacked)
    else:
      if (loss_time[pn_space] == 0):
        loss_time[pn_space] = unacked.time_sent + loss_delay
      else:
        loss_time[pn_space] = min(loss_time[pn_space],
                                  unacked.time_sent + loss_delay)
  return lost_packets
```

[¶](#section-a.10-3){.pilcrow}
:::
:::
:::

::: {#upon-dropping-initial-or-handshake-keys}
::: {#section-a.11 .section}
## [A.11.](#section-a.11){.section-number .selfRef} [Upon Dropping Initial or Handshake Keys](#name-upon-dropping-initial-or-ha){.section-name .selfRef} {#name-upon-dropping-initial-or-ha}

When Initial or Handshake keys are discarded, packets from the space are
discarded and loss detection state is
updated.[¶](#section-a.11-1){.pilcrow}

Pseudocode for OnPacketNumberSpaceDiscarded
follows:[¶](#section-a.11-2){.pilcrow}

::: {#section-a.11-3}
``` {.sourcecode .lang-pseudocode}
OnPacketNumberSpaceDiscarded(pn_space):
  assert(pn_space != ApplicationData)
  RemoveFromBytesInFlight(sent_packets[pn_space])
  sent_packets[pn_space].clear()
  // Reset the loss detection and PTO timer
  time_of_last_ack_eliciting_packet[pn_space] = 0
  loss_time[pn_space] = 0
  pto_count = 0
  SetLossDetectionTimer()
```

[¶](#section-a.11-3){.pilcrow}
:::
:::
:::
:::
:::

::: {#congestion-control-pseudocode}
::: {#section-appendix.b .section}
## [Appendix B.](#section-appendix.b){.section-number .selfRef} [Congestion Control Pseudocode](#name-congestion-control-pseudoco){.section-name .selfRef} {#name-congestion-control-pseudoco}

We now describe an example implementation of the congestion controller
described in [Section
7](#congestion-control){.xref}.[¶](#section-appendix.b-1){.pilcrow}

The pseudocode segments in this section are licensed as Code Components;
see the copyright notice.[¶](#section-appendix.b-2){.pilcrow}

::: {#cc-consts-of-interest}
::: {#section-b.1 .section}
## [B.1.](#section-b.1){.section-number .selfRef} [Constants of Interest](#name-constants-of-interest-2){.section-name .selfRef} {#name-constants-of-interest-2}

Constants used in congestion control are based on a combination of RFCs,
papers, and common practice.[¶](#section-b.1-1){.pilcrow}

[]{.break}

kInitialWindow:

:   Default limit on the initial bytes in flight as described in
    [Section
    7.2](#initial-cwnd){.xref}.[¶](#section-b.1-2.2.1){.pilcrow}

:   

kMinimumWindow:

:   Minimum congestion window in bytes as described in [Section
    7.2](#initial-cwnd){.xref}.[¶](#section-b.1-2.4.1){.pilcrow}

:   

kLossReductionFactor:

:   Scaling factor applied to reduce the congestion window when a new
    loss event is detected. [Section 7](#congestion-control){.xref}
    recommends a value of 0.5.[¶](#section-b.1-2.6.1){.pilcrow}

:   

kPersistentCongestionThreshold:

:   Period of time for persistent congestion to be established,
    specified as a PTO multiplier. [Section
    7.6](#persistent-congestion){.xref} recommends a value of
    3.[¶](#section-b.1-2.8.1){.pilcrow}

:   
:::
:::

::: {#vars-of-interest}
::: {#section-b.2 .section}
## [B.2.](#section-b.2){.section-number .selfRef} [Variables of Interest](#name-variables-of-interest-2){.section-name .selfRef} {#name-variables-of-interest-2}

Variables required to implement the congestion control mechanisms are
described in this section.[¶](#section-b.2-1){.pilcrow}

[]{.break}

max_datagram_size:

:   The sender\'s current maximum payload size. This does not include
    UDP or IP overhead. The max datagram size is used for congestion
    window computations. An endpoint sets the value of this variable
    based on its Path Maximum Transmission Unit (PMTU; see [Section
    14.2](https://www.rfc-editor.org/rfc/rfc9000#section-14.2){.relref}
    of \[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]), with a minimum
    value of 1200 bytes.[¶](#section-b.2-2.2.1){.pilcrow}

:   

ecn_ce_counters\[kPacketNumberSpace\]:

:   The highest value reported for the ECN-CE counter in the packet
    number space by the peer in an ACK frame. This value is used to
    detect increases in the reported ECN-CE
    counter.[¶](#section-b.2-2.4.1){.pilcrow}

:   

bytes_in_flight:

:   The sum of the size in bytes of all sent packets that contain at
    least one ack-eliciting or PADDING frame and have not been
    acknowledged or declared lost. The size does not include IP or UDP
    overhead, but does include the QUIC header and Authenticated
    Encryption with Associated Data (AEAD) overhead. Packets only
    containing ACK frames do not count toward bytes_in_flight to ensure
    congestion control does not impede congestion
    feedback.[¶](#section-b.2-2.6.1){.pilcrow}

:   

congestion_window:

:   Maximum number of bytes allowed to be in
    flight.[¶](#section-b.2-2.8.1){.pilcrow}

:   

congestion_recovery_start_time:

:   The time the current recovery period started due to the detection of
    loss or ECN. When a packet sent after this time is acknowledged,
    QUIC exits congestion recovery.[¶](#section-b.2-2.10.1){.pilcrow}

:   

ssthresh:

:   Slow start threshold in bytes. When the congestion window is below
    ssthresh, the mode is slow start and the window grows by the number
    of bytes acknowledged.[¶](#section-b.2-2.12.1){.pilcrow}

:   

The congestion control pseudocode also accesses some of the variables
from the loss recovery pseudocode.[¶](#section-b.2-3){.pilcrow}
:::
:::

::: {#initialization-1}
::: {#section-b.3 .section}
## [B.3.](#section-b.3){.section-number .selfRef} [Initialization](#name-initialization-2){.section-name .selfRef} {#name-initialization-2}

At the beginning of the connection, initialize the congestion control
variables as follows:[¶](#section-b.3-1){.pilcrow}

::: {#section-b.3-2}
``` {.sourcecode .lang-pseudocode}
congestion_window = kInitialWindow
bytes_in_flight = 0
congestion_recovery_start_time = 0
ssthresh = infinite
for pn_space in [ Initial, Handshake, ApplicationData ]:
  ecn_ce_counters[pn_space] = 0
```

[¶](#section-b.3-2){.pilcrow}
:::
:::
:::

::: {#on-packet-sent}
::: {#section-b.4 .section}
## [B.4.](#section-b.4){.section-number .selfRef} [On Packet Sent](#name-on-packet-sent){.section-name .selfRef} {#name-on-packet-sent}

Whenever a packet is sent and it contains non-ACK frames, the packet
increases bytes_in_flight.[¶](#section-b.4-1){.pilcrow}

::: {#section-b.4-2}
``` {.sourcecode .lang-pseudocode}
OnPacketSentCC(sent_bytes):
  bytes_in_flight += sent_bytes
```

[¶](#section-b.4-2){.pilcrow}
:::
:::
:::

::: {#on-packet-acknowledgment}
::: {#section-b.5 .section}
## [B.5.](#section-b.5){.section-number .selfRef} [On Packet Acknowledgment](#name-on-packet-acknowledgment){.section-name .selfRef} {#name-on-packet-acknowledgment}

This is invoked from loss detection\'s OnAckReceived and is supplied
with the newly acked_packets from
sent_packets.[¶](#section-b.5-1){.pilcrow}

In congestion avoidance, implementers that use an integer representation
for congestion_window should be careful with division and can use the
alternative approach suggested in [Section
2.1](https://www.rfc-editor.org/rfc/rfc3465#section-2.1){.relref} of
\[[RFC3465](#RFC3465){.xref}\].[¶](#section-b.5-2){.pilcrow}

::: {#section-b.5-3}
``` {.sourcecode .lang-pseudocode}
InCongestionRecovery(sent_time):
  return sent_time <= congestion_recovery_start_time

OnPacketsAcked(acked_packets):
  for acked_packet in acked_packets:
    OnPacketAcked(acked_packet)

OnPacketAcked(acked_packet):
  if (!acked_packet.in_flight):
    return;
  // Remove from bytes_in_flight.
  bytes_in_flight -= acked_packet.sent_bytes
  // Do not increase congestion_window if application
  // limited or flow control limited.
  if (IsAppOrFlowControlLimited())
    return
  // Do not increase congestion window in recovery period.
  if (InCongestionRecovery(acked_packet.time_sent)):
    return
  if (congestion_window < ssthresh):
    // Slow start.
    congestion_window += acked_packet.sent_bytes
  else:
    // Congestion avoidance.
    congestion_window +=
      max_datagram_size * acked_packet.sent_bytes
      / congestion_window
```

[¶](#section-b.5-3){.pilcrow}
:::
:::
:::

::: {#on-new-congestion-event}
::: {#section-b.6 .section}
## [B.6.](#section-b.6){.section-number .selfRef} [On New Congestion Event](#name-on-new-congestion-event){.section-name .selfRef} {#name-on-new-congestion-event}

This is invoked from ProcessECN and OnPacketsLost when a new congestion
event is detected. If not already in recovery, this starts a recovery
period and reduces the slow start threshold and congestion window
immediately.[¶](#section-b.6-1){.pilcrow}

::: {#section-b.6-2}
``` {.sourcecode .lang-pseudocode}
OnCongestionEvent(sent_time):
  // No reaction if already in a recovery period.
  if (InCongestionRecovery(sent_time)):
    return

  // Enter recovery period.
  congestion_recovery_start_time = now()
  ssthresh = congestion_window * kLossReductionFactor
  congestion_window = max(ssthresh, kMinimumWindow)
  // A packet can be sent to speed up loss recovery.
  MaybeSendOnePacket()
```

[¶](#section-b.6-2){.pilcrow}
:::
:::
:::

::: {#process-ecn-information}
::: {#section-b.7 .section}
## [B.7.](#section-b.7){.section-number .selfRef} [Process ECN Information](#name-process-ecn-information){.section-name .selfRef} {#name-process-ecn-information}

This is invoked when an ACK frame with an ECN section is received from
the peer.[¶](#section-b.7-1){.pilcrow}

::: {#section-b.7-2}
``` {.sourcecode .lang-pseudocode}
ProcessECN(ack, pn_space):
  // If the ECN-CE counter reported by the peer has increased,
  // this could be a new congestion event.
  if (ack.ce_counter > ecn_ce_counters[pn_space]):
    ecn_ce_counters[pn_space] = ack.ce_counter
    sent_time = sent_packets[ack.largest_acked].time_sent
    OnCongestionEvent(sent_time)
```

[¶](#section-b.7-2){.pilcrow}
:::
:::
:::

::: {#on-packets-lost}
::: {#section-b.8 .section}
## [B.8.](#section-b.8){.section-number .selfRef} [On Packets Lost](#name-on-packets-lost){.section-name .selfRef} {#name-on-packets-lost}

This is invoked when DetectAndRemoveLostPackets deems packets
lost.[¶](#section-b.8-1){.pilcrow}

::: {#section-b.8-2}
``` {.sourcecode .lang-pseudocode}
OnPacketsLost(lost_packets):
  sent_time_of_last_loss = 0
  // Remove lost packets from bytes_in_flight.
  for lost_packet in lost_packets:
    if lost_packet.in_flight:
      bytes_in_flight -= lost_packet.sent_bytes
      sent_time_of_last_loss =
        max(sent_time_of_last_loss, lost_packet.time_sent)
  // Congestion event if in-flight packets were lost
  if (sent_time_of_last_loss != 0):
    OnCongestionEvent(sent_time_of_last_loss)

  // Reset the congestion window if the loss of these
  // packets indicates persistent congestion.
  // Only consider packets sent after getting an RTT sample.
  if (first_rtt_sample == 0):
    return
  pc_lost = []
  for lost in lost_packets:
    if lost.time_sent > first_rtt_sample:
      pc_lost.insert(lost)
  if (InPersistentCongestion(pc_lost)):
    congestion_window = kMinimumWindow
    congestion_recovery_start_time = 0
```

[¶](#section-b.8-2){.pilcrow}
:::
:::
:::

::: {#removing-discarded-packets-from-bytes-in-flight}
::: {#section-b.9 .section}
## [B.9.](#section-b.9){.section-number .selfRef} [Removing Discarded Packets from Bytes in Flight](#name-removing-discarded-packets-){.section-name .selfRef} {#name-removing-discarded-packets-}

When Initial or Handshake keys are discarded, packets sent in that space
no longer count toward bytes in flight.[¶](#section-b.9-1){.pilcrow}

Pseudocode for RemoveFromBytesInFlight
follows:[¶](#section-b.9-2){.pilcrow}

::: {#section-b.9-3}
``` {.sourcecode .lang-pseudocode}
RemoveFromBytesInFlight(discarded_packets):
  // Remove any unacknowledged packets from flight.
  foreach packet in discarded_packets:
    if packet.in_flight
      bytes_in_flight -= size
```

[¶](#section-b.9-3){.pilcrow}
:::
:::
:::
:::
:::

::: {#contributors}
::: {#section-appendix.c .section}
## [Contributors](#name-contributors){.section-name .selfRef} {#name-contributors}

The IETF QUIC Working Group received an enormous amount of support from
many people. The following people provided substantive contributions to
this document:[¶](#section-appendix.c-1){.pilcrow}

-   ::: {#section-appendix.c-2.1}
    [Alessandro
    Ghedini]{.contact-name}[¶](#section-appendix.c-2.1.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.2}
    [Benjamin
    Saunders]{.contact-name}[¶](#section-appendix.c-2.2.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.3}
    [Gorry
    Fairhurst]{.contact-name}[¶](#section-appendix.c-2.3.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.4}
    [[山本和彦]{.non-ascii} ([Kazu
    Yamamoto]{.ascii})]{.contact-name}[¶](#section-appendix.c-2.4.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.5}
    [[奥 一穂]{.non-ascii} ([Kazuho
    Oku]{.ascii})]{.contact-name}[¶](#section-appendix.c-2.5.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.6}
    [Lars Eggert]{.contact-name}[¶](#section-appendix.c-2.6.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.7}
    [Magnus
    Westerlund]{.contact-name}[¶](#section-appendix.c-2.7.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.8}
    [Marten
    Seemann]{.contact-name}[¶](#section-appendix.c-2.8.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.9}
    [Martin Duke]{.contact-name}[¶](#section-appendix.c-2.9.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.10}
    [Martin
    Thomson]{.contact-name}[¶](#section-appendix.c-2.10.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.11}
    [Mirja
    Kühlewind]{.contact-name}[¶](#section-appendix.c-2.11.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.12}
    [Nick Banks]{.contact-name}[¶](#section-appendix.c-2.12.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.13}
    [Praveen
    Balasubramanian]{.contact-name}[¶](#section-appendix.c-2.13.1){.pilcrow}
    :::
:::
:::

::: {#authors-addresses}
::: {#section-appendix.d .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Jana Iyengar ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Fastly]{.org}
:::

::: email
Email: <jri.ietf@gmail.com>
:::

::: {.left dir="auto"}
[Ian Swett ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google]{.org}
:::

::: email
Email: <ianswett@google.com>
:::
:::
:::
