  RFC 9177              Quick Block-Wise Transfer Options   March 2022
  --------------------- ----------------------------------- ------------
  Boucadair & Shallow   Standards Track                     \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9177](https://www.rfc-editor.org/rfc/rfc9177){.eref}

Category:
:   Standards Track

Published:
:   March 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    M. Boucadair
    :::

    ::: org
    Orange
    :::
    :::

    ::: author
    ::: author-name
    J. Shallow
    :::
    :::
:::

# RFC 9177 {#rfcnum}

# Constrained Application Protocol (CoAP) Block-Wise Transfer Options Supporting Robust Transmission {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document specifies alternative Constrained Application Protocol
(CoAP) block-wise transfer options: Q-Block1 and
Q-Block2.[¶](#section-abstract-1){.pilcrow}

These options are similar to, but distinct from, the CoAP Block1 and
Block2 options defined in RFC 7959. The Q-Block1 and Q-Block2 options
are not intended to replace the Block1 and Block2 options but rather
have the goal of supporting Non-confirmable (NON) messages for large
amounts of data with fewer packet interchanges. Also, the Q-Block1 and
Q-Block2 options support faster recovery should any of the blocks get
lost in transmission.[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9177>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Alternative CoAP Block-Wise Transfer
    Options](#name-alternative-coap-block-wise){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [CoAP Response Code (4.08)
        Usage](#name-coap-response-code-408-usag){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Applicability
        Scope](#name-applicability-scope){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [The Q-Block1 and Q-Block2
    Options](#name-the-q-block1-and-q-block2-o){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Properties of the Q-Block1 and
        Q-Block2 Options](#name-properties-of-the-q-block1-){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Structure of the Q-Block1 and
        Q-Block2 Options](#name-structure-of-the-q-block1-a){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Using the Q-Block1
        Option](#name-using-the-q-block1-option){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Using the Q-Block2
        Option](#name-using-the-q-block2-option){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [Using the Observe
        Option](#name-using-the-observe-option){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.6}
        [4.6](#section-4.6){.xref}.  [Using the Size1 and Size2
        Options](#name-using-the-size1-and-size2-o){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.7}
        [4.7](#section-4.7){.xref}.  [Using the Q-Block1 and Q-Block2
        Options Together](#name-using-the-q-block1-and-q-bl){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.8}
        [4.8](#section-4.8){.xref}.  [Using the Q-Block2 Option with
        Multicast](#name-using-the-q-block2-option-w){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [The Use of the 4.08 (Request Entity
    Incomplete) Response Code](#name-the-use-of-the-408-request-){.xref}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [The Use of
    Tokens](#name-the-use-of-tokens){.xref}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Congestion Control for Unreliable
    Transports](#name-congestion-control-for-unre){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Confirmable
        (CON)](#name-confirmable-con){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Non-confirmable
        (NON)](#name-non-confirmable-non){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Caching
    Considerations](#name-caching-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [HTTP Mapping
    Considerations](#name-http-mapping-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Examples with Non-confirmable
    Messages](#name-examples-with-non-confirmab){.xref}

    -   ::: {#section-toc.1-1.10.2.1}
        [10.1](#section-10.1){.xref}.  [Q-Block1
        Option](#name-q-block1-option){.xref}

        -   ::: {#section-toc.1-1.10.2.1.2.1}
            [10.1.1](#section-10.1.1){.xref}.  [A Simple
            Example](#name-a-simple-example){.xref}
            :::

        -   ::: {#section-toc.1-1.10.2.1.2.2}
            [10.1.2](#section-10.1.2){.xref}.  [Handling MAX_PAYLOADS
            Limits](#name-handling-max_payloads-limit){.xref}
            :::

        -   ::: {#section-toc.1-1.10.2.1.2.3}
            [10.1.3](#section-10.1.3){.xref}.  [Handling MAX_PAYLOADS
            with Recovery](#name-handling-max_payloads-with-){.xref}
            :::

        -   ::: {#section-toc.1-1.10.2.1.2.4}
            [10.1.4](#section-10.1.4){.xref}.  [Handling Recovery if
            Failure Occurs](#name-handling-recovery-if-failur){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [10.2](#section-10.2){.xref}.  [Q-Block2
        Option](#name-q-block2-option){.xref}

        -   ::: {#section-toc.1-1.10.2.2.2.1}
            [10.2.1](#section-10.2.1){.xref}.  [A Simple
            Example](#name-a-simple-example-2){.xref}
            :::

        -   ::: {#section-toc.1-1.10.2.2.2.2}
            [10.2.2](#section-10.2.2){.xref}.  [Handling MAX_PAYLOADS
            Limits](#name-handling-max_payloads-limits){.xref}
            :::

        -   ::: {#section-toc.1-1.10.2.2.2.3}
            [10.2.3](#section-10.2.3){.xref}.  [Handling MAX_PAYLOADS
            with Recovery](#name-handling-max_payloads-with-r){.xref}
            :::

        -   ::: {#section-toc.1-1.10.2.2.2.4}
            [10.2.4](#section-10.2.4){.xref}.  [Handling Recovery by
            Setting the M Bit](#name-handling-recovery-by-settin){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.10.2.3}
        [10.3](#section-10.3){.xref}.  [Q-Block1 and Q-Block2
        Options](#name-q-block1-and-q-block2-optio){.xref}

        -   ::: {#section-toc.1-1.10.2.3.2.1}
            [10.3.1](#section-10.3.1){.xref}.  [A Simple
            Example](#name-a-simple-example-3){.xref}
            :::

        -   ::: {#section-toc.1-1.10.2.3.2.2}
            [10.3.2](#section-10.3.2){.xref}.  [Handling MAX_PAYLOADS
            Limits](#name-handling-max_payloads-limits-2){.xref}
            :::

        -   ::: {#section-toc.1-1.10.2.3.2.3}
            [10.3.3](#section-10.3.3){.xref}.  [Handling
            Recovery](#name-handling-recovery){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [Security
    Considerations](#name-security-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}

    -   ::: {#section-toc.1-1.12.2.1}
        [12.1](#section-12.1){.xref}.  [CoAP Option Numbers
        Registry](#name-coap-option-numbers-registr){.xref}
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [12.2](#section-12.2){.xref}.  [Media Type
        Registration](#name-media-type-registration){.xref}
        :::

    -   ::: {#section-toc.1-1.12.2.3}
        [12.3](#section-12.3){.xref}.  [CoAP Content-Formats
        Registry](#name-coap-content-formats-regist){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [13](#section-13){.xref}. [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.13.2.1}
        [13.1](#section-13.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.13.2.2}
        [13.2](#section-13.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.14}
    [Appendix A](#appendix-A){.xref}.  [Examples with Confirmable
    Messages](#name-examples-with-confirmable-m){.xref}

    -   ::: {#section-toc.1-1.14.2.1}
        [A.1](#appendix-A.1){.xref}.  [Q-Block1
        Option](#name-q-block1-option-2){.xref}
        :::

    -   ::: {#section-toc.1-1.14.2.2}
        [A.2](#appendix-A.2){.xref}.  [Q-Block2
        Option](#name-q-block2-option-2){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.15}
    [Appendix B](#appendix-B){.xref}.  [Examples with Reliable
    Transports](#name-examples-with-reliable-tran){.xref}

    -   ::: {#section-toc.1-1.15.2.1}
        [B.1](#appendix-B.1){.xref}.  [Q-Block1
        Option](#name-q-block1-option-3){.xref}
        :::

    -   ::: {#section-toc.1-1.15.2.2}
        [B.2](#appendix-B.2){.xref}.  [Q-Block2
        Option](#name-q-block2-option-3){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.16}
    [](#appendix-C){.xref}[Acknowledgments](#name-acknowledgments){.xref}
    :::

-   ::: {#section-toc.1-1.17}
    [](#appendix-D){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The Constrained Application Protocol (CoAP)
\[[RFC7252](#RFC7252){.xref}\], although inspired by HTTP, was designed
to use UDP instead of TCP. The message layer of CoAP over UDP includes
support for reliable delivery, simple congestion control, and flow
control. CoAP supports two message types ([Section
1.2](https://www.rfc-editor.org/rfc/rfc7252#section-1.2){.relref} of
\[[RFC7252](#RFC7252){.xref}\]): Confirmable (CON) and Non-confirmable
(NON). Unlike NON messages, every CON message will elicit an
acknowledgment or a reset.[¶](#section-1-1){.pilcrow}

The CoAP specification recommends that a CoAP message should fit within
a single IP packet (i.e., avoid IP fragmentation). To handle data
records that cannot fit in a single IP packet,
\[[RFC7959](#RFC7959){.xref}\] introduced the concept of block-wise
transfers and the companion CoAP Block1 and Block2 options. However,
this concept is designed to work exclusively with Confirmable messages
([Section 1](https://www.rfc-editor.org/rfc/rfc7959#section-1){.relref}
of \[[RFC7959](#RFC7959){.xref}\]). Note that the block-wise transfer
was further updated by \[[RFC8323](#RFC8323){.xref}\] for use over TCP,
TLS, and WebSockets.[¶](#section-1-2){.pilcrow}

The CoAP Block1 and Block2 options work well in environments where there
are no, or minimal, packet losses. These options operate synchronously,
i.e., each individual block has to be requested. A CoAP endpoint can
only ask for (or send) the next block when the transfer of the previous
block has completed. The packet transmission rate, and hence the block
transmission rate, is controlled by Round-Trip Times
(RTTs).[¶](#section-1-3){.pilcrow}

There is a requirement for blocks of data larger than a single IP
datagram to be transmitted under network conditions where there may be
asymmetrical transient packet loss (e.g., acknowledgment responses may
get dropped). An example is when a network is subject to a Distributed
Denial of Service (DDoS) attack and there is a need for DDoS mitigation
agents relying upon CoAP to communicate with each other (e.g.,
\[[RFC9132](#RFC9132){.xref}\]
\[[DOTS-TELEMETRY](#DOTS-TELEMETRY){.xref}\]). As a reminder,
\[[RFC7959](#RFC7959){.xref}\] recommends the use of CON responses to
handle potential packet loss. However, such a recommendation does not
work with a \"flooded pipe\" DDoS situation (e.g.,
\[[RFC9132](#RFC9132){.xref}\]).[¶](#section-1-4){.pilcrow}

This document introduces the CoAP Q-Block1 and Q-Block2 options, which
allow block-wise transfers to work with a series of Non-confirmable
messages instead of lock-stepping using Confirmable messages ([Section
3](#alt){.xref}). In other words, this document provides a missing piece
of \[[RFC7959](#RFC7959){.xref}\], namely the support of block-wise
transfers using Non-confirmable messages where an entire body of data
can be transmitted without the requirement that intermediate
acknowledgments be received from the peer (but recovery is available
should it be needed).[¶](#section-1-5){.pilcrow}

Similar to \[[RFC7959](#RFC7959){.xref}\], this specification does not
remove any of the constraints posed by the base CoAP specification
\[[RFC7252](#RFC7252){.xref}\] it is strictly layered on top
of.[¶](#section-1-6){.pilcrow}
:::
:::

::: {#notation}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}

Readers should be familiar with the terms and concepts defined in
\[[RFC7252](#RFC7252){.xref}\], \[[RFC7959](#RFC7959){.xref}\], and
\[[RFC8132](#RFC8132){.xref}\]. Particularly, the document uses the
following key concepts:[¶](#section-2-2){.pilcrow}

[]{.break}

Token:
:   used to match responses to requests independently from the
    underlying messages ([Section
    5.3.1](https://www.rfc-editor.org/rfc/rfc7252#section-5.3.1){.relref}
    of \[[RFC7252](#RFC7252){.xref}\]).[¶](#section-2-3.2){.pilcrow}
:   

ETag:
:   used as a resource-local identifier for differentiating between
    representations of the same resource that vary over time ([Section
    5.10.6](https://www.rfc-editor.org/rfc/rfc7252#section-5.10.6){.relref}
    of \[[RFC7252](#RFC7252){.xref}\]).[¶](#section-2-3.4){.pilcrow}
:   

The terms \"payload\" and \"body\" are defined in
\[[RFC7959](#RFC7959){.xref}\]. The term \"payload\" is thus used for
the content of a single CoAP message (i.e., a single block being
transferred), while the term \"body\" is used for the entire resource
representation that is being transferred in a block-wise
fashion.[¶](#section-2-4){.pilcrow}

Request-Tag refers to an option that allows a CoAP server to match
message fragments belonging to the same request
\[[RFC9175](#RFC9175){.xref}\].[¶](#section-2-5){.pilcrow}

MAX_PAYLOADS is the maximum number of payloads that can be transmitted
at any one time.[¶](#section-2-6){.pilcrow}

MAX_PAYLOADS_SET is the set of blocks identified by block numbers that,
when divided by MAX_PAYLOADS, have the same numeric result. For example,
if MAX_PAYLOADS is set to 10, a MAX_PAYLOADS_SET could be blocks #0 to
#9, #10 to #19, etc. Depending on the overall data size, there could be
fewer than MAX_PAYLOADS blocks in the final
MAX_PAYLOADS_SET.[¶](#section-2-7){.pilcrow}
:::
:::

::: {#alt}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Alternative CoAP Block-Wise Transfer Options](#name-alternative-coap-block-wise){.section-name .selfRef} {#name-alternative-coap-block-wise}

This document introduces the CoAP Q-Block1 and Q-Block2 options. These
options are designed to work in particular with NON requests and
responses.[¶](#section-3-1){.pilcrow}

Using NON messages, faster transmissions can occur, as all the blocks
can be transmitted serially (akin to fragmented IP packets) without
having to wait for a response or next request from the remote CoAP peer.
Recovery of missing blocks is faster in that multiple missing blocks can
be requested in a single CoAP message. Even if there is asymmetrical
packet loss, a body can still be sent and received by the peer whether
the body comprises a single payload or multiple payloads, assuming no
recovery is required.[¶](#section-3-2){.pilcrow}

A CoAP endpoint can acknowledge all or a subset of the blocks.
Concretely, the receiving CoAP endpoint either informs the sending CoAP
endpoint of successful reception or reports on all blocks in the body
that have not yet been received. The sending CoAP endpoint will then
retransmit only the blocks that have been lost in
transmission.[¶](#section-3-3){.pilcrow}

Note that similar transmission rate benefits can be applied to
Confirmable messages if the value of NSTART is increased from 1
([Section
4.7](https://www.rfc-editor.org/rfc/rfc7252#section-4.7){.relref} of
\[[RFC7252](#RFC7252){.xref}\]). However, the use of Confirmable
messages will not work effectively if there is asymmetrical packet loss.
Some examples with Confirmable messages are provided in [Appendix
A](#CON){.xref}.[¶](#section-3-4){.pilcrow}

There is little, if any, benefit of using these options with CoAP
running over a reliable connection \[[RFC8323](#RFC8323){.xref}\]. In
this case, there is no differentiation between CON and NON, as they are
not used. Some examples using a reliable transport are provided in
[Appendix B](#REL){.xref}.[¶](#section-3-5){.pilcrow}

The Q-Block1 and Q-Block2 options are similar in operation to the CoAP
Block1 and Block2 options, respectively. They are not a replacement for
them but have the following benefits:[¶](#section-3-6){.pilcrow}

-   [They can operate in environments where packet loss is highly
    asymmetrical.[¶](#section-3-7.1){.pilcrow}]{#section-3-7.1}
-   [They enable faster transmissions of sets of blocks of data with
    fewer packet
    interchanges.[¶](#section-3-7.2){.pilcrow}]{#section-3-7.2}
-   [They support faster recovery should any of the blocks get lost in
    transmission.[¶](#section-3-7.3){.pilcrow}]{#section-3-7.3}
-   [They support sending an entire body using NON messages without
    requiring that an intermediate response be received from the
    peer.[¶](#section-3-7.4){.pilcrow}]{#section-3-7.4}

The disadvantages of using the CoAP Block1 and Block2 options are as
follows:[¶](#section-3-8){.pilcrow}

-   [There is a loss of lock-stepping, so payloads are not always
    received in the correct order (blocks in ascending
    order).[¶](#section-3-9.1){.pilcrow}]{#section-3-9.1}
-   [Additional congestion control measures need to be put in place for
    NON messages ([Section
    7.2](#cc-non){.xref}).[¶](#section-3-9.2){.pilcrow}]{#section-3-9.2}
-   [To reduce the transmission times for CON transmissions of large
    bodies, NSTART needs to be increased from 1, but this affects
    congestion control and incurs a requirement to retune other
    parameters ([Section
    4.7](https://www.rfc-editor.org/rfc/rfc7252#section-4.7){.relref} of
    \[[RFC7252](#RFC7252){.xref}\]). Such tuning is out of scope of this
    document.[¶](#section-3-9.3){.pilcrow}]{#section-3-9.3}
-   [Mixing of NON and CON during an exchange of requests/responses
    using Q-Block options is not
    supported.[¶](#section-3-9.4){.pilcrow}]{#section-3-9.4}
-   [The Q-Block options do not support stateless operation/random
    access.[¶](#section-3-9.5){.pilcrow}]{#section-3-9.5}
-   [Proxying of Q-Block options is limited to caching full
    representations.[¶](#section-3-9.6){.pilcrow}]{#section-3-9.6}
-   [There is no multicast
    support.[¶](#section-3-9.7){.pilcrow}]{#section-3-9.7}

The Q-Block1 and Q-Block2 options can be used instead of the Block1 and
Block2 options when the different transmission properties are required.
If the new options are not supported by a peer, then transmissions can
fall back to using the Block1 and Block2 options ([Section
4.1](#prop){.xref}).[¶](#section-3-10){.pilcrow}

The deviations from the Block1 and Block2 options are specified in
[Section 4](#spec){.xref}. Pointers to the appropriate sections in
\[[RFC7959](#RFC7959){.xref}\] are provided.[¶](#section-3-11){.pilcrow}

The specification refers to the base CoAP methods defined in [Section
5.8](https://www.rfc-editor.org/rfc/rfc7252#section-5.8){.relref} of
\[[RFC7252](#RFC7252){.xref}\] and the new CoAP methods, FETCH, PATCH,
and iPATCH, which are introduced in
\[[RFC8132](#RFC8132){.xref}\].[¶](#section-3-12){.pilcrow}

The No-Response option \[[RFC7967](#RFC7967){.xref}\] was considered but
was abandoned, as it does not apply to Q-Block2 responses. A unified
solution is defined in the document.[¶](#section-3-13){.pilcrow}

::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [CoAP Response Code (4.08) Usage](#name-coap-response-code-408-usag){.section-name .selfRef} {#name-coap-response-code-408-usag}

This document adds a media type for the 4.08 (Request Entity Incomplete)
response defining an additional message format for reporting on payloads
using the Q-Block1 option that are not received by the
server.[¶](#section-3.1-1){.pilcrow}

See [Section 5](#code){.xref} for more
details.[¶](#section-3.1-2){.pilcrow}
:::

::: {#scope}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Applicability Scope](#name-applicability-scope){.section-name .selfRef} {#name-applicability-scope}

The block-wise transfer specified in \[[RFC7959](#RFC7959){.xref}\]
covers the general case using Confirmable messages but falls short in
situations where packet loss is highly asymmetrical or there is no need
for an acknowledgment. In other words, there is a need for
Non-confirmable support.[¶](#section-3.2-1){.pilcrow}

The mechanism specified in this document provides roughly similar
features to the Block1/Block2 options. It provides additional properties
that are tailored towards the intended use case of Non-confirmable
transmission. Concretely, this mechanism primarily targets applications,
such as DDoS Open Threat Signaling (DOTS), that cannot use CON
requests/responses because of potential packet loss and that support
application-specific mechanisms to assess whether the remote peer is not
overloaded and thus is able to process the messages sent by a CoAP
endpoint (e.g., DOTS heartbeats in [Section
4.7](https://www.rfc-editor.org/rfc/rfc9132#section-4.7){.relref} of
\[[RFC9132](#RFC9132){.xref}\]). Other use cases are when an application
sends data but has no need for an acknowledgment of receipt and any data
transmission loss is not critical.[¶](#section-3.2-2){.pilcrow}

The mechanism includes guards to prevent a CoAP agent from overloading
the network by adopting an aggressive sending rate. These guards
[MUST]{.bcp14} be followed in addition to the existing CoAP congestion
control, as specified in [Section
4.7](https://www.rfc-editor.org/rfc/rfc7252#section-4.7){.relref} of
\[[RFC7252](#RFC7252){.xref}\]. See [Section 7](#cc){.xref} for more
details.[¶](#section-3.2-3){.pilcrow}

Any usage outside the primary use case of Non-confirmable messages with
block transfers should be carefully weighed against the potential loss
of interoperability with generic CoAP applications (see the
disadvantages listed in [Section 3](#alt){.xref}). It is hoped that the
experience gained with this mechanism can feed future extensions of the
block-wise mechanism that will both be generally applicable and serve
this particular use case.[¶](#section-3.2-4){.pilcrow}

It is not recommended that these options are used in the \"NoSec\"
security mode ([Section
9](https://www.rfc-editor.org/rfc/rfc7252#section-9){.relref} of
\[[RFC7252](#RFC7252){.xref}\]), as the source endpoint needs to be
trusted. Using Object Security for Constrained RESTful Environments
(OSCORE) \[[RFC8613](#RFC8613){.xref}\] does provide a security context
and hence a trust of the source endpoint that prepared the inner OSCORE
content. However, even with OSCORE, using the NoSec mode with these
options may still be inadequate, for reasons discussed in [Section
11](#security){.xref}.[¶](#section-3.2-5){.pilcrow}
:::
:::
:::
:::

::: {#spec}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [The Q-Block1 and Q-Block2 Options](#name-the-q-block1-and-q-block2-o){.section-name .selfRef} {#name-the-q-block1-and-q-block2-o}

::: {#prop}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Properties of the Q-Block1 and Q-Block2 Options](#name-properties-of-the-q-block1-){.section-name .selfRef} {#name-properties-of-the-q-block1-}

The properties of the Q-Block1 and Q-Block2 options are shown in [Table
1](#coap){.xref}. The formatting of this table follows the one used in
Table 4 of [Section
5.10](https://www.rfc-editor.org/rfc/rfc7252#section-5.10){.relref} of
\[[RFC7252](#RFC7252){.xref}\]. The C, U, N, and R columns indicate the
properties Critical, UnSafe, NoCacheKey, and Repeatable, which are
defined in [Section
5.4](https://www.rfc-editor.org/rfc/rfc7252#section-5.4){.relref} of
\[[RFC7252](#RFC7252){.xref}\]. Only the Critical and UnSafe columns are
marked for the Q-Block1 option. The Critical, UnSafe, and Repeatable
columns are marked for the Q-Block2 option. As these options are UnSafe,
NoCacheKey has no meaning and so is marked with a
dash.[¶](#section-4.1-1){.pilcrow}

[]{#name-coap-q-block1-and-q-block2-}

::: {#coap}
  No.   C   U   N    R   Name       Format   Length   Default
  ----- --- --- ---- --- ---------- -------- -------- ---------
  19    x   x   \-       Q-Block1   uint     0-3      (none)
  31    x   x   \-   x   Q-Block2   uint     0-3      (none)

  : [Table 1](#table-1){.selfRef}: [CoAP Q-Block1 and Q-Block2 Option
  Properties](#name-coap-q-block1-and-q-block2-){.selfRef}
:::

The Q-Block1 and Q-Block2 options can be present in both the request and
response messages. The Q-Block1 option pertains to the request payload,
and the Q-Block2 option pertains to the response payload. When the
Content-Format option is present together with the Q-Block1 or Q-Block2
option, the option applies to the body, not to the payload (i.e., it
must be the same for all payloads of the same
body).[¶](#section-4.1-3){.pilcrow}

The Q-Block1 option is useful with the payload-bearing (e.g., POST, PUT,
FETCH, PATCH, and iPATCH) requests and their
responses.[¶](#section-4.1-4){.pilcrow}

The Q-Block2 option is useful, for example, with GET, POST, PUT, FETCH,
PATCH, and iPATCH requests and their payload-bearing responses (response
codes 2.01, 2.02, 2.04, and 2.05) ([Section
5.5](https://www.rfc-editor.org/rfc/rfc7252#section-5.5){.relref} of
\[[RFC7252](#RFC7252){.xref}\]).[¶](#section-4.1-5){.pilcrow}

A CoAP endpoint (or proxy) [MUST]{.bcp14} support either both or neither
of the Q-Block1 and Q-Block2 options.[¶](#section-4.1-6){.pilcrow}

If the Q-Block1 option is present in a request or the Q-Block2 option is
returned in a response, this indicates a block-wise transfer and
describes how this specific block-wise payload forms part of the entire
body being transferred. If it is present in the opposite direction, it
provides additional control on how that payload will be formed or was
processed.[¶](#section-4.1-7){.pilcrow}

To indicate support for Q-Block2 responses, the CoAP client
[MUST]{.bcp14} include the Q-Block2 option in a GET or similar request
(e.g., FETCH), the Q-Block2 option in a PUT or similar request (e.g.,
POST), or the Q-Block1 option in a PUT or similar request so that the
server knows that the client supports this Q-Block functionality should
it need to send back a body that spans multiple payloads. Otherwise, the
server would use the Block2 option (if supported) to send back a message
body that is too large to fit into a single IP packet
\[[RFC7959](#RFC7959){.xref}\].[¶](#section-4.1-8){.pilcrow}

How a client decides whether it needs to include a Q-Block1 or Q-Block2
option can be driven by a local configuration parameter, triggered by an
application (e.g., DOTS), etc. Such considerations are out of the scope
of this document.[¶](#section-4.1-9){.pilcrow}

Implementation of the Q-Block1 and Q-Block2 options is intended to be
optional. However, when a Q-Block1 or Q-Block2 option is present in a
CoAP message, it [MUST]{.bcp14} be processed (or the message rejected).
Therefore, the Q-Block1 and Q-Block2 options are identified as critical
options.[¶](#section-4.1-10){.pilcrow}

With CoAP over UDP, the way a request message is rejected for critical
options depends on the message type. A Confirmable message with an
unrecognized critical option is rejected with a 4.02 (Bad Option)
response ([Section
5.4.1](https://www.rfc-editor.org/rfc/rfc7252#section-5.4.1){.relref} of
\[[RFC7252](#RFC7252){.xref}\]). A Non-confirmable message with an
unrecognized critical option is either rejected with a Reset message or
just silently ignored (Sections
[5.4.1](https://www.rfc-editor.org/rfc/rfc7252#section-5.4.1){.relref}
and [4.3](https://www.rfc-editor.org/rfc/rfc7252#section-4.3){.relref}
of \[[RFC7252](#RFC7252){.xref}\]). To reliably get a rejection message,
it is therefore [REQUIRED]{.bcp14} that clients use a Confirmable
message for determining support for the Q-Block1 and Q-Block2 options.
This Confirmable message can be sent under the base CoAP congestion
control setup specified in [Section
4.7](https://www.rfc-editor.org/rfc/rfc7252#section-4.7){.relref} of
\[[RFC7252](#RFC7252){.xref}\] (that is, NSTART does not need to be
increased ([Section
7.1](#cc-con){.xref})).[¶](#section-4.1-11){.pilcrow}

The Q-Block1 and Q-Block2 options are unsafe to forward. That is, a CoAP
proxy that does not understand the Q-Block1 (or Q-Block2) option must
reject the request or response that uses either option (see [Section
5.7.1](https://www.rfc-editor.org/rfc/rfc7252#section-5.7.1){.relref} of
\[[RFC7252](#RFC7252){.xref}\]).[¶](#section-4.1-12){.pilcrow}

The Q-Block2 option is repeatable when requesting retransmission of
missing blocks but not otherwise. Except for that case, any request
carrying multiple Q-Block1 (or Q-Block2) options [MUST]{.bcp14} be
handled following the procedure specified in [Section
5.4.5](https://www.rfc-editor.org/rfc/rfc7252#section-5.4.5){.relref} of
\[[RFC7252](#RFC7252){.xref}\].[¶](#section-4.1-13){.pilcrow}

The Q-Block1 and Q-Block2 options, like the Block1 and Block2 options,
are of both class E and class U for OSCORE processing ([Table
2](#oscore){.xref}). The Q-Block1 (or Q-Block2) option [MAY]{.bcp14} be
an Inner or Outer option ([Section
4.1](https://www.rfc-editor.org/rfc/rfc8613#section-4.1){.relref} of
\[[RFC8613](#RFC8613){.xref}\]). The Inner and Outer values are
therefore independent of each other. The Inner option is encrypted and
integrity protected between clients and servers and provides message
body identification in case of end-to-end fragmentation of requests. The
Outer option is visible to proxies and labels message bodies in case of
hop-by-hop fragmentation of requests.[¶](#section-4.1-14){.pilcrow}

[]{#name-oscore-protection-of-the-q-}

::: {#oscore}
  Number   Name       E   U
  -------- ---------- --- ---
  19       Q-Block1   x   x
  31       Q-Block2   x   x

  : [Table 2](#table-2){.selfRef}: [OSCORE Protection of the Q-Block1
  and Q-Block2 Options](#name-oscore-protection-of-the-q-){.selfRef}
:::

Note that, if the Q-Block1 or Q-Block2 options are included in a packet
as Inner options, the Block1 or Block2 options [MUST NOT]{.bcp14} be
included as Inner options. Similarly, there [MUST NOT]{.bcp14} be a mix
of Q-Block and Block options for the Outer options. Messages that do not
adhere to this behavior [MUST]{.bcp14} be rejected with a 4.02 (Bad
Option). The Q-Block and Block options can be mixed across Inner and
Outer options, as these are handled independently of each other. For
clarity, if OSCORE is not being used, there [MUST NOT]{.bcp14} be a mix
of Q-Block and Block options in the same
packet.[¶](#section-4.1-16){.pilcrow}
:::
:::

::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Structure of the Q-Block1 and Q-Block2 Options](#name-structure-of-the-q-block1-a){.section-name .selfRef} {#name-structure-of-the-q-block1-a}

The structure of the Q-Block1 and Q-Block2 options follows the structure
defined in [Section
2.2](https://www.rfc-editor.org/rfc/rfc7959#section-2.2){.relref} of
\[[RFC7959](#RFC7959){.xref}\].[¶](#section-4.2-1){.pilcrow}

There is no default value for the Q-Block1 and Q-Block2 options. The
absence of one of these options is equivalent to an option value of 0
with respect to the value of block number (NUM) and more bit (M) that
could be given in the option, i.e., it indicates that the current block
is the first and only block of the transfer (block number is set to 0; M
is unset). However, in contrast to the explicit value 0, which would
indicate a size of the block (SZX) of 0, and thus a size value of 16
bytes, there is no specific size implied by the absence of the option
\-- the size is left unspecified. (As for any uint, the explicit value 0
is efficiently indicated by a zero-length option; therefore, this is
semantically different from the absence of the
option.)[¶](#section-4.2-2){.pilcrow}
:::

::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Using the Q-Block1 Option](#name-using-the-q-block1-option){.section-name .selfRef} {#name-using-the-q-block1-option}

The Q-Block1 option is used when the client wants to send a large amount
of data to the server using the POST, PUT, FETCH, PATCH, or iPATCH
methods where the data and headers do not fit into a single
packet.[¶](#section-4.3-1){.pilcrow}

When the Q-Block1 option is used, the client [MUST]{.bcp14} include a
Request-Tag option \[[RFC9175](#RFC9175){.xref}\]. The Request-Tag value
[MUST]{.bcp14} be the same for all of the requests for the body of data
that is being transferred. The Request-Tag is opaque, but the client
[MUST]{.bcp14} ensure that it is unique for every different body of
transmitted data.[¶](#section-4.3-2){.pilcrow}

Implementation Note: It is suggested that the client treats the
Request-Tag as an unsigned integer of 8 bytes in length. An
implementation may want to consider limiting this to 4 bytes to reduce
packet overhead size. The initial Request-Tag value should be randomly
generated and then subsequently incremented by the client whenever a new
body of data is being transmitted between
peers.[¶](#section-4.3-3){.pilcrow}

[Section 4.6](#size){.xref} discusses the use of the Size1
option.[¶](#section-4.3-4){.pilcrow}

For Confirmable transmission, the server continues to acknowledge each
packet, but a response is not required (whether separate or piggybacked)
until successful receipt of the body by the server. For Non-confirmable
transmission, no response is required until either the successful
receipt of the body by the server or a timer expires with some of the
payloads having not yet arrived. In the latter case, a \"retransmit
missing payloads\" response is needed. For reliable transports (e.g.,
\[[RFC8323](#RFC8323){.xref}\]), a response is not required until
successful receipt of the body by the
server.[¶](#section-4.3-5){.pilcrow}

Each individual message that carries a block of the body is treated as a
new request ([Section 6](#token){.xref}).[¶](#section-4.3-6){.pilcrow}

The client [MUST]{.bcp14} send the payloads in order of increasing block
number, starting from zero, until the body is complete (subject to any
congestion control ([Section 7](#cc){.xref})). In addition, any missing
payloads requested by the server must be separately transmitted with
increasing block numbers.[¶](#section-4.3-7){.pilcrow}

The following response codes are used:[¶](#section-4.3-8){.pilcrow}

[]{.break}

2.01 (Created)
:   This response code indicates successful receipt of the entire body
    and that the resource was created. The token to use [MUST]{.bcp14}
    be one of the tokens that were received in a request for this
    block-wise exchange. However, it is desirable to provide the one
    used in the last received request, since that will aid any
    troubleshooting. The client should then release all of the tokens
    used for this body. Note that the last received payload might not be
    the one with the highest block
    number.[¶](#section-4.3-9.2){.pilcrow}
:   

2.02 (Deleted)
:   This response code indicates successful receipt of the entire body
    and that the resource was deleted when using POST ([Section
    5.8.2](https://www.rfc-editor.org/rfc/rfc7252#section-5.8.2){.relref}
    of \[[RFC7252](#RFC7252){.xref}\]). The token to use [MUST]{.bcp14}
    be one of the tokens that were received in a request for this
    block-wise exchange. However, it is desirable to provide the one
    used in the last received request. The client should then release
    all of the tokens used for this body.[¶](#section-4.3-9.4){.pilcrow}
:   

2.04 (Changed)
:   This response code indicates successful receipt of the entire body
    and that the resource was updated. The token to use [MUST]{.bcp14}
    be one of the tokens that were received in a request for this
    block-wise exchange. However, it is desirable to provide the one
    used in the last received request. The client should then release
    all of the tokens used for this body.[¶](#section-4.3-9.6){.pilcrow}
:   

2.05 (Content)

:   This response code indicates successful receipt of the entire FETCH
    request body ([Section
    2](https://www.rfc-editor.org/rfc/rfc8132#section-2){.relref} of
    \[[RFC8132](#RFC8132){.xref}\]) and that the appropriate
    representation of the resource is being returned. The token to use
    [MUST]{.bcp14} be one of the tokens that were received in a request
    for this block-wise exchange. However, it is desirable to provide
    the one used in the last received
    request.[¶](#section-4.3-9.8.1){.pilcrow}

    If the FETCH request includes the Observe option, then the server
    [MUST]{.bcp14} use the same token as used for the 2.05 (Content)
    response for returning any triggered Observe responses so that the
    client can match them up.[¶](#section-4.3-9.8.2){.pilcrow}

    The client should then release all of the tokens used for this body
    apart from the one used for tracking an observed
    resource.[¶](#section-4.3-9.8.3){.pilcrow}

:   

2.31 (Continue)

:   This response code can be used to indicate that all of the blocks up
    to and including the Q-Block1 option block NUM (all having the M bit
    set) have been successfully received. The token to use
    [MUST]{.bcp14} be one of the tokens that were received in a request
    for this latest MAX_PAYLOADS_SET block-wise exchange. However, it is
    desirable to provide the one used in the last received
    request.[¶](#section-4.3-9.10.1){.pilcrow}

    The client should then release all of the tokens used for this
    MAX_PAYLOADS_SET.[¶](#section-4.3-9.10.2){.pilcrow}

    A response using this response code [MUST NOT]{.bcp14} be generated
    for every received Q-Block1 option request. It [SHOULD]{.bcp14} only
    be generated when all the payload requests are Non-confirmable and a
    MAX_PAYLOADS_SET has been received by the server. More details about
    the motivations for this optimization are discussed in [Section
    7.2](#cc-non){.xref}.[¶](#section-4.3-9.10.3){.pilcrow}

    This response code [SHOULD NOT]{.bcp14} be generated for CON, as
    this may cause duplicated payloads to unnecessarily be
    sent.[¶](#section-4.3-9.10.4){.pilcrow}

:   

4.00 (Bad Request)
:   This response code [MUST]{.bcp14} be returned if the request does
    not include a Request-Tag option or a Size1 option but does include
    a Q-Block1 option.[¶](#section-4.3-9.12){.pilcrow}
:   

4.02 (Bad Option)
:   This response code [MUST]{.bcp14} be returned for a Confirmable
    request if the server does not support the Q-Block options. Note
    that a Reset message may be sent in case of a Non-confirmable
    request.[¶](#section-4.3-9.14){.pilcrow}
:   

4.08 (Request Entity Incomplete)

:   As a reminder, this response code returned without content type
    \"application/missing-blocks+cbor-seq\" ([Section
    12.3](#new-format){.xref}) is handled as in [Section
    2.9.2](https://www.rfc-editor.org/rfc/rfc7959#section-2.9.2){.relref}
    of \[[RFC7959](#RFC7959){.xref}\].[¶](#section-4.3-9.16.1){.pilcrow}

    This response code returned with content type
    \"application/missing-blocks+cbor-seq\" indicates that some of the
    payloads are missing and need to be resent. The client then
    retransmits the individual missing payloads using the same
    Request-Tag, Size1, and Q-Block1 options to specify the same NUM,
    SZX, and M bit values as those sent initially in the original (but
    not received) packets.[¶](#section-4.3-9.16.2){.pilcrow}

    The Request-Tag value to use is determined by taking the token in
    the 4.08 (Request Entity Incomplete) response, locating the matching
    client request, and then using its
    Request-Tag.[¶](#section-4.3-9.16.3){.pilcrow}

    The token to use in the 4.08 (Request Entity Incomplete) response
    [MUST]{.bcp14} be one of the tokens that were received in a request
    for this block-wise body exchange. However, it is desirable to
    provide the one used in the last received request. See [Section
    5](#code){.xref} for further
    information.[¶](#section-4.3-9.16.4){.pilcrow}

    If the server has not received all the blocks of a body, but one or
    more NON payloads have been received, it [SHOULD]{.bcp14} wait for
    NON_RECEIVE_TIMEOUT ([Section 7.2](#cc-non){.xref}) before sending a
    4.08 (Request Entity Incomplete)
    response.[¶](#section-4.3-9.16.5){.pilcrow}

:   

4.13 (Request Entity Too Large)

:   This response code can be returned under conditions similar to those
    discussed in [Section
    2.9.3](https://www.rfc-editor.org/rfc/rfc7959#section-2.9.3){.relref}
    of \[[RFC7959](#RFC7959){.xref}\].[¶](#section-4.3-9.18.1){.pilcrow}

    This response code can be returned if there is insufficient space to
    create a response PDU with a block size of 16 bytes (SZX = 0) to
    send back all the response options as appropriate. In this case, the
    Size1 option is not included in the
    response.[¶](#section-4.3-9.18.2){.pilcrow}

:   

Further considerations related to the transmission timings of the 4.08
(Request Entity Incomplete) and 2.31 (Continue) response codes are
discussed in [Section
7.2](#cc-non){.xref}.[¶](#section-4.3-10){.pilcrow}

If a server receives payloads with different Request-Tags for the same
resource, it should continue to process all the bodies, as it has no way
of determining which is the latest version or which body, if any, the
client is terminating the transmission
for.[¶](#section-4.3-11){.pilcrow}

If the client elects to stop the transmission of a complete body, then
absent any local policy, the client [MUST]{.bcp14} \"forget\" all
tracked tokens associated with the body\'s Request-Tag so that a Reset
message is generated for the invalid token in the 4.08 (Request Entity
Incomplete) response. On receipt of the Reset message, the server
[SHOULD]{.bcp14} delete the partial body.[¶](#section-4.3-12){.pilcrow}

If the server receives a duplicate block with the same Request-Tag, it
[MUST]{.bcp14} ignore the payload of the packet but [MUST]{.bcp14} still
respond as if the block was received for the first
time.[¶](#section-4.3-13){.pilcrow}

A server [SHOULD]{.bcp14} maintain a partial body (missing payloads) for
NON_PARTIAL_TIMEOUT ([Section
7.2](#cc-non){.xref}).[¶](#section-4.3-14){.pilcrow}
:::

::: {#qblock2}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Using the Q-Block2 Option](#name-using-the-q-block2-option){.section-name .selfRef} {#name-using-the-q-block2-option}

In a request for any block number, an unset M bit indicates the request
is just for that block. If the M bit is set, this has different meanings
based on the NUM value:[¶](#section-4.4-1){.pilcrow}

[]{.break}

NUM is zero:
:   This is a request for the entire
    body.[¶](#section-4.4-2.2){.pilcrow}
:   

\'NUM modulo MAX_PAYLOADS\' is zero, while NUM is not zero:
:   This is used to confirm that the current MAX_PAYLOADS_SET (the
    latest block having block number NUM-1) has been successfully
    received and that, upon receipt of this request, the server can
    continue to send the next MAX_PAYLOADS_SET (the first block having
    block number NUM). This is the \'Continue\' Q-Block-2 and
    conceptually has the same usage (i.e., continue sending the next set
    of data) as the use of 2.31 (Continue) for
    Q-Block1.[¶](#section-4.4-2.4){.pilcrow}
:   

Any other value of NUM:
:   This is a request for that block and for all of the remaining blocks
    in the current MAX_PAYLOADS_SET.[¶](#section-4.4-2.6){.pilcrow}
:   

If the request includes multiple Q-Block2 options and these options
overlap (e.g., combination of M being set (this and later blocks) and
unset (this individual block)), resulting in an individual block being
requested multiple times, the server [MUST]{.bcp14} only send back one
instance of that block. This behavior is meant to prevent amplification
attacks.[¶](#section-4.4-3){.pilcrow}

The payloads sent back from the server as a response [MUST]{.bcp14} all
have the same ETag ([Section
5.10.6](https://www.rfc-editor.org/rfc/rfc7252#section-5.10.6){.relref}
of \[[RFC7252](#RFC7252){.xref}\]) for the same body. The server [MUST
NOT]{.bcp14} use the same ETag value for different representations of a
resource.[¶](#section-4.4-4){.pilcrow}

The ETag is opaque, but the server [MUST]{.bcp14} ensure that it is
unique for every different body of transmitted
data.[¶](#section-4.4-5){.pilcrow}

Implementation Note: It is suggested that the server treats the ETag as
an unsigned integer of 8 bytes in length. An implementation may want to
consider limiting this to 4 bytes to reduce packet overhead size. The
initial ETag value should be randomly generated and then subsequently
incremented by the server whenever a new body of data is being
transmitted between peers.[¶](#section-4.4-6){.pilcrow}

[Section 4.6](#size){.xref} discusses the use of the Size2
option.[¶](#section-4.4-7){.pilcrow}

The client may elect to request any detected missing blocks or just
ignore the partial body. This decision is implementation
specific.[¶](#section-4.4-8){.pilcrow}

For NON payloads, the client [SHOULD]{.bcp14} wait for
NON_RECEIVE_TIMEOUT ([Section 7.2](#cc-non){.xref}) after the last
received payload before requesting retransmission of any missing blocks.
Retransmission is requested by issuing a GET, POST, PUT, FETCH, PATCH,
or iPATCH request that contains one or more Q-Block2 options that define
the missing block(s). Generally, the M bit on the Q-Block2 option(s)
[SHOULD]{.bcp14} be unset, although the M bit [MAY]{.bcp14} be set to
request this and later blocks from this MAX_PAYLOADS_SET; see [Section
10.2.4](#sec-nonb411){.xref} for an example of this in operation.
Further considerations related to the transmission timing for missing
requests are discussed in [Section
7.2](#cc-non){.xref}.[¶](#section-4.4-9){.pilcrow}

The missing block numbers requested by the client [MUST]{.bcp14} have an
increasing block number in each additional Q-Block2 option with no
duplicates. The server [SHOULD]{.bcp14} respond with a 4.00 (Bad
Request) to requests not adhering to this behavior. Note that the
ordering constraint is meant to force the client to check for duplicates
and remove them. This also helps with
troubleshooting.[¶](#section-4.4-10){.pilcrow}

If the client receives a duplicate block with the same ETag, it
[MUST]{.bcp14} silently ignore the
payload.[¶](#section-4.4-11){.pilcrow}

A client [SHOULD]{.bcp14} maintain a partial body (missing payloads) for
NON_PARTIAL_TIMEOUT ([Section 7.2](#cc-non){.xref}) or as defined by the
Max-Age option (or its default of 60 seconds ([Section
5.6.1](https://www.rfc-editor.org/rfc/rfc7252#section-5.6.1){.relref} of
\[[RFC7252](#RFC7252){.xref}\])), whichever is less. On release of the
partial body, the client should then release all of the tokens used for
this body apart from the token that is used to track a resource that is
being observed.[¶](#section-4.4-12){.pilcrow}

The ETag option should not be used in the request for missing blocks, as
the server could respond with a 2.03 (Valid) response with no payload.
It can be used in the request if the client wants to check the freshness
of the locally cached body response.[¶](#section-4.4-13){.pilcrow}

The server [SHOULD]{.bcp14} maintain a cached copy of the body when
using the Q-Block2 option to facilitate retransmission of any missing
payloads.[¶](#section-4.4-14){.pilcrow}

If the server detects partway through a body transfer that the resource
data has changed and the server is not maintaining a cached copy of the
old data, then the transmission is terminated. Any subsequent missing
block requests [MUST]{.bcp14} be responded to using the latest ETag and
Size2 option values with the updated data.[¶](#section-4.4-15){.pilcrow}

If the server responds during a body update with a different ETag option
value (as the resource representation has changed), then the client
should treat the partial body with the old ETag as no longer being
fresh. The client may then request all of the new data by specifying
Q-Block2 with block number \'0\' and the M bit
set.[¶](#section-4.4-16){.pilcrow}

If the server transmits a new body of data (e.g., a triggered Observe
notification) with a new ETag to the same client as an additional
response, the client should remove any partially received body held for
a previous ETag for that resource, as it is unlikely the missing blocks
can be retrieved.[¶](#section-4.4-17){.pilcrow}

If there is insufficient space to create a response PDU with a block
size of 16 bytes (SZX = 0) to send back all the response options as
appropriate, a 4.13 (Request Entity Too Large) is returned without the
Size1 option.[¶](#section-4.4-18){.pilcrow}

For Confirmable traffic, the server typically acknowledges the initial
request using an Acknowledgment (ACK) with a piggybacked payload and
then sends the subsequent payloads of the MAX_PAYLOADS_SET as CON
responses. These CON responses are individually ACKed by the client. The
server will detect failure to send a packet and [SHOULD]{.bcp14}
terminate the body transfer, but the client can issue, after a
MAX_TRANSMIT_SPAN delay, a separate GET, POST, PUT, FETCH, PATCH, or
iPATCH for any missing blocks as needed.[¶](#section-4.4-19){.pilcrow}
:::
:::

::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [Using the Observe Option](#name-using-the-observe-option){.section-name .selfRef} {#name-using-the-observe-option}

For a request that uses Q-Block1, the Observe value
\[[RFC7641](#RFC7641){.xref}\] [MUST]{.bcp14} be the same for all the
payloads of the same body. This includes any missing payloads that are
retransmitted.[¶](#section-4.5-1){.pilcrow}

For a response that uses Q-Block2, the Observe value [MUST]{.bcp14} be
the same for all the payloads of the same body. This is different from
Block2 usage where the Observe value is only present in the first block
([Section
3.4](https://www.rfc-editor.org/rfc/rfc7959#section-3.4){.relref} of
\[[RFC7959](#RFC7959){.xref}\]). This includes payloads transmitted
following receipt of the \'Continue\' Q-Block2 option ([Section
4.4](#qblock2){.xref}) by the server. If a missing payload is requested
by a client, then both the request and response [MUST NOT]{.bcp14}
include the Observe option.[¶](#section-4.5-2){.pilcrow}
:::

::: {#size}
::: {#section-4.6 .section}
### [4.6.](#section-4.6){.section-number .selfRef} [Using the Size1 and Size2 Options](#name-using-the-size1-and-size2-o){.section-name .selfRef} {#name-using-the-size1-and-size2-o}

[Section 4](https://www.rfc-editor.org/rfc/rfc7959#section-4){.relref}
of \[[RFC7959](#RFC7959){.xref}\] defines two CoAP options: Size1 for
indicating the size of the representation transferred in requests and
Size2 for indicating the size of the representation transferred in
responses.[¶](#section-4.6-1){.pilcrow}

For the Q-Block1 and Q-Block2 options, the Size1 or Size2 option values
[MUST]{.bcp14} exactly represent the size of the data on the body so
that any missing data can easily be
determined.[¶](#section-4.6-2){.pilcrow}

The Size1 option [MUST]{.bcp14} be used with the Q-Block1 option when
used in a request and [MUST]{.bcp14} be present in all payloads of the
request, preserving the same value. The Size2 option [MUST]{.bcp14} be
used with the Q-Block2 option when used in a response and [MUST]{.bcp14}
be present in all payloads of the response, preserving the same
value.[¶](#section-4.6-3){.pilcrow}
:::
:::

::: {#section-4.7 .section}
### [4.7.](#section-4.7){.section-number .selfRef} [Using the Q-Block1 and Q-Block2 Options Together](#name-using-the-q-block1-and-q-bl){.section-name .selfRef} {#name-using-the-q-block1-and-q-bl}

The behavior is similar to the one defined in [Section
3.3](https://www.rfc-editor.org/rfc/rfc7959#section-3.3){.relref} of
\[[RFC7959](#RFC7959){.xref}\] with Q-Block1 substituted for Block1 and
Q-Block2 substituted for Block2.[¶](#section-4.7-1){.pilcrow}
:::

::: {#section-4.8 .section}
### [4.8.](#section-4.8){.section-number .selfRef} [Using the Q-Block2 Option with Multicast](#name-using-the-q-block2-option-w){.section-name .selfRef} {#name-using-the-q-block2-option-w}

Servers [MUST]{.bcp14} ignore multicast requests that contain the
Q-Block2 option. As a reminder, the Block2 option can be used as stated
in [Section
2.8](https://www.rfc-editor.org/rfc/rfc7959#section-2.8){.relref} of
\[[RFC7959](#RFC7959){.xref}\].[¶](#section-4.8-1){.pilcrow}
:::
:::
:::

::: {#code}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [The Use of the 4.08 (Request Entity Incomplete) Response Code](#name-the-use-of-the-408-request-){.section-name .selfRef} {#name-the-use-of-the-408-request-}

The 4.08 (Request Entity Incomplete) response code has a new content
type \"application/missing-blocks+cbor-seq\" used to indicate that the
server has not received all of the blocks of the request body that it
needs to proceed. Such messages must not be treated by the client as a
fatal error.[¶](#section-5-1){.pilcrow}

Likely causes are the client has not sent all blocks, some blocks were
dropped during transmission, or the client sent them a long enough time
ago that the server has already discarded
them.[¶](#section-5-2){.pilcrow}

The new data payload of the 4.08 (Request Entity Incomplete) response
with content type \"application/missing-blocks+cbor-seq\" is encoded as
a Concise Binary Object Representation (CBOR) Sequence
\[[RFC8742](#RFC8742){.xref}\]. It comprises one or more missing block
numbers encoded as CBOR unsigned integers
\[[RFC8949](#RFC8949){.xref}\]. The missing block numbers [MUST]{.bcp14}
be unique in each 4.08 (Request Entity Incomplete) response when created
by the server; the client [MUST]{.bcp14} ignore any duplicates in the
same 4.08 (Request Entity Incomplete)
response.[¶](#section-5-3){.pilcrow}

The Content-Format option ([Section
5.10.3](https://www.rfc-editor.org/rfc/rfc7252#section-5.10.3){.relref}
of \[[RFC7252](#RFC7252){.xref}\]) [MUST]{.bcp14} be used in the 4.08
(Request Entity Incomplete) response. It [MUST]{.bcp14} be set to
\"application/missing-blocks+cbor-seq\" ([Section
12.3](#new-format){.xref}).[¶](#section-5-4){.pilcrow}

The Concise Data Definition Language (CDDL)
\[[RFC8610](#RFC8610){.xref}\] (and see [Section
4.1](https://www.rfc-editor.org/rfc/rfc8742#section-4.1){.relref} of
\[[RFC8742](#RFC8742){.xref}\]) for the data describing these missing
blocks is as follows:[¶](#section-5-5){.pilcrow}

[]{#name-structure-of-the-missing-bl}

::: {#cddl}
::: {#section-5-6.1}
``` {.lang-cddl .sourcecode}
; This defines an array, the elements of which are to be used
; in a CBOR Sequence:
payload = [+ missing-block-number]
; A unique block number not received:
missing-block-number = uint
```
:::

[Figure 1](#figure-1){.selfRef}: [Structure of the Missing Blocks
Payload](#name-structure-of-the-missing-bl){.selfRef}
:::

This CDDL syntax [MUST]{.bcp14} be followed.[¶](#section-5-7){.pilcrow}

It is desirable that the token to use for the response is the token that
was used in the last block number received so far with the same
Request-Tag value. Note that the use of any received token with the same
Request-Tag would be acceptable, but providing the one used in the last
received payload will aid any troubleshooting. The client will use the
token to determine what was the previously sent request to obtain the
Request-Tag value that was used.[¶](#section-5-8){.pilcrow}

If the size of the 4.08 (Request Entity Incomplete) response packet is
larger than that defined by [Section
4.6](https://www.rfc-editor.org/rfc/rfc7252#section-4.6){.relref} of
\[[RFC7252](#RFC7252){.xref}\], then the number of reported missing
blocks [MUST]{.bcp14} be limited so that the response can fit into a
single packet. If this is the case, then the server can send subsequent
4.08 (Request Entity Incomplete) responses containing those additional
missing blocks on receipt of a new request providing a missing payload
with the same Request-Tag.[¶](#section-5-9){.pilcrow}

The missing blocks [MUST]{.bcp14} be reported in ascending order without
any duplicates. The client [SHOULD]{.bcp14} silently drop 4.08 (Request
Entity Incomplete) responses not adhering to this
behavior.[¶](#section-5-10){.pilcrow}

Implementation Note: Consider limiting the number of missing payloads to
MAX_PAYLOADS to minimize the need for congestion control. The CBOR
Sequence does not include any array wrapper.[¶](#section-5-11){.pilcrow}

A 4.08 (Request Entity Incomplete) response with content type
\"application/missing-blocks+cbor-seq\" [SHOULD NOT]{.bcp14} be used
when using Confirmable requests or a reliable connection
\[[RFC8323](#RFC8323){.xref}\], as the client will be able to determine
that there is a transmission failure of a particular payload and hence
that the server is missing that payload.[¶](#section-5-12){.pilcrow}
:::
:::

::: {#token}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [The Use of Tokens](#name-the-use-of-tokens){.section-name .selfRef} {#name-the-use-of-tokens}

Each new request generally uses a new Token (and sometimes must; see
[Section 4](https://www.rfc-editor.org/rfc/rfc9175#section-4){.relref}
of \[[RFC9175](#RFC9175){.xref}\]). Additional responses to a request
all use the token of the request they respond
to.[¶](#section-6-1){.pilcrow}

Implementation Note: By using 8-byte tokens, it is possible to easily
minimize the number of tokens that have to be tracked by clients, by
keeping the bottom 32 bits the same for the same body and the upper 32
bits containing the current body\'s request number (incrementing every
request, including every retransmit). This alleviates the client\'s need
to keep all the per-request state, e.g., per [Section
3](https://www.rfc-editor.org/rfc/rfc8974#section-3){.relref} of
\[[RFC8974](#RFC8974){.xref}\]. However, if using NoSec, [Section
5.2](https://www.rfc-editor.org/rfc/rfc8974#section-5.2){.relref} of
\[[RFC8974](#RFC8974){.xref}\] needs to be considered for security
implications.[¶](#section-6-2){.pilcrow}
:::
:::

::: {#cc}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Congestion Control for Unreliable Transports](#name-congestion-control-for-unre){.section-name .selfRef} {#name-congestion-control-for-unre}

The transmission of all the blocks of a single body over an unreliable
transport [MUST]{.bcp14} either all be Confirmable or all be
Non-confirmable. This is meant to simplify the congestion control
procedure.[¶](#section-7-1){.pilcrow}

As a reminder, there is no need for CoAP-specific congestion control for
reliable transports
\[[RFC8323](#RFC8323){.xref}\].[¶](#section-7-2){.pilcrow}

::: {#cc-con}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Confirmable (CON)](#name-confirmable-con){.section-name .selfRef} {#name-confirmable-con}

Congestion control for CON requests and responses is specified in
[Section
4.7](https://www.rfc-editor.org/rfc/rfc7252#section-4.7){.relref} of
\[[RFC7252](#RFC7252){.xref}\]. In order to benefit from faster
transmission rates, NSTART will need to be increased from 1. However,
the other CON congestion control parameters will need to be tuned to
cover this change. This tuning is not specified in this document, given
that the applicability scope of the current specification assumes that
all requests and responses using Q-Block1 and Q-Block2 will be
Non-confirmable ([Section 3.2](#scope){.xref}) apart from the initial
Q-Block functionality negotiation.[¶](#section-7.1-1){.pilcrow}

Following the failure to transmit a packet due to packet loss after
MAX_TRANSMIT_SPAN time ([Section
4.8.2](https://www.rfc-editor.org/rfc/rfc7252#section-4.8.2){.relref} of
\[[RFC7252](#RFC7252){.xref}\]), it is implementation specific as to
whether there should be any further requests for missing
data.[¶](#section-7.1-2){.pilcrow}
:::
:::

::: {#cc-non}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Non-confirmable (NON)](#name-non-confirmable-non){.section-name .selfRef} {#name-non-confirmable-non}

This document introduces the new parameters MAX_PAYLOADS, NON_TIMEOUT,
NON_TIMEOUT_RANDOM, NON_RECEIVE_TIMEOUT, NON_MAX_RETRANSMIT,
NON_PROBING_WAIT, and NON_PARTIAL_TIMEOUT primarily for use with NON
([Table 3](#congestion){.xref}).[¶](#section-7.2-1){.pilcrow}

Note: Randomness may naturally be provided based on the traffic profile,
how PROBING_RATE is computed (as this is an average), and when the peer
responds. Randomness is explicitly added for some of the congestion
control parameters to handle situations where everything is in sync when
retrying.[¶](#section-7.2-2){.pilcrow}

MAX_PAYLOADS should be configurable with a default value of 10. Both
CoAP endpoints [MUST]{.bcp14} have the same value (otherwise, there will
be transmission delays in one direction), and the value [MAY]{.bcp14} be
negotiated between the endpoints to a common value by using a
higher-level protocol (out of scope of this document). This is the
maximum number of payloads that can be transmitted at any one
time.[¶](#section-7.2-3){.pilcrow}

Note: The default value of 10 is chosen for reasons similar to those
discussed in [Section
5](https://www.rfc-editor.org/rfc/rfc6928#section-5){.relref} of
\[[RFC6928](#RFC6928){.xref}\], especially given the target application
discussed in [Section 3.2](#scope){.xref}.[¶](#section-7.2-4){.pilcrow}

NON_TIMEOUT is used to compute the delay between sending
MAX_PAYLOADS_SET for the same body. By default, NON_TIMEOUT has the same
value as ACK_TIMEOUT ([Section
4.8](https://www.rfc-editor.org/rfc/rfc7252#section-4.8){.relref} of
\[[RFC7252](#RFC7252){.xref}\]).[¶](#section-7.2-5){.pilcrow}

NON_TIMEOUT_RANDOM is the initial actual delay between sending the first
two MAX_PAYLOADS_SETs of the same body. The same delay is then used
between the subsequent MAX_PAYLOADS_SETs. It is a random duration (not
an integral number of seconds) between NON_TIMEOUT and (NON_TIMEOUT \*
ACK_RANDOM_FACTOR). ACK_RANDOM_FACTOR is set to 1.5, as discussed in
[Section
4.8](https://www.rfc-editor.org/rfc/rfc7252#section-4.8){.relref} of
\[[RFC7252](#RFC7252){.xref}\].[¶](#section-7.2-6){.pilcrow}

NON_RECEIVE_TIMEOUT is the initial time to wait for a missing payload
before requesting retransmission for the first time. Every time the
missing payload is re-requested, the Time-to-Wait value doubles. The
time to wait is calculated as:[¶](#section-7.2-7){.pilcrow}

Time-to-Wait = NON_RECEIVE_TIMEOUT \* (2 \*\* (Re-Request-Count -
1))[¶](#section-7.2-8){.pilcrow}

NON_RECEIVE_TIMEOUT has a default value of twice NON_TIMEOUT.
NON_RECEIVE_TIMEOUT [MUST]{.bcp14} always be greater than
NON_TIMEOUT_RANDOM by at least one second so that the sender of the
payloads has the opportunity to start sending the next MAX_PAYLOADS_SET
before the receiver times out.[¶](#section-7.2-9){.pilcrow}

NON_MAX_RETRANSMIT is the maximum number of times a request for the
retransmission of missing payloads can occur without a response from the
remote peer. After this occurs, the local endpoint [SHOULD]{.bcp14}
consider the body stale, remove any body, and release the tokens and
Request-Tag on the client (or the ETag on the server). By default,
NON_MAX_RETRANSMIT has the same value as MAX_RETRANSMIT ([Section
4.8](https://www.rfc-editor.org/rfc/rfc7252#section-4.8){.relref} of
\[[RFC7252](#RFC7252){.xref}\]).[¶](#section-7.2-10){.pilcrow}

NON_PROBING_WAIT is used to limit the potential wait needed when using
PROBING_RATE. By default, NON_PROBING_WAIT is computed in a way similar
to EXCHANGE_LIFETIME ([Section
4.8.2](https://www.rfc-editor.org/rfc/rfc7252#section-4.8.2){.relref} of
\[[RFC7252](#RFC7252){.xref}\]) but with ACK_TIMEOUT, MAX_RETRANSMIT,
and PROCESSING_DELAY substituted with NON_TIMEOUT, NON_MAX_RETRANSMIT,
and NON_TIMEOUT_RANDOM, respectively:[¶](#section-7.2-11){.pilcrow}

NON_PROBING_WAIT = NON_TIMEOUT \* ((2 \*\* NON_MAX_RETRANSMIT) - 1) \*
ACK_RANDOM_FACTOR + (2 \* MAX_LATENCY) +
NON_TIMEOUT_RANDOM[¶](#section-7.2-12){.pilcrow}

NON_PARTIAL_TIMEOUT is used for expiring partially received bodies. By
default, NON_PARTIAL_TIMEOUT is computed in the same way as
EXCHANGE_LIFETIME ([Section
4.8.2](https://www.rfc-editor.org/rfc/rfc7252#section-4.8.2){.relref} of
\[[RFC7252](#RFC7252){.xref}\]) but with ACK_TIMEOUT and MAX_RETRANSMIT
substituted with NON_TIMEOUT and NON_MAX_RETRANSMIT,
respectively:[¶](#section-7.2-13){.pilcrow}

NON_PARTIAL_TIMEOUT = NON_TIMEOUT \* ((2 \*\* NON_MAX_RETRANSMIT) - 1)
\* ACK_RANDOM_FACTOR + (2 \* MAX_LATENCY) +
NON_TIMEOUT[¶](#section-7.2-14){.pilcrow}

[]{#name-congestion-control-paramete}

::: {#congestion}
  Parameter Name        Default Value
  --------------------- -------------------
  MAX_PAYLOADS          10
  NON_MAX_RETRANSMIT    4
  NON_TIMEOUT           2 s
  NON_TIMEOUT_RANDOM    between 2-3 s
  NON_RECEIVE_TIMEOUT   4 s
  NON_PROBING_WAIT      between 247-248 s
  NON_PARTIAL_TIMEOUT   247 s

  : [Table 3](#table-3){.selfRef}: [Congestion Control
  Parameters](#name-congestion-control-paramete){.selfRef}
:::

The PROBING_RATE parameter in CoAP indicates the average data rate that
must not be exceeded by a CoAP endpoint in sending to a peer endpoint
that does not respond. A single body will be subjected to PROBING_RATE
([Section
4.7](https://www.rfc-editor.org/rfc/rfc7252#section-4.7){.relref} of
\[[RFC7252](#RFC7252){.xref}\]), not the individual packets. If the wait
time between sending bodies that are not being responded to based on
PROBING_RATE exceeds NON_PROBING_WAIT, then the wait time is limited to
NON_PROBING_WAIT.[¶](#section-7.2-16){.pilcrow}

Note: For the particular DOTS application, PROBING_RATE and other
transmission parameters are negotiated between peers. Even when not
negotiated, the DOTS application uses customized defaults, as discussed
in [Section
4.5.2](https://www.rfc-editor.org/rfc/rfc9132#section-4.5.2){.relref} of
\[[RFC9132](#RFC9132){.xref}\]. Note that MAX_PAYLOADS,
NON_MAX_RETRANSMIT, NON_TIMEOUT, NON_PROBING_WAIT, and
NON_PARTIAL_TIMEOUT can be negotiated between DOTS peers, e.g., as per
\[[DOTS-QUICK-BLOCKS](#I-D.bosh-dots-quick-blocks){.xref}\]. When
explicit values are configured for NON_PROBING_WAIT and
NON_PARTIAL_TIMEOUT, these values are used without applying any
jitter.[¶](#section-7.2-17.1){.pilcrow}

Each NON 4.08 (Request Entity Incomplete) response is subject to
PROBING_RATE.[¶](#section-7.2-18){.pilcrow}

Each NON GET or FETCH request using a Q-Block2 option is subject to
PROBING_RATE.[¶](#section-7.2-19){.pilcrow}

As the sending of many payloads of a single body may itself cause
congestion, after transmission of every MAX_PAYLOADS_SET of a single
body, a delay of NON_TIMEOUT_RANDOM [MUST]{.bcp14} be introduced before
sending the next MAX_PAYLOADS_SET, unless a \'Continue\' is received
from the peer for the current MAX_PAYLOADS_SET, in which case the next
MAX_PAYLOADS_SET [MAY]{.bcp14} start transmission
immediately.[¶](#section-7.2-20){.pilcrow}

Note: Assuming 1500-byte packets and the MAX_PAYLOADS_SET having 10
payloads, this corresponds to 1500 \* 10 \* 8 = 120 kbits. With a delay
of 2 seconds between MAX_PAYLOADS_SET, this indicates an average speed
requirement of 60 kbps for a single body should there be no responses.
This transmission rate is further reduced by being subject to
PROBING_RATE.[¶](#section-7.2-21){.pilcrow}

The sending of a set of missing blocks of a body is restricted to those
in a MAX_PAYLOADS_SET at a time. In other words, a NON_TIMEOUT_RANDOM
delay is still observed between each
MAX_PAYLOADS_SET.[¶](#section-7.2-22){.pilcrow}

For the Q-Block1 option, if the server responds with a 2.31 (Continue)
response code for the latest payload sent, then the client can continue
to send the next MAX_PAYLOADS_SET without any further delay. If the
server responds with a 4.08 (Request Entity Incomplete) response code,
then the missing payloads [SHOULD]{.bcp14} be retransmitted before going
into another NON_TIMEOUT_RANDOM delay prior to sending the next set of
payloads.[¶](#section-7.2-23){.pilcrow}

For the server receiving NON Q-Block1 requests, it [SHOULD]{.bcp14} send
back a 2.31 (Continue) response code on receipt of all of the
MAX_PAYLOADS_SET to prevent the client unnecessarily delaying the
transfer of remaining blocks. If not all of the MAX_PAYLOADS_SET were
received, the server [SHOULD]{.bcp14} delay for NON_RECEIVE_TIMEOUT
(exponentially scaled based on the repeat request count for a payload)
before sending the 4.08 (Request Entity Incomplete) response code for
the missing payload(s). If all of the MAX_PAYLOADS_SET were received and
a 2.31 (Continue) response code had been sent, but no more payloads were
received for NON_RECEIVE_TIMEOUT (exponentially scaled), the server
[SHOULD]{.bcp14} send a 4.08 (Request Entity Incomplete) response
detailing the missing payloads after the block number that was indicated
in the sent 2.31 (Continue) response code. If the repeat response count
of the 4.08 (Request Entity Incomplete) exceeds NON_MAX_RETRANSMIT, the
server [SHOULD]{.bcp14} discard the partial body and stop requesting the
missing payloads.[¶](#section-7.2-24){.pilcrow}

It is likely that the client will start transmitting the next
MAX_PAYLOADS_SET before the server times out on waiting for the last
block of the previous MAX_PAYLOADS_SET. On receipt of a payload from the
next MAX_PAYLOADS_SET, the server [SHOULD]{.bcp14} send a 4.08 (Request
Entity Incomplete) response code indicating any missing payloads from
any previous MAX_PAYLOADS_SET. Upon receipt of the 4.08 (Request Entity
Incomplete) response code, the client [SHOULD]{.bcp14} send the missing
payloads before continuing to send the remainder of the MAX_PAYLOADS_SET
and then go into another NON_TIMEOUT_RANDOM delay prior to sending the
next MAX_PAYLOADS_SET.[¶](#section-7.2-25){.pilcrow}

For the client receiving NON Q-Block2 responses, it [SHOULD]{.bcp14}
send a \'Continue\' Q-Block2 request ([Section 4.4](#qblock2){.xref})
for the next MAX_PAYLOADS_SET on receipt of all of the MAX_PAYLOADS_SET
to prevent the server unnecessarily delaying the transfer of remaining
blocks. Otherwise, the client [SHOULD]{.bcp14} delay for
NON_RECEIVE_TIMEOUT (exponentially scaled based on the repeat request
count for a payload) before sending the request for the missing
payload(s). If the repeat request count for a missing payload exceeds
NON_MAX_RETRANSMIT, the client [SHOULD]{.bcp14} discard the partial body
and stop requesting the missing payloads.[¶](#section-7.2-26){.pilcrow}

The server [SHOULD]{.bcp14} recognize the \'Continue\' Q-Block2 request
per the definition in [Section 4.4](#qblock2){.xref} and just continue
the transmission of the body (including the Observe option, if
appropriate for an unsolicited response) rather than treat \'Continue\'
as a request for the remaining missing
blocks.[¶](#section-7.2-27){.pilcrow}

It is likely that the server will start transmitting the next
MAX_PAYLOADS_SET before the client times out on waiting for the last
block of the previous MAX_PAYLOADS_SET. Upon receipt of a payload from
the new MAX_PAYLOADS_SET, the client [SHOULD]{.bcp14} send a request
indicating any missing payloads from any previous MAX_PAYLOADS_SET. Upon
receipt of such a request, the server [SHOULD]{.bcp14} send the missing
payloads before continuing to send the remainder of the MAX_PAYLOADS_SET
and then go into another NON_TIMEOUT_RANDOM delay prior to sending the
next MAX_PAYLOADS_SET.[¶](#section-7.2-28){.pilcrow}

The client does not need to acknowledge the receipt of the entire
body.[¶](#section-7.2-29){.pilcrow}

Note: If there is asymmetric traffic loss causing responses to never get
received, a delay of NON_TIMEOUT_RANDOM after every transmission of
MAX_PAYLOADS_SET will be observed. The endpoint receiving the body is
still likely to receive the entire body.[¶](#section-7.2-30){.pilcrow}
:::
:::
:::
:::

::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Caching Considerations](#name-caching-considerations){.section-name .selfRef} {#name-caching-considerations}

Caching block-based information is not straightforward in a proxy. For
the Q-Block1 and Q-Block2 options, for simplicity, it is expected that
the proxy will reassemble the body (using any appropriate recovery
options for packet loss) before passing the body onward to the
appropriate CoAP endpoint. This does not preclude an implementation
doing a more complex per-payload caching, but how to do this is out of
the scope of this document. The onward transmission of the body does not
require the use of the Q-Block1 or Q-Block2 options, as these options
may not be supported in that link. This means that the proxy must fully
support the Q-Block1 and Q-Block2 options.[¶](#section-8-1){.pilcrow}

How the body is cached in the CoAP client (for Q-Block1 transmissions)
or the CoAP server (for Q-Block2 transmissions) is implementation
specific.[¶](#section-8-2){.pilcrow}

As the entire body is being cached in the proxy, the Q-Block1 and
Q-Block2 options are removed as part of the block assembly and thus do
not reach the cache.[¶](#section-8-3){.pilcrow}

For Q-Block2 responses, the ETag option value is associated with the
data (and transmitted onward to the CoAP client) but is not part of the
cache key.[¶](#section-8-4){.pilcrow}

For requests with the Q-Block1 option, the Request-Tag option is
associated with building the body from successive payloads but is not
part of the cache key. For the onward transmission of the body using
CoAP, a new Request-Tag [SHOULD]{.bcp14} be generated and used. Ideally,
this new Request-Tag should replace the Request-Tag used by the
client.[¶](#section-8-5){.pilcrow}

It is possible that two or more CoAP clients are concurrently updating
the same resource through a common proxy to the same CoAP server using
the Q-Block1 (or Block1) option. If this is the case, the first client
to complete building the body causes that body to start transmitting to
the CoAP server with an appropriate Request-Tag value. When the next
client completes building the body, any existing partial body
transmission to the CoAP server is terminated, and the transmission of
the new body representation starts with a new Request-Tag value. Note
that it cannot be assumed that the proxy will always receive a complete
body from a client.[¶](#section-8-6){.pilcrow}

A proxy that supports the Q-Block2 option [MUST]{.bcp14} be prepared to
receive a GET or similar request indicating one or more missing blocks.
From its cache, the proxy will serve the missing blocks that are
available in its cache in the same way a server would send all the
appropriate Q-Block2 responses. If a body matching the cache key is not
available in the cache, the proxy [MUST]{.bcp14} request the entire body
from the CoAP server using the information in the cache
key.[¶](#section-8-7){.pilcrow}

How long a CoAP endpoint (or proxy) keeps the body in its cache is
implementation specific (e.g., it may be based on
Max-Age).[¶](#section-8-8){.pilcrow}
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [HTTP Mapping Considerations](#name-http-mapping-considerations){.section-name .selfRef} {#name-http-mapping-considerations}

As a reminder, the basic normative requirements on HTTP/CoAP mappings
are defined in [Section
10](https://www.rfc-editor.org/rfc/rfc7252#section-10){.relref} of
\[[RFC7252](#RFC7252){.xref}\]. The implementation guidelines for
HTTP/CoAP mappings are elaborated in
\[[RFC8075](#RFC8075){.xref}\].[¶](#section-9-1){.pilcrow}

The rules defined in [Section
5](https://www.rfc-editor.org/rfc/rfc7959#section-5){.relref} of
\[[RFC7959](#RFC7959){.xref}\] are to be
followed.[¶](#section-9-2){.pilcrow}
:::

::: {#non-confirm}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Examples with Non-confirmable Messages](#name-examples-with-non-confirmab){.section-name .selfRef} {#name-examples-with-non-confirmab}

This section provides some sample flows to illustrate the use of the
Q-Block1 and Q-Block2 options with NON. Examples with CON are provided
in [Appendix A](#CON){.xref}.[¶](#section-10-1){.pilcrow}

The examples in the following subsections assume MAX_PAYLOADS is set to
10 and NON_MAX_RETRANSMIT is set to 4.[¶](#section-10-2){.pilcrow}

The list below contains the conventions that are used in the figures in
the following subsections.[¶](#section-10-3){.pilcrow}

[]{.break}

T:
:   Token value[¶](#section-10-4.2){.pilcrow}
:   

O:
:   Observe option value[¶](#section-10-4.4){.pilcrow}
:   

M:
:   Message ID[¶](#section-10-4.6){.pilcrow}
:   

RT:
:   Request-Tag[¶](#section-10-4.8){.pilcrow}
:   

ET:
:   ETag[¶](#section-10-4.10){.pilcrow}
:   

QB1:
:   Q-Block1 option values NUM/More/Size[¶](#section-10-4.12){.pilcrow}
:   

QB2:
:   Q-Block2 option values NUM/More/Size[¶](#section-10-4.14){.pilcrow}
:   

Size:
:   Actual block size encoded in SZX[¶](#section-10-4.16){.pilcrow}
:   

\\:
:   Trimming long lines[¶](#section-10-4.18){.pilcrow}
:   

\[\[\]\]:
:   Comments[¶](#section-10-4.20){.pilcrow}
:   

\--\>X:
:   Message loss (request)[¶](#section-10-4.22){.pilcrow}
:   

X\<\--:
:   Message loss (response)[¶](#section-10-4.24){.pilcrow}
:   

\...:
:   Passage of time[¶](#section-10-4.26){.pilcrow}
:   

Payload N:
:   Corresponds to the CoAP message that conveys a block number (N-1) of
    a given block-wise exchange.[¶](#section-10-4.28){.pilcrow}
:   

::: {#section-10.1 .section}
### [10.1.](#section-10.1){.section-number .selfRef} [Q-Block1 Option](#name-q-block1-option){.section-name .selfRef} {#name-q-block1-option}

::: {#section-10.1.1 .section}
#### [10.1.1.](#section-10.1.1){.section-number .selfRef} [A Simple Example](#name-a-simple-example){.section-name .selfRef} {#name-a-simple-example}

[Figure 2](#B3non){.xref} depicts an example of a NON PUT request
conveying the Q-Block1 option. All the blocks are received by the
server.[¶](#section-10.1.1-1){.pilcrow}

[]{#name-example-of-a-non-request-wi}

::: {#B3non}
::: {#section-10.1.1-2.1 .alignLeft .art-ascii-art .art-text .artwork}
     CoAP        CoAP
    Client      Server
      |          |
      +--------->| NON PUT /path M:0x81 T:0xc0 RT=9 QB1:0/1/1024
      +--------->| NON PUT /path M:0x82 T:0xc1 RT=9 QB1:1/1/1024
      +--------->| NON PUT /path M:0x83 T:0xc2 RT=9 QB1:2/1/1024
      +--------->| NON PUT /path M:0x84 T:0xc3 RT=9 QB1:3/0/1024
      |<---------+ NON 2.04 M:0xf1 T:0xc3
      |   ...    |
:::

[Figure 2](#figure-2){.selfRef}: [Example of a NON Request with the
Q-Block1 option (without
Loss)](#name-example-of-a-non-request-wi){.selfRef}
:::
:::

::: {#section-10.1.2 .section}
#### [10.1.2.](#section-10.1.2){.section-number .selfRef} [Handling MAX_PAYLOADS Limits](#name-handling-max_payloads-limit){.section-name .selfRef} {#name-handling-max_payloads-limit}

[Figure 3](#B3non0){.xref} depicts an example of a NON PUT request
conveying the Q-Block1 option. The number of payloads exceeds
MAX_PAYLOADS. All the blocks are received by the
server.[¶](#section-10.1.2-1){.pilcrow}

[]{#name-example-of-a-max_payloads-n}

::: {#B3non0}
::: {#section-10.1.2-2.1 .alignLeft .art-ascii-art .art-text .artwork}
      CoAP        CoAP
     Client      Server
       |          |
       +--------->| NON PUT /path M:0x01 T:0xf1 RT=10 QB1:0/1/1024
       +--------->| NON PUT /path M:0x02 T:0xf2 RT=10 QB1:1/1/1024
       +--------->| [[Payloads 3 - 9 not detailed]]
       +--------->| NON PUT /path M:0x0a T:0xfa RT=10 QB1:9/1/1024
    [[MAX_PAYLOADS_SET has been received]]
       |     [[MAX_PAYLOADS_SET receipt acknowledged by server]]
       |<---------+ NON 2.31 M:0x81 T:0xfa
       +--------->| NON PUT /path M:0x0b T:0xfb RT=10 QB1:10/0/1024
       |<---------+ NON 2.04 M:0x82 T:0xfb
       |   ...    |
:::

[Figure 3](#figure-3){.selfRef}: [Example of a MAX_PAYLOADS NON Request
with the Q-Block1 Option (without
Loss)](#name-example-of-a-max_payloads-n){.selfRef}
:::
:::

::: {#section-10.1.3 .section}
#### [10.1.3.](#section-10.1.3){.section-number .selfRef} [Handling MAX_PAYLOADS with Recovery](#name-handling-max_payloads-with-){.section-name .selfRef} {#name-handling-max_payloads-with-}

Consider now a scenario where a new body of data is to be sent by the
client, but some blocks are dropped in transmission, as illustrated in
[Figure 4](#B3non1){.xref}.[¶](#section-10.1.3-1){.pilcrow}

[]{#name-example-of-a-max_payloads-no}

::: {#B3non1}
::: {#section-10.1.3-2.1 .alignLeft .art-ascii-art .art-text .artwork}
      CoAP        CoAP
     Client      Server
       |          |
       +--------->| NON PUT /path M:0x11 T:0xe1 RT=11 QB1:0/1/1024
       +--->X     | NON PUT /path M:0x12 T:0xe2 RT=11 QB1:1/1/1024
       +--------->| [[Payloads 3 - 8 not detailed]]
       +--------->| NON PUT /path M:0x19 T:0xe9 RT=11 QB1:8/1/1024
       +--->X     | NON PUT /path M:0x1a T:0xea RT=11 QB1:9/1/1024
       [[Some of the MAX_PAYLOADS_SET has been received]]
       |   ...    |
    [[NON_TIMEOUT_RANDOM (client) delay expires]]
       |     [[Client starts sending next MAX_PAYLOADS_SET]]
       +--->X     | NON PUT /path M:0x1b T:0xeb RT=11 QB1:10/1/1024
       +--------->| NON PUT /path M:0x1c T:0xec RT=11 QB1:11/1/1024
       |          |
:::

[Figure 4](#figure-4){.selfRef}: [Example of a MAX_PAYLOADS NON Request
with the Q-Block1 Option (with
Loss)](#name-example-of-a-max_payloads-no){.selfRef}
:::

On seeing a payload from the next MAX_PAYLOADS_SET, the server realizes
that some blocks are missing from the previous MAX_PAYLOADS_SET and asks
for the missing blocks in one go ([Figure 5](#B3non2){.xref}). It does
so by indicating which blocks from the previous MAX_PAYLOADS_SET have
not been received in the data portion of the response ([Section
5](#code){.xref}). The token used in the response should be the token
that was used in the last received payload. The client can then derive
the Request-Tag by matching the token with the sent
request.[¶](#section-10.1.3-3){.pilcrow}

[]{#name-example-of-a-non-request-wit}

::: {#B3non2}
::: {#section-10.1.3-4.1 .alignLeft .art-ascii-art .art-text .artwork}
      CoAP        CoAP
     Client      Server
       |          |
       |<---------+ NON 4.08 M:0x91 T:0xec [Missing 1,9]
       |     [[Client responds with missing payloads]]
       +--------->| NON PUT /path M:0x1d T:0xed RT=11 QB1:1/1/1024
       +--------->| NON PUT /path M:0x1e T:0xee RT=11 QB1:9/1/1024
       |     [[Client continues sending next MAX_PAYLOADS_SET]]
       +--------->| NON PUT /path M:0x1f T:0xef RT=11 QB1:12/0/1024
       |   ...    |
    [[NON_RECEIVE_TIMEOUT (server) delay expires]]
       |     [[The server realizes a block is still missing and asks
       |        for the missing one]]
       |<---------+ NON 4.08 M:0x92 T:0xef [Missing 10]
       +--------->| NON PUT /path M:0x20 T:0xf0 RT=11 QB1:10/1/1024
       |<---------+ NON 2.04 M:0x93 T:0xf0
       |   ...    |
:::

[Figure 5](#figure-5){.selfRef}: [Example of a NON Request with the
Q-Block1 Option (Block
Recovery)](#name-example-of-a-non-request-wit){.selfRef}
:::
:::

::: {#section-10.1.4 .section}
#### [10.1.4.](#section-10.1.4){.section-number .selfRef} [Handling Recovery if Failure Occurs](#name-handling-recovery-if-failur){.section-name .selfRef} {#name-handling-recovery-if-failur}

[Figure 6](#B3non3){.xref} depicts an example of a NON PUT request
conveying the Q-Block1 option where recovery takes place but eventually
fails.[¶](#section-10.1.4-1){.pilcrow}

[]{#name-example-of-a-non-request-with}

::: {#B3non3}
::: {#section-10.1.4-2.1 .alignLeft .art-ascii-art .art-text .artwork}
      CoAP        CoAP
     Client      Server
       |          |
       +--------->| NON PUT /path M:0x91 T:0xd0 RT=12 QB1:0/1/1024
       +--->X     | NON PUT /path M:0x92 T:0xd1 RT=12 QB1:1/1/1024
       +--------->| NON PUT /path M:0x93 T:0xd2 RT=12 QB1:2/0/1024
       |   ...    |
    [[NON_RECEIVE_TIMEOUT (server) delay expires]]
       |     [[The server realizes a block is missing and asks
       |        for the missing one.  Retry #1]]
       |<---------+ NON 4.08 M:0x01 T:0xd2 [Missing 1]
       |   ...    |
    [[2 * NON_RECEIVE_TIMEOUT (server) delay expires]]
       |     [[The server realizes a block is still missing and asks
       |        for the missing one.  Retry #2]]
       |<---------+ NON 4.08 M:0x02 T:0xd2 [Missing 1]
       |   ...    |
    [[4 * NON_RECEIVE_TIMEOUT (server) delay expires]]
       |     [[The server realizes a block is still missing and asks
       |        for the missing one.  Retry #3]]
       |<---------+ NON 4.08 M:0x03 T:0xd2 [Missing 1]
       |   ...    |
    [[8 * NON_RECEIVE_TIMEOUT (server) delay expires]]
       |     [[The server realizes a block is still missing and asks
       |        for the missing one.  Retry #4]]
       |<---------+ NON 4.08 M:0x04 T:0xd2 [Missing 1]
       |   ...    |
    [[16 * NON_RECEIVE_TIMEOUT (server) delay expires]]
       |     [[NON_MAX_RETRANSMIT exceeded.  Server stops requesting
       |       the missing blocks and releases partial body]]
       |   ...    |
:::

[Figure 6](#figure-6){.selfRef}: [Example of a NON Request with the
Q-Block1 Option (with Eventual
Failure)](#name-example-of-a-non-request-with){.selfRef}
:::
:::
:::

::: {#section-10.2 .section}
### [10.2.](#section-10.2){.section-number .selfRef} [Q-Block2 Option](#name-q-block2-option){.section-name .selfRef} {#name-q-block2-option}

These examples include the Observe option to demonstrate how that option
is used. Note that the Observe option is not required for
Q-Block2.[¶](#section-10.2-1){.pilcrow}

::: {#section-10.2.1 .section}
#### [10.2.1.](#section-10.2.1){.section-number .selfRef} [A Simple Example](#name-a-simple-example-2){.section-name .selfRef} {#name-a-simple-example-2}

[Figure 7](#nonb4){.xref} illustrates an example of the Q-Block2 option.
The client sends a NON GET carrying the Observe and Q-Block2 options.
The Q-Block2 option indicates a block size hint (1024 bytes). The server
replies to this request using four (4) blocks that are transmitted to
the client without any loss. Each of these blocks carries a Q-Block2
option. The same process is repeated when an Observe is triggered, but
no loss is experienced by any of the notification
blocks.[¶](#section-10.2.1-1){.pilcrow}

[]{#name-example-of-non-notification}

::: {#nonb4}
::: {#section-10.2.1-2.1 .alignLeft .art-ascii-art .art-text .artwork}
     CoAP        CoAP
    Client      Server
      |          |
      +--------->| NON GET /path M:0x01 T:0xc0 O:0 QB2:0/1/1024
      |<---------+ NON 2.05 M:0xf1 T:0xc0 O:1220 ET=19 QB2:0/1/1024
      |<---------+ NON 2.05 M:0xf2 T:0xc0 O:1220 ET=19 QB2:1/1/1024
      |<---------+ NON 2.05 M:0xf3 T:0xc0 O:1220 ET=19 QB2:2/1/1024
      |<---------+ NON 2.05 M:0xf4 T:0xc0 O:1220 ET=19 QB2:3/0/1024
      |   ...    |
      |     [[Observe triggered]]
      |<---------+ NON 2.05 M:0xf5 T:0xc0 O:1221 ET=20 QB2:0/1/1024
      |<---------+ NON 2.05 M:0xf6 T:0xc0 O:1221 ET=20 QB2:1/1/1024
      |<---------+ NON 2.05 M:0xf7 T:0xc0 O:1221 ET=20 QB2:2/1/1024
      |<---------+ NON 2.05 M:0xf8 T:0xc0 O:1221 ET=20 QB2:3/0/1024
      |   ...    |
:::

[Figure 7](#figure-7){.selfRef}: [Example of NON Notifications with the
Q-Block2 Option (without
Loss)](#name-example-of-non-notification){.selfRef}
:::
:::

::: {#section-10.2.2 .section}
#### [10.2.2.](#section-10.2.2){.section-number .selfRef} [Handling MAX_PAYLOADS Limits](#name-handling-max_payloads-limits){.section-name .selfRef} {#name-handling-max_payloads-limits}

[Figure 8](#nonb40){.xref} illustrates the same scenario as [Figure
7](#nonb4){.xref}, but this time with eleven (11) payloads, which
exceeds MAX_PAYLOADS. There is no loss
experienced.[¶](#section-10.2.2-1){.pilcrow}

[]{#name-example-of-non-notifications}

::: {#nonb40}
::: {#section-10.2.2-2.1 .alignLeft .art-ascii-art .art-text .artwork}
      CoAP        CoAP
     Client      Server
       |          |
       +--------->| NON GET /path M:0x01 T:0xf0 O:0 QB2:0/1/1024
       |<---------+ NON 2.05 M:0x81 T:0xf0 O:1234 ET=21 QB2:0/1/1024
       |<---------+ NON 2.05 M:0x82 T:0xf0 O:1234 ET=21 QB2:1/1/1024
       |<---------+ [[Payloads 3 - 9 not detailed]]
       |<---------+ NON 2.05 M:0x8a T:0xf0 O:1234 ET=21 QB2:9/1/1024
    [[MAX_PAYLOADS_SET has been received]]
       |     [[MAX_PAYLOADS_SET acknowledged by client using
       |       'Continue' Q-Block2]]
       +--------->| NON GET /path M:0x02 T:0xf1 QB2:10/1/1024
       |<---------+ NON 2.05 M:0x8b T:0xf0 O:1234 ET=21 QB2:10/0/1024
       |   ...    |
       |     [[Observe triggered]]
       |<---------+ NON 2.05 M:0x91 T:0xf0 O:1235 ET=22 QB2:0/1/1024
       |<---------+ NON 2.05 M:0x92 T:0xf0 O:1235 ET=22 QB2:1/1/1024
       |<---------+ [[Payloads 3 - 9 not detailed]]
       |<---------+ NON 2.05 M:0x9a T:0xf0 O:1235 ET=22 QB2:9/1/1024
    [[MAX_PAYLOADS_SET has been received]]
       |     [[MAX_PAYLOADS_SET acknowledged by client using
       |       'Continue' Q-Block2]]
       +--------->| NON GET /path M:0x03 T:0xf2 QB2:10/1/1024
       |<---------+ NON 2.05 M:0x9b T:0xf0 O:1235 ET=22 QB2:10/0/1024
    [[Body has been received]]
       |   ...    |
:::

[Figure 8](#figure-8){.selfRef}: [Example of NON Notifications with the
Q-Block2 Option (without
Loss)](#name-example-of-non-notifications){.selfRef}
:::
:::

::: {#section-10.2.3 .section}
#### [10.2.3.](#section-10.2.3){.section-number .selfRef} [Handling MAX_PAYLOADS with Recovery](#name-handling-max_payloads-with-r){.section-name .selfRef} {#name-handling-max_payloads-with-r}

[Figure 9](#nonb41){.xref} shows an example of an Observe that is
triggered but for which some notification blocks are lost. The client
detects the missing blocks and requests their retransmission. It does so
by indicating the blocks that are missing as one or more Q-Block2
options.[¶](#section-10.2.3-1){.pilcrow}

[]{#name-example-of-non-notifications-}

::: {#nonb41}
::: {#section-10.2.3-2.1 .alignLeft .art-ascii-art .art-text .artwork}
      CoAP        CoAP
     Client      Server
       |   ...    |
       |     [[Observe triggered]]
       |<---------+ NON 2.05 M:0xa1 T:0xf0 O:1236 ET=23 QB2:0/1/1024
       |     X<---+ NON 2.05 M:0xa2 T:0xf0 O:1236 ET=23 QB2:1/1/1024
       |<---------+ [[Payloads 3 - 9 not detailed]]
       |     X<---+ NON 2.05 M:0xaa T:0xf0 O:1236 ET=23 QB2:9/1/1024
    [[Some of the MAX_PAYLOADS_SET has been received]]
       |   ...    |
    [[NON_TIMEOUT_RANDOM (server) delay expires]]
       |     [[Server sends next MAX_PAYLOADS_SET]]
       |<---------+ NON 2.05 M:0xab T:0xf0 O:1236 ET=23 QB2:10/0/1024
       |     [[On seeing a payload from the next MAX_PAYLOADS_SET,
       |       client realizes blocks are missing and asks for the
       |       missing ones in one go]]
       +--------->| NON GET /path M:0x04 T:0xf3 QB2:1/0/1024\
       |          |                             QB2:9/0/1024
       |     X<---+ NON 2.05 M:0xac T:0xf3 ET=23 QB2:1/1/1024
       |<---------+ NON 2.05 M:0xad T:0xf3 ET=23 QB2:9/1/1024
       |   ...    |
    [[NON_RECEIVE_TIMEOUT (client) delay expires]]
       |     [[Client realizes block is still missing and asks for
       |       missing block]]
       +--------->| NON GET /path M:0x05 T:0xf4 QB2:1/0/1024
       |<---------+ NON 2.05 M:0xae T:0xf4 ET=23 QB2:1/1/1024
    [[Body has been received]]
       |   ...    |
:::

[Figure 9](#figure-9){.selfRef}: [Example of NON Notifications with the
Q-Block2 Option (Block
Recovery)](#name-example-of-non-notifications-){.selfRef}
:::
:::

::: {#sec-nonb411}
::: {#section-10.2.4 .section}
#### [10.2.4.](#section-10.2.4){.section-number .selfRef} [Handling Recovery by Setting the M Bit](#name-handling-recovery-by-settin){.section-name .selfRef} {#name-handling-recovery-by-settin}

[Figure 10](#nonb411){.xref} shows an example where an Observe is
triggered but only the first two notification blocks reach the client.
In order to retrieve the missing blocks, the client sends a request with
a single Q-Block2 option with the M bit
set.[¶](#section-10.2.4-1){.pilcrow}

[]{#name-example-of-non-notifications-w}

::: {#nonb411}
::: {#section-10.2.4-2.1 .alignLeft .art-ascii-art .art-text .artwork}
      CoAP        CoAP
     Client      Server
       |   ...    |
       |     [[Observe triggered]]
       |<---------+ NON 2.05 M:0xb1 T:0xf0 O:1237 ET=24 QB2:0/1/1024
       |<---------+ NON 2.05 M:0xb2 T:0xf0 O:1237 ET=24 QB2:1/1/1024
       |     X<---+ NON 2.05 M:0xb3 T:0xf0 O:1237 ET=24 QB2:2/1/1024
       |     X<---+ [[Payloads 4 - 9 not detailed]]
       |     X<---+ NON 2.05 M:0xb9 T:0xf0 O:1237 ET=24 QB2:9/1/1024
    [[Some of the MAX_PAYLOADS_SET has been received]]
       |   ...    |
    [[NON_TIMEOUT_RANDOM (server) delay expires]]
       |     [[Server sends next MAX_PAYLOADS_SET]]
       |     X<---+ NON 2.05 M:0xba T:0xf0 O:1237 ET=24 QB2:10/0/1024
       |   ...    |
    [[NON_RECEIVE_TIMEOUT (client) delay expires]]
       |     [[Client realizes blocks are missing and asks for the
       |       missing ones in one go by setting the M bit]]
       +--------->| NON GET /path M:0x06 T:0xf5 QB2:2/1/1024
       |<---------+ NON 2.05 M:0xbb T:0xf5 ET=24 QB2:2/1/1024
       |<---------+ [[Payloads 3 - 9 not detailed]]
       |<---------+ NON 2.05 M:0xc2 T:0xf5 ET=24 QB2:9/1/1024
    [[MAX_PAYLOADS_SET has been received]]
       |     [[MAX_PAYLOADS_SET acknowledged by client using 'Continue'
       |       Q-Block2]]
       +--------->| NON GET /path M:0x87 T:0xf6 QB2:10/1/1024
       |<---------+ NON 2.05 M:0xc3 T:0xf0 O:1237 ET=24 QB2:10/0/1024
    [[Body has been received]]
       |   ...    |
:::

[Figure 10](#figure-10){.selfRef}: [Example of NON Notifications with
the Q-Block2 Option (Block Recovery with the M Bit
Set)](#name-example-of-non-notifications-w){.selfRef}
:::
:::
:::
:::

::: {#section-10.3 .section}
### [10.3.](#section-10.3){.section-number .selfRef} [Q-Block1 and Q-Block2 Options](#name-q-block1-and-q-block2-optio){.section-name .selfRef} {#name-q-block1-and-q-block2-optio}

::: {#section-10.3.1 .section}
#### [10.3.1.](#section-10.3.1){.section-number .selfRef} [A Simple Example](#name-a-simple-example-3){.section-name .selfRef} {#name-a-simple-example-3}

[Figure 11](#b12non){.xref} illustrates an example of a FETCH using both
the Q-Block1 and Q-Block2 options along with an Observe option. No loss
is experienced.[¶](#section-10.3.1-1){.pilcrow}

[]{#name-example-of-a-non-fetch-with}

::: {#b12non}
::: {#section-10.3.1-2.1 .alignLeft .art-ascii-art .art-text .artwork}
     CoAP        CoAP
    Client      Server
      |          |
      +--------->| NON FETCH /path M:0x10 T:0x90 O:0 RT=30 QB1:0/1/1024
      +--------->| NON FETCH /path M:0x11 T:0x91 O:0 RT=30 QB1:1/1/1024
      +--------->| NON FETCH /path M:0x12 T:0x93 O:0 RT=30 QB1:2/0/1024
      |<---------+ NON 2.05 M:0x60 T:0x93 O:1320 ET=90 QB2:0/1/1024
      |<---------+ NON 2.05 M:0x61 T:0x93 O:1320 ET=90 QB2:1/1/1024
      |<---------+ NON 2.05 M:0x62 T:0x93 O:1320 ET=90 QB2:2/1/1024
      |<---------+ NON 2.05 M:0x63 T:0x93 O:1320 ET=90 QB2:3/0/1024
      |   ...    |
      |     [[Observe triggered]]
      |<---------+ NON 2.05 M:0x64 T:0x93 O:1321 ET=91 QB2:0/1/1024
      |<---------+ NON 2.05 M:0x65 T:0x93 O:1321 ET=91 QB2:1/1/1024
      |<---------+ NON 2.05 M:0x66 T:0x93 O:1321 ET=91 QB2:2/1/1024
      |<---------+ NON 2.05 M:0x67 T:0x93 O:1321 ET=91 QB2:3/0/1024
      |   ...    |
:::

[Figure 11](#figure-11){.selfRef}: [Example of a NON FETCH with the
Q-Block1 and Q-Block2 Options (without
Loss)](#name-example-of-a-non-fetch-with){.selfRef}
:::
:::

::: {#section-10.3.2 .section}
#### [10.3.2.](#section-10.3.2){.section-number .selfRef} [Handling MAX_PAYLOADS Limits](#name-handling-max_payloads-limits-2){.section-name .selfRef} {#name-handling-max_payloads-limits-2}

[Figure 12](#b12non0){.xref} illustrates the same scenario as [Figure
11](#b12non){.xref}, but this time with eleven (11) payloads in both
directions, which exceeds MAX_PAYLOADS. There is no loss
experienced.[¶](#section-10.3.2-1){.pilcrow}

[]{#name-example-of-a-non-fetch-with-}

::: {#b12non0}
::: {#section-10.3.2-2.1 .alignLeft .art-ascii-art .art-text .artwork}
      CoAP        CoAP
     Client      Server
       |          |
       +--------->| NON FETCH /path M:0x30 T:0xa0 O:0 RT=10 QB1:0/1/1024
       +--------->| NON FETCH /path M:0x31 T:0xa1 O:0 RT=10 QB1:1/1/1024
       +--------->| [[Payloads 3 - 9 not detailed]]
       +--------->| NON FETCH /path M:0x39 T:0xa9 O:0 RT=10 QB1:9/1/1024
    [[MAX_PAYLOADS_SET has been received]]
       |     [[MAX_PAYLOADS_SET acknowledged by server]]
       |<---------+ NON 2.31 M:0x80 T:0xa9
       +--------->| NON FETCH /path M:0x3a T:0xaa O:0 RT=10 QB1:10/0/1024
       |<---------+ NON 2.05 M:0x81 T:0xaa O:1334 ET=21 QB2:0/1/1024
       |<---------+ NON 2.05 M:0x82 T:0xaa O:1334 ET=21 QB2:1/1/1024
       |<---------+ [[Payloads 3 - 9 not detailed]]
       |<---------+ NON 2.05 M:0x8a T:0xaa O:1334 ET=21 QB2:9/1/1024
    [[MAX_PAYLOADS_SET has been received]]
       |     [[MAX_PAYLOADS_SET acknowledged by client using
       |       'Continue' Q-Block2]]
       +--------->| NON FETCH /path M:0x3b T:0xab QB2:10/1/1024
       |<---------+ NON 2.05 M:0x8b T:0xaa O:1334 ET=21 QB2:10/0/1024
       |   ...    |
       |     [[Observe triggered]]
       |<---------+ NON 2.05 M:0x8c T:0xaa O:1335 ET=22 QB2:0/1/1024
       |<---------+ NON 2.05 M:0x8d T:0xaa O:1335 ET=22 QB2:1/1/1024
       |<---------+ [[Payloads 3 - 9 not detailed]]
       |<---------+ NON 2.05 M:0x95 T:0xaa O:1335 ET=22 QB2:9/1/1024
    [[MAX_PAYLOADS_SET has been received]]
       |     [[MAX_PAYLOADS_SET acknowledged by client using
       |       'Continue' Q-Block2]]
       +--------->| NON FETCH /path M:0x3c T:0xac QB2:10/1/1024
       |<---------+ NON 2.05 M:0x96 T:0xaa O:1335 ET=22 QB2:10/0/1024
    [[Body has been received]]
       |   ...    |
:::

[Figure 12](#figure-12){.selfRef}: [Example of a NON FETCH with the
Q-Block1 and Q-Block2 Options (without
Loss)](#name-example-of-a-non-fetch-with-){.selfRef}
:::

Note that, as \'Continue\' was used, the server continues to use the
same token (0xaa), since the \'Continue\' is not being used as a request
for a new set of packets but rather is being used to instruct the server
to continue its transmission ([Section
7.2](#cc-non){.xref}).[¶](#section-10.3.2-3){.pilcrow}
:::

::: {#section-10.3.3 .section}
#### [10.3.3.](#section-10.3.3){.section-number .selfRef} [Handling Recovery](#name-handling-recovery){.section-name .selfRef} {#name-handling-recovery}

Consider now a scenario where some blocks are lost in transmission, as
illustrated in [Figure
13](#b12non1){.xref}.[¶](#section-10.3.3-1){.pilcrow}

[]{#name-example-of-a-non-fetch-with-t}

::: {#b12non1}
::: {#section-10.3.3-2.1 .alignLeft .art-ascii-art .art-text .artwork}
      CoAP        CoAP
     Client      Server
       |          |
       +--------->| NON FETCH /path M:0x50 T:0xc0 O:0 RT=31 QB1:0/1/1024
       +--->X     | NON FETCH /path M:0x51 T:0xc1 O:0 RT=31 QB1:1/1/1024
       +--->X     | NON FETCH /path M:0x52 T:0xc2 O:0 RT=31 QB1:2/1/1024
       +--------->| NON FETCH /path M:0x53 T:0xc3 O:0 RT=31 QB1:3/0/1024
       |   ...    |
    [[NON_RECEIVE_TIMEOUT (server) delay expires]]
:::

[Figure 13](#figure-13){.selfRef}: [Example of a NON FETCH with the
Q-Block1 and Q-Block2 Options (with
Loss)](#name-example-of-a-non-fetch-with-t){.selfRef}
:::

The server realizes that some blocks are missing and asks for the
missing blocks in one go ([Figure 14](#b12non2){.xref}). It does so by
indicating which blocks have not been received in the data portion of
the response. The token used in the response is the token that was used
in the last received payload. The client can then derive the Request-Tag
by matching the token with the sent
request.[¶](#section-10.3.3-3){.pilcrow}

[]{#name-example-of-a-non-request-with-}

::: {#b12non2}
::: {#section-10.3.3-4.1 .alignLeft .art-ascii-art .art-text .artwork}
      CoAP        CoAP
     Client      Server
       |          |
       |<---------+ NON 4.08 M:0xa0 T:0xc3 [Missing 1,2]
       |     [[Client responds with missing payloads]]
       +--------->| NON FETCH /path M:0x54 T:0xc4 O:0 RT=31 QB1:1/1/1024
       +--------->| NON FETCH /path M:0x55 T:0xc5 O:0 RT=31 QB1:2/1/1024
       |     [[Server received FETCH body,
       |       starts transmitting response body]]
       |<---------+ NON 2.05 M:0xa1 T:0xc3 O:1236 ET=23 QB2:0/1/1024
       |     X<---+ NON 2.05 M:0xa2 T:0xc3 O:1236 ET=23 QB2:1/1/1024
       |<---------+ NON 2.05 M:0xa3 T:0xc3 O:1236 ET=23 QB2:2/1/1024
       |     X<---+ NON 2.05 M:0xa4 T:0xc3 O:1236 ET=23 QB2:3/0/1024
       |   ...    |
    [[NON_RECEIVE_TIMEOUT (client) delay expires]]
       |          |
:::

[Figure 14](#figure-14){.selfRef}: [Example of a NON Request with the
Q-Block1 Option (Server
Recovery)](#name-example-of-a-non-request-with-){.selfRef}
:::

The client realizes that not all the payloads of the response have been
returned. The client then asks for the missing blocks in one go ([Figure
15](#b12non3){.xref}). Note that, following [Section
2.7](https://www.rfc-editor.org/rfc/rfc7959#section-2.7){.relref} of
\[[RFC7959](#RFC7959){.xref}\], the FETCH request does not include the
Q-Block1 or any payload.[¶](#section-10.3.3-5){.pilcrow}

[]{#name-example-of-a-non-request-with-t}

::: {#b12non3}
::: {#section-10.3.3-6.1 .alignLeft .art-ascii-art .art-text .artwork}
      CoAP        CoAP
     Client      Server
       |          |
       +--------->| NON FETCH /path M:0x56 T:0xc6 RT=31 QB2:1/0/1024\
       |          |                                     QB2:3/0/1024
       |     [[Server receives FETCH request for missing payloads,
       |       starts transmitting missing blocks]]
       |     X<---+ NON 2.05 M:0xa5 T:0xc6 ET=23 QB2:1/1/1024
       |<---------+ NON 2.05 M:0xa6 T:0xc6 ET=23 QB2:3/0/1024
       |   ...    |
    [[NON_RECEIVE_TIMEOUT (client) delay expires]]
       |     [[Client realizes block is still missing and asks for
       |       missing block]]
       +--------->| NON FETCH /path M:0x57 T:0xc7 RT=31 QB2:1/0/1024
       |     [[Server receives FETCH request for missing payload,
       |       starts transmitting missing block]]
       |<---------+ NON 2.05 M:0xa7 T:0xc7 ET=23 QB2:1/1/1024
    [[Body has been received]]
       |   ...    |
       |     [[Observe triggered]]
       |<---------+ NON 2.05 M:0xa8 T:0xc3 O:1337 ET=24 QB2:0/1/1024
       |     X<---+ NON 2.05 M:0xa9 T:0xc3 O:1337 ET=24 QB2:1/1/1024
       |<---------+ NON 2.05 M:0xaa T:0xc3 O:1337 ET=24 QB2:2/0/1024
    [[NON_RECEIVE_TIMEOUT (client) delay expires]]
       |     [[Client realizes block is still missing and asks for
       |       missing block]]
       +--------->| NON FETCH /path M:0x58 T:0xc8 RT=31 QB2:1/0/1024
       |     [[Server receives FETCH request for missing payload,
       |       starts transmitting missing block]]
       |<---------+ NON 2.05 M:0xa7 T:0xc8 ET=24 QB2:1/1/1024
    [[Body has been received]]
       |   ...    |
:::

[Figure 15](#figure-15){.selfRef}: [Example of a NON Request with the
Q-Block1 Option (Client
Recovery)](#name-example-of-a-non-request-with-t){.selfRef}
:::
:::
:::
:::
:::

::: {#security}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

Security considerations discussed in [Section
7](https://www.rfc-editor.org/rfc/rfc7959#section-7){.relref} of
\[[RFC7959](#RFC7959){.xref}\] should be taken into
account.[¶](#section-11-1){.pilcrow}

Security considerations discussed in Sections
[11.3](https://www.rfc-editor.org/rfc/rfc7252#section-11.3){.relref} and
[11.4](https://www.rfc-editor.org/rfc/rfc7252#section-11.4){.relref} of
\[[RFC7252](#RFC7252){.xref}\] should also be taken into
account.[¶](#section-11-2){.pilcrow}

OSCORE provides end-to-end protection of all information that is not
required for proxy operations and requires that a security context is
set up ([Section
3.1](https://www.rfc-editor.org/rfc/rfc8613#section-3.1){.relref} of
\[[RFC8613](#RFC8613){.xref}\]). It can be trusted that the source
endpoint is legitimate even if the NoSec mode is used. However, an
intermediary node can modify the unprotected Outer Q-Block1 and/or
Q-Block2 options to cause a Q-Block transfer to fail or keep requesting
all the blocks by setting the M bit and thus causing attack
amplification. As discussed in [Section
12.1](https://www.rfc-editor.org/rfc/rfc8613#section-12.1){.relref} of
\[[RFC8613](#RFC8613){.xref}\], applications need to consider that
certain message fields and message types are not protected end to end
and may be spoofed or manipulated. Therefore, it is [NOT
RECOMMENDED]{.bcp14} to use the NoSec mode if either the Q-Block1 or
Q-Block2 option is used.[¶](#section-11-3){.pilcrow}

If OSCORE is not used, it is also [NOT RECOMMENDED]{.bcp14} to use the
NoSec mode if either the Q-Block1 or Q-Block2 option is
used.[¶](#section-11-4){.pilcrow}

If NoSec is being used, [Appendix
D.5](https://www.rfc-editor.org/rfc/rfc8613#appendix-D.5){.relref} of
\[[RFC8613](#RFC8613){.xref}\] discusses the security analysis and
considerations for unprotected message fields even if OSCORE is not
being used.[¶](#section-11-5){.pilcrow}

Security considerations related to the use of Request-Tag are discussed
in [Section
5](https://www.rfc-editor.org/rfc/rfc9175#section-5){.relref} of
\[[RFC9175](#RFC9175){.xref}\].[¶](#section-11-6){.pilcrow}
:::
:::

::: {#IANA}
::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

::: {#section-12.1 .section}
### [12.1.](#section-12.1){.section-number .selfRef} [CoAP Option Numbers Registry](#name-coap-option-numbers-registr){.section-name .selfRef} {#name-coap-option-numbers-registr}

IANA has added the following entries to the \"CoAP Option Numbers\"
subregistry \[[IANA-Options](#IANA-Options){.xref}\] defined in
\[[RFC7252](#RFC7252){.xref}\] within the \"Constrained RESTful
Environments (CoRE) Parameters\" registry:[¶](#section-12.1-1){.pilcrow}

[]{#name-additions-to-coap-option-nu}

  Number   Name       Reference
  -------- ---------- -----------
  19       Q-Block1   RFC 9177
  31       Q-Block2   RFC 9177

  : [Table 4](#table-4){.selfRef}: [Additions to CoAP Option Numbers
  Registry](#name-additions-to-coap-option-nu){.selfRef}
:::

::: {#section-12.2 .section}
### [12.2.](#section-12.2){.section-number .selfRef} [Media Type Registration](#name-media-type-registration){.section-name .selfRef} {#name-media-type-registration}

IANA has registered the \"application/missing-blocks+cbor-seq\" media
type in the \"Media Types\" registry
\[[IANA-MediaTypes](#IANA-MediaTypes){.xref}\]. This registration
follows the procedures specified in
\[[RFC6838](#RFC6838){.xref}\].[¶](#section-12.2-1){.pilcrow}

[]{.break}

Type name:
:   application[¶](#section-12.2-2.2){.pilcrow}
:   

Subtype name:
:   missing-blocks+cbor-seq[¶](#section-12.2-2.4){.pilcrow}
:   

Required parameters:
:   N/A[¶](#section-12.2-2.6){.pilcrow}
:   

Optional parameters:
:   N/A[¶](#section-12.2-2.8){.pilcrow}
:   

Encoding considerations:
:   Must be encoded as a CBOR Sequence \[[RFC8742](#RFC8742){.xref}\],
    as defined in [Section 5](#code){.xref} of RFC
    9177.[¶](#section-12.2-2.10){.pilcrow}
:   

Security considerations:
:   See [Section 11](#security){.xref} of RFC
    9177.[¶](#section-12.2-2.12){.pilcrow}
:   

Interoperability considerations:
:   N/A[¶](#section-12.2-2.14){.pilcrow}
:   

Published specification:
:   RFC 9177[¶](#section-12.2-2.16){.pilcrow}
:   

Applications that use this media type:
:   Data serialization and deserialization. In particular, the type is
    used by applications relying upon block-wise transfers, allowing a
    server to specify non-received blocks and request their
    retransmission, as defined in [Section 4](#spec){.xref} of RFC
    9177.[¶](#section-12.2-2.18){.pilcrow}
:   

Fragment identifier considerations:
:   N/A[¶](#section-12.2-2.20){.pilcrow}
:   

Additional information:
:   N/A[¶](#section-12.2-2.22){.pilcrow}
:   

Person & email address to contact for further information:
:   IETF, iesg​@​ietf.org[¶](#section-12.2-2.24){.pilcrow}
:   

Intended usage:
:   COMMON[¶](#section-12.2-2.26){.pilcrow}
:   

Restrictions on usage:
:   none[¶](#section-12.2-2.28){.pilcrow}
:   

Author:
:   See Authors\' Addresses section of RFC
    9177.[¶](#section-12.2-2.30){.pilcrow}
:   

Change controller:
:   IESG[¶](#section-12.2-2.32){.pilcrow}
:   

Provisional registration?
:   No[¶](#section-12.2-2.34){.pilcrow}
:   
:::

::: {#new-format}
::: {#section-12.3 .section}
### [12.3.](#section-12.3){.section-number .selfRef} [CoAP Content-Formats Registry](#name-coap-content-formats-regist){.section-name .selfRef} {#name-coap-content-formats-regist}

IANA has registered the following CoAP Content-Format for the
\"application/missing-blocks+cbor-seq\" media type in the \"CoAP
Content-Formats\" registry \[[IANA-Format](#IANA-Format){.xref}\]
defined in \[[RFC7252](#RFC7252){.xref}\] within the \"Constrained
RESTful Environments (CoRE) Parameters\"
registry:[¶](#section-12.3-1){.pilcrow}

[]{#name-addition-to-coap-content-fo}

  Media Type                            Encoding   ID    Reference
  ------------------------------------- ---------- ----- -----------
  application/missing-blocks+cbor-seq   \-         272   RFC 9177

  : [Table 5](#table-5){.selfRef}: [Addition to CoAP Content-Format
  Registry](#name-addition-to-coap-content-fo){.selfRef}
:::
:::
:::
:::

::: {#section-13 .section}
## [13.](#section-13){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-13.1 .section}
### [13.1.](#section-13.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC6838\]
:   [Freed, N.]{.refAuthor}, [Klensin, J.]{.refAuthor}, and [T.
    Hansen]{.refAuthor}, [\"Media Type Specifications and Registration
    Procedures\"]{.refTitle}, [BCP 13]{.seriesInfo}, [RFC
    6838]{.seriesInfo}, [DOI 10.17487/RFC6838]{.seriesInfo}, January
    2013, \<<https://www.rfc-editor.org/info/rfc6838>\>.
:   

\[RFC7252\]
:   [Shelby, Z.]{.refAuthor}, [Hartke, K.]{.refAuthor}, and [C.
    Bormann]{.refAuthor}, [\"The Constrained Application Protocol
    (CoAP)\"]{.refTitle}, [RFC 7252]{.seriesInfo}, [DOI
    10.17487/RFC7252]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7252>\>.
:   

\[RFC7641\]
:   [Hartke, K.]{.refAuthor}, [\"Observing Resources in the Constrained
    Application Protocol (CoAP)\"]{.refTitle}, [RFC 7641]{.seriesInfo},
    [DOI 10.17487/RFC7641]{.seriesInfo}, September 2015,
    \<<https://www.rfc-editor.org/info/rfc7641>\>.
:   

\[RFC7959\]
:   [Bormann, C.]{.refAuthor} and [Z. Shelby, Ed.]{.refAuthor},
    [\"Block-Wise Transfers in the Constrained Application Protocol
    (CoAP)\"]{.refTitle}, [RFC 7959]{.seriesInfo}, [DOI
    10.17487/RFC7959]{.seriesInfo}, August 2016,
    \<<https://www.rfc-editor.org/info/rfc7959>\>.
:   

\[RFC8075\]
:   [Castellani, A.]{.refAuthor}, [Loreto, S.]{.refAuthor},
    [Rahman, A.]{.refAuthor}, [Fossati, T.]{.refAuthor}, and [E.
    Dijk]{.refAuthor}, [\"Guidelines for Mapping Implementations: HTTP
    to the Constrained Application Protocol (CoAP)\"]{.refTitle}, [RFC
    8075]{.seriesInfo}, [DOI 10.17487/RFC8075]{.seriesInfo}, February
    2017, \<<https://www.rfc-editor.org/info/rfc8075>\>.
:   

\[RFC8132\]
:   [van der Stok, P.]{.refAuthor}, [Bormann, C.]{.refAuthor}, and [A.
    Sehgal]{.refAuthor}, [\"PATCH and FETCH Methods for the Constrained
    Application Protocol (CoAP)\"]{.refTitle}, [RFC 8132]{.seriesInfo},
    [DOI 10.17487/RFC8132]{.seriesInfo}, April 2017,
    \<<https://www.rfc-editor.org/info/rfc8132>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8323\]
:   [Bormann, C.]{.refAuthor}, [Lemay, S.]{.refAuthor},
    [Tschofenig, H.]{.refAuthor}, [Hartke, K.]{.refAuthor},
    [Silverajan, B.]{.refAuthor}, and [B. Raymor, Ed.]{.refAuthor},
    [\"CoAP (Constrained Application Protocol) over TCP, TLS, and
    WebSockets\"]{.refTitle}, [RFC 8323]{.seriesInfo}, [DOI
    10.17487/RFC8323]{.seriesInfo}, February 2018,
    \<<https://www.rfc-editor.org/info/rfc8323>\>.
:   

\[RFC8610\]
:   [Birkholz, H.]{.refAuthor}, [Vigano, C.]{.refAuthor}, and [C.
    Bormann]{.refAuthor}, [\"Concise Data Definition Language (CDDL): A
    Notational Convention to Express Concise Binary Object
    Representation (CBOR) and JSON Data Structures\"]{.refTitle}, [RFC
    8610]{.seriesInfo}, [DOI 10.17487/RFC8610]{.seriesInfo}, June 2019,
    \<<https://www.rfc-editor.org/info/rfc8610>\>.
:   

\[RFC8613\]
:   [Selander, G.]{.refAuthor}, [Mattsson, J.]{.refAuthor},
    [Palombini, F.]{.refAuthor}, and [L. Seitz]{.refAuthor}, [\"Object
    Security for Constrained RESTful Environments
    (OSCORE)\"]{.refTitle}, [RFC 8613]{.seriesInfo}, [DOI
    10.17487/RFC8613]{.seriesInfo}, July 2019,
    \<<https://www.rfc-editor.org/info/rfc8613>\>.
:   

\[RFC8742\]
:   [Bormann, C.]{.refAuthor}, [\"Concise Binary Object Representation
    (CBOR) Sequences\"]{.refTitle}, [RFC 8742]{.seriesInfo}, [DOI
    10.17487/RFC8742]{.seriesInfo}, February 2020,
    \<<https://www.rfc-editor.org/info/rfc8742>\>.
:   

\[RFC8949\]
:   [Bormann, C.]{.refAuthor} and [P. Hoffman]{.refAuthor}, [\"Concise
    Binary Object Representation (CBOR)\"]{.refTitle}, [STD
    94]{.seriesInfo}, [RFC 8949]{.seriesInfo}, [DOI
    10.17487/RFC8949]{.seriesInfo}, December 2020,
    \<<https://www.rfc-editor.org/info/rfc8949>\>.
:   

\[RFC9175\]
:   [Amsüss, C.]{.refAuthor}, [Preuß Mattsson, J.]{.refAuthor}, and [G.
    Selander]{.refAuthor}, [\"Constrained Application Protocol (CoAP):
    Echo, Request-Tag, and Token Processing\"]{.refTitle}, [RFC
    9175]{.seriesInfo}, [DOI 10.17487/RFC9175]{.seriesInfo}, February
    2022, \<<https://www.rfc-editor.org/info/rfc9175>\>.
:   
:::

::: {#section-13.2 .section}
### [13.2.](#section-13.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[DOTS-QUICK-BLOCKS\]
:   [Boucadair, M.]{.refAuthor} and [J. Shallow]{.refAuthor},
    [\"Distributed Denial-of-Service Open Threat Signaling (DOTS) Signal
    Channel Configuration Attributes for Robust Block
    Transmission\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-bosh-dots-quick-blocks-03]{.seriesInfo}, 29
    June 2021,
    \<<https://datatracker.ietf.org/doc/html/draft-bosh-dots-quick-blocks-03>\>.
:   

\[DOTS-TELEMETRY\]
:   [Boucadair, M., Ed.]{.refAuthor}, [Reddy.K, T., Ed.]{.refAuthor},
    [Doron, E.]{.refAuthor}, [Chen, M.]{.refAuthor}, and [J.
    Shallow]{.refAuthor}, [\"Distributed Denial-of-Service Open Threat
    Signaling (DOTS) Telemetry\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-dots-telemetry-19]{.seriesInfo}, 4 January 2022,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-dots-telemetry-19>\>.
:   

\[IANA-Format\]
:   [IANA]{.refAuthor}, [\"CoAP Content-Formats\"]{.refTitle},
    \<<https://www.iana.org/assignments/core-parameters/>\>.
:   

\[IANA-MediaTypes\]
:   [IANA]{.refAuthor}, [\"Media Types\"]{.refTitle},
    \<<https://www.iana.org/assignments/media-types/>\>.
:   

\[IANA-Options\]
:   [IANA]{.refAuthor}, [\"CoAP Option Numbers\"]{.refTitle},
    \<<https://www.iana.org/assignments/core-parameters/>\>.
:   

\[RFC6928\]
:   [Chu, J.]{.refAuthor}, [Dukkipati, N.]{.refAuthor},
    [Cheng, Y.]{.refAuthor}, and [M. Mathis]{.refAuthor}, [\"Increasing
    TCP\'s Initial Window\"]{.refTitle}, [RFC 6928]{.seriesInfo}, [DOI
    10.17487/RFC6928]{.seriesInfo}, April 2013,
    \<<https://www.rfc-editor.org/info/rfc6928>\>.
:   

\[RFC7967\]
:   [Bhattacharyya, A.]{.refAuthor}, [Bandyopadhyay, S.]{.refAuthor},
    [Pal, A.]{.refAuthor}, and [T. Bose]{.refAuthor}, [\"Constrained
    Application Protocol (CoAP) Option for No Server
    Response\"]{.refTitle}, [RFC 7967]{.seriesInfo}, [DOI
    10.17487/RFC7967]{.seriesInfo}, August 2016,
    \<<https://www.rfc-editor.org/info/rfc7967>\>.
:   

\[RFC8974\]
:   [Hartke, K.]{.refAuthor} and [M. Richardson]{.refAuthor},
    [\"Extended Tokens and Stateless Clients in the Constrained
    Application Protocol (CoAP)\"]{.refTitle}, [RFC 8974]{.seriesInfo},
    [DOI 10.17487/RFC8974]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8974>\>.
:   

\[RFC9132\]
:   [Boucadair, M., Ed.]{.refAuthor}, [Shallow, J.]{.refAuthor}, and [T.
    Reddy.K]{.refAuthor}, [\"Distributed Denial-of-Service Open Threat
    Signaling (DOTS) Signal Channel Specification\"]{.refTitle}, [RFC
    9132]{.seriesInfo}, [DOI 10.17487/RFC9132]{.seriesInfo}, September
    2021, \<<https://www.rfc-editor.org/info/rfc9132>\>.
:   
:::
:::

::: {#CON}
::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [Examples with Confirmable Messages](#name-examples-with-confirmable-m){.section-name .selfRef} {#name-examples-with-confirmable-m}

The following examples assume NSTART has been increased to
3.[¶](#appendix-A-1){.pilcrow}

The conventions provided in [Section 10](#non-confirm){.xref} are used
in the following subsections.[¶](#appendix-A-2){.pilcrow}

::: {#appendix-A.1 .section}
### [A.1.](#appendix-A.1){.section-number .selfRef} [Q-Block1 Option](#name-q-block1-option-2){.section-name .selfRef} {#name-q-block1-option-2}

Let\'s now consider the use of the Q-Block1 option with a CON request,
as shown in [Figure 16](#con3){.xref}. All the blocks are acknowledged
(as noted with \"ACK\").[¶](#appendix-A.1-1){.pilcrow}

[]{#name-example-of-a-con-request-wi}

::: {#con3}
::: {#appendix-A.1-2.1 .alignLeft .art-ascii-art .art-text .artwork}
      CoAP        CoAP
     Client      Server
       |          |
       +--------->| CON PUT /path M:0x01 T:0xf0 RT=10 QB1:0/1/1024
       +--------->| CON PUT /path M:0x02 T:0xf1 RT=10 QB1:1/1/1024
       +--------->| CON PUT /path M:0x03 T:0xf2 RT=10 QB1:2/1/1024
    [[NSTART(3) limit reached]]
       |<---------+ ACK 0.00 M:0x01
       +--------->| CON PUT /path M:0x04 T:0xf3 RT=10 QB1:3/0/1024
       |<---------+ ACK 0.00 M:0x02
       |<---------+ ACK 0.00 M:0x03
       |<---------+ ACK 2.04 M:0x04
       |          |
:::

[Figure 16](#figure-16){.selfRef}: [Example of a CON Request with the
Q-Block1 Option (without
Loss)](#name-example-of-a-con-request-wi){.selfRef}
:::

Now, suppose that a new body of data is to be sent but with some blocks
dropped in transmission, as illustrated in [Figure 17](#con32){.xref}.
The client will retry sending blocks for which no ACK was
received.[¶](#appendix-A.1-3){.pilcrow}

[]{#name-example-of-a-con-request-wit}

::: {#con32}
::: {#appendix-A.1-4.1 .alignLeft .art-ascii-art .art-text .artwork}
      CoAP        CoAP
     Client      Server
       |          |
       +--------->| CON PUT /path M:0x05 T:0xf4 RT=11 QB1:0/1/1024
       +--->X     | CON PUT /path M:0x06 T:0xf5 RT=11 QB1:1/1/1024
       +--->X     | CON PUT /path M:0x07 T:0xf6 RT=11 QB1:2/1/1024
    [[NSTART(3) limit reached]]
       |<---------+ ACK 0.00 M:0x05
       +--------->| CON PUT /path M:0x08 T:0xf7 RT=11 QB1:3/1/1024
       |<---------+ ACK 0.00 M:0x08
       |   ...    |
    [[ACK TIMEOUT (client) for M:0x06 delay expires]]
       |     [[Client retransmits packet]]
       +--------->| CON PUT /path M:0x06 T:0xf5 RT=11 QB1:1/1/1024
    [[ACK TIMEOUT (client) for M:0x07 delay expires]]
       |     [[Client retransmits packet]]
       +--->X     | CON PUT /path M:0x07 T:0xf6 RT=11 QB1:2/1/1024
       |<---------+ ACK 0.00 M:0x06
       |   ...    |
    [[ACK TIMEOUT exponential backoff (client) delay expires]]
       |     [[Client retransmits packet]]
       +--->X     | CON PUT /path M:0x07 T:0xf6 RT=11 QB1:2/1/1024
       |   ...    |
    [[Either body transmission failure (acknowledge retry timeout)
       or successfully transmitted]]
:::

[Figure 17](#figure-17){.selfRef}: [Example of a CON Request with the
Q-Block1 Option (Block
Recovery)](#name-example-of-a-con-request-wit){.selfRef}
:::

It is up to the implementation as to whether the application process
stops trying to send this particular body of data on reaching
MAX_RETRANSMIT for any payload or separately tries to initiate the new
transmission of the payloads that have not been acknowledged under these
adverse traffic conditions.[¶](#appendix-A.1-5){.pilcrow}

If transient network losses are possible, then the use of NON should be
considered.[¶](#appendix-A.1-6){.pilcrow}
:::

::: {#appendix-A.2 .section}
### [A.2.](#appendix-A.2){.section-number .selfRef} [Q-Block2 Option](#name-q-block2-option-2){.section-name .selfRef} {#name-q-block2-option-2}

An example of the use of the Q-Block2 option with Confirmable messages
is shown in [Figure 18](#b4con){.xref}.[¶](#appendix-A.2-1){.pilcrow}

[]{#name-example-of-con-notification}

::: {#b4con}
::: {#appendix-A.2-2.1 .alignLeft .art-ascii-art .art-text .artwork}
     Client      Server
       |          |
       +--------->| CON GET /path M:0x01 T:0xf0 O:0 QB2:0/1/1024
       |<---------+ ACK 2.05 M:0x01 T:0xf0 O:1234 ET=21 QB2:0/1/1024
       |<---------+ CON 2.05 M:0xe1 T:0xf0 O:1234 ET=21 QB2:1/1/1024
       |<---------+ CON 2.05 M:0xe2 T:0xf0 O:1234 ET=21 QB2:2/1/1024
       |<---------+ CON 2.05 M:0xe3 T:0xf0 O:1234 ET=21 QB2:3/0/1024
       |--------->+ ACK 0.00 M:0xe1
       |--------->+ ACK 0.00 M:0xe2
       |--------->+ ACK 0.00 M:0xe3
       |   ...    |
       |     [[Observe triggered]]
       |<---------+ CON 2.05 M:0xe4 T:0xf0 O:1235 ET=22 QB2:0/1/1024
       |<---------+ CON 2.05 M:0xe5 T:0xf0 O:1235 ET=22 QB2:1/1/1024
       |<---------+ CON 2.05 M:0xe6 T:0xf0 O:1235 ET=22 QB2:2/1/1024
    [[NSTART(3) limit reached]]
       |--------->+ ACK 0.00 M:0xe4
       |<---------+ CON 2.05 M:0xe7 T:0xf0 O:1235 ET=22 QB2:3/0/1024
       |--------->+ ACK 0.00 M:0xe5
       |--------->+ ACK 0.00 M:0xe6
       |--------->+ ACK 0.00 M:0xe7
       |   ...    |
       |     [[Observe triggered]]
       |<---------+ CON 2.05 M:0xe8 T:0xf0 O:1236 ET=23 QB2:0/1/1024
       |     X<---+ CON 2.05 M:0xe9 T:0xf0 O:1236 ET=23 QB2:1/1/1024
       |     X<---+ CON 2.05 M:0xea T:0xf0 O:1236 ET=23 QB2:2/1/1024
    [[NSTART(3) limit reached]]
       |--------->+ ACK 0.00 M:0xe8
       |<---------+ CON 2.05 M:0xeb T:0xf0 O:1236 ET=23 QB2:3/0/1024
       |--------->+ ACK 0.00 M:0xeb
       |   ...    |
    [[ACK TIMEOUT (server) for M:0xe9 delay expires]]
       |     [[Server retransmits packet]]
       |<---------+ CON 2.05 M:0xe9 T:0xf0 O:1236 ET=23 QB2:1/1/1024
    [[ACK TIMEOUT (server) for M:0xea delay expires]]
       |     [[Server retransmits packet]]
       |     X<---+ CON 2.05 M:0xea T:0xf0 O:1236 ET=23 QB2:2/1/1024
       |--------->+ ACK 0.00 M:0xe9
       |   ...    |
    [[ACK TIMEOUT exponential backoff (server) delay expires]]
       |     [[Server retransmits packet]]
       |     X<---+ CON 2.05 M:0xea T:0xf0 O:1236 ET=23 QB2:2/1/1024
       |   ...    |
    [[Either body transmission failure (acknowledge retry timeout)
       or successfully transmitted]]
:::

[Figure 18](#figure-18){.selfRef}: [Example of CON Notifications with
the Q-Block2 Option](#name-example-of-con-notification){.selfRef}
:::

It is up to the implementation as to whether the application process
stops trying to send this particular body of data on reaching
MAX_RETRANSMIT for any payload or separately tries to initiate the new
transmission of the payloads that have not been acknowledged under these
adverse traffic conditions.[¶](#appendix-A.2-3){.pilcrow}

If transient network losses are possible, then the use of NON should be
considered.[¶](#appendix-A.2-4){.pilcrow}
:::
:::
:::

::: {#REL}
::: {#appendix-B .section}
## [Appendix B.](#appendix-B){.section-number .selfRef} [Examples with Reliable Transports](#name-examples-with-reliable-tran){.section-name .selfRef} {#name-examples-with-reliable-tran}

The conventions provided in [Section 10](#non-confirm){.xref} are used
in the following subsections.[¶](#appendix-B-1){.pilcrow}

::: {#appendix-B.1 .section}
### [B.1.](#appendix-B.1){.section-number .selfRef} [Q-Block1 Option](#name-q-block1-option-3){.section-name .selfRef} {#name-q-block1-option-3}

Let\'s now consider the use of the Q-Block1 option with a reliable
transport, as shown in [Figure 19](#rel3){.xref}. There is no
acknowledgment of packets at the CoAP layer, just the final
result.[¶](#appendix-B.1-1){.pilcrow}

[]{#name-example-of-a-reliable-reque}

::: {#rel3}
::: {#appendix-B.1-2.1 .alignLeft .art-ascii-art .art-text .artwork}
     CoAP        CoAP
    Client      Server
      |          |
      +--------->| PUT /path T:0xf0 RT=10 QB1:0/1/1024
      +--------->| PUT /path T:0xf1 RT=10 QB1:1/1/1024
      +--------->| PUT /path T:0xf2 RT=10 QB1:2/1/1024
      +--------->| PUT /path T:0xf3 RT=10 QB1:3/0/1024
      |<---------+ 2.04
      |          |
:::

[Figure 19](#figure-19){.selfRef}: [Example of a Reliable Request with
the Q-Block1 Option](#name-example-of-a-reliable-reque){.selfRef}
:::

If transient network losses are possible, then the use of unreliable
transport with NON should be considered.[¶](#appendix-B.1-3){.pilcrow}
:::

::: {#appendix-B.2 .section}
### [B.2.](#appendix-B.2){.section-number .selfRef} [Q-Block2 Option](#name-q-block2-option-3){.section-name .selfRef} {#name-q-block2-option-3}

An example of the use of the Q-Block2 option with a reliable transport
is shown in [Figure 20](#b4rel){.xref}.[¶](#appendix-B.2-1){.pilcrow}

[]{#name-example-of-notifications-wi}

::: {#b4rel}
::: {#appendix-B.2-2.1 .alignLeft .art-ascii-art .art-text .artwork}
    Client      Server
      |          |
      +--------->| GET /path T:0xf0 O:0 QB2:0/1/1024
      |<---------+ 2.05 T:0xf0 O:1234 ET=21 QB2:0/1/1024
      |<---------+ 2.05 T:0xf0 O:1234 ET=21 QB2:1/1/1024
      |<---------+ 2.05 T:0xf0 O:1234 ET=21 QB2:2/1/1024
      |<---------+ 2.05 T:0xf0 O:1234 ET=21 QB2:3/0/1024
      |   ...    |
      |     [[Observe triggered]]
      |<---------+ 2.05 T:0xf0 O:1235 ET=22 QB2:0/1/1024
      |<---------+ 2.05 T:0xf0 O:1235 ET=22 QB2:1/1/1024
      |<---------+ 2.05 T:0xf0 O:1235 ET=22 QB2:2/1/1024
      |<---------+ 2.05 T:0xf0 O:1235 ET=22 QB2:3/0/1024
      |   ...    |
:::

[Figure 20](#figure-20){.selfRef}: [Example of Notifications with the
Q-Block2 Option](#name-example-of-notifications-wi){.selfRef}
:::

If transient network losses are possible, then the use of unreliable
transport with NON should be considered.[¶](#appendix-B.2-3){.pilcrow}
:::
:::
:::

::: {#appendix-C .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

Thanks to [Achim Kraus]{.contact-name}, [Jim Schaad]{.contact-name}, and
[Michael Richardson]{.contact-name} for their
comments.[¶](#appendix-C-1){.pilcrow}

Special thanks to [Christian Amsüss]{.contact-name}, [Carsten
Bormann]{.contact-name}, and [Marco Tiloca]{.contact-name} for their
suggestions and several reviews, which improved this specification
significantly. Thanks to [Francesca Palombini]{.contact-name} for the AD
review. Thanks to [Pete Resnick]{.contact-name} for the Gen-ART review,
[Colin Perkins]{.contact-name} for the TSVART review, and [Emmanuel
Baccelli]{.contact-name} for the IOT-DIR review. Thanks to [Martin
Duke]{.contact-name}, [Éric Vyncke]{.contact-name}, [Benjamin
Kaduk]{.contact-name}, [Roman Danyliw]{.contact-name}, [John
Scudder]{.contact-name}, and [Lars Eggert]{.contact-name} for the IESG
review.[¶](#appendix-C-2){.pilcrow}

Some text from \[[RFC7959](#RFC7959){.xref}\] is reused for the
readers\' convenience.[¶](#appendix-C-3){.pilcrow}
:::

::: {#authors-addresses}
::: {#appendix-D .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Mohamed Boucadair]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Orange]{.org}
:::

::: {.left dir="auto"}
[35000]{.postal-code} [Rennes]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <mohamed.boucadair@orange.com>
:::

::: {.left dir="auto"}
[Jon Shallow]{.fn .nameRole}
:::

::: {.left dir="auto"}
[United Kingdom]{.country-name}
:::

::: email
Email: <supjps-ietf@jpshallow.com>
:::
:::
:::
