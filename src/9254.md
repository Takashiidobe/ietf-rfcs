  RFC 9254            CBOR Encoding of Data Modeled with YANG   July 2022
  ------------------- ----------------------------------------- -----------
  Veillette, et al.   Standards Track                           \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9254](https://www.rfc-editor.org/rfc/rfc9254){.eref}

Category:
:   Standards Track

Published:
:   July 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    M. Veillette, [Ed.]{.editor}
    :::

    ::: org
    Trilliant Networks Inc.
    :::
    :::

    ::: author
    ::: author-name
    I. Petrov, [Ed.]{.editor}
    :::

    ::: org
    Google Switzerland GmbH
    :::
    :::

    ::: author
    ::: author-name
    A. Pelov
    :::

    ::: org
    Acklio
    :::
    :::

    ::: author
    ::: author-name
    C. Bormann
    :::

    ::: org
    Universität Bremen TZI
    :::
    :::

    ::: author
    ::: author-name
    M. Richardson
    :::

    ::: org
    Sandelman Software Works
    :::
    :::
:::

# RFC 9254 {#rfcnum}

# Encoding of Data Modeled with YANG in the Concise Binary Object Representation (CBOR) {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

YANG (RFC 7950) is a data modeling language used to model configuration
data, state data, parameters and results of Remote Procedure Call (RPC)
operations or actions, and
notifications.[¶](#section-abstract-1){.pilcrow}

This document defines encoding rules for YANG in the Concise Binary
Object Representation (CBOR) (RFC
8949).[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9254>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology and
    Notation](#name-terminology-and-notation){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Properties of the CBOR
    Encoding](#name-properties-of-the-cbor-enco){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [CBOR Diagnostic
        Notation](#name-cbor-diagnostic-notation){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [YANG Schema Item
        iDentifier](#name-yang-schema-item-identifier){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Name](#name-name){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Encoding of Representation
    Nodes](#name-encoding-of-representation-){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [The
        \'leaf\'](#name-the-leaf){.xref}

        -   ::: {#section-toc.1-1.4.2.1.2.1}
            [4.1.1](#section-4.1.1){.xref}.  [Using SIDs in
            Keys](#name-using-sids-in-keys){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.2}
            [4.1.2](#section-4.1.2){.xref}.  [Using Names in
            Keys](#name-using-names-in-keys){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [The \'container\' and Other Nodes
        from the Data Tree](#name-the-container-and-other-nod){.xref}

        -   ::: {#section-toc.1-1.4.2.2.2.1}
            [4.2.1](#section-4.2.1){.xref}.  [Using SIDs in
            Keys](#name-using-sids-in-keys-2){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.2}
            [4.2.2](#section-4.2.2){.xref}.  [Using Names in
            Keys](#name-using-names-in-keys-2){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [The
        \'leaf-list\'](#name-the-leaf-list){.xref}

        -   ::: {#section-toc.1-1.4.2.3.2.1}
            [4.3.1](#section-4.3.1){.xref}.  [Using SIDs in
            Keys](#name-using-sids-in-keys-3){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.2}
            [4.3.2](#section-4.3.2){.xref}.  [Using Names in
            Keys](#name-using-names-in-keys-3){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [The \'list\' and the \'list\'
        Entries](#name-the-list-and-the-list-entri){.xref}

        -   ::: {#section-toc.1-1.4.2.4.2.1}
            [4.4.1](#section-4.4.1){.xref}.  [Using SIDs in
            Keys](#name-using-sids-in-keys-4){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.2}
            [4.4.2](#section-4.4.2){.xref}.  [Using Names in
            Keys](#name-using-names-in-keys-4){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [The
        \'anydata\'](#name-the-anydata){.xref}

        -   ::: {#section-toc.1-1.4.2.5.2.1}
            [4.5.1](#section-4.5.1){.xref}.  [Using SIDs in
            Keys](#name-using-sids-in-keys-5){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.2}
            [4.5.2](#section-4.5.2){.xref}.  [Using Names in
            Keys](#name-using-names-in-keys-5){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.6}
        [4.6](#section-4.6){.xref}.  [The
        \'anyxml\'](#name-the-anyxml){.xref}

        -   ::: {#section-toc.1-1.4.2.6.2.1}
            [4.6.1](#section-4.6.1){.xref}.  [Using SIDs in
            Keys](#name-using-sids-in-keys-6){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.6.2.2}
            [4.6.2](#section-4.6.2){.xref}.  [Using Names in
            Keys](#name-using-names-in-keys-6){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Encoding of the \'yang-data\'
    Extension](#name-encoding-of-the-yang-data-e){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Using SIDs in
        Keys](#name-using-sids-in-keys-7){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Using Names in
        Keys](#name-using-names-in-keys-7){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Representing YANG Data Types in
    CBOR](#name-representing-yang-data-type){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [The Unsigned Integer
        Types](#name-the-unsigned-integer-types){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [The Integer
        Types](#name-the-integer-types){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [The \'decimal64\'
        Type](#name-the-decimal64-type){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [The \'string\'
        Type](#name-the-string-type){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.5}
        [6.5](#section-6.5){.xref}.  [The \'boolean\'
        Type](#name-the-boolean-type){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.6}
        [6.6](#section-6.6){.xref}.  [The \'enumeration\'
        Type](#name-the-enumeration-type){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.7}
        [6.7](#section-6.7){.xref}.  [The \'bits\'
        Type](#name-the-bits-type){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.8}
        [6.8](#section-6.8){.xref}.  [The \'binary\'
        Type](#name-the-binary-type){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.9}
        [6.9](#section-6.9){.xref}.  [The \'leafref\'
        Type](#name-the-leafref-type){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.10}
        [6.10](#section-6.10){.xref}. [The \'identityref\'
        Type](#name-the-identityref-type){.xref}

        -   ::: {#section-toc.1-1.6.2.10.2.1}
            [6.10.1](#section-6.10.1){.xref}.  [SIDs as
            \'identityref\'](#name-sids-as-identityref){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.10.2.2}
            [6.10.2](#section-6.10.2){.xref}.  [Name as
            \'identityref\'](#name-name-as-identityref){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.6.2.11}
        [6.11](#section-6.11){.xref}. [The \'empty\'
        Type](#name-the-empty-type){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.12}
        [6.12](#section-6.12){.xref}. [The \'union\'
        Type](#name-the-union-type){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.13}
        [6.13](#section-6.13){.xref}. [The \'instance-identifier\'
        Type](#name-the-instance-identifier-typ){.xref}

        -   ::: {#section-toc.1-1.6.2.13.2.1}
            [6.13.1](#section-6.13.1){.xref}.  [SIDs as
            \'instance-identifier\'](#name-sids-as-instance-identifier){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.13.2.2}
            [6.13.2](#section-6.13.2){.xref}.  [Names as
            \'instance-identifier\'](#name-names-as-instance-identifie){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Content-Types](#name-content-types){.xref}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Media Types
        Registry](#name-media-types-registry){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [CoAP Content-Formats
        Registry](#name-coap-content-formats-regist){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.3}
        [9.3](#section-9.3){.xref}.  [CBOR Tags
        Registry](#name-cbor-tags-registry){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.10.2.1}
        [10.1](#section-10.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [10.2](#section-10.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [](#appendix-A){.xref}[Acknowledgments](#name-acknowledgments){.xref}
    :::

-   ::: {#section-toc.1-1.12}
    [](#appendix-B){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The specification of the YANG 1.1 data modeling language
\[[RFC7950](#RFC7950){.xref}\] defines an XML encoding for data
instances, i.e., contents of configuration datastores, state data, RPC
inputs and outputs, action inputs and outputs, and event
notifications.[¶](#section-1-1){.pilcrow}

An additional set of encoding rules has been defined in
\[[RFC7951](#RFC7951){.xref}\] based on \"The JavaScript Object Notation
(JSON) Data Interchange Format\"
\[[RFC8259](#RFC8259){.xref}\].[¶](#section-1-2){.pilcrow}

The aim of this document is to define a set of encoding rules for the
Concise Binary Object Representation (CBOR)
\[[RFC8949](#RFC8949){.xref}\], collectively called \"YANG-CBOR\". The
resulting encoding is more compact compared to XML and JSON and more
suitable for constrained nodes and/or constrained networks, as defined
by \[[RFC7228](#RFC7228){.xref}\].[¶](#section-1-3){.pilcrow}
:::
:::

::: {#terminology-and-notation}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology and Notation](#name-terminology-and-notation){.section-name .selfRef} {#name-terminology-and-notation}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}

SID values (and the SID deltas computed from them) shown in the examples
are example values; these examples do not allocate the SIDs shown for
specific items in the modules.[¶](#section-2-2){.pilcrow}

The following terms are defined in
\[[RFC7950](#RFC7950){.xref}\]:[¶](#section-2-3){.pilcrow}

-   [action[¶](#section-2-4.1){.pilcrow}]{#section-2-4.1}
-   [anydata[¶](#section-2-4.2){.pilcrow}]{#section-2-4.2}
-   [anyxml[¶](#section-2-4.3){.pilcrow}]{#section-2-4.3}
-   [data node[¶](#section-2-4.4){.pilcrow}]{#section-2-4.4}
-   [data tree[¶](#section-2-4.5){.pilcrow}]{#section-2-4.5}
-   [datastore[¶](#section-2-4.6){.pilcrow}]{#section-2-4.6}
-   [feature[¶](#section-2-4.7){.pilcrow}]{#section-2-4.7}
-   [identity[¶](#section-2-4.8){.pilcrow}]{#section-2-4.8}
-   [module[¶](#section-2-4.9){.pilcrow}]{#section-2-4.9}
-   [notification[¶](#section-2-4.10){.pilcrow}]{#section-2-4.10}
-   [RPC[¶](#section-2-4.11){.pilcrow}]{#section-2-4.11}
-   [schema node[¶](#section-2-4.12){.pilcrow}]{#section-2-4.12}
-   [submodule[¶](#section-2-4.13){.pilcrow}]{#section-2-4.13}

The following term is defined in
\[[RFC8040](#RFC8040){.xref}\]:[¶](#section-2-5){.pilcrow}

-   [yang-data extension[¶](#section-2-6.1){.pilcrow}]{#section-2-6.1}

The following term is defined in
\[[RFC8791](#RFC8791){.xref}\]:[¶](#section-2-7){.pilcrow}

-   [YANG data structure[¶](#section-2-8.1){.pilcrow}]{#section-2-8.1}

This specification also makes use of the following
terminology:[¶](#section-2-9){.pilcrow}

[]{.break}

YANG Schema Item iDentifier (or \"YANG SID\" or simply \"SID\"):
:   63-bit unsigned integer used to identify different YANG
    items.[¶](#section-2-10.2){.pilcrow}
:   

delta:
:   Difference between the current YANG SID and a reference YANG SID. A
    reference YANG SID is defined for each context for which deltas are
    used.[¶](#section-2-10.4){.pilcrow}
:   

absolute SID:
:   A YANG SID that is not encoded as a delta. This is usually called
    out explicitly only in positions where normally a delta would be
    found.[¶](#section-2-10.6){.pilcrow}
:   

representation tree:
:   A YANG data tree, possibly enclosed by a representation of a schema
    node, such as a YANG data structure, a notification, an RPC, or an
    action.[¶](#section-2-10.8){.pilcrow}
:   

representation node:
:   A node in a representation tree, i.e., a data tree node, or a
    representation of a schema node, such as a YANG data structure, a
    notification, an RPC, or an action.[¶](#section-2-10.10){.pilcrow}
:   

item:
:   A schema node, an identity, a module, or a feature defined using the
    YANG modeling language.[¶](#section-2-10.12){.pilcrow}
:   

list entry:
:   The data associated with a single entry of a list (see [Section
    7.8](https://www.rfc-editor.org/rfc/rfc7950#section-7.8){.relref} of
    \[[RFC7950](#RFC7950){.xref}\]).[¶](#section-2-10.14){.pilcrow}
:   

container-like instance:
:   An instance of a container, a YANG data structure, notification
    contents, RPC input, RPC output, action input, or action output
    ([Section 4.2](#container){.xref}); a list entry in a list ([Section
    4.4](#list){.xref}); or an anydata node ([Section
    4.5](#the-anydata){.xref}).[¶](#section-2-10.16){.pilcrow}
:   

parent (of a representation node):
:   The schema node of the closest enclosing representation node in
    which a given representation node is
    defined.[¶](#section-2-10.18){.pilcrow}
:   
:::
:::

::: {#properties-of-cbor-encoding}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Properties of the CBOR Encoding](#name-properties-of-the-cbor-enco){.section-name .selfRef} {#name-properties-of-the-cbor-enco}

This document defines CBOR encoding rules for YANG data trees and their
subtrees.[¶](#section-3-1){.pilcrow}

A YANG data tree can be enclosed by a representation of a schema node,
such as a YANG data structure, a notification, an RPC, or an action;
this is called a representation tree. The data tree nodes and the
enclosing schema node representation, if any, are collectively called
the representation nodes.[¶](#section-3-2){.pilcrow}

A representation node, such as a container, list entry, YANG data
structure, notification, RPC input, RPC output, action input, action
output, or anydata node, is serialized using a CBOR map in which each
schema node defined within is encoded using a key and a value. This
specification supports two types of CBOR keys: YANG Schema Item
iDentifier (YANG SID), as defined in [Section 3.2](#sid){.xref}, and
names, as defined in [Section 3.3](#name){.xref}. Each of these key
types is encoded using a specific CBOR type that allows their
interpretation during the deserialization process. Protocols or
mechanisms implementing this specification can mandate the use of a
specific key type or allow the generator to choose freely per
key.[¶](#section-3-3){.pilcrow}

In order to minimize the size of the encoded data, the mapping avoids
any unnecessary meta-information beyond that directly provided by the
CBOR basic generic data model ([Section
2](https://www.rfc-editor.org/rfc/rfc8949#section-2){.relref} of
\[[RFC8949](#RFC8949){.xref}\]). For instance, CBOR tags are used solely
in the case of an absolute SID, anyxml data nodes, or the union datatype
to explicitly distinguish the use of different YANG datatypes encoded
using the same CBOR major type.[¶](#section-3-4){.pilcrow}

Unless specified otherwise by the protocol or mechanism implementing
this specification, the indefinite length encoding, as defined in
[Section
3.2](https://www.rfc-editor.org/rfc/rfc8949#section-3.2){.relref} of
\[[RFC8949](#RFC8949){.xref}\], [SHALL]{.bcp14} be supported by the CBOR
decoders employed with YANG-CBOR. (This enables an implementation to
begin emitting an array or map before the number of entries in that
structure is known, possibly also avoiding excessive locking or race
conditions. On the other hand, it deprives the receiver of the encoded
data from advance announcement about some size information, so a
generator should choose indefinite length encoding only when these
benefits do accrue.)[¶](#section-3-5){.pilcrow}

Data nodes implemented using a CBOR array, map, byte string, or text
string can be instantiated but empty. In this case, they are encoded
with a length of zero.[¶](#section-3-6){.pilcrow}

When representation nodes are serialized using the rules defined by this
specification as part of an application payload, the payload
[SHOULD]{.bcp14} include information that would allow each node to be
identified in a stateless way, for instance, the SID number associated
with the node, the SID delta from another SID in the application
payload, the namespace-qualified name, or the
instance-identifier.[¶](#section-3-7){.pilcrow}

Examples in [Section 4](#instance-encoding){.xref} include a root CBOR
map with a single entry having a key set to either a namespace-qualified
name or a SID. This root CBOR map is provided only as a typical usage
example and is not part of the present encoding rules. Only the value
within this CBOR map is compulsory.[¶](#section-3-8){.pilcrow}

::: {#cbor-diagnostic-notation}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [CBOR Diagnostic Notation](#name-cbor-diagnostic-notation){.section-name .selfRef} {#name-cbor-diagnostic-notation}

Within this document, CBOR binary contents are represented using an
equivalent textual form called CBOR diagnostic notation, as defined in
[Section 8](https://www.rfc-editor.org/rfc/rfc8949#section-8){.relref}
of \[[RFC8949](#RFC8949){.xref}\]. This notation is used strictly for
documentation purposes and is never used in the data serialization.
[Table 1](#diagnostic-notation-summary){.xref} below provides a summary
of this notation.[¶](#section-3.1-1){.pilcrow}

[]{#name-cbor-diagnostic-notation-su}

::: {#diagnostic-notation-summary}
  CBOR Content       CBOR Type   Diagnostic Notation                                                         Example              CBOR Encoding
  ------------------ ----------- --------------------------------------------------------------------------- -------------------- --------------------
  Unsigned integer   0           Decimal digits                                                              123                  18 7B
  Negative integer   1           Decimal digits prefixed by a minus sign                                     -123                 38 7A
  Byte string        2           Hexadecimal value enclosed between single quotes and prefixed by an \'h\'   h\'F15C\'            42 F15C
  Text string        3           String of Unicode characters enclosed between double quotes                 \"txt\"              63 747874
  Array              4           Comma-separated list of values within square brackets                       \[ 1, 2 \]           82 01 02
  Map                5           Comma-separated list of key : value pairs within curly braces               { 1: 123, 2: 456 }   A2 01187B 021901C8
  Boolean            7/20        false                                                                       false                F4
                     7/21        true                                                                        true                 F5
  Null               7/22        null                                                                        null                 F6
  Not assigned       7/23        undefined                                                                   undefined            F7

  : [Table 1](#table-1){.selfRef}: [CBOR Diagnostic Notation
  Summary](#name-cbor-diagnostic-notation-su){.selfRef}
:::

Note: CBOR binary contents shown in this specification are annotated
with comments. These comments are delimited by slashes (\"/\"), as
defined in [Appendix
G.6](https://www.rfc-editor.org/rfc/rfc8610#appendix-G.6){.relref} of
\[[RFC8610](#RFC8610){.xref}\].[¶](#section-3.1-3){.pilcrow}
:::
:::

::: {#sid}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [YANG Schema Item iDentifier](#name-yang-schema-item-identifier){.section-name .selfRef} {#name-yang-schema-item-identifier}

Some of the items defined in YANG \[[RFC7950](#RFC7950){.xref}\] require
the use of a unique identifier. In both the Network Configuration
Protocol (NETCONF) \[[RFC6241](#RFC6241){.xref}\] and RESTCONF
\[[RFC8040](#RFC8040){.xref}\], these identifiers are implemented using
text strings. To allow the implementation of data models defined in YANG
in constrained devices and constrained networks, a more compact method
to identify YANG items is required. This compact identifier, called
\"YANG Schema Item iDentifier\", is an unsigned integer limited to 63
bits of range (i.e., 0..9223372036854775807 or 0..0x7fffffffffffffff).
The following items are identified using YANG SIDs (often shortened to
SIDs):[¶](#section-3.2-1){.pilcrow}

-   [identities[¶](#section-3.2-2.1){.pilcrow}]{#section-3.2-2.1}
-   [data nodes[¶](#section-3.2-2.2){.pilcrow}]{#section-3.2-2.2}
-   [RPCs and associated input(s) and
    output(s)[¶](#section-3.2-2.3){.pilcrow}]{#section-3.2-2.3}
-   [actions and associated input(s) and
    output(s)[¶](#section-3.2-2.4){.pilcrow}]{#section-3.2-2.4}
-   [YANG data
    structures[¶](#section-3.2-2.5){.pilcrow}]{#section-3.2-2.5}
-   [notifications and associated
    information[¶](#section-3.2-2.6){.pilcrow}]{#section-3.2-2.6}
-   [YANG modules and
    features[¶](#section-3.2-2.7){.pilcrow}]{#section-3.2-2.7}

Note that any structuring of modules into submodules is transparent to
YANG-CBOR: SIDs are not allocated for the names of submodules, and any
items within a submodule are effectively allocated SIDs as part of
processing the module that includes them.[¶](#section-3.2-3.1){.pilcrow}

To minimize their size, SIDs used as keys in CBOR maps are encoded using
deltas, i.e., signed (negative or unsigned) integers that are added to
the reference SID applying to the map. The reference SID of an outermost
map is zero, unless a different reference SID is unambiguously conferred
from the environment in which the outermost map is used. The reference
SID of a map that is most directly embedded in a map entry with a
name-based key is zero. For all other maps, the reference SID is the SID
computed for the map entry it is most directly embedded in. (The
embedding may be indirect if an array intervenes, e.g., in a YANG list.)
Where absolute SIDs are desired in map key positions (where a bare
integer implies a delta), they need to be identified as absolute SID
values by using CBOR tag number 47 (as defined in [Section
4.2.1](#container-with-sid){.xref}).[¶](#section-3.2-4){.pilcrow}

Thus, conversion from SIDs to deltas and back to SIDs is a stateless
process solely based on the data serialized or deserialized combined
with, potentially, an outermost reference SID unambiguously conferred by
the environment.[¶](#section-3.2-5){.pilcrow}

Mechanisms and processes used to assign SIDs to YANG items and to
guarantee their uniqueness are outside the scope of the present
specification. If SIDs are to be used, the present specification is used
in conjunction with a specification defining this management. A related
document, i.e., \[[CORE-SID](#I-D.ietf-core-sid){.xref}\], is intended
to serve as the definitive way to assign SID values for YANG modules
managed by the IETF and recommends itself for YANG modules managed by
non-IETF entities, as well. The present specification has been designed
to allow different methods of assignment to be used within separate
domains.[¶](#section-3.2-6){.pilcrow}

To provide implementations with a way to internally indicate the absence
of a SID, the SID value 0 is reserved and will not be allocated; it is
not used in interchange.[¶](#section-3.2-7){.pilcrow}
:::
:::

::: {#name}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Name](#name-name){.section-name .selfRef} {#name-name}

This specification also supports the encoding of YANG item identifiers
as text strings, similar to those used by the JSON encoding of data
modeled with YANG \[[RFC7951](#RFC7951){.xref}\]. This approach can be
used to avoid the management overhead associated with SID allocation.
The main drawback is the significant increase in size of the encoded
data.[¶](#section-3.3-1){.pilcrow}

YANG item identifiers implemented using names [MUST]{.bcp14} be in one
of the following forms:[¶](#section-3.3-2){.pilcrow}

-   [simple \-- the identifier of the YANG item (i.e., schema node or
    identity).[¶](#section-3.3-3.1){.pilcrow}]{#section-3.3-3.1}
-   [namespace-qualified \-- the identifier of the YANG item is prefixed
    with the name of the module in which this item is defined, separated
    by the colon character
    (\":\").[¶](#section-3.3-3.2){.pilcrow}]{#section-3.3-3.2}

The name of a module determines the namespace of all YANG items defined
in that module. If an item is defined in a submodule, then the
namespace-qualified name uses the name of the main module to which the
submodule belongs.[¶](#section-3.3-4){.pilcrow}

ABNF syntax \[[RFC5234](#RFC5234){.xref}\] of a name is shown in [Figure
1](#namesyntax){.xref}, where the production for \"identifier\" is
defined in [Section
14](https://www.rfc-editor.org/rfc/rfc7950#section-14){.relref} of
\[[RFC7950](#RFC7950){.xref}\].[¶](#section-3.3-5){.pilcrow}

[]{#name-abnf-production-for-a-simpl}

::: {#namesyntax}
::: {#section-3.3-6.1}
``` {.lang-abnf .sourcecode}
name = [identifier ":"] identifier
```
:::

[Figure 1](#figure-1){.selfRef}: [ABNF Production for a Simple or
Namespace-Qualified Name](#name-abnf-production-for-a-simpl){.selfRef}
:::

A namespace-qualified name [MUST]{.bcp14} be used for all members of a
top-level CBOR map and then also whenever the namespaces of the
representation node and its parent node are different. In all other
cases, the simple form of the name [MUST]{.bcp14} be
used.[¶](#section-3.3-7){.pilcrow}

Definition example:[¶](#section-3.3-8){.pilcrow}

::: {#section-3.3-9}
``` {.lang-yang .sourcecode}
module example-foomod {
  container top {
    leaf foo {
      type uint8;
    }
  }
}

module example-barmod {
  import example-foomod {
    prefix "foomod";
  }
  augment "/foomod:top" {
    leaf bar {
      type boolean;
    }
  }
}
```

[¶](#section-3.3-9){.pilcrow}
:::

A valid CBOR encoding of the \'top\' container is as
follows.[¶](#section-3.3-10){.pilcrow}

CBOR diagnostic notation:[¶](#section-3.3-11){.pilcrow}

::: {#section-3.3-12}
``` {.lang-cbor-diag .sourcecode}
{
  "example-foomod:top": {
    "foo": 54,
    "example-barmod:bar": true
  }
}
```

[¶](#section-3.3-12){.pilcrow}
:::

Both the \'top\' container and the \'bar\' leaf defined in a different
YANG module as its parent container are encoded as namespace-qualified
names. The \'foo\' leaf defined in the same YANG module as its parent
container is encoded as a simple name.[¶](#section-3.3-13){.pilcrow}
:::
:::
:::
:::

::: {#instance-encoding}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Encoding of Representation Nodes](#name-encoding-of-representation-){.section-name .selfRef} {#name-encoding-of-representation-}

Representation nodes defined using the YANG modeling language are
encoded using CBOR \[[RFC8949](#RFC8949){.xref}\], based on the rules
defined in this section. We assume that the reader is already familiar
with both YANG \[[RFC7950](#RFC7950){.xref}\] and CBOR
\[[RFC8949](#RFC8949){.xref}\].[¶](#section-4-1){.pilcrow}

::: {#the-leaf}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [The \'leaf\'](#name-the-leaf){.section-name .selfRef} {#name-the-leaf}

A \'leaf\' [MUST]{.bcp14} be encoded accordingly to its datatype using
one of the encoding rules specified in [Section
6](#data-types-mapping){.xref}.[¶](#section-4.1-1){.pilcrow}

The following examples show the encoding of a \'hostname\' leaf using a
SID or a name.[¶](#section-4.1-2){.pilcrow}

Definition example adapted from \[[RFC6991](#RFC6991){.xref}\] and
\[[RFC7317](#RFC7317){.xref}\]:[¶](#section-4.1-3){.pilcrow}

::: {#section-4.1-4}
``` {.lang-yang .sourcecode}
typedef domain-name {
  type string {
    pattern
      '((([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.)*'
    + '([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.?)'
    + '|\.';
    length "1..253";
  }
}

leaf hostname {
  type inet:domain-name;
}
```

[¶](#section-4.1-4){.pilcrow}
:::

::: {#using-sids-in-keys}
::: {#section-4.1.1 .section}
#### [4.1.1.](#section-4.1.1){.section-number .selfRef} [Using SIDs in Keys](#name-using-sids-in-keys){.section-name .selfRef} {#name-using-sids-in-keys}

As with all examples below, the delta in the outermost map assumes a
reference YANG SID (current schema node) of
0.[¶](#section-4.1.1-1){.pilcrow}

CBOR diagnostic notation:[¶](#section-4.1.1-2){.pilcrow}

::: {#section-4.1.1-3}
``` {.lang-cbor-diag .sourcecode}
{
  1752 : "myhost.example.com"     / hostname (SID 1752) /
}
```

[¶](#section-4.1.1-3){.pilcrow}
:::

CBOR encoding:[¶](#section-4.1.1-4){.pilcrow}

::: {#section-4.1.1-5}
``` {.lang-cbor-pretty .sourcecode}
A1                                         # map(1)
   19 06D8                                 # unsigned(1752)
   72                                      # text(18)
      6D79686F73742E6578616D706C652E636F6D # "myhost.example.com"
```

[¶](#section-4.1.1-5){.pilcrow}
:::
:::
:::

::: {#using-names-in-keys}
::: {#section-4.1.2 .section}
#### [4.1.2.](#section-4.1.2){.section-number .selfRef} [Using Names in Keys](#name-using-names-in-keys){.section-name .selfRef} {#name-using-names-in-keys}

CBOR diagnostic notation:[¶](#section-4.1.2-1){.pilcrow}

::: {#section-4.1.2-2}
``` {.lang-cbor-diag .sourcecode}
{
  "ietf-system:hostname" : "myhost.example.com"
}
```

[¶](#section-4.1.2-2){.pilcrow}
:::

CBOR encoding:[¶](#section-4.1.2-3){.pilcrow}

::: {#section-4.1.2-4}
``` {.lang-cbor-pretty .sourcecode}
A1                                         # map(1)
   74                                      # text(20)
      696574662D73797374656D3A686F73746E616D65
   72                                      # text(18)
      6D79686F73742E6578616D706C652E636F6D
```

[¶](#section-4.1.2-4){.pilcrow}
:::
:::
:::
:::
:::

::: {#container}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [The \'container\' and Other Nodes from the Data Tree](#name-the-container-and-other-nod){.section-name .selfRef} {#name-the-container-and-other-nod}

Instances of containers, YANG data structures, notification contents,
RPC inputs, RPC outputs, action inputs, and action outputs
[MUST]{.bcp14} be encoded using a CBOR map data item (major type 5). The
same encoding is also used for the list entries in a list ([Section
4.4](#list){.xref}) and for anydata nodes ([Section
4.5](#the-anydata){.xref}). Collectively, we speak of these instances as
\"container-like instances\".[¶](#section-4.2-1){.pilcrow}

A map consists of pairs of data items, with each pair consisting of a
key and a value. Each key within the CBOR map is set to a schema node
identifier, and each value is set to the value of this representation
node according to the instance datatype.[¶](#section-4.2-2){.pilcrow}

This specification supports two types of CBOR map keys: SID, as defined
in [Section 3.2](#sid){.xref}, and names, as defined in [Section
3.3](#name){.xref}.[¶](#section-4.2-3){.pilcrow}

The following examples show the encoding of a \'system-state\' container
representation instance using SIDs or
names.[¶](#section-4.2-4){.pilcrow}

Definition example adapted from \[[RFC6991](#RFC6991){.xref}\] and
\[[RFC7317](#RFC7317){.xref}\]:[¶](#section-4.2-5){.pilcrow}

::: {#section-4.2-6}
``` {.lang-yang .sourcecode}
typedef date-and-time {
  type string {
    pattern '\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?'
          + '(Z|[\+\-]\d{2}:\d{2})';
  }
}

container system-state {

  container clock {
    leaf current-datetime {
      type date-and-time;
    }

    leaf boot-datetime {
      type date-and-time;
    }
  }
}
```

[¶](#section-4.2-6){.pilcrow}
:::

::: {#container-with-sid}
::: {#section-4.2.1 .section}
#### [4.2.1.](#section-4.2.1){.section-number .selfRef} [Using SIDs in Keys](#name-using-sids-in-keys-2){.section-name .selfRef} {#name-using-sids-in-keys-2}

In the context of containers and other nodes from the data tree, CBOR
map keys within inner CBOR maps can be encoded using deltas (bare
integers) or absolute SIDs (tagged with tag number
47).[¶](#section-4.2.1-1){.pilcrow}

Delta values are computed as follows:[¶](#section-4.2.1-2){.pilcrow}

-   [In the case of a \'container\', deltas are equal to the SID of the
    current representation node minus the SID of the parent
    \'container\'.[¶](#section-4.2.1-3.1){.pilcrow}]{#section-4.2.1-3.1}
-   [In the case of a \'list\', deltas are equal to the SID of the
    current representation node minus the SID of the parent
    \'list\'.[¶](#section-4.2.1-3.2){.pilcrow}]{#section-4.2.1-3.2}
-   [In the case of an \'RPC input\' or \'RPC output\', deltas are equal
    to the SID of the current representation node minus the SID of the
    \'RPC\'.[¶](#section-4.2.1-3.3){.pilcrow}]{#section-4.2.1-3.3}
-   [In the case of an \'action input\' or \'action output\', deltas are
    equal to the SID of the current representation node minus the SID of
    the
    \'action\'.[¶](#section-4.2.1-3.4){.pilcrow}]{#section-4.2.1-3.4}
-   [In the case of a \'notification content\', deltas are equal to the
    SID of the current representation node minus the SID of the
    \'notification\'.[¶](#section-4.2.1-3.5){.pilcrow}]{#section-4.2.1-3.5}

CBOR diagnostic notation:[¶](#section-4.2.1-4){.pilcrow}

::: {#section-4.2.1-5}
``` {.lang-cbor-diag .sourcecode}
{
  1720 : {                              / system-state (SID 1720) /
    1 : {                               / clock  (SID 1721) /
      2 : "2015-10-02T14:47:24Z-05:00", / current-datetime(SID 1723)/
      1 : "2015-09-15T09:12:58Z-05:00"  / boot-datetime (SID 1722) /
    }
  }
}
```

[¶](#section-4.2.1-5){.pilcrow}
:::

CBOR encoding:[¶](#section-4.2.1-6){.pilcrow}

[]{#name-system-state-clock-encoding}

::: {#Fig-system-clock}
::: {#section-4.2.1-7.1}
``` {.lang-cbor-pretty .sourcecode}
A1                                      # map(1)
   19 06B8                              # unsigned(1720)
   A1                                   # map(1)
      01                                # unsigned(1)
      A2                                # map(2)
         02                             # unsigned(2)
         78 1A                          # text(26)
            323031352D31302D30325431343A34373A32345A2D30353A3030
         01                             # unsigned(1)
         78 1A                          # text(26)
            323031352D30392D31355430393A31323A35385A2D30353A3030
```
:::

[Figure 2](#figure-2){.selfRef}: [System State Clock
Encoding](#name-system-state-clock-encoding){.selfRef}
:::
:::
:::

::: {#container-with-name}
::: {#section-4.2.2 .section}
#### [4.2.2.](#section-4.2.2){.section-number .selfRef} [Using Names in Keys](#name-using-names-in-keys-2){.section-name .selfRef} {#name-using-names-in-keys-2}

CBOR map keys implemented using names [MUST]{.bcp14} be encoded using a
CBOR text string data item (major type 3). A namespace-qualified name
[MUST]{.bcp14} be used each time the namespace of a representation node
and its parent differ. In all other cases, the simple form of the name
[MUST]{.bcp14} be used. Names and namespaces are defined in [Section
4](https://www.rfc-editor.org/rfc/rfc7951#section-4){.relref} of
\[[RFC7951](#RFC7951){.xref}\].[¶](#section-4.2.2-1){.pilcrow}

The following example shows the encoding of a \'system\' container
representation node instance using names.[¶](#section-4.2.2-2){.pilcrow}

CBOR diagnostic notation:[¶](#section-4.2.2-3){.pilcrow}

::: {#section-4.2.2-4}
``` {.lang-cbor-diag .sourcecode}
{
  "ietf-system:system-state" : {
    "clock" : {
      "current-datetime" : "2015-10-02T14:47:24Z-05:00",
      "boot-datetime" : "2015-09-15T09:12:58Z-05:00"
    }
  }
}
```

[¶](#section-4.2.2-4){.pilcrow}
:::

CBOR encoding:[¶](#section-4.2.2-5){.pilcrow}

::: {#section-4.2.2-6}
``` {.lang-cbor-pretty .sourcecode}
A1                                      # map(1)
   78 18                                # text(24)
      696574662D73797374656D3A73797374656D2D7374617465
   A1                                   # map(1)
      65                                # text(5)
         636C6F636B                     # "clock"
      A2                                # map(2)
         70                             # text(16)
            63757272656E742D6461746574696D65
         78 1A                          # text(26)
            323031352D31302D30325431343A34373A32345A2D30353A3030
         6D                             # text(13)
            626F6F742D6461746574696D65
         78 1A                          # text(26)
            323031352D30392D31355430393A31323A35385A2D30353A3030
```

[¶](#section-4.2.2-6){.pilcrow}
:::
:::
:::
:::
:::

::: {#leaf-list}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [The \'leaf-list\'](#name-the-leaf-list){.section-name .selfRef} {#name-the-leaf-list}

A leaf-list [MUST]{.bcp14} be encoded using a CBOR array data item
(major type 4). Each entry of this array [MUST]{.bcp14} be encoded
accordingly to its datatype using one of the encoding rules specified in
[Section 6](#data-types-mapping){.xref}.[¶](#section-4.3-1){.pilcrow}

The following example shows the encoding of the \'search\' leaf-list
representation node instance containing two entries: \"ietf.org\" and
\"ieee.org\".[¶](#section-4.3-2){.pilcrow}

Definition example adapted from \[[RFC6991](#RFC6991){.xref}\] and
\[[RFC7317](#RFC7317){.xref}\]:[¶](#section-4.3-3){.pilcrow}

::: {#section-4.3-4}
``` {.lang-yang .sourcecode}
typedef domain-name {
  type string {
    pattern
      '((([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.)*'
    + '([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.?)'
    + '|\.';
    length "1..253";
  }
}

leaf-list search {
  type domain-name;
  ordered-by user;
}
```

[¶](#section-4.3-4){.pilcrow}
:::

::: {#using-sids-in-keys-1}
::: {#section-4.3.1 .section}
#### [4.3.1.](#section-4.3.1){.section-number .selfRef} [Using SIDs in Keys](#name-using-sids-in-keys-3){.section-name .selfRef} {#name-using-sids-in-keys-3}

CBOR diagnostic notation:[¶](#section-4.3.1-1){.pilcrow}

::: {#section-4.3.1-2}
``` {.lang-cbor-diag .sourcecode}
{
  1746 : [ "ietf.org", "ieee.org" ]     / search (SID 1746) /
}
```

[¶](#section-4.3.1-2){.pilcrow}
:::

CBOR encoding:[¶](#section-4.3.1-3){.pilcrow}

::: {#section-4.3.1-4}
``` {.lang-cbor-pretty .sourcecode}
A1                        # map(1)
   19 06D2                # unsigned(1746)
   82                     # array(2)
      68                  # text(8)
         696574662E6F7267 # "ietf.org"
      68                  # text(8)
         696565652E6F7267 # "ieee.org"
```

[¶](#section-4.3.1-4){.pilcrow}
:::
:::
:::

::: {#using-names-in-keys-1}
::: {#section-4.3.2 .section}
#### [4.3.2.](#section-4.3.2){.section-number .selfRef} [Using Names in Keys](#name-using-names-in-keys-3){.section-name .selfRef} {#name-using-names-in-keys-3}

CBOR diagnostic notation:[¶](#section-4.3.2-1){.pilcrow}

::: {#section-4.3.2-2}
``` {.lang-cbor-diag .sourcecode}
{
  "ietf-system:search" : [ "ietf.org", "ieee.org" ]
}
```

[¶](#section-4.3.2-2){.pilcrow}
:::

CBOR encoding:[¶](#section-4.3.2-3){.pilcrow}

::: {#section-4.3.2-4}
``` {.lang-cbor-pretty .sourcecode}
A1                                         # map(1)
   72                                      # text(18)
      696574662D73797374656D3A736561726368 # "ietf-system:search"
   82                                      # array(2)
      68                                   # text(8)
         696574662E6F7267                  # "ietf.org"
      68                                   # text(8)
         696565652E6F7267                  # "ieee.org"
```

[¶](#section-4.3.2-4){.pilcrow}
:::
:::
:::
:::
:::

::: {#list}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [The \'list\' and the \'list\' Entries](#name-the-list-and-the-list-entri){.section-name .selfRef} {#name-the-list-and-the-list-entri}

A list or a subset of a list [MUST]{.bcp14} be encoded using a CBOR
array data item (major type 4). Each list entry within this CBOR array
is encoded using a CBOR map data item (major type 5) based on the
encoding rules of a container-like instance, as defined in [Section
4.2](#container){.xref}.[¶](#section-4.4-1){.pilcrow}

It is important to note that this encoding rule also applies to a
\'list\' representation node instance that has a single
entry.[¶](#section-4.4-2){.pilcrow}

The following examples show the encoding of a \'server\' list using SIDs
or names.[¶](#section-4.4-3){.pilcrow}

Definition example adapted from
\[[RFC7317](#RFC7317){.xref}\]:[¶](#section-4.4-4){.pilcrow}

::: {#section-4.4-5}
``` {.lang-yang .sourcecode}
list server {
  key name;

  leaf name {
    type string;
  }
  choice transport {
    case udp {
      container udp {
        leaf address {
          type host;
          mandatory true;
        }
        leaf port {
          type port-number;
        }
      }
    }
  }
  leaf association-type {
    type enumeration {
      enum server;
      enum peer;
      enum pool;
    }
    default server;
  }
  leaf iburst {
    type boolean;
    default false;
  }
  leaf prefer {
    type boolean;
    default false;
  }
}
```

[¶](#section-4.4-5){.pilcrow}
:::

::: {#list-with-sid}
::: {#section-4.4.1 .section}
#### [4.4.1.](#section-4.4.1){.section-number .selfRef} [Using SIDs in Keys](#name-using-sids-in-keys-4){.section-name .selfRef} {#name-using-sids-in-keys-4}

The encoding rules of each \'list\' entry are defined in [Section
4.2.1](#container-with-sid){.xref}.[¶](#section-4.4.1-1){.pilcrow}

CBOR diagnostic notation:[¶](#section-4.4.1-2){.pilcrow}

::: {#section-4.4.1-3}
``` {.lang-cbor-diag .sourcecode}
{
  1756 : [                      / server (SID 1756) /
    {
      3 : "NRC TIC server",     / name (SID 1759) /
      5 : {                     / udp (SID 1761) /
        1 : "tic.nrc.ca",       / address (SID 1762) /
        2 : 123                 / port (SID 1763) /
      },
      1 : 0,                    / association-type (SID 1757) /
      2 : false,                / iburst (SID 1758) /
      4 : true                  / prefer (SID 1760) /
    },
    {
      3 : "NRC TAC server",     / name (SID 1759) /
      5 : {                     / udp (SID 1761) /
        1 : "tac.nrc.ca"        / address (SID 1762) /
      }
    }
  ]
}
```

[¶](#section-4.4.1-3){.pilcrow}
:::

CBOR encoding:[¶](#section-4.4.1-4){.pilcrow}

::: {#section-4.4.1-5}
``` {.lang-cbor-pretty .sourcecode}
A1                                      # map(1)
   19 06DC                              # unsigned(1756)
   82                                   # array(2)
      A5                                # map(5)
         03                             # unsigned(3)
         6E                             # text(14)
            4E52432054494320736572766572 # "NRC TIC server"
         05                             # unsigned(5)
         A2                             # map(2)
            01                          # unsigned(1)
            6A                          # text(10)
               7469632E6E72632E6361     # "tic.nrc.ca"
            02                          # unsigned(2)
            18 7B                       # unsigned(123)
         01                             # unsigned(1)
         00                             # unsigned(0)
         02                             # unsigned(2)
         F4                             # primitive(20)
         04                             # unsigned(4)
         F5                             # primitive(21)
      A2                                # map(2)
         03                             # unsigned(3)
         6E                             # text(14)
            4E52432054414320736572766572 # "NRC TAC server"
         05                             # unsigned(5)
         A1                             # map(1)
            01                          # unsigned(1)
            6A                          # text(10)
               7461632E6E72632E6361     # "tac.nrc.ca"
```

[¶](#section-4.4.1-5){.pilcrow}
:::
:::
:::

::: {#using-names-in-keys-2}
::: {#section-4.4.2 .section}
#### [4.4.2.](#section-4.4.2){.section-number .selfRef} [Using Names in Keys](#name-using-names-in-keys-4){.section-name .selfRef} {#name-using-names-in-keys-4}

The encoding rules of each \'list\' entry are defined in [Section
4.2.2](#container-with-name){.xref}.[¶](#section-4.4.2-1){.pilcrow}

CBOR diagnostic notation:[¶](#section-4.4.2-2){.pilcrow}

::: {#section-4.4.2-3}
``` {.lang-cbor-diag .sourcecode}
{
  "ietf-system:server" : [
    {
      "name" : "NRC TIC server",
      "udp" : {
        "address" : "tic.nrc.ca",
        "port" : 123
      },
      "association-type" : 0,
      "iburst" : false,
      "prefer" : true
    },
    {
      "name" : "NRC TAC server",
      "udp" : {
        "address" : "tac.nrc.ca"
      }
    }
  ]
}
```

[¶](#section-4.4.2-3){.pilcrow}
:::

CBOR encoding:[¶](#section-4.4.2-4){.pilcrow}

::: {#section-4.4.2-5}
``` {.lang-cbor-pretty .sourcecode}
A1                                      # map(1)
   72                                   # text(18)
      696574662D73797374656D3A736572766572
   82                                   # array(2)
      A5                                # map(5)
         64                             # text(4)
            6E616D65                    # "name"
         6E                             # text(14)
            4E52432054494320736572766572
         63                             # text(3)
            756470                      # "udp"
         A2                             # map(2)
            67                          # text(7)
               61646472657373           # "address"
            6A                          # text(10)
               7469632E6E72632E6361     # "tic.nrc.ca"
            64                          # text(4)
               706F7274                 # "port"
            18 7B                       # unsigned(123)
         70                             # text(16)
            6173736F63696174696F6E2D74797065
         00                             # unsigned(0)
         66                             # text(6)
            696275727374                # "iburst"
         F4                             # primitive(20)
         66                             # text(6)
            707265666572                # "prefer"
         F5                             # primitive(21)
      A2                                # map(2)
         64                             # text(4)
            6E616D65                    # "name"
         6E                             # text(14)
            4E52432054414320736572766572
         63                             # text(3)
            756470                      # "udp"
         A1                             # map(1)
            67                          # text(7)
               61646472657373           # "address"
            6A                          # text(10)
               7461632E6E72632E6361     # "tac.nrc.ca"
```

[¶](#section-4.4.2-5){.pilcrow}
:::
:::
:::
:::
:::

::: {#the-anydata}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [The \'anydata\'](#name-the-anydata){.section-name .selfRef} {#name-the-anydata}

An anydata node serves as a container for an arbitrary set of
representation nodes that otherwise appear as normal YANG-modeled data.
An anydata representation node instance is encoded using the same rules
as a container, i.e., using a CBOR map data item (major type 5) based on
the encoding rules of a container-like instance, as defined in [Section
4.2](#container){.xref}.[¶](#section-4.5-1){.pilcrow}

The following example shows a possible use of an anydata node. In this
example, an anydata node is used to define a representation node
containing a notification event; this representation node can be part of
a YANG list to create an event logger.[¶](#section-4.5-2){.pilcrow}

Definition example:[¶](#section-4.5-3){.pilcrow}

::: {#section-4.5-4}
``` {.lang-yang .sourcecode}
module event-log {
  ...
  anydata last-event;                // SID 60123
}
```

[¶](#section-4.5-4){.pilcrow}
:::

This example also assumes the assistance of the following
notification.[¶](#section-4.5-5){.pilcrow}

::: {#section-4.5-6}
``` {.lang-yang .sourcecode}
module example-port {
  ...

  notification example-port-fault {  // SID 60200
    leaf port-name {                 // SID 60201
      type string;
    }
    leaf port-fault {                // SID 60202
      type string;
    }
  }
}
```

[¶](#section-4.5-6){.pilcrow}
:::

::: {#using-sids-in-keys-2}
::: {#section-4.5.1 .section}
#### [4.5.1.](#section-4.5.1){.section-number .selfRef} [Using SIDs in Keys](#name-using-sids-in-keys-5){.section-name .selfRef} {#name-using-sids-in-keys-5}

CBOR diagnostic notation:[¶](#section-4.5.1-1){.pilcrow}

::: {#section-4.5.1-2}
``` {.lang-cbor-diag .sourcecode}
{
  60123 : {                   / last-event (SID 60123) /
    77 : {                    / example-port-fault (SID 60200) /
      1 : "0/4/21",           / port-name (SID 60201) /
      2 : "Open pin 2"        / port-fault (SID 60202) /
    }
  }
}
```

[¶](#section-4.5.1-2){.pilcrow}
:::

CBOR encoding:[¶](#section-4.5.1-3){.pilcrow}

::: {#section-4.5.1-4}
``` {.lang-cbor-pretty .sourcecode}
A1                               # map(1)
   19 EADB                       # unsigned(60123)
   A1                            # map(1)
      18 4D                      # unsigned(77)
      A2                         # map(2)
         01                      # unsigned(1)
         66                      # text(6)
            302F342F3231         # "0/4/21"
         02                      # unsigned(2)
         6A                      # text(10)
            4F70656E2070696E2032 # "Open pin 2"
```

[¶](#section-4.5.1-4){.pilcrow}
:::

In some implementations, it might be simpler to use the absolute SID
encoding (tag number 47) for the anydata root element. CBOR diagnostic
notation:[¶](#section-4.5.1-5){.pilcrow}

::: {#section-4.5.1-6}
``` {.lang-cbor-diag .sourcecode}
{
  60123 : {                   / last-event (SID 60123) /
    47(60200) : {             / event-port-fault (SID 60200) /
      1 : "0/4/21",           / port-name (SID 60201) /
      2 : "Open pin 2"        / port-fault (SID 60202) /
    }
  }
}
```

[¶](#section-4.5.1-6){.pilcrow}
:::
:::
:::

::: {#using-names-in-keys-3}
::: {#section-4.5.2 .section}
#### [4.5.2.](#section-4.5.2){.section-number .selfRef} [Using Names in Keys](#name-using-names-in-keys-5){.section-name .selfRef} {#name-using-names-in-keys-5}

CBOR diagnostic notation:[¶](#section-4.5.2-1){.pilcrow}

::: {#section-4.5.2-2}
``` {.lang-cbor-diag .sourcecode}
{
  "event-log:last-event" : {
    "example-port:example-port-fault" : {
      "port-name" : "0/4/21",
      "port-fault" : "Open pin 2"
    }
  }
}
```

[¶](#section-4.5.2-2){.pilcrow}
:::

CBOR encoding:[¶](#section-4.5.2-3){.pilcrow}

::: {#section-4.5.2-4}
``` {.lang-cbor-pretty .sourcecode}
A1                                      # map(1)
   74                                   # text(20)
      6576656E742D6C6F673A6C6173742D6576656E74
   A1                                   # map(1)
      78 1F                             # text(31)
         6578616D706C652D706F72743A
         6578616D706C652D706F72742D6661756C74
      A2                                # map(2)
         69                             # text(9)
            706F72742D6E616D65          # "port-name"
         66                             # text(6)
            302F342F3231                # "0/4/21"
         6A                             # text(10)
            706F72742D6661756C74        # "port-fault"
         6A                             # text(10)
            4F70656E2070696E2032        # "Open pin 2"
```

[¶](#section-4.5.2-4){.pilcrow}
:::
:::
:::
:::
:::

::: {#the-anyxml}
::: {#section-4.6 .section}
### [4.6.](#section-4.6){.section-number .selfRef} [The \'anyxml\'](#name-the-anyxml){.section-name .selfRef} {#name-the-anyxml}

An anyxml representation node is used to serialize an arbitrary CBOR
content, i.e., its value can be any CBOR binary object. (The \"xml\" in
the name is a misnomer that only applied to YANG-XML
\[[RFC7950](#RFC7950){.xref}\].) An anyxml value [MAY]{.bcp14} contain
CBOR data items tagged with one of the tags listed in [Section
9.3](#tag-registry){.xref}. The tags listed in [Section
9.3](#tag-registry){.xref} [SHALL]{.bcp14} be
supported.[¶](#section-4.6-1){.pilcrow}

The following example shows a valid CBOR-encoded anyxml representation
node instance consisting of a CBOR array containing the CBOR simple
values \'true\', \'null\', and \'true\'.[¶](#section-4.6-2){.pilcrow}

Definition example adapted from
\[[RFC7951](#RFC7951){.xref}\]:[¶](#section-4.6-3){.pilcrow}

::: {#section-4.6-4}
``` {.lang-yang .sourcecode}
module bar-module {
  ...
  anyxml bar;      // SID 60000
}
```

[¶](#section-4.6-4){.pilcrow}
:::

::: {#using-sids-in-keys-3}
::: {#section-4.6.1 .section}
#### [4.6.1.](#section-4.6.1){.section-number .selfRef} [Using SIDs in Keys](#name-using-sids-in-keys-6){.section-name .selfRef} {#name-using-sids-in-keys-6}

CBOR diagnostic notation:[¶](#section-4.6.1-1){.pilcrow}

::: {#section-4.6.1-2}
``` {.lang-cbor-diag .sourcecode}
{
  60000 : [true, null, true]   / bar (SID 60000) /
}
```

[¶](#section-4.6.1-2){.pilcrow}
:::

CBOR encoding:[¶](#section-4.6.1-3){.pilcrow}

::: {#section-4.6.1-4}
``` {.lang-cbor-pretty .sourcecode}
A1         # map(1)
   19 EA60 # unsigned(60000)
   83      # array(3)
      F5   # primitive(21)
      F6   # primitive(22)
      F5   # primitive(21)
```

[¶](#section-4.6.1-4){.pilcrow}
:::
:::
:::

::: {#using-names-in-keys-4}
::: {#section-4.6.2 .section}
#### [4.6.2.](#section-4.6.2){.section-number .selfRef} [Using Names in Keys](#name-using-names-in-keys-6){.section-name .selfRef} {#name-using-names-in-keys-6}

CBOR diagnostic notation:[¶](#section-4.6.2-1){.pilcrow}

::: {#section-4.6.2-2}
``` {.lang-cbor-diag .sourcecode}
{
  "bar-module:bar" : [true, null, true]   / bar (SID 60000) /
}
```

[¶](#section-4.6.2-2){.pilcrow}
:::

CBOR encoding:[¶](#section-4.6.2-3){.pilcrow}

::: {#section-4.6.2-4}
``` {.lang-cbor-pretty .sourcecode}
A1                                 # map(1)
   6E                              # text(14)
      6261722D6D6F64756C653A626172 # "bar-module:bar"
   83                              # array(3)
      F5                           # primitive(21)
      F6                           # primitive(22)
      F5                           # primitive(21)
```

[¶](#section-4.6.2-4){.pilcrow}
:::
:::
:::
:::
:::
:::
:::

::: {#encoding-of-yang-data-extension}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Encoding of the \'yang-data\' Extension](#name-encoding-of-the-yang-data-e){.section-name .selfRef} {#name-encoding-of-the-yang-data-e}

The yang-data extension \[[RFC8040](#RFC8040){.xref}\] is used to define
data structures in YANG that are not intended to be implemented as part
of a datastore.[¶](#section-5-1){.pilcrow}

The yang-data extension will specify a container that [MUST]{.bcp14} be
encoded using the encoding rules of nodes of data trees, as defined in
[Section 4.2](#container){.xref}.[¶](#section-5-2){.pilcrow}

Just like YANG containers, the yang-data extension can be encoded using
either SIDs or names.[¶](#section-5-3){.pilcrow}

Definition example adapted from [Appendix
A](https://datatracker.ietf.org/doc/html/draft-ietf-core-comi-11#appendix-A){.relref}
of
\[[CORE-COMI](#I-D.ietf-core-comi){.xref}\]:[¶](#section-5-4){.pilcrow}

::: {#section-5-5}
``` {.lang-yang .sourcecode}
module ietf-coreconf {
  ...

  import ietf-restconf {
    prefix rc;
  }

  rc:yang-data yang-errors {
    container error {
      leaf error-tag {
        type identityref {
          base error-tag;
        }
      }
      leaf error-app-tag {
        type identityref {
          base error-app-tag;
        }
      }
      leaf error-data-node {
        type instance-identifier;
      }
      leaf error-message {
        type string;
      }
    }
  }
}
```

[¶](#section-5-5){.pilcrow}
:::

::: {#using-sids-in-keys-4}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Using SIDs in Keys](#name-using-sids-in-keys-7){.section-name .selfRef} {#name-using-sids-in-keys-7}

The yang-data extensions encoded using SIDs are carried in a CBOR map
containing a single item pair. The key of this item is set to the SID
assigned to the yang-data extension container; the value is set to the
CBOR encoding of this container, as defined in [Section
4.2](#container){.xref}.[¶](#section-5.1-1){.pilcrow}

This example shows a serialization example of the yang-errors yang-data
extension, as defined in \[[CORE-COMI](#I-D.ietf-core-comi){.xref}\],
using SIDs, as defined in [Section
3.2](#sid){.xref}.[¶](#section-5.1-2){.pilcrow}

CBOR diagnostic notation:[¶](#section-5.1-3){.pilcrow}

::: {#section-5.1-4}
``` {.lang-cbor-diag .sourcecode}
{
  1024 : {                      / error  (SID 1024) /
    4 : 1011,                   / error-tag (SID 1028) /
                                / = invalid-value (SID 1011) /
    1 : 1018,                   / error-app-tag (SID 1025) /
                                / = not-in-range (SID 1018) /
    2 : 1740,                   / error-data-node (SID 1026) /
                                / = timezone-utc-offset (SID 1740) /
    3 : "Maximum exceeded"      / error-message (SID 1027) /
  }
}
```

[¶](#section-5.1-4){.pilcrow}
:::

CBOR encoding:[¶](#section-5.1-5){.pilcrow}

::: {#section-5.1-6}
``` {.lang-cbor-pretty .sourcecode}
A1                                      # map(1)
   19 0400                              # unsigned(1024)
   A4                                   # map(4)
      04                                # unsigned(4)
      19 03F3                           # unsigned(1011)
      01                                # unsigned(1)
      19 03FA                           # unsigned(1018)
      02                                # unsigned(2)
      19 06CC                           # unsigned(1740)
      03                                # unsigned(3)
      70                                # text(16)
         4D6178696D756D206578636565646564 # "Maximum exceeded"
```

[¶](#section-5.1-6){.pilcrow}
:::
:::
:::

::: {#using-names-in-keys-5}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Using Names in Keys](#name-using-names-in-keys-7){.section-name .selfRef} {#name-using-names-in-keys-7}

The yang-data extensions encoded using names are carried in a CBOR map
containing a single item pair. The key of this item is set to the
namespace-qualified name of the yang-data extension container; the value
is set to the CBOR encoding of this container, as defined in [Section
4.2](#container){.xref}.[¶](#section-5.2-1){.pilcrow}

This example shows a serialization example of the yang-errors yang-data
extension, as defined in \[[CORE-COMI](#I-D.ietf-core-comi){.xref}\],
using names, as defined [Section
3.3](#name){.xref}.[¶](#section-5.2-2){.pilcrow}

CBOR diagnostic notation:[¶](#section-5.2-3){.pilcrow}

::: {#section-5.2-4}
``` {.lang-cbor-diag .sourcecode}
{
  "ietf-coreconf:error" : {
    "error-tag" : "invalid-value",
    "error-app-tag" : "not-in-range",
    "error-data-node" : "timezone-utc-offset",
    "error-message" : "Maximum exceeded"
  }
}
```

[¶](#section-5.2-4){.pilcrow}
:::

CBOR encoding:[¶](#section-5.2-5){.pilcrow}

::: {#section-5.2-6}
``` {.lang-cbor-pretty .sourcecode}
A1                                           # map(1)
   73                                        # text(19)
      696574662D636F7265636F6E663A6572726F72 # "ietf-coreconf:error"
   A4                                        # map(4)
      69                                     # text(9)
         6572726F722D746167                  # "error-tag"
      6D                                     # text(13)
         696E76616C69642D76616C7565          # "invalid-value"
      6D                                     # text(13)
         6572726F722D6170702D746167          # "error-app-tag"
      6C                                     # text(12)
         6E6F742D696E2D72616E6765            # "not-in-range"
      6F                                     # text(15)
         6572726F722D646174612D6E6F6465      # "error-data-node"
      73                                     # text(19)
         74696D657A6F6E652D7574632D6F6666736574
                                             # "timezone-utc-offset"
      6D                                     # text(13)
         6572726F722D6D657373616765          # "error-message"
      70                                     # text(16)
         4D6178696D756D206578636565646564    # "Maximum exceeded"
```

[¶](#section-5.2-6){.pilcrow}
:::
:::
:::
:::
:::

::: {#data-types-mapping}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Representing YANG Data Types in CBOR](#name-representing-yang-data-type){.section-name .selfRef} {#name-representing-yang-data-type}

The CBOR encoding of an instance of a leaf or leaf-list representation
node depends on the built-in type of that representation node. The
following subsection defines the CBOR encoding of each built-in type
supported by YANG, as listed in [Section
4.2.4](https://www.rfc-editor.org/rfc/rfc7950#section-4.2.4){.relref} of
\[[RFC7950](#RFC7950){.xref}\]. Each subsection shows an example value
assigned to a representation node instance of the discussed built-in
type.[¶](#section-6-1){.pilcrow}

::: {#the-unsigned-integer-types}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [The Unsigned Integer Types](#name-the-unsigned-integer-types){.section-name .selfRef} {#name-the-unsigned-integer-types}

Leafs of type uint8, uint16, uint32, and uint64 [MUST]{.bcp14} be
encoded using a CBOR unsigned integer data item (major type
0).[¶](#section-6.1-1){.pilcrow}

The following example shows the encoding of an \'mtu\' leaf
representation node instance set to 1280
bytes.[¶](#section-6.1-2){.pilcrow}

Definition example adapted from
\[[RFC8344](#RFC8344){.xref}\]:[¶](#section-6.1-3){.pilcrow}

::: {#section-6.1-4}
``` {.lang-yang .sourcecode}
leaf mtu {
  type uint16 {
    range "68..max";
  }
}
```

[¶](#section-6.1-4){.pilcrow}
:::

CBOR diagnostic notation: 1280[¶](#section-6.1-5){.pilcrow}

CBOR encoding: 19 0500[¶](#section-6.1-6){.pilcrow}
:::
:::

::: {#the-integer-types}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [The Integer Types](#name-the-integer-types){.section-name .selfRef} {#name-the-integer-types}

Leafs of type int8, int16, int32, and int64 [MUST]{.bcp14} be encoded
using either a CBOR unsigned integer (major type 0) or a CBOR negative
integer (major type 1), depending on the actual
value.[¶](#section-6.2-1){.pilcrow}

The following example shows the encoding of a \'timezone-utc-offset\'
leaf representation node instance set to -300
minutes.[¶](#section-6.2-2){.pilcrow}

Definition example adapted from
\[[RFC7317](#RFC7317){.xref}\]:[¶](#section-6.2-3){.pilcrow}

::: {#section-6.2-4}
``` {.lang-yang .sourcecode}
leaf timezone-utc-offset {
  type int16 {
    range "-1500 .. 1500";
  }
}
```

[¶](#section-6.2-4){.pilcrow}
:::

CBOR diagnostic notation: -300[¶](#section-6.2-5){.pilcrow}

CBOR encoding: 39 012B[¶](#section-6.2-6){.pilcrow}
:::
:::

::: {#the-decimal64-type}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [The \'decimal64\' Type](#name-the-decimal64-type){.section-name .selfRef} {#name-the-decimal64-type}

Leafs of type decimal64 [MUST]{.bcp14} be encoded using a decimal
fraction, as defined in [Section
3.4.4](https://www.rfc-editor.org/rfc/rfc8949#section-3.4.4){.relref} of
\[[RFC8949](#RFC8949){.xref}\].[¶](#section-6.3-1){.pilcrow}

The following example shows the encoding of a \'my-decimal\' leaf
representation node instance set to 2.57.[¶](#section-6.3-2){.pilcrow}

Definition example adapted from
\[[RFC7317](#RFC7317){.xref}\]:[¶](#section-6.3-3){.pilcrow}

::: {#section-6.3-4}
``` {.lang-yang .sourcecode}
leaf my-decimal {
  type decimal64 {
    fraction-digits 2;
    range "1 .. 3.14 | 10 | 20..max";
  }
}
```

[¶](#section-6.3-4){.pilcrow}
:::

CBOR diagnostic notation: 4(\[-2, 257\])[¶](#section-6.3-5){.pilcrow}

CBOR encoding: C4 82 21 19 0101[¶](#section-6.3-6){.pilcrow}
:::
:::

::: {#the-string-type}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [The \'string\' Type](#name-the-string-type){.section-name .selfRef} {#name-the-string-type}

Leafs of type string [MUST]{.bcp14} be encoded using a CBOR text string
data item (major type 3).[¶](#section-6.4-1){.pilcrow}

The following example shows the encoding of a \'name\' leaf
representation node instance set to
\"eth0\".[¶](#section-6.4-2){.pilcrow}

Definition example adapted from
\[[RFC8343](#RFC8343){.xref}\]:[¶](#section-6.4-3){.pilcrow}

::: {#section-6.4-4}
``` {.lang-yang .sourcecode}
leaf name {
  type string;
}
```

[¶](#section-6.4-4){.pilcrow}
:::

CBOR diagnostic notation: \"eth0\"[¶](#section-6.4-5){.pilcrow}

CBOR encoding: 64 65746830[¶](#section-6.4-6){.pilcrow}
:::
:::

::: {#the-boolean-type}
::: {#section-6.5 .section}
### [6.5.](#section-6.5){.section-number .selfRef} [The \'boolean\' Type](#name-the-boolean-type){.section-name .selfRef} {#name-the-boolean-type}

Leafs of type boolean [MUST]{.bcp14} be encoded using a CBOR simple
value \'true\' (major type 7, additional information 21) or \'false\'
(major type 7, additional information 20).[¶](#section-6.5-1){.pilcrow}

The following example shows the encoding of an \'enabled\' leaf
representation node instance set to
\'true\'.[¶](#section-6.5-2){.pilcrow}

Definition example adapted from
\[[RFC7317](#RFC7317){.xref}\]:[¶](#section-6.5-3){.pilcrow}

::: {#section-6.5-4}
``` {.lang-yang .sourcecode}
leaf enabled {
  type boolean;
}
```

[¶](#section-6.5-4){.pilcrow}
:::

CBOR diagnostic notation: true[¶](#section-6.5-5){.pilcrow}

CBOR encoding: F5[¶](#section-6.5-6){.pilcrow}
:::
:::

::: {#enumeration}
::: {#section-6.6 .section}
### [6.6.](#section-6.6){.section-number .selfRef} [The \'enumeration\' Type](#name-the-enumeration-type){.section-name .selfRef} {#name-the-enumeration-type}

Leafs of type enumeration [MUST]{.bcp14} be encoded using a CBOR
unsigned integer (major type 0) or CBOR negative integer (major type 1),
depending on the actual value, or exceptionally as a tagged text string
(see below). Enumeration values are either explicitly assigned using the
YANG statement \'value\' or automatically assigned based on the
algorithm defined in [Section
9.6.4.2](https://www.rfc-editor.org/rfc/rfc7950#section-9.6.4.2){.relref}
of \[[RFC7950](#RFC7950){.xref}\].[¶](#section-6.6-1){.pilcrow}

The following example shows the encoding of an \'oper-status\' leaf
representation node instance set to
\'testing\'.[¶](#section-6.6-2){.pilcrow}

Definition example adapted from
\[[RFC7317](#RFC7317){.xref}\]:[¶](#section-6.6-3){.pilcrow}

::: {#section-6.6-4}
``` {.lang-yang .sourcecode}
leaf oper-status {
  type enumeration {
    enum up { value 1; }
    enum down { value 2; }
    enum testing { value 3; }
    enum unknown { value 4; }
    enum dormant { value 5; }
    enum not-present { value 6; }
    enum lower-layer-down { value 7; }
  }
}
```

[¶](#section-6.6-4){.pilcrow}
:::

CBOR diagnostic notation: 3[¶](#section-6.6-5){.pilcrow}

CBOR encoding: 03[¶](#section-6.6-6){.pilcrow}

Values of \'enumeration\' types defined in a \'union\' type
[MUST]{.bcp14} be encoded using a CBOR text string data item (major type
3) and [MUST]{.bcp14} contain one of the names assigned by \'enum\'
statements in YANG (see also [Section 6.12](#union){.xref}). The
encoding [MUST]{.bcp14} be enclosed by the enumeration CBOR tag, as
specified in [Section
9.3](#tag-registry){.xref}.[¶](#section-6.6-7){.pilcrow}

Definition example adapted from
\[[RFC7950](#RFC7950){.xref}\]:[¶](#section-6.6-8){.pilcrow}

::: {#section-6.6-9}
``` {.lang-yang .sourcecode}
type union {
  type int32;
  type enumeration {
    enum unbounded;
  }
}
```

[¶](#section-6.6-9){.pilcrow}
:::

CBOR diagnostic notation:
44(\"unbounded\")[¶](#section-6.6-10){.pilcrow}

CBOR encoding: D8 2C 69 756E626F756E646564[¶](#section-6.6-11){.pilcrow}
:::
:::

::: {#bits}
::: {#section-6.7 .section}
### [6.7.](#section-6.7){.section-number .selfRef} [The \'bits\' Type](#name-the-bits-type){.section-name .selfRef} {#name-the-bits-type}

Keeping in mind that bit positions are either explicitly assigned using
the YANG statement \'position\' or automatically assigned based on the
algorithm defined in [Section
9.7.4.2](https://www.rfc-editor.org/rfc/rfc7950#section-9.7.4.2){.relref}
of \[[RFC7950](#RFC7950){.xref}\], each element of type bits could be
seen as a set of bit positions (or offsets from position 0) that have a
value of either 1, which represents the bit being set, or 0, which
represents that the bit is not set.[¶](#section-6.7-1){.pilcrow}

Leafs of type bits [MUST]{.bcp14} be encoded either using a CBOR array
(major type 4) or byte string (major type 2) or exceptionally as a
tagged text string (see below). In case CBOR array representation is
used, each element is either (1) a positive integer (major type 0 with
value 0 being disallowed) that can be used to calculate the offset of
the next byte string or (2) a byte string (major type 2) that carries
the information regarding whether certain bits are set or not. The
initial offset value is 0, and each unsigned integer modifies the offset
value of the next byte string by the integer value multiplied by 8. For
example, if the bit offset is 0 and there is an integer with value 5,
the first byte of the byte string that follows will represent bit
positions 40 to 47, with both ends included. If the byte string has a
second byte, it will carry information about bits 48 to 55, and so on.
Within each byte, bits are assigned from least to most significant.
After the byte string, the offset is modified by the number of bytes in
the byte string multiplied by 8. Bytes with no bits set (zero bytes) at
the end of the byte string are never generated. If they occur at the end
of the array, the zero bytes are simply omitted; if they occur at the
end of a byte string preceding an integer, the zero bytes are removed
and the integer is adjusted upwards by the number of zero bytes that
were removed. An example follows.[¶](#section-6.7-2){.pilcrow}

The following example shows the encoding of an \'alarm-state\' leaf
representation node instance with the \'critical\' (position 2),
\'warning\' (position 8), and \'indeterminate\' (position 128) flags
set.[¶](#section-6.7-3){.pilcrow}

::: {#section-6.7-4}
``` {.lang-yang .sourcecode}
typedef alarm-state {
  type bits {
    bit unknown;
    bit under-repair;
    bit critical;
    bit major;
    bit minor;
    bit warning {
      position 8;
    }
    bit indeterminate {
      position 128;
    }
  }
}

leaf alarm-state {
  type alarm-state;
}
```

[¶](#section-6.7-4){.pilcrow}
:::

CBOR diagnostic notation: \[h\'0401\', 14,
h\'01\'\][¶](#section-6.7-5){.pilcrow}

CBOR encoding: 83 42 0401 0E 41 01[¶](#section-6.7-6){.pilcrow}

In a number of cases, the array would only need to have one element \--
a byte string with a few bytes inside. For this case, it is
[REQUIRED]{.bcp14} to omit the array element and have only the byte
array that would have been inside. To illustrate this, let us consider
the same example YANG definition but this time encoding only
\'under-repair\' and \'critical\' flags. The result would
be[¶](#section-6.7-7){.pilcrow}

CBOR diagnostic notation: h\'06\'[¶](#section-6.7-8){.pilcrow}

CBOR encoding: 41 06[¶](#section-6.7-9){.pilcrow}

Elements in the array [MUST]{.bcp14} be either byte strings that do not
end in a zero byte or positive unsigned integers, where byte strings and
integers [MUST]{.bcp14} alternate, i.e., adjacent byte strings or
adjacent integers are an error. An array with a single byte string
[MUST]{.bcp14} instead be encoded as just that byte string. An array
with a single positive integer is an error. Note that a recipient can
handle trailing zero bytes in the byte strings using the normal rules
without any issue, so an implementation [MAY]{.bcp14} silently accept
them.[¶](#section-6.7-10){.pilcrow}

Values of \'bits\' types defined in a \'union\' type [MUST]{.bcp14} be
encoded using a CBOR text string data item (major type 3) and
[MUST]{.bcp14} contain a space-separated sequence of names of \'bits\'
that are set (see also [Section 6.12](#union){.xref}). The encoding
[MUST]{.bcp14} be enclosed by the bits CBOR tag, as specified in
[Section 9.3](#tag-registry){.xref}.[¶](#section-6.7-11){.pilcrow}

The following example shows the encoding of an \'alarm-state\' leaf
representation node instance defined using a union type with the
\'under-repair\' and \'critical\' flags
set.[¶](#section-6.7-12){.pilcrow}

Definition example:[¶](#section-6.7-13){.pilcrow}

::: {#section-6.7-14}
``` {.lang-yang .sourcecode}
leaf alarm-state-2 {
  type union {
    type alarm-state;
    type bits {
      bit extra-flag;
    }
  }
}
```

[¶](#section-6.7-14){.pilcrow}
:::

CBOR diagnostic notation: 43(\"under-repair
critical\")[¶](#section-6.7-15){.pilcrow}

CBOR encoding: D8 2B 75
756E6465722D72657061697220637269746963616C[¶](#section-6.7-16){.pilcrow}
:::
:::

::: {#the-binary-type}
::: {#section-6.8 .section}
### [6.8.](#section-6.8){.section-number .selfRef} [The \'binary\' Type](#name-the-binary-type){.section-name .selfRef} {#name-the-binary-type}

Leafs of type binary [MUST]{.bcp14} be encoded using a CBOR byte string
data item (major type 2).[¶](#section-6.8-1){.pilcrow}

The following example shows the encoding of an \'aes128-key\' leaf
representation node instance set to
0x1f1ce6a3f42660d888d92a4d8030476e.[¶](#section-6.8-2){.pilcrow}

Definition example:[¶](#section-6.8-3){.pilcrow}

::: {#section-6.8-4}
``` {.lang-yang .sourcecode}
leaf aes128-key {
  type binary {
    length 16;
  }
}
```

[¶](#section-6.8-4){.pilcrow}
:::

CBOR diagnostic notation:
h\'1F1CE6A3F42660D888D92A4D8030476E\'[¶](#section-6.8-5){.pilcrow}

CBOR encoding: 50
1F1CE6A3F42660D888D92A4D8030476E[¶](#section-6.8-6){.pilcrow}
:::
:::

::: {#the-leafref-type}
::: {#section-6.9 .section}
### [6.9.](#section-6.9){.section-number .selfRef} [The \'leafref\' Type](#name-the-leafref-type){.section-name .selfRef} {#name-the-leafref-type}

Leafs of type leafref [MUST]{.bcp14} be encoded using the rules of the
representation node referenced by the \'path\' YANG
statement.[¶](#section-6.9-1){.pilcrow}

The following example shows the encoding of an \'interface-state-ref\'
leaf representation node instance set to
\"eth1\".[¶](#section-6.9-2){.pilcrow}

Definition example adapted from
\[[RFC8343](#RFC8343){.xref}\]:[¶](#section-6.9-3){.pilcrow}

::: {#section-6.9-4}
``` {.lang-yang .sourcecode}
typedef interface-state-ref {
  type leafref {
    path "/interfaces-state/interface/name";
  }
}

container interfaces-state {
  list interface {
    key "name";
    leaf name {
      type string;
    }
    leaf-list higher-layer-if {
      type interface-state-ref;
    }
  }
}
```

[¶](#section-6.9-4){.pilcrow}
:::

CBOR diagnostic notation: \"eth1\"[¶](#section-6.9-5){.pilcrow}

CBOR encoding: 64 65746831[¶](#section-6.9-6){.pilcrow}
:::
:::

::: {#identityref}
::: {#section-6.10 .section}
### [6.10.](#section-6.10){.section-number .selfRef} [The \'identityref\' Type](#name-the-identityref-type){.section-name .selfRef} {#name-the-identityref-type}

This specification supports two approaches for encoding identityref: as
a YANG Schema Item iDentifier, as defined in [Section 3.2](#sid){.xref},
or as a name, as defined in [Section
6.8](https://www.rfc-editor.org/rfc/rfc7951#section-6.8){.relref} of
\[[RFC7951](#RFC7951){.xref}\]. See [Section 6.12](#union){.xref} for an
exceptional case when this representation needs to be
tagged.[¶](#section-6.10-1){.pilcrow}

::: {#identityref-with-sid}
::: {#section-6.10.1 .section}
#### [6.10.1.](#section-6.10.1){.section-number .selfRef} [SIDs as \'identityref\'](#name-sids-as-identityref){.section-name .selfRef} {#name-sids-as-identityref}

When representation nodes of type identityref are implemented using
SIDs, they [MUST]{.bcp14} be encoded using a CBOR unsigned integer data
item (major type 0). (Note that, as they are not used in the position of
CBOR map keys, no delta mechanism is employed for SIDs used for
identityref.)[¶](#section-6.10.1-1){.pilcrow}

The following example shows the encoding of a \'type\' leaf
representation node instance set to the value
\'iana-if-type:ethernetCsmacd\' (SID
1880).[¶](#section-6.10.1-2){.pilcrow}

Definition example adapted from
\[[RFC7317](#RFC7317){.xref}\]:[¶](#section-6.10.1-3){.pilcrow}

::: {#section-6.10.1-4}
``` {.lang-yang .sourcecode}
identity interface-type {
}

identity iana-interface-type {
  base interface-type;
}

identity ethernetCsmacd {
  base iana-interface-type;
}

leaf type {
  type identityref {
    base interface-type;
  }
}
```

[¶](#section-6.10.1-4){.pilcrow}
:::

CBOR diagnostic notation: 1880[¶](#section-6.10.1-5){.pilcrow}

CBOR encoding: 19 0758[¶](#section-6.10.1-6){.pilcrow}
:::
:::

::: {#name-as-identityref}
::: {#section-6.10.2 .section}
#### [6.10.2.](#section-6.10.2){.section-number .selfRef} [Name as \'identityref\'](#name-name-as-identityref){.section-name .selfRef} {#name-name-as-identityref}

Alternatively, an identityref [MAY]{.bcp14} be encoded using a name, as
defined in [Section 3.3](#name){.xref}. When names are used, identityref
[MUST]{.bcp14} be encoded using a CBOR text string data item (major type
3). If the identity is defined in a different module than the leaf node
containing the identityref data node, the namespace-qualified form
[MUST]{.bcp14} be used. Otherwise, both the simple and
namespace-qualified forms are permitted. Names and namespaces are
defined in [Section 3.3](#name){.xref}.[¶](#section-6.10.2-1){.pilcrow}

The following example shows the encoding of the identity
\'iana-if-type:ethernetCsmacd\' using its namespace-qualified name. This
example is described in [Section
6.10.1](#identityref-with-sid){.xref}.[¶](#section-6.10.2-2){.pilcrow}

CBOR diagnostic notation:
\"iana-if-type:ethernetCsmacd\"[¶](#section-6.10.2-3){.pilcrow}

CBOR encoding: 78 1B
69616E612D69662D747970653A65746865726E657443736D616364[¶](#section-6.10.2-4){.pilcrow}
:::
:::
:::
:::

::: {#the-empty-type}
::: {#section-6.11 .section}
### [6.11.](#section-6.11){.section-number .selfRef} [The \'empty\' Type](#name-the-empty-type){.section-name .selfRef} {#name-the-empty-type}

Leafs of type empty [MUST]{.bcp14} be encoded using the CBOR null value
(major type 7, additional information 22).[¶](#section-6.11-1){.pilcrow}

The following example shows the encoding of an \'is-router\' leaf
representation node instance when present.[¶](#section-6.11-2){.pilcrow}

Definition example adapted from
\[[RFC8344](#RFC8344){.xref}\]:[¶](#section-6.11-3){.pilcrow}

::: {#section-6.11-4}
``` {.lang-yang .sourcecode}
leaf is-router {
  type empty;
}
```

[¶](#section-6.11-4){.pilcrow}
:::

CBOR diagnostic notation: null[¶](#section-6.11-5){.pilcrow}

CBOR encoding: F6[¶](#section-6.11-6){.pilcrow}
:::
:::

::: {#union}
::: {#section-6.12 .section}
### [6.12.](#section-6.12){.section-number .selfRef} [The \'union\' Type](#name-the-union-type){.section-name .selfRef} {#name-the-union-type}

Leafs of type union [MUST]{.bcp14} be encoded using the rules associated
with one of the types listed. When used in a union, the following YANG
datatypes are enclosed by a CBOR tag to avoid confusion between
different YANG datatypes encoded using the same CBOR major
type.[¶](#section-6.12-1){.pilcrow}

-   [bits[¶](#section-6.12-2.1){.pilcrow}]{#section-6.12-2.1}
-   [enumeration[¶](#section-6.12-2.2){.pilcrow}]{#section-6.12-2.2}
-   [identityref[¶](#section-6.12-2.3){.pilcrow}]{#section-6.12-2.3}
-   [instance-identifier[¶](#section-6.12-2.4){.pilcrow}]{#section-6.12-2.4}

See [Section 9.3](#tag-registry){.xref} for the assigned value of these
CBOR tags.[¶](#section-6.12-3){.pilcrow}

As mentioned in Sections [6.6](#enumeration){.xref} and in
[6.7](#bits){.xref}, \'enumeration\' and \'bits\' are encoded as a CBOR
text string data item (major type 3) when defined within a \'union\'
type. (This adds considerable complexity but is necessary because of an
idiosyncrasy of the YANG data model for unions; the work-around allows
compatibility to be maintained with the encoding of overlapping unions
in XML and JSON. See also [Section
9.12](https://www.rfc-editor.org/rfc/rfc7950#section-9.12){.relref} of
\[[RFC7950](#RFC7950){.xref}\].)[¶](#section-6.12-4){.pilcrow}

The following example shows the encoding of an \'ip-address\' leaf
representation node instance when set to
\"2001:db8:a0b:12f0::1\".[¶](#section-6.12-5){.pilcrow}

Definition example adapted from
\[[RFC6991](#RFC6991){.xref}\]:[¶](#section-6.12-6){.pilcrow}

::: {#section-6.12-7}
``` {.lang-yang .sourcecode}
typedef ipv4-address {
  type string {
    pattern
      '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
    +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
    + '(%[\p{N}\p{L}]+)?';
  }
}

typedef ipv6-address {
  type string {
    pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
          + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
          + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
          + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
          + '(%[\p{N}\p{L}]+)?';
    pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
          + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
          + '(%.+)?';
  }
}

typedef ip-address {
  type union {
    type ipv4-address;
    type ipv6-address;
  }
}

leaf address {
  type ip-address;
}
```

[¶](#section-6.12-7){.pilcrow}
:::

CBOR diagnostic notation:
\"2001:db8:a0b:12f0::1\"[¶](#section-6.12-8){.pilcrow}

CBOR encoding: 74
323030313A6462383A6130623A313266303A3A31[¶](#section-6.12-9){.pilcrow}
:::
:::

::: {#instance-id}
::: {#section-6.13 .section}
### [6.13.](#section-6.13){.section-number .selfRef} [The \'instance-identifier\' Type](#name-the-instance-identifier-typ){.section-name .selfRef} {#name-the-instance-identifier-typ}

This specification supports two approaches for encoding an
instance-identifier: one based on YANG Schema Item iDentifier, as
defined in [Section 3.2](#sid){.xref}, and one based on names, as
defined in [Section 3.3](#name){.xref}. See [Section
6.12](#union){.xref} for an exceptional case when this representation
needs to be tagged.[¶](#section-6.13-1){.pilcrow}

::: {#instance-identifier-with-sid}
::: {#section-6.13.1 .section}
#### [6.13.1.](#section-6.13.1){.section-number .selfRef} [SIDs as \'instance-identifier\'](#name-sids-as-instance-identifier){.section-name .selfRef} {#name-sids-as-instance-identifier}

SIDs uniquely identify a schema node. In the case of a single instance
schema node, i.e., a schema node defined at the root of a YANG module or
submodule or schema nodes defined within a container, the SID is
sufficient to identify this instance (representation node). (Note that
no delta mechanism is employed for SIDs used for identityref, see
[Section
6.10.1](#identityref-with-sid){.xref}.)[¶](#section-6.13.1-1){.pilcrow}

In the case of a representation node that is an entry of a YANG list, a
SID is combined with the list key(s) to identify each instance within
the YANG list(s).[¶](#section-6.13.1-2){.pilcrow}

Instance-identifiers of single instance schema nodes [MUST]{.bcp14} be
encoded using a CBOR unsigned integer data item (major type 0) and set
to the targeted schema node SID.[¶](#section-6.13.1-3){.pilcrow}

Instance-identifiers of representation node entries of a YANG list
[MUST]{.bcp14} be encoded using a CBOR array data item (major type 4)
containing the following entries:[¶](#section-6.13.1-4){.pilcrow}

-   [The first entry [MUST]{.bcp14} be encoded as a CBOR unsigned
    integer data item (major type 0) and set to the targeted schema node
    SID.[¶](#section-6.13.1-5.1){.pilcrow}]{#section-6.13.1-5.1}
-   [The following entries [MUST]{.bcp14} contain the value of each key
    required to identify the instance of the targeted schema node. These
    keys [MUST]{.bcp14} be ordered as defined in the \'key\' YANG
    statement, starting from the top-level list, and followed by each
    subordinate
    list(s).[¶](#section-6.13.1-5.2){.pilcrow}]{#section-6.13.1-5.2}

Examples within this section assume the definition of a schema node of
type \'instance-identifier\':[¶](#section-6.13.1-6){.pilcrow}

Definition example adapted from
\[[RFC7950](#RFC7950){.xref}\]:[¶](#section-6.13.1-7){.pilcrow}

::: {#section-6.13.1-8}
``` {.lang-yang .sourcecode}
container system {
  ...
  leaf reporting-entity {
    type instance-identifier;
  }
```

[¶](#section-6.13.1-8){.pilcrow}
:::

**First example:**[¶](#section-6.13.1-9){.pilcrow}

The following example shows the encoding of the \'reporting-entity\'
value referencing data node instance \"/system/contact\" (SID
1741).[¶](#section-6.13.1-10){.pilcrow}

Definition example adapted from
\[[RFC7317](#RFC7317){.xref}\]:[¶](#section-6.13.1-11){.pilcrow}

::: {#section-6.13.1-12}
``` {.lang-yang .sourcecode}
container system {

  leaf contact {
    type string;
  }

  leaf hostname {
    type inet:domain-name;
  }
}
```

[¶](#section-6.13.1-12){.pilcrow}
:::

CBOR diagnostic notation: 1741[¶](#section-6.13.1-13){.pilcrow}

CBOR encoding: 19 06CD[¶](#section-6.13.1-14){.pilcrow}

**Second example:**[¶](#section-6.13.1-15){.pilcrow}

This example aims to show how a representation node entry of a YANG list
is identified. It uses a somewhat arbitrarily modified YANG module
version from \[[RFC7317](#RFC7317){.xref}\] by adding `country` to the
leafs and keys of `authorized-key`.[¶](#section-6.13.1-16){.pilcrow}

The following example shows the encoding of the \'reporting-entity\'
value referencing list instance
\"/system/authentication/user/authorized-key/key-data\" (which is
assumed to have SID 1734) for username \"bob\" and authorized-key with
name \"admin\" and country \"france\".[¶](#section-6.13.1-17){.pilcrow}

::: {#section-6.13.1-18}
``` {.lang-yang .sourcecode}
list user {
  key name;

  leaf name {
    type string;
  }

  leaf password {
    type ianach:crypt-hash;
  }

  list authorized-key {
    key "name country";

    leaf country {
      type string;
    }

    leaf name {
      type string;
    }

    leaf algorithm {
      type string;
    }

    leaf key-data {
      type binary;
    }
  }
}
```

[¶](#section-6.13.1-18){.pilcrow}
:::

CBOR diagnostic notation: \[1734, \"bob\", \"admin\",
\"france\"\][¶](#section-6.13.1-19){.pilcrow}

CBOR encoding:[¶](#section-6.13.1-20){.pilcrow}

::: {#section-6.13.1-21}
``` {.lang-cbor-pretty .sourcecode}
84                 # array(4)
   19 06C6         # unsigned(1734)
   63              # text(3)
      626F62       # "bob"
   65              # text(5)
      61646D696E   # "admin"
   66              # text(6)
      6672616E6365 # "france"
```

[¶](#section-6.13.1-21){.pilcrow}
:::

**Third example:**[¶](#section-6.13.1-22){.pilcrow}

The following example shows the encoding of the \'reporting-entity\'
value referencing the list instance \"/system/authentication/user\" (SID
1730), corresponding to username
\"jack\".[¶](#section-6.13.1-23){.pilcrow}

CBOR diagnostic notation: \[1730,
\"jack\"\][¶](#section-6.13.1-24){.pilcrow}

CBOR encoding:[¶](#section-6.13.1-25){.pilcrow}

::: {#section-6.13.1-26}
``` {.lang-cbor-pretty .sourcecode}
82             # array(2)
   19 06C2     # unsigned(1730)
   64          # text(4)
      6A61636B # "jack"
```

[¶](#section-6.13.1-26){.pilcrow}
:::
:::
:::

::: {#names-as-instance-identifier}
::: {#section-6.13.2 .section}
#### [6.13.2.](#section-6.13.2){.section-number .selfRef} [Names as \'instance-identifier\'](#name-names-as-instance-identifie){.section-name .selfRef} {#name-names-as-instance-identifie}

An \'instance-identifier\' value is encoded as a text string that is
analogous to the lexical representation in XML encoding; see [Section
9.13.2](https://www.rfc-editor.org/rfc/rfc7950#section-9.13.2){.relref}
of \[[RFC7950](#RFC7950){.xref}\]. However, the encoding of namespaces
in instance-identifier values follows the rules stated in [Section
3.3](#name){.xref}, namely:[¶](#section-6.13.2-1){.pilcrow}

-   [The leftmost (top-level) data node name is always in the
    namespace-qualified
    form.[¶](#section-6.13.2-2.1){.pilcrow}]{#section-6.13.2-2.1}
-   [Any subsequent data node name is in the namespace-qualified form if
    the node is defined in a module other than its parent node;
    otherwise, the simple form is used. This rule also holds for node
    names appearing in
    predicates.[¶](#section-6.13.2-2.2){.pilcrow}]{#section-6.13.2-2.2}

For example,[¶](#section-6.13.2-3){.pilcrow}

/ietf-interfaces:interfaces/interface\[name=\'eth0\'\]/ietf-ip:ipv4/ip[¶](#section-6.13.2-4){.pilcrow}

is a valid instance-identifier value because the data nodes
\"interfaces\", \"interface\", and \"name\" are defined in the module
\"ietf-interfaces\", whereas \"ipv4\" and \"ip\" are defined in
\"ietf-ip\".[¶](#section-6.13.2-5){.pilcrow}

The resulting XML Path Language (XPath) [MUST]{.bcp14} be encoded using
a CBOR text string data item (major type
3).[¶](#section-6.13.2-6){.pilcrow}

**First example:**[¶](#section-6.13.2-7){.pilcrow}

This example is described in [Section
6.13.1](#instance-identifier-with-sid){.xref}.[¶](#section-6.13.2-8){.pilcrow}

CBOR diagnostic notation:
\"/ietf-system:system/contact\"[¶](#section-6.13.2-9){.pilcrow}

CBOR encoding:[¶](#section-6.13.2-10){.pilcrow}

::: {#section-6.13.2-11}
``` {.lang-cbor-pretty .sourcecode}
78 1B 2F696574662D73797374656D3A73797374656D2F636F6E74616374
```

[¶](#section-6.13.2-11){.pilcrow}
:::

**Second example:**[¶](#section-6.13.2-12){.pilcrow}

This example is described in [Section
6.13.1](#instance-identifier-with-sid){.xref}.[¶](#section-6.13.2-13){.pilcrow}

CBOR diagnostic notation (the line break is inserted for exposition
only):[¶](#section-6.13.2-14){.pilcrow}

::: {#section-6.13.2-15}
``` {.lang-cbor-diag .sourcecode}
"/ietf-system:system/authentication/user[name='bob']/
authorized-key[name='admin'][country='france']/key-data"
```

[¶](#section-6.13.2-15){.pilcrow}
:::

CBOR encoding:[¶](#section-6.13.2-16){.pilcrow}

::: {#section-6.13.2-17}
``` {.lang-cbor-pretty .sourcecode}
78 6B
   2F696574662D73797374656D3A73797374656D2F61757468656E74696361
   74696F6E2F757365725B6E616D653D27626F62275D2F617574686F72697A
   65642D6B65795B6E616D653D2761646D696E275D5B636F756E7472793D27
   6672616E6365275D2F6B65792D64617461
```

[¶](#section-6.13.2-17){.pilcrow}
:::

**Third example:**[¶](#section-6.13.2-18){.pilcrow}

This example is described in [Section
6.13.1](#instance-identifier-with-sid){.xref}.[¶](#section-6.13.2-19){.pilcrow}

CBOR diagnostic notation:[¶](#section-6.13.2-20){.pilcrow}

::: {#section-6.13.2-21}
``` {.lang-cbor-diag .sourcecode}
"/ietf-system:system/authentication/user[name='jack']"
```

[¶](#section-6.13.2-21){.pilcrow}
:::

CBOR encoding:[¶](#section-6.13.2-22){.pilcrow}

::: {#section-6.13.2-23}
``` {.lang-cbor-pretty .sourcecode}
78 34                                   # text(52)
   2F696574662D73797374656D3A73797374656D2F61757468656E74696361
   74696F6E2F757365725B6E616D653D276A61636B275D
```

[¶](#section-6.13.2-23){.pilcrow}
:::
:::
:::
:::
:::
:::
:::

::: {#content-type}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Content-Types](#name-content-types){.section-name .selfRef} {#name-content-types}

This specification defines the media type `application/yang-data+cbor`,
which can be used without parameters or with the `id` parameter set to
either `name` or `sid`.[¶](#section-7-1){.pilcrow}

This media type represents a YANG-CBOR document containing a
representation tree. If the media type parameter `id` is present,
depending on its value, each representation node is identified by its
associated namespace-qualified name, as defined in [Section
3.3](#name){.xref} (`id=name`), or by its associated YANG SID
(represented, e.g., in CBOR map keys as a SID delta or via tag number
47), as defined in [Section 3.2](#sid){.xref} (`id=sid`), respectively.
If no `id` parameter is given, both forms may be
present.[¶](#section-7-2){.pilcrow}

The format of an `application/yang-data+cbor` representation is that of
a CBOR map, mapping names, and/or SIDs (as defined above) into instance
values (using the rules defined in [Section
4](#instance-encoding){.xref}).[¶](#section-7-3){.pilcrow}

It is not foreseen at this point that the valid set of values for the
`id` parameter will extend beyond `name`, `sid`, or being unset; if that
does happen, any new value is foreseen to be of the form
`[a-z][a-z0-9]*(-[a-z0-9]+)*`.[¶](#section-7-4){.pilcrow}

In summary, this document defines three content-types, which are
intended for use by different classes of
applications:[¶](#section-7-5){.pilcrow}

-   [`application/yang-data+cbor; id=sid` \-- for use by applications
    that need to be frugal with encoding space and text string
    processing (e.g., applications running on constrained nodes
    \[[RFC7228](#RFC7228){.xref}\] or applications with particular
    performance
    requirements);[¶](#section-7-6.1){.pilcrow}]{#section-7-6.1}
-   [`application/yang-data+cbor; id=name` \-- for use by applications
    that do not want to engage in SID management and that have ample
    resources to manage text-string-based item identifiers (e.g.,
    applications that directly want to substitute
    `application/yang.data+json` with a more efficient representation
    without any other changes);
    and[¶](#section-7-6.2){.pilcrow}]{#section-7-6.2}
-   [`application/yang-data+cbor` \-- for use by more complex
    applications that can benefit from the increased efficiency of SID
    identifiers but also need to integrate databases of YANG modules
    before SID mappings are defined for
    them.[¶](#section-7-6.3){.pilcrow}]{#section-7-6.3}

All three content-types are based on the same representation mechanisms,
parts of which are simply not used in the first and second
cases.[¶](#section-7-7){.pilcrow}

How the use of one of these content-types is selected in a transfer
protocol is outside the scope of this specification. The last paragraph
of [Section
5.2](https://www.rfc-editor.org/rfc/rfc8040#section-5.2){.relref} of
\[[RFC8040](#RFC8040){.xref}\] discusses how to indicate and request the
usage of specific content-types in RESTCONF. Similar mechanisms are
available in the Constrained Application Protocol (CoAP)
\[[RFC7252](#RFC7252){.xref}\] using the Content-Format and Accept
Options; \[[CORE-COMI](#I-D.ietf-core-comi){.xref}\] demonstrates
specifics on how Content-Format may be used to indicate the `id=sid`
case.[¶](#section-7-8){.pilcrow}
:::
:::

::: {#security-considerations}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

The security considerations of \[[RFC8949](#RFC8949){.xref}\] and
\[[RFC7950](#RFC7950){.xref}\] apply.[¶](#section-8-1){.pilcrow}

This document defines an alternative encoding for data modeled in the
YANG data modeling language. As such, this encoding does not contribute
any new security issues in addition to those identified for the specific
protocol or context for which it is used.[¶](#section-8-2){.pilcrow}

To minimize security risks, software on the receiving side
[SHOULD]{.bcp14} reject all messages that do not comply to the rules of
this document and reply with an appropriate error message to the
sender.[¶](#section-8-3){.pilcrow}

For instance, when the `id` parameter to the media type is used, it is
important to properly reject identifiers of the other type to avoid
scenarios where different implementations interpret a given content in
different ways.[¶](#section-8-4){.pilcrow}

When SIDs are in use, the interpretation of encoded data not only relies
on having the right YANG modules but also on having the right SID
mapping information. Management and evolution of that mapping
information therefore requires the same care as the management and
evolution of the YANG modules themselves. The procedures in
\[[CORE-SID](#I-D.ietf-core-sid){.xref}\] are being defined with this in
mind.[¶](#section-8-5){.pilcrow}
:::
:::

::: {#iana-considerations}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

::: {#media-types-registry}
::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Media Types Registry](#name-media-types-registry){.section-name .selfRef} {#name-media-types-registry}

IANA has added the following media type to the \"[Media
Types](https://www.iana.org/assignments/media-types/#media-types){.relref}\"
registry
\[[IANA.media-types](#IANA.media-types){.xref}\].[¶](#section-9.1-1){.pilcrow}

[]{#name-media-types-registry-2}

  Name             Template                     Reference
  ---------------- ---------------------------- -----------
  yang-data+cbor   application/yang-data+cbor   RFC 9254

  : [Table 2](#table-2){.selfRef}: [Media Types
  Registry](#name-media-types-registry-2){.selfRef}

[]{.break}

Type name:
:   application[¶](#section-9.1-3.2){.pilcrow}
:   

Subtype name:
:   yang-data+cbor[¶](#section-9.1-3.4){.pilcrow}
:   

Required parameters:
:   N/A[¶](#section-9.1-3.6){.pilcrow}
:   

Optional parameters:
:   id (see [Section 7](#content-type){.xref} of RFC
    9254)[¶](#section-9.1-3.8){.pilcrow}
:   

Encoding considerations:
:   binary (CBOR)[¶](#section-9.1-3.10){.pilcrow}
:   

Security considerations:
:   see [Section 8](#security-considerations){.xref} of RFC
    9254[¶](#section-9.1-3.12){.pilcrow}
:   

Interoperability considerations:
:   N/A[¶](#section-9.1-3.14){.pilcrow}
:   

Published specification:
:   RFC 9254[¶](#section-9.1-3.16){.pilcrow}
:   

Applications that use this media type:
:   applications that need a concise and efficient representation of
    YANG-modeled data[¶](#section-9.1-3.18){.pilcrow}
:   

Fragment identifier considerations:
:   The syntax and semantics of fragment identifiers specified for
    \"application/yang-data+cbor\" is as specified for
    \"application/cbor\". (At publication of this document, there is no
    fragment identification syntax defined for
    \"application/cbor\".)[¶](#section-9.1-3.20){.pilcrow}
:   

Additional information:

:   

:   

Magic number(s):
:   N/A[¶](#section-9.1-3.24){.pilcrow}
:   

File extension(s):
:   N/A[¶](#section-9.1-3.26){.pilcrow}
:   

Macintosh file type code(s):
:   N/A[¶](#section-9.1-3.28){.pilcrow}
:   

Person & email address to contact for further information:
:   CORE WG mailing list (core\@ietf.org) or IETF Applications and
    Real-Time Area (art\@ietf.org)[¶](#section-9.1-3.30){.pilcrow}
:   

Intended usage:
:   COMMON[¶](#section-9.1-3.32){.pilcrow}
:   

Restrictions on usage:
:   N/A[¶](#section-9.1-3.34){.pilcrow}
:   

Author:
:   CoRE WG[¶](#section-9.1-3.36){.pilcrow}
:   

Change controller:
:   IETF[¶](#section-9.1-3.38){.pilcrow}
:   
:::
:::

::: {#coap-content-formats-registry}
::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [CoAP Content-Formats Registry](#name-coap-content-formats-regist){.section-name .selfRef} {#name-coap-content-formats-regist}

IANA has added the following Content-Formats to the \"[CoAP
Content-Formats](https://www.iana.org/assignments/core-parameters/#content-formats){.relref}\"
subregistry, within the \"[Constrained RESTful Environments (CoRE)
Parameters](https://www.iana.org/assignments/core-parameters/#coap-content-format){.relref}\"
registry \[[IANA.core-parameters](#IANA.core-parameters){.xref}\]. The
registration procedure is \"Expert Review\" for the 0-255 range and
\"IETF Review\" for the 256-9999 range.[¶](#section-9.2-1){.pilcrow}

[]{#name-coap-content-format-registr}

  Media Type                            Encoding   ID    Reference
  ------------------------------------- ---------- ----- -----------
  application/yang-data+cbor            \-         340   RFC 9254
  application/yang-data+cbor; id=name   \-         341   RFC 9254
  application/yang-data+cbor; id=sid    \-         140   RFC 9254

  : [Table 3](#table-3){.selfRef}: [CoAP Content-Format
  Registry](#name-coap-content-format-registr){.selfRef}
:::
:::

::: {#tag-registry}
::: {#section-9.3 .section}
### [9.3.](#section-9.3){.section-number .selfRef} [CBOR Tags Registry](#name-cbor-tags-registry){.section-name .selfRef} {#name-cbor-tags-registry}

IANA has allocated the following CBOR tag numbers in the \"[CBOR
Tags](https://www.iana.org/assignments/cbor-tags#tags){.relref}\"
registry \[[IANA.cbor-tags](#IANA.cbor-tags){.xref}\] defined in
[Section
9.2](https://www.rfc-editor.org/rfc/rfc8949#section-9.2){.relref} of
\[[RFC8949](#RFC8949){.xref}\].[¶](#section-9.3-1){.pilcrow}

[]{#name-cbor-tags-registry-2}

::: {#tab-tag-values}
  Tag   Data Item                                  Semantics                                                                     Reference
  ----- ------------------------------------------ ----------------------------------------------------------------------------- -----------
  43    text string                                YANG bits datatype; see [Section 6.7](#bits){.xref}.                          RFC 9254
  44    text string                                YANG enumeration datatype; see [Section 6.6](#enumeration){.xref}.            RFC 9254
  45    unsigned integer or text string            YANG identityref datatype; see [Section 6.10](#identityref){.xref}.           RFC 9254
  46    unsigned integer or text string or array   YANG instance-identifier datatype; see [Section 6.13](#instance-id){.xref}.   RFC 9254
  47    unsigned integer                           YANG Schema Item iDentifier (SID); see [Section 3.2](#sid){.xref}.            RFC 9254

  : [Table 4](#table-4){.selfRef}: [CBOR Tags
  Registry](#name-cbor-tags-registry-2){.selfRef}
:::
:::
:::
:::
:::

::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-10.1 .section}
### [10.1.](#section-10.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[IANA.cbor-tags\]
:   [IANA]{.refAuthor}, [\"Concise Binary Object Representation (CBOR)
    Tags\"]{.refTitle},
    \<<https://www.iana.org/assignments/cbor-tags>\>.
:   

\[IANA.core-parameters\]
:   [IANA]{.refAuthor}, [\"Constrained RESTful Environments (CoRE)
    Parameters\"]{.refTitle},
    \<<https://www.iana.org/assignments/core-parameters/>\>.
:   

\[IANA.media-types\]
:   [IANA]{.refAuthor}, [\"Media Types\"]{.refTitle},
    \<<https://www.iana.org/assignments/media-types/>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC5234\]
:   [Crocker, D., Ed.]{.refAuthor} and [P. Overell]{.refAuthor},
    [\"Augmented BNF for Syntax Specifications: ABNF\"]{.refTitle}, [STD
    68]{.seriesInfo}, [RFC 5234]{.seriesInfo}, [DOI
    10.17487/RFC5234]{.seriesInfo}, January 2008,
    \<<https://www.rfc-editor.org/info/rfc5234>\>.
:   

\[RFC7950\]
:   [Bjorklund, M., Ed.]{.refAuthor}, [\"The YANG 1.1 Data Modeling
    Language\"]{.refTitle}, [RFC 7950]{.seriesInfo}, [DOI
    10.17487/RFC7950]{.seriesInfo}, August 2016,
    \<<https://www.rfc-editor.org/info/rfc7950>\>.
:   

\[RFC7951\]
:   [Lhotka, L.]{.refAuthor}, [\"JSON Encoding of Data Modeled with
    YANG\"]{.refTitle}, [RFC 7951]{.seriesInfo}, [DOI
    10.17487/RFC7951]{.seriesInfo}, August 2016,
    \<<https://www.rfc-editor.org/info/rfc7951>\>.
:   

\[RFC8040\]
:   [Bierman, A.]{.refAuthor}, [Bjorklund, M.]{.refAuthor}, and [K.
    Watsen]{.refAuthor}, [\"RESTCONF Protocol\"]{.refTitle}, [RFC
    8040]{.seriesInfo}, [DOI 10.17487/RFC8040]{.seriesInfo}, January
    2017, \<<https://www.rfc-editor.org/info/rfc8040>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8259\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The JavaScript Object Notation
    (JSON) Data Interchange Format\"]{.refTitle}, [STD 90]{.seriesInfo},
    [RFC 8259]{.seriesInfo}, [DOI 10.17487/RFC8259]{.seriesInfo},
    December 2017, \<<https://www.rfc-editor.org/info/rfc8259>\>.
:   

\[RFC8610\]
:   [Birkholz, H.]{.refAuthor}, [Vigano, C.]{.refAuthor}, and [C.
    Bormann]{.refAuthor}, [\"Concise Data Definition Language (CDDL): A
    Notational Convention to Express Concise Binary Object
    Representation (CBOR) and JSON Data Structures\"]{.refTitle}, [RFC
    8610]{.seriesInfo}, [DOI 10.17487/RFC8610]{.seriesInfo}, June 2019,
    \<<https://www.rfc-editor.org/info/rfc8610>\>.
:   

\[RFC8791\]
:   [Bierman, A.]{.refAuthor}, [Björklund, M.]{.refAuthor}, and [K.
    Watsen]{.refAuthor}, [\"YANG Data Structure
    Extensions\"]{.refTitle}, [RFC 8791]{.seriesInfo}, [DOI
    10.17487/RFC8791]{.seriesInfo}, June 2020,
    \<<https://www.rfc-editor.org/info/rfc8791>\>.
:   

\[RFC8949\]
:   [Bormann, C.]{.refAuthor} and [P. Hoffman]{.refAuthor}, [\"Concise
    Binary Object Representation (CBOR)\"]{.refTitle}, [STD
    94]{.seriesInfo}, [RFC 8949]{.seriesInfo}, [DOI
    10.17487/RFC8949]{.seriesInfo}, December 2020,
    \<<https://www.rfc-editor.org/info/rfc8949>\>.
:   
:::

::: {#section-10.2 .section}
### [10.2.](#section-10.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[CORE-COMI\]
:   [Veillette, M., Ed.]{.refAuthor}, [van der Stok, P.,
    Ed.]{.refAuthor}, [Pelov, A.]{.refAuthor},
    [Bierman, A.]{.refAuthor}, and [I. Petrov, Ed.]{.refAuthor}, [\"CoAP
    Management Interface (CORECONF)\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-core-comi-11]{.seriesInfo}, 17 January 2021,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-core-comi-11>\>.
:   

\[CORE-SID\]
:   [Veillette, M., Ed.]{.refAuthor}, [Pelov, A., Ed.]{.refAuthor},
    [Petrov, I., Ed.]{.refAuthor}, [Bormann, C.]{.refAuthor}, and [M.
    Richardson]{.refAuthor}, [\"YANG Schema Item iDentifier (YANG
    SID)\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-core-sid-18]{.seriesInfo}, 18 November
    2021,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-core-sid-18>\>.
:   

\[RFC6241\]
:   [Enns, R., Ed.]{.refAuthor}, [Bjorklund, M., Ed.]{.refAuthor},
    [Schoenwaelder, J., Ed.]{.refAuthor}, and [A. Bierman,
    Ed.]{.refAuthor}, [\"Network Configuration Protocol
    (NETCONF)\"]{.refTitle}, [RFC 6241]{.seriesInfo}, [DOI
    10.17487/RFC6241]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6241>\>.
:   

\[RFC6991\]
:   [Schoenwaelder, J., Ed.]{.refAuthor}, [\"Common YANG Data
    Types\"]{.refTitle}, [RFC 6991]{.seriesInfo}, [DOI
    10.17487/RFC6991]{.seriesInfo}, July 2013,
    \<<https://www.rfc-editor.org/info/rfc6991>\>.
:   

\[RFC7228\]
:   [Bormann, C.]{.refAuthor}, [Ersue, M.]{.refAuthor}, and [A.
    Keranen]{.refAuthor}, [\"Terminology for Constrained-Node
    Networks\"]{.refTitle}, [RFC 7228]{.seriesInfo}, [DOI
    10.17487/RFC7228]{.seriesInfo}, May 2014,
    \<<https://www.rfc-editor.org/info/rfc7228>\>.
:   

\[RFC7252\]
:   [Shelby, Z.]{.refAuthor}, [Hartke, K.]{.refAuthor}, and [C.
    Bormann]{.refAuthor}, [\"The Constrained Application Protocol
    (CoAP)\"]{.refTitle}, [RFC 7252]{.seriesInfo}, [DOI
    10.17487/RFC7252]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7252>\>.
:   

\[RFC7317\]
:   [Bierman, A.]{.refAuthor} and [M. Bjorklund]{.refAuthor}, [\"A YANG
    Data Model for System Management\"]{.refTitle}, [RFC
    7317]{.seriesInfo}, [DOI 10.17487/RFC7317]{.seriesInfo}, August
    2014, \<<https://www.rfc-editor.org/info/rfc7317>\>.
:   

\[RFC8343\]
:   [Bjorklund, M.]{.refAuthor}, [\"A YANG Data Model for Interface
    Management\"]{.refTitle}, [RFC 8343]{.seriesInfo}, [DOI
    10.17487/RFC8343]{.seriesInfo}, March 2018,
    \<<https://www.rfc-editor.org/info/rfc8343>\>.
:   

\[RFC8344\]
:   [Bjorklund, M.]{.refAuthor}, [\"A YANG Data Model for IP
    Management\"]{.refTitle}, [RFC 8344]{.seriesInfo}, [DOI
    10.17487/RFC8344]{.seriesInfo}, March 2018,
    \<<https://www.rfc-editor.org/info/rfc8344>\>.
:   
:::
:::

::: {#acknowledgments}
::: {#appendix-A .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

This document has been largely inspired by the extensive work done by
[Andy Bierman]{.contact-name} and [Peter van der Stok]{.contact-name} on
\[[CORE-COMI](#I-D.ietf-core-comi){.xref}\].
\[[RFC7951](#RFC7951){.xref}\] has also been a critical input to this
work. The authors would like to thank the authors and contributors of
these two documents.[¶](#appendix-A-1){.pilcrow}

The authors would also like to acknowledge the review, feedback, and
comments from [Ladislav Lhotka]{.contact-name} and [Jürgen
Schönwälder]{.contact-name} and from the Document Shepherd [Marco
Tiloca]{.contact-name}. Extensive comments helped us further improve the
document in the IESG review process; the authors would like to call out
specifically the feedback and guidance by the responsible AD [Francesca
Palombini]{.contact-name} and the significant improvements suggested by
IESG members [Benjamin Kaduk]{.contact-name} and [Rob
Wilton]{.contact-name}.[¶](#appendix-A-2){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-B .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Michel Veillette ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Trilliant Networks Inc.]{.org}
:::

::: {.left dir="auto"}
[610 Rue du Luxembourg]{.street-address}
:::

::: {.left dir="auto"}
[Granby]{.locality} [Quebec]{.region} [J2J 2V2]{.postal-code}
:::

::: {.left dir="auto"}
[Canada]{.country-name}
:::

::: email
Email: <michel.veillette@trilliantinc.com>
:::

::: {.left dir="auto"}
[Ivaylo Petrov ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google Switzerland GmbH]{.org}
:::

::: {.left dir="auto"}
[Brandschenkestrasse 110]{.street-address}
:::

::: {.left dir="auto"}
CH-[8002]{.postal-code} [Zurich]{.locality}
:::

::: {.left dir="auto"}
[Switzerland]{.country-name}
:::

::: email
Email: <ivaylopetrov@google.com>
:::

::: {.left dir="auto"}
[Alexander Pelov]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Acklio]{.org}
:::

::: {.left dir="auto"}
[1137A avenue des Champs Blancs]{.street-address}
:::

::: {.left dir="auto"}
[35510]{.postal-code} [Cesson-Sevigne Cedex]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <a@ackl.io>
:::

::: {.left dir="auto"}
[Carsten Bormann]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Universität Bremen TZI]{.org}
:::

::: {.left dir="auto"}
[Postfach 330440]{.street-address}
:::

::: {.left dir="auto"}
[D-28359]{.postal-code} [Bremen]{.locality}
:::

::: {.left dir="auto"}
[Germany]{.country-name}
:::

::: tel
Phone: [+49-421-218-63921](tel:+49-421-218-63921){.tel}
:::

::: email
Email: <cabo@tzi.org>
:::

::: {.left dir="auto"}
[Michael Richardson]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Sandelman Software Works]{.org}
:::

::: {.left dir="auto"}
[Canada]{.country-name}
:::

::: email
Email: <mcr+ietf@sandelman.ca>
:::
:::
:::
