  RFC 8985        RACK              February 2021
  --------------- ----------------- ---------------
  Cheng, et al.   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8985](https://www.rfc-editor.org/rfc/rfc8985){.eref}

Category:
:   Standards Track

Published:
:   February 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    Y. Cheng
    :::

    ::: org
    Google, Inc.
    :::
    :::

    ::: author
    ::: author-name
    N. Cardwell
    :::

    ::: org
    Google, Inc.
    :::
    :::

    ::: author
    ::: author-name
    N. Dukkipati
    :::

    ::: org
    Google, Inc.
    :::
    :::

    ::: author
    ::: author-name
    P. Jha
    :::

    ::: org
    Google, Inc.
    :::
    :::
:::

# RFC 8985 {#rfcnum}

# The RACK-TLP Loss Detection Algorithm for TCP {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document presents the RACK-TLP loss detection algorithm for TCP.
RACK-TLP uses per-segment transmit timestamps and selective
acknowledgments (SACKs) and has two parts. Recent Acknowledgment (RACK)
starts fast recovery quickly using time-based inferences derived from
acknowledgment (ACK) feedback, and Tail Loss Probe (TLP) leverages RACK
and sends a probe packet to trigger ACK feedback to avoid retransmission
timeout (RTO) events. Compared to the widely used duplicate
acknowledgment (DupAck) threshold approach, RACK-TLP detects losses more
efficiently when there are application-limited flights of data, lost
retransmissions, or data packet reordering events. It is intended to be
an alternative to the DupAck threshold
approach.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8985>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Background](#name-background){.xref}[¶](#section-toc.1-1.1.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.1.2.2}
        [1.2](#section-1.2){.xref}.  [Motivation](#name-motivation){.xref}[¶](#section-toc.1-1.1.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [RACK-TLP High-Level
    Design](#name-rack-tlp-high-level-design){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [RACK: Time-Based Loss Inferences
        from
        ACKs](#name-rack-time-based-loss-infere){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [TLP: Sending One Segment to Probe
        Losses Quickly with
        RACK](#name-tlp-sending-one-segment-to-){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [RACK-TLP: Reordering Resilience
        with a Time
        Threshold](#name-rack-tlp-reordering-resilie){.xref}[¶](#section-toc.1-1.3.2.3.1){.pilcrow}

        -   ::: {#section-toc.1-1.3.2.3.2.1}
            [3.3.1](#section-3.3.1){.xref}.  [Reordering Design
            Rationale](#name-reordering-design-rationale){.xref}[¶](#section-toc.1-1.3.2.3.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.2}
            [3.3.2](#section-3.3.2){.xref}.  [Reordering Window
            Adaptation](#name-reordering-window-adaptatio){.xref}[¶](#section-toc.1-1.3.2.3.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [An Example of RACK-TLP in Action:
        Fast
        Recovery](#name-an-example-of-rack-tlp-in-a){.xref}[¶](#section-toc.1-1.3.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.5}
        [3.5](#section-3.5){.xref}.  [An Example of RACK-TLP in Action:
        RTO](#name-an-example-of-rack-tlp-in-ac){.xref}[¶](#section-toc.1-1.3.2.5.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.6}
        [3.6](#section-3.6){.xref}.  [Design
        Summary](#name-design-summary){.xref}[¶](#section-toc.1-1.3.2.6.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Requirements](#name-requirements){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Definitions](#name-definitions){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Terms](#name-terms){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Per-Segment
        Variables](#name-per-segment-variables){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Per-Connection
        Variables](#name-per-connection-variables){.xref}[¶](#section-toc.1-1.5.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [Per-Connection
        Timers](#name-per-connection-timers){.xref}[¶](#section-toc.1-1.5.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [RACK Algorithm
    Details](#name-rack-algorithm-details){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Upon Transmitting a Data
        Segment](#name-upon-transmitting-a-data-se){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Upon Receiving an
        ACK](#name-upon-receiving-an-ack){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Upon RTO
        Expiration](#name-upon-rto-expiration){.xref}[¶](#section-toc.1-1.6.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [TLP Algorithm
    Details](#name-tlp-algorithm-details){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Initializing
        State](#name-initializing-state){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Scheduling a Loss
        Probe](#name-scheduling-a-loss-probe){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Sending a Loss Probe upon PTO
        Expiration](#name-sending-a-loss-probe-upon-p){.xref}[¶](#section-toc.1-1.7.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [Detecting Losses Using the ACK of
        the Loss
        Probe](#name-detecting-losses-using-the-){.xref}[¶](#section-toc.1-1.7.2.4.1){.pilcrow}

        -   ::: {#section-toc.1-1.7.2.4.2.1}
            [7.4.1](#section-7.4.1){.xref}.  [General Case: Detecting
            Packet Losses Using
            RACK](#name-general-case-detecting-pack){.xref}[¶](#section-toc.1-1.7.2.4.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.7.2.4.2.2}
            [7.4.2](#section-7.4.2){.xref}.  [Special Case: Detecting a
            Single Loss Repaired by the Loss
            Probe](#name-special-case-detecting-a-si){.xref}[¶](#section-toc.1-1.7.2.4.2.2.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Managing RACK-TLP
    Timers](#name-managing-rack-tlp-timers){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Discussion](#name-discussion){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Advantages and
        Disadvantages](#name-advantages-and-disadvantage){.xref}[¶](#section-toc.1-1.9.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Relationships with Other Loss
        Recovery
        Algorithms](#name-relationships-with-other-lo){.xref}[¶](#section-toc.1-1.9.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.3}
        [9.3](#section-9.3){.xref}.  [Interaction with Congestion
        Control](#name-interaction-with-congestion){.xref}[¶](#section-toc.1-1.9.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.4}
        [9.4](#section-9.4){.xref}.  [TLP Recovery Detection with
        Delayed
        ACKs](#name-tlp-recovery-detection-with){.xref}[¶](#section-toc.1-1.9.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.5}
        [9.5](#section-9.5){.xref}.  [RACK-TLP for Other Transport
        Protocols](#name-rack-tlp-for-other-transpor){.xref}[¶](#section-toc.1-1.9.2.5.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}

    -   ::: {#section-toc.1-1.12.2.1}
        [12.1](#section-12.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.12.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [12.2](#section-12.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.12.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [](#section-appendix.a){.xref}[Acknowledgments](#name-acknowledgments){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.14}
    [](#section-appendix.b){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

This document presents RACK-TLP, a TCP loss detection algorithm that
improves upon the widely implemented duplicate acknowledgment (DupAck)
counting approach described in \[[RFC5681](#RFC5681){.xref}\] and
\[[RFC6675](#RFC6675){.xref}\]; it is [RECOMMENDED]{.bcp14} as an
alternative to that earlier approach. RACK-TLP has two parts. Recent
Acknowledgment (RACK) detects losses quickly using time-based inferences
derived from ACK feedback. Tail Loss Probe (TLP) triggers ACK feedback
by quickly sending a probe segment to avoid retransmission timeout (RTO)
events.[¶](#section-1-1){.pilcrow}

::: {#background}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Background](#name-background){.section-name .selfRef} {#name-background}

In traditional TCP loss recovery algorithms
\[[RFC5681](#RFC5681){.xref}\] \[[RFC6675](#RFC6675){.xref}\], a sender
starts fast recovery when the number of DupAcks received reaches a
threshold (DupThresh) that defaults to 3 (this approach is referred to
as \"DupAck counting\" in the rest of the document). The sender also
halves the congestion window during the recovery. The rationale behind
the partial window reduction is that congestion does not seem severe
since ACK clocking is still maintained. The time elapsed in fast
recovery can be just one round trip, e.g., if the sender uses SACK-based
recovery \[[RFC6675](#RFC6675){.xref}\] and the number of lost segments
is small.[¶](#section-1.1-1){.pilcrow}

If fast recovery is not triggered or is triggered but fails to repair
all the losses, then the sender resorts to RTO recovery. The RTO timer
interval is conservatively the smoothed RTT (SRTT) plus four times the
RTT variation, and is lower bounded to 1 second
\[[RFC6298](#RFC6298){.xref}\]. Upon RTO timer expiration, the sender
retransmits the first unacknowledged segment and resets the congestion
window to the loss window value (by default, 1 full-sized segment
\[[RFC5681](#RFC5681){.xref}\]). The rationale behind the congestion
window reset is that an entire flight of data and the ACK clock were
lost, so this deserves a cautious response. The sender then retransmits
the rest of the data following the slow start algorithm
\[[RFC5681](#RFC5681){.xref}\]. The time elapsed in RTO recovery is one
RTO interval plus the number of round trips needed to repair all the
losses.[¶](#section-1.1-2){.pilcrow}
:::
:::

::: {#motivation}
::: {#section-1.2 .section}
### [1.2.](#section-1.2){.section-number .selfRef} [Motivation](#name-motivation){.section-name .selfRef} {#name-motivation}

Fast recovery is the preferred form of loss recovery because it can
potentially recover all losses in the timescale of a single round trip,
with only a fractional congestion window reduction. RTO recovery and
congestion window reset should ideally be the last resort and should
ideally be used only when the entire flight is lost. However, in
addition to losing an entire flight of data, the following situations
can unnecessarily resort to RTO recovery with traditional TCP loss
recovery algorithms \[[RFC5681](#RFC5681){.xref}\]
\[[RFC6675](#RFC6675){.xref}\]:[¶](#section-1.2-1){.pilcrow}

1.  [Packet drops for short flows or at the end of an application data
    flight. When the sender is limited by the application (e.g.,
    structured request/response traffic), segments lost at the end of
    the application data transfer often can only be recovered by RTO.
    Consider an example where only the last segment in a flight of 100
    segments is lost. Lacking any DupAck, the sender RTO expires,
    reduces the congestion window to 1, and raises the congestion window
    to just 2 after the loss repair is acknowledged. In contrast, any
    single segment loss occurring between the first and the 97th segment
    would result in fast recovery, which would only cut the window in
    half.[¶](#section-1.2-2.1){.pilcrow}]{#section-1.2-2.1}
2.  [Lost retransmissions. Heavy congestion or traffic policers can
    cause retransmissions to be lost. Lost retransmissions cause a
    resort to RTO recovery since DupAck counting does not detect the
    loss of the retransmissions. Then the slow start after RTO recovery
    could cause burst losses again, which severely degrades performance
    \[[POLICER16](#POLICER16){.xref}\].[¶](#section-1.2-2.2){.pilcrow}]{#section-1.2-2.2}
3.  [Packet reordering. In this document, \"reordering\" refers to the
    events where segments are delivered at the TCP receiver in a
    chronological order different from their chronological transmission
    order. Link-layer protocols (e.g., 802.11 block ACK), link bonding,
    or routers\' internal load balancing (e.g., ECMP) can deliver TCP
    segments out of order. The degree of such reordering is usually
    within the order of the path round-trip time. If the reordering
    degree is beyond DupThresh, DupAck counting can cause a spurious
    fast recovery and unnecessary congestion window reduction. To
    mitigate the issue, Non-Congestion Robustness (NCR) for TCP
    \[[RFC4653](#RFC4653){.xref}\] increases the DupThresh from the
    current fixed value of three duplicate ACKs
    \[[RFC5681](#RFC5681){.xref}\] to approximate a congestion window of
    data having left the
    network.[¶](#section-1.2-2.3){.pilcrow}]{#section-1.2-2.3}
:::
:::
:::
:::

::: {#terminology}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}
:::
:::

::: {#rack-tlp-high-level-design}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [RACK-TLP High-Level Design](#name-rack-tlp-high-level-design){.section-name .selfRef} {#name-rack-tlp-high-level-design}

RACK-TLP allows senders to recover losses more effectively in all three
scenarios described in the [previous](#motivation){.xref} section. There
are two design principles behind RACK-TLP. The first principle is to
detect losses via ACK events as much as possible, to repair losses at
round-trip timescales. The second principle is to gently probe the
network to solicit additional ACK feedback, to avoid RTO expiration and
subsequent congestion window reset. At a high level, the two principles
are implemented in RACK and TLP,
respectively.[¶](#section-3-1){.pilcrow}

::: {#rack-time-based-loss-inferences-from-acks}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [RACK: Time-Based Loss Inferences from ACKs](#name-rack-time-based-loss-infere){.section-name .selfRef} {#name-rack-time-based-loss-infere}

The rationale behind RACK is that if a segment is delivered out of
order, then the segments sent chronologically before that were either
lost or reordered. This concept is not fundamentally different from
those described in \[[RFC5681](#RFC5681){.xref}\],
\[[RFC6675](#RFC6675){.xref}\], or \[[FACK](#FACK){.xref}\]. RACK\'s key
innovation is using per-segment transmission timestamps and widely
deployed SACK \[[RFC2018](#RFC2018){.xref}\] options to conduct
time-based inferences instead of inferring losses by counting ACKs or
SACKed sequences. Time-based inferences are more robust than DupAck
counting approaches because they do not depend on flight size and thus
are effective for application-limited
traffic.[¶](#section-3.1-1){.pilcrow}

Conceptually, RACK keeps a virtual timer for every data segment sent
(including retransmissions). Each timer expires dynamically based on the
latest RTT measurements plus an additional delay budget to accommodate
potential packet reordering (called the \"reordering window\"). When a
segment\'s timer expires, RACK marks the corresponding segment as lost
for retransmission.[¶](#section-3.1-2){.pilcrow}

In reality, as an algorithm, RACK does not arm a timer for every segment
sent because it\'s not necessary. Instead, the sender records the most
recent transmission time of every data segment sent, including
retransmissions. For each ACK received, the sender calculates the latest
RTT measurement (if eligible) and adjusts the expiration time of every
segment sent but not yet delivered. If a segment has expired, RACK marks
it as lost.[¶](#section-3.1-3){.pilcrow}

Since the time-based logic of RACK applies equally to retransmissions
and original transmissions, it can detect lost retransmissions as well.
If a segment has been retransmitted but its most recent (re)transmission
timestamp has expired, then, after a reordering window, it\'s marked as
lost.[¶](#section-3.1-4){.pilcrow}
:::
:::

::: {#tlp-sending-one-segment-to-probe-losses-quickly-with-rack}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [TLP: Sending One Segment to Probe Losses Quickly with RACK](#name-tlp-sending-one-segment-to-){.section-name .selfRef} {#name-tlp-sending-one-segment-to-}

RACK infers losses from ACK feedback; however, in some cases, ACKs are
sparse, particularly when the inflight is small or when the losses are
high. In some challenging cases, the last few segments in a flight are
lost. With the operations described in \[[RFC5681](#RFC5681){.xref}\] or
\[[RFC6675](#RFC6675){.xref}\], the sender\'s RTO would expire and reset
the congestion window when, in reality, most of the flight has been
delivered.[¶](#section-3.2-1){.pilcrow}

Consider an example where a sender with a large congestion window
transmits 100 new data segments after an application write and only the
last three segments are lost. Without RACK-TLP, the RTO expires, the
sender retransmits the first unacknowledged segment, and the congestion
window slow starts from 1. After all the retransmits are acknowledged,
the congestion window is increased to 4. The total delivery time for
this application transfer is three RTTs plus one RTO, a steep cost given
that only a tiny fraction of the flight was lost. If instead the losses
had occurred three segments sooner in the flight, then fast recovery
would have recovered all losses within one round trip and would have
avoided resetting the congestion window.[¶](#section-3.2-2){.pilcrow}

Fast recovery would be preferable in such scenarios; TLP is designed to
trigger the feedback RACK needed to enable that. After the last (100th)
segment was originally sent, TLP sends the next available (new) segment
or retransmits the last (highest-sequenced) segment in two round trips
to probe the network, hence the name \"Tail Loss Probe\". The successful
delivery of the probe would solicit an ACK. RACK uses this ACK to detect
that the 98th and 99th segments were lost, trigger fast recovery, and
retransmit both successfully. The total recovery time is four RTTs, and
the congestion window is only partially reduced instead of being fully
reset. If the probe was also lost, then the sender would invoke RTO
recovery, resetting the congestion window.[¶](#section-3.2-3){.pilcrow}
:::
:::

::: {#rack-tlp-reordering-resilience-with-a-time-threshold}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [RACK-TLP: Reordering Resilience with a Time Threshold](#name-rack-tlp-reordering-resilie){.section-name .selfRef} {#name-rack-tlp-reordering-resilie}

::: {#reordering-design-rationale}
::: {#section-3.3.1 .section}
#### [3.3.1.](#section-3.3.1){.section-number .selfRef} [Reordering Design Rationale](#name-reordering-design-rationale){.section-name .selfRef} {#name-reordering-design-rationale}

Upon receiving an ACK indicating a SACKed segment, a sender cannot tell
immediately whether that was a result of reordering or loss. It can only
distinguish between the two in hindsight if the missing sequence ranges
are filled in later without retransmission. Thus, a loss detection
algorithm needs to budget some wait time \-- a reordering window \-- to
try to disambiguate packet reordering from packet
loss.[¶](#section-3.3.1-1){.pilcrow}

The reordering window in the DupAck counting approach is implicitly
defined as the elapsed time to receive DupThresh SACKed segments or
duplicate acknowledgments. This approach is effective if the network
reordering degree (in sequence distance) is smaller than DupThresh and
at least DupThresh segments after the loss is acknowledged. For cases
where the reordering degree is larger than the default DupThresh of 3
packets, one alternative is to dynamically adapt DupThresh based on the
FlightSize (e.g., the sender adjusts the DupThresh to half of the
FlightSize). However, this does not work well with the following two
types of reordering:[¶](#section-3.3.1-2){.pilcrow}

1.  [Application-limited flights where the last non-full-sized segment
    is delivered first and then the remaining full-sized segments in the
    flight are delivered in order. This reordering pattern can occur
    when segments traverse parallel forwarding paths. In such scenarios,
    the degree of reordering in packet distance is one segment less than
    the flight
    size.[¶](#section-3.3.1-3.1){.pilcrow}]{#section-3.3.1-3.1}
2.  [A flight of segments that are delivered partially out of order. One
    cause for this pattern is wireless link-layer retransmissions with
    an inadequate reordering buffer at the receiver. In such scenarios,
    the wireless sender sends the data packets in order initially, but
    some are lost and then recovered by link-layer retransmissions; the
    wireless receiver delivers the TCP data packets in the order they
    are received due to the inadequate reordering buffer. The random
    wireless transmission errors in such scenarios cause the reordering
    degree, expressed in packet distance, to have highly variable values
    up to the flight
    size.[¶](#section-3.3.1-3.2){.pilcrow}]{#section-3.3.1-3.2}

In the above two cases, the degree of reordering in packet distance is
highly variable. This makes the DupAck counting approach ineffective,
including dynamic adaptation variants as in
\[[RFC4653](#RFC4653){.xref}\]. Instead, the degree of reordering in
time difference in such cases is usually within a single round-trip
time. This is because the packets either traverse disjoint paths with
similar propagation delays or are repaired quickly by the local access
technology. Hence, using a time threshold instead of a packet threshold
strikes a middle ground, allowing a bounded degree of reordering
resilience while still allowing fast recovery. This is the rationale
behind the RACK-TLP reordering resilience
design.[¶](#section-3.3.1-4){.pilcrow}

Specifically, RACK-TLP introduces a new dynamic reordering window
parameter in time units, and the sender considers a data segment S lost
if both of these conditions are met:[¶](#section-3.3.1-5){.pilcrow}

1.  [Another data segment sent later than S has been
    delivered.[¶](#section-3.3.1-6.1){.pilcrow}]{#section-3.3.1-6.1}
2.  [S has not been delivered after the estimated round-trip time plus
    the reordering
    window.[¶](#section-3.3.1-6.2){.pilcrow}]{#section-3.3.1-6.2}

Note that condition (1) implies at least one round trip of time has
elapsed since S has been sent.[¶](#section-3.3.1-7){.pilcrow}
:::
:::

::: {#reordering-window-adaptation}
::: {#section-3.3.2 .section}
#### [3.3.2.](#section-3.3.2){.section-number .selfRef} [Reordering Window Adaptation](#name-reordering-window-adaptatio){.section-name .selfRef} {#name-reordering-window-adaptatio}

The RACK reordering window adapts to the measured duration of reordering
events within reasonable and specific bounds to disincentivize excessive
reordering. More specifically, the sender sets the reordering window as
follows:[¶](#section-3.3.2-1){.pilcrow}

1.  ::: {#section-3.3.2-2.1}
    ::: {#rule1}
    The reordering window [SHOULD]{.bcp14} be set to zero if no
    reordering has been observed on the connection so far, and
    either (a) three segments have been SACKed since the last recovery
    or (b) the sender is already in fast or RTO recovery. Otherwise, the
    reordering window [SHOULD]{.bcp14} start from a small fraction of
    the round-trip time or zero if no round-trip time estimate is
    available.[¶](#rule1){.pilcrow}
    :::
    :::

2.  ::: {#section-3.3.2-2.2}
    ::: {#rule2}
    The RACK reordering window [SHOULD]{.bcp14} adaptively increase
    (using the [algorithm](#step4alg){.xref} in [\"Step 4: Update RACK
    reordering window\"](#step4){.xref} below) if the sender receives a
    Duplicate Selective Acknowledgment (DSACK) option
    \[[RFC2883](#RFC2883){.xref}\]. Receiving a DSACK suggests the
    sender made a spurious retransmission, which may have been due to
    the reordering window being too small.[¶](#rule2){.pilcrow}
    :::
    :::

3.  ::: {#section-3.3.2-2.3}
    ::: {#rule3}
    The RACK reordering window [MUST]{.bcp14} be bounded, and this bound
    [SHOULD]{.bcp14} be SRTT.[¶](#rule3){.pilcrow}
    :::
    :::

Rules [2](#rule2){.xref} and [3](#rule3){.xref} are required to adapt to
reordering caused by dynamics such as the prolonged link-layer loss
recovery episodes described earlier. Each increase in the reordering
window requires a new round trip where the sender receives a DSACK;
thus, depending on the extent of reordering, it may take multiple round
trips to fully adapt.[¶](#section-3.3.2-3){.pilcrow}

For short flows, the low initial reordering window helps recover losses
quickly, at the risk of spurious retransmissions. The rationale is that
spurious retransmissions for short flows are not expected to produce
excessive additional network traffic. For long flows, the design
tolerates reordering within a round trip. This handles reordering in
small timescales (reordering within the round-trip time of the shortest
path).[¶](#section-3.3.2-4){.pilcrow}

However, the fact that the initial reordering window is low and the
reordering window\'s adaptive growth is bounded means that there will
continue to be a cost to reordering that disincentivizes excessive
reordering.[¶](#section-3.3.2-5){.pilcrow}
:::
:::
:::
:::

::: {#an-example-of-rack-tlp-in-action-fast-recovery}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [An Example of RACK-TLP in Action: Fast Recovery](#name-an-example-of-rack-tlp-in-a){.section-name .selfRef} {#name-an-example-of-rack-tlp-in-a}

The following example in [Figure 1](#fig1){.xref} illustrates the
RACK-TLP algorithm in action:[¶](#section-3.4-1){.pilcrow}

[]{#name-rack-tlp-protocol-example}

::: {#fig1}
::: {#section-3.4-2.1 .artwork .art-text .alignLeft}
     Event  TCP DATA SENDER                            TCP DATA RECEIVER
     _____  ____________________________________________________________
       1.   Send P0, P1, P2, P3          -->
            [P1, P2, P3 dropped by network]

       2.                                <--          Receive P0, ACK P0

       3a.  2RTTs after (2), TLP timer fires
       3b.  TLP: retransmits P3          -->

       4.                                <--         Receive P3, SACK P3

       5a.  Receive SACK for P3
       5b.  RACK: marks P1, P2 lost
       5c.  Retransmit P1, P2            -->
            [P1 retransmission dropped by network]

       6.                                <--    Receive P2, SACK P2 & P3

       7a.  RACK: marks P1 retransmission lost
       7b.  Retransmit P1                -->

       8.                                <--          Receive P1, ACK P3
:::

[Figure 1](#figure-1){.selfRef}: [RACK-TLP Protocol
Example](#name-rack-tlp-protocol-example){.selfRef}
:::

::: {#fig1desc}
[Figure 1](#fig1){.xref} illustrates a sender sending four segments (P0,
P1, P2, P3) and losing the last three segments. After two round trips,
TLP sends a loss probe, retransmitting the last segment, P3, to solicit
SACK feedback and restore the ACK clock (Event 3). The delivery of P3
enables RACK to infer (Event 5b) that P1 and P2 were likely lost because
they were sent before P3. The sender then retransmits P1 and P2.
Unfortunately, the retransmission of P1 is lost again. However, the
delivery of the retransmission of P2 allows RACK to infer that the
retransmission of P1 was likely lost (Event 7a); hence, P1 should be
retransmitted (Event 7b). Note that \[[RFC5681](#RFC5681){.xref}\]
mandates a principle that loss in two successive windows of data or the
loss of a retransmission must be taken as two indications of congestion
and therefore results in two separate congestion control
reactions.[¶](#section-3.4-3){.pilcrow}
:::
:::
:::

::: {#an-example-of-rack-tlp-in-action-rto}
::: {#section-3.5 .section}
### [3.5.](#section-3.5){.section-number .selfRef} [An Example of RACK-TLP in Action: RTO](#name-an-example-of-rack-tlp-in-ac){.section-name .selfRef} {#name-an-example-of-rack-tlp-in-ac}

In addition to enhancing fast recovery, RACK improves the accuracy of
RTO recovery by reducing spurious
retransmissions.[¶](#section-3.5-1){.pilcrow}

Without RACK, upon RTO timer expiration, the sender marks all the
unacknowledged segments as lost. This approach can lead to spurious
retransmissions. For example, consider a simple case where one segment
was sent with an RTO of 1 second and then the application writes more
data, causing a second and third segment to be sent right before the RTO
of the first segment expires. Suppose none of the segments were lost.
Without RACK, if there is a spurious RTO, then the sender marks all
three segments as lost and retransmits the first segment. If the ACK for
the original copy of the first segment arrives right after the spurious
RTO retransmission, then the sender continues slow start and spuriously
retransmits the second and third segments since it (erroneously)
presumed they are lost.[¶](#section-3.5-2){.pilcrow}

With RACK, upon RTO timer expiration, the only segment automatically
marked as lost is the first segment (since it was sent an RTO ago); for
all the other segments, RACK only marks the segment as lost if at least
one round trip has elapsed since the segment was transmitted. Consider
the previous example scenario, but this time with RACK. With RACK, when
the RTO expires, the sender only marks the first segment as lost and
retransmits that segment. The other two very recently sent segments are
not marked as lost because they were sent less than one round trip ago
and there were no ACKs providing evidence that they were lost. Upon
receiving the ACK for the RTO retransmission, the RACK sender would not
yet retransmit the second or third segment, but rather would re-arm the
RTO timer and wait for a new RTO interval to elapse before marking the
second or third segment as lost.[¶](#section-3.5-3){.pilcrow}
:::
:::

::: {#design-summary}
::: {#section-3.6 .section}
### [3.6.](#section-3.6){.section-number .selfRef} [Design Summary](#name-design-summary){.section-name .selfRef} {#name-design-summary}

To summarize, RACK-TLP aims to adapt to small time-varying degrees of
reordering, quickly recover most losses within one to two round trips,
and avoid costly RTO recoveries. In the presence of reordering, the
adaptation algorithm can impose sometimes needless delays when it waits
to disambiguate loss from reordering, but the penalty for waiting is
bounded to one round trip, and such delays are confined to flows long
enough to have observed reordering.[¶](#section-3.6-1){.pilcrow}
:::
:::
:::
:::

::: {#requirements}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Requirements](#name-requirements){.section-name .selfRef} {#name-requirements}

The reader is expected to be familiar with the definitions given in the
TCP congestion control \[[RFC5681](#RFC5681){.xref}\], selective
acknowledgment \[[RFC2018](#RFC2018){.xref}\], and loss recovery
\[[RFC6675](#RFC6675){.xref}\] RFCs. RACK-TLP has the following
requirements:[¶](#section-4-1){.pilcrow}

1.  [The connection [MUST]{.bcp14} use selective acknowledgment (SACK)
    options \[[RFC2018](#RFC2018){.xref}\], and the sender
    [MUST]{.bcp14} keep SACK scoreboard information on a per-connection
    basis (\"SACK scoreboard\" has the same meaning here as in
    \[[RFC6675](#RFC6675){.xref}\], [Section
    3](https://www.rfc-editor.org/rfc/rfc6675#section-3){.relref}).[¶](#section-4-2.1){.pilcrow}]{#section-4-2.1}
2.  [For each data segment sent, the sender [MUST]{.bcp14} store its
    most recent transmission time with a timestamp whose granularity is
    finer than 1/4 of the minimum RTT of the connection. At the time of
    writing, microsecond resolution is suitable for intra-data center
    traffic, and millisecond granularity or finer is suitable for the
    Internet. Note that RACK-TLP can be implemented with TSO (TCP
    Segmentation Offload) support by having multiple segments in a TSO
    aggregate share the same
    timestamp.[¶](#section-4-2.2){.pilcrow}]{#section-4-2.2}
3.  [RACK DSACK-based reordering window adaptation is
    [RECOMMENDED]{.bcp14} but is not
    required.[¶](#section-4-2.3){.pilcrow}]{#section-4-2.3}
4.  [TLP requires RACK.[¶](#section-4-2.4){.pilcrow}]{#section-4-2.4}
:::
:::

::: {#definitions}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Definitions](#name-definitions){.section-name .selfRef} {#name-definitions}

The reader is expected to be familiar with the variables SND.UNA,
SND.NXT, SEG.ACK, and SEG.SEQ in \[[RFC793](#RFC0793){.xref}\]; Sender
Maximum Segment Size (SMSS) and FlightSize in
\[[RFC5681](#RFC5681){.xref}\]; DupThresh in
\[[RFC6675](#RFC6675){.xref}\]; and RTO and SRTT in
\[[RFC6298](#RFC6298){.xref}\]. A RACK-TLP implementation uses several
new terms and needs to store new per-segment and per-connection state,
described below.[¶](#section-5-1){.pilcrow}

::: {#terms}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Terms](#name-terms){.section-name .selfRef} {#name-terms}

These terms are used to explain the variables and algorithms
below:[¶](#section-5.1-1){.pilcrow}

[]{.break}

RACK.segment
:   Among all the segments that have been either selectively or
    cumulatively acknowledged, the term \"RACK.segment\" denotes the
    segment that was sent most recently (including
    retransmissions).[¶](#section-5.1-2.2){.pilcrow}
:   

RACK.ack_ts
:   Denotes the time when the full sequence range of RACK.segment was
    selectively or cumulatively
    acknowledged.[¶](#section-5.1-2.4){.pilcrow}
:   
:::
:::

::: {#per-segment-variables}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Per-Segment Variables](#name-per-segment-variables){.section-name .selfRef} {#name-per-segment-variables}

These variables indicate the status of the most recent transmission of a
data segment:[¶](#section-5.2-1){.pilcrow}

[]{.break}

Segment.lost
:   True if the most recent (re)transmission of the segment has been
    marked as lost and needs to be retransmitted. False
    otherwise.[¶](#section-5.2-2.2){.pilcrow}
:   

Segment.retransmitted
:   True if the segment has ever been retransmitted. False
    otherwise.[¶](#section-5.2-2.4){.pilcrow}
:   

Segment.xmit_ts
:   The time of the last transmission of a data segment, including
    retransmissions, if any, with a clock granularity specified in the
    [\"Requirements\"](#requirements){.xref} section. A maximum value
    INFINITE_TS indicates an invalid timestamp that represents that the
    segment is not currently in flight.[¶](#section-5.2-2.6){.pilcrow}
:   

Segment.end_seq
:   The next sequence number after the last sequence number of the data
    segment.[¶](#section-5.2-2.8){.pilcrow}
:   
:::
:::

::: {#per-connection-variables}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Per-Connection Variables](#name-per-connection-variables){.section-name .selfRef} {#name-per-connection-variables}

[]{.break}

RACK.xmit_ts
:   The latest transmission timestamp of
    RACK.segment.[¶](#section-5.3-1.2){.pilcrow}
:   

RACK.end_seq
:   The Segment.end_seq of RACK.segment.[¶](#section-5.3-1.4){.pilcrow}
:   

RACK.segs_sacked
:   Returns the total number of segments selectively acknowledged in the
    SACK scoreboard.[¶](#section-5.3-1.6){.pilcrow}
:   

RACK.fack
:   The highest selectively or cumulatively acknowledged sequence (i.e.,
    forward acknowledgment).[¶](#section-5.3-1.8){.pilcrow}
:   

RACK.min_RTT
:   The estimated minimum round-trip time (RTT) of the
    connection.[¶](#section-5.3-1.10){.pilcrow}
:   

RACK.rtt
:   The RTT of the most recently delivered segment on the connection
    (either cumulatively acknowledged or selectively acknowledged) that
    was not marked as invalid as a possible spurious
    retransmission.[¶](#section-5.3-1.12){.pilcrow}
:   

RACK.reordering_seen
:   Indicates whether the sender has detected data segment reordering
    event(s).[¶](#section-5.3-1.14){.pilcrow}
:   

RACK.reo_wnd
:   A reordering window computed in the unit of time used for recording
    segment transmission times. It is used to defer the moment at which
    RACK marks a segment as lost.[¶](#section-5.3-1.16){.pilcrow}
:   

RACK.dsack_round
:   Indicates if a DSACK option has been received in the latest round
    trip.[¶](#section-5.3-1.18){.pilcrow}
:   

RACK.reo_wnd_mult
:   The multiplier applied to adjust
    RACK.reo_wnd.[¶](#section-5.3-1.20){.pilcrow}
:   

RACK.reo_wnd_persist
:   The number of loss recoveries before resetting
    RACK.reo_wnd.[¶](#section-5.3-1.22){.pilcrow}
:   

TLP.is_retrans
:   A boolean indicating whether there is an unacknowledged TLP
    retransmission.[¶](#section-5.3-1.24){.pilcrow}
:   

TLP.end_seq
:   The value of SND.NXT at the time of sending a TLP
    probe.[¶](#section-5.3-1.26){.pilcrow}
:   

TLP.max_ack_delay:
:   The sender\'s budget for the maximum delayed ACK
    interval.[¶](#section-5.3-1.28){.pilcrow}
:   
:::
:::

::: {#per-connection-timers}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [Per-Connection Timers](#name-per-connection-timers){.section-name .selfRef} {#name-per-connection-timers}

[]{.break}

RACK reordering timer
:   A timer that allows RACK to wait for reordering to resolve in order
    to try to disambiguate reordering from loss when some segments are
    marked as SACKed.[¶](#section-5.4-1.2){.pilcrow}
:   

TLP PTO
:   A timer event indicating that an ACK is overdue and the sender
    should transmit a TLP segment to solicit SACK or ACK
    feedback.[¶](#section-5.4-1.4){.pilcrow}
:   

These timers augment the existing timers maintained by a sender,
including the RTO timer \[[RFC6298](#RFC6298){.xref}\]. A RACK-TLP
sender arms one of these three timers \-- RACK reordering timer, TLP PTO
timer, or RTO timer \-- when it has unacknowledged segments in flight.
The implementation can simplify managing all three timers by
multiplexing a single timer among them with an additional variable to
indicate the event to invoke upon the next timer
expiration.[¶](#section-5.4-2){.pilcrow}
:::
:::
:::
:::

::: {#rack-algorithm-details}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [RACK Algorithm Details](#name-rack-algorithm-details){.section-name .selfRef} {#name-rack-algorithm-details}

::: {#upon-transmitting-a-data-segment}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Upon Transmitting a Data Segment](#name-upon-transmitting-a-data-se){.section-name .selfRef} {#name-upon-transmitting-a-data-se}

Upon transmitting a new segment or retransmitting an old segment, record
the time in Segment.xmit_ts and set Segment.lost to FALSE. Upon
retransmitting a segment, set Segment.retransmitted to
TRUE.[¶](#section-6.1-1){.pilcrow}

::: {#section-6.1-2}
``` {.sourcecode .lang-pseudocode}
RACK_transmit_new_data(Segment):
        Segment.xmit_ts = Now()
        Segment.lost = FALSE

RACK_retransmit_data(Segment):
        Segment.retransmitted = TRUE
        Segment.xmit_ts = Now()
        Segment.lost = FALSE
```

[¶](#section-6.1-2){.pilcrow}
:::
:::
:::

::: {#upon-receiving-an-ack}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Upon Receiving an ACK](#name-upon-receiving-an-ack){.section-name .selfRef} {#name-upon-receiving-an-ack}

::: {#step1}
Step 1: Update RACK.min_RTT.[¶](#section-6.2-1){.pilcrow}
:::

Use the RTT measurements obtained via \[[RFC6298](#RFC6298){.xref}\] or
\[[RFC7323](#RFC7323){.xref}\] to update the estimated minimum RTT in
RACK.min_RTT. The sender [SHOULD]{.bcp14} track a windowed min-filtered
estimate of recent RTT measurements that can adapt when migrating to
significantly longer paths rather than tracking a simple global minimum
of all RTT measurements.[¶](#section-6.2-2){.pilcrow}

::: {#step2}
Step 2: Update the state for the most recently sent segment that has
been delivered.[¶](#section-6.2-3){.pilcrow}
:::

In this step, RACK updates the state that tracks the most recently sent
segment that has been delivered: RACK.segment. RACK maintains its latest
transmission timestamp in RACK.xmit_ts and its highest sequence number
in RACK.end_seq. These two variables are used in later steps to estimate
if some segments not yet delivered were likely lost. Given the
information provided in an ACK, each segment cumulatively ACKed or
SACKed is marked as delivered in the scoreboard. Because an ACK can also
acknowledge retransmitted data segments and because retransmissions can
be spurious, the sender needs to take care to avoid spurious inferences.
For example, if the sender were to use timing information from a
spurious retransmission, the RACK.rtt could be vastly
underestimated.[¶](#section-6.2-4){.pilcrow}

To avoid spurious inferences, ignore a segment as invalid if any of its
sequence range has been retransmitted before and if either of two
conditions is true:[¶](#section-6.2-5){.pilcrow}

1.  [The Timestamp Echo Reply field (TSecr) of the ACK\'s timestamp
    option \[[RFC7323](#RFC7323){.xref}\], if available, indicates the
    ACK was not acknowledging the last retransmission of the
    segment.[¶](#section-6.2-6.1){.pilcrow}]{#section-6.2-6.1}
2.  [The segment was last retransmitted less than RACK.min_rtt
    ago.[¶](#section-6.2-6.2){.pilcrow}]{#section-6.2-6.2}

The second check is a heuristic when the TCP Timestamp option is not
available or when the round-trip time is less than the TCP Timestamp
clock granularity.[¶](#section-6.2-7){.pilcrow}

Among all the segments newly ACKed or SACKed by this ACK that pass the
checks above, update the RACK.rtt to be the RTT sample calculated using
this ACK. Furthermore, record the most recent Segment.xmit_ts in
RACK.xmit_ts if it is ahead of RACK.xmit_ts. If Segment.xmit_ts equals
RACK.xmit_ts (e.g., due to clock granularity limits), then compare
Segment.end_seq and RACK.end_seq to break the tie when deciding whether
to update the RACK.segment\'s associated
state.[¶](#section-6.2-8){.pilcrow}

Step 2 may be summarized in pseudocode as:[¶](#section-6.2-9){.pilcrow}

::: {#section-6.2-10}
``` {.sourcecode .lang-pseudocode}
RACK_sent_after(t1, seq1, t2, seq2):
    If t1 > t2:
        Return true
    Else if t1 == t2 AND seq1 > seq2:
        Return true
    Else:
        Return false

RACK_update():
    For each Segment newly acknowledged, cumulatively or selectively,
    in ascending order of Segment.xmit_ts:
        rtt = Now() - Segment.xmit_ts
        If Segment.retransmitted is TRUE:
            If ACK.ts_option.echo_reply < Segment.xmit_ts:
               Continue
            If rtt < RACK.min_rtt:
               Continue

        RACK.rtt = rtt
        If RACK_sent_after(Segment.xmit_ts, Segment.end_seq
                           RACK.xmit_ts, RACK.end_seq):
            RACK.xmit_ts = Segment.xmit_ts
            RACK.end_seq = Segment.end_seq
```

[¶](#section-6.2-10){.pilcrow}
:::

::: {#step3}
Step 3: Detect data segment reordering.[¶](#section-6.2-11){.pilcrow}
:::

To detect reordering, the sender looks for original data segments being
delivered out of order. To detect such cases, the sender tracks the
highest sequence selectively or cumulatively acknowledged in the
RACK.fack variable. \".fack\" stands for the most \"Forward ACK\" (this
term is adopted from \[[FACK](#FACK){.xref}\]). If a never-retransmitted
segment that\'s below RACK.fack is (selectively or cumulatively)
acknowledged, it has been delivered out of order. The sender sets
RACK.reordering_seen to TRUE if such a segment is
identified.[¶](#section-6.2-12){.pilcrow}

::: {#section-6.2-13}
``` {.sourcecode .lang-pseudocode}
RACK_detect_reordering():
    For each Segment newly acknowledged, cumulatively or selectively,
    in ascending order of Segment.end_seq:
        If Segment.end_seq > RACK.fack:
            RACK.fack = Segment.end_seq
        Else if Segment.end_seq < RACK.fack AND
                Segment.retransmitted is FALSE:
            RACK.reordering_seen = TRUE
```

[¶](#section-6.2-13){.pilcrow}
:::

::: {#step4}
Step 4: Update the RACK reordering window.[¶](#section-6.2-14){.pilcrow}
:::

The RACK reordering window, RACK.reo_wnd, serves as an adaptive
allowance for settling time before marking a segment as lost. This step
documents a detailed algorithm that follows the principles outlined in
the [\"Reordering Window
Adaptation\"](#reordering-window-adaptation){.xref}
section.[¶](#section-6.2-15){.pilcrow}

If no reordering has been observed based on the [previous
step](#step3){.xref}, then one way the sender can enter fast recovery is
when the number of SACKed segments matches or exceeds DupThresh (similar
to \[[RFC6675](#RFC6675){.xref}\]). Furthermore, when no reordering has
been observed, the RACK.reo_wnd is set to 0 both upon entering and
during fast recovery or RTO recovery.[¶](#section-6.2-16){.pilcrow}

Otherwise, if some reordering has been observed, then RACK does not
trigger fast recovery based on DupThresh.[¶](#section-6.2-17){.pilcrow}

Whether or not reordering has been observed, RACK uses the reordering
window to assess whether any segments can be marked as lost. As a
consequence, the sender also enters fast recovery when there are any
number of SACKed segments, as long as the reorder window has passed for
some non-SACKed segments.[¶](#section-6.2-18){.pilcrow}

When the reordering window is not set to 0, it starts with a
conservative RACK.reo_wnd of RACK.min_RTT/4. This value was chosen
because Linux TCP used the same factor in its implementation to delay
Early Retransmit \[[RFC5827](#RFC5827){.xref}\] to reduce spurious loss
detections in the presence of reordering, and experience showed this
worked reasonably well
\[[DMCG11](#DMCG11){.xref}\].[¶](#section-6.2-19){.pilcrow}

However, the reordering detection in the previous step, [Step
3](#step3){.xref}, has a self-reinforcing drawback when the reordering
window is too small to cope with the actual reordering. When that
happens, RACK could spuriously mark reordered segments as lost, causing
them to be retransmitted. In turn, the retransmissions can prevent the
necessary conditions for [Step 3](#step3){.xref} to detect reordering
since this mechanism requires ACKs or SACKs only for segments that have
never been retransmitted. In some cases, such scenarios can persist,
causing RACK to continue to spuriously mark segments as lost without
realizing the reordering window is too
small.[¶](#section-6.2-20){.pilcrow}

To avoid the issue above, RACK dynamically adapts to higher degrees of
reordering using DSACK options from the receiver. Receiving an ACK with
a DSACK option indicates a possible spurious retransmission, suggesting
that RACK.reo_wnd may be too small. The RACK.reo_wnd increases linearly
for every round trip in which the sender receives some DSACK option so
that after N round trips in which a DSACK is received, the RACK.reo_wnd
becomes (N+1) \* min_RTT / 4, with an upper-bound of
SRTT.[¶](#section-6.2-21){.pilcrow}

If the reordering is temporary, then a large adapted reordering window
would unnecessarily delay loss recovery later. Therefore, RACK persists
using the inflated RACK.reo_wnd for up to 16 loss recoveries, after
which it resets RACK.reo_wnd to its starting value, min_RTT / 4. The
downside of resetting the reordering window is the risk of triggering
spurious fast recovery episodes if the reordering remains high. The
rationale for this approach is to bound such spurious recoveries to
approximately once every 16 recoveries (less than
7%).[¶](#section-6.2-22){.pilcrow}

To track the linear scaling factor for the adaptive reordering window,
RACK uses the variable RACK.reo_wnd_mult, which is initialized to 1 and
adapts with the observed reordering.[¶](#section-6.2-23){.pilcrow}

The following pseudocode implements the above algorithm for updating the
RACK reordering window:[¶](#section-6.2-24){.pilcrow}

::: {#step4alg}
::: {#section-6.2-25}
``` {.sourcecode .lang-pseudocode}
RACK_update_reo_wnd():

    /* DSACK-based reordering window adaptation */
    If RACK.dsack_round is not None AND
       SND.UNA >= RACK.dsack_round:
        RACK.dsack_round = None
    /* Grow the reordering window per round that sees DSACK.
       Reset the window after 16 DSACK-free recoveries */
    If RACK.dsack_round is None AND
       any DSACK option is present on latest received ACK:
        RACK.dsack_round = SND.NXT
        RACK.reo_wnd_mult += 1
        RACK.reo_wnd_persist = 16
    Else if exiting Fast or RTO recovery:
        RACK.reo_wnd_persist -= 1
        If RACK.reo_wnd_persist <= 0:
            RACK.reo_wnd_mult = 1

    If RACK.reordering_seen is FALSE:
        If in Fast or RTO recovery:
            Return 0
        Else if RACK.segs_sacked >= DupThresh:
            Return 0
    Return min(RACK.reo_wnd_mult * RACK.min_RTT / 4, SRTT)
```

[¶](#section-6.2-25){.pilcrow}
:::
:::

::: {#step5}
Step 5: Detect losses.[¶](#section-6.2-26){.pilcrow}
:::

For each segment that has not been SACKed, RACK considers that segment
lost if another segment that was sent later has been delivered and the
reordering window has passed. RACK considers the reordering window to
have passed if the RACK.segment was sent a sufficient time after the
segment in question, if a sufficient time has elapsed since the
RACK.segment was S/ACKed, or some combination of the two. More
precisely, RACK marks a segment as lost
if:[¶](#section-6.2-27){.pilcrow}

::: {#section-6.2-28}
``` {.sourcecode .lang-pseudocode}
 RACK.xmit_ts >= Segment.xmit_ts
        AND
 RACK.xmit_ts - Segment.xmit_ts + (now - RACK.ack_ts) >= RACK.reo_wnd
```

[¶](#section-6.2-28){.pilcrow}
:::

Solving this second condition for \"now\", the moment at which a segment
is marked as lost, yields:[¶](#section-6.2-29){.pilcrow}

::: {#section-6.2-30}
``` {.sourcecode .lang-pseudocode}
now >= Segment.xmit_ts + RACK.reo_wnd + (RACK.ack_ts - RACK.xmit_ts)
```

[¶](#section-6.2-30){.pilcrow}
:::

Then (RACK.ack_ts - RACK.xmit_ts) is the round-trip time of the most
recently (re)transmitted segment that\'s been delivered. When segments
are delivered in order, the most recently (re)transmitted segment
that\'s been delivered is also the most recently delivered; hence,
RACK.rtt == RACK.ack_ts - RACK.xmit_ts. But if segments were reordered,
then the segment delivered most recently was sent before the most
recently (re)transmitted segment. Hence, RACK.rtt \> (RACK.ack_ts -
RACK.xmit_ts).[¶](#section-6.2-31){.pilcrow}

Since RACK.RTT \>= (RACK.ack_ts - RACK.xmit_ts), the previous equation
reduces to saying that the sender can declare a segment lost
when:[¶](#section-6.2-32){.pilcrow}

::: {#section-6.2-33}
``` {.sourcecode .lang-pseudocode}
now >= Segment.xmit_ts + RACK.reo_wnd + RACK.rtt
```

[¶](#section-6.2-33){.pilcrow}
:::

In turn, that is equivalent to stating that a RACK sender should declare
a segment lost when:[¶](#section-6.2-34){.pilcrow}

::: {#section-6.2-35}
``` {.sourcecode .lang-pseudocode}
Segment.xmit_ts + RACK.rtt + RACK.reo_wnd - now <= 0
```

[¶](#section-6.2-35){.pilcrow}
:::

Note that if the value on the left-hand side is positive, it represents
the remaining wait time before the segment is deemed lost. But this
risks a timeout (RTO) if no more ACKs come back (e.g., due to losses or
application-limited transmissions) to trigger the marking. For timely
loss detection, it is [RECOMMENDED]{.bcp14} that the sender install a
reordering timer. This timer expires at the earliest moment when RACK
would conclude that all the unacknowledged segments within the
reordering window were lost.[¶](#section-6.2-36){.pilcrow}

The following pseudocode implements the algorithm above. When an ACK is
received or the RACK reordering timer expires, call
RACK_detect_loss_and_arm_timer(). The algorithm breaks timestamp ties by
using the TCP sequence space since high-speed networks often have
multiple segments with identical
timestamps.[¶](#section-6.2-37){.pilcrow}

::: {#section-6.2-38}
``` {.sourcecode .lang-pseudocode}
RACK_detect_loss():
    timeout = 0
    RACK.reo_wnd = RACK_update_reo_wnd()
    For each segment, Segment, not acknowledged yet:
        If RACK_sent_after(RACK.xmit_ts, RACK.end_seq,
                           Segment.xmit_ts, Segment.end_seq):
            remaining = Segment.xmit_ts + RACK.rtt +
                        RACK.reo_wnd - Now()
            If remaining <= 0:
                Segment.lost = TRUE
                Segment.xmit_ts = INFINITE_TS
            Else:
                timeout = max(remaining, timeout)
    Return timeout

RACK_detect_loss_and_arm_timer():
    timeout = RACK_detect_loss()
    If timeout != 0
        Arm the RACK timer to call
        RACK_detect_loss_and_arm_timer() after timeout
```

[¶](#section-6.2-38){.pilcrow}
:::

As an optimization, an implementation can choose to check only segments
that have been sent before RACK.xmit_ts. This can be more efficient than
scanning the entire SACK scoreboard, especially when there are many
segments in flight. The implementation can use a separate doubly linked
list ordered by Segment.xmit_ts, insert a segment at the tail of the
list when it is (re)transmitted, and remove a segment from the list when
it is delivered or marked as lost. In Linux TCP, this optimization
improved CPU usage by orders of magnitude during some fast recovery
episodes on high-speed WAN networks.[¶](#section-6.2-39){.pilcrow}
:::
:::

::: {#upon-rto-expiration}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Upon RTO Expiration](#name-upon-rto-expiration){.section-name .selfRef} {#name-upon-rto-expiration}

Upon RTO timer expiration, RACK marks the first outstanding segment as
lost (since it was sent an RTO ago); for all the other segments, RACK
only marks the segment as lost if the time elapsed since the segment was
transmitted is at least the sum of the recent RTT and the reordering
window.[¶](#section-6.3-1){.pilcrow}

::: {#section-6.3-2}
``` {.sourcecode .lang-pseudocode}
RACK_mark_losses_on_RTO():
    For each segment, Segment, not acknowledged yet:
        If SEG.SEQ == SND.UNA OR
           Segment.xmit_ts + RACK.rtt + RACK.reo_wnd - Now() <= 0:
            Segment.lost = TRUE
```

[¶](#section-6.3-2){.pilcrow}
:::
:::
:::
:::
:::

::: {#tlp-algorithm-details}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [TLP Algorithm Details](#name-tlp-algorithm-details){.section-name .selfRef} {#name-tlp-algorithm-details}

::: {#initializing-state}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Initializing State](#name-initializing-state){.section-name .selfRef} {#name-initializing-state}

Reset TLP.is_retrans and TLP.end_seq when initiating a connection, fast
recovery, or RTO recovery.[¶](#section-7.1-1){.pilcrow}

::: {#section-7.1-2}
``` {.sourcecode .lang-pseudocode}
TLP_init():
    TLP.end_seq = None
    TLP.is_retrans = false
```

[¶](#section-7.1-2){.pilcrow}
:::
:::
:::

::: {#scheduling-a-loss-probe}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Scheduling a Loss Probe](#name-scheduling-a-loss-probe){.section-name .selfRef} {#name-scheduling-a-loss-probe}

The sender schedules a loss probe timeout (PTO) to transmit a segment
during the normal transmission process. The sender [SHOULD]{.bcp14}
start or restart a loss probe PTO timer after transmitting new data
(that was not itself a loss probe) or upon receiving an ACK that
cumulatively acknowledges new data unless it is already in fast
recovery, RTO recovery, or segments have been SACKed (i.e.,
RACK.segs_sacked is not zero). These conditions are excluded because
they are addressed by similar mechanisms, like Limited Transmit
\[[RFC3042](#RFC3042){.xref}\], the RACK reordering timer, and Forward
RTO-Recovery (F-RTO)
\[[RFC5682](#RFC5682){.xref}\].[¶](#section-7.2-1){.pilcrow}

The sender calculates the PTO interval by taking into account a number
of factors.[¶](#section-7.2-2){.pilcrow}

First, the default PTO interval is 2\*SRTT. By that time, it is prudent
to declare that an ACK is overdue since under normal circumstances,
i.e., no losses, an ACK typically arrives in one SRTT. Choosing the PTO
to be exactly an SRTT would risk causing spurious probes given that
network and end-host delay variance can cause an ACK to be delayed
beyond the SRTT. Hence, the PTO is conservatively chosen to be the next
integral multiple of SRTT.[¶](#section-7.2-3){.pilcrow}

Second, when there is no SRTT estimate available, the PTO
[SHOULD]{.bcp14} be 1 second. This conservative value corresponds to the
RTO value when no SRTT is available, per
\[[RFC6298](#RFC6298){.xref}\].[¶](#section-7.2-4){.pilcrow}

Third, when the FlightSize is one segment, the sender [MAY]{.bcp14}
inflate the PTO by TLP.max_ack_delay to accommodate a potentially
delayed acknowledgment and reduce the risk of spurious retransmissions.
The actual value of TLP.max_ack_delay is implementation
specific.[¶](#section-7.2-5){.pilcrow}

Finally, if the time at which an RTO would fire (here denoted as
\"TCP_RTO_expiration()\") is sooner than the computed time for the PTO,
then the sender schedules a TLP to be sent at that RTO
time.[¶](#section-7.2-6){.pilcrow}

Summarizing these considerations in pseudocode form, a sender
[SHOULD]{.bcp14} use the following logic to select the duration of a
PTO:[¶](#section-7.2-7){.pilcrow}

::: {#section-7.2-8}
``` {.sourcecode .lang-pseudocode}
TLP_calc_PTO():
    If SRTT is available:
        PTO = 2 * SRTT
        If FlightSize is one segment:
           PTO += TLP.max_ack_delay
    Else:
        PTO = 1 sec

    If Now() + PTO > TCP_RTO_expiration():
        PTO = TCP_RTO_expiration() - Now()
```

[¶](#section-7.2-8){.pilcrow}
:::
:::
:::

::: {#sending-a-loss-probe-upon-pto-expiration}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Sending a Loss Probe upon PTO Expiration](#name-sending-a-loss-probe-upon-p){.section-name .selfRef} {#name-sending-a-loss-probe-upon-p}

When the PTO timer expires, the sender [MUST]{.bcp14} check whether both
of the following conditions are met before sending a loss
probe:[¶](#section-7.3-1){.pilcrow}

1.  [First, there is no other previous loss probe still in flight. This
    ensures that, at any given time, the sender has at most one
    additional packet in flight beyond the congestion window limit. This
    invariant is maintained using the state variable TLP.end_seq, which
    indicates the latest unacknowledged TLP loss probe\'s ending
    sequence. It is reset when the loss probe has been acknowledged or
    is deemed lost or
    irrelevant.[¶](#section-7.3-2.1){.pilcrow}]{#section-7.3-2.1}
2.  [Second, the sender has obtained an RTT measurement since the last
    loss probe transmission or the start of the connection, whichever
    was later. This condition ensures that loss probe retransmissions do
    not prevent taking the RTT samples necessary to adapt SRTT to an
    increase in path
    RTT.[¶](#section-7.3-2.2){.pilcrow}]{#section-7.3-2.2}

If either one of these two conditions is not met, then the sender
[MUST]{.bcp14} skip sending a loss probe and [MUST]{.bcp14} proceed to
re-arm the RTO timer, as specified at the end of this
section.[¶](#section-7.3-3){.pilcrow}

If both conditions are met, then the sender [SHOULD]{.bcp14} transmit a
previously unsent data segment, if one exists and the receive window
allows, and increment the FlightSize accordingly. Note that the
FlightSize could be one packet greater than the congestion window
temporarily until the next ACK arrives.[¶](#section-7.3-4){.pilcrow}

If such an unsent segment is not available, then the sender
[SHOULD]{.bcp14} retransmit the highest-sequence segment sent so far and
set TLP.is_retrans to true. This segment is chosen to deal with the
retransmission ambiguity problem in TCP. Suppose a sender sends N
segments and then retransmits the last segment (segment N) as a loss
probe, after which the sender receives a SACK for segment N. As long as
the sender waits for the RACK reordering window to expire, it doesn\'t
matter if that SACK was for the original transmission of segment N or
the TLP retransmission; in either case, the arrival of the SACK for
segment N provides evidence that the N-1 segments preceding segment N
were likely lost.[¶](#section-7.3-5){.pilcrow}

In a case where there is only one original outstanding segment of data
(N=1), the same logic (trivially) applies: an ACK for a single
outstanding segment tells the sender that the N-1=0 segments preceding
that segment were lost. Furthermore, whether there are N>1 or N=1
outstanding segments, there is a question about whether the original
last segment or its TLP retransmission were lost; the sender estimates
whether there was such a loss using TLP recovery detection (see
below).[¶](#section-7.3-6){.pilcrow}

The sender [MUST]{.bcp14} follow the RACK transmission procedures in the
[\"Upon Transmitting a Data
Segment\"](#upon-transmitting-a-data-segment){.xref} section upon
sending either a retransmission or a new data loss probe. This is
critical for detecting losses using the ACK for the loss
probe.[¶](#section-7.3-7){.pilcrow}

After attempting to send a loss probe, regardless of whether a loss
probe was sent, the sender [MUST]{.bcp14} re-arm the RTO timer, not the
PTO timer, if the FlightSize is not zero. This ensures RTO recovery
remains the last resort if TLP fails. The following pseudocode
summarizes the operations.[¶](#section-7.3-8){.pilcrow}

::: {#section-7.3-9}
``` {.sourcecode .lang-pseudocode}
TLP_send_probe():

    If TLP.end_seq is None and
       Sender has taken a new RTT sample since last probe or
       the start of connection:
        TLP.is_retrans = false
        Segment = send buffer segment starting at SND.NXT
        If Segment exists and fits the peer receive window limit:
           /* Transmit the lowest-sequence unsent Segment */
           Transmit Segment
           RACK_transmit_data(Segment)
           TLP.end_seq = SND.NXT
           Increase FlightSize by Segment length
        Else:
           /* Retransmit the highest-sequence Segment sent */
           Segment = send buffer segment ending at SND.NXT
           Transmit Segment
           RACK_retransmit_data(Segment)
           TLP.end_seq = SND.NXT
           TLP.is_retrans = true

    If FlightSize is not zero:
        Rearm RTO timer to fire at timeout = now + RTO
```

[¶](#section-7.3-9){.pilcrow}
:::
:::
:::

::: {#detecting-losses-using-the-ack-of-the-loss-probe}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [Detecting Losses Using the ACK of the Loss Probe](#name-detecting-losses-using-the-){.section-name .selfRef} {#name-detecting-losses-using-the-}

When there is packet loss in a flight ending with a loss probe, the
feedback solicited by a loss probe will reveal one of two scenarios,
depending on the pattern of losses.[¶](#section-7.4-1){.pilcrow}

::: {#general-case-detecting-packet-losses-using-rack-}
::: {#section-7.4.1 .section}
#### [7.4.1.](#section-7.4.1){.section-number .selfRef} [General Case: Detecting Packet Losses Using RACK](#name-general-case-detecting-pack){.section-name .selfRef} {#name-general-case-detecting-pack}

If the loss probe and the ACK that acknowledges the probe are delivered
successfully, RACK-TLP uses this ACK \-- just as it would with any other
ACK \-- to detect if any segments sent prior to the probe were dropped.
RACK would typically infer that any unacknowledged data segments sent
before the loss probe were lost, since they were sent sufficiently far
in the past (where at least one PTO has elapsed, plus one round trip for
the loss probe to be ACKed). More specifically, RACK_detect_loss()
([Step 5](#step5){.xref}) would mark those earlier segments as lost.
Then the sender would trigger a fast recovery to recover those
losses.[¶](#section-7.4.1-1){.pilcrow}
:::
:::

::: {#special-case-detecting-a-single-loss-repaired-by-the-loss-probe}
::: {#section-7.4.2 .section}
#### [7.4.2.](#section-7.4.2){.section-number .selfRef} [Special Case: Detecting a Single Loss Repaired by the Loss Probe](#name-special-case-detecting-a-si){.section-name .selfRef} {#name-special-case-detecting-a-si}

If the TLP retransmission repairs all the lost in-flight sequence ranges
(i.e., only the last segment in the flight was lost), the ACK for the
loss probe appears to be a regular cumulative ACK, which would not
normally trigger the congestion control response to this packet loss
event. The following TLP recovery detection mechanism examines ACKs to
detect this special case to make congestion control respond properly
\[[RFC5681](#RFC5681){.xref}\].[¶](#section-7.4.2-1){.pilcrow}

After a TLP retransmission, the sender checks for this special case of a
single loss that is recovered by the loss probe itself. To accomplish
this, the sender checks for a duplicate ACK or DSACK indicating that
both the original segment and TLP retransmission arrived at the
receiver, which means there was no loss. If the TLP sender does not
receive such an indication, then it [MUST]{.bcp14} assume that the
original data segment, the TLP retransmission, or a corresponding ACK
was lost for congestion control purposes.[¶](#section-7.4.2-2){.pilcrow}

If the TLP retransmission is spurious, a receiver that uses DSACK would
return an ACK that covers TLP.end_seq with a DSACK option (Case 1). If
the receiver does not support DSACK, it would return a DupAck without
any SACK option (Case 2). If the sender receives an ACK matching either
case, then the sender estimates that the receiver received both the
original data segment and the TLP probe retransmission. The sender
considers the TLP episode to be done and records that fact by setting
TLP.end_seq to None.[¶](#section-7.4.2-3){.pilcrow}

Upon receiving an ACK that covers some sequence number after
TLP.end_seq, the sender should have received any ACKs for the original
segment and TLP probe retransmission segment. At that time, if the
TLP.end_seq is still set and thus indicates that the TLP probe
retransmission remains unacknowledged, then the sender should presume
that at least one of its data segments was lost. The sender then
[SHOULD]{.bcp14} invoke a congestion control response equivalent to a
fast recovery.[¶](#section-7.4.2-4){.pilcrow}

More precisely, on each ACK, the sender executes the
following:[¶](#section-7.4.2-5){.pilcrow}

::: {#section-7.4.2-6}
``` {.sourcecode .lang-pseudocode}
TLP_process_ack(ACK):
    If TLP.end_seq is not None AND ACK's ack. number >= TLP.end_seq:
        If not TLP.is_retrans:
            TLP.end_seq = None    /* TLP of new data delivered */
        Else if ACK has a DSACK option matching TLP.end_seq:
            TLP.end_seq = None    /* Case 1, above */
        Else If ACK's ack. number > TLP.end_seq:
            TLP.end_seq = None    /* Repaired the single loss */
            (Invoke congestion control to react to
             the loss event the probe has repaired)
        Else If ACK is a DupAck without any SACK option:
            TLP.end_seq = None     /* Case 2, above */
```

[¶](#section-7.4.2-6){.pilcrow}
:::
:::
:::
:::
:::
:::
:::

::: {#managing-rack-tlp-timers}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Managing RACK-TLP Timers](#name-managing-rack-tlp-timers){.section-name .selfRef} {#name-managing-rack-tlp-timers}

The RACK reordering timer, the TLP PTO timer, the RTO, and Zero Window
Probe (ZWP) timer \[[RFC793](#RFC0793){.xref}\] are mutually exclusive
and are used in different scenarios. When arming a RACK reordering timer
or TLP PTO timer, the sender [SHOULD]{.bcp14} cancel any other pending
timers. An implementation is expected to have one timer with an
additional state variable indicating the type of the
timer.[¶](#section-8-1){.pilcrow}
:::
:::

::: {#discussion}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Discussion](#name-discussion){.section-name .selfRef} {#name-discussion}

::: {#advantages-and-disadvantages}
::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Advantages and Disadvantages](#name-advantages-and-disadvantage){.section-name .selfRef} {#name-advantages-and-disadvantage}

The biggest advantage of RACK-TLP is that every data segment, whether it
is an original data transmission or a retransmission, can be used to
detect losses of the segments sent chronologically prior to it. This
enables RACK-TLP to use fast recovery in cases with application-limited
flights of data, lost retransmissions, or data segment reordering
events. Consider the following examples:[¶](#section-9.1-1){.pilcrow}

1.  [Packet drops at the end of an application data flight: Consider a
    sender that transmits an application-limited flight of three data
    segments (P1, P2, P3), and P1 and P3 are lost. Suppose the
    transmission of each segment is at least RACK.reo_wnd after the
    transmission of the previous segment. RACK will mark P1 as lost when
    the SACK of P2 is received, and this will trigger the retransmission
    of P1 as R1. When R1 is cumulatively acknowledged, RACK will mark P3
    as lost, and the sender will retransmit P3 as R3. This example
    illustrates how RACK is able to repair certain drops at the tail of
    a transaction without an RTO recovery. Notice that neither the
    conventional duplicate ACK threshold \[[RFC5681](#RFC5681){.xref}\],
    nor the loss recovery algorithm \[[RFC6675](#RFC6675){.xref}\], nor
    the Forward Acknowledgment \[[FACK](#FACK){.xref}\] algorithm can
    detect such losses because of the required segment or sequence
    count.[¶](#section-9.1-2.1){.pilcrow}]{#section-9.1-2.1}
2.  [Lost retransmission: Consider a flight of three data segments (P1,
    P2, P3) that are sent; P1 and P2 are dropped. Suppose the
    transmission of each segment is at least RACK.reo_wnd after the
    transmission of the previous segment. When P3 is SACKed, RACK will
    mark P1 and P2 as lost, and they will be retransmitted as R1 and R2.
    Suppose R1 is lost again but R2 is SACKed; RACK will mark R1 as lost
    and trigger retransmission again. Again, neither the conventional
    three-duplicate ACK threshold approach, nor the loss recovery
    algorithm \[[RFC6675](#RFC6675){.xref}\], nor the Forward
    Acknowledgment \[[FACK](#FACK){.xref}\] algorithm can detect such
    losses. And such a lost retransmission can happen when TCP is being
    rate-limited, particularly by token bucket policers with a large
    bucket depth and low rate limit; in such cases, retransmissions are
    often lost repeatedly because standard congestion control requires
    multiple round trips to reduce the rate below the policed
    rate.[¶](#section-9.1-2.2){.pilcrow}]{#section-9.1-2.2}
3.  [Packet reordering: Consider a simple reordering event where a
    flight of segments are sent as (P1, P2, P3). P1 and P2 carry a full
    payload of Maximum Sender Size (MSS) octets, but P3 has only a
    1-octet payload. Suppose the sender has detected reordering
    previously and thus RACK.reo_wnd is min_RTT/4. Now P3 is reordered
    and delivered first, before P1 and P2. As long as P1 and P2 are
    delivered within min_RTT/4, RACK will not consider P1 and P2 lost.
    But if P1 and P2 are delivered outside the reordering window, then
    RACK will still spuriously mark P1 and P2 as
    lost.[¶](#section-9.1-2.3){.pilcrow}]{#section-9.1-2.3}

The examples above show that RACK-TLP is particularly useful when the
sender is limited by the application, which can happen with interactive
or request/response traffic. Similarly, RACK still works when the sender
is limited by the receive window, which can happen with applications
that use the receive window to throttle the
sender.[¶](#section-9.1-3){.pilcrow}

RACK-TLP works more efficiently with TCP Segmentation Offload (TSO)
compared to DupAck counting. RACK always marks the entire TSO aggregate
as lost because the segments in the same TSO aggregate have the same
transmission timestamp. By contrast, the algorithms based on sequence
counting (e.g., \[[RFC6675](#RFC6675){.xref}\],
\[[RFC5681](#RFC5681){.xref}\]) may mark only a subset of segments in
the TSO aggregate as lost, forcing the stack to perform expensive
fragmentation of the TSO aggregate or to selectively tag individual
segments as lost in the scoreboard.[¶](#section-9.1-4){.pilcrow}

The main drawback of RACK-TLP is the additional state required compared
to DupAck counting. RACK requires the sender to record the transmission
time of each segment sent at a clock granularity that is finer than 1/4
of the minimum RTT of the connection. TCP implementations that already
record this for RTT estimation do not require any new per-packet state.
But implementations that are not yet recording segment transmission
times will need to add per-packet internal state (expected to be either
4 or 8 octets per segment or TSO aggregate) to track transmission times.
In contrast, the loss detection approach described in
\[[RFC6675](#RFC6675){.xref}\] does not require any per-packet state
beyond the SACK scoreboard; this is particularly useful on ultra-low RTT
networks where the RTT may be less than the sender TCP clock granularity
(e.g., inside data centers). Another disadvantage is that the reordering
timer may expire prematurely (like any other retransmission timer) and
cause higher spurious retransmissions, especially if DSACK is not
supported.[¶](#section-9.1-5){.pilcrow}
:::
:::

::: {#relationships-with-other-loss-recovery-algorithms}
::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Relationships with Other Loss Recovery Algorithms](#name-relationships-with-other-lo){.section-name .selfRef} {#name-relationships-with-other-lo}

The primary motivation of RACK-TLP is to provide a general alternative
to some of the standard loss recovery algorithms
\[[RFC5681](#RFC5681){.xref}\] \[[RFC6675](#RFC6675){.xref}\]
\[[RFC5827](#RFC5827){.xref}\] \[[RFC4653](#RFC4653){.xref}\]. In
particular, the SACK loss recovery algorithm for TCP
\[[RFC6675](#RFC6675){.xref}\] is not designed to handle lost
retransmissions, so its NextSeg() does not work for lost
retransmissions, and it does not specify the corresponding required
additional congestion response. Therefore, the algorithm
\[[RFC6675](#RFC6675){.xref}\] [MUST NOT]{.bcp14} be used with RACK-TLP;
instead, a modified recovery algorithm that carefully addresses such a
case is needed.[¶](#section-9.2-1){.pilcrow}

The Early Retransmit mechanism \[[RFC5827](#RFC5827){.xref}\] and NCR
for TCP \[[RFC4653](#RFC4653){.xref}\] dynamically adjust the duplicate
ACK threshold based on the current or previous flight sizes. RACK-TLP
takes a different approach by using a time-based reordering window.
RACK-TLP can be seen as an extended Early Retransmit
\[[RFC5827](#RFC5827){.xref}\] without a FlightSize limit but with an
additional reordering window. \[[FACK](#FACK){.xref}\] considers an
original segment to be lost when its sequence range is sufficiently far
below the highest SACKed sequence. In some sense, RACK-TLP can be seen
as a generalized form of FACK that operates in time space instead of
sequence space, enabling it to better handle reordering,
application-limited traffic, and lost
retransmissions.[¶](#section-9.2-2){.pilcrow}

RACK-TLP is compatible with the standard RTO
\[[RFC6298](#RFC6298){.xref}\], RTO Restart
\[[RFC7765](#RFC7765){.xref}\], F-RTO \[[RFC5682](#RFC5682){.xref}\],
and Eifel algorithms \[[RFC3522](#RFC3522){.xref}\]. This is because
RACK-TLP only detects loss by using ACK events. It neither changes the
RTO timer calculation nor detects spurious RTOs. RACK-TLP slightly
changes the behavior of \[[RFC6298](#RFC6298){.xref}\] by preceding the
RTO with a TLP and reducing potential spurious retransmissions after
RTO.[¶](#section-9.2-3){.pilcrow}
:::
:::

::: {#interaction-with-congestion-control}
::: {#section-9.3 .section}
### [9.3.](#section-9.3){.section-number .selfRef} [Interaction with Congestion Control](#name-interaction-with-congestion){.section-name .selfRef} {#name-interaction-with-congestion}

RACK-TLP intentionally decouples loss detection from congestion control.
RACK-TLP only detects losses; it does not modify the congestion control
algorithm \[[RFC5681](#RFC5681){.xref}\] \[[RFC6937](#RFC6937){.xref}\].
A segment marked as lost by RACK-TLP [MUST NOT]{.bcp14} be retransmitted
until congestion control deems this appropriate. As mentioned in the
paragraph following [Figure 1](#fig1){.xref} ([Section 3.4, Paragraph
3](#fig1desc){.xref}), \[[RFC5681](#RFC5681){.xref}\] mandates a
principle that loss in two successive windows of data or the loss of a
retransmission must be taken as two indications of congestion and
therefore trigger two separate reactions. The Proportional Rate
Reduction (PRR) algorithm \[[RFC6937](#RFC6937){.xref}\] is
[RECOMMENDED]{.bcp14} for the specific congestion control actions taken
upon the losses detected by RACK-TLP. In the absence of PRR
\[[RFC6937](#RFC6937){.xref}\], when RACK-TLP detects a lost
retransmission, the congestion control [MUST]{.bcp14} trigger an
additional congestion response per the aforementioned principle in
\[[RFC5681](#RFC5681){.xref}\]. If multiple original transmissions or
retransmissions were lost in a window, the congestion control specified
in \[[RFC5681](#RFC5681){.xref}\] only reacts once per window. The
congestion control implementer is advised to carefully consider this
subtle situation introduced by RACK-TLP.[¶](#section-9.3-1){.pilcrow}

The only exception \-- the only way in which RACK-TLP modulates the
congestion control algorithm \-- is that one outstanding loss probe can
be sent even if the congestion window is fully used. However, this
temporary overcommit is accounted for and credited in the in-flight data
tracked for congestion control, so that congestion control will erase
the overcommit upon the next ACK.[¶](#section-9.3-2){.pilcrow}

If packet losses happen after reordering has been observed, RACK-TLP may
take longer to detect losses than the pure DupAck counting approach. In
this case, TCP may continue to increase the congestion window upon
receiving ACKs during this time, making the sender more
aggressive.[¶](#section-9.3-3){.pilcrow}

The following simple example compares how RACK-TLP and non-RACK-TLP loss
detection interact with congestion control: suppose a sender has a
congestion window (cwnd) of 20 segments on a SACK-enabled connection. It
sends 10 data segments, and all of them are
lost.[¶](#section-9.3-4){.pilcrow}

Without RACK-TLP, the sender would time out, reset cwnd to 1, and
retransmit the first segment. It would take four round trips (1 + 2 + 4
+ 3 = 10) to retransmit all the 10 lost segments using slow start. The
recovery latency would be RTO + 4\*RTT, with an ending cwnd of 4
segments due to congestion window
validation.[¶](#section-9.3-5){.pilcrow}

With RACK-TLP, a sender would send the TLP after 2\*RTT and get a
DupAck, enabling RACK to detect the losses and trigger fast recovery. If
the sender implements Proportional Rate Reduction
\[[RFC6937](#RFC6937){.xref}\], it would slow start to retransmit the
remaining 9 lost segments since the number of segments in flight (0) is
lower than the slow start threshold (10). The slow start would again
take four round trips (1 + 2 + 4 + 3 = 10) to retransmit all the lost
segments. The recovery latency would be 2\*RTT + 4\*RTT, with an ending
cwnd set to the slow-start threshold of 10
segments.[¶](#section-9.3-6){.pilcrow}

The difference in recovery latency (RTO + 4\*RTT vs 6\*RTT) can be
significant if the RTT is much smaller than the minimum RTO (1 second in
\[[RFC6298](#RFC6298){.xref}\]) or if the RTT is large. The former case
can happen in local area networks, data center networks, or content
distribution networks with deep deployments. The latter case can happen
in developing regions with highly congested and/or high-latency
networks.[¶](#section-9.3-7){.pilcrow}
:::
:::

::: {#tlp-recovery-detection-with-delayed-acks}
::: {#section-9.4 .section}
### [9.4.](#section-9.4){.section-number .selfRef} [TLP Recovery Detection with Delayed ACKs](#name-tlp-recovery-detection-with){.section-name .selfRef} {#name-tlp-recovery-detection-with}

Delayed or stretched ACKs complicate the detection of repairs done by
TLP since, with such ACKs, the sender takes a longer time to receive
fewer ACKs than would normally be expected. To mitigate this
complication, before sending a TLP loss probe retransmission, the sender
should attempt to wait long enough that the receiver has sent any
delayed ACKs that it is withholding. The sender algorithm described
above features such a delay in the form of TLP.max_ack_delay.
Furthermore, if the receiver supports DSACK, then, in the case of a
delayed ACK, the sender\'s TLP recovery detection mechanism (see above)
can use the DSACK information to infer that the original and TLP
retransmission both arrived at the
receiver.[¶](#section-9.4-1){.pilcrow}

If there is ACK loss or a delayed ACK without a DSACK, then this
algorithm is conservative because the sender will reduce the congestion
window when, in fact, there was no packet loss. In practice, this is
acceptable and potentially even desirable: if there is reverse path
congestion, then reducing the congestion window can be
prudent.[¶](#section-9.4-2){.pilcrow}
:::
:::

::: {#rack-tlp-for-other-transport-protocols}
::: {#section-9.5 .section}
### [9.5.](#section-9.5){.section-number .selfRef} [RACK-TLP for Other Transport Protocols](#name-rack-tlp-for-other-transpor){.section-name .selfRef} {#name-rack-tlp-for-other-transpor}

RACK-TLP can be implemented in other transport protocols (e.g.,
\[[QUIC-LR](#I-D.ietf-quic-recovery){.xref}\]). The
\[[SPROUT](#SPROUT){.xref}\] loss detection algorithm was also
independently designed to use a 10 ms reordering window to improve its
loss detection similar to RACK.[¶](#section-9.5-1){.pilcrow}
:::
:::
:::
:::

::: {#security-considerations}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

RACK-TLP algorithm behavior is based on information conveyed in SACK
options, so it has security considerations similar to those described in
the Security Considerations section of
\[[RFC6675](#RFC6675){.xref}\].[¶](#section-10-1){.pilcrow}

Additionally, RACK-TLP has a lower risk profile than the loss recovery
algorithm \[[RFC6675](#RFC6675){.xref}\] because it is not vulnerable to
ACK-splitting attacks \[[SCWA99](#SCWA99){.xref}\]: for an MSS-sized
segment sent, the receiver or the attacker might send MSS ACKs that
selectively or cumulatively acknowledge one additional byte per ACK.
This would not fool RACK. In such a scenario, RACK.xmit_ts would not
advance because all the sequence ranges within the segment were
transmitted at the same time and thus carry the same transmission
timestamp. In other words, SACKing only one byte of a segment or SACKing
the segment in entirety have the same effect with
RACK.[¶](#section-10-2){.pilcrow}
:::
:::

::: {#iana-considerations}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-11-1){.pilcrow}
:::
:::

::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-12.1 .section}
### [12.1.](#section-12.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2018\]
:   [Mathis, M.]{.refAuthor}[, Mahdavi, J.]{.refAuthor}[,
    Floyd, S.]{.refAuthor}[, and A. Romanow]{.refAuthor}, [\"TCP
    Selective Acknowledgment Options\"]{.refTitle}, [RFC
    2018]{.seriesInfo}, [DOI 10.17487/RFC2018]{.seriesInfo}, October
    1996, \<<https://www.rfc-editor.org/info/rfc2018>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC2883\]
:   [Floyd, S.]{.refAuthor}[, Mahdavi, J.]{.refAuthor}[,
    Mathis, M.]{.refAuthor}[, and M. Podolsky]{.refAuthor}, [\"An
    Extension to the Selective Acknowledgement (SACK) Option for
    TCP\"]{.refTitle}, [RFC 2883]{.seriesInfo}, [DOI
    10.17487/RFC2883]{.seriesInfo}, July 2000,
    \<<https://www.rfc-editor.org/info/rfc2883>\>.
:   

\[RFC5681\]
:   [Allman, M.]{.refAuthor}[, Paxson, V.]{.refAuthor}[, and E.
    Blanton]{.refAuthor}, [\"TCP Congestion Control\"]{.refTitle}, [RFC
    5681]{.seriesInfo}, [DOI 10.17487/RFC5681]{.seriesInfo}, September
    2009, \<<https://www.rfc-editor.org/info/rfc5681>\>.
:   

\[RFC6298\]
:   [Paxson, V.]{.refAuthor}[, Allman, M.]{.refAuthor}[,
    Chu, J.]{.refAuthor}[, and M. Sargent]{.refAuthor}, [\"Computing
    TCP\'s Retransmission Timer\"]{.refTitle}, [RFC 6298]{.seriesInfo},
    [DOI 10.17487/RFC6298]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6298>\>.
:   

\[RFC6675\]
:   [Blanton, E.]{.refAuthor}[, Allman, M.]{.refAuthor}[,
    Wang, L.]{.refAuthor}[, Jarvinen, I.]{.refAuthor}[,
    Kojo, M.]{.refAuthor}[, and Y. Nishida]{.refAuthor}, [\"A
    Conservative Loss Recovery Algorithm Based on Selective
    Acknowledgment (SACK) for TCP\"]{.refTitle}, [RFC
    6675]{.seriesInfo}, [DOI 10.17487/RFC6675]{.seriesInfo}, August
    2012, \<<https://www.rfc-editor.org/info/rfc6675>\>.
:   

\[RFC7323\]
:   [Borman, D.]{.refAuthor}[, Braden, B.]{.refAuthor}[,
    Jacobson, V.]{.refAuthor}[, and R. Scheffenegger, Ed.]{.refAuthor},
    [\"TCP Extensions for High Performance\"]{.refTitle}, [RFC
    7323]{.seriesInfo}, [DOI 10.17487/RFC7323]{.seriesInfo}, September
    2014, \<<https://www.rfc-editor.org/info/rfc7323>\>.
:   

\[RFC793\]
:   [Postel, J.]{.refAuthor}, [\"Transmission Control
    Protocol\"]{.refTitle}, [STD 7]{.seriesInfo}, [RFC
    793]{.seriesInfo}, [DOI 10.17487/RFC0793]{.seriesInfo}, September
    1981, \<<https://www.rfc-editor.org/info/rfc793>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   
:::

::: {#section-12.2 .section}
### [12.2.](#section-12.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[DMCG11\]
:   [Dukkipati, N.]{.refAuthor}[, Matthis, M.]{.refAuthor}[,
    Cheng, Y.]{.refAuthor}[, and M. Ghobadi]{.refAuthor},
    [\"Proportional Rate Reduction for TCP\"]{.refTitle}, [Proceedings
    of the 2011 ACM SIGCOMM Conference on Internet Measurement
    Conference pp. 155-170]{.seriesInfo}, [DOI
    10.1145/2068816.2068832]{.seriesInfo}, November 2011,
    \<<https://doi.org/10.1145/2068816.2068832>\>.
:   

\[FACK\]
:   [Mathis, M.]{.refAuthor}[ and J. Mahdavi]{.refAuthor}, [\"Forward
    acknowledgement: refining TCP congestion control\"]{.refTitle}, [ACM
    SIGCOMM Computer Communication Review Volume 26, Issue
    4]{.seriesInfo}, [DOI 10.1145/248157.248181]{.seriesInfo}, August
    1996, \<<https://doi.org/10.1145/248157.248181>\>.
:   

\[POLICER16\]
:   [Flach, T.]{.refAuthor}[, Papageorge, P.]{.refAuthor}[,
    Terzis, A.]{.refAuthor}[, Pedrosa, L.]{.refAuthor}[,
    Cheng, Y.]{.refAuthor}[, Karim, T.]{.refAuthor}[,
    Katz-Bassett, E.]{.refAuthor}[, and R. Govindan]{.refAuthor}, [\"An
    Internet-Wide Analysis of Traffic Policing\"]{.refTitle},
    [Proceedings of the 2016 ACM SIGCOMM Conference pp.
    468-482]{.refContent}, [DOI 10.1145/2934872.2934873]{.seriesInfo},
    August 2016, \<<https://doi.org/10.1145/2934872.2934873>\>.
:   

\[QUIC-LR\]
:   [Iyengar, J.]{.refAuthor}[ and I. Swett]{.refAuthor}, [\"QUIC Loss
    Detection and Congestion Control\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-quic-recovery-34]{.seriesInfo}, 14 January 2021,
    \<<https://tools.ietf.org/html/draft-ietf-quic-recovery-34>\>.
:   

\[RFC3042\]
:   [Allman, M.]{.refAuthor}[, Balakrishnan, H.]{.refAuthor}[, and S.
    Floyd]{.refAuthor}, [\"Enhancing TCP\'s Loss Recovery Using Limited
    Transmit\"]{.refTitle}, [RFC 3042]{.seriesInfo}, [DOI
    10.17487/RFC3042]{.seriesInfo}, January 2001,
    \<<https://www.rfc-editor.org/info/rfc3042>\>.
:   

\[RFC3522\]
:   [Ludwig, R.]{.refAuthor}[ and M. Meyer]{.refAuthor}, [\"The Eifel
    Detection Algorithm for TCP\"]{.refTitle}, [RFC 3522]{.seriesInfo},
    [DOI 10.17487/RFC3522]{.seriesInfo}, April 2003,
    \<<https://www.rfc-editor.org/info/rfc3522>\>.
:   

\[RFC4653\]
:   [Bhandarkar, S.]{.refAuthor}[, Reddy, A. L. N.]{.refAuthor}[,
    Allman, M.]{.refAuthor}[, and E. Blanton]{.refAuthor}, [\"Improving
    the Robustness of TCP to Non-Congestion Events\"]{.refTitle}, [RFC
    4653]{.seriesInfo}, [DOI 10.17487/RFC4653]{.seriesInfo}, August
    2006, \<<https://www.rfc-editor.org/info/rfc4653>\>.
:   

\[RFC5682\]
:   [Sarolahti, P.]{.refAuthor}[, Kojo, M.]{.refAuthor}[,
    Yamamoto, K.]{.refAuthor}[, and M. Hata]{.refAuthor}, [\"Forward
    RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious
    Retransmission Timeouts with TCP\"]{.refTitle}, [RFC
    5682]{.seriesInfo}, [DOI 10.17487/RFC5682]{.seriesInfo}, September
    2009, \<<https://www.rfc-editor.org/info/rfc5682>\>.
:   

\[RFC5827\]
:   [Allman, M.]{.refAuthor}[, Avrachenkov, K.]{.refAuthor}[,
    Ayesta, U.]{.refAuthor}[, Blanton, J.]{.refAuthor}[, and P.
    Hurtig]{.refAuthor}, [\"Early Retransmit for TCP and Stream Control
    Transmission Protocol (SCTP)\"]{.refTitle}, [RFC 5827]{.seriesInfo},
    [DOI 10.17487/RFC5827]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5827>\>.
:   

\[RFC6937\]
:   [Mathis, M.]{.refAuthor}[, Dukkipati, N.]{.refAuthor}[, and Y.
    Cheng]{.refAuthor}, [\"Proportional Rate Reduction for
    TCP\"]{.refTitle}, [RFC 6937]{.seriesInfo}, [DOI
    10.17487/RFC6937]{.seriesInfo}, May 2013,
    \<<https://www.rfc-editor.org/info/rfc6937>\>.
:   

\[RFC7765\]
:   [Hurtig, P.]{.refAuthor}[, Brunstrom, A.]{.refAuthor}[,
    Petlund, A.]{.refAuthor}[, and M. Welzl]{.refAuthor}, [\"TCP and
    Stream Control Transmission Protocol (SCTP) RTO
    Restart\"]{.refTitle}, [RFC 7765]{.seriesInfo}, [DOI
    10.17487/RFC7765]{.seriesInfo}, February 2016,
    \<<https://www.rfc-editor.org/info/rfc7765>\>.
:   

\[SCWA99\]
:   [Savage, S.]{.refAuthor}[, Cardwell, N.]{.refAuthor}[,
    Wetherall, D.]{.refAuthor}[, and T. Anderson]{.refAuthor}, [\"TCP
    congestion control with a misbehaving receiver\"]{.refTitle}, [ACM
    Computer Communication Review 29(5)]{.seriesInfo}, [DOI
    10.1145/505696.505704]{.seriesInfo}, October 1999,
    \<<https://doi.org/10.1145/505696.505704>\>.
:   

\[SPROUT\]
:   [Winstein, K.]{.refAuthor}[, Sivaraman, A.]{.refAuthor}[, and H.
    Balakrishnan]{.refAuthor}, [\"Stochastic Forecasts Achieve High
    Throughput and Low Delay over Cellular Networks\"]{.refTitle}, [10th
    USENIX Symposium on Networked Systems Design and Implementation
    (NSDI \'13)\"]{.refContent}, 2013.
:   
:::
:::

::: {#acknowledgments}
::: {#section-appendix.a .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

The authors thank [Matt Mathis]{.contact-name} for his insights in FACK
and [Michael Welzl]{.contact-name} for his per-packet timer idea that
inspired this work. [Eric Dumazet]{.contact-name}, [Randy
Stewart]{.contact-name}, [Van Jacobson]{.contact-name}, [Ian
Swett]{.contact-name}, [Rick Jones]{.contact-name}, [Jana
Iyengar]{.contact-name}, [Hiren Panchasara]{.contact-name}, [Praveen
Balasubramanian]{.contact-name}, [Yoshifumi Nishida]{.contact-name},
[Bob Briscoe]{.contact-name}, [Felix Weinrank]{.contact-name}, [Michael
Tüxen]{.contact-name}, [Martin Duke]{.contact-name}, [Ilpo
Jarvinen]{.contact-name}, [Theresa Enghardt]{.contact-name}, [Mirja
Kühlewind]{.contact-name}, [Gorry Fairhurst]{.contact-name}, [Markku
Kojo]{.contact-name}, and [Yi Huang]{.contact-name} contributed to this
document or the implementations in Linux, FreeBSD, Windows, and
QUIC.[¶](#section-appendix.a-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.b .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Yuchung Cheng]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google, Inc.]{.org}
:::

::: email
Email: <ycheng@google.com>
:::

::: {.left dir="auto"}
[Neal Cardwell]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google, Inc.]{.org}
:::

::: email
Email: <ncardwell@google.com>
:::

::: {.left dir="auto"}
[Nandita Dukkipati]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google, Inc.]{.org}
:::

::: email
Email: <nanditad@google.com>
:::

::: {.left dir="auto"}
[Priyaranjan Jha]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google, Inc.]{.org}
:::

::: email
Email: <priyarjha@google.com>
:::
:::
:::
