  RFC 8977           RDAP Sorting and Paging   January 2021
  ------------------ ------------------------- --------------
  Loffredo, et al.   Standards Track           \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8977](https://www.rfc-editor.org/rfc/rfc8977){.eref}

Category:
:   Standards Track

Published:
:   January 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    M. Loffredo
    :::

    ::: org
    IIT-CNR/Registro.it
    :::
    :::

    ::: author
    ::: author-name
    M. Martinelli
    :::

    ::: org
    IIT-CNR/Registro.it
    :::
    :::

    ::: author
    ::: author-name
    S. Hollenbeck
    :::

    ::: org
    Verisign Labs
    :::
    :::
:::

# RFC 8977 {#rfcnum}

# Registration Data Access Protocol (RDAP) Query Parameters for Result Sorting and Paging {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

The Registration Data Access Protocol (RDAP) does not include core
functionality for clients to provide sorting and paging parameters for
control of large result sets. This omission can lead to unpredictable
server processing of queries and client processing of responses. This
unpredictability can be greatly reduced if clients can provide servers
with their preferences for managing large responses. This document
describes RDAP query extensions that allow clients to specify their
preferences for sorting and paging result
sets.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8977>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Conventions Used in This
        Document](#name-conventions-used-in-this-do){.xref}[¶](#section-toc.1-1.1.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [RDAP Query Parameter
    Specification](#name-rdap-query-parameter-specif){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Sorting and Paging
        Metadata](#name-sorting-and-paging-metadata){.xref}[¶](#section-toc.1-1.2.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.2.2.1.2.1}
            [2.1.1](#section-2.1.1){.xref}.  [RDAP
            Conformance](#name-rdap-conformance){.xref}[¶](#section-toc.1-1.2.2.1.2.1.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [\"count\"
        Parameter](#name-count-parameter){.xref}[¶](#section-toc.1-1.2.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.3}
        [2.3](#section-2.3){.xref}.  [\"sort\"
        Parameter](#name-sort-parameter){.xref}[¶](#section-toc.1-1.2.2.3.1){.pilcrow}

        -   ::: {#section-toc.1-1.2.2.3.2.1}
            [2.3.1](#section-2.3.1){.xref}.  [Sorting Properties
            Declaration](#name-sorting-properties-declarat){.xref}[¶](#section-toc.1-1.2.2.3.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.2.2.3.2.2}
            [2.3.2](#section-2.3.2){.xref}.  [Representing Sorting
            Links](#name-representing-sorting-links){.xref}[¶](#section-toc.1-1.2.2.3.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.2.2.4}
        [2.4](#section-2.4){.xref}.  [\"cursor\"
        Parameter](#name-cursor-parameter){.xref}[¶](#section-toc.1-1.2.2.4.1){.pilcrow}

        -   ::: {#section-toc.1-1.2.2.4.2.1}
            [2.4.1](#section-2.4.1){.xref}.  [Representing Paging
            Links](#name-representing-paging-links){.xref}[¶](#section-toc.1-1.2.2.4.2.1.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Negative
    Answers](#name-negative-answers){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Implementation
    Considerations](#name-implementation-consideratio){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [References](#name-references){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [Appendix A](#section-appendix.a){.xref}.  [JSONPath
    Operators](#name-jsonpath-operators){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [Appendix B](#section-appendix.b){.xref}.  [Approaches to Result
    Pagination](#name-approaches-to-result-pagina){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}

    -   ::: {#section-toc.1-1.9.2.1}
        [B.1](#section-b.1){.xref}.  [Specific Issues Raised by
        RDAP](#name-specific-issues-raised-by-r){.xref}[¶](#section-toc.1-1.9.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [Appendix C](#section-appendix.c){.xref}.  [Implementation
    Notes](#name-implementation-notes){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}

    -   ::: {#section-toc.1-1.10.2.1}
        [C.1](#section-c.1){.xref}.  [Sorting](#name-sorting){.xref}[¶](#section-toc.1-1.10.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [C.2](#section-c.2){.xref}.  [Counting](#name-counting){.xref}[¶](#section-toc.1-1.10.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.3}
        [C.3](#section-c.3){.xref}.  [Paging](#name-paging){.xref}[¶](#section-toc.1-1.10.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [](#section-appendix.d){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.12}
    [](#section-appendix.e){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}
    :::
:::
:::

::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The availability of functionality for result sorting and paging provides
benefits to both clients and servers in the implementation of RESTful
services \[[REST](#REST){.xref}\]. These benefits
include:[¶](#section-1-1){.pilcrow}

-   [reducing the server response bandwidth
    requirements[¶](#section-1-2.1){.pilcrow}]{#section-1-2.1}
-   [improving server response
    time[¶](#section-1-2.2){.pilcrow}]{#section-1-2.2}
-   [improving query precision and, consequently, obtaining more
    relevant results[¶](#section-1-2.3){.pilcrow}]{#section-1-2.3}
-   [decreasing server query processing
    load[¶](#section-1-2.4){.pilcrow}]{#section-1-2.4}
-   [reducing client response processing
    time[¶](#section-1-2.5){.pilcrow}]{#section-1-2.5}

Approaches to implementing features for result sorting and paging can be
grouped into two main categories:[¶](#section-1-3){.pilcrow}

1.  ::: {#section-1-4.1}
    Sorting and paging are implemented through the introduction of
    additional parameters in the query string (e.g., the Open Data
    Protocol (ODATA)
    \[[ODATA-PART1](#ODATA-PART1){.xref}\]).[¶](#section-1-4.1.1){.pilcrow}
    :::

2.  [Information related to the number of results and the specific
    portion of the result set to be returned, in addition to a set of
    ready-made links for the result set scrolling, are inserted in the
    HTTP header of the request/response
    \[[RFC7231](#RFC7231){.xref}\].[¶](#section-1-4.2){.pilcrow}]{#section-1-4.2}

However, there are some drawbacks associated with the use of the HTTP
header. First, the header properties cannot be set directly from a web
browser. Moreover, in an HTTP session, the information on the status
(i.e., the session identifier) is usually inserted in the header or a
cookie, while the information on the resource identification or the
search type is included in the query string. Finally, providing custom
information through HTTP headers assumes the client has prior knowledge
of the server implementation, which is widely considered a
Representational State Transfer (REST) design anti-pattern. As a result,
this document describes a specification based on the use of query
parameters.[¶](#section-1-5){.pilcrow}

Currently, RDAP \[[RFC7482](#RFC7482){.xref}\] defines two query
types:[¶](#section-1-6){.pilcrow}

[]{.break}

lookup:
:   the server returns only one object[¶](#section-1-7.2){.pilcrow}
:   

search:
:   the server returns a collection of
    objects[¶](#section-1-7.4){.pilcrow}
:   

While the lookup query does not raise issues regarding response size
management, the search query can potentially generate a large result set
that is often truncated according to server limits. Besides, it is not
possible to obtain the total number of objects found that might be
returned in a search query response \[[RFC7483](#RFC7483){.xref}\].
Lastly, there is no way to specify sort criteria to return the most
relevant objects at the beginning of the result set. Therefore, the
client might traverse the whole result set to find the relevant objects
or, due to truncation, might not find them at
all.[¶](#section-1-8){.pilcrow}

The specification described in this document extends RDAP query
capabilities to enable result sorting and paging by adding new query
parameters that can be applied to RDAP search path segments. The service
is implemented using the Hypertext Transfer Protocol (HTTP)
\[[RFC7230](#RFC7230){.xref}\] and the conventions described in
\[[RFC7480](#RFC7480){.xref}\].[¶](#section-1-9){.pilcrow}

The implementation of the new parameters is technically feasible, as
operators for counting, sorting, and paging rows are currently supported
by the major relational database management
systems.[¶](#section-1-10){.pilcrow}

::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Conventions Used in This Document](#name-conventions-used-in-this-do){.section-name .selfRef} {#name-conventions-used-in-this-do}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-1){.pilcrow}
:::
:::

::: {#rdap-query-parameter-specification}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [RDAP Query Parameter Specification](#name-rdap-query-parameter-specif){.section-name .selfRef} {#name-rdap-query-parameter-specif}

The new query parameters are [OPTIONAL]{.bcp14} extensions of path
segments defined in \[[RFC7482](#RFC7482){.xref}\]. They are as
follows:[¶](#section-2-1){.pilcrow}

[]{.break}

\"count\":
:   a boolean value that allows a client to request the return of the
    total number of objects found[¶](#section-2-2.2){.pilcrow}
:   

\"sort\":
:   a string value that allows a client to request a specific sort order
    for the result set[¶](#section-2-2.4){.pilcrow}
:   

\"cursor\":
:   a string value representing a pointer to a specific fixed-size
    portion of the result set[¶](#section-2-2.6){.pilcrow}
:   

Augmented Backus-Naur Form (ABNF) \[[RFC5234](#RFC5234){.xref}\] is used
in the following sections to describe the formal syntax of these new
parameters.[¶](#section-2-3){.pilcrow}

::: {#sorting_and_paging_metadata}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Sorting and Paging Metadata](#name-sorting-and-paging-metadata){.section-name .selfRef} {#name-sorting-and-paging-metadata}

According to most advanced principles in REST design, collectively known
as HATEOAS (Hypermedia as the Engine of Application State)
\[[HATEOAS](#HATEOAS){.xref}\], a client entering a REST application
through an initial URI should use server-provided links to dynamically
discover available actions and access the resources it needs. In this
way, the client is neither required to have prior knowledge of the
service nor, consequently, to hard code the URIs of different resources.
This allows the server to make URI changes as the API evolves without
breaking clients. Definitively, a REST service should be as
self-descriptive as possible.[¶](#section-2.1-1){.pilcrow}

Therefore, servers implementing the query parameters described in this
specification [SHOULD]{.bcp14} provide additional information in their
responses about both the available sorting criteria and possible
pagination. Such information is collected in two [OPTIONAL]{.bcp14}
response elements named \"sorting_metadata\" and
\"paging_metadata\".[¶](#section-2.1-2){.pilcrow}

The \"sorting_metadata\" element contains the following
properties:[¶](#section-2.1-3){.pilcrow}

[]{.break}

\"currentSort\": \"String\" ([OPTIONAL]{.bcp14})
:   Either the value of the \"sort\" parameter as specified in the query
    string or the sort applied by default, if
    any.[¶](#section-2.1-4.2){.pilcrow}
:   

\"availableSorts\": \"AvailableSort\[\]\" ([OPTIONAL]{.bcp14})

:   An array of objects, with each element describing an available sort
    criterion. The AvailableSort object includes the following
    members:[¶](#section-2.1-4.4.1){.pilcrow}

    []{.break}

    \"property\": \"String\" ([REQUIRED]{.bcp14})
    :   The name that can be used by the client to request the sort
        criterion.[¶](#section-2.1-4.4.2.2){.pilcrow}
    :   

    \"default\": \"Boolean\" ([REQUIRED]{.bcp14})
    :   Indicator of whether the sort criterion is applied by default.
        An RDAP server [MUST]{.bcp14} define only one default sorting
        property for each object
        class.[¶](#section-2.1-4.4.2.4){.pilcrow}
    :   

    \"jsonPath\": \"String\" ([OPTIONAL]{.bcp14})
    :   The JSONPath expression of the RDAP field corresponding to the
        property.[¶](#section-2.1-4.4.2.6){.pilcrow}
    :   

    \"links\": \"Link\[\]\" ([OPTIONAL]{.bcp14})
    :   An array of links as described in \[[RFC8288](#RFC8288){.xref}\]
        containing the query string that applies the sort
        criterion.[¶](#section-2.1-4.4.2.8){.pilcrow}
    :   

:   

At least one of the \"currentSort\" and \"availableSorts\" properties
[MUST]{.bcp14} be present.[¶](#section-2.1-5){.pilcrow}

The \"paging_metadata\" element contains the following
fields:[¶](#section-2.1-6){.pilcrow}

[]{.break}

\"totalCount\": \"Numeric\" ([OPTIONAL]{.bcp14})
:   A numeric value representing the total number of objects found. It
    [MUST]{.bcp14} be provided if and only if the query string contains
    the \"count\" parameter.[¶](#section-2.1-7.2){.pilcrow}
:   

\"pageSize\": \"Numeric\" ([OPTIONAL]{.bcp14})
:   A numeric value representing the number of objects that should have
    been returned in the current page. It [MUST]{.bcp14} be provided if
    and only if the total number of objects exceeds the page size. This
    property is redundant for RDAP clients because the page size can be
    derived from the length of the search results array, but it can be
    helpful if the end user interacts with the server through a web
    browser.[¶](#section-2.1-7.4){.pilcrow}
:   

\"pageNumber\": \"Numeric\" ([OPTIONAL]{.bcp14})
:   A numeric value representing the number of the current page in the
    result set. It [MUST]{.bcp14} be provided if and only if the total
    number of objects found exceeds the page
    size.[¶](#section-2.1-7.6){.pilcrow}
:   

\"links\": \"Link\[\]\" ([OPTIONAL]{.bcp14})
:   An array of links as described in \[[RFC8288](#RFC8288){.xref}\]
    containing the reference to the next page. In this specification,
    only forward pagination is described because it is all that is
    necessary to traverse the result set.[¶](#section-2.1-7.8){.pilcrow}
:   

::: {#rdap-conformance}
::: {#section-2.1.1 .section}
#### [2.1.1.](#section-2.1.1){.section-number .selfRef} [RDAP Conformance](#name-rdap-conformance){.section-name .selfRef} {#name-rdap-conformance}

Servers returning the \"paging_metadata\" element in their response
[MUST]{.bcp14} include the string literal \"paging\" in the
rdapConformance array. Servers returning the \"sorting_metadata\"
element [MUST]{.bcp14} include the string literal
\"sorting\".[¶](#section-2.1.1-1){.pilcrow}
:::
:::
:::
:::

::: {#count-parameter}
::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [\"count\" Parameter](#name-count-parameter){.section-name .selfRef} {#name-count-parameter}

Currently, RDAP does not allow a client to determine the total number of
results in a query response when the result set is truncated. This is
inefficient because the user cannot determine if the result set is
complete.[¶](#section-2.2-1){.pilcrow}

The \"count\" parameter provides additional functionality that allows a
client to request information from the server that specifies the total
number of objects matching the search
pattern.[¶](#section-2.2-2){.pilcrow}

The following is an example of an RDAP query including the \"count\"
parameter:[¶](#section-2.2-3){.pilcrow}

https://example.com/rdap/domains?name=example\*.com&count=true[¶](#section-2.2-4){.pilcrow}

The ABNF syntax is the following:[¶](#section-2.2-5){.pilcrow}

::: {#section-2.2-6}
``` {.sourcecode .lang-abnf}
   count = "count=" ( trueValue / falseValue )
   trueValue = ("true" / "yes" / "1")
   falseValue = ("false" / "no" / "0")
```

[¶](#section-2.2-6){.pilcrow}
:::

A trueValue means that the server [MUST]{.bcp14} provide the total
number of objects in the \"totalCount\" field of the \"paging_metadata\"
element ([Figure 1](#count-in-response-example){.xref}). A falseValue
means that the server [MUST NOT]{.bcp14} provide this
number.[¶](#section-2.2-7){.pilcrow}

[]{#name-example-of-rdap-response-wi}

::: {#count-in-response-example}
::: {#section-2.2-8.1}
``` {.sourcecode .lang-json}
{
  "rdapConformance": [
        "rdap_level_0",
        "paging"
  ],
  ...
  "paging_metadata": {
    "totalCount": 43
  },
  "domainSearchResults": [
    ...
  ]
}
```
:::

[Figure 1](#figure-1){.selfRef}: [Example of RDAP Response with
\"paging_metadata\" Element Containing the \"totalCount\"
Field](#name-example-of-rdap-response-wi){.selfRef}
:::
:::
:::

::: {#sort-parameter}
::: {#section-2.3 .section}
### [2.3.](#section-2.3){.section-number .selfRef} [\"sort\" Parameter](#name-sort-parameter){.section-name .selfRef} {#name-sort-parameter}

RDAP does not provide any capability to specify the result set sort
criteria. A server could implement a default sorting scheme according to
the object class, but this feature is not mandatory and might not meet
user requirements. Sorting can be addressed by the client, but this
solution is rather inefficient. Sorting features provided by the RDAP
server could help avoid truncation of relevant
results.[¶](#section-2.3-1){.pilcrow}

The \"sort\" parameter allows the client to ask the server to sort the
results according to the values of one or more properties and according
to the sort direction of each property. The ABNF syntax is the
following:[¶](#section-2.3-2){.pilcrow}

::: {#section-2.3-3}
``` {.sourcecode .lang-abnf}
   sort = "sort=" sortItem *( "," sortItem )
   sortItem = property-ref [":" ( "a" / "d" ) ]
   property-ref = ALPHA *( ALPHA / DIGIT / "_" )
```

[¶](#section-2.3-3){.pilcrow}
:::

\"a\" means that an ascending sort [MUST]{.bcp14} be applied; \"d\"
means that a descending sort [MUST]{.bcp14} be applied. If the sort
direction is absent, an ascending sort [MUST]{.bcp14} be
applied.[¶](#section-2.3-4){.pilcrow}

The following are examples of RDAP queries that include the \"sort\"
parameter:[¶](#section-2.3-5){.pilcrow}

https://example.com/rdap/domains?name=example\*.com&sort=name[¶](#section-2.3-6){.pilcrow}

https://example.com/rdap/
domains?name=example\*.com&sort=registrationDate:d[¶](#section-2.3-7){.pilcrow}

https://example.com/rdap/
domains?name=example\*.com&sort=lockedDate,name[¶](#section-2.3-8){.pilcrow}

Except for sorting IP addresses and values denoting dates and times,
servers [MUST]{.bcp14} implement sorting according to the JSON value
type of the RDAP field the sorting property refers to. That is, JSON
strings [MUST]{.bcp14} be sorted lexicographically, and JSON numbers
[MUST]{.bcp14} be sorted numerically. Values denoting dates and times
[MUST]{.bcp14} be sorted in chronological order. If IP addresses are
represented as JSON strings, they [MUST]{.bcp14} be sorted based on
their numeric conversion.[¶](#section-2.3-9){.pilcrow}

The conversion of an IPv4 address to a number is possible since each
dotted format IPv4 address is a representation of a number written in a
256-based manner; for example, 192.168.0.1 means 1\*256\^0 + 0\*256\^1 +
168\*256\^2 + 192\*256\^3 = 3232235521. Similarly, an IPv6 address can
be converted into a number by applying the base 65536. Therefore, the
numerical representation of the IPv6 address
2001:0db8:85a3:0:0:8a2e:0370:7334 is
42540766452641154071740215577757643572. Built-in functions and libraries
for converting IP addresses into numbers are available in most known
programming languages and relational database management
systems.[¶](#section-2.3-10){.pilcrow}

If the \"sort\" parameter presents an allowed sorting property, it
[MUST]{.bcp14} be provided in the \"currentSort\" field of the
\"sorting_metadata\" element.[¶](#section-2.3-11){.pilcrow}

::: {#sorting_properties}
::: {#section-2.3.1 .section}
#### [2.3.1.](#section-2.3.1){.section-number .selfRef} [Sorting Properties Declaration](#name-sorting-properties-declarat){.section-name .selfRef} {#name-sorting-properties-declarat}

In the \"sort\" parameter ABNF syntax, the element named
\"property-ref\" represents a reference to a property of an RDAP object.
Such a reference could be expressed by using a JSONPath expression
(named \"jsonpath\" in the following).[¶](#section-2.3.1-1){.pilcrow}

JSONPath is a syntax, originally based on the XML XPath notation
\[[W3C.CR-xpath-31-20170321](#W3C.CR-xpath-31-20170321){.xref}\], which
represents a path to select an element (or a set of elements) in a JSON
document \[[RFC8259](#RFC8259){.xref}\]. For example, the jsonpath to
select the value of the ASCII name inside an RDAP domain lookup response
is \"\$.ldhName\", where \$ identifies the root of the document object
model (DOM). Another way to select a value inside a JSON document is the
JSON Pointer
\[[RFC6901](#RFC6901){.xref}\].[¶](#section-2.3.1-2){.pilcrow}

While JSONPath and JSON Pointer are both commonly adopted notations to
select any value inside JSON data, neither is particularly concise and
easy to use (e.g.,
\"\$.domainSearchResults\[\*\].events\[?(@.eventAction=\'registration\')\].eventDate\"
is the jsonpath of the registration date in an RDAP domain search
response).[¶](#section-2.3.1-3){.pilcrow}

Therefore, this specification defines the \"property-ref\" element in
terms of names identifying RDAP properties. However, not all the RDAP
properties are suitable to be used in sort criteria. These properties
include:[¶](#section-2.3.1-4){.pilcrow}

-   ::: {#section-2.3.1-5.1}
    properties providing service information (e.g., links, notices, and
    remarks)[¶](#section-2.3.1-5.1.1){.pilcrow}
    :::

-   ::: {#section-2.3.1-5.2}
    multivalued properties (e.g., status, roles, and
    variants)[¶](#section-2.3.1-5.2.1){.pilcrow}
    :::

-   [properties representing relationships to other objects (e.g.,
    entities)[¶](#section-2.3.1-5.3){.pilcrow}]{#section-2.3.1-5.3}

On the contrary, properties expressed as values of other properties
(e.g., registration date) could be used in such a
context.[¶](#section-2.3.1-6){.pilcrow}

A list of properties an RDAP server [MAY]{.bcp14} implement is defined.
The properties are divided into two groups: object-common properties and
object-specific properties.[¶](#section-2.3.1-7){.pilcrow}

-   ::: {#section-2.3.1-8.1}
    Object-common properties. Object-common properties are derived from
    merging the \"eventAction\" and the \"eventDate\" properties. The
    following values of the \"sort\" parameter are
    defined:[¶](#section-2.3.1-8.1.1){.pilcrow}

    -   [registrationDate[¶](#section-2.3.1-8.1.2.1){.pilcrow}]{#section-2.3.1-8.1.2.1}
    -   [reregistrationDate[¶](#section-2.3.1-8.1.2.2){.pilcrow}]{#section-2.3.1-8.1.2.2}
    -   [lastChangedDate[¶](#section-2.3.1-8.1.2.3){.pilcrow}]{#section-2.3.1-8.1.2.3}
    -   [expirationDate[¶](#section-2.3.1-8.1.2.4){.pilcrow}]{#section-2.3.1-8.1.2.4}
    -   [deletionDate[¶](#section-2.3.1-8.1.2.5){.pilcrow}]{#section-2.3.1-8.1.2.5}
    -   [reinstantiationDate[¶](#section-2.3.1-8.1.2.6){.pilcrow}]{#section-2.3.1-8.1.2.6}
    -   [transferDate[¶](#section-2.3.1-8.1.2.7){.pilcrow}]{#section-2.3.1-8.1.2.7}
    -   [lockedDate[¶](#section-2.3.1-8.1.2.8){.pilcrow}]{#section-2.3.1-8.1.2.8}
    -   [unlockedDate[¶](#section-2.3.1-8.1.2.9){.pilcrow}]{#section-2.3.1-8.1.2.9}
    :::

-   ::: {#section-2.3.1-8.2}
    Object-specific properties. Note that some of these properties are
    also defined as query path segments. These properties
    include:[¶](#section-2.3.1-8.2.1){.pilcrow}

    -   [Domain:
        name[¶](#section-2.3.1-8.2.2.1){.pilcrow}]{#section-2.3.1-8.2.2.1}
    -   [Nameserver: name, ipv4,
        ipv6[¶](#section-2.3.1-8.2.2.2){.pilcrow}]{#section-2.3.1-8.2.2.2}
    -   [Entity: fn, handle, org, email, voice, country, cc,
        city[¶](#section-2.3.1-8.2.2.3){.pilcrow}]{#section-2.3.1-8.2.2.3}
    :::

The correspondence between these sorting properties and the RDAP object
classes is shown in [Table
1](#table_sorting_properties_definition){.xref}. Some of the sorting
properties defined for the RDAP entity class are related to jCard
elements \[[RFC7095](#RFC7095){.xref}\], but because jCard is the JSON
format for vCard, the corresponding definitions are included in the
vCard specification
\[[RFC6350](#RFC6350){.xref}\].[¶](#section-2.3.1-9){.pilcrow}

An RDAP server [MUST NOT]{.bcp14} use the defined sorting properties
with a meaning other than that described in [Table
1](#table_sorting_properties_definition){.xref}.[¶](#section-2.3.1-10){.pilcrow}

[]{#name-definitions-of-sorting-prop}

::: {#table_sorting_properties_definition}
  Object class         Sorting property    RDAP property                             RFC 7483                                                             RFC 6350                                                                 RFC 8605
  -------------------- ------------------- ----------------------------------------- -------------------------------------------------------------------- ------------------------------------------------------------------------ --------------------------------------------------------------------
  Searchable objects   Common properties   eventAction values suffixed by \"Date\"   [4.5](https://www.rfc-editor.org/rfc/rfc7483#section-4.5){.relref}                                                                            
  Domain               name                unicodeName/ ldhName                      [5.3](https://www.rfc-editor.org/rfc/rfc7483#section-5.3){.relref}                                                                            
  Nameserver           name                unicodeName/ ldhName                      [5.2](https://www.rfc-editor.org/rfc/rfc7483#section-5.2){.relref}                                                                            
                       ipv4                v4 ipAddress                              [5.2](https://www.rfc-editor.org/rfc/rfc7483#section-5.2){.relref}                                                                            
                       ipv6                v6 ipAddress                              [5.2](https://www.rfc-editor.org/rfc/rfc7483#section-5.2){.relref}                                                                            
  Entity               handle              handle                                    [5.1](https://www.rfc-editor.org/rfc/rfc7483#section-5.1){.relref}                                                                            
                       fn                  jCard fn                                  [5.1](https://www.rfc-editor.org/rfc/rfc7483#section-5.1){.relref}   [6.2.1](https://www.rfc-editor.org/rfc/rfc6350#section-6.2.1){.relref}   
                       org                 jCard org                                 [5.1](https://www.rfc-editor.org/rfc/rfc7483#section-5.1){.relref}   [6.6.4](https://www.rfc-editor.org/rfc/rfc6350#section-6.6.4){.relref}   
                       voice               jCard tel with type=\"voice\"             [5.1](https://www.rfc-editor.org/rfc/rfc7483#section-5.1){.relref}   [6.4.1](https://www.rfc-editor.org/rfc/rfc6350#section-6.4.1){.relref}   
                       email               jCard email                               [5.1](https://www.rfc-editor.org/rfc/rfc7483#section-5.1){.relref}   [6.4.2](https://www.rfc-editor.org/rfc/rfc6350#section-6.4.2){.relref}   
                       country             country name in jCard adr                 [5.1](https://www.rfc-editor.org/rfc/rfc7483#section-5.1){.relref}   [6.3.1](https://www.rfc-editor.org/rfc/rfc6350#section-6.3.1){.relref}   
                       cc                  country code in jCard adr                 [5.1](https://www.rfc-editor.org/rfc/rfc7483#section-5.1){.relref}                                                                            [3.1](https://www.rfc-editor.org/rfc/rfc8605#section-3.1){.relref}
                       city                locality in jCard adr                     [5.1](https://www.rfc-editor.org/rfc/rfc7483#section-5.1){.relref}   [6.3.1](https://www.rfc-editor.org/rfc/rfc6350#section-6.3.1){.relref}   

  : [Table 1](#table-1){.selfRef}: [Definitions of Sorting
  Properties](#name-definitions-of-sorting-prop){.selfRef}
:::

Regarding the definitions in [Table
1](#table_sorting_properties_definition){.xref}, some further
considerations are needed to disambiguate some
cases:[¶](#section-2.3.1-12){.pilcrow}

-   ::: {#section-2.3.1-13.1}
    Since the response to a search on either domains or nameservers
    might include both A-labels and U-labels
    \[[RFC5890](#RFC5890){.xref}\] in general, a consistent sorting
    policy [MUST]{.bcp14} treat the unicodeName and ldhName as two
    representations of the same value. The unicodeName value
    [MUST]{.bcp14} be used while sorting if it is present; when the
    unicodeName is unavailable, the value of the ldhName [MUST]{.bcp14}
    be used instead.[¶](#section-2.3.1-13.1.1){.pilcrow}
    :::

-   ::: {#section-2.3.1-13.2}
    The jCard \"sort-as\" parameter [MUST]{.bcp14} be ignored for the
    sorting capability described in this
    document.[¶](#section-2.3.1-13.2.1){.pilcrow}
    :::

-   ::: {#section-2.3.1-13.3}
    Even if a nameserver can have multiple IPv4 and IPv6 addresses, the
    most common configuration includes one address for each IP version.
    Therefore, this specification makes the assumption that nameservers
    have a single IPv4 and/or IPv6 value. When more than one address per
    IP version is presented, sorting [MUST]{.bcp14} be applied to the
    first value.[¶](#section-2.3.1-13.3.1){.pilcrow}
    :::

-   ::: {#section-2.3.1-13.4}
    Multiple events with a given action on an object might be returned.
    If this occurs, sorting [MUST]{.bcp14} be applied to the most recent
    event.[¶](#section-2.3.1-13.4.1){.pilcrow}
    :::

-   [Except for handle values, all the sorting properties defined for
    entity objects can be multivalued according to the definition of
    vCard as given in \[[RFC6350](#RFC6350){.xref}\]. When more than one
    value is presented, sorting [MUST]{.bcp14} be applied to the
    preferred value identified by the parameter pref=\"1\". If the
    \"pref\" parameter is missing, sorting [MUST]{.bcp14} be applied to
    the first
    value.[¶](#section-2.3.1-13.5){.pilcrow}]{#section-2.3.1-13.5}

The \"jsonPath\" field in the \"sorting_metadata\" element is used to
clarify the RDAP response field the sorting property refers to. The
mapping between the sorting properties and the jsonpaths of the RDAP
response fields is shown below. The JSONPath operators used herein are
described in [Appendix
A](#jsonpath-operators){.xref}.[¶](#section-2.3.1-14){.pilcrow}

-   ::: {#section-2.3.1-15.1}
    Searchable objects[¶](#section-2.3.1-15.1.1){.pilcrow}

    []{.break}

    registrationDate

    :   \$.domainSearchResults\[\*\].events\[?(@.eventAction==\"registration\")\].eventDate[¶](#section-2.3.1-15.1.2.2.1){.pilcrow}

    :   

    reregistrationDate

    :   \$.domainSearchResults\[\*\].events\[?(@.eventAction==\"reregistration\")\].eventDate[¶](#section-2.3.1-15.1.2.4.1){.pilcrow}

    :   

    lastChangedDate

    :   \$.domainSearchResults\[\*\].events\[?(@.eventAction==\"last
        changed\")\].eventDate[¶](#section-2.3.1-15.1.2.6.1){.pilcrow}

    :   

    expirationDate

    :   \$.domainSearchResults\[\*\].events\[?(@.eventAction==\"expiration\")\].eventDate[¶](#section-2.3.1-15.1.2.8.1){.pilcrow}

    :   

    deletionDate

    :   \$.domainSearchResults\[\*\].events\[?(@.eventAction==\"deletion\")\].eventDate[¶](#section-2.3.1-15.1.2.10.1){.pilcrow}

    :   

    reinstantiationDate

    :   \$.domainSearchResults\[\*\].events\[?(@.eventAction==\"reinstantiation\")\].eventDate[¶](#section-2.3.1-15.1.2.12.1){.pilcrow}

    :   

    transferDate

    :   \$.domainSearchResults\[\*\].events\[?(@.eventAction==\"transfer\")\].eventDate[¶](#section-2.3.1-15.1.2.14.1){.pilcrow}

    :   

    lockedDate

    :   \$.domainSearchResults\[\*\].events\[?(@.eventAction==\"locked\")\].eventDate[¶](#section-2.3.1-15.1.2.16.1){.pilcrow}

    :   

    unlockedDate

    :   \$.domainSearchResults\[\*\].events\[?(@.eventAction==\"unlocked\")\].eventDate[¶](#section-2.3.1-15.1.2.18.1){.pilcrow}

    :   
    :::

-   ::: {#section-2.3.1-15.2}
    Domain[¶](#section-2.3.1-15.2.1){.pilcrow}

    []{.break}

    name

    :   \$.domainSearchResults\[\*\].\[unicodeName,ldhName\][¶](#section-2.3.1-15.2.2.2.1){.pilcrow}

    :   
    :::

-   ::: {#section-2.3.1-15.3}
    Nameserver[¶](#section-2.3.1-15.3.1){.pilcrow}

    []{.break}

    name

    :   \$.nameserverSearchResults\[\*\].\[unicodeName,ldhName\][¶](#section-2.3.1-15.3.2.2.1){.pilcrow}

    :   

    ipv4

    :   \$.nameserverSearchResults\[\*\].ipAddresses.v4\[0\][¶](#section-2.3.1-15.3.2.4.1){.pilcrow}

    :   

    ipv6

    :   \$.nameserverSearchResults\[\*\].ipAddresses.v6\[0\][¶](#section-2.3.1-15.3.2.6.1){.pilcrow}

    :   
    :::

-   ::: {#section-2.3.1-15.4}
    Entity[¶](#section-2.3.1-15.4.1){.pilcrow}

    []{.break}

    handle

    :   \$.entitySearchResults\[\*\].handle[¶](#section-2.3.1-15.4.2.2.1){.pilcrow}

    :   

    fn

    :   \$.entitySearchResults\[\*\].vcardArray\[1\]\[?(@\[0\]==\"fn\")\]\[3\][¶](#section-2.3.1-15.4.2.4.1){.pilcrow}

    :   

    org

    :   \$.entitySearchResults\[\*\].vcardArray\[1\]\[?(@\[0\]==\"org\")\]\[3\][¶](#section-2.3.1-15.4.2.6.1){.pilcrow}

    :   

    voice

    :   \$.entitySearchResults\[\*\].vcardArray\[1\]\[?(@\[0\]==\"tel\"
        &&
        @\[1\].type==\"voice\")\]\[3\][¶](#section-2.3.1-15.4.2.8.1){.pilcrow}

    :   

    email

    :   \$.entitySearchResults\[\*\].vcardArray\[1\]\[?(@\[0\]==\"email\")\]\[3\][¶](#section-2.3.1-15.4.2.10.1){.pilcrow}

    :   

    country

    :   \$.entitySearchResults\[\*\].vcardArray\[1\]\[?(@\[0\]==\"adr\")\]\[3\]\[6\][¶](#section-2.3.1-15.4.2.12.1){.pilcrow}

    :   

    cc

    :   \$.entitySearchResults\[\*\].vcardArray\[1\]\[?(@\[0\]==\"adr\")\]\[1\].cc[¶](#section-2.3.1-15.4.2.14.1){.pilcrow}

    :   

    city

    :   \$.entitySearchResults\[\*\].vcardArray\[1\]\[?(@\[0\]==\"adr\")\]\[3\]\[3\][¶](#section-2.3.1-15.4.2.16.1){.pilcrow}

    :   
    :::

Additional notes on the provided
jsonpaths:[¶](#section-2.3.1-16){.pilcrow}

-   ::: {#section-2.3.1-17.1}
    Those related to the event dates are defined only for the \"domain\"
    object. To obtain the equivalent jsonpaths for \"entity\" and
    \"nameserver\", the path segment \"domainSearchResults\" must be
    replaced with \"entitySearchResults\" and
    \"nameserverSearchResults\",
    respectively.[¶](#section-2.3.1-17.1.1){.pilcrow}
    :::

-   [Those related to jCard elements are specified without taking into
    account the \"pref\" parameter. Servers that sort those values
    identified by the \"pref\" parameter [SHOULD]{.bcp14} update a
    jsonpath by adding an appropriate filter. For example, if the email
    values identified by pref=\"1\" are considered for sorting, the
    jsonpath of the \"email\" sorting property should be
    \$.entitySearchResults\[\*\].vcardArray\[1\]\[?(@\[0\]==\"email\" &&
    @\[1\].pref==\"1\")\]\[3\].[¶](#section-2.3.1-17.2){.pilcrow}]{#section-2.3.1-17.2}
:::
:::

::: {#sorting_links}
::: {#section-2.3.2 .section}
#### [2.3.2.](#section-2.3.2){.section-number .selfRef} [Representing Sorting Links](#name-representing-sorting-links){.section-name .selfRef} {#name-representing-sorting-links}

An RDAP server [MAY]{.bcp14} use the \"links\" array of the
\"sorting_metadata\" element to provide ready-made references
\[[RFC8288](#RFC8288){.xref}\] to the available sort criteria ([Figure
2](#sort-link-in-response-example){.xref}). Each link represents a
reference to an alternate view of the
results.[¶](#section-2.3.2-1){.pilcrow}

The \"value\", \"rel\", and \"href\" JSON values [MUST]{.bcp14} be
specified. All other JSON values are
[OPTIONAL]{.bcp14}.[¶](#section-2.3.2-2){.pilcrow}

[]{#name-example-of-a-sorting_metada}

::: {#sort-link-in-response-example}
::: {#section-2.3.2-3.1}
``` {.sourcecode .lang-json}
{
  "rdapConformance": [
    "rdap_level_0",
    "sorting"
  ],
  ...
  "sorting_metadata": {
     "currentSort": "name",
     "availableSorts": [
       {
       "property": "registrationDate",
       "jsonPath": "$.domainSearchResults[*]
          .events[?(@.eventAction==\"registration\")].eventDate",
       "default": false,
       "links": [
         {
         "value": "https://example.com/rdap/domains?name=example*.com
                   &sort=name",
         "rel": "alternate",
         "href": "https://example.com/rdap/domains?name=example*.com
                  &sort=registrationDate",
         "title": "Result Ascending Sort Link",
         "type": "application/rdap+json"
         },
         {
         "value": "https://example.com/rdap/domains?name=example*.com
                   &sort=name",
         "rel": "alternate",
         "href": "https://example.com/rdap/domains?name=example*.com
                  &sort=registrationDate:d",
         "title": "Result Descending Sort Link",
         "type": "application/rdap+json"
         }
       ]
       },
       ...
     ]
  },
  "domainSearchResults": [
    ...
  ]
}
```
:::

[Figure 2](#figure-2){.selfRef}: [Example of a \"sorting_metadata\"
Instance to Implement Result
Sorting](#name-example-of-a-sorting_metada){.selfRef}
:::
:::
:::
:::
:::

::: {#cursor-parameter}
::: {#section-2.4 .section}
### [2.4.](#section-2.4){.section-number .selfRef} [\"cursor\" Parameter](#name-cursor-parameter){.section-name .selfRef} {#name-cursor-parameter}

The \"cursor\" parameter defined in this specification can be used to
encode information about any pagination method. For example, in the case
of a simple implementation of the \"cursor\" parameter to represent
offset pagination information, the \"cursor\" value
\"b2Zmc2V0PTEwMCxsaW1pdD01MA==\" is the base64 encoding of
\"offset=100,limit=50\". Likewise, in a simple implementation to
represent keyset pagination information, the \"cursor\" value
\"ZXhhbXBsZS1OLmNvbQ==\" represents the base64 encoding of
\"key=example-N.com\" whereby the key value identifies the last row of
the current page.[¶](#section-2.4-1){.pilcrow}

Note that this specification uses a base64 encoding for cursor
obfuscation just for example. RDAP servers are [NOT RECOMMENDED]{.bcp14}
to obfuscate the \"cursor\" value through a mere base64
encoding.[¶](#section-2.4-2){.pilcrow}

This solution lets RDAP providers implement a pagination method
according to their needs, a user\'s access level, and the submitted
query. Besides, servers can change the method over time without
announcing anything to clients. The considerations that have led to this
solution are described in more detail in [Appendix
B](#approaches-to-result-pagination){.xref}.[¶](#section-2.4-3){.pilcrow}

The ABNF syntax of the \"cursor\" parameter is the
following:[¶](#section-2.4-4){.pilcrow}

::: {#section-2.4-5}
``` {.sourcecode .lang-abnf}
   cursor = "cursor=" 1*( ALPHA / DIGIT / "/" / "=" / "-" / "_" )
```

[¶](#section-2.4-5){.pilcrow}
:::

The following is an example of an RDAP query including the \"cursor\"
parameter:[¶](#section-2.4-6){.pilcrow}

https://example.com/rdap/domains?name=example\*.com
&cursor=wJlCDLIl6KTWypN7T6vc6nWEmEYe99Hjf1XY1xmqV-M=[¶](#section-2.4-7){.pilcrow}

::: {#cursor_paging_links}
::: {#section-2.4.1 .section}
#### [2.4.1.](#section-2.4.1){.section-number .selfRef} [Representing Paging Links](#name-representing-paging-links){.section-name .selfRef} {#name-representing-paging-links}

An RDAP server [SHOULD]{.bcp14} use the \"links\" array of the
\"paging_metadata\" element to provide a ready-made reference
\[[RFC8288](#RFC8288){.xref}\] to the next page of the result set
([Figure 3](#cursor-pagination-link-in-response-example){.xref}).
Examples of additional \"rel\" values a server [MAY]{.bcp14} implement
are \"first\", \"last\", and \"prev\".[¶](#section-2.4.1-1){.pilcrow}

[]{#name-example-of-a-paging_metadat}

::: {#cursor-pagination-link-in-response-example}
::: {#section-2.4.1-2.1}
``` {.sourcecode .lang-json}
{
  "rdapConformance": [
    "rdap_level_0",
    "paging"
  ],
  ...
  "notices": [
    {
      "title": "Search query limits",
      "type": "result set truncated due to excessive load",
      "description": [
      "search results for domains are limited to 50"
      ]
    }
  ],
  "paging_metadata": {
    "totalCount": 73,
    "pageSize": 50,
    "pageNumber": 1,
    "links": [
      {
      "value": "https://example.com/rdap/domains?name=example*.com",
      "rel": "next",
      "href": "https://example.com/rdap/domains?name=example*.com
              &cursor=wJlCDLIl6KTWypN7T6vc6nWEmEYe99Hjf1XY1xmqV-M=",
      "title": "Result Pagination Link",
      "type": "application/rdap+json"
      }
    ]
  },
  "domainSearchResults": [
    ...
  ]
}
```
:::

[Figure 3](#figure-3){.selfRef}: [Example of a \"paging_metadata\"
Instance to Implement Cursor
Pagination](#name-example-of-a-paging_metadat){.selfRef}
:::
:::
:::
:::
:::
:::
:::

::: {#negative-answers}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Negative Answers](#name-negative-answers){.section-name .selfRef} {#name-negative-answers}

The constraints for the values of parameters are defined by their ABNF
syntax. Therefore, each request that includes an invalid value for a
parameter [SHOULD]{.bcp14} produce an HTTP 400 (Bad Request) response
code. The same response [SHOULD]{.bcp14} be returned in the following
cases:[¶](#section-3-1){.pilcrow}

-   ::: {#section-3-2.1}
    if sorting by either single or multiple properties, the client
    provides an unsupported value for the \"sort\" parameter, as well as
    a value related to an object property not included in the
    response[¶](#section-3-2.1.1){.pilcrow}
    :::

-   [if the client submits an invalid value for the \"cursor\"
    parameter[¶](#section-3-2.2){.pilcrow}]{#section-3-2.2}

Optionally, the response [MAY]{.bcp14} include additional information
regarding either the supported sorting properties or the correct
\"cursor\" value in the HTTP entity body ([Figure
4](#sorting-property-error){.xref}).[¶](#section-3-3){.pilcrow}

[]{#name-example-of-rdap-error-respo}

::: {#sorting-property-error}
::: {#section-3-4.1}
``` {.sourcecode .lang-json}
{
    "errorCode": 400,
    "title": "Domain sorting property 'unknown' is not valid",
    "description": [
        "Supported domain sorting properties are:"
        "'aproperty', 'anotherproperty'"
    ]

}
```
:::

[Figure 4](#figure-4){.selfRef}: [Example of RDAP Error Response Due to
an Invalid Domain Sorting Property Included in the
Request](#name-example-of-rdap-error-respo){.selfRef}
:::
:::
:::

::: {#implementation-considerations}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Implementation Considerations](#name-implementation-consideratio){.section-name .selfRef} {#name-implementation-consideratio}

Implementation of the new parameters is technically feasible, as
operators for counting, sorting, and paging are currently supported by
the major relational database management systems. Similar operators are
completely or partially supported by the most well-known NoSQL databases
(e.g., MongoDB, CouchDB, HBase, Cassandra, Hadoop, etc.). Additional
implementation notes are included in [Appendix
C](#additional-implementation-notes){.xref}.[¶](#section-4-1){.pilcrow}
:::
:::

::: {#IANA-considerations}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

IANA has registered the following values in the \"RDAP Extensions\"
registry:[¶](#section-5-1){.pilcrow}

[]{.break}

Extension identifier:
:   paging[¶](#section-5-2.2){.pilcrow}
:   

Registry operator:
:   Any[¶](#section-5-2.4){.pilcrow}
:   

Published specification:
:   RFC 8977[¶](#section-5-2.6){.pilcrow}
:   

Contact:
:   IETF \<iesg\@ietf.org>[¶](#section-5-2.8){.pilcrow}
:   

Intended usage:
:   This extension describes a best practice for result set
    paging.[¶](#section-5-2.10){.pilcrow}
:   

[]{.break}

Extension identifier:
:   sorting[¶](#section-5-3.2){.pilcrow}
:   

Registry operator:
:   Any[¶](#section-5-3.4){.pilcrow}
:   

Published specification:
:   RFC 8977[¶](#section-5-3.6){.pilcrow}
:   

Contact:
:   IETF \<iesg\@ietf.org>[¶](#section-5-3.8){.pilcrow}
:   

Intended usage:
:   This extension describes a best practice for result set
    sorting.[¶](#section-5-3.10){.pilcrow}
:   
:::
:::

::: {#security-considerations}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

Security services for the operations specified in this document are
described in \[[RFC7481](#RFC7481){.xref}\].[¶](#section-6-1){.pilcrow}

A search query typically requires more server resources (such as memory,
CPU cycles, and network bandwidth) when compared to a lookup query. This
increases the risk of server resource exhaustion and subsequent denial
of service. This risk can be mitigated by either restricting search
functionality or limiting the rate of search requests. Servers can also
reduce their load by truncating the results in a response. However, this
last security policy can result in a higher inefficiency or risk due to
acting on incomplete information if the RDAP server does not provide any
functionality to return the truncated
results.[¶](#section-6-2){.pilcrow}

The new parameters presented in this document provide RDAP operators
with a way to implement a server that reduces inefficiency risks. The
\"count\" parameter gives the client the ability to evaluate the
completeness of a response. The \"sort\" parameter allows the client to
obtain the most relevant information at the beginning of the result set.
This can reduce the number of unnecessary search requests. Finally, the
\"cursor\" parameter enables the user to scroll the result set by
submitting a sequence of sustainable queries within server-acceptable
limits.[¶](#section-6-3){.pilcrow}
:::
:::

::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC5234\]
:   [Crocker, D., Ed.]{.refAuthor}[ and P. Overell]{.refAuthor},
    [\"Augmented BNF for Syntax Specifications: ABNF\"]{.refTitle}, [STD
    68]{.seriesInfo}, [RFC 5234]{.seriesInfo}, [DOI
    10.17487/RFC5234]{.seriesInfo}, January 2008,
    \<<https://www.rfc-editor.org/info/rfc5234>\>.
:   

\[RFC5890\]
:   [Klensin, J.]{.refAuthor}, [\"Internationalized Domain Names for
    Applications (IDNA): Definitions and Document
    Framework\"]{.refTitle}, [RFC 5890]{.seriesInfo}, [DOI
    10.17487/RFC5890]{.seriesInfo}, August 2010,
    \<<https://www.rfc-editor.org/info/rfc5890>\>.
:   

\[RFC6350\]
:   [Perreault, S.]{.refAuthor}, [\"vCard Format
    Specification\"]{.refTitle}, [RFC 6350]{.seriesInfo}, [DOI
    10.17487/RFC6350]{.seriesInfo}, August 2011,
    \<<https://www.rfc-editor.org/info/rfc6350>\>.
:   

\[RFC7095\]
:   [Kewisch, P.]{.refAuthor}, [\"jCard: The JSON Format for
    vCard\"]{.refTitle}, [RFC 7095]{.seriesInfo}, [DOI
    10.17487/RFC7095]{.seriesInfo}, January 2014,
    \<<https://www.rfc-editor.org/info/rfc7095>\>.
:   

\[RFC7230\]
:   [Fielding, R., Ed.]{.refAuthor}[ and J. Reschke, Ed.]{.refAuthor},
    [\"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and
    Routing\"]{.refTitle}, [RFC 7230]{.seriesInfo}, [DOI
    10.17487/RFC7230]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7230>\>.
:   

\[RFC7231\]
:   [Fielding, R., Ed.]{.refAuthor}[ and J. Reschke, Ed.]{.refAuthor},
    [\"Hypertext Transfer Protocol (HTTP/1.1): Semantics and
    Content\"]{.refTitle}, [RFC 7231]{.seriesInfo}, [DOI
    10.17487/RFC7231]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7231>\>.
:   

\[RFC7480\]
:   [Newton, A.]{.refAuthor}[, Ellacott, B.]{.refAuthor}[, and N.
    Kong]{.refAuthor}, [\"HTTP Usage in the Registration Data Access
    Protocol (RDAP)\"]{.refTitle}, [RFC 7480]{.seriesInfo}, [DOI
    10.17487/RFC7480]{.seriesInfo}, March 2015,
    \<<https://www.rfc-editor.org/info/rfc7480>\>.
:   

\[RFC7481\]
:   [Hollenbeck, S.]{.refAuthor}[ and N. Kong]{.refAuthor}, [\"Security
    Services for the Registration Data Access Protocol
    (RDAP)\"]{.refTitle}, [RFC 7481]{.seriesInfo}, [DOI
    10.17487/RFC7481]{.seriesInfo}, March 2015,
    \<<https://www.rfc-editor.org/info/rfc7481>\>.
:   

\[RFC7482\]
:   [Newton, A.]{.refAuthor}[ and S. Hollenbeck]{.refAuthor},
    [\"Registration Data Access Protocol (RDAP) Query
    Format\"]{.refTitle}, [RFC 7482]{.seriesInfo}, [DOI
    10.17487/RFC7482]{.seriesInfo}, March 2015,
    \<<https://www.rfc-editor.org/info/rfc7482>\>.
:   

\[RFC7483\]
:   [Newton, A.]{.refAuthor}[ and S. Hollenbeck]{.refAuthor}, [\"JSON
    Responses for the Registration Data Access Protocol
    (RDAP)\"]{.refTitle}, [RFC 7483]{.seriesInfo}, [DOI
    10.17487/RFC7483]{.seriesInfo}, March 2015,
    \<<https://www.rfc-editor.org/info/rfc7483>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8259\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The JavaScript Object Notation
    (JSON) Data Interchange Format\"]{.refTitle}, [STD 90]{.seriesInfo},
    [RFC 8259]{.seriesInfo}, [DOI 10.17487/RFC8259]{.seriesInfo},
    December 2017, \<<https://www.rfc-editor.org/info/rfc8259>\>.
:   

\[RFC8288\]
:   [Nottingham, M.]{.refAuthor}, [\"Web Linking\"]{.refTitle}, [RFC
    8288]{.seriesInfo}, [DOI 10.17487/RFC8288]{.seriesInfo}, October
    2017, \<<https://www.rfc-editor.org/info/rfc8288>\>.
:   

\[RFC8605\]
:   [Hollenbeck, S.]{.refAuthor}[ and R. Carney]{.refAuthor}, [\"vCard
    Format Extensions: ICANN Extensions for the Registration Data Access
    Protocol (RDAP)\"]{.refTitle}, [RFC 8605]{.seriesInfo}, [DOI
    10.17487/RFC8605]{.seriesInfo}, May 2019,
    \<<https://www.rfc-editor.org/info/rfc8605>\>.
:   
:::

::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[CURSOR\]
:   [Nimesh, R.]{.refAuthor}, [\"Paginating Real-Time Data with Cursor
    Based Pagination\"]{.refTitle}, July 2014,
    \<<https://www.sitepoint.com/paginating-real-time-data-cursor-based-pagination/>\>.
:   

\[CURSOR-API1\]
:   [Facebook]{.refAuthor}, [\"Facebook for Developers \-- Using the
    Graph API\"]{.refTitle},
    \<<https://developers.facebook.com/docs/graph-api/using-graph-api>\>.
:   

\[CURSOR-API2\]
:   [Twitter]{.refAuthor}, [\"Twitter Ads API\"]{.refTitle},
    \<<https://developer.twitter.com/en/docs/twitter-ads-api>\>.
:   

\[GOESSNER-JSON-PATH\]
:   [Goessner, S.]{.refAuthor}, [\"JSONPath - XPath for
    JSON\"]{.refTitle}, February 2007,
    \<<https://goessner.net/articles/JsonPath/>\>.
:   

\[HATEOAS\]
:   [Jedrzejewski, B.]{.refAuthor}, [\"HATEOAS - a simple
    explanation\"]{.refTitle}, February 2018,
    \<<https://www.e4developer.com/2018/02/16/hateoas-simple-explanation/>\>.
:   

\[JSONPATH-COMPARISON\]
:   [\"JSONPath Comparison\"]{.refTitle},
    \<<https://cburgmer.github.io/json-path-comparison/>\>.
:   

\[JSONPATH-WG\]
:   [IETF]{.refAuthor}, [\"JSON Path (jsonpath)\"]{.refTitle},
    \<<https://datatracker.ietf.org/wg/jsonpath/about/>\>.
:   

\[ODATA-PART1\]
:   [Pizzo, M.]{.refAuthor}[, Handl, R.]{.refAuthor}[, and M.
    Zurmuehl]{.refAuthor}, [\"OData Version 4.0. Part 1: Protocol Plus
    Errata 03\"]{.refTitle}, June 2016,
    \<<https://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/part1-protocol/odata-v4.0-errata03-os-part1-protocol-complete.pdf>\>.
:   

\[REST\]
:   [Fielding, R.]{.refAuthor}, [\"Architectural Styles and the Design
    of Network-based Software Architectures\"]{.refTitle}, 2000,
    \<<https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf>\>.
:   

\[RFC6901\]
:   [Bryan, P., Ed.]{.refAuthor}[, Zyp, K.]{.refAuthor}[, and M.
    Nottingham, Ed.]{.refAuthor}, [\"JavaScript Object Notation (JSON)
    Pointer\"]{.refTitle}, [RFC 6901]{.seriesInfo}, [DOI
    10.17487/RFC6901]{.seriesInfo}, April 2013,
    \<<https://www.rfc-editor.org/info/rfc6901>\>.
:   

\[SEEK\]
:   [EverSQL]{.refAuthor}, [\"Faster Pagination in Mysql - Why Order By
    With Limit and Offset is Slow?\"]{.refTitle}, July 2017,
    \<<https://www.eversql.com/faster-pagination-in-mysql-why-order-by-with-limit-and-offset-is-slow/>\>.
:   

\[W3C.CR-xpath-31-20170321\]
:   [Robie, J.]{.refAuthor}[, Dyck, M.]{.refAuthor}[, and J.
    Spiegel]{.refAuthor}, [\"XML Path Language (XPath)
    3.1\"]{.refTitle}, [World Wide Web Consortium Recommendation
    REC-xpath-31-20170321]{.refContent}, March 2017,
    \<<https://www.w3.org/TR/2017/REC-xpath-31-20170321/>\>.
:   
:::
:::

::: {#jsonpath-operators}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [JSONPath Operators](#name-jsonpath-operators){.section-name .selfRef} {#name-jsonpath-operators}

The jsonpaths used in this document are provided according to the
Goessner proposal
\[[GOESSNER-JSON-PATH](#GOESSNER-JSON-PATH){.xref}\].[¶](#section-appendix.a-1){.pilcrow}

Such specification requires that implementations support a set of
\"basic operators\". These operators are used to access the elements of
a JSON structure like objects and arrays, as well as their subelements
(object members and array items, respectively). No operations are
defined for retrieving parent or sibling elements of a given element.
The root element is always referred to as \$ regardless of it being an
object or array.[¶](#section-appendix.a-2){.pilcrow}

Additionally, the specification permits implementations to support
arbitrary script expressions. These can be used to index into an object
or array, or to filter elements from an array. While script expression
behavior is implementation-defined, most implementations support the
basic relational and logical operators as well as both object member and
array item access, sufficiently similar for the purpose of this
document. Commonly supported operators/functions divided into
\"top-level operators\" and \"filter operators\" are documented in
Tables [2](#table_json_path_top_level_operators){.xref} and
[3](#table_json_path_filter_operators){.xref},
respectively.[¶](#section-appendix.a-3){.pilcrow}

For more information on implementation interoperability issues, see
\[[JSONPATH-COMPARISON](#JSONPATH-COMPARISON){.xref}\]. At the time of
writing, work is beginning on a standardization effort too (see
\[[JSONPATH-WG](#JSONPATH-WG){.xref}\]).[¶](#section-appendix.a-4){.pilcrow}

[]{#name-jsonpath-top-level-operator}

::: {#table_json_path_top_level_operators}
  Operator               Description
  ---------------------- -----------------------------------------
  \$                     Root element
  .\<name>               Object member access (dot-notation)
  \[\'\<name>\'\]        Object member access (bracket-notation)
  \[\<number>\]          Array item access
  \*                     All elements within the specified scope
  \[?(\<expression>)\]   Filter expression

  : [Table 2](#table-2){.selfRef}: [JSONPath Top-Level
  Operators](#name-jsonpath-top-level-operator){.selfRef}
:::

[]{#name-jsonpath-filter-operators}

::: {#table_json_path_filter_operators}
  Operator                 Description
  ------------------------ ----------------------------------------
  @                        Current element being processed
  .\<name>                 Object member access
  .\[\<name1>,\<name2>\]   Union of object members
  \[\<number>\]            Array item access
  ==                       Left is equal to right
  !=                       Left is not equal to right
  \<                       Left is less than right
  \<=                      Left is less than or equal to right
  \>                       Left is greater than right
  \>=                      Left is greater than or equal to right
  &&                       Logical conjunction
  \|\|                     Logical disjunction

  : [Table 3](#table-3){.selfRef}: [JSONPath Filter
  Operators](#name-jsonpath-filter-operators){.selfRef}
:::
:::
:::

::: {#approaches-to-result-pagination}
::: {#section-appendix.b .section}
## [Appendix B.](#section-appendix.b){.section-number .selfRef} [Approaches to Result Pagination](#name-approaches-to-result-pagina){.section-name .selfRef} {#name-approaches-to-result-pagina}

An RDAP query could return a response with hundreds, even thousands, of
objects, especially when partial matching is used. For this reason, the
\"cursor\" parameter addressing result pagination is defined to make
responses easier to handle.[¶](#section-appendix.b-1){.pilcrow}

Presently, the most popular methods to implement pagination in a REST
API include offset pagination and keyset pagination. Neither pagination
method requires the server to handle the result set in a storage area
across multiple requests since a new result set is generated each time a
request is submitted. Therefore, they are preferred to any other method
requiring the management of a REST
session.[¶](#section-appendix.b-2){.pilcrow}

Using limit and offset operators represents the traditionally used
method to implement result pagination. Both of them can be used
individually:[¶](#section-appendix.b-3){.pilcrow}

[]{.break}

\"limit=N\":
:   means that the server returns the first N objects of the result
    set[¶](#section-appendix.b-4.2){.pilcrow}
:   

\"offset=N\":
:   means that the server skips the first N objects and returns objects
    starting from position N+1[¶](#section-appendix.b-4.4){.pilcrow}
:   

When limit and offset are used together, they provide the ability to
identify a specific portion of the result set. For example, the pair
\"offset=100,limit=50\" returns the first 50 objects starting from
position 101 of the result set.[¶](#section-appendix.b-5){.pilcrow}

Though easy to implement, offset pagination also includes
drawbacks:[¶](#section-appendix.b-6){.pilcrow}

-   ::: {#section-appendix.b-7.1}
    When offset has a very high value, scrolling the result set could
    take some time.[¶](#section-appendix.b-7.1.1){.pilcrow}
    :::

-   ::: {#section-appendix.b-7.2}
    It always requires fetching all rows before dropping as many rows as
    specified by offset.[¶](#section-appendix.b-7.2.1){.pilcrow}
    :::

-   [It may return inconsistent pages when data are frequently updated
    (i.e., real-time
    data).[¶](#section-appendix.b-7.3){.pilcrow}]{#section-appendix.b-7.3}

Keyset pagination \[[SEEK](#SEEK){.xref}\] adds a query condition that
enables the selection of the only data not yet returned. This method has
been taken as the basis for the implementation of a \"cursor\" parameter
\[[CURSOR](#CURSOR){.xref}\] by some REST API providers
\[[CURSOR-API1](#CURSOR-API1){.xref}\]
\[[CURSOR-API2](#CURSOR-API2){.xref}\]. The cursor is a URL-safe string
opaque to the client and representing a logical pointer to the first
result of the next page.[¶](#section-appendix.b-8){.pilcrow}

Nevertheless, even keyset pagination can be
troublesome:[¶](#section-appendix.b-9){.pilcrow}

-   ::: {#section-appendix.b-10.1}
    It needs at least one key
    field.[¶](#section-appendix.b-10.1.1){.pilcrow}
    :::

-   ::: {#section-appendix.b-10.2}
    It does not allow sorting simply by any field because the sorting
    criterion must contain a
    key.[¶](#section-appendix.b-10.2.1){.pilcrow}
    :::

-   ::: {#section-appendix.b-10.3}
    It works best with full composite values supported by database
    management systems (i.e., \[x,y\]\>\[a,b\]); emulation is possible
    but inelegant and less
    efficient.[¶](#section-appendix.b-10.3.1){.pilcrow}
    :::

-   ::: {#section-appendix.b-10.4}
    It does not allow direct navigation to arbitrary pages because the
    result set must be scrolled in sequential order starting from the
    initial page.[¶](#section-appendix.b-10.4.1){.pilcrow}
    :::

-   [Implementing bidirectional navigation is tedious because all
    comparison and sort operations have to be
    reversed.[¶](#section-appendix.b-10.5){.pilcrow}]{#section-appendix.b-10.5}

::: {#pagination-in-rdap}
::: {#section-b.1 .section}
## [B.1.](#section-b.1){.section-number .selfRef} [Specific Issues Raised by RDAP](#name-specific-issues-raised-by-r){.section-name .selfRef} {#name-specific-issues-raised-by-r}

Some additional considerations can be made in the RDAP
context:[¶](#section-b.1-1){.pilcrow}

-   ::: {#section-b.1-2.1}
    An RDAP object is a conceptual aggregation of information generally
    collected from more than one data structure (e.g., table), and this
    makes it even harder to implement keyset pagination, a task that is
    already quite difficult. For example, the entity object can include
    information from different data structures (registrars, registrants,
    contacts, resellers), each one with its key field mapping the RDAP
    entity handle.[¶](#section-b.1-2.1.1){.pilcrow}
    :::

-   ::: {#section-b.1-2.2}
    Depending on the number of page results as well as the number and
    the complexity of the properties of each RDAP object in the
    response, the time required by offset pagination to skip the
    previous pages could be much faster than the processing time needed
    to build the current page. In fact, RDAP objects are usually formed
    by information belonging to multiple data structures and containing
    multivalued properties (i.e., arrays); therefore, data selection
    might be a time-consuming process. This situation occurs even though
    the selection is supported by
    indexes.[¶](#section-b.1-2.2.1){.pilcrow}
    :::

-   [Depending on the access levels defined by each RDAP operator, the
    increase in complexity and the decrease in flexibility of keyset
    pagination in comparison to offset pagination could be considered
    impractical.[¶](#section-b.1-2.3){.pilcrow}]{#section-b.1-2.3}

Ultimately, both pagination methods have benefits and
drawbacks.[¶](#section-b.1-3){.pilcrow}
:::
:::
:::
:::

::: {#additional-implementation-notes}
::: {#section-appendix.c .section}
## [Appendix C.](#section-appendix.c){.section-number .selfRef} [Implementation Notes](#name-implementation-notes){.section-name .selfRef} {#name-implementation-notes}

This section contains an overview of the main choices made during the
implementation of the capabilities defined in this document in the RDAP
public test server of Registro.it at the Institute of Informatics and
Telematics of the National Research Council (IIT-CNR). The content of
this section can represent guidance for implementers who plan to provide
RDAP users with those capabilities. The RDAP public test server can be
accessed at \<<https://rdap.pubtest.nic.it/>\>. Further documentation
about the server features is available at
\<<https://rdap.pubtest.nic.it/doc/README.html>\>.[¶](#section-appendix.c-1){.pilcrow}

::: {#section-c.1 .section}
## [C.1.](#section-c.1){.section-number .selfRef} [Sorting](#name-sorting){.section-name .selfRef} {#name-sorting}

If no sort criterion is specified in the query string, the results are
sorted by a default property: \"name\" for domains and nameservers, and
\"handle\" for entities. The server supports multiple property sorting
but the \"sorting_metadata\" object includes only the links to
alternative result set views sorted by a single property just to show
the list of sorting properties allowed for each searchable object. The
server supports all the object-specific sorting properties described in
the specification except for nameserver sorting based on unicodeName,
that is, the \"name\" sorting property is mapped onto the \"ldhName\"
response field. Regarding the object-common properties, sorting by
registrationDate, expirationDate, lastChangedDate, and transferDate is
supported.[¶](#section-c.1-1){.pilcrow}
:::

::: {#section-c.2 .section}
## [C.2.](#section-c.2){.section-number .selfRef} [Counting](#name-counting){.section-name .selfRef} {#name-counting}

The counting operation is implemented through a separate query. Some
relational database management systems support custom operators to get
the total count together with the rows, but the resulting query can be
considerably more expensive than that performed without the total count.
Therefore, as \"totalCount\" is an optional response information, always
fetching the total number of rows has been considered an inefficient
solution. Furthermore, to avoid the processing of unnecessary queries,
when the \"count\" parameter is included in the submitted query, it is
not also repeated in the query strings of the \"links\" array provided
in both \"paging_metadata\" and \"sorting_metadata\"
objects.[¶](#section-c.2-1){.pilcrow}
:::

::: {#section-c.3 .section}
## [C.3.](#section-c.3){.section-number .selfRef} [Paging](#name-paging){.section-name .selfRef} {#name-paging}

The server implements the cursor pagination through the keyset
pagination when sorting by a unique property is requested or the default
sort is applied. Otherwise, it implements the cursor pagination through
the offset pagination. As most relational database management systems
don\'t support the comparison of full composite values natively, the
implementation of full keyset pagination seem to be troublesome so, at
least initially, a selective applicability of keyset pagination is
advisable. Moreover, the \"cursor\" value encodes not only information
about pagination but also about the search pattern and the other query
parameters in order to check the consistency of the entire query string.
If the \"cursor\" value is inconsistent with the rest of the query
string, the server returns an error
response.[¶](#section-c.3-1){.pilcrow}
:::
:::
:::

::: {#section-appendix.d .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

The authors would like to acknowledge [Brian Mountford]{.contact-name},
[Tom Harrison]{.contact-name}, [Karl Heinz Wolf]{.contact-name}, [Jasdip
Singh]{.contact-name}, [Erik Kline]{.contact-name}, [Éric
Vyncke]{.contact-name}, [Benjamin Kaduk]{.contact-name}, and [Roman
Danyliw]{.contact-name} for their contributions to the development of
this document.[¶](#section-appendix.d-1){.pilcrow}
:::

::: {#authors-addresses}
::: {#section-appendix.e .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Mario Loffredo]{.fn .nameRole}
:::

::: {.left dir="auto"}
[IIT-CNR/Registro.it]{.org}
:::

::: {.left dir="auto"}
[Via Moruzzi,1]{.street-address}
:::

::: {.left dir="auto"}
[56124]{.postal-code} [Pisa]{.locality}
:::

::: {.left dir="auto"}
[Italy]{.country-name}
:::

::: email
Email: <mario.loffredo@iit.cnr.it>
:::

::: url
URI: <https://www.iit.cnr.it>
:::

::: {.left dir="auto"}
[Maurizio Martinelli]{.fn .nameRole}
:::

::: {.left dir="auto"}
[IIT-CNR/Registro.it]{.org}
:::

::: {.left dir="auto"}
[Via Moruzzi,1]{.street-address}
:::

::: {.left dir="auto"}
[56124]{.postal-code} [Pisa]{.locality}
:::

::: {.left dir="auto"}
[Italy]{.country-name}
:::

::: email
Email: <maurizio.martinelli@iit.cnr.it>
:::

::: url
URI: <https://www.iit.cnr.it>
:::

::: {.left dir="auto"}
[Scott Hollenbeck]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Verisign Labs]{.org}
:::

::: {.left dir="auto"}
[12061 Bluemont Way]{.street-address}
:::

::: {.left dir="auto"}
[Reston]{.locality}, [VA]{.region} [20190]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <shollenbeck@verisign.com>
:::

::: url
URI: <https://www.verisignlabs.com/>
:::
:::
:::
