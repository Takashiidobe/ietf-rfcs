  RFC 8698      NADA           February 2020
  ------------- -------------- ---------------
  Zhu, et al.   Experimental   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8698](https://www.rfc-editor.org/rfc/rfc8698){.eref}

Category:
:   Experimental

Published:
:   February 2020

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    X. Zhu
    :::

    ::: org
    Cisco Systems
    :::
    :::

    ::: author
    ::: author-name
    R. Pan
    :::

    ::: org
    Intel Corporation
    :::
    :::

    ::: author
    ::: author-name
    M. Ramalho
    :::

    ::: org
    AcousticComms
    :::
    :::

    ::: author
    ::: author-name
    S. Mena
    :::

    ::: org
    Cisco Systems
    :::
    :::
:::

# RFC 8698 {#rfcnum}

# Network-Assisted Dynamic Adaptation (NADA): A Unified Congestion Control Scheme for Real-Time Media {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes Network-Assisted Dynamic Adaptation (NADA), a
novel congestion control scheme for interactive real-time media
applications such as video conferencing. In the proposed scheme, the
sender regulates its sending rate, based on either implicit or explicit
congestion signaling, in a unified approach. The scheme can benefit from
Explicit Congestion Notification (ECN) markings from network nodes. It
also maintains consistent sender behavior in the absence of such
markings by reacting to queuing delays and packet losses
instead.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for examination, experimental implementation, and
evaluation.[¶](#section-boilerplate.1-1){.pilcrow}

This document defines an Experimental Protocol for the Internet
community. This document is a product of the Internet Engineering Task
Force (IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Not all documents approved
by the IESG are candidates for any level of Internet Standard; see
Section 2 of RFC 7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8698>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [System
    Overview](#name-system-overview){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Core Congestion Control
    Algorithm](#name-core-congestion-control-alg){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Mathematical
        Notations](#name-mathematical-notations){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Receiver-Side
        Algorithm](#name-receiver-side-algorithm){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Sender-Side
        Algorithm](#name-sender-side-algorithm){.xref}[¶](#section-toc.1-1.4.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Practical Implementation of
    NADA](#name-practical-implementation-of){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Receiver-Side
        Operation](#name-receiver-side-operation){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.5.2.1.2.1}
            [5.1.1](#section-5.1.1){.xref}.  [Estimation of One-Way
            Delay and Queuing
            Delay](#name-estimation-of-one-way-delay){.xref}[¶](#section-toc.1-1.5.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.2}
            [5.1.2](#section-5.1.2){.xref}.  [Estimation of Packet
            Loss/Marking
            Ratio](#name-estimation-of-packet-loss-m){.xref}[¶](#section-toc.1-1.5.2.1.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.3}
            [5.1.3](#section-5.1.3){.xref}.  [Estimation of Receiving
            Rate](#name-estimation-of-receiving-rat){.xref}[¶](#section-toc.1-1.5.2.1.2.3.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Sender-Side
        Operation](#name-sender-side-operation){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.5.2.2.2.1}
            [5.2.1](#section-5.2.1){.xref}.  [Rate-Shaping
            Buffer](#name-rate-shaping-buffer){.xref}[¶](#section-toc.1-1.5.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.2}
            [5.2.2](#section-5.2.2){.xref}.  [Adjusting Video Target
            Rate and Sending
            Rate](#name-adjusting-video-target-rate){.xref}[¶](#section-toc.1-1.5.2.2.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Feedback Message
        Requirements](#name-feedback-message-requiremen){.xref}[¶](#section-toc.1-1.5.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Discussions and Further
    Investigations](#name-discussions-and-further-inv){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Choice of Delay
        Metrics](#name-choice-of-delay-metrics){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Method for Delay, Loss, and
        Marking Ratio
        Estimation](#name-method-for-delay-loss-and-m){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Impact of Parameter
        Values](#name-impact-of-parameter-values){.xref}[¶](#section-toc.1-1.6.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [Sender-Based vs. Receiver-Based
        Calculation](#name-sender-based-vs-receiver-ba){.xref}[¶](#section-toc.1-1.6.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.5}
        [6.5](#section-6.5){.xref}.  [Incremental
        Deployment](#name-incremental-deployment){.xref}[¶](#section-toc.1-1.6.2.5.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Reference
    Implementations](#name-reference-implementations){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Suggested
    Experiments](#name-suggested-experiments){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}

    -   ::: {#section-toc.1-1.11.2.1}
        [11.1](#section-11.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.11.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [11.2](#section-11.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.11.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [Appendix A](#section-appendix.a){.xref}.  [Network Node
    Operations](#name-network-node-operations){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}

    -   ::: {#section-toc.1-1.12.2.1}
        [A.1](#section-a.1){.xref}.  [Default Behavior of Drop-Tail
        Queues](#name-default-behavior-of-drop-ta){.xref}[¶](#section-toc.1-1.12.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [A.2](#section-a.2){.xref}.  [RED-Based ECN
        Marking](#name-red-based-ecn-marking){.xref}[¶](#section-toc.1-1.12.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.12.2.3}
        [A.3](#section-a.3){.xref}.  [Random Early Marking with Virtual
        Queues](#name-random-early-marking-with-v){.xref}[¶](#section-toc.1-1.12.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [](#section-appendix.b){.xref}[Acknowledgments](#name-acknowledgments){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.14}
    [](#section-appendix.c){.xref}[Contributors](#name-contributors){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.15}
    [](#section-appendix.d){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.15.1){.pilcrow}
    :::
:::
:::

::: {#sec-intro}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Interactive real-time media applications introduce a unique set of
challenges for congestion control. Unlike TCP, the mechanism used for
real-time media needs to adapt quickly to instantaneous bandwidth
changes, accommodate fluctuations in the output of video encoder rate
control, and cause low queuing delay over the network. An ideal scheme
should also make effective use of all types of congestion signals,
including packet loss, queuing delay, and explicit congestion
notification (ECN) \[[RFC3168](#RFC3168){.xref}\] markings. The
requirements for the congestion control algorithm are outlined in
\[[RMCAT-CC](#I-D.ietf-rmcat-cc-requirements){.xref}\]. The requirements
highlight that the desired congestion control scheme should 1) avoid
flow starvation and attain a reasonable fair share of bandwidth when
competing against other flows, 2) adapt quickly, and 3) operate in a
stable manner.[¶](#section-1-1){.pilcrow}

This document describes an experimental congestion control scheme called
Network-Assisted Dynamic Adaptation (NADA). The design of NADA benefits
from explicit congestion control signals (e.g., ECN markings) from the
network, yet also operates when only implicit congestion indicators
(delay and/or loss) are available. Such a unified sender behavior
distinguishes NADA from other congestion control schemes for real-time
media. In addition, its core congestion control algorithm is designed to
guarantee stability for path round-trip times (RTTs) below a prescribed
bound (e.g., 250 ms with default parameter choices). It further supports
weighted bandwidth sharing among competing video flows with different
priorities. The signaling mechanism consists of standard Real-time
Transport Protocol (RTP) timestamp \[[RFC3550](#RFC3550){.xref}\] and
Real-time Transport Control Protocol (RTCP) feedback reports. The
definition of the desired RTCP feedback message is described in detail
in \[[RTCP-FEEDBACK](#I-D.ietf-avtcore-cc-feedback-message){.xref}\] so
as to support the successful operation of several congestion control
schemes for real-time interactive media.[¶](#section-1-2){.pilcrow}
:::
:::

::: {#sec-term}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}
:::
:::

::: {#sec-system-overview}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [System Overview](#name-system-overview){.section-name .selfRef} {#name-system-overview}

[Figure 1](#fig-system-overview){.xref} shows the end-to-end system for
real-time media transport that NADA operates in. Note that there also
exist network nodes along the reverse (potentially uncongested) path
that the RTCP feedback reports traverse. Those network nodes are not
shown in the figure for the sake of brevity.[¶](#section-3-1){.pilcrow}

[]{#name-system-overview-2}

::: {#fig-system-overview}
::: {#section-3-2.1 .artwork .art-text .alignLeft}
      +---------+  r_vin  +--------+        +--------+     +----------+
      |  Media  |<--------|  RTP   |        |Network |     |   RTP    |
      | Encoder |========>| Sender |=======>|  Node  |====>| Receiver |  
      +---------+  r_vout +--------+ r_send +--------+     +----------+
                              /|\                                |
                               |                                 |
                               +---------------------------------+
                                     RTCP Feedback Report
:::

[Figure 1](#figure-1){.selfRef}: [System
Overview](#name-system-overview-2){.selfRef}
:::

Media encoder with rate control capabilities:
:   Encodes raw media (audio and video) frames into a compressed
    bitstream that is later packetized into RTP packets. As discussed in
    \[[RFC8593](#RFC8593){.xref}\], the actual output rate from the
    encoder r_vout may fluctuate around the target r_vin. Furthermore,
    it is possible that the encoder can only react to bit rate changes
    at rather coarse time intervals, e.g., once every 0.5
    seconds.[¶](#section-3-3.2){.pilcrow}

RTP sender:
:   Responsible for calculating the NADA reference rate based on network
    congestion indicators (delay, loss, or ECN marking reports from the
    receiver), for updating the video encoder with a new target rate
    r_vin and for regulating the actual sending rate r_send accordingly.
    The RTP sender also generates a sending timestamp for each outgoing
    packet.[¶](#section-3-3.4){.pilcrow}

RTP receiver:
:   Responsible for measuring and estimating end-to-end delay (based on
    sender timestamp), packet loss (based on RTP sequence number), ECN
    marking ratios (based on \[[RFC6679](#RFC6679){.xref}\]), and
    receiving rate (r_recv) of the flow. It calculates the aggregated
    congestion signal (x_curr) that accounts for queuing delay, ECN
    markings, and packet losses. The receiver also determines the mode
    for sender rate adaptation (rmode) based on whether the flow has
    encountered any standing non-zero congestion. The receiver sends
    periodic RTCP reports back to the sender, containing values of
    x_curr, rmode, and r_recv.[¶](#section-3-3.6){.pilcrow}

Network node with several modes of operation:
:   The system can work with the default behavior of a simple drop-tail
    queue. It can also benefit from advanced Active Queue Management
    (AQM) features such as Proportional Integral Controller Enhanced
    [(PIE)](#RFC8033){.xref} \[[RFC8033](#RFC8033){.xref}\], Flow Queue
    Controlling Queue Delay [(FQ-CoDel)](#RFC8290){.xref}
    \[[RFC8290](#RFC8290){.xref}\], ECN marking based on [Random Early
    Detection (RED)](#RFC7567){.xref} \[[RFC7567](#RFC7567){.xref}\],
    and Pre-Congestion Notification (PCN) marking using a token bucket
    algorithm \[[RFC6660](#RFC6660){.xref}\]. Note that network node
    operation is out of scope for the design of
    NADA.[¶](#section-3-3.8){.pilcrow}
:::
:::

::: {#sec-algorithm}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Core Congestion Control Algorithm](#name-core-congestion-control-alg){.section-name .selfRef} {#name-core-congestion-control-alg}

Like TCP-Friendly Rate Control (TFRC)
\[[FLOYD-CCR00](#FLOYD-CCR00){.xref}\] \[[RFC5348](#RFC5348){.xref}\],
NADA is a rate-based congestion control algorithm. In its simplest form,
the sender reacts to the collection of network congestion indicators in
the form of an aggregated congestion signal and operates in one of two
modes:[¶](#section-4-1){.pilcrow}

Accelerated ramp up:
:   When the bottleneck is deemed to be underutilized, the rate
    increases multiplicatively with respect to the rate of previously
    successful transmissions. The rate increase multiplier (gamma) is
    calculated based on the observed round-trip time and target feedback
    interval, so as to limit self-inflicted queuing
    delay.[¶](#section-4-2.2){.pilcrow}

Gradual rate update:
:   In the presence of a non-zero aggregate congestion signal, the
    sending rate is adjusted in reaction to both its value (x_curr) and
    its change in value (x_diff).[¶](#section-4-2.4){.pilcrow}

This section introduces the list of mathematical notations and describes
the core congestion control algorithm at the sender and receiver,
respectively. Additional details on recommended practical
implementations are described in Sections [5.1](#sec-receiver){.xref}
and [5.2](#sec-sender){.xref}.[¶](#section-4-3){.pilcrow}

::: {#sec-notation}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Mathematical Notations](#name-mathematical-notations){.section-name .selfRef} {#name-mathematical-notations}

This section summarizes the list of variables and parameters used in the
NADA algorithm. [Table 2](#tab-parameters){.xref} also includes the
default values for choosing the algorithm parameters to represent either
a typical setting in practical applications or a setting based on
theoretical and simulation studies. See [Section
6.3](#sec-discussion-c){.xref} for some of the discussions on the impact
of parameter values. Additional studies in real-world settings suggested
in [Section 8](#sec-experiments){.xref} could gather further insight on
how to choose and adapt these parameter values in practical
deployment.[¶](#section-4.1-1){.pilcrow}

[]{#name-list-of-variables}

::: {#tab-variables}
  Notation     Variable Name
  ------------ -------------------------------------------------------------------------------------------
  t_curr       Current timestamp
  t_last       Last time sending/receiving a feedback message
  delta        Observed interval between current and previous feedback reports: delta = t_curr-t_last
  r_ref        Reference rate based on network congestion
  r_send       Sending rate
  r_recv       Receiving rate
  r_vin        Target rate for video encoder
  r_vout       Output rate from video encoder
  d_base       Estimated baseline delay
  d_fwd        Measured and filtered one-way delay
  d_queue      Estimated queuing delay
  d_tilde      Equivalent delay after non-linear warping
  p_mark       Estimated packet ECN marking ratio
  p_loss       Estimated packet loss ratio
  x_curr       Aggregate congestion signal
  x_prev       Previous value of aggregate congestion signal
  x_diff       Change in aggregate congestion signal w.r.t. its previous value: x_diff = x_curr - x_prev
  rmode        Rate update mode: (0 = accelerated ramp up; 1 = gradual update)
  gamma        Rate increase multiplier in accelerated ramp-up mode
  loss_int     Measured average loss interval in packet count
  loss_exp     Threshold value for setting the last observed packet loss to expiration
  rtt          Estimated round-trip time at sender
  buffer_len   Rate-shaping buffer occupancy measured in bytes

  : [Table 1](#table-1){.selfRef}: [List of
  Variables](#name-list-of-variables){.selfRef}
:::

[]{#name-list-of-algorithm-parameter}

::: {#tab-parameters}
  Notation    Parameter Name                                                                                                                                 Default Value
  ----------- ---------------------------------------------------------------------------------------------------------------------------------------------- ---------------
  PRIO        Weight of priority of the flow                                                                                                                 1.0
  RMIN        Minimum rate of application supported by media encoder                                                                                         150 Kbps
  RMAX        Maximum rate of application supported by media encoder                                                                                         1.5 Mbps
  XREF        Reference congestion level                                                                                                                     10 ms
  KAPPA       Scaling parameter for gradual rate update calculation                                                                                          0.5
  ETA         Scaling parameter for gradual rate update calculation                                                                                          2.0
  TAU         Upper bound of RTT in gradual rate update calculation                                                                                          500 ms
  DELTA       Target feedback interval                                                                                                                       100 ms
  LOGWIN      Observation window in time for calculating packet summary statistics at receiver                                                               500 ms
  QEPS        Threshold for determining queuing delay buildup at receiver                                                                                    10 ms
  DFILT       Bound on filtering delay                                                                                                                       120 ms
  GAMMA_MAX   Upper bound on rate increase ratio for accelerated ramp up                                                                                     0.5
  QBOUND      Upper bound on self-inflicted queuing delay during ramp up                                                                                     50 ms
  MULTILOSS   Multiplier for self-scaling the expiration threshold of the last observed loss (loss_exp) based on measured average loss interval (loss_int)   7.0
  QTH         Delay threshold for invoking non-linear warping                                                                                                50 ms
  LAMBDA      Scaling parameter in the exponent of non-linear warping                                                                                        0.5
  PLRREF      Reference packet loss ratio                                                                                                                    0.01
  PMRREF      Reference packet marking ratio                                                                                                                 0.01
  DLOSS       Reference delay penalty for loss when packet loss ratio is at PLRREF                                                                           10 ms
  DMARK       Reference delay penalty for ECN marking when packet marking is at PMRREF                                                                       2 ms
  FPS         Frame rate of incoming video                                                                                                                   30
  BETA_S      Scaling parameter for modulating outgoing sending rate                                                                                         0.1
  BETA_V      Scaling parameter for modulating video encoder target rate                                                                                     0.1
  ALPHA       Smoothing factor in exponential smoothing of packet loss and marking ratios                                                                    0.1

  : [Table 2](#table-2){.selfRef}: [List of Algorithm Parameters and
  Their Default Values](#name-list-of-algorithm-parameter){.selfRef}
:::
:::
:::

::: {#subsec-receiver-algorithm}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Receiver-Side Algorithm](#name-receiver-side-algorithm){.section-name .selfRef} {#name-receiver-side-algorithm}

The receiver-side algorithm can be outlined as
below:[¶](#section-4.2-1){.pilcrow}

-   [On
    initialization:[¶](#section-4.2-2.1){.pilcrow}]{#section-4.2-2.1}

-   ::: {#section-4.2-2.2}
    -   [set d_base =
        +INFINITY[¶](#section-4.2-2.2.1.1){.pilcrow}]{#section-4.2-2.2.1.1}
    -   [set p_loss =
        0[¶](#section-4.2-2.2.1.2){.pilcrow}]{#section-4.2-2.2.1.2}
    -   [set p_mark =
        0[¶](#section-4.2-2.2.1.3){.pilcrow}]{#section-4.2-2.2.1.3}
    -   [set r_recv =
        0[¶](#section-4.2-2.2.1.4){.pilcrow}]{#section-4.2-2.2.1.4}
    -   [set both t_last and t_curr as current time in
        milliseconds[¶](#section-4.2-2.2.1.5){.pilcrow}]{#section-4.2-2.2.1.5}
    :::

-   [On receiving a media
    packet:[¶](#section-4.2-2.3){.pilcrow}]{#section-4.2-2.3}

-   ::: {#section-4.2-2.4}
    -   [obtain current timestamp t_curr from system
        clock[¶](#section-4.2-2.4.1.1){.pilcrow}]{#section-4.2-2.4.1.1}
    -   [obtain from packet header sending time stamp
        t_sent[¶](#section-4.2-2.4.1.2){.pilcrow}]{#section-4.2-2.4.1.2}
    -   [obtain one-way delay measurement: d_fwd = t_curr -
        t_sent[¶](#section-4.2-2.4.1.3){.pilcrow}]{#section-4.2-2.4.1.3}
    -   [update baseline delay: d_base = min(d_base,
        d_fwd)[¶](#section-4.2-2.4.1.4){.pilcrow}]{#section-4.2-2.4.1.4}
    -   [update queuing delay: d_queue = d_fwd -
        d_base[¶](#section-4.2-2.4.1.5){.pilcrow}]{#section-4.2-2.4.1.5}
    -   [update packet loss ratio estimate
        p_loss[¶](#section-4.2-2.4.1.6){.pilcrow}]{#section-4.2-2.4.1.6}
    -   [update packet marking ratio estimate
        p_mark[¶](#section-4.2-2.4.1.7){.pilcrow}]{#section-4.2-2.4.1.7}
    -   [update measurement of receiving rate
        r_recv[¶](#section-4.2-2.4.1.8){.pilcrow}]{#section-4.2-2.4.1.8}
    :::

-   [On time to send a new feedback report (t_curr - t_last >
    DELTA):[¶](#section-4.2-2.5){.pilcrow}]{#section-4.2-2.5}

-   ::: {#section-4.2-2.6}
    -   [calculate non-linear warping of delay d_tilde if packet loss
        exists[¶](#section-4.2-2.6.1.1){.pilcrow}]{#section-4.2-2.6.1.1}
    -   [calculate current aggregate congestion signal
        x_curr[¶](#section-4.2-2.6.1.2){.pilcrow}]{#section-4.2-2.6.1.2}
    -   [determine mode of rate adaptation for sender:
        rmode[¶](#section-4.2-2.6.1.3){.pilcrow}]{#section-4.2-2.6.1.3}
    -   [send feedback containing values of: rmode, x_curr, and
        r_recv[¶](#section-4.2-2.6.1.4){.pilcrow}]{#section-4.2-2.6.1.4}
    -   [update t_last =
        t_curr[¶](#section-4.2-2.6.1.5){.pilcrow}]{#section-4.2-2.6.1.5}
    :::

In order for a delay-based flow to hold its ground when competing
against loss-based flows (e.g., loss-based TCP), it is important to
distinguish between different levels of observed queuing delay. For
instance, over wired connections, a moderate queuing delay value on the
order of tens of milliseconds is likely self-inflicted or induced by
other delay-based flows, whereas a high queuing delay value of several
hundreds of milliseconds may indicate the presence of a loss-based flow
that does not refrain from increased delay.[¶](#section-4.2-3){.pilcrow}

If the last observed packet loss is within the expiration window of
loss_exp (measured in terms of packet counts), the estimated queuing
delay follows a non-linear warping:[¶](#section-4.2-4){.pilcrow}

::: {#section-4.2-5 .artwork .art-text .alignLeft}
               / d_queue,                   if d_queue < QTH
               |
    d_tilde = <                                           (1)
               |                  (d_queue-QTH)  
               \ QTH exp(-LAMBDA ---------------) , otherwise
                                     QTH    

[¶](#section-4.2-5){.pilcrow}
:::

In Equation (1), the queuing delay value is unchanged when it is below
the first threshold QTH; otherwise, it is scaled down following a
non-linear curve. This non-linear warping is inspired by the
delay-adaptive congestion window backoff policy in
\[[BUDZISZ-AIMD-CC](#BUDZISZ-AIMD-CC){.xref}\] so as to \"gradually
nudge\" the controller to operate based on loss-induced congestion
signals when competing against loss-based flows. The exact form of the
non-linear function has been simplified with respect to
\[[BUDZISZ-AIMD-CC](#BUDZISZ-AIMD-CC){.xref}\]. The value of the
threshold QTH should be carefully tuned for different operational
environments so as to avoid potential risks of prematurely discounting
the congestion signal level. Typically, a higher value of QTH is
required in a noisier environment (e.g., over wireless connections or
where the video stream encounters many time-varying background competing
traffic) so as to stay robust against occasional non-congestion-induced
delay spikes. Additional insights on how this value can be tuned or
auto-tuned should be gathered from carrying out experimental studies in
different real-world deployment scenarios.[¶](#section-4.2-6){.pilcrow}

The value of loss_exp is configured to self-scale with the average
packet loss interval loss_int with a multiplier
MULTILOSS:[¶](#section-4.2-7){.pilcrow}

::: {#section-4.2-8 .artwork .art-text .alignLeft}
     loss_exp = MULTILOSS *
    loss_int.  

[¶](#section-4.2-8){.pilcrow}
:::

Estimation of the average loss interval loss_int, in turn, follows
[Section
5.4](https://www.rfc-editor.org/rfc/rfc5348#section-5.4){.relref} of
\"TCP Friendly Rate Control (TFRC): Protocol Specification\"
\[[RFC5348](#RFC5348){.xref}\].[¶](#section-4.2-9){.pilcrow}

In practice, it is recommended to linearly interpolate between the
warped (d_tilde) and non-warped (d_queue) values of the queuing delay
during the transitional period lasting for the duration of
loss_int.[¶](#section-4.2-10){.pilcrow}

The aggregate congestion signal is:[¶](#section-4.2-11){.pilcrow}

::: {#section-4.2-12 .artwork .art-text .alignLeft}
                             / p_mark \^2        / p_loss \^2 
    x_curr = d_tilde + DMARK*|--------|  + DLOSS*|--------|   (2) 
                             \ PMRREF /          \ PLRREF /         

[¶](#section-4.2-12){.pilcrow}
:::

Here, DMARK is prescribed a reference delay penalty associated with ECN
markings at the reference marking ratio of PMRREF; DLOSS is prescribed a
reference delay penalty associated with packet losses at the reference
packet loss ratio of PLRREF. The value of DLOSS and DMARK does not
depend on configurations at the network node. Since ECN-enabled active
queue management schemes typically mark a packet before dropping it, the
value of DLOSS [SHOULD]{.bcp14} be higher than that of DMARK.
Furthermore, the values of DLOSS and DMARK need to be set consistently
across all NADA flows sharing the same bottleneck link so that they can
compete fairly.[¶](#section-4.2-13){.pilcrow}

In the absence of packet marking and losses, the value of x_curr reduces
to the observed queuing delay d_queue. In that case, the NADA algorithm
operates in the regime of delay-based
adaptation.[¶](#section-4.2-14){.pilcrow}

Given observed per-packet delay and loss information, the receiver is
also in a good position to determine whether or not the network is
underutilized and then recommend the corresponding rate adaptation mode
for the sender. The criteria for operating in accelerated ramp-up mode
are:[¶](#section-4.2-15){.pilcrow}

-   [No recent packet losses within the observation window LOGWIN;
    and[¶](#section-4.2-16.1){.pilcrow}]{#section-4.2-16.1}
-   [No buildup of queuing delay: d_fwd-d_base \< QEPS for all previous
    delay samples within the observation window
    LOGWIN.[¶](#section-4.2-16.2){.pilcrow}]{#section-4.2-16.2}

Otherwise, the algorithm operates in graduate update
mode.[¶](#section-4.2-17){.pilcrow}
:::
:::

::: {#subsec-sender-algorithm}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Sender-Side Algorithm](#name-sender-side-algorithm){.section-name .selfRef} {#name-sender-side-algorithm}

The sender-side algorithm is outlined as
follows:[¶](#section-4.3-1){.pilcrow}

-   [On
    initialization:[¶](#section-4.3-2.1){.pilcrow}]{#section-4.3-2.1}

-   ::: {#section-4.3-2.2}
    -   [set r_ref =
        RMIN[¶](#section-4.3-2.2.1.1){.pilcrow}]{#section-4.3-2.2.1.1}
    -   [set rtt =
        0[¶](#section-4.3-2.2.1.2){.pilcrow}]{#section-4.3-2.2.1.2}
    -   [set x_prev =
        0[¶](#section-4.3-2.2.1.3){.pilcrow}]{#section-4.3-2.2.1.3}
    -   [set t_last and t_curr as current system clock
        time[¶](#section-4.3-2.2.1.4){.pilcrow}]{#section-4.3-2.2.1.4}
    :::

-   [On receiving feedback
    report:[¶](#section-4.3-2.3){.pilcrow}]{#section-4.3-2.3}

-   ::: {#section-4.3-2.4}
    -   [obtain current timestamp from system clock:
        t_curr[¶](#section-4.3-2.4.1.1){.pilcrow}]{#section-4.3-2.4.1.1}

    -   [obtain values of rmode, x_curr, and r_recv from feedback
        report[¶](#section-4.3-2.4.1.2){.pilcrow}]{#section-4.3-2.4.1.2}

    -   [update estimation of
        rtt[¶](#section-4.3-2.4.1.3){.pilcrow}]{#section-4.3-2.4.1.3}

    -   [measure feedback interval: delta = t_curr -
        t_last[¶](#section-4.3-2.4.1.4){.pilcrow}]{#section-4.3-2.4.1.4}

    -   [if rmode ==
        0:[¶](#section-4.3-2.4.1.5){.pilcrow}]{#section-4.3-2.4.1.5}

    -   ::: {#section-4.3-2.4.1.6}
        -   [update r_ref following accelerated ramp-up
            rules[¶](#section-4.3-2.4.1.6.1.1){.pilcrow}]{#section-4.3-2.4.1.6.1.1}
        :::

    -   [else:[¶](#section-4.3-2.4.1.7){.pilcrow}]{#section-4.3-2.4.1.7}

    -   ::: {#section-4.3-2.4.1.8}
        -   [update r_ref following gradual update
            rules[¶](#section-4.3-2.4.1.8.1.1){.pilcrow}]{#section-4.3-2.4.1.8.1.1}
        :::

    -   [clip rate r_ref within the range of minimum rate (RMIN) and
        maximum rate
        (RMAX).[¶](#section-4.3-2.4.1.9){.pilcrow}]{#section-4.3-2.4.1.9}

    -   [set x_prev =
        x_curr[¶](#section-4.3-2.4.1.10){.pilcrow}]{#section-4.3-2.4.1.10}

    -   [set t_last =
        t_curr[¶](#section-4.3-2.4.1.11){.pilcrow}]{#section-4.3-2.4.1.11}
    :::

In accelerated ramp-up mode, the rate r_ref is updated as
follows:[¶](#section-4.3-3){.pilcrow}

::: {#section-4.3-4 .artwork .art-text .alignLeft}
                                    QBOUND
        gamma = min(GAMMA_MAX, ------------------)       (3)
                                rtt+DELTA+DFILT

                                r_ref = max(r_ref, (1+gamma) r_recv)
                                (4)    

[¶](#section-4.3-4){.pilcrow}
:::

The rate increase multiplier gamma is calculated as a function of the
upper bound of self-inflicted queuing delay (QBOUND), round-trip time
(rtt), and target feedback interval (DELTA); it is bound on the
filtering delay for calculating d_queue (DFILT). It has a maximum value
of GAMMA_MAX. The rationale behind Equations (3)-(4) is that the longer
it takes for the sender to observe self-inflicted queuing delay buildup,
the more conservative the sender should be in increasing its rate and,
hence, the smaller the rate increase
multiplier.[¶](#section-4.3-5){.pilcrow}

In gradual update mode, the rate r_ref is updated
as:[¶](#section-4.3-6){.pilcrow}

::: {#section-4.3-7 .artwork .art-text .alignLeft}
        x_offset = x_curr - PRIO*XREF*RMAX/r_ref          (5)

        x_diff   = x_curr - x_prev                        (6) 

                               delta    x_offset
        r_ref = r_ref - KAPPA*-------*------------*r_ref
                                TAU       TAU

                                    x_diff
                      - KAPPA*ETA*---------*r_ref         (7)
                                     TAU    

[¶](#section-4.3-7){.pilcrow}
:::

The rate changes in proportion to the previous rate decision. It is
affected by two terms: the offset of the aggregate congestion signal
from its value at equilibrium (x_offset) and its change (x_diff). The
calculation of x_offset depends on the maximum rate of the flow (RMAX),
its weight of priority (PRIO), as well as a reference congestion signal
(XREF). The value of XREF is chosen so that the maximum rate of RMAX can
be achieved when the observed congestion signal level is below
PRIO\*XREF.[¶](#section-4.3-8){.pilcrow}

At equilibrium, the aggregated congestion signal stabilizes at x_curr =
PRIO\*XREF\*RMAX/r_ref. This ensures that when multiple flows share the
same bottleneck and observe a common value of x_curr, their rates at
equilibrium will be proportional to their respective priority levels
(PRIO) and the range between minimum and maximum rate. Values of the
minimum rate (RMIN) and maximum rate (RMAX) will be provided by the
media codec, for instance, as outlined by
\[[RMCAT-CC-RTP](#I-D.ietf-rmcat-cc-codec-interactions){.xref}\]. In the
absence of such information, the NADA sender will choose a default value
of 0 for RMIN and 3 Mbps for RMAX.[¶](#section-4.3-9){.pilcrow}

As mentioned in the sender-side algorithm, the final rate is always
clipped within the dynamic range specified by the
application:[¶](#section-4.3-10){.pilcrow}

::: {#section-4.3-11 .artwork .art-text .alignLeft}
        r_ref = min(r_ref, RMAX)                         (8)

        r_ref = max(r_ref, RMIN)                         (9)

[¶](#section-4.3-11){.pilcrow}
:::

The above operations ignore many practical issues such as clock
synchronization between sender and receiver, the filtering of noise in
delay measurements, and base delay expiration. These will be addressed
in [Section
5](#sec-practical-nada){.xref}.[¶](#section-4.3-12){.pilcrow}
:::
:::
:::
:::

::: {#sec-practical-nada}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Practical Implementation of NADA](#name-practical-implementation-of){.section-name .selfRef} {#name-practical-implementation-of}

::: {#sec-receiver}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Receiver-Side Operation](#name-receiver-side-operation){.section-name .selfRef} {#name-receiver-side-operation}

The receiver continuously monitors end-to-end per-packet statistics in
terms of delay, loss, and/or ECN marking ratios. It then aggregates all
forms of congestion indicators into the form of an equivalent delay and
periodically reports this back to the sender. In addition, the receiver
tracks the receiving rate of the flow and includes that in the feedback
message.[¶](#section-5.1-1){.pilcrow}

::: {#sec-receiver-a}
::: {#section-5.1.1 .section}
#### [5.1.1.](#section-5.1.1){.section-number .selfRef} [Estimation of One-Way Delay and Queuing Delay](#name-estimation-of-one-way-delay){.section-name .selfRef} {#name-estimation-of-one-way-delay}

The delay estimation process in NADA follows an approach similar to that
of earlier delay-based congestion control schemes, such as Low Extra
Delay Background Transport (LEDBAT) \[[RFC6817](#RFC6817){.xref}\]. For
experimental implementations, instead of relying on RTP timestamps and
the transmission time offset RTP header extension
\[[RFC5450](#RFC5450){.xref}\], the NADA sender can generate its own
timestamp based on the local system clock and embed that information in
the transport packet header. The NADA receiver estimates the forward
delay as having a constant base delay component plus a time-varying
queuing delay component. The base delay is estimated as the minimum
value of one-way delay observed over a relatively long period (e.g.,
tens of minutes), whereas the individual queuing delay value is taken to
be the difference between one-way delay and base delay. By re-estimating
the base delay periodically, one can avoid the potential issue of base
delay expiration, whereby an earlier measured base delay value is no
longer valid due to underlying route changes or a cumulative timing
difference introduced by the clock-rate skew between sender and
receiver. All delay estimations are based on sender timestamps with a
recommended granularity of 100 microseconds or
finer.[¶](#section-5.1.1-1){.pilcrow}

The individual sample values of queuing delay should be further filtered
against various non-congestion-induced noise, such as spikes due to a
processing \"hiccup\" at the network nodes. Therefore, in addition to
calculating the value of queuing delay using d_queue = d_fwd - d_base,
as expressed in [Section 5.1](#sec-receiver){.xref}, the current
implementation further employs a minimum filter with a window size of 15
samples over per-packet queuing delay
values.[¶](#section-5.1.1-2){.pilcrow}
:::
:::

::: {#sec-receiver-b}
::: {#section-5.1.2 .section}
#### [5.1.2.](#section-5.1.2){.section-number .selfRef} [Estimation of Packet Loss/Marking Ratio](#name-estimation-of-packet-loss-m){.section-name .selfRef} {#name-estimation-of-packet-loss-m}

The receiver detects packet losses via gaps in the RTP sequence numbers
of received packets. For interactive real-time media applications with
stringent latency constraints (e.g., video conferencing), the receiver
avoids the packet reordering delay by treating out-of-order packets as
losses. The instantaneous packet loss ratio p_inst is estimated as the
ratio between the number of missing packets over the number of total
transmitted packets within the recent observation window LOGWIN. The
packet loss ratio p_loss is obtained after exponential
smoothing:[¶](#section-5.1.2-1){.pilcrow}

::: {#section-5.1.2-2 .artwork .art-text .alignLeft}
        
                p_loss = ALPHA*p_inst + (1-ALPHA)*p_loss        (10)
                

[¶](#section-5.1.2-2){.pilcrow}
:::

The filtered result is reported back to the sender as the observed
packet loss ratio p_loss.[¶](#section-5.1.2-3){.pilcrow}

The estimation of the packet marking ratio p_mark follows the same
procedure as above. It is assumed that ECN marking information at the IP
header can be passed to the receiving endpoint, e.g., by following the
mechanism described in
\[[RFC6679](#RFC6679){.xref}\].[¶](#section-5.1.2-4){.pilcrow}
:::
:::

::: {#sec-receiver-c}
::: {#section-5.1.3 .section}
#### [5.1.3.](#section-5.1.3){.section-number .selfRef} [Estimation of Receiving Rate](#name-estimation-of-receiving-rat){.section-name .selfRef} {#name-estimation-of-receiving-rat}

It is fairly straightforward to estimate the receiving rate r_recv. NADA
maintains a recent observation window with a time span of LOGWIN and
simply divides the total size of packets arriving during that window
over the time span. The receiving rate (r_recv) can be either calculated
at the sender side based on the per-packet feedback from the receiver or
included as part of the feedback report.[¶](#section-5.1.3-1){.pilcrow}
:::
:::
:::
:::

::: {#sec-sender}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Sender-Side Operation](#name-sender-side-operation){.section-name .selfRef} {#name-sender-side-operation}

[Figure 2](#fig-nada-sender){.xref} provides a detailed view of the NADA
sender. Upon receipt of an RTCP feedback report from the receiver, the
NADA sender calculates the reference rate r_ref as specified in [Section
4.3](#subsec-sender-algorithm){.xref}. It further adjusts both the
target rate for the live video encoder r_vin and the sending rate r_send
over the network based on the updated value of r_ref and rate-shaping
buffer occupancy buffer_len.[¶](#section-5.2-1){.pilcrow}

The NADA sender behavior stays the same in the presence of all types of
congestion indicators: delay, loss, and ECN marking. This unified
approach allows a graceful transition of the scheme as the network
shifts dynamically between light and heavy congestion
levels.[¶](#section-5.2-2){.pilcrow}

[]{#name-nada-sender-structure}

::: {#fig-nada-sender}
::: {#section-5.2-3.1 .artwork .art-text .alignLeft}
                       +----------------+             
                       |  Calculate     | <---- RTCP report
                       | Reference Rate | 
                       -----------------+
                               | r_ref
                  +------------+-------------+
                  |                          |
                 \|/                        \|/
          +-----------------+           +---------------+
          | Calculate Video |           |   Calculate   |
          |  Target Rate    |           | Sending Rate  |
          +-----------------+           +---------------+
              |        /|\                 /|\      |   
        r_vin |         |                   |       |
             \|/        +-------------------+       |       
          +----------+          | buffer_len        |  r_send
          |  Video   | r_vout  -----------+        \|/
          |  Encoder |-------->   |||||||||=================>  
          +----------+         -----------+    RTP packets     
          Rate-Shaping Buffer         
:::

[Figure 2](#figure-2){.selfRef}: [NADA Sender
Structure](#name-nada-sender-structure){.selfRef}
:::

::: {#sec-sender-c}
::: {#section-5.2.1 .section}
#### [5.2.1.](#section-5.2.1){.section-number .selfRef} [Rate-Shaping Buffer](#name-rate-shaping-buffer){.section-name .selfRef} {#name-rate-shaping-buffer}

The operation of the live video encoder is out of the scope of the
design for the congestion control scheme in NADA. Instead, its behavior
is treated as a black box.[¶](#section-5.2.1-1){.pilcrow}

A rate-shaping buffer is employed to absorb any instantaneous mismatch
between the encoder rate output r_vout and the regulated sending rate
r_send. Its current level of occupancy is measured in bytes and is
denoted as buffer_len.[¶](#section-5.2.1-2){.pilcrow}

A large rate-shaping buffer contributes to higher end-to-end delay,
which may harm the performance of real-time media communications.
Therefore, the sender has a strong incentive to prevent the rate-shaping
buffer from building up. The mechanisms adopted
are:[¶](#section-5.2.1-3){.pilcrow}

-   [To deplete the rate-shaping buffer faster by increasing the sending
    rate r_send;
    and[¶](#section-5.2.1-4.1){.pilcrow}]{#section-5.2.1-4.1}
-   [To limit incoming packets of the rate-shaping buffer by reducing
    the video encoder target rate
    r_vin.[¶](#section-5.2.1-4.2){.pilcrow}]{#section-5.2.1-4.2}
:::
:::

::: {#sec-sender-d}
::: {#section-5.2.2 .section}
#### [5.2.2.](#section-5.2.2){.section-number .selfRef} [Adjusting Video Target Rate and Sending Rate](#name-adjusting-video-target-rate){.section-name .selfRef} {#name-adjusting-video-target-rate}

If the level of occupancy in the rate-shaping buffer is accessible at
the sender, such information can be leveraged to further adjust the
target rate of the live video encoder r_vin as well as the actual
sending rate r_send. The purpose of such adjustments is to mitigate the
additional latencies introduced by the rate-shaping buffer. The amount
of rate adjustment can be calculated as
follows:[¶](#section-5.2.2-1){.pilcrow}

::: {#section-5.2.2-2 .artwork .art-text .alignLeft}
        r_diff_v = min(0.05*r_ref, BETA_V*8*buffer_len*FPS)     (11) 
        r_diff_s = min(0.05*r_ref, BETA_S*8*buffer_len*FPS)     (12) 
        r_vin  = max(RMIN, r_ref - r_diff_v)                    (13) 
        r_send = min(RMAX, r_ref + r_diff_s)                    (14)

[¶](#section-5.2.2-2){.pilcrow}
:::

In Equations (11) and (12), the amount of adjustment is calculated as
proportional to the size of the rate-shaping buffer but is bounded by 5%
of the reference rate r_ref calculated from network congestion feedback
alone. This ensures that the adjustment introduced by the rate-shaping
buffer will not counteract with the core congestion control process.
Equations (13) and (14) indicate the influence of the rate-shaping
buffer. A large rate-shaping buffer nudges the encoder target rate
slightly below (and the sending rate slightly above) the reference rate
r_ref. The final video target rate (r_vin) and sending rate (r_send) are
further bounded within the original range of \[RMIN,
RMAX\].[¶](#section-5.2.2-3){.pilcrow}

Intuitively, the amount of extra rate offset needed to completely drain
the rate-shaping buffer within the duration of a single video frame is
given by 8\*buffer_len\*FPS, where FPS stands for the reference frame
rate of the video. The scaling parameters BETA_V and BETA_S can be tuned
to balance between the competing goals of maintaining a small
rate-shaping buffer and deviating from the reference rate point.
Empirical observations show that the rate-shaping buffer for a
responsive live video encoder typically stays empty and only
occasionally holds a large frame (e.g., when an intra-frame is produced)
in transit. Therefore, the rate adjustment introduced by this mechanism
is expected to be minor. For instance, a rate-shaping buffer of 2000
bytes will lead to a rate adjustment of 48 Kbps given the recommended
scaling parameters of BETA_V = 0.1 and BETA_S = 0.1, and the reference
frame rate of FPS = 30.[¶](#section-5.2.2-4){.pilcrow}
:::
:::
:::
:::

::: {#sec-feedback}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Feedback Message Requirements](#name-feedback-message-requiremen){.section-name .selfRef} {#name-feedback-message-requiremen}

The following list of information is required for NADA congestion
control to function properly:[¶](#section-5.3-1){.pilcrow}

Recommended rate adaptation mode (rmode):
:   A 1-bit flag indicating whether the sender should operate in
    accelerated ramp-up mode (rmode=0) or gradual update mode
    (rmode=1).[¶](#section-5.3-2.2){.pilcrow}

Aggregated congestion signal (x_curr):
:   The most recently updated value, calculated by the receiver
    according to [Section 4.2](#subsec-receiver-algorithm){.xref}. This
    information can be expressed with a unit of 100 microseconds (i.e.,
    1/10 of a millisecond) in 15 bits. This allows a maximum value of
    x_curr at approximately 3.27 seconds.[¶](#section-5.3-2.4){.pilcrow}

Receiving rate (r_recv):
:   The most recently measured receiving rate according to [Section
    5.1.3](#sec-receiver-c){.xref}. This information is expressed with a
    unit of bits per second (bps) in 32 bits (unsigned int). This allows
    a maximum rate of approximately 4.3 Gbps, approximately 1000 times
    the streaming rate of a typical high-definition (HD) video
    conferencing session today. This field can be expanded further by a
    few more bytes if an even higher rate needs to be
    specified.[¶](#section-5.3-2.6){.pilcrow}

The above list of information can be accommodated by 48 bits, or 6
bytes, in total. They can be either included in the feedback report from
the receiver or, in the case where all receiver-side calculations are
moved to the sender, derived from per-packet information from the
feedback message as defined in
\[[RTCP-FEEDBACK](#I-D.ietf-avtcore-cc-feedback-message){.xref}\].
Choosing the feedback message interval DELTA is discussed in [Section
6.3](#sec-discussion-c){.xref}. A target feedback interval of DELTA =
100 ms is recommended.[¶](#section-5.3-3){.pilcrow}
:::
:::
:::
:::

::: {#sec-discussions}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Discussions and Further Investigations](#name-discussions-and-further-inv){.section-name .selfRef} {#name-discussions-and-further-inv}

This section discusses the various design choices made by NADA,
potential alternative variants of its implementation, and guidelines on
how the key algorithm parameters can be chosen. [Section
8](#sec-experiments){.xref} recommends additional experimental setups to
further explore these topics.[¶](#section-6-1){.pilcrow}

::: {#sec-discussion-a}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Choice of Delay Metrics](#name-choice-of-delay-metrics){.section-name .selfRef} {#name-choice-of-delay-metrics}

The current design works with relative one-way delay (OWD) as the main
indication of congestion. The value of the relative OWD is obtained by
maintaining the minimum value of observed OWD over a relatively long
time horizon and subtracting that out from the observed absolute OWD
value. Such an approach cancels out the fixed difference between the
sender and receiver clocks. It has been widely adopted by other
delay-based congestion control approaches such as
\[[RFC6817](#RFC6817){.xref}\]. As discussed in
\[[RFC6817](#RFC6817){.xref}\], the time horizon for tracking the
minimum OWD needs to be chosen with care; it must be long enough for an
opportunity to observe the minimum OWD with zero standing queue along
the path, and it must be sufficiently short enough to timely reflect
\"true\" changes in minimum OWD introduced by route changes and other
rare events and to mitigate the cumulative impact of clock rate skew
over time.[¶](#section-6.1-1){.pilcrow}

The potential drawback in relying on relative OWD as the congestion
signal is that when multiple flows share the same bottleneck, the flow
arriving late at the network experiencing a non-empty queue may
mistakenly consider the standing queuing delay as part of the fixed path
propagation delay. This will lead to slightly unfair bandwidth sharing
among the flows.[¶](#section-6.1-2){.pilcrow}

Alternatively, one could move the per-packet statistical handling to the
sender instead and use relative round-trip time (RTT) in lieu of
relative OWD, assuming that per-packet acknowledgments are available.
The main drawback of an RTT-based approach is the noise in the measured
delay in the reverse direction.[¶](#section-6.1-3){.pilcrow}

Note that the choice of either delay metric (relative OWD vs. RTT)
involves no change in the proposed rate adaptation algorithm. Therefore,
comparing the pros and cons regarding which delay metric to adopt can be
kept as an orthogonal direction of
investigation.[¶](#section-6.1-4){.pilcrow}
:::
:::

::: {#sec-discussion-b}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Method for Delay, Loss, and Marking Ratio Estimation](#name-method-for-delay-loss-and-m){.section-name .selfRef} {#name-method-for-delay-loss-and-m}

Like other delay-based congestion control schemes, performance of NADA
depends on the accuracy of its delay measurement and estimation module.
[Appendix A](https://www.rfc-editor.org/rfc/rfc6817#appendix-A){.relref}
of \[[RFC6817](#RFC6817){.xref}\] provides an extensive discussion on
this aspect.[¶](#section-6.2-1){.pilcrow}

The current recommended practice of applying minimum filter with a
window size of 15 samples suffices in guarding against processing delay
outliers observed in wired connections. For wireless connections with a
higher packet delay variation (PDV), more sophisticated techniques on
denoising, outlier rejection, and trend analysis may be
needed.[¶](#section-6.2-2){.pilcrow}

More sophisticated methods in packet loss ratio calculation, such as
that adopted by \[[FLOYD-CCR00](#FLOYD-CCR00){.xref}\], will likely be
beneficial. These alternatives are part of the experiments this document
proposes.[¶](#section-6.2-3){.pilcrow}
:::
:::

::: {#sec-discussion-c}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Impact of Parameter Values](#name-impact-of-parameter-values){.section-name .selfRef} {#name-impact-of-parameter-values}

In the gradual rate update mode, the parameter TAU indicates the upper
bound of round-trip time (RTT) in the feedback control loop. Typically,
the observed feedback interval delta is close to the target feedback
interval DELTA, and the relative ratio of delta/TAU versus ETA dictates
the relative strength of influence from the aggregate congestion signal
offset term (x_offset) versus its recent change (x_diff), respectively.
These two terms are analogous to the integral and proportional terms in
a proportional-integral (PI) controller. The recommended choice of TAU =
500 ms, DELTA = 100 ms, and ETA = 2.0 corresponds to a relative ratio of
1:10 between the gains of the integral and proportional terms.
Consequently, the rate adaptation is mostly driven by the change in the
congestion signal with a long-term shift towards its equilibrium value
driven by the offset term. Finally, the scaling parameter KAPPA
determines the overall speed of the adaptation and needs to strike a
balance between responsiveness and
stability.[¶](#section-6.3-1){.pilcrow}

The choice of the target feedback interval DELTA needs to strike the
right balance between timely feedback and low RTCP feedback message
counts. A target feedback interval of DELTA = 100 ms is recommended,
corresponding to a feedback bandwidth of 16 Kbps with 200 bytes per
feedback message \-- approximately 1.6% overhead for a 1 Mbps flow.
Furthermore, both simulation studies and frequency-domain analysis in
\[[IETF-95](#IETF-95){.xref}\] have established that a feedback interval
below 250 ms (i.e., more frequently than 4 feedback messages per second)
will not break up the feedback control loop of NADA congestion
control.[¶](#section-6.3-2){.pilcrow}

In calculating the non-linear warping of delay in Equation (1), the
current design uses fixed values of QTH for determining whether to
perform the non-linear warping. Its value should be carefully tuned for
different operational environments (e.g., over wired vs. wireless
connections) so as to avoid the potential risk of prematurely
discounting the congestion signal level. It is possible to adapt its
value based on past observed patterns of queuing delay in the presence
of packet losses. It needs to be noted that the non-linear warping
mechanism may lead to multiple NADA streams stuck in loss-based mode
when competing against each other.[¶](#section-6.3-3){.pilcrow}

In calculating the aggregate congestion signal x_curr, the choice of
DMARK and DLOSS influence the steady-state packet loss/marking ratio
experienced by the flow at a given available bandwidth. Higher values of
DMARK and DLOSS result in lower steady-state loss/marking ratios but are
more susceptible to the impact of individual packet loss/marking events.
While the value of DMARK and DLOSS are fixed and predetermined in the
current design, this document also encourages further explorations of a
scheme for automatically tuning these values based on desired bandwidth
sharing behavior in the presence of other competing loss-based flows
(e.g., loss-based TCP).[¶](#section-6.3-4){.pilcrow}
:::
:::

::: {#sec-discussion-d}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [Sender-Based vs. Receiver-Based Calculation](#name-sender-based-vs-receiver-ba){.section-name .selfRef} {#name-sender-based-vs-receiver-ba}

In the current design, the aggregated congestion signal x_curr is
calculated at the receiver, keeping the sender operation completely
independent of the form of actual network congestion indications (delay,
loss, or marking) in use.[¶](#section-6.4-1){.pilcrow}

Alternatively, one can shift receiver-side calculations to the sender,
whereby the receiver simply reports on per-packet information via
periodic feedback messages as defined in
\[[RTCP-FEEDBACK](#I-D.ietf-avtcore-cc-feedback-message){.xref}\]. Such
an approach enables interoperability amongst senders operating on
different congestion control schemes but requires slightly higher
overhead in the feedback messages. See additional discussions in
\[[RTCP-FEEDBACK](#I-D.ietf-avtcore-cc-feedback-message){.xref}\]
regarding the desired format of the feedback messages and the
recommended feedback intervals.[¶](#section-6.4-2){.pilcrow}
:::
:::

::: {#sec-discussion-e}
::: {#section-6.5 .section}
### [6.5.](#section-6.5){.section-number .selfRef} [Incremental Deployment](#name-incremental-deployment){.section-name .selfRef} {#name-incremental-deployment}

One nice property of NADA is the consistent video endpoint behavior
irrespective of network node variations. This facilitates gradual,
incremental adoption of the scheme.[¶](#section-6.5-1){.pilcrow}

Initially, the proposed congestion control mechanism can be implemented
without any explicit support from the network and relies solely on
observed relative one-way delay measurements and packet loss ratios as
implicit congestion signals.[¶](#section-6.5-2){.pilcrow}

When ECN is enabled at the network nodes with RED-based marking, the
receiver can fold its observations of ECN markings into the calculation
of the equivalent delay. The sender can react to these explicit
congestion signals without any
modification.[¶](#section-6.5-3){.pilcrow}

Ultimately, networks equipped with proactive marking based on the level
of token bucket metering can reap the additional benefits of zero
standing queues and lower end-to-end delay and work seamlessly with
existing senders and receivers.[¶](#section-6.5-4){.pilcrow}
:::
:::
:::
:::

::: {#sec-implementations}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Reference Implementations](#name-reference-implementations){.section-name .selfRef} {#name-reference-implementations}

The NADA scheme has been implemented in both ns-2
\[[NS-2](#NS-2){.xref}\] and ns-3 \[[NS-3](#NS-3){.xref}\] simulation
platforms. The implementation in ns-2 hosts the calculations as
described in [Section 4.2](#subsec-receiver-algorithm){.xref} at the
receiver side, whereas the implementation in ns-3 hosts these
receiver-side calculations at the sender for the sake of
interoperability. Extensive ns-2 simulation evaluations of an earlier
draft version of this document are recorded in
\[[ZHU-PV13](#ZHU-PV13){.xref}\]. An open-source implementation of NADA
as part of an ns-3 module is available at
\[[NS3-RMCAT](#NS3-RMCAT){.xref}\]. Evaluation results of this document
based on ns-3 are presented in \[[IETF-90](#IETF-90){.xref}\] and
\[[IETF-91](#IETF-91){.xref}\] for wired test cases as documented in
\[[RMCAT-EVAL-TEST](#I-D.ietf-rmcat-eval-test){.xref}\]. Evaluation
results of NADA over Wi-Fi-based test cases as defined in
\[[WIRELESS-TESTS](#I-D.ietf-rmcat-wireless-tests){.xref}\] are
presented in \[[IETF-93](#IETF-93){.xref}\]. These simulation-based
evaluations have shown that NADA flows can obtain their fair share of
bandwidth when competing against each other. They typically adapt fast
in reaction to the arrival and departure of other flows and can sustain
a reasonable throughput when competing against loss-based TCP
flows.[¶](#section-7-1){.pilcrow}

\[[IETF-90](#IETF-90){.xref}\] describes the implementation and
evaluation of NADA in a lab setting. Preliminary evaluation results of
NADA in single-flow and multi-flow test scenarios are presented in
\[[IETF-91](#IETF-91){.xref}\].[¶](#section-7-2){.pilcrow}

A reference implementation of NADA has been carried out by modifying the
WebRTC module embedded in the Mozilla open-source browser. Presentations
from \[[IETF-103](#IETF-103){.xref}\] and
\[[IETF-105](#IETF-105){.xref}\] document real-world evaluations of the
modified browser driven by NADA. The experimental setting involves
remote connections with endpoints over either home or enterprise
wireless networks. These evaluations validate the effectiveness of NADA
flows in recovering quickly from throughput drops caused by intermittent
delay spikes over the last-hop wireless
connections.[¶](#section-7-3){.pilcrow}
:::
:::

::: {#sec-experiments}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Suggested Experiments](#name-suggested-experiments){.section-name .selfRef} {#name-suggested-experiments}

NADA has been extensively evaluated under various test scenarios,
including the collection of test cases specified by
\[[RMCAT-EVAL-TEST](#I-D.ietf-rmcat-eval-test){.xref}\] and the subset
of Wi-Fi-based test cases in
\[[WIRELESS-TESTS](#I-D.ietf-rmcat-wireless-tests){.xref}\]. Additional
evaluations have been carried out to characterize how NADA interacts
with various AQM schemes such as RED, Controlling Queue Delay (CoDel),
and Proportional Integral Controller Enhanced (PIE). Most of these
evaluations have been carried out in simulators. A few key test cases
have been evaluated in lab environments with implementations embedded in
video conferencing clients. It is strongly recommended to carry out
implementation and experimentation of NADA in real-world settings. Such
exercises will provide insights on how to choose or automatically adapt
the values of the key algorithm parameters (see list in [Table
2](#tab-parameters){.xref}) as discussed in [Section
6](#sec-discussions){.xref}.[¶](#section-8-1){.pilcrow}

Additional experiments are suggested for the following scenarios,
preferably over real-world networks:[¶](#section-8-2){.pilcrow}

-   [Experiments reflecting the setup of a typical WAN
    connection.[¶](#section-8-3.1){.pilcrow}]{#section-8-3.1}
-   [Experiments with ECN marking capability turned on at the network
    for existing test
    cases.[¶](#section-8-3.2){.pilcrow}]{#section-8-3.2}
-   [Experiments with multiple NADA streams bearing different
    user-specified
    priorities.[¶](#section-8-3.3){.pilcrow}]{#section-8-3.3}
-   [Experiments with additional access technologies, especially over
    cellular networks such as
    3G/LTE.[¶](#section-8-3.4){.pilcrow}]{#section-8-3.4}
-   [Experiments with various media source contents, including audio
    only, audio and video, and application content sharing (e.g.,
    slideshows).[¶](#section-8-3.5){.pilcrow}]{#section-8-3.5}
:::
:::

::: {#sec-iana}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-9-1){.pilcrow}
:::
:::

::: {#sec-security}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

The rate adaptation mechanism in NADA relies on feedback from the
receiver. As such, it is vulnerable to attacks where feedback messages
are hijacked, replaced, or intentionally injected with misleading
information resulting in denial of service, similar to those that can
affect TCP. Therefore, it is [RECOMMENDED]{.bcp14} that the RTCP
feedback message is at least integrity checked. In addition,
\[[RTCP-FEEDBACK](#I-D.ietf-avtcore-cc-feedback-message){.xref}\]
discusses the potential risk of a receiver providing misleading
congestion feedback information and the mechanisms for mitigating such
risks.[¶](#section-10-1){.pilcrow}

The modification of the sending rate based on the sender-side
rate-shaping buffer may lead to temporary excessive congestion over the
network in the presence of an unresponsive video encoder. However, this
effect can be mitigated by limiting the amount of rate modification
introduced by the rate-shaping buffer, bounding the size of the
rate-shaping buffer at the sender, and maintaining a maximum allowed
sending rate by NADA.[¶](#section-10-2){.pilcrow}
:::
:::

::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-11.1 .section}
### [11.1.](#section-11.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.

\[RFC3168\]
:   [Ramakrishnan, K.]{.refAuthor}[, Floyd, S.]{.refAuthor}[, and D.
    Black]{.refAuthor}, [\"The Addition of Explicit Congestion
    Notification (ECN) to IP\"]{.refTitle}, [RFC 3168]{.seriesInfo},
    [DOI 10.17487/RFC3168]{.seriesInfo}, September 2001,
    \<<https://www.rfc-editor.org/info/rfc3168>\>.

\[RFC3550\]
:   [Schulzrinne, H.]{.refAuthor}[, Casner, S.]{.refAuthor}[,
    Frederick, R.]{.refAuthor}[, and V. Jacobson]{.refAuthor}, [\"RTP: A
    Transport Protocol for Real-Time Applications\"]{.refTitle}, [STD
    64]{.seriesInfo}, [RFC 3550]{.seriesInfo}, [DOI
    10.17487/RFC3550]{.seriesInfo}, July 2003,
    \<<https://www.rfc-editor.org/info/rfc3550>\>.

\[RFC5348\]
:   [Floyd, S.]{.refAuthor}[, Handley, M.]{.refAuthor}[,
    Padhye, J.]{.refAuthor}[, and J. Widmer]{.refAuthor}, [\"TCP
    Friendly Rate Control (TFRC): Protocol Specification\"]{.refTitle},
    [RFC 5348]{.seriesInfo}, [DOI 10.17487/RFC5348]{.seriesInfo},
    September 2008, \<<https://www.rfc-editor.org/info/rfc5348>\>.

\[RFC6679\]
:   [Westerlund, M.]{.refAuthor}[, Johansson, I.]{.refAuthor}[,
    Perkins, C.]{.refAuthor}[, O\'Hanlon, P.]{.refAuthor}[, and K.
    Carlberg]{.refAuthor}, [\"Explicit Congestion Notification (ECN) for
    RTP over UDP\"]{.refTitle}, [RFC 6679]{.seriesInfo}, [DOI
    10.17487/RFC6679]{.seriesInfo}, August 2012,
    \<<https://www.rfc-editor.org/info/rfc6679>\>.

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:::

::: {#section-11.2 .section}
### [11.2.](#section-11.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[BUDZISZ-AIMD-CC\]
:   [Budzisz, L.]{.refAuthor}[, Stanojevic, R.]{.refAuthor}[,
    Schlote, A.]{.refAuthor}[, Baker, F.]{.refAuthor}[, and R.
    Shorten]{.refAuthor}, [\"On the Fair Coexistence of Loss- and
    Delay-Based TCP\"]{.refTitle}, [IEEE/ACM Transactions on Networking,
    vol. 19, no. 6, pp. 1811-1824 ]{.refContent}, [DOI
    10.1109/TNET.2011.2159736]{.seriesInfo}, December 2011,
    \<<https://doi.org/10.1109/TNET.2011.2159736>\>.

\[FLOYD-CCR00\]
:   [Floyd, S.]{.refAuthor}[, Handley, M.]{.refAuthor}[,
    Padhye, J.]{.refAuthor}[, and J. Widmer]{.refAuthor},
    [\"Equation-based congestion control for unicast
    applications\"]{.refTitle}, [ACM SIGCOMM Computer Communications
    Review, vol. 30, no. 4, pp. 43-56 ]{.refContent}, [DOI
    10.1145/347057.347397]{.seriesInfo}, October 2000,
    \<<https://doi.org/10.1145/347057.347397>\>.

\[IETF-103\]
:   [Zhu, X.]{.refAuthor}[, Pan, R.]{.refAuthor}[,
    Ramalho, M.]{.refAuthor}[, Mena, S.]{.refAuthor}[,
    Jones, P.]{.refAuthor}[, Fu, J.]{.refAuthor}[, and S.
    D\'Aronco]{.refAuthor}, [\"NADA Implementation in Mozilla
    Browser\"]{.refTitle}, [IETF 103 ]{.refContent}, November 2018,
    \<<https://datatracker.ietf.org/meeting/103/materials/slides-103-rmcat-nada-implementation-in-mozilla-browser-00>\>.

\[IETF-105\]
:   [Zhu, X.]{.refAuthor}[, Pan, R.]{.refAuthor}[,
    Ramalho, M.]{.refAuthor}[, Mena, S.]{.refAuthor}[,
    Jones, P.]{.refAuthor}[, Fu, J.]{.refAuthor}[, and S.
    D\'Aronco]{.refAuthor}, [\"NADA Implementation in Mozilla Browser
    and Draft Update\"]{.refTitle}, [IETF 105 ]{.refContent}, July 2019,
    \<<https://datatracker.ietf.org/meeting/105/materials/slides-105-rmcat-nada-update-02.pdf>\>.

\[IETF-90\]
:   [Zhu, X.]{.refAuthor}[, Ramalho, M.]{.refAuthor}[,
    Ganzhorn, C.]{.refAuthor}[, Jones, P.]{.refAuthor}[, and R.
    Pan]{.refAuthor}, [\"NADA Update: Algorithm, Implementation, and
    Test Case Evaluation Results\"]{.refTitle}, [IETF 90 ]{.refContent},
    July 2014,
    \<<https://tools.ietf.org/agenda/90/slides/slides-90-rmcat-6.pdf>\>.

\[IETF-91\]
:   [Zhu, X.]{.refAuthor}[, Pan, R.]{.refAuthor}[,
    Ramalho, M.]{.refAuthor}[, Mena, S.]{.refAuthor}[,
    Ganzhorn, C.]{.refAuthor}[, Jones, P.]{.refAuthor}[, and S.
    D\'Aronco]{.refAuthor}, [\"NADA Algorithm Update and Test Case
    Evaluations\"]{.refTitle}, [IETF 91 ]{.refContent}, November 2014,
    \<<https://www.ietf.org/proceedings/interim/2014/11/09/rmcat/slides/slides-interim-2014-rmcat-1-2.pdf>\>.

\[IETF-93\]
:   [Zhu, X.]{.refAuthor}[, Pan, R.]{.refAuthor}[,
    Ramalho, M.]{.refAuthor}[, Mena, S.]{.refAuthor}[,
    Ganzhorn, C.]{.refAuthor}[, Jones, P.]{.refAuthor}[,
    D\'Aronco, S.]{.refAuthor}[, and J. Fu]{.refAuthor}, [\"Updates on
    NADA\"]{.refTitle}, [IETF 93 ]{.refContent}, July 2015,
    \<<https://www.ietf.org/proceedings/93/slides/slides-93-rmcat-0.pdf>\>.

\[IETF-95\]
:   [Zhu, X.]{.refAuthor}[, Pan, R.]{.refAuthor}[,
    Ramalho, M.]{.refAuthor}[, Mena, S.]{.refAuthor}[,
    Jones, P.]{.refAuthor}[, Fu, J.]{.refAuthor}[,
    D\'Aronco, S.]{.refAuthor}[, and C. Ganzhorn]{.refAuthor},
    [\"Updates on NADA: Stability Analysis and Impact of Feedback
    Intervals\"]{.refTitle}, [IETF 95 ]{.refContent}, April 2016,
    \<<https://www.ietf.org/proceedings/95/slides/slides-95-rmcat-5.pdf>\>.

\[NS-2\]
:   [\"ns-2\"]{.refTitle}, December 2014,
    \<<http://nsnam.sourceforge.net/wiki/index.php/Main_Page>\>.

\[NS-3\]
:   [\"ns-3 Network Simulator\"]{.refTitle},
    \<<https://www.nsnam.org/>\>.

\[NS3-RMCAT\]
:   [Fu, J.]{.refAuthor}[, Mena, S.]{.refAuthor}[, and X.
    Zhu]{.refAuthor}, [\"Simulator of IETF RMCAT congestion control
    protocols\"]{.refTitle}, November 2017,
    \<<https://github.com/cisco/ns3-rmcat>\>.

\[RFC5450\]
:   [Singer, D.]{.refAuthor}[ and H. Desineni]{.refAuthor},
    [\"Transmission Time Offsets in RTP Streams\"]{.refTitle}, [RFC
    5450]{.seriesInfo}, [DOI 10.17487/RFC5450]{.seriesInfo}, March 2009,
    \<<https://www.rfc-editor.org/info/rfc5450>\>.

\[RFC6660\]
:   [Briscoe, B.]{.refAuthor}[, Moncaster, T.]{.refAuthor}[, and M.
    Menth]{.refAuthor}, [\"Encoding Three Pre-Congestion Notification
    (PCN) States in the IP Header Using a Single Diffserv Codepoint
    (DSCP)\"]{.refTitle}, [RFC 6660]{.seriesInfo}, [DOI
    10.17487/RFC6660]{.seriesInfo}, July 2012,
    \<<https://www.rfc-editor.org/info/rfc6660>\>.

\[RFC6817\]
:   [Shalunov, S.]{.refAuthor}[, Hazel, G.]{.refAuthor}[,
    Iyengar, J.]{.refAuthor}[, and M. Kuehlewind]{.refAuthor}, [\"Low
    Extra Delay Background Transport (LEDBAT)\"]{.refTitle}, [RFC
    6817]{.seriesInfo}, [DOI 10.17487/RFC6817]{.seriesInfo}, December
    2012, \<<https://www.rfc-editor.org/info/rfc6817>\>.

\[RFC7567\]
:   [Baker, F., Ed.]{.refAuthor}[ and G. Fairhurst, Ed.]{.refAuthor},
    [\"IETF Recommendations Regarding Active Queue
    Management\"]{.refTitle}, [BCP 197]{.seriesInfo}, [RFC
    7567]{.seriesInfo}, [DOI 10.17487/RFC7567]{.seriesInfo}, July 2015,
    \<<https://www.rfc-editor.org/info/rfc7567>\>.

\[RFC8033\]
:   [Pan, R.]{.refAuthor}[, Natarajan, P.]{.refAuthor}[,
    Baker, F.]{.refAuthor}[, and G. White]{.refAuthor}, [\"Proportional
    Integral Controller Enhanced (PIE): A Lightweight Control Scheme to
    Address the Bufferbloat Problem\"]{.refTitle}, [RFC
    8033]{.seriesInfo}, [DOI 10.17487/RFC8033]{.seriesInfo}, February
    2017, \<<https://www.rfc-editor.org/info/rfc8033>\>.

\[RFC8290\]
:   [Hoeiland-Joergensen, T.]{.refAuthor}[, McKenney, P.]{.refAuthor}[,
    Taht, D.]{.refAuthor}[, Gettys, J.]{.refAuthor}[, and E.
    Dumazet]{.refAuthor}, [\"The Flow Queue CoDel Packet Scheduler and
    Active Queue Management Algorithm\"]{.refTitle}, [RFC
    8290]{.seriesInfo}, [DOI 10.17487/RFC8290]{.seriesInfo}, January
    2018, \<<https://www.rfc-editor.org/info/rfc8290>\>.

\[RFC8593\]
:   [Zhu, X.]{.refAuthor}[, Mena, S.]{.refAuthor}[, and Z.
    Sarker]{.refAuthor}, [\"Video Traffic Models for RTP Congestion
    Control Evaluations\"]{.refTitle}, [RFC 8593]{.seriesInfo}, [DOI
    10.17487/RFC8593]{.seriesInfo}, May 2019,
    \<<https://www.rfc-editor.org/info/rfc8593>\>.

\[RMCAT-CC\]
:   [Jesup, R.]{.refAuthor}[ and Z. Sarker]{.refAuthor}, [\"Congestion
    Control Requirements for Interactive Real-Time Media\"]{.refTitle},
    [Work in Progress]{.refContent}, [Internet-Draft,
    draft-ietf-rmcat-cc-requirements-09]{.seriesInfo}, 12 December 2014,
    \<<https://tools.ietf.org/html/draft-ietf-rmcat-cc-requirements-09>\>.

\[RMCAT-CC-RTP\]
:   [Zanaty, M.]{.refAuthor}[, Singh, V.]{.refAuthor}[,
    Nandakumar, S.]{.refAuthor}[, and Z. Sarker]{.refAuthor},
    [\"Congestion Control and Codec interactions in RTP
    Applications\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft,
    draft-ietf-rmcat-cc-codec-interactions-02]{.seriesInfo}, 18 March
    2016,
    \<<https://tools.ietf.org/html/draft-ietf-rmcat-cc-codec-interactions-02>\>.

\[RMCAT-EVAL-TEST\]
:   [Sarker, Z.]{.refAuthor}[, Singh, V.]{.refAuthor}[,
    Zhu, X.]{.refAuthor}[, and M. Ramalho]{.refAuthor}, [\"Test Cases
    for Evaluating RMCAT Proposals\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-rmcat-eval-test-10]{.seriesInfo}, 23 May 2019,
    \<<https://tools.ietf.org/html/draft-ietf-rmcat-eval-test-10>\>.

\[RTCP-FEEDBACK\]
:   [Sarker, Z.]{.refAuthor}[, Perkins, C.]{.refAuthor}[,
    Singh, V.]{.refAuthor}[, and M. Ramalho]{.refAuthor}, [\"RTP Control
    Protocol (RTCP) Feedback for Congestion Control\"]{.refTitle}, [Work
    in Progress]{.refContent}, [Internet-Draft,
    draft-ietf-avtcore-cc-feedback-message-05]{.seriesInfo}, 4 November
    2019,
    \<<https://tools.ietf.org/html/draft-ietf-avtcore-cc-feedback-message-05>\>.

\[WIRELESS-TESTS\]
:   [Sarker, Z.]{.refAuthor}[, Johansson, I.]{.refAuthor}[,
    Zhu, X.]{.refAuthor}[, Fu, J.]{.refAuthor}[, Tan, W.]{.refAuthor}[,
    and M. Ramalho]{.refAuthor}, [\"Evaluation Test Cases for
    Interactive Real-Time Media over Wireless Networks\"]{.refTitle},
    [Work in Progress]{.refContent}, [Internet-Draft,
    draft-ietf-rmcat-wireless-tests-08]{.seriesInfo}, 5 July 2019,
    \<<https://tools.ietf.org/html/draft-ietf-rmcat-wireless-tests-08>\>.

\[ZHU-PV13\]
:   [Zhu, X.]{.refAuthor}[ and R. Pan]{.refAuthor}, [\"NADA: A Unified
    Congestion Control Scheme for Low-Latency Interactive
    Video\"]{.refTitle}, [Proc. IEEE International Packet Video
    Workshop, San Jose, CA, USA ]{.refContent}, [DOI
    10.1109/PV.2013.6691448]{.seriesInfo}, December 2013,
    \<<https://doi.org/10.1109/PV.2013.6691448>\>.
:::
:::

::: {#sec-network-nodes}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Network Node Operations](#name-network-node-operations){.section-name .selfRef} {#name-network-node-operations}

NADA can work with different network queue management schemes and does
not assume any specific network node operation. As an example, this
appendix describes three variants of queue management behavior at the
network node, leading to either implicit or explicit congestion signals.
It needs to be acknowledged that NADA has not yet been tested with
non-probabilistic ECN marking
behaviors.[¶](#section-appendix.a-1){.pilcrow}

In all three flavors described below, the network queue operates with
the simple First In, First Out (FIFO) principle. There is no need to
maintain per-flow state. The system can scale easily with a large number
of video flows and at high link
capacity.[¶](#section-appendix.a-2){.pilcrow}

::: {#sec-network-droptail}
::: {#section-a.1 .section}
## [A.1.](#section-a.1){.section-number .selfRef} [Default Behavior of Drop-Tail Queues](#name-default-behavior-of-drop-ta){.section-name .selfRef} {#name-default-behavior-of-drop-ta}

In a conventional network with drop-tail or RED queues, congestion is
inferred from the estimation of end-to-end delay and/or packet loss.
Packet drops at the queue are detected at the receiver and contribute to
the calculation of the aggregated congestion signal x_curr. No special
action is required at the network node.[¶](#section-a.1-1){.pilcrow}
:::
:::

::: {#sec-network-ecn}
::: {#section-a.2 .section}
## [A.2.](#section-a.2){.section-number .selfRef} [RED-Based ECN Marking](#name-red-based-ecn-marking){.section-name .selfRef} {#name-red-based-ecn-marking}

In this mode, the network node randomly marks the ECN field in the IP
packet header following the [Random Early Detection (RED)
algorithm](#RFC7567){.xref} \[[RFC7567](#RFC7567){.xref}\]. Calculation
of the marking probability involves the following steps on packet
arrival:[¶](#section-a.2-1){.pilcrow}

1.  ::: {#section-a.2-2.1}
    update smoothed queue size q_avg
    as:[¶](#section-a.2-2.1.1){.pilcrow}

    ::: {#section-a.2-2.1.2 .artwork .art-text .alignLeft}
           q_avg = w*q + (1-w)*q_avg

    [¶](#section-a.2-2.1.2){.pilcrow}
    :::
    :::

2.  ::: {#section-a.2-2.2}
    calculate marking probability p as:[¶](#section-a.2-2.2.1){.pilcrow}

    ::: {#section-a.2-2.2.2 .artwork .art-text .alignLeft}
                / 0,                    if q < q_lo
                |
                |        q_avg - q_lo
            p= <  p_max*--------------, if q_lo <= q < q_hi
                |         q_hi - q_lo
                |
                \ p = 1,                if q >= q_hi

    [¶](#section-a.2-2.2.2){.pilcrow}
    :::
    :::

Here, q_lo and q_hi correspond to the low and high thresholds of queue
occupancy. The maximum marking probability is
p_max.[¶](#section-a.2-3){.pilcrow}

The ECN marking events will contribute to the calculation of an
equivalent delay x_curr at the receiver. No changes are required at the
sender.[¶](#section-a.2-4){.pilcrow}
:::
:::

::: {#sec-network-pcn}
::: {#section-a.3 .section}
## [A.3.](#section-a.3){.section-number .selfRef} [Random Early Marking with Virtual Queues](#name-random-early-marking-with-v){.section-name .selfRef} {#name-random-early-marking-with-v}

Advanced network nodes may support random early marking based on a token
bucket algorithm originally designed for [Pre-Congestion Notification
(PCN)](#RFC6660){.xref} \[[RFC6660](#RFC6660){.xref}\]. The early
congestion notification (ECN) bit in the IP header of packets is marked
randomly. The marking probability is calculated based on a token bucket
algorithm originally designed for [PCN](#RFC6660){.xref}
\[[RFC6660](#RFC6660){.xref}\]. The target link utilization is set as
90%; the marking probability is designed to grow linearly with the token
bucket size when it varies between 1/3 and 2/3 of the full token bucket
limit.[¶](#section-a.3-1){.pilcrow}

Calculation of the marking probability involves the following steps upon
packet arrival:[¶](#section-a.3-2){.pilcrow}

1.  ::: {#section-a.3-3.1}
    meter packet against token bucket
    (r,b)[¶](#section-a.3-3.1.1){.pilcrow}
    :::

2.  ::: {#section-a.3-3.2}
    update token level b_tk[¶](#section-a.3-3.2.1){.pilcrow}
    :::

3.  ::: {#section-a.3-3.3}
    calculate the marking probability
    as:[¶](#section-a.3-3.3.1){.pilcrow}

    ::: {#section-a.3-3.3.2 .artwork .art-text .alignLeft}
                 / 0,                     if b-b_tk < b_lo 
                 |
                 |          b-b_tk-b_lo
            p = <  p_max* --------------, if b_lo <= b-b_tk < b_hi
                 |           b_hi-b_lo
                 |
                 \ 1,                     if b-b_tk >= b_hi 

    [¶](#section-a.3-3.3.2){.pilcrow}
    :::
    :::

Here, the token bucket lower and upper limits are denoted by b_lo and
b_hi, respectively. The parameter b indicates the size of the token
bucket. The parameter r is chosen to be below capacity, resulting in
slight underutilization of the link. The maximum marking probability is
p_max.[¶](#section-a.3-4){.pilcrow}

The ECN marking events will contribute to the calculation of an
equivalent delay x_curr at the receiver. No changes are required at the
sender. The virtual queuing mechanism from the PCN-based marking
algorithm will lead to additional benefits such as zero standing
queues.[¶](#section-a.3-5){.pilcrow}
:::
:::
:::
:::

::: {#sec-acknowledgments}
::: {#section-appendix.b .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

The authors would like to thank [Randell Jesup]{.contact-name}, [Luca De
Cicco]{.contact-name}, [Piers O\'Hanlon]{.contact-name}, [Ingemar
Johansson]{.contact-name}, [Stefan Holmer]{.contact-name}, [Cesar
Ilharco Magalhaes]{.contact-name}, [Safiqul Islam]{.contact-name},
[Michael Welzl]{.contact-name}, [Mirja Kühlewind]{.contact-name}, [Karen
Elisabeth Egede Nielsen]{.contact-name}, [Julius Flohr]{.contact-name},
[Roland Bless]{.contact-name}, [Andreas Smas]{.contact-name}, and
[Martin Stiemerling]{.contact-name} for their valuable review comments
and helpful input to this
specification.[¶](#section-appendix.b-1){.pilcrow}
:::
:::

::: {#sec-contributors}
::: {#section-appendix.c .section}
## [Contributors](#name-contributors){.section-name .selfRef} {#name-contributors}

The following individuals contributed to the implementation and
evaluation of the proposed scheme and, therefore, helped to validate and
substantially improve this
specification.[¶](#section-appendix.c-1){.pilcrow}

[Paul E. Jones]{.contact-name} \<paulej\@packetizer.com> of Cisco
Systems implemented an early version of the NADA congestion control
scheme and helped with its lab-based testbed
evaluations.[¶](#section-appendix.c-2){.pilcrow}

[Jiantao Fu]{.contact-name} \<jianfu\@cisco.com> of Cisco Systems helped
with the implementation and extensive evaluation of NADA both in Mozilla
web browsers and in earlier simulation-based evaluation
efforts.[¶](#section-appendix.c-3){.pilcrow}

[Stefano D\'Aronco]{.contact-name} \<stefano.daronco\@geod.baug.ethz.ch>
of ETH Zurich (previously at Ecole Polytechnique Federale de Lausanne
when contributing to this work) helped with the implementation and
evaluation of an early version of NADA in
\[[NS-3](#NS-3){.xref}\].[¶](#section-appendix.c-4){.pilcrow}

[Charles Ganzhorn]{.contact-name} \<charles.ganzhorn\@gmail.com>
contributed to the testbed-based evaluation of NADA during an early
stage of its development.[¶](#section-appendix.c-5){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.d .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Xiaoqing Zhu]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Cisco Systems]{.org}
:::

::: {.left dir="auto"}
[12515 Research Blvd., Building 4]{.street-address}
:::

::: {.left dir="auto"}
[Austin]{.locality}, [TX]{.region} [78759]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <xiaoqzhu@cisco.com>
:::

::: {.left dir="auto"}
[Rong Pan]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Intel Corporation]{.org}
:::

::: {.left dir="auto"}
[2200 Mission College Blvd]{.street-address}
:::

::: {.left dir="auto"}
[Santa Clara]{.locality}, [CA]{.region} [95054]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <rong.pan@intel.com>
:::

::: {.left dir="auto"}
[Michael A. Ramalho]{.fn .nameRole}
:::

::: {.left dir="auto"}
[AcousticComms Consulting]{.org}
:::

::: {.left dir="auto"}
[6310 Watercrest Way Unit 203]{.street-address}
:::

::: {.left dir="auto"}
[Lakewood Ranch]{.locality}, [FL]{.region} [34202-5211]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: tel
Phone: [+1 732 832 9723](tel:+1%20732%20832%209723){.tel}
:::

::: email
Email: <mar42@cornell.edu>
:::

::: url
URI: <http://ramalho.webhop.info/>
:::

::: {.left dir="auto"}
[Sergio Mena]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Cisco Systems]{.org}
:::

::: {.left dir="auto"}
[EPFL, Quartier de l\'Innovation, Batiment E]{.street-address}
:::

::: {.left dir="auto"}
[1015]{.postal-code} [Ecublens]{.locality}
:::

::: {.left dir="auto"}
[Switzerland]{.country-name}
:::

::: email
Email: <semena@cisco.com>
:::
:::
:::
