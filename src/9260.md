  RFC 9260          Stream Control Transmission Protocol   June 2022
  ----------------- -------------------------------------- -----------
  Stewart, et al.   Standards Track                        \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9260](https://www.rfc-editor.org/rfc/rfc9260){.eref}

Obsoletes:
:   [4460](https://www.rfc-editor.org/rfc/rfc4460){.eref},
    [4960](https://www.rfc-editor.org/rfc/rfc4960){.eref},
    [6096](https://www.rfc-editor.org/rfc/rfc6096){.eref},
    [7053](https://www.rfc-editor.org/rfc/rfc7053){.eref},
    [8540](https://www.rfc-editor.org/rfc/rfc8540){.eref}

Category:
:   Standards Track

Published:
:   June 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    R. Stewart
    :::

    ::: org
    Netflix, Inc.
    :::
    :::

    ::: author
    ::: author-name
    M. Tüxen
    :::

    ::: org
    Münster Univ. of Appl. Sciences
    :::
    :::

    ::: author
    ::: author-name
    K. Nielsen
    :::

    ::: org
    Kamstrup A/S
    :::
    :::
:::

# RFC 9260 {#rfcnum}

# Stream Control Transmission Protocol {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes the Stream Control Transmission Protocol (SCTP)
and obsoletes RFC 4960. It incorporates the specification of the chunk
flags registry from RFC 6096 and the specification of the I bit of DATA
chunks from RFC 7053. Therefore, RFCs 6096 and 7053 are also obsoleted
by this document. In addition, RFCs 4460 and 8540, which describe errata
for SCTP, are obsoleted by this
document.[¶](#section-abstract-1){.pilcrow}

SCTP was originally designed to transport Public Switched Telephone
Network (PSTN) signaling messages over IP networks. It is also suited to
be used for other applications, for example,
WebRTC.[¶](#section-abstract-2){.pilcrow}

SCTP is a reliable transport protocol operating on top of a
connectionless packet network, such as IP. It offers the following
services to its users:[¶](#section-abstract-3){.pilcrow}

-   ::: {#section-abstract-4.1}
    acknowledged error-free, non-duplicated transfer of user
    data,[¶](#section-abstract-4.1.1){.pilcrow}
    :::

-   ::: {#section-abstract-4.2}
    data fragmentation to conform to discovered Path Maximum
    Transmission Unit (PMTU) size,[¶](#section-abstract-4.2.1){.pilcrow}
    :::

-   ::: {#section-abstract-4.3}
    sequenced delivery of user messages within multiple streams, with an
    option for order-of-arrival delivery of individual user
    messages,[¶](#section-abstract-4.3.1){.pilcrow}
    :::

-   ::: {#section-abstract-4.4}
    optional bundling of multiple user messages into a single SCTP
    packet, and[¶](#section-abstract-4.4.1){.pilcrow}
    :::

-   ::: {#section-abstract-4.5}
    network-level fault tolerance through supporting of multi-homing at
    either or both ends of an
    association.[¶](#section-abstract-4.5.1){.pilcrow}
    :::

The design of SCTP includes appropriate congestion avoidance behavior
and resistance to flooding and masquerade
attacks.[¶](#section-abstract-5){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9260>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}

This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November 10,
2008. The person(s) controlling the copyright in some of this material
may not have granted the IETF Trust the right to allow modifications of
such material outside the IETF Standards Process. Without obtaining an
adequate license from the person(s) controlling the copyright in such
materials, this document may not be modified outside the IETF Standards
Process, and derivative works of it may not be created outside the IETF
Standards Process, except to format it for publication as an RFC or to
translate it into languages other than
English.[¶](#section-boilerplate.2-3){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Motivation](#name-motivation){.xref}
        :::

    -   ::: {#section-toc.1-1.1.2.2}
        [1.2](#section-1.2){.xref}.  [Architectural View of
        SCTP](#name-architectural-view-of-sctp){.xref}
        :::

    -   ::: {#section-toc.1-1.1.2.3}
        [1.3](#section-1.3){.xref}.  [Key Terms](#name-key-terms){.xref}
        :::

    -   ::: {#section-toc.1-1.1.2.4}
        [1.4](#section-1.4){.xref}.  [Abbreviations](#name-abbreviations){.xref}
        :::

    -   ::: {#section-toc.1-1.1.2.5}
        [1.5](#section-1.5){.xref}.  [Functional View of
        SCTP](#name-functional-view-of-sctp){.xref}

        -   ::: {#section-toc.1-1.1.2.5.2.1}
            [1.5.1](#section-1.5.1){.xref}.  [Association Startup and
            Takedown](#name-association-startup-and-tak){.xref}
            :::

        -   ::: {#section-toc.1-1.1.2.5.2.2}
            [1.5.2](#section-1.5.2){.xref}.  [Sequenced Delivery within
            Streams](#name-sequenced-delivery-within-s){.xref}
            :::

        -   ::: {#section-toc.1-1.1.2.5.2.3}
            [1.5.3](#section-1.5.3){.xref}.  [User Data
            Fragmentation](#name-user-data-fragmentation){.xref}
            :::

        -   ::: {#section-toc.1-1.1.2.5.2.4}
            [1.5.4](#section-1.5.4){.xref}.  [Acknowledgement and
            Congestion
            Avoidance](#name-acknowledgement-and-congest){.xref}
            :::

        -   ::: {#section-toc.1-1.1.2.5.2.5}
            [1.5.5](#section-1.5.5){.xref}.  [Chunk
            Bundling](#name-chunk-bundling){.xref}
            :::

        -   ::: {#section-toc.1-1.1.2.5.2.6}
            [1.5.6](#section-1.5.6){.xref}.  [Packet
            Validation](#name-packet-validation){.xref}
            :::

        -   ::: {#section-toc.1-1.1.2.5.2.7}
            [1.5.7](#section-1.5.7){.xref}.  [Path
            Management](#name-path-management){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.1.2.6}
        [1.6](#section-1.6){.xref}.  [Serial Number
        Arithmetic](#name-serial-number-arithmetic){.xref}
        :::

    -   ::: {#section-toc.1-1.1.2.7}
        [1.7](#section-1.7){.xref}.  [Changes from RFC
        4960](#name-changes-from-rfc-4960){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Conventions](#name-conventions){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [SCTP Packet
    Format](#name-sctp-packet-format){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [SCTP Common Header Field
        Descriptions](#name-sctp-common-header-field-de){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Chunk Field
        Descriptions](#name-chunk-field-descriptions){.xref}

        -   ::: {#section-toc.1-1.3.2.2.2.1}
            [3.2.1](#section-3.2.1){.xref}.  [Optional/Variable-Length
            Parameter Format](#name-optional-variable-length-pa){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.2}
            [3.2.2](#section-3.2.2){.xref}.  [Reporting of Unrecognized
            Parameters](#name-reporting-of-unrecognized-p){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [SCTP Chunk
        Definitions](#name-sctp-chunk-definitions){.xref}

        -   ::: {#section-toc.1-1.3.2.3.2.1}
            [3.3.1](#section-3.3.1){.xref}.  [Payload Data
            (DATA) (0)](#name-payload-data-data-0){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.2}
            [3.3.2](#section-3.3.2){.xref}.  [Initiation
            (INIT) (1)](#name-initiation-init-1){.xref}

            -   ::: {#section-toc.1-1.3.2.3.2.2.2.1}
                [3.3.2.1](#section-3.3.2.1){.xref}.  [Optional or
                Variable-Length Parameters in INIT
                chunks](#name-optional-or-variable-length){.xref}
                :::
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.3}
            [3.3.3](#section-3.3.3){.xref}.  [Initiation Acknowledgement
            (INIT ACK) (2)](#name-initiation-acknowledgement-){.xref}

            -   ::: {#section-toc.1-1.3.2.3.2.3.2.1}
                [3.3.3.1](#section-3.3.3.1){.xref}.  [Optional or
                Variable-Length Parameters in INIT ACK
                Chunks](#name-optional-or-variable-length-){.xref}
                :::
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.4}
            [3.3.4](#section-3.3.4){.xref}.  [Selective Acknowledgement
            (SACK) (3)](#name-selective-acknowledgement-s){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.5}
            [3.3.5](#section-3.3.5){.xref}.  [Heartbeat Request
            (HEARTBEAT) (4)](#name-heartbeat-request-heartbeat){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.6}
            [3.3.6](#section-3.3.6){.xref}.  [Heartbeat Acknowledgement
            (HEARTBEAT
            ACK) (5)](#name-heartbeat-acknowledgement-h){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.7}
            [3.3.7](#section-3.3.7){.xref}.  [Abort Association
            (ABORT) (6)](#name-abort-association-abort-6){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.8}
            [3.3.8](#section-3.3.8){.xref}.  [Shutdown Association
            (SHUTDOWN) (7)](#name-shutdown-association-shutdo){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.9}
            [3.3.9](#section-3.3.9){.xref}.  [Shutdown Acknowledgement
            (SHUTDOWN
            ACK) (8)](#name-shutdown-acknowledgement-sh){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.10}
            [3.3.10](#section-3.3.10){.xref}. [Operation Error
            (ERROR) (9)](#name-operation-error-error-9){.xref}

            -   ::: {#section-toc.1-1.3.2.3.2.10.2.1}
                [3.3.10.1](#section-3.3.10.1){.xref}.  [Invalid Stream
                Identifier (1)](#name-invalid-stream-identifier-1){.xref}
                :::

            -   ::: {#section-toc.1-1.3.2.3.2.10.2.2}
                [3.3.10.2](#section-3.3.10.2){.xref}.  [Missing
                Mandatory
                Parameter (2)](#name-missing-mandatory-parameter){.xref}
                :::

            -   ::: {#section-toc.1-1.3.2.3.2.10.2.3}
                [3.3.10.3](#section-3.3.10.3){.xref}.  [Stale
                Cookie (3)](#name-stale-cookie-3){.xref}
                :::

            -   ::: {#section-toc.1-1.3.2.3.2.10.2.4}
                [3.3.10.4](#section-3.3.10.4){.xref}.  [Out of
                Resource (4)](#name-out-of-resource-4){.xref}
                :::

            -   ::: {#section-toc.1-1.3.2.3.2.10.2.5}
                [3.3.10.5](#section-3.3.10.5){.xref}.  [Unresolvable
                Address (5)](#name-unresolvable-address-5){.xref}
                :::

            -   ::: {#section-toc.1-1.3.2.3.2.10.2.6}
                [3.3.10.6](#section-3.3.10.6){.xref}.  [Unrecognized
                Chunk Type (6)](#name-unrecognized-chunk-type-6){.xref}
                :::

            -   ::: {#section-toc.1-1.3.2.3.2.10.2.7}
                [3.3.10.7](#section-3.3.10.7){.xref}.  [Invalid
                Mandatory
                Parameter (7)](#name-invalid-mandatory-parameter){.xref}
                :::

            -   ::: {#section-toc.1-1.3.2.3.2.10.2.8}
                [3.3.10.8](#section-3.3.10.8){.xref}.  [Unrecognized
                Parameters (8)](#name-unrecognized-parameters-8){.xref}
                :::

            -   ::: {#section-toc.1-1.3.2.3.2.10.2.9}
                [3.3.10.9](#section-3.3.10.9){.xref}.  [No User
                Data (9)](#name-no-user-data-9){.xref}
                :::

            -   ::: {#section-toc.1-1.3.2.3.2.10.2.10}
                [3.3.10.10](#section-3.3.10.10){.xref}. [Cookie Received
                While Shutting
                Down (10)](#name-cookie-received-while-shutt){.xref}
                :::

            -   ::: {#section-toc.1-1.3.2.3.2.10.2.11}
                [3.3.10.11](#section-3.3.10.11){.xref}. [Restart of an
                Association with New
                Addresses (11)](#name-restart-of-an-association-w){.xref}
                :::

            -   ::: {#section-toc.1-1.3.2.3.2.10.2.12}
                [3.3.10.12](#section-3.3.10.12){.xref}. [User-Initiated
                Abort (12)](#name-user-initiated-abort-12){.xref}
                :::

            -   ::: {#section-toc.1-1.3.2.3.2.10.2.13}
                [3.3.10.13](#section-3.3.10.13){.xref}. [Protocol
                Violation (13)](#name-protocol-violation-13){.xref}
                :::
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.11}
            [3.3.11](#section-3.3.11){.xref}. [Cookie Echo (COOKIE
            ECHO) (10)](#name-cookie-echo-cookie-echo-10){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.12}
            [3.3.12](#section-3.3.12){.xref}. [Cookie Acknowledgement
            (COOKIE ACK) (11)](#name-cookie-acknowledgement-cook){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.13}
            [3.3.13](#section-3.3.13){.xref}. [Shutdown Complete
            (SHUTDOWN
            COMPLETE) (14)](#name-shutdown-complete-shutdown-){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [SCTP Association State
    Diagram](#name-sctp-association-state-diag){.xref}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Association
    Initialization](#name-association-initialization){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Normal Establishment of an
        Association](#name-normal-establishment-of-an-){.xref}

        -   ::: {#section-toc.1-1.5.2.1.2.1}
            [5.1.1](#section-5.1.1){.xref}.  [Handle Stream
            Parameters](#name-handle-stream-parameters){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.2}
            [5.1.2](#section-5.1.2){.xref}.  [Handle Address
            Parameters](#name-handle-address-parameters){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.3}
            [5.1.3](#section-5.1.3){.xref}.  [Generating State
            Cookie](#name-generating-state-cookie){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.4}
            [5.1.4](#section-5.1.4){.xref}.  [State Cookie
            Processing](#name-state-cookie-processing){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.5}
            [5.1.5](#section-5.1.5){.xref}.  [State Cookie
            Authentication](#name-state-cookie-authentication){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.6}
            [5.1.6](#section-5.1.6){.xref}.  [An Example of Normal
            Association
            Establishment](#name-an-example-of-normal-associ){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Handle Duplicate or Unexpected
        INIT, INIT ACK, COOKIE ECHO, and COOKIE ACK
        Chunks](#name-handle-duplicate-or-unexpec){.xref}

        -   ::: {#section-toc.1-1.5.2.2.2.1}
            [5.2.1](#section-5.2.1){.xref}.  [INIT Chunk Received in
            COOKIE-WAIT or COOKIE-ECHOED State
            (Item B)](#name-init-chunk-received-in-cook){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.2}
            [5.2.2](#section-5.2.2){.xref}.  [Unexpected INIT Chunk in
            States Other than CLOSED, COOKIE-ECHOED, COOKIE-WAIT, and
            SHUTDOWN-ACK-SENT](#name-unexpected-init-chunk-in-st){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.3}
            [5.2.3](#section-5.2.3){.xref}.  [Unexpected INIT ACK
            Chunk](#name-unexpected-init-ack-chunk){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.4}
            [5.2.4](#section-5.2.4){.xref}.  [Handle a COOKIE ECHO Chunk
            When a TCB Exists](#name-handle-a-cookie-echo-chunk-){.xref}

            -   ::: {#section-toc.1-1.5.2.2.2.4.2.1}
                [5.2.4.1](#section-5.2.4.1){.xref}.  [An Example of an
                Association
                Restart](#name-an-example-of-an-associatio){.xref}
                :::
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.5}
            [5.2.5](#section-5.2.5){.xref}.  [Handle Duplicate COOKIE
            ACK Chunk](#name-handle-duplicate-cookie-ack){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.6}
            [5.2.6](#section-5.2.6){.xref}.  [Handle Stale Cookie
            Error](#name-handle-stale-cookie-error){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Other Initialization
        Issues](#name-other-initialization-issues){.xref}

        -   ::: {#section-toc.1-1.5.2.3.2.1}
            [5.3.1](#section-5.3.1){.xref}.  [Selection of Tag
            Value](#name-selection-of-tag-value){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [Path
        Verification](#name-path-verification){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [User Data
    Transfer](#name-user-data-transfer){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Transmission of DATA
        Chunks](#name-transmission-of-data-chunks){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Acknowledgement on Reception of
        DATA Chunks](#name-acknowledgement-on-receptio){.xref}

        -   ::: {#section-toc.1-1.6.2.2.2.1}
            [6.2.1](#section-6.2.1){.xref}.  [Processing a Received SACK
            Chunk](#name-processing-a-received-sack-){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Management of Retransmission
        Timer](#name-management-of-retransmissio){.xref}

        -   ::: {#section-toc.1-1.6.2.3.2.1}
            [6.3.1](#section-6.3.1){.xref}.  [RTO
            Calculation](#name-rto-calculation){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.3.2.2}
            [6.3.2](#section-6.3.2){.xref}.  [Retransmission Timer
            Rules](#name-retransmission-timer-rules){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.3.2.3}
            [6.3.3](#section-6.3.3){.xref}.  [Handle T3-rtx
            Expiration](#name-handle-t3-rtx-expiration){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [Multi-Homed SCTP
        Endpoints](#name-multi-homed-sctp-endpoints){.xref}

        -   ::: {#section-toc.1-1.6.2.4.2.1}
            [6.4.1](#section-6.4.1){.xref}.  [Failover from an Inactive
            Destination
            Address](#name-failover-from-an-inactive-d){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.6.2.5}
        [6.5](#section-6.5){.xref}.  [Stream Identifier and Stream
        Sequence Number](#name-stream-identifier-and-strea){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.6}
        [6.6](#section-6.6){.xref}.  [Ordered and Unordered
        Delivery](#name-ordered-and-unordered-deliv){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.7}
        [6.7](#section-6.7){.xref}.  [Report Gaps in Received DATA
        TSNs](#name-report-gaps-in-received-dat){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.8}
        [6.8](#section-6.8){.xref}.  [CRC32c Checksum
        Calculation](#name-crc32c-checksum-calculation){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.9}
        [6.9](#section-6.9){.xref}.  [Fragmentation and
        Reassembly](#name-fragmentation-and-reassembl){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.10}
        [6.10](#section-6.10){.xref}. [Bundling](#name-bundling){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Congestion
    Control](#name-congestion-control){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [SCTP Differences from TCP
        Congestion Control](#name-sctp-differences-from-tcp-c){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [SCTP Slow-Start and Congestion
        Avoidance](#name-sctp-slow-start-and-congest){.xref}

        -   ::: {#section-toc.1-1.7.2.2.2.1}
            [7.2.1](#section-7.2.1){.xref}.  [Slow-Start](#name-slow-start){.xref}
            :::

        -   ::: {#section-toc.1-1.7.2.2.2.2}
            [7.2.2](#section-7.2.2){.xref}.  [Congestion
            Avoidance](#name-congestion-avoidance){.xref}
            :::

        -   ::: {#section-toc.1-1.7.2.2.2.3}
            [7.2.3](#section-7.2.3){.xref}.  [Congestion
            Control](#name-congestion-control-2){.xref}
            :::

        -   ::: {#section-toc.1-1.7.2.2.2.4}
            [7.2.4](#section-7.2.4){.xref}.  [Fast Retransmit on Gap
            Reports](#name-fast-retransmit-on-gap-repo){.xref}
            :::

        -   ::: {#section-toc.1-1.7.2.2.2.5}
            [7.2.5](#section-7.2.5){.xref}.  [Reinitialization](#name-reinitialization){.xref}

            -   ::: {#section-toc.1-1.7.2.2.2.5.2.1}
                [7.2.5.1](#section-7.2.5.1){.xref}.  [Change of
                Differentiated Services Code
                Points](#name-change-of-differentiated-se){.xref}
                :::

            -   ::: {#section-toc.1-1.7.2.2.2.5.2.2}
                [7.2.5.2](#section-7.2.5.2){.xref}.  [Change of
                Routes](#name-change-of-routes){.xref}
                :::
            :::
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [PMTU
        Discovery](#name-pmtu-discovery){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Fault
    Management](#name-fault-management){.xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Endpoint Failure
        Detection](#name-endpoint-failure-detection){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Path Failure
        Detection](#name-path-failure-detection){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [8.3](#section-8.3){.xref}.  [Path
        Heartbeat](#name-path-heartbeat){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.4}
        [8.4](#section-8.4){.xref}.  [Handle \"Out of the Blue\"
        Packets](#name-handle-out-of-the-blue-pack){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.5}
        [8.5](#section-8.5){.xref}.  [Verification
        Tag](#name-verification-tag){.xref}

        -   ::: {#section-toc.1-1.8.2.5.2.1}
            [8.5.1](#section-8.5.1){.xref}.  [Exceptions in Verification
            Tag Rules](#name-exceptions-in-verification-){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Termination of
    Association](#name-termination-of-association){.xref}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Abort of an
        Association](#name-abort-of-an-association){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Shutdown of an
        Association](#name-shutdown-of-an-association){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [ICMP
    Handling](#name-icmp-handling){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [Interface with Upper
    Layer](#name-interface-with-upper-layer){.xref}

    -   ::: {#section-toc.1-1.11.2.1}
        [11.1](#section-11.1){.xref}.  [ULP-to-SCTP](#name-ulp-to-sctp){.xref}

        -   ::: {#section-toc.1-1.11.2.1.2.1}
            [11.1.1](#section-11.1.1){.xref}.  [Initialize](#name-initialize){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.1.2.2}
            [11.1.2](#section-11.1.2){.xref}.  [Associate](#name-associate){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.1.2.3}
            [11.1.3](#section-11.1.3){.xref}.  [Shutdown](#name-shutdown){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.1.2.4}
            [11.1.4](#section-11.1.4){.xref}.  [Abort](#name-abort){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.1.2.5}
            [11.1.5](#section-11.1.5){.xref}.  [Send](#name-send){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.1.2.6}
            [11.1.6](#section-11.1.6){.xref}.  [Set
            Primary](#name-set-primary){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.1.2.7}
            [11.1.7](#section-11.1.7){.xref}.  [Receive](#name-receive){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.1.2.8}
            [11.1.8](#section-11.1.8){.xref}.  [Status](#name-status){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.1.2.9}
            [11.1.9](#section-11.1.9){.xref}.  [Change
            Heartbeat](#name-change-heartbeat){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.1.2.10}
            [11.1.10](#section-11.1.10){.xref}. [Request
            Heartbeat](#name-request-heartbeat){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.1.2.11}
            [11.1.11](#section-11.1.11){.xref}. [Get SRTT
            Report](#name-get-srtt-report){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.1.2.12}
            [11.1.12](#section-11.1.12){.xref}. [Set Failure
            Threshold](#name-set-failure-threshold){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.1.2.13}
            [11.1.13](#section-11.1.13){.xref}. [Set Protocol
            Parameters](#name-set-protocol-parameters){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.1.2.14}
            [11.1.14](#section-11.1.14){.xref}. [Receive Unsent
            Message](#name-receive-unsent-message){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.1.2.15}
            [11.1.15](#section-11.1.15){.xref}. [Receive Unacknowledged
            Message](#name-receive-unacknowledged-mess){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.1.2.16}
            [11.1.16](#section-11.1.16){.xref}. [Destroy SCTP
            Instance](#name-destroy-sctp-instance){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [11.2](#section-11.2){.xref}.  [SCTP-to-ULP](#name-sctp-to-ulp){.xref}

        -   ::: {#section-toc.1-1.11.2.2.2.1}
            [11.2.1](#section-11.2.1){.xref}.  [DATA ARRIVE
            Notification](#name-data-arrive-notification){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.2.2.2}
            [11.2.2](#section-11.2.2){.xref}.  [SEND FAILURE
            Notification](#name-send-failure-notification){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.2.2.3}
            [11.2.3](#section-11.2.3){.xref}.  [NETWORK STATUS CHANGE
            Notification](#name-network-status-change-notif){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.2.2.4}
            [11.2.4](#section-11.2.4){.xref}.  [COMMUNICATION UP
            Notification](#name-communication-up-notificati){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.2.2.5}
            [11.2.5](#section-11.2.5){.xref}.  [COMMUNICATION LOST
            Notification](#name-communication-lost-notifica){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.2.2.6}
            [11.2.6](#section-11.2.6){.xref}.  [COMMUNICATION ERROR
            Notification](#name-communication-error-notific){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.2.2.7}
            [11.2.7](#section-11.2.7){.xref}.  [RESTART
            Notification](#name-restart-notification){.xref}
            :::

        -   ::: {#section-toc.1-1.11.2.2.2.8}
            [11.2.8](#section-11.2.8){.xref}.  [SHUTDOWN COMPLETE
            Notification](#name-shutdown-complete-notificat){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.12.2.1}
        [12.1](#section-12.1){.xref}.  [Security
        Objectives](#name-security-objectives){.xref}
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [12.2](#section-12.2){.xref}.  [SCTP Responses to Potential
        Threats](#name-sctp-responses-to-potential){.xref}

        -   ::: {#section-toc.1-1.12.2.2.2.1}
            [12.2.1](#section-12.2.1){.xref}.  [Countering Insider
            Attacks](#name-countering-insider-attacks){.xref}
            :::

        -   ::: {#section-toc.1-1.12.2.2.2.2}
            [12.2.2](#section-12.2.2){.xref}.  [Protecting against Data
            Corruption in the
            Network](#name-protecting-against-data-cor){.xref}
            :::

        -   ::: {#section-toc.1-1.12.2.2.2.3}
            [12.2.3](#section-12.2.3){.xref}.  [Protecting
            Confidentiality](#name-protecting-confidentiality){.xref}
            :::

        -   ::: {#section-toc.1-1.12.2.2.2.4}
            [12.2.4](#section-12.2.4){.xref}.  [Protecting against Blind
            Denial-of-Service
            Attacks](#name-protecting-against-blind-de){.xref}

            -   ::: {#section-toc.1-1.12.2.2.2.4.2.1}
                [12.2.4.1](#section-12.2.4.1){.xref}.  [Flooding](#name-flooding){.xref}
                :::

            -   ::: {#section-toc.1-1.12.2.2.2.4.2.2}
                [12.2.4.2](#section-12.2.4.2){.xref}.  [Blind
                Masquerade](#name-blind-masquerade){.xref}
                :::

            -   ::: {#section-toc.1-1.12.2.2.2.4.2.3}
                [12.2.4.3](#section-12.2.4.3){.xref}.  [Improper
                Monopolization of
                Services](#name-improper-monopolization-of-){.xref}
                :::
            :::
        :::

    -   ::: {#section-toc.1-1.12.2.3}
        [12.3](#section-12.3){.xref}.  [SCTP Interactions with
        Firewalls](#name-sctp-interactions-with-fire){.xref}
        :::

    -   ::: {#section-toc.1-1.12.2.4}
        [12.4](#section-12.4){.xref}.  [Protection of Non-SCTP-capable
        Hosts](#name-protection-of-non-sctp-capa){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [13](#section-13){.xref}. [Network Management
    Considerations](#name-network-management-consider){.xref}
    :::

-   ::: {#section-toc.1-1.14}
    [14](#section-14){.xref}. [Recommended Transmission Control Block
    (TCB) Parameters](#name-recommended-transmission-co){.xref}

    -   ::: {#section-toc.1-1.14.2.1}
        [14.1](#section-14.1){.xref}.  [Parameters Necessary for the
        SCTP Instance](#name-parameters-necessary-for-th){.xref}
        :::

    -   ::: {#section-toc.1-1.14.2.2}
        [14.2](#section-14.2){.xref}.  [Parameters Necessary per
        Association (i.e., the
        TCB)](#name-parameters-necessary-per-as){.xref}
        :::

    -   ::: {#section-toc.1-1.14.2.3}
        [14.3](#section-14.3){.xref}.  [Per Transport Address
        Data](#name-per-transport-address-data){.xref}
        :::

    -   ::: {#section-toc.1-1.14.2.4}
        [14.4](#section-14.4){.xref}.  [General Parameters
        Needed](#name-general-parameters-needed){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.15}
    [15](#section-15){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}

    -   ::: {#section-toc.1-1.15.2.1}
        [15.1](#section-15.1){.xref}.  [IETF-Defined Chunk
        Extension](#name-ietf-defined-chunk-extensio){.xref}
        :::

    -   ::: {#section-toc.1-1.15.2.2}
        [15.2](#section-15.2){.xref}.  [IETF-Defined Chunk Flags
        Registration](#name-ietf-defined-chunk-flags-re){.xref}
        :::

    -   ::: {#section-toc.1-1.15.2.3}
        [15.3](#section-15.3){.xref}.  [IETF-Defined Chunk Parameter
        Extension](#name-ietf-defined-chunk-paramete){.xref}
        :::

    -   ::: {#section-toc.1-1.15.2.4}
        [15.4](#section-15.4){.xref}.  [IETF-Defined Additional Error
        Causes](#name-ietf-defined-additional-err){.xref}
        :::

    -   ::: {#section-toc.1-1.15.2.5}
        [15.5](#section-15.5){.xref}.  [Payload Protocol
        Identifiers](#name-payload-protocol-identifier){.xref}
        :::

    -   ::: {#section-toc.1-1.15.2.6}
        [15.6](#section-15.6){.xref}.  [Port Numbers
        Registry](#name-port-numbers-registry){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.16}
    [16](#section-16){.xref}. [Suggested SCTP Protocol Parameter
    Values](#name-suggested-sctp-protocol-par){.xref}
    :::

-   ::: {#section-toc.1-1.17}
    [17](#section-17){.xref}. [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.17.2.1}
        [17.1](#section-17.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.17.2.2}
        [17.2](#section-17.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.18}
    [Appendix A](#appendix-A){.xref}.  [CRC32c Checksum
    Calculation](#name-crc32c-checksum-calculation-2){.xref}
    :::

-   ::: {#section-toc.1-1.19}
    [](#appendix-B){.xref}[Acknowledgements](#name-acknowledgements){.xref}
    :::

-   ::: {#section-toc.1-1.20}
    [](#appendix-C){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

This section explains the reasoning behind the development of the Stream
Control Transmission Protocol (SCTP), the services it offers, and the
basic concepts needed to understand the detailed description of the
protocol.[¶](#section-1-1){.pilcrow}

This document obsoletes \[[RFC4960](#RFC4960){.xref}\]. In addition to
that, it incorporates the specification of the chunk flags registry from
\[[RFC6096](#RFC6096){.xref}\] and the specification of the I bit of
DATA chunks from \[[RFC7053](#RFC7053){.xref}\]. Therefore,
\[[RFC6096](#RFC6096){.xref}\] and \[[RFC7053](#RFC7053){.xref}\] are
also obsoleted by this document.[¶](#section-1-2){.pilcrow}

::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Motivation](#name-motivation){.section-name .selfRef} {#name-motivation}

TCP \[[RFC0793](#RFC0793){.xref}\] has performed immense service as the
primary means of reliable data transfer in IP networks. However, an
increasing number of recent applications have found TCP too limiting and
have incorporated their own reliable data transfer protocol on top of
UDP \[[RFC0768](#RFC0768){.xref}\]. The limitations that users have
wished to bypass include the following:[¶](#section-1.1-1){.pilcrow}

-   ::: {#section-1.1-2.1}
    TCP provides both reliable data transfer and strict
    order-of-transmission delivery of data. Some applications need
    reliable transfer without sequence maintenance, while others would
    be satisfied with partial ordering of the data. In both of these
    cases, the head-of-line blocking offered by TCP causes unnecessary
    delay.[¶](#section-1.1-2.1.1){.pilcrow}
    :::

-   ::: {#section-1.1-2.2}
    The stream-oriented nature of TCP is often an inconvenience.
    Applications add their own record marking to delineate their
    messages and make explicit use of the push facility to ensure that a
    complete message is transferred in a reasonable
    time.[¶](#section-1.1-2.2.1){.pilcrow}
    :::

-   ::: {#section-1.1-2.3}
    The limited scope of TCP sockets complicates the task of providing
    highly available data transfer capability using multi-homed
    hosts.[¶](#section-1.1-2.3.1){.pilcrow}
    :::

-   ::: {#section-1.1-2.4}
    TCP is relatively vulnerable to denial-of-service attacks, such as
    SYN attacks.[¶](#section-1.1-2.4.1){.pilcrow}
    :::

Transport of PSTN signaling across the IP network is an application for
which all of these limitations of TCP are relevant. While this
application directly motivated the development of SCTP, other
applications might find SCTP a good match to their requirements. One
example of this is the use of data channels in the WebRTC
infrastructure.[¶](#section-1.1-3){.pilcrow}
:::

::: {#section-1.2 .section}
### [1.2.](#section-1.2){.section-number .selfRef} [Architectural View of SCTP](#name-architectural-view-of-sctp){.section-name .selfRef} {#name-architectural-view-of-sctp}

SCTP is viewed as a layer between the SCTP user application (\"SCTP
user\" for short) and a connectionless packet network service, such as
IP. The remainder of this document assumes SCTP runs on top of IP. The
basic service offered by SCTP is the reliable transfer of user messages
between peer SCTP users. It performs this service within the context of
an association between two SCTP endpoints. [Section 11](#sec_api){.xref}
of this document sketches the API that exists at the boundary between
SCTP and the SCTP upper layers.[¶](#section-1.2-1){.pilcrow}

SCTP is connection oriented in nature, but the SCTP association is a
broader concept than the TCP connection. SCTP provides the means for
each SCTP endpoint ([Section 1.3](#sec_key_terms){.xref}) to provide the
other endpoint (during association startup) with a list of transport
addresses (i.e., multiple IP addresses in combination with an SCTP port)
through which that endpoint can be reached and from which it will
originate SCTP packets. The association spans transfers over all of the
possible source/destination combinations that can be generated from each
endpoint\'s lists.[¶](#section-1.2-2){.pilcrow}

[]{#name-an-sctp-association}

::: {#fig_association}
::: {#section-1.2-3.1 .alignCenter .art-text .artwork}
     _____________                                      _____________
    |  SCTP User  |                                    |  SCTP User  |
    | Application |                                    | Application |
    |-------------|                                    |-------------|
    |    SCTP     |                                    |    SCTP     |
    |  Transport  |                                    |  Transport  |
    |   Service   |                                    |   Service   |
    |-------------|                                    |-------------|
    |             |One or more    ----      One or more|             |
    | IP Network  |IP address      \/        IP address| IP Network  |
    |   Service   |appearances     /\       appearances|   Service   |
    |_____________|               ----                 |_____________|

      SCTP Node A |<-------- Network transport ------->| SCTP Node B
:::

[Figure 1](#figure-1){.selfRef}: [An SCTP
Association](#name-an-sctp-association){.selfRef}
:::

In addition to encapsulating SCTP packets in IPv4 or IPv6, it is also
possible to encapsulate SCTP packets in UDP as specified in
\[[RFC6951](#RFC6951){.xref}\] or encapsulate them in DTLS as specified
in \[[RFC8261](#RFC8261){.xref}\].[¶](#section-1.2-4){.pilcrow}
:::

::: {#sec_key_terms}
::: {#section-1.3 .section}
### [1.3.](#section-1.3){.section-number .selfRef} [Key Terms](#name-key-terms){.section-name .selfRef} {#name-key-terms}

Some of the language used to describe SCTP has been introduced in the
previous sections. This section provides a consolidated list of the key
terms and their definitions.[¶](#section-1.3-1){.pilcrow}

[]{.break}

Active Destination Transport Address:
:   A transport address on a peer endpoint that a transmitting endpoint
    considers available for receiving user
    messages.[¶](#section-1.3-2.2){.pilcrow}
:   

Association Maximum DATA Chunk Size (AMDCS):
:   The smallest Path Maximum DATA Chunk Size (PMDCS) of all destination
    addresses.[¶](#section-1.3-2.4){.pilcrow}
:   

Bundling of Chunks:
:   An optional multiplexing operation, whereby more than one chunk can
    be carried in the same SCTP packet.[¶](#section-1.3-2.6){.pilcrow}
:   

Bundling of User Messages:
:   An optional multiplexing operation, whereby more than one user
    message can be carried in the same SCTP packet. Each user message
    occupies its own DATA chunk.[¶](#section-1.3-2.8){.pilcrow}
:   

Chunk:
:   A unit of information within an SCTP packet, consisting of a chunk
    header and chunk-specific content.[¶](#section-1.3-2.10){.pilcrow}
:   

Congestion Window (cwnd):
:   An SCTP variable that limits outstanding data, in number of bytes,
    that a sender can send to a particular destination transport address
    before receiving an acknowledgement.[¶](#section-1.3-2.12){.pilcrow}
:   

Control Chunk:
:   A chunk not being used for transmitting user data, i.e., every chunk
    that is not a DATA chunk.[¶](#section-1.3-2.14){.pilcrow}
:   

Cumulative TSN Ack Point:
:   The Transmission Sequence Number (TSN) of the last DATA chunk
    acknowledged via the Cumulative TSN Ack field of a SACK
    chunk.[¶](#section-1.3-2.16){.pilcrow}
:   

Flightsize:
:   The number of bytes of outstanding data to a particular destination
    transport address at any given time.[¶](#section-1.3-2.18){.pilcrow}
:   

Idle Destination Address:
:   An address that has not had user messages sent to it within some
    length of time, normally the \'HB.interval\' or
    greater.[¶](#section-1.3-2.20){.pilcrow}
:   

Inactive Destination Transport Address:
:   An address that is considered inactive due to errors and unavailable
    to transport user messages.[¶](#section-1.3-2.22){.pilcrow}
:   

Message (or User Message):
:   Data submitted to SCTP by the Upper-Layer Protocol
    (ULP).[¶](#section-1.3-2.24){.pilcrow}
:   

Network Byte Order:
:   Most significant byte first, a.k.a., big
    endian.[¶](#section-1.3-2.26){.pilcrow}
:   

Ordered Message:
:   A user message that is delivered in order with respect to all
    previous user messages sent within the stream on which the message
    was sent.[¶](#section-1.3-2.28){.pilcrow}
:   

Outstanding Data (or Data Outstanding or Data In Flight):
:   The total size of the DATA chunks associated with outstanding TSNs.
    A retransmitted DATA chunk is counted once in outstanding data. A
    DATA chunk that is classified as lost but that has not yet been
    retransmitted is not in outstanding
    data.[¶](#section-1.3-2.30){.pilcrow}
:   

Outstanding TSN (at an SCTP Endpoint):
:   A TSN (and the associated DATA chunk) that has been sent by the
    endpoint but for which it has not yet received an
    acknowledgement.[¶](#section-1.3-2.32){.pilcrow}
:   

\"Out of the Blue\" (OOTB) Packet:
:   A correctly formed packet, for which the receiver cannot identify
    the association it belongs to. See [Section
    8.4](#sec_handle_out_of_the_blue_packets){.xref}.[¶](#section-1.3-2.34){.pilcrow}
:   

Path:
:   The route taken by the SCTP packets sent by one SCTP endpoint to a
    specific destination transport address of its peer SCTP endpoint.
    Sending to different destination transport addresses does not
    necessarily guarantee getting separate paths. Within this
    specification, a path is identified by the destination transport
    address, since the routing is assumed to be stable. This includes,
    in particular, the source address being selected when sending
    packets to the destination address.[¶](#section-1.3-2.36){.pilcrow}
:   

Path Maximum DATA Chunk Size (PMDCS):
:   The maximum size (including the DATA chunk header) of a DATA chunk
    that fits into an SCTP packet not exceeding the PMTU of a particular
    destination address.[¶](#section-1.3-2.38){.pilcrow}
:   

Path Maximum Transmission Unit (PMTU):
:   The maximum size (including the SCTP common header and all chunks
    including their paddings) of an SCTP packet that can be sent to a
    particular destination address without using IP-level
    fragmentation.[¶](#section-1.3-2.40){.pilcrow}
:   

Primary Path:
:   The destination and source address that will be put into a packet
    outbound to the peer endpoint by default. The definition includes
    the source address since an implementation [MAY]{.bcp14} wish to
    specify both destination and source address to better control the
    return path taken by reply chunks and on which interface the packet
    is transmitted when the data sender is
    multi-homed.[¶](#section-1.3-2.42){.pilcrow}
:   

Receiver Window (rwnd):
:   An SCTP variable a data sender uses to store the most recently
    calculated receiver window of its peer, in number of bytes. This
    gives the sender an indication of the space available in the
    receiver\'s inbound buffer.[¶](#section-1.3-2.44){.pilcrow}
:   

SCTP Association:
:   A protocol relationship between SCTP endpoints, composed of the two
    SCTP endpoints and protocol state information, including
    Verification Tags and the currently active set of Transmission
    Sequence Numbers (TSNs), etc. An association can be uniquely
    identified by the transport addresses used by the endpoints in the
    association. Two SCTP endpoints [MUST NOT]{.bcp14} have more than
    one SCTP association between them at any given
    time.[¶](#section-1.3-2.46){.pilcrow}
:   

SCTP Endpoint:
:   The logical sender/receiver of SCTP packets. On a multi-homed host,
    an SCTP endpoint is represented to its peers as a combination of a
    set of eligible destination transport addresses to which SCTP
    packets can be sent and a set of eligible source transport addresses
    from which SCTP packets can be received. All transport addresses
    used by an SCTP endpoint [MUST]{.bcp14} use the same port number but
    can use multiple IP addresses. A transport address used by an SCTP
    endpoint [MUST NOT]{.bcp14} be used by another SCTP endpoint. In
    other words, a transport address is unique to an SCTP
    endpoint.[¶](#section-1.3-2.48){.pilcrow}
:   

SCTP Packet (or Packet):
:   The unit of data delivery across the interface between SCTP and the
    connectionless packet network (e.g., IP). An SCTP packet includes
    the common SCTP header, possible SCTP control chunks, and user data
    encapsulated within SCTP DATA
    chunks.[¶](#section-1.3-2.50){.pilcrow}
:   

SCTP User Application (or SCTP User):
:   The logical higher-layer application entity that uses the services
    of SCTP, also called the Upper-Layer Protocol
    (ULP).[¶](#section-1.3-2.52){.pilcrow}
:   

Slow-Start Threshold (ssthresh):
:   An SCTP variable. This is the threshold that the endpoint will use
    to determine whether to perform slow-start or congestion avoidance
    on a particular destination transport address. Ssthresh is in number
    of bytes.[¶](#section-1.3-2.54){.pilcrow}
:   

State Cookie:
:   A container of all information needed to establish an
    association.[¶](#section-1.3-2.56){.pilcrow}
:   

Stream:

:   A unidirectional logical channel established from one to another
    associated SCTP endpoint, within which all user messages are
    delivered in sequence, except for those submitted to the unordered
    delivery service.[¶](#section-1.3-2.58.1){.pilcrow}

    Note: The relationship between stream numbers in opposite directions
    is strictly a matter of how the applications use them. It is the
    responsibility of the SCTP user to create and manage these
    correlations if they are so
    desired.[¶](#section-1.3-2.58.2){.pilcrow}

:   

Stream Sequence Number:
:   A 16-bit sequence number used internally by SCTP to ensure sequenced
    delivery of the user messages within a given stream. One Stream
    Sequence Number is attached to each ordered user
    message.[¶](#section-1.3-2.60){.pilcrow}
:   

Tie-Tags:
:   Two 32-bit random numbers that together make a 64-bit nonce. These
    tags are used within a State Cookie and TCB so that a newly
    restarting association can be linked to the original association
    within the endpoint that did not restart and yet not reveal the true
    Verification Tags of an existing
    association.[¶](#section-1.3-2.62){.pilcrow}
:   

Transmission Control Block (TCB):
:   An internal data structure created by an SCTP endpoint for each of
    its existing SCTP associations to other SCTP endpoints. TCB contains
    all the status and operational information for the endpoint to
    maintain and manage the corresponding
    association.[¶](#section-1.3-2.64){.pilcrow}
:   

Transmission Sequence Number (TSN):
:   A 32-bit sequence number used internally by SCTP. One TSN is
    attached to each chunk containing user data to permit the receiving
    SCTP endpoint to acknowledge its receipt and detect duplicate
    deliveries.[¶](#section-1.3-2.66){.pilcrow}
:   

Transport Address:
:   A transport address is typically defined by a network-layer address,
    a transport-layer protocol, and a transport-layer port number. In
    the case of SCTP running over IP, a transport address is defined by
    the combination of an IP address and an SCTP port number (where SCTP
    is the transport protocol).[¶](#section-1.3-2.68){.pilcrow}
:   

Unordered Message:
:   Unordered messages are \"unordered\" with respect to any other
    message; this includes both other unordered messages as well as
    other ordered messages. An unordered message might be delivered
    prior to or later than ordered messages sent on the same
    stream.[¶](#section-1.3-2.70){.pilcrow}
:   

User Message:
:   The unit of data delivery across the interface between SCTP and its
    user.[¶](#section-1.3-2.72){.pilcrow}
:   

Verification Tag:
:   A 32-bit unsigned integer that is randomly generated. The
    Verification Tag provides a key that allows a receiver to verify
    that the SCTP packet belongs to the current association and is not
    an old or stale packet from a previous
    association.[¶](#section-1.3-2.74){.pilcrow}
:   
:::
:::

::: {#section-1.4 .section}
### [1.4.](#section-1.4){.section-number .selfRef} [Abbreviations](#name-abbreviations){.section-name .selfRef} {#name-abbreviations}

[]{.break}

MAC
:   Message Authentication Code
    \[[RFC2104](#RFC2104){.xref}\][¶](#section-1.4-1.2){.pilcrow}
:   

RTO
:   Retransmission Timeout[¶](#section-1.4-1.4){.pilcrow}
:   

RTT
:   Round-Trip Time[¶](#section-1.4-1.6){.pilcrow}
:   

RTTVAR
:   Round-Trip Time Variation[¶](#section-1.4-1.8){.pilcrow}
:   

SCTP
:   Stream Control Transmission Protocol[¶](#section-1.4-1.10){.pilcrow}
:   

SRTT
:   Smoothed RTT[¶](#section-1.4-1.12){.pilcrow}
:   

TCB
:   Transmission Control Block[¶](#section-1.4-1.14){.pilcrow}
:   

TLV
:   Type-Length-Value coding format[¶](#section-1.4-1.16){.pilcrow}
:   

TSN
:   Transmission Sequence Number[¶](#section-1.4-1.18){.pilcrow}
:   

ULP
:   Upper-Layer Protocol[¶](#section-1.4-1.20){.pilcrow}
:   
:::

::: {#section-1.5 .section}
### [1.5.](#section-1.5){.section-number .selfRef} [Functional View of SCTP](#name-functional-view-of-sctp){.section-name .selfRef} {#name-functional-view-of-sctp}

The SCTP transport service can be decomposed into a number of functions.
These are depicted in [Figure 2](#fig_functional_view){.xref} and
explained in the remainder of this section.[¶](#section-1.5-1){.pilcrow}

[]{#name-functional-view-of-the-sctp}

::: {#fig_functional_view}
::: {#section-1.5-2.1 .alignCenter .art-text .artwork}
                    SCTP User Application

    -----------------------------------------------------
     _____________                  ____________________
    |             |                | Sequenced Delivery |
    | Association |                |   within Streams   |
    |             |                |____________________|
    |   Startup   |
    |             |         ____________________________
    |     and     |        |  User Data Fragmentation   |
    |             |        |____________________________|
    |  Takedown   |
    |             |         ____________________________
    |             |        |      Acknowledgement       |
    |             |        |            and             |
    |             |        |    Congestion Avoidance    |
    |             |        |____________________________|
    |             |
    |             |         ____________________________
    |             |        |       Chunk Bundling       |
    |             |        |____________________________|
    |             |
    |             |     ________________________________
    |             |    |       Packet Validation        |
    |             |    |________________________________|
    |             |
    |             |     ________________________________
    |             |    |        Path Management         |
    |_____________|    |________________________________|
:::

[Figure 2](#figure-2){.selfRef}: [Functional View of the SCTP Transport
Service](#name-functional-view-of-the-sctp){.selfRef}
:::

::: {#section-1.5.1 .section}
#### [1.5.1.](#section-1.5.1){.section-number .selfRef} [Association Startup and Takedown](#name-association-startup-and-tak){.section-name .selfRef} {#name-association-startup-and-tak}

An association is initiated by a request from the SCTP user (see the
description of the ASSOCIATE (or SEND) primitive in [Section
11](#sec_api){.xref}).[¶](#section-1.5.1-1){.pilcrow}

A cookie mechanism, similar to one described by Karn and Simpson in
\[[RFC2522](#RFC2522){.xref}\], is employed during the initialization to
provide protection against synchronization attacks. The cookie mechanism
uses a four-way handshake, the last two legs of which are allowed to
carry user data for fast setup. The startup sequence is described in
[Section 5](#sec_assoc_initialization){.xref} of this
document.[¶](#section-1.5.1-2){.pilcrow}

SCTP provides for graceful close (i.e., shutdown) of an active
association on request from the SCTP user. See the description of the
SHUTDOWN primitive in [Section 11](#sec_api){.xref}. SCTP also allows
ungraceful close (i.e., abort), either on request from the user (ABORT
primitive) or as a result of an error condition detected within the SCTP
layer. [Section 9](#sec_assoc_termination){.xref} describes both the
graceful and the ungraceful close
procedures.[¶](#section-1.5.1-3){.pilcrow}

SCTP does not support a half-open state (like TCP) wherein one side
continues sending data while the other end is closed. When either
endpoint performs a shutdown, the association on each peer will stop
accepting new data from its user and only deliver data in queue at the
time of the graceful close (see [Section
9](#sec_assoc_termination){.xref}).[¶](#section-1.5.1-4){.pilcrow}
:::

::: {#section-1.5.2 .section}
#### [1.5.2.](#section-1.5.2){.section-number .selfRef} [Sequenced Delivery within Streams](#name-sequenced-delivery-within-s){.section-name .selfRef} {#name-sequenced-delivery-within-s}

The term \"stream\" is used in SCTP to refer to a sequence of user
messages that are to be delivered to the upper-layer protocol in order
with respect to other messages within the same stream. This is in
contrast to its usage in TCP, where it refers to a sequence of bytes (in
this document, a byte is assumed to be 8
bits).[¶](#section-1.5.2-1){.pilcrow}

At association startup time, the SCTP user can specify the number of
streams to be supported by the association. This number is negotiated
with the remote end (see [Section
5.1.1](#sec_handle_stream_parameters){.xref}). User messages are
associated with stream numbers (SEND, RECEIVE primitives; [Section
11](#sec_api){.xref}). Internally, SCTP assigns a Stream Sequence Number
to each message passed to it by the SCTP user. On the receiving side,
SCTP ensures that messages are delivered to the SCTP user in sequence
within a given stream. However, while one stream might be blocked
waiting for the next in-sequence user message, delivery from other
streams might proceed.[¶](#section-1.5.2-2){.pilcrow}

SCTP provides a mechanism for bypassing the sequenced delivery service.
User messages sent using this mechanism are delivered to the SCTP user
as soon as they are received.[¶](#section-1.5.2-3){.pilcrow}
:::

::: {#section-1.5.3 .section}
#### [1.5.3.](#section-1.5.3){.section-number .selfRef} [User Data Fragmentation](#name-user-data-fragmentation){.section-name .selfRef} {#name-user-data-fragmentation}

When needed, SCTP fragments user messages to ensure that the size of the
SCTP packet passed to the lower layer does not exceed the PMTU. Once a
user message has been fragmented, this fragmentation cannot be changed
anymore. On receipt, fragments are reassembled into complete messages
before being passed to the SCTP user.[¶](#section-1.5.3-1){.pilcrow}
:::

::: {#section-1.5.4 .section}
#### [1.5.4.](#section-1.5.4){.section-number .selfRef} [Acknowledgement and Congestion Avoidance](#name-acknowledgement-and-congest){.section-name .selfRef} {#name-acknowledgement-and-congest}

SCTP assigns a Transmission Sequence Number (TSN) to each user data
fragment or unfragmented message. The TSN is independent of any Stream
Sequence Number assigned at the stream level. The receiving end
acknowledges all TSNs received, even if there are gaps in the sequence.
If a user data fragment or unfragmented message needs to be
retransmitted, the TSN assigned to it is used. In this way, reliable
delivery is kept functionally separate from sequenced stream
delivery.[¶](#section-1.5.4-1){.pilcrow}

The acknowledgement and congestion avoidance function is responsible for
packet retransmission when timely acknowledgement has not been received.
Packet retransmission is conditioned by congestion avoidance procedures
similar to those used for TCP. See Sections
[6](#sec_user_data_transfer){.xref} and
[7](#sec_congestion_control){.xref} for detailed descriptions of the
protocol procedures associated with this
function.[¶](#section-1.5.4-2){.pilcrow}
:::

::: {#section-1.5.5 .section}
#### [1.5.5.](#section-1.5.5){.section-number .selfRef} [Chunk Bundling](#name-chunk-bundling){.section-name .selfRef} {#name-chunk-bundling}

As described in [Section 3](#sec_sctp_packet_format){.xref}, the SCTP
packet as delivered to the lower layer consists of a common header
followed by one or more chunks. Each chunk contains either user data or
SCTP control information. An SCTP implementation supporting bundling on
the sender side might delay the sending of user messages to allow the
corresponding DATA chunks to be bundled.[¶](#section-1.5.5-1){.pilcrow}

The SCTP user has the option to request that an SCTP implementation does
not delay the sending of a user message just for this purpose. However,
even if the SCTP user has chosen this option, the SCTP implementation
might delay the sending due to other reasons (for example, due to
congestion control or flow control) and might also bundle multiple DATA
chunks, if possible.[¶](#section-1.5.5-2){.pilcrow}
:::

::: {#section-1.5.6 .section}
#### [1.5.6.](#section-1.5.6){.section-number .selfRef} [Packet Validation](#name-packet-validation){.section-name .selfRef} {#name-packet-validation}

A mandatory Verification Tag field and a 32-bit checksum field (see
[Appendix A](#sec_crc32c){.xref} for a description of the 32-bit Cyclic
Redundancy Check (CRC32c) checksum) are included in the SCTP common
header. The Verification Tag value is chosen by each end of the
association during association startup. Packets received without the
expected Verification Tag value are discarded, as a protection against
blind masquerade attacks and against stale SCTP packets from a previous
association. The CRC32c checksum is set by the sender of each SCTP
packet to provide additional protection against data corruption in the
network. The receiver of an SCTP packet with an invalid CRC32c checksum
silently discards the packet.[¶](#section-1.5.6-1){.pilcrow}
:::

::: {#section-1.5.7 .section}
#### [1.5.7.](#section-1.5.7){.section-number .selfRef} [Path Management](#name-path-management){.section-name .selfRef} {#name-path-management}

The sending SCTP user is able to manipulate the set of transport
addresses used as destinations for SCTP packets through the primitives
described in [Section 11](#sec_api){.xref}. The SCTP path management
function monitors reachability through heartbeats when other packet
traffic is inadequate to provide this information and advises the SCTP
user when reachability of any transport address of the peer endpoint
changes. The path management function chooses the destination transport
address for each outgoing SCTP packet based on the SCTP user\'s
instructions and the currently perceived reachability status of the
eligible destination set. The path management function is also
responsible for reporting the eligible set of local transport addresses
to the peer endpoint during association startup and for reporting the
transport addresses returned from the peer endpoint to the SCTP
user.[¶](#section-1.5.7-1){.pilcrow}

At association startup, a primary path is defined for each SCTP endpoint
and is used to send SCTP packets
normally.[¶](#section-1.5.7-2){.pilcrow}

On the receiving end, the path management is responsible for verifying
the existence of a valid SCTP association to which the inbound SCTP
packet belongs before passing it for further
processing.[¶](#section-1.5.7-3){.pilcrow}

Note: Path Management and Packet Validation are done at the same time;
although described separately above, in reality, they cannot be
performed as separate items.[¶](#section-1.5.7-4){.pilcrow}
:::
:::

::: {#section-1.6 .section}
### [1.6.](#section-1.6){.section-number .selfRef} [Serial Number Arithmetic](#name-serial-number-arithmetic){.section-name .selfRef} {#name-serial-number-arithmetic}

It is essential to remember that the actual Transmission Sequence Number
space is finite, though very large. This space ranges from 0 to 2^32^ -
1. Since the space is finite, all arithmetic dealing with Transmission
Sequence Numbers [MUST]{.bcp14} be performed modulo 2^32^. This unsigned
arithmetic preserves the relationship of sequence numbers as they cycle
from 2^32^ - 1 to 0 again. There are some subtleties to computer modulo
arithmetic, so great care has to be taken in programming the comparison
of such values. When referring to TSNs, the symbol \"\<=\" means \"less
than or equal\" (modulo 2^32^).[¶](#section-1.6-1){.pilcrow}

Comparisons and arithmetic on TSNs in this document [SHOULD]{.bcp14} use
Serial Number Arithmetic, as defined in \[[RFC1982](#RFC1982){.xref}\],
where SERIAL_BITS = 32.[¶](#section-1.6-2){.pilcrow}

An endpoint [SHOULD NOT]{.bcp14} transmit a DATA chunk with a TSN that
is more than 2^31^ - 1 above the beginning TSN of its current send
window. Doing so will cause problems in comparing
TSNs.[¶](#section-1.6-3){.pilcrow}

Transmission Sequence Numbers wrap around when they reach 2^32^ - 1.
That is, the next TSN a DATA chunk [MUST]{.bcp14} use after transmitting
TSN = 2^32^ - 1 is TSN = 0.[¶](#section-1.6-4){.pilcrow}

Any arithmetic done on Stream Sequence Numbers [SHOULD]{.bcp14} use
Serial Number Arithmetic, as defined in \[[RFC1982](#RFC1982){.xref}\],
where SERIAL_BITS = 16. All other arithmetic and comparisons in this
document use normal arithmetic.[¶](#section-1.6-5){.pilcrow}
:::

::: {#section-1.7 .section}
### [1.7.](#section-1.7){.section-number .selfRef} [Changes from RFC 4960](#name-changes-from-rfc-4960){.section-name .selfRef} {#name-changes-from-rfc-4960}

SCTP was originally defined in \[[RFC4960](#RFC4960){.xref}\], which
this document obsoletes. Readers interested in the details of the
various changes that this document incorporates are asked to consult
\[[RFC8540](#RFC8540){.xref}\].[¶](#section-1.7-1){.pilcrow}

In addition to these and further editorial changes, the following
changes have been incorporated in this
document:[¶](#section-1.7-2){.pilcrow}

-   ::: {#section-1.7-3.1}
    Update references.[¶](#section-1.7-3.1.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.2}
    Improve the language related to requirements
    levels.[¶](#section-1.7-3.2.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.3}
    Allow the ASSOCIATE primitive to take multiple remote addresses;
    also refer to the socket API
    specification.[¶](#section-1.7-3.3.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.4}
    Refer to the Packetization Layer Path MTU Discovery (PLPMTUD)
    specification for path MTU
    discovery.[¶](#section-1.7-3.4.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.5}
    Move the description of ICMP handling from the Appendix to the main
    text.[¶](#section-1.7-3.5.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.6}
    Remove the Appendix describing Explicit Congestion Notification
    (ECN) handling from the document.[¶](#section-1.7-3.6.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.7}
    Describe the packet size handling more precisely by introducing
    PMTU, PMDCS, and AMDCS.[¶](#section-1.7-3.7.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.8}
    Add the definition of control
    chunk.[¶](#section-1.7-3.8.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.9}
    Improve the description of the handling of INIT and INIT ACK chunks
    with invalid mandatory parameters.[¶](#section-1.7-3.9.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.10}
    Allow using L > 1 for Appropriate Byte Counting (ABC) during slow
    start.[¶](#section-1.7-3.10.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.11}
    Explicitly describe the reinitialization of the congestion
    controller on route changes.[¶](#section-1.7-3.11.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.12}
    Improve the terminology to make it clear that this specification
    does not describe a full mesh
    architecture.[¶](#section-1.7-3.12.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.13}
    Improve the description of sequence number generation (Transmission
    Sequence Number and Stream Sequence
    Number).[¶](#section-1.7-3.13.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.14}
    Improve the description of
    reneging.[¶](#section-1.7-3.14.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.15}
    Don\'t require the change of the Cumulative TSN Ack anymore for
    increasing the congestion window. This improves the consistency with
    the handling in congestion
    avoidance.[¶](#section-1.7-3.15.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.16}
    Improve the description of the State
    Cookie.[¶](#section-1.7-3.16.1){.pilcrow}
    :::

-   ::: {#section-1.7-3.17}
    Fix the API for retrieving messages in case of association
    failures.[¶](#section-1.7-3.17.1){.pilcrow}
    :::
:::
:::

::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Conventions](#name-conventions){.section-name .selfRef} {#name-conventions}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}
:::

::: {#sec_sctp_packet_format}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [SCTP Packet Format](#name-sctp-packet-format){.section-name .selfRef} {#name-sctp-packet-format}

An SCTP packet is composed of a common header and chunks. A chunk
contains either control information or user
data.[¶](#section-3-1){.pilcrow}

The SCTP packet format is shown below:[¶](#section-3-2){.pilcrow}

::: {#section-3-3 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                         Common Header                         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           Chunk #1                            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                              ...                              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           Chunk #n                            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3-3){.pilcrow}
:::

INIT, INIT ACK, and SHUTDOWN COMPLETE chunks [MUST NOT]{.bcp14} be
bundled with any other chunk into an SCTP packet. All other chunks
[MAY]{.bcp14} be bundled to form an SCTP packet that does not exceed the
PMTU. See [Section 6.10](#sec_bundling){.xref} for more details on chunk
bundling.[¶](#section-3-4){.pilcrow}

If a user data message does not fit into one SCTP packet, it can be
fragmented into multiple chunks using the procedure defined in [Section
6.9](#sec_frag_reass){.xref}.[¶](#section-3-5){.pilcrow}

All integer fields in an SCTP packet [MUST]{.bcp14} be transmitted in
network byte order, unless otherwise stated.[¶](#section-3-6){.pilcrow}

::: {#sec_sctp_common_header_field_desriptions}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [SCTP Common Header Field Descriptions](#name-sctp-common-header-field-de){.section-name .selfRef} {#name-sctp-common-header-field-de}

::: {#section-3.1-1 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |      Source Port Number       |    Destination Port Number    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                       Verification Tag                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           Checksum                            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.1-1){.pilcrow}
:::

[]{.break}

Source Port Number: 16 bits (unsigned integer)
:   This is the SCTP sender\'s port number. It can be used by the
    receiver in combination with the source IP address, the SCTP
    Destination Port Number, and possibly the destination IP address to
    identify the association to which this packet belongs. The Source
    Port Number 0 [MUST NOT]{.bcp14} be
    used.[¶](#section-3.1-2.2){.pilcrow}
:   

Destination Port Number: 16 bits (unsigned integer)
:   This is the SCTP port number to which this packet is destined. The
    receiving host will use this port number to de-multiplex the SCTP
    packet to the correct receiving endpoint/application. The
    Destination Port Number 0 [MUST NOT]{.bcp14} be
    used.[¶](#section-3.1-2.4){.pilcrow}
:   

Verification Tag: 32 bits (unsigned integer)

:   The receiver of an SCTP packet uses the Verification Tag to validate
    the sender of this packet. On transmit, the value of the
    Verification Tag [MUST]{.bcp14} be set to the value of the Initiate
    Tag received from the peer endpoint during the association
    initialization, with the following
    exceptions:[¶](#section-3.1-2.6.1){.pilcrow}

    -   [A packet containing an INIT chunk [MUST]{.bcp14} have a zero
        Verification
        Tag.[¶](#section-3.1-2.6.2.1){.pilcrow}]{#section-3.1-2.6.2.1}
    -   [A packet containing a SHUTDOWN COMPLETE chunk with the T bit
        set [MUST]{.bcp14} have the Verification Tag copied from the
        packet with the SHUTDOWN ACK
        chunk.[¶](#section-3.1-2.6.2.2){.pilcrow}]{#section-3.1-2.6.2.2}
    -   [A packet containing an ABORT chunk [MAY]{.bcp14} have the
        Verification Tag copied from the packet that caused the ABORT
        chunk to be sent. For details, see Sections
        [8.4](#sec_handle_out_of_the_blue_packets){.xref} and
        [8.5](#sec_verification_tag){.xref}.[¶](#section-3.1-2.6.2.3){.pilcrow}]{#section-3.1-2.6.2.3}

:   

Checksum: 32 bits (unsigned integer)
:   This field contains the checksum of the SCTP packet. Its calculation
    is discussed in [Section
    6.8](#sec_crc32c_checksum_calculation){.xref}. SCTP uses the CRC32c
    algorithm as described in [Appendix A](#sec_crc32c){.xref} for
    calculating the checksum.[¶](#section-3.1-2.8){.pilcrow}
:   
:::
:::

::: {#sec_chunk_field_descriptions}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Chunk Field Descriptions](#name-chunk-field-descriptions){.section-name .selfRef} {#name-chunk-field-descriptions}

The figure below illustrates the field format for the chunks to be
transmitted in the SCTP packet. Each chunk is formatted with a Chunk
Type field, a Chunk Flags field, a Chunk Length field, and a Chunk Value
field.[¶](#section-3.2-1){.pilcrow}

::: {#section-3.2-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Chunk Type   |  Chunk Flags  |         Chunk Length          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    \                                                               \
    /                          Chunk Value                          /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.2-2){.pilcrow}
:::

[]{.break}

Chunk Type: 8 bits (unsigned integer)

:   This field identifies the type of information contained in the Chunk
    Value field. It takes a value from 0 to 254. The value of 255 is
    reserved for future use as an extension
    field.[¶](#section-3.2-3.2.1){.pilcrow}

    The values of Chunk Types defined in this document are as
    follows:[¶](#section-3.2-3.2.2){.pilcrow}

    []{#name-chunk-types}

      ID Value     Chunk Type
      ------------ -----------------------------------------------------------
      0            Payload Data (DATA)
      1            Initiation (INIT)
      2            Initiation Acknowledgement (INIT ACK)
      3            Selective Acknowledgement (SACK)
      4            Heartbeat Request (HEARTBEAT)
      5            Heartbeat Acknowledgement (HEARTBEAT ACK)
      6            Abort (ABORT)
      7            Shutdown (SHUTDOWN)
      8            Shutdown Acknowledgement (SHUTDOWN ACK)
      9            Operation Error (ERROR)
      10           State Cookie (COOKIE ECHO)
      11           Cookie Acknowledgement (COOKIE ACK)
      12           Reserved for Explicit Congestion Notification Echo (ECNE)
      13           Reserved for Congestion Window Reduced (CWR)
      14           Shutdown Complete (SHUTDOWN COMPLETE)
      15 to 62     Unassigned
      63           Reserved for IETF-defined Chunk Extensions
      64 to 126    Unassigned
      127          Reserved for IETF-defined Chunk Extensions
      128 to 190   Unassigned
      191          Reserved for IETF-defined Chunk Extensions
      192 to 254   Unassigned
      255          Reserved for IETF-defined Chunk Extensions

      : [Table 1](#table-1){.selfRef}: [Chunk
      Types](#name-chunk-types){.selfRef}

    Note: The ECNE and CWR chunk types are reserved for future use of
    Explicit Congestion Notification
    (ECN).[¶](#section-3.2-3.2.4){.pilcrow}

    Chunk Types are encoded such that the highest-order 2 bits specify
    the action that is taken if the processing endpoint does not
    recognize the Chunk Type.[¶](#section-3.2-3.2.5){.pilcrow}

    []{#name-processing-of-unknown-chunk}

      ---- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      00   Stop processing this SCTP packet and discard the unrecognized chunk and all further chunks.[¶](#section-3.2-3.2.6.1.1.2.1){.pilcrow}
      01   Stop processing this SCTP packet, discard the unrecognized chunk and all further chunks, and report the unrecognized chunk in an ERROR chunk using the \'Unrecognized Chunk Type\' error cause.[¶](#section-3.2-3.2.6.1.2.2.1){.pilcrow}
      10   Skip this chunk and continue processing.[¶](#section-3.2-3.2.6.1.3.2.1){.pilcrow}
      11   Skip this chunk and continue processing, but report it in an ERROR chunk using the \'Unrecognized Chunk Type\' error cause.[¶](#section-3.2-3.2.6.1.4.2.1){.pilcrow}
      ---- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

      : [Table 2](#table-2){.selfRef}: [Processing of Unknown
      Chunks](#name-processing-of-unknown-chunk){.selfRef}

:   

Chunk Flags: 8 bits

:   The usage of these bits depends on the Chunk Type, as given by the
    Chunk Type field. Unless otherwise specified, they are set to 0 on
    transmit and are ignored on
    receipt.[¶](#section-3.2-3.4.1){.pilcrow}

:   

Chunk Length: 16 bits (unsigned integer)

:   This value represents the size of the chunk in bytes, including the
    Chunk Type, Chunk Flags, Chunk Length, and Chunk Value fields.
    Therefore, if the Chunk Value field is zero-length, the Length field
    will be set to 4. The Chunk Length field does not count any chunk
    padding. However, it does include any padding of variable-length
    parameters other than the last parameter in the
    chunk.[¶](#section-3.2-3.6.1){.pilcrow}

    Note: A robust implementation is expected to accept the chunk
    whether or not the final padding has been included in the Chunk
    Length.[¶](#section-3.2-3.6.2){.pilcrow}

:   

Chunk Value: variable length

:   The Chunk Value field contains the actual information to be
    transferred in the chunk. The usage and format of this field is
    dependent on the Chunk Type.[¶](#section-3.2-3.8.1){.pilcrow}

:   

The total length of a chunk (including Type, Length, and Value fields)
[MUST]{.bcp14} be a multiple of 4 bytes. If the length of the chunk is
not a multiple of 4 bytes, the sender [MUST]{.bcp14} pad the chunk with
all zero bytes, and this padding is not included in the Chunk Length
field. The sender [MUST NOT]{.bcp14} pad with more than 3 bytes. The
receiver [MUST]{.bcp14} ignore the padding
bytes.[¶](#section-3.2-4){.pilcrow}

SCTP-defined chunks are described in detail in [Section
3.3](#sec_sctp_chunk_definitions){.xref}. The guidelines for
IETF-defined chunk extensions can be found in [Section
15.1](#sec_ietf_defined_chunks_extension){.xref} of this
document.[¶](#section-3.2-5){.pilcrow}

::: {#sec_parameter_format}
::: {#section-3.2.1 .section}
#### [3.2.1.](#section-3.2.1){.section-number .selfRef} [Optional/Variable-Length Parameter Format](#name-optional-variable-length-pa){.section-name .selfRef} {#name-optional-variable-length-pa}

Chunk values of SCTP control chunks consist of a chunk-type-specific
header of required fields, followed by zero or more parameters. The
optional and variable-length parameters contained in a chunk are defined
in a Type-Length-Value format, as shown
below.[¶](#section-3.2.1-1){.pilcrow}

::: {#section-3.2.1-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Parameter Type         |       Parameter Length        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    \                                                               \
    /                        Parameter Value                        /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.2.1-2){.pilcrow}
:::

[]{.break}

Parameter Type: 16 bits (unsigned integer)

:   The Type field is a 16-bit identifier of the type of parameter. It
    takes a value of 0 to 65534.[¶](#section-3.2.1-3.2.1){.pilcrow}

    The value of 65535 is reserved for IETF-defined extensions. Values
    other than those defined in specific SCTP chunk descriptions are
    reserved for use by IETF.[¶](#section-3.2.1-3.2.2){.pilcrow}

:   

Parameter Length: 16 bits (unsigned integer)
:   The Parameter Length field contains the size of the parameter in
    bytes, including the Parameter Type, Parameter Length, and Parameter
    Value fields. Thus, a parameter with a zero-length Parameter Value
    field would have a Parameter Length field of 4. The Parameter Length
    does not include any padding bytes.[¶](#section-3.2.1-3.4){.pilcrow}
:   

Parameter Value: variable length

:   The Parameter Value field contains the actual information to be
    transferred in the parameter.[¶](#section-3.2.1-3.6.1){.pilcrow}

:   

The total length of a parameter (including Parameter Type, Parameter
Length, and Parameter Value fields) [MUST]{.bcp14} be a multiple of 4
bytes. If the length of the parameter is not a multiple of 4 bytes, the
sender pads the parameter at the end (i.e., after the Parameter Value
field) with all zero bytes. The length of the padding is not included in
the Parameter Length field. A sender [MUST NOT]{.bcp14} pad with more
than 3 bytes. The receiver [MUST]{.bcp14} ignore the padding
bytes.[¶](#section-3.2.1-4){.pilcrow}

The Parameter Types are encoded such that the highest-order 2 bits
specify the action that is taken if the processing endpoint does not
recognize the Parameter Type.[¶](#section-3.2.1-5){.pilcrow}

[]{#name-processing-of-unknown-param}

  ---- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  00   Stop processing this parameter and do not process any further parameters within this chunk.[¶](#section-3.2.1-6.1.1.2.1){.pilcrow}
  01   Stop processing this parameter, do not process any further parameters within this chunk, and report the unrecognized parameter, as described in [Section 3.2.2](#sec_reporting_of_unrecognized_parameters){.xref}.[¶](#section-3.2.1-6.1.2.2.1){.pilcrow}
  10   Skip this parameter and continue processing.[¶](#section-3.2.1-6.1.3.2.1){.pilcrow}
  11   Skip this parameter and continue processing, but report the unrecognized parameter, as described in [Section 3.2.2](#sec_reporting_of_unrecognized_parameters){.xref}.[¶](#section-3.2.1-6.1.4.2.1){.pilcrow}
  ---- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  : [Table 3](#table-3){.selfRef}: [Processing of Unknown
  Parameters](#name-processing-of-unknown-param){.selfRef}

Please note that, when an INIT or INIT ACK chunk is received, in all
four cases, an INIT ACK or COOKIE ECHO chunk is sent in response,
respectively. In the 00 or 01 case, the processing of the parameters
after the unknown parameter is canceled, but no processing already done
is rolled back.[¶](#section-3.2.1-7){.pilcrow}

The actual SCTP parameters are defined in the specific SCTP chunk
sections. The rules for IETF-defined parameter extensions are defined in
[Section 15.3](#sec_ietf_defined_chunk_parameter_extension){.xref}.
Parameter types [MUST]{.bcp14} be unique across all chunks. For example,
the parameter type \'5\' is used to represent an IPv4 address (see
[Section 3.3.2.1.1](#sec_ipv4_address_parameter){.xref}). The value
\'5\' then is reserved across all chunks to represent an IPv4 address
and [MUST NOT]{.bcp14} be reused with a different meaning in any other
chunk.[¶](#section-3.2.1-8){.pilcrow}
:::
:::

::: {#sec_reporting_of_unrecognized_parameters}
::: {#section-3.2.2 .section}
#### [3.2.2.](#section-3.2.2){.section-number .selfRef} [Reporting of Unrecognized Parameters](#name-reporting-of-unrecognized-p){.section-name .selfRef} {#name-reporting-of-unrecognized-p}

If the receiver of an INIT chunk detects unrecognized parameters and has
to report them according to [Section
3.2.1](#sec_parameter_format){.xref}, it [MUST]{.bcp14} put the
\"Unrecognized Parameter\" parameter(s) in the INIT ACK chunk sent in
response to the INIT chunk. Note that, if the receiver of the INIT chunk
is not going to establish an association (e.g., due to lack of
resources), an \"Unrecognized Parameters\" error cause would not be
included with any ABORT chunk being sent to the sender of the INIT
chunk.[¶](#section-3.2.2-1){.pilcrow}

If the receiver of any other chunk (e.g., INIT ACK) detects unrecognized
parameters and has to report them according to [Section
3.2.1](#sec_parameter_format){.xref}, it [SHOULD]{.bcp14} bundle the
ERROR chunk containing the \"Unrecognized Parameters\" error cause with
the chunk sent in response (e.g., COOKIE ECHO). If the receiver of an
INIT ACK chunk cannot bundle the COOKIE ECHO chunk with the ERROR chunk,
the ERROR chunk [MAY]{.bcp14} be sent separately but not before the
COOKIE ACK chunk has been received.[¶](#section-3.2.2-2){.pilcrow}

Any time a COOKIE ECHO chunk is sent in a packet, it [MUST]{.bcp14} be
the first chunk.[¶](#section-3.2.2-3){.pilcrow}
:::
:::
:::
:::

::: {#sec_sctp_chunk_definitions}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [SCTP Chunk Definitions](#name-sctp-chunk-definitions){.section-name .selfRef} {#name-sctp-chunk-definitions}

This section defines the format of the different SCTP chunk
types.[¶](#section-3.3-1){.pilcrow}

::: {#sec_data_chunk}
::: {#section-3.3.1 .section}
#### [3.3.1.](#section-3.3.1){.section-number .selfRef} [Payload Data (DATA) (0)](#name-payload-data-data-0){.section-name .selfRef} {#name-payload-data-data-0}

The following format [MUST]{.bcp14} be used for the DATA
chunk:[¶](#section-3.3.1-1){.pilcrow}

::: {#section-3.3.1-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 0    |  Res  |I|U|B|E|            Length             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                              TSN                              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |      Stream Identifier S      |   Stream Sequence Number n    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                  Payload Protocol Identifier                  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    \                                                               \
    /                 User Data (seq n of Stream S)                 /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.1-2){.pilcrow}
:::

[]{.break}

Res: 4 bits
:   All set to 0 on transmit and ignored on
    receipt.[¶](#section-3.3.1-3.2){.pilcrow}
:   

I bit: 1 bit
:   The (I)mmediate bit [MAY]{.bcp14} be set by the sender whenever the
    sender of a DATA chunk can benefit from the corresponding SACK chunk
    being sent back without delay. See [Section
    4](https://www.rfc-editor.org/rfc/rfc7053#section-4){.relref} of
    \[[RFC7053](#RFC7053){.xref}\] for a discussion of the
    benefits.[¶](#section-3.3.1-3.4){.pilcrow}
:   

U bit: 1 bit

:   The (U)nordered bit, if set to 1, indicates that this is an
    unordered DATA chunk, and there is no Stream Sequence Number
    assigned to this DATA chunk. Therefore, the receiver [MUST]{.bcp14}
    ignore the Stream Sequence Number
    field.[¶](#section-3.3.1-3.6.1){.pilcrow}

    After reassembly (if necessary), unordered DATA chunks
    [MUST]{.bcp14} be dispatched to the upper layer by the receiver
    without any attempt to reorder.[¶](#section-3.3.1-3.6.2){.pilcrow}

    If an unordered user message is fragmented, each fragment of the
    message [MUST]{.bcp14} have its U bit set to
    1.[¶](#section-3.3.1-3.6.3){.pilcrow}

:   

B bit: 1 bit
:   The (B)eginning fragment bit, if set, indicates the first fragment
    of a user message.[¶](#section-3.3.1-3.8){.pilcrow}
:   

E bit: 1 bit
:   The (E)nding fragment bit, if set, indicates the last fragment of a
    user message.[¶](#section-3.3.1-3.10){.pilcrow}
:   

Length: 16 bits (unsigned integer)

:   This field indicates the length of the DATA chunk in bytes from the
    beginning of the type field to the end of the User Data field
    excluding any padding. A DATA chunk with one byte of user data will
    have the Length field set to 17 (indicating 17
    bytes).[¶](#section-3.3.1-3.12.1){.pilcrow}

    A DATA chunk with a User Data field of length L will have the Length
    field set to (16 + L) (indicating 16 + L bytes) where L
    [MUST]{.bcp14} be greater than
    0.[¶](#section-3.3.1-3.12.2){.pilcrow}

:   

TSN: 32 bits (unsigned integer)
:   This value represents the TSN for this DATA chunk. The valid range
    of TSN is from 0 to 4294967295 (2^32^ - 1). TSN wraps back to 0
    after reaching 4294967295.[¶](#section-3.3.1-3.14){.pilcrow}
:   

Stream Identifier S: 16 bits (unsigned integer)
:   Identifies the stream to which the following user data
    belongs.[¶](#section-3.3.1-3.16){.pilcrow}
:   

Stream Sequence Number n: 16 bits (unsigned integer)

:   This value represents the Stream Sequence Number of the following
    user data within the stream S. Valid range is 0 to
    65535.[¶](#section-3.3.1-3.18.1){.pilcrow}

    When a user message is fragmented by SCTP for transport, the same
    Stream Sequence Number [MUST]{.bcp14} be carried in each of the
    fragments of the message.[¶](#section-3.3.1-3.18.2){.pilcrow}

:   

Payload Protocol Identifier: 32 bits (unsigned integer)

:   This value represents an application (or upper layer) specified
    protocol identifier. This value is passed to SCTP by its upper layer
    and sent to its peer. This identifier is not used by SCTP but can be
    used by certain network entities, as well as by the peer
    application, to identify the type of information being carried in
    this DATA chunk. This field [MUST]{.bcp14} be sent even in
    fragmented DATA chunks (to make sure it is available for agents in
    the middle of the network). Note that this field is not touched by
    an SCTP implementation; the upper layer is responsible for the host
    to network byte order conversion of this
    field.[¶](#section-3.3.1-3.20.1){.pilcrow}

    The value 0 indicates that no application identifier is specified by
    the upper layer for this payload
    data.[¶](#section-3.3.1-3.20.2){.pilcrow}

:   

User Data: variable length
:   This is the payload user data. The implementation [MUST]{.bcp14} pad
    the end of the data to a 4-byte boundary with all zero bytes. Any
    padding [MUST NOT]{.bcp14} be included in the Length field. A sender
    [MUST]{.bcp14} never add more than 3 bytes of
    padding.[¶](#section-3.3.1-3.22){.pilcrow}
:   

An unfragmented user message [MUST]{.bcp14} have both the B and E bits
set to 1. Setting both B and E bits to 0 indicates a middle fragment of
a multi-fragment user message, as summarized in the following
table:[¶](#section-3.3.1-4){.pilcrow}

[]{#name-fragment-description-flags}

::: {#table_fragment_description_flags}
  B   E   Description
  --- --- -------------------------------------------
  1   0   First piece of a fragmented user message
  0   0   Middle piece of a fragmented user message
  0   1   Last piece of a fragmented user message
  1   1   Unfragmented message

  : [Table 4](#table-4){.selfRef}: [Fragment Description
  Flags](#name-fragment-description-flags){.selfRef}
:::

When a user message is fragmented into multiple chunks, the TSNs are
used by the receiver to reassemble the message. This means that the TSNs
for each fragment of a fragmented user message [MUST]{.bcp14} be
strictly sequential.[¶](#section-3.3.1-6){.pilcrow}

The TSNs of DATA chunks sent [SHOULD]{.bcp14} be strictly
sequential.[¶](#section-3.3.1-7){.pilcrow}

Note: The extension described in \[[RFC8260](#RFC8260){.xref}\] can be
used to mitigate the head of line blocking when transferring large user
messages.[¶](#section-3.3.1-8){.pilcrow}
:::
:::

::: {#sec_init_chunk}
::: {#section-3.3.2 .section}
#### [3.3.2.](#section-3.3.2){.section-number .selfRef} [Initiation (INIT) (1)](#name-initiation-init-1){.section-name .selfRef} {#name-initiation-init-1}

This chunk is used to initiate an SCTP association between two
endpoints. The format of the INIT chunk is shown
below:[¶](#section-3.3.2-1){.pilcrow}

::: {#section-3.3.2-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 1    |  Chunk Flags  |      Chunk Length             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                         Initiate Tag                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          Advertised Receiver Window Credit (a_rwnd)           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Number of Outbound Streams   |   Number of Inbound Streams   |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                          Initial TSN                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    \                                                               \
    /              Optional/Variable-Length Parameters              /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.2-2){.pilcrow}
:::

The following parameters are specified for the INIT chunk. Unless
otherwise noted, each parameter [MUST]{.bcp14} only be included once in
the INIT chunk.[¶](#section-3.3.2-3){.pilcrow}

[]{#name-fixed-length-parameters-of-}

  Fixed-Length Parameter              Status
  ----------------------------------- -----------
  Initiate Tag                        Mandatory
  Advertised Receiver Window Credit   Mandatory
  Number of Outbound Streams          Mandatory
  Number of Inbound Streams           Mandatory
  Initial TSN                         Mandatory

  : [Table 5](#table-5){.selfRef}: [Fixed-Length Parameters of INIT
  Chunks](#name-fixed-length-parameters-of-){.selfRef}

[]{#name-variable-length-parameters-}

  Variable-Length Parameter           Status       Type Value
  ----------------------------------- ------------ ----------------
  IPv4 Address (Note 1)               Optional     5
  IPv6 Address (Note 1)               Optional     6
  Cookie Preservative                 Optional     9
  Reserved for ECN Capable (Note 2)   Optional     32768 (0x8000)
  Host Name Address (Note 3)          Deprecated   11
  Supported Address Types (Note 4)    Optional     12

  : [Table 6](#table-6){.selfRef}: [Variable-Length Parameters of INIT
  Chunks](#name-variable-length-parameters-){.selfRef}

Note 1: The INIT chunks can contain multiple addresses that can be IPv4
and/or IPv6 in any combination.[¶](#section-3.3.2-6){.pilcrow}

Note 2: The ECN Capable field is reserved for future use of Explicit
Congestion Notification.[¶](#section-3.3.2-7){.pilcrow}

Note 3: An INIT chunk [MUST NOT]{.bcp14} contain the Host Name Address
parameter. The receiver of an INIT chunk containing a Host Name Address
parameter [MUST]{.bcp14} send an ABORT chunk and [MAY]{.bcp14} include
an \"Unresolvable Address\" error cause.[¶](#section-3.3.2-8){.pilcrow}

Note 4: This parameter, when present, specifies all the address types
the sending endpoint can support. The absence of this parameter
indicates that the sending endpoint can support any address
type.[¶](#section-3.3.2-9){.pilcrow}

If an INIT chunk is received with all mandatory parameters that are
specified for the INIT chunk, then the receiver [SHOULD]{.bcp14} process
the INIT chunk and send back an INIT ACK. The receiver of the INIT chunk
[MAY]{.bcp14} bundle an ERROR chunk with the COOKIE ACK chunk later.
However, restrictive implementations [MAY]{.bcp14} send back an ABORT
chunk in response to the INIT chunk.[¶](#section-3.3.2-10){.pilcrow}

The Chunk Flags field in INIT chunks is reserved, and all bits in it
[SHOULD]{.bcp14} be set to 0 by the sender and ignored by the
receiver.[¶](#section-3.3.2-11){.pilcrow}

[]{.break}

Initiate Tag: 32 bits (unsigned integer)

:   The receiver of the INIT chunk (the responding end) records the
    value of the Initiate Tag parameter. This value [MUST]{.bcp14} be
    placed into the Verification Tag field of every SCTP packet that the
    receiver of the INIT chunk transmits within this
    association.[¶](#section-3.3.2-12.2.1){.pilcrow}

    The Initiate Tag is allowed to have any value except 0. See [Section
    5.3.1](#sec_selection_of_tag_value){.xref} for more on the selection
    of the tag value.[¶](#section-3.3.2-12.2.2){.pilcrow}

    If the value of the Initiate Tag in a received INIT chunk is found
    to be 0, the receiver [MUST]{.bcp14} silently discard the
    packet.[¶](#section-3.3.2-12.2.3){.pilcrow}

:   

Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned integer)

:   This value represents the dedicated buffer space, in number of
    bytes, the sender of the INIT chunk has reserved in association with
    this window.[¶](#section-3.3.2-12.4.1){.pilcrow}

    The Advertised Receiver Window Credit [MUST NOT]{.bcp14} be smaller
    than 1500.[¶](#section-3.3.2-12.4.2){.pilcrow}

    A receiver of an INIT chunk with the a_rwnd value set to a value
    smaller than 1500 [MUST]{.bcp14} discard the packet,
    [SHOULD]{.bcp14} send a packet in response containing an ABORT chunk
    and using the Initiate Tag as the Verification Tag, and [MUST
    NOT]{.bcp14} change the state of any existing
    association.[¶](#section-3.3.2-12.4.3){.pilcrow}

    During the life of the association, this buffer space [SHOULD
    NOT]{.bcp14} be reduced (i.e., dedicated buffers ought not to be
    taken away from this association); however, an endpoint
    [MAY]{.bcp14} change the value of a_rwnd it sends in SACK
    chunks.[¶](#section-3.3.2-12.4.4){.pilcrow}

:   

Number of Outbound Streams (OS): 16 bits (unsigned integer)

:   Defines the number of outbound streams the sender of this INIT chunk
    wishes to create in this association. The value of 0 [MUST
    NOT]{.bcp14} be used.[¶](#section-3.3.2-12.6.1){.pilcrow}

    A receiver of an INIT chunk with the OS value set to 0
    [MUST]{.bcp14} discard the packet, [SHOULD]{.bcp14} send a packet in
    response containing an ABORT chunk and using the Initiate Tag as the
    Verification Tag, and [MUST NOT]{.bcp14} change the state of any
    existing association.[¶](#section-3.3.2-12.6.2){.pilcrow}

:   

Number of Inbound Streams (MIS): 16 bits (unsigned integer)

:   Defines the maximum number of streams the sender of this INIT chunk
    allows the peer end to create in this association. The value 0 [MUST
    NOT]{.bcp14} be used.[¶](#section-3.3.2-12.8.1){.pilcrow}

    Note: There is no negotiation of the actual number of streams;
    instead, the two endpoints will use the min(requested, offered). See
    [Section 5.1.1](#sec_handle_stream_parameters){.xref} for
    details.[¶](#section-3.3.2-12.8.2){.pilcrow}

    A receiver of an INIT chunk with the MIS value set to 0
    [MUST]{.bcp14} discard the packet, [SHOULD]{.bcp14} send a packet in
    response containing an ABORT chunk and using the Initiate Tag as the
    Verification Tag, and [MUST NOT]{.bcp14} change the state of any
    existing association.[¶](#section-3.3.2-12.8.3){.pilcrow}

:   

Initial TSN (I-TSN): 32 bits (unsigned integer)
:   Defines the TSN that the sender of the INIT chunk will use
    initially. The valid range is from 0 to 4294967295 and the Initial
    TSN [SHOULD]{.bcp14} be set to a random value in that range. The
    methods described in \[[RFC4086](#RFC4086){.xref}\] can be used for
    the Initial TSN randomization.[¶](#section-3.3.2-12.10){.pilcrow}
:   

::: {#sec_optional_variable_length_parameters_in_init}
::: {#section-3.3.2.1 .section}
##### [3.3.2.1.](#section-3.3.2.1){.section-number .selfRef} [Optional or Variable-Length Parameters in INIT chunks](#name-optional-or-variable-length){.section-name .selfRef} {#name-optional-or-variable-length}

The following parameters follow the Type-Length-Value format as defined
in [Section 3.2.1](#sec_parameter_format){.xref}. Any Type-Length-Value
fields [MUST]{.bcp14} be placed after the fixed-length fields. (The
fixed-length fields are defined in the previous
section.)[¶](#section-3.3.2.1-1){.pilcrow}

::: {#sec_ipv4_address_parameter}
::: {#section-3.3.2.1.1 .section}
###### [3.3.2.1.1.](#section-3.3.2.1.1){.section-number .selfRef} [IPv4 Address (5)](#name-ipv4-address-5){.section-name .selfRef} {#name-ipv4-address-5}

::: {#section-3.3.2.1.1-1 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           Type = 5            |          Length = 8           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                         IPv4 Address                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.2.1.1-1){.pilcrow}
:::

[]{.break}

IPv4 Address: 32 bits (unsigned integer)
:   Contains an IPv4 address of the sending endpoint. It is binary
    encoded.[¶](#section-3.3.2.1.1-2.2){.pilcrow}
:   
:::
:::

::: {#sec_ipv6_address_parameter}
::: {#section-3.3.2.1.2 .section}
###### [3.3.2.1.2.](#section-3.3.2.1.2){.section-number .selfRef} [IPv6 Address (6)](#name-ipv6-address-6){.section-name .selfRef} {#name-ipv6-address-6}

::: {#section-3.3.2.1.2-1 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           Type = 6            |          Length = 20          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    |                         IPv6 Address                          |
    |                                                               |
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.2.1.2-1){.pilcrow}
:::

[]{.break}

IPv6 Address: 128 bits (unsigned integer)

:   Contains an IPv6 \[[RFC8200](#RFC8200){.xref}\] address of the
    sending endpoint. It is binary
    encoded.[¶](#section-3.3.2.1.2-2.2.1){.pilcrow}

    A sender [MUST NOT]{.bcp14} use an IPv4-mapped IPv6 address
    \[[RFC4291](#RFC4291){.xref}\] but [SHOULD]{.bcp14} instead use an
    IPv4 Address parameter for an IPv4
    address.[¶](#section-3.3.2.1.2-2.2.2){.pilcrow}

:   

Combined with the Source Port Number in the SCTP common header, the
value passed in an IPv4 or IPv6 Address parameter indicates a transport
address the sender of the INIT chunk will support for the association
being initiated. That is, during the life time of this association, this
IP address can appear in the source address field of an IP datagram sent
from the sender of the INIT chunk and can be used as a destination
address of an IP datagram sent from the receiver of the INIT
chunk.[¶](#section-3.3.2.1.2-3){.pilcrow}

More than one IP Address parameter can be included in an INIT chunk when
the sender of the INIT chunk is multi-homed. Moreover, a multi-homed
endpoint might have access to different types of network; thus, more
than one address type can be present in one INIT chunk, i.e., IPv4 and
IPv6 addresses are allowed in the same INIT
chunk.[¶](#section-3.3.2.1.2-4){.pilcrow}

If the INIT chunk contains at least one IP Address parameter, then the
source address of the IP datagram containing the INIT chunk and any
additional address(es) provided within the INIT can be used as
destinations by the endpoint receiving the INIT chunk. If the INIT chunk
does not contain any IP Address parameters, the endpoint receiving the
INIT chunk [MUST]{.bcp14} use the source address associated with the
received IP datagram as its sole destination address for the
association.[¶](#section-3.3.2.1.2-5){.pilcrow}

Note that not using any IP Address parameters in the INIT and INIT ACK
chunk is a way to make an association more likely to work in combination
with Network Address Translation
(NAT).[¶](#section-3.3.2.1.2-6){.pilcrow}
:::
:::

::: {#section-3.3.2.1.3 .section}
###### [3.3.2.1.3.](#section-3.3.2.1.3){.section-number .selfRef} [Cookie Preservative (9)](#name-cookie-preservative-9){.section-name .selfRef} {#name-cookie-preservative-9}

The sender of the INIT chunk uses this parameter to suggest to the
receiver of the INIT chunk a longer life span for the State
Cookie.[¶](#section-3.3.2.1.3-1){.pilcrow}

::: {#section-3.3.2.1.3-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           Type = 9            |          Length = 8           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |         Suggested Cookie Life-Span Increment (msec.)          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.2.1.3-2){.pilcrow}
:::

[]{.break}

Suggested Cookie Life-Span Increment: 32 bits (unsigned integer)

:   This parameter indicates to the receiver how much increment in
    milliseconds the sender wishes the receiver to add to its default
    cookie life span.[¶](#section-3.3.2.1.3-3.2.1){.pilcrow}

    This optional parameter [MAY]{.bcp14} be added to the INIT chunk by
    the sender when it reattempts establishing an association with a
    peer to which its previous attempt of establishing the association
    failed due to a stale cookie operation error. The receiver
    [MAY]{.bcp14} choose to ignore the suggested cookie life span
    increase for its own security
    reasons.[¶](#section-3.3.2.1.3-3.2.2){.pilcrow}

:   
:::

::: {#sec_host_name_address_parameter}
::: {#section-3.3.2.1.4 .section}
###### [3.3.2.1.4.](#section-3.3.2.1.4){.section-number .selfRef} [Host Name Address (11)](#name-host-name-address-11){.section-name .selfRef} {#name-host-name-address-11}

The sender of an INIT chunk or INIT ACK chunk [MUST NOT]{.bcp14} include
this parameter. The usage of the Host Name Address parameter is
deprecated. The receiver of an INIT chunk or an INIT ACK containing a
Host Name Address parameter [MUST]{.bcp14} send an ABORT chunk and
[MAY]{.bcp14} include an \"Unresolvable Address\" error
cause.[¶](#section-3.3.2.1.4-1){.pilcrow}

::: {#section-3.3.2.1.4-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           Type = 11           |            Length             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                           Host Name                           /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.2.1.4-2){.pilcrow}
:::

[]{.break}

Host Name: variable length

:   This field contains a host name in \"host name syntax\" per [Section
    2.1](https://www.rfc-editor.org/rfc/rfc1123#section-2.1){.relref} of
    \[[RFC1123](#RFC1123){.xref}\]. The method for resolving the host
    name is out of scope of SCTP.[¶](#section-3.3.2.1.4-3.2.1){.pilcrow}

    At least one null terminator is included in the Host Name string and
    [MUST]{.bcp14} be included in the
    length.[¶](#section-3.3.2.1.4-3.2.2){.pilcrow}

:   
:::
:::

::: {#section-3.3.2.1.5 .section}
###### [3.3.2.1.5.](#section-3.3.2.1.5){.section-number .selfRef} [Supported Address Types (12)](#name-supported-address-types-12){.section-name .selfRef} {#name-supported-address-types-12}

The sender of the INIT chunk uses this parameter to list all the address
types it can support.[¶](#section-3.3.2.1.5-1){.pilcrow}

::: {#section-3.3.2.1.5-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           Type = 12           |            Length             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Address Type #1        |        Address Type #2        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            ......                             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+

[¶](#section-3.3.2.1.5-2){.pilcrow}
:::

[]{.break}

Address Type: 16 bits (unsigned integer)
:   This is filled with the type value of the corresponding address TLV
    (e.g., 5 for indicating IPv4, and 6 for indicating IPv6). The value
    indicating the Host Name Address parameter [MUST NOT]{.bcp14} be
    used when sending this parameter and [MUST]{.bcp14} be ignored when
    receiving this parameter.[¶](#section-3.3.2.1.5-3.2){.pilcrow}
:   
:::
:::
:::
:::
:::

::: {#sec_init_ack_chunk}
::: {#section-3.3.3 .section}
#### [3.3.3.](#section-3.3.3){.section-number .selfRef} [Initiation Acknowledgement (INIT ACK) (2)](#name-initiation-acknowledgement-){.section-name .selfRef} {#name-initiation-acknowledgement-}

The INIT ACK chunk is used to acknowledge the initiation of an SCTP
association. The format of the INIT ACK chunk is shown
below:[¶](#section-3.3.3-1){.pilcrow}

::: {#section-3.3.3-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 2    |  Chunk Flags  |         Chunk Length          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                         Initiate Tag                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |               Advertised Receiver Window Credit               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Number of Outbound Streams   |   Number of Inbound Streams   |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                          Initial TSN                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    \                                                               \
    /              Optional/Variable-Length Parameters              /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.3-2){.pilcrow}
:::

The parameter part of INIT ACK is formatted similarly to the INIT chunk.
The following parameters are specified for the INIT ACK
chunk:[¶](#section-3.3.3-3){.pilcrow}

[]{#name-fixed-length-parameters-of-i}

  Fixed-Length Parameter              Status
  ----------------------------------- -----------
  Initiate Tag                        Mandatory
  Advertised Receiver Window Credit   Mandatory
  Number of Outbound Streams          Mandatory
  Number of Inbound Streams           Mandatory
  Initial TSN                         Mandatory

  : [Table 7](#table-7){.selfRef}: [Fixed-Length Parameters of INIT ACK
  Chunks](#name-fixed-length-parameters-of-i){.selfRef}

It uses two extra variable parameters: the State Cookie and the
Unrecognized Parameter.[¶](#section-3.3.3-5){.pilcrow}

[]{#name-variable-length-parameters-o}

  Variable-Length Parameter           Status       Type Value
  ----------------------------------- ------------ ----------------
  State Cookie                        Mandatory    7
  IPv4 Address (Note 1)               Optional     5
  IPv6 Address (Note 1)               Optional     6
  Unrecognized Parameter              Optional     8
  Reserved for ECN Capable (Note 2)   Optional     32768 (0x8000)
  Host Name Address (Note 3)          Deprecated   11

  : [Table 8](#table-8){.selfRef}: [Variable-Length Parameters of INIT
  ACK Chunks](#name-variable-length-parameters-o){.selfRef}

Note 1: The INIT ACK chunks can contain any number of IP Address
parameters that can be IPv4 and/or IPv6 in any
combination.[¶](#section-3.3.3-7){.pilcrow}

Note 2: The ECN Capable field is reserved for future use of Explicit
Congestion Notification.[¶](#section-3.3.3-8){.pilcrow}

Note 3: An INIT ACK chunk [MUST NOT]{.bcp14} contain the Host Name
Address parameter. The receiver of INIT ACK chunks containing a Host
Name Address parameter [MUST]{.bcp14} send an ABORT chunk and
[MAY]{.bcp14} include an \"Unresolvable Address\" error
cause.[¶](#section-3.3.3-9){.pilcrow}

The Chunk Flags field in INIT ACK chunks is reserved, and all bits in it
[SHOULD]{.bcp14} be set to 0 by the sender and ignored by the
receiver.[¶](#section-3.3.3-10){.pilcrow}

[]{.break}

Initiate Tag: 32 bits (unsigned integer)

:   The receiver of the INIT ACK chunk records the value of the Initiate
    Tag parameter. This value [MUST]{.bcp14} be placed into the
    Verification Tag field of every SCTP packet that the receiver of the
    INIT ACK chunk transmits within this
    association.[¶](#section-3.3.3-11.2.1){.pilcrow}

    The Initiate Tag [MUST NOT]{.bcp14} take the value 0. See [Section
    5.3.1](#sec_selection_of_tag_value){.xref} for more on the selection
    of the Initiate Tag value.[¶](#section-3.3.3-11.2.2){.pilcrow}

    If an endpoint in the COOKIE-WAIT state receives an INIT ACK chunk
    with the Initiate Tag set to 0, it [MUST]{.bcp14} destroy the TCB
    and [SHOULD]{.bcp14} send an ABORT chunk with the T bit set. If such
    an INIT ACK chunk is received in any state other than CLOSED or
    COOKIE-WAIT, it [SHOULD]{.bcp14} be discarded silently (see [Section
    5.2.3](#sec_unexpected_init_ack){.xref}).[¶](#section-3.3.3-11.2.3){.pilcrow}

:   

Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned integer)

:   This value represents the dedicated buffer space, in number of
    bytes, the sender of the INIT ACK chunk has reserved in association
    with this window.[¶](#section-3.3.3-11.4.1){.pilcrow}

    The Advertised Receiver Window Credit [MUST NOT]{.bcp14} be smaller
    than 1500.[¶](#section-3.3.3-11.4.2){.pilcrow}

    A receiver of an INIT ACK chunk with the a_rwnd value set to a value
    smaller than 1500 [MUST]{.bcp14} discard the packet,
    [SHOULD]{.bcp14} send a packet in response containing an ABORT chunk
    and using the Initiate Tag as the Verification Tag, and [MUST
    NOT]{.bcp14} change the state of any existing
    association.[¶](#section-3.3.3-11.4.3){.pilcrow}

    During the life of the association, this buffer space [SHOULD
    NOT]{.bcp14} be reduced (i.e., dedicated buffers ought not to be
    taken away from this association); however, an endpoint
    [MAY]{.bcp14} change the value of a_rwnd it sends in SACK
    chunks.[¶](#section-3.3.3-11.4.4){.pilcrow}

:   

Number of Outbound Streams (OS): 16 bits (unsigned integer)

:   Defines the number of outbound streams the sender of this INIT ACK
    chunk wishes to create in this association. The value of 0 [MUST
    NOT]{.bcp14} be used, and the value [MUST NOT]{.bcp14} be greater
    than the MIS value sent in the INIT
    chunk.[¶](#section-3.3.3-11.6.1){.pilcrow}

    If an endpoint in the COOKIE-WAIT state receives an INIT ACK chunk
    with the OS value set to 0, it [MUST]{.bcp14} destroy the TCB and
    [SHOULD]{.bcp14} send an ABORT chunk. If such an INIT ACK chunk is
    received in any state other than CLOSED or COOKIE-WAIT, it
    [SHOULD]{.bcp14} be discarded silently (see [Section
    5.2.3](#sec_unexpected_init_ack){.xref}).[¶](#section-3.3.3-11.6.2){.pilcrow}

:   

Number of Inbound Streams (MIS): 16 bits (unsigned integer)

:   Defines the maximum number of streams the sender of this INIT ACK
    chunk allows the peer end to create in this association. The value 0
    [MUST NOT]{.bcp14} be used.[¶](#section-3.3.3-11.8.1){.pilcrow}

    Note: There is no negotiation of the actual number of streams, but
    instead the two endpoints will use the min(requested, offered). See
    [Section 5.1.1](#sec_handle_stream_parameters){.xref} for
    details.[¶](#section-3.3.3-11.8.2){.pilcrow}

    If an endpoint in the COOKIE-WAIT state receives an INIT ACK chunk
    with the MIS value set to 0, it [MUST]{.bcp14} destroy the TCB and
    [SHOULD]{.bcp14} send an ABORT chunk. If such an INIT ACK chunk is
    received in any state other than CLOSED or COOKIE-WAIT, it
    [SHOULD]{.bcp14} be discarded silently (see [Section
    5.2.3](#sec_unexpected_init_ack){.xref}).[¶](#section-3.3.3-11.8.3){.pilcrow}

:   

Initial TSN (I-TSN): 32 bits (unsigned integer)
:   Defines the TSN that the sender of the INIT ACK chunk will use
    initially. The valid range is from 0 to 4294967295 and the Initial
    TSN [SHOULD]{.bcp14} be set to a random value in that range. The
    methods described in \[[RFC4086](#RFC4086){.xref}\] can be used for
    the Initial TSN randomization.[¶](#section-3.3.3-11.10){.pilcrow}
:   

Implementation Note: An implementation [MUST]{.bcp14} be prepared to
receive an INIT ACK chunk that is quite large (more than 1500 bytes) due
to the variable size of the State Cookie and the variable address list.
For example, if a responder to the INIT chunk has 1000 IPv4 addresses it
wishes to send, it would need at least 8,000 bytes to encode this in the
INIT ACK chunk.[¶](#section-3.3.3-12){.pilcrow}

If an INIT ACK chunk is received with all mandatory parameters that are
specified for the INIT ACK chunk, then the receiver [SHOULD]{.bcp14}
process the INIT ACK chunk and send back a COOKIE ECHO chunk. The
receiver of the INIT ACK chunk [MAY]{.bcp14} bundle an ERROR chunk with
the COOKIE ECHO chunk. However, restrictive implementations
[MAY]{.bcp14} send back an ABORT chunk in response to the INIT ACK
chunk.[¶](#section-3.3.3-13){.pilcrow}

In combination with the Source Port Number carried in the SCTP common
header, each IP Address parameter in the INIT ACK chunk indicates to the
receiver of the INIT ACK chunk a valid transport address supported by
the sender of the INIT ACK chunk for the life time of the association
being initiated.[¶](#section-3.3.3-14){.pilcrow}

If the INIT ACK chunk contains at least one IP Address parameter, then
the source address of the IP datagram containing the INIT ACK chunk and
any additional address(es) provided within the INIT ACK chunk
[MAY]{.bcp14} be used as destinations by the receiver of the INIT ACK
chunk. If the INIT ACK chunk does not contain any IP Address parameters,
the receiver of the INIT ACK chunk [MUST]{.bcp14} use the source address
associated with the received IP datagram as its sole destination address
for the association.[¶](#section-3.3.3-15){.pilcrow}

The State Cookie and Unrecognized Parameters use the Type-Length-Value
format as defined in [Section 3.2.1](#sec_parameter_format){.xref} and
are described below. The other fields are defined in the same way as
their counterparts in the INIT chunk.[¶](#section-3.3.3-16){.pilcrow}

::: {#sec_optional_variable_length_parameters_in_init_ack}
::: {#section-3.3.3.1 .section}
##### [3.3.3.1.](#section-3.3.3.1){.section-number .selfRef} [Optional or Variable-Length Parameters in INIT ACK Chunks](#name-optional-or-variable-length-){.section-name .selfRef} {#name-optional-or-variable-length-}

The State Cookie and Unrecognized Parameters use the Type-Length-Value
format, as defined in [Section 3.2.1](#sec_parameter_format){.xref}, and
are described below. The IPv4 Address parameter is described in [Section
3.3.2.1.1](#sec_ipv4_address_parameter){.xref}, and the IPv6 Address
parameter is described in [Section
3.3.2.1.2](#sec_ipv6_address_parameter){.xref}. The Host Name Address
parameter is described in [Section
3.3.2.1.4](#sec_host_name_address_parameter){.xref} and [MUST
NOT]{.bcp14} be included in an INIT ACK chunk. Any Type-Length-Value
fields [MUST]{.bcp14} be placed after the fixed-length fields. (The
fixed-length fields are defined in the previous
section.)[¶](#section-3.3.3.1-1){.pilcrow}

::: {#section-3.3.3.1.1 .section}
###### [3.3.3.1.1.](#section-3.3.3.1.1){.section-number .selfRef} [State Cookie (7)](#name-state-cookie-7){.section-name .selfRef} {#name-state-cookie-7}

::: {#section-3.3.3.1.1-1 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           Type = 7            |            Length             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                            Cookie                             /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.3.1.1-1){.pilcrow}
:::

[]{.break}

Cookie: variable length
:   This parameter value [MUST]{.bcp14} contain all the necessary state
    and parameter information required for the sender of this INIT ACK
    chunk to create the association, along with a Message Authentication
    Code (MAC). See [Section 5.1.3](#sec_generating_state_cookie){.xref}
    for details on State Cookie
    definition.[¶](#section-3.3.3.1.1-2.2){.pilcrow}
:   
:::

::: {#section-3.3.3.1.2 .section}
###### [3.3.3.1.2.](#section-3.3.3.1.2){.section-number .selfRef} [Unrecognized Parameter (8)](#name-unrecognized-parameter-8){.section-name .selfRef} {#name-unrecognized-parameter-8}

This parameter is returned to the originator of the INIT chunk when the
INIT chunk contains an unrecognized parameter that has a type that
indicates it [SHOULD]{.bcp14} be reported to the
sender.[¶](#section-3.3.3.1.2-1){.pilcrow}

::: {#section-3.3.3.1.2-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           Type = 8            |            Length             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                    Unrecognized Parameter                     /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.3.1.2-2){.pilcrow}
:::

[]{.break}

Unrecognized Parameter: variable length
:   The Parameter Value field will contain an unrecognized parameter
    copied from the INIT chunk complete with Parameter Type, Length, and
    Value fields.[¶](#section-3.3.3.1.2-3.2){.pilcrow}
:   
:::
:::
:::
:::
:::

::: {#sec_sack_chunk}
::: {#section-3.3.4 .section}
#### [3.3.4.](#section-3.3.4){.section-number .selfRef} [Selective Acknowledgement (SACK) (3)](#name-selective-acknowledgement-s){.section-name .selfRef} {#name-selective-acknowledgement-s}

This chunk is sent to the peer endpoint to acknowledge received DATA
chunks and to inform the peer endpoint of gaps in the received
subsequences of DATA chunks as represented by their
TSNs.[¶](#section-3.3.4-1){.pilcrow}

The SACK chunk [MUST]{.bcp14} contain the Cumulative TSN Ack, Advertised
Receiver Window Credit (a_rwnd), Number of Gap Ack Blocks, and Number of
Duplicate TSNs fields.[¶](#section-3.3.4-2){.pilcrow}

By definition, the value of the Cumulative TSN Ack parameter is the last
TSN received before a break in the sequence of received TSNs occurs; the
next TSN value following this one has not yet been received at the
endpoint sending the SACK chunk. This parameter therefore acknowledges
receipt of all TSNs less than or equal to its
value.[¶](#section-3.3.4-3){.pilcrow}

The handling of a_rwnd by the receiver of the SACK chunk is discussed in
detail in [Section
6.2.1](#sec_processing_of_received_sack){.xref}.[¶](#section-3.3.4-4){.pilcrow}

The SACK chunk also contains zero or more Gap Ack Blocks. Each Gap Ack
Block acknowledges a subsequence of TSNs received following a break in
the sequence of received TSNs. The Gap Ack Blocks [SHOULD]{.bcp14} be
isolated. This means that the TSN just before each Gap Ack Block and the
TSN just after each Gap Ack Block have not been received. By definition,
all TSNs acknowledged by Gap Ack Blocks are greater than the value of
the Cumulative TSN Ack.[¶](#section-3.3.4-5){.pilcrow}

::: {#section-3.3.4-6 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 3    |  Chunk Flags  |         Chunk Length          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                      Cumulative TSN Ack                       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          Advertised Receiver Window Credit (a_rwnd)           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | Number of Gap Ack Blocks = N  |  Number of Duplicate TSNs = M |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Gap Ack Block #1 Start     |     Gap Ack Block #1 End      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                                                               /
    \                              ...                              \
    /                                                               /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Gap Ack Block #N Start     |     Gap Ack Block #N End      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                        Duplicate TSN 1                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                                                               /
    \                              ...                              \
    /                                                               /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                        Duplicate TSN M                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.4-6){.pilcrow}
:::

[]{.break}

Chunk Flags: 8 bits
:   All set to 0 on transmit and ignored on
    receipt.[¶](#section-3.3.4-7.2){.pilcrow}
:   

Cumulative TSN Ack: 32 bits (unsigned integer)
:   The largest TSN, such that all TSNs smaller than or equal to it have
    been received and the next one has not been received. In the case
    where no DATA chunk has been received, this value is set to the
    peer\'s Initial TSN minus one.[¶](#section-3.3.4-7.4){.pilcrow}
:   

Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned integer)
:   This field indicates the updated receive buffer space in bytes of
    the sender of this SACK chunk; see [Section
    6.2.1](#sec_processing_of_received_sack){.xref} for
    details.[¶](#section-3.3.4-7.6){.pilcrow}
:   

Number of Gap Ack Blocks: 16 bits (unsigned integer)
:   Indicates the number of Gap Ack Blocks included in this SACK
    chunk.[¶](#section-3.3.4-7.8){.pilcrow}
:   

Number of Duplicate TSNs: 16 bit
:   This field contains the number of duplicate TSNs the endpoint has
    received. Each duplicate TSN is listed following the Gap Ack Block
    list.[¶](#section-3.3.4-7.10){.pilcrow}
:   

Gap Ack Blocks:
:   These fields contain the Gap Ack Blocks. They are repeated for each
    Gap Ack Block up to the number of Gap Ack Blocks defined in the
    Number of Gap Ack Blocks field. All DATA chunks with TSNs greater
    than or equal to (Cumulative TSN Ack + Gap Ack Block Start) and less
    than or equal to (Cumulative TSN Ack + Gap Ack Block End) of each
    Gap Ack Block are assumed to have been received
    correctly.[¶](#section-3.3.4-7.12){.pilcrow}
:   

Gap Ack Block Start: 16 bits (unsigned integer)
:   Indicates the Start offset TSN for this Gap Ack Block. To calculate
    the actual TSN number, the Cumulative TSN Ack is added to this
    offset number. This calculated TSN identifies the lowest TSN in this
    Gap Ack Block that has been
    received.[¶](#section-3.3.4-7.14){.pilcrow}
:   

Gap Ack Block End: 16 bits (unsigned integer)

:   Indicates the End offset TSN for this Gap Ack Block. To calculate
    the actual TSN number, the Cumulative TSN Ack is added to this
    offset number. This calculated TSN identifies the highest TSN in
    this Gap Ack Block that has been
    received.[¶](#section-3.3.4-7.16.1){.pilcrow}

    For example, assume that the receiver has the following DATA chunks
    newly arrived at the time when it decides to send a Selective
    ACK:[¶](#section-3.3.4-7.16.2){.pilcrow}

    ::: {#section-3.3.4-7.16.3 .alignCenter .art-text .artwork}
        ------------
        | TSN = 17 |
        ------------
        |          | <- still missing
        ------------
        | TSN = 15 |
        ------------
        | TSN = 14 |
        ------------
        |          | <- still missing
        ------------
        | TSN = 12 |
        ------------
        | TSN = 11 |
        ------------
        | TSN = 10 |
        ------------

    [¶](#section-3.3.4-7.16.3){.pilcrow}
    :::

    Then, the parameter part of the SACK chunk [MUST]{.bcp14} be
    constructed as follows (assuming the new a_rwnd is set to 4660 by
    the sender):[¶](#section-3.3.4-7.16.4){.pilcrow}

    ::: {#section-3.3.4-7.16.5 .alignCenter .art-text .artwork}
        +-------------------+-------------------+
        |        Cumulative TSN Ack = 12        |
        +-------------------+-------------------+
        |             a_rwnd = 4660             |
        +-------------------+-------------------+
        | num of block = 2  |  num of dup = 0   |
        +-------------------+-------------------+
        |block #1 start = 2 | block #1 end = 3  |
        +-------------------+-------------------+
        |block #2 start = 5 | block #2 end = 5  |
        +-------------------+-------------------+

    [¶](#section-3.3.4-7.16.5){.pilcrow}
    :::

:   

Duplicate TSN: 32 bits (unsigned integer)

:   Indicates the number of times a TSN was received in duplicate since
    the last SACK chunk was sent. Every time a receiver gets a duplicate
    TSN (before sending the SACK chunk), it adds it to the list of
    duplicates. The duplicate count is reinitialized to zero after
    sending each SACK chunk.[¶](#section-3.3.4-7.18.1){.pilcrow}

    For example, if a receiver were to get the TSN 19 three times, it
    would list 19 twice in the outbound SACK chunk. After sending the
    SACK chunk, if it received yet one more TSN 19, it would list 19 as
    a duplicate once in the next outgoing SACK
    chunk.[¶](#section-3.3.4-7.18.2){.pilcrow}

:   
:::
:::

::: {#sec_heartbeat_chunk}
::: {#section-3.3.5 .section}
#### [3.3.5.](#section-3.3.5){.section-number .selfRef} [Heartbeat Request (HEARTBEAT) (4)](#name-heartbeat-request-heartbeat){.section-name .selfRef} {#name-heartbeat-request-heartbeat}

An endpoint [SHOULD]{.bcp14} send a HEARTBEAT (HB) chunk to its peer
endpoint to probe the reachability of a particular destination transport
address defined in the present
association.[¶](#section-3.3.5-1){.pilcrow}

The parameter field contains the Heartbeat Information, which is a
variable-length opaque data structure understood only by the
sender.[¶](#section-3.3.5-2){.pilcrow}

::: {#section-3.3.5-3 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 4    |  Chunk Flags  |       Heartbeat Length        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    \                                                               \
    /          Heartbeat Information TLV (Variable-Length)          /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.5-3){.pilcrow}
:::

[]{.break}

Chunk Flags: 8 bits
:   Set to 0 on transmit and ignored on
    receipt.[¶](#section-3.3.5-4.2){.pilcrow}
:   

Heartbeat Length: 16 bits (unsigned integer)
:   Set to the size of the chunk in bytes, including the chunk header
    and the Heartbeat Information
    field.[¶](#section-3.3.5-4.4){.pilcrow}
:   

Heartbeat Information: variable length

:   Defined as a variable-length parameter using the format described in
    [Section 3.2.1](#sec_parameter_format){.xref}, that
    is:[¶](#section-3.3.5-4.6.1){.pilcrow}

    []{#name-variable-length-parameters-of}

      Variable Parameters   Status      Type Value
      --------------------- ----------- ------------
      Heartbeat Info        Mandatory   1

      : [Table 9](#table-9){.selfRef}: [Variable-Length Parameters of
      HEARTBEAT Chunks](#name-variable-length-parameters-of){.selfRef}

    ::: {#section-3.3.5-4.6.3 .alignCenter .art-text .artwork}
         0                   1                   2                   3
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |    Heartbeat Info Type = 1    |        HB Info Length         |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        /                Sender-Specific Heartbeat Info                 /
        \                                                               \
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    [¶](#section-3.3.5-4.6.3){.pilcrow}
    :::

    The Sender-Specific Heartbeat Info field [SHOULD]{.bcp14} include
    information about the sender\'s current time when this HEARTBEAT
    chunk is sent and the destination transport address to which this
    HEARTBEAT chunk is sent (see [Section
    8.3](#sec_path_heartbeat){.xref}). This information is simply
    reflected back by the receiver in the HEARTBEAT ACK chunk (see
    [Section 3.3.6](#sec_heartbeat_ack_chunk){.xref}). Note also that
    the HEARTBEAT chunk is both for reachability checking and for path
    verification (see [Section 5.4](#sec_path_verifiation){.xref}). When
    a HEARTBEAT chunk is being used for path verification purposes, it
    [MUST]{.bcp14} include a random nonce of length 64 bits or longer
    (\[[RFC4086](#RFC4086){.xref}\] provides some information on
    randomness guidelines).[¶](#section-3.3.5-4.6.4){.pilcrow}

:   
:::
:::

::: {#sec_heartbeat_ack_chunk}
::: {#section-3.3.6 .section}
#### [3.3.6.](#section-3.3.6){.section-number .selfRef} [Heartbeat Acknowledgement (HEARTBEAT ACK) (5)](#name-heartbeat-acknowledgement-h){.section-name .selfRef} {#name-heartbeat-acknowledgement-h}

An endpoint [MUST]{.bcp14} send this chunk to its peer endpoint as a
response to a HEARTBEAT chunk (see [Section
8.3](#sec_path_heartbeat){.xref}). A packet containing the HEARTBEAT ACK
chunk is always sent to the source IP address of the IP datagram
containing the HEARTBEAT chunk to which this HEARTBEAT ACK chunk is
responding.[¶](#section-3.3.6-1){.pilcrow}

The parameter field contains a variable-length opaque data
structure.[¶](#section-3.3.6-2){.pilcrow}

::: {#section-3.3.6-3 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 5    |  Chunk Flags  |     Heartbeat Ack Length      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    \                                                               \
    /          Heartbeat Information TLV (Variable-Length)          /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.6-3){.pilcrow}
:::

[]{.break}

Chunk Flags: 8 bits
:   Set to 0 on transmit and ignored on
    receipt.[¶](#section-3.3.6-4.2){.pilcrow}
:   

Heartbeat Ack Length: 16 bits (unsigned integer)
:   Set to the size of the chunk in bytes, including the chunk header
    and the Heartbeat Information
    field.[¶](#section-3.3.6-4.4){.pilcrow}
:   

Heartbeat Information: variable length

:   This field [MUST]{.bcp14} contain the Heartbeat Info parameter (as
    defined in [Section 3.3.5](#sec_heartbeat_chunk){.xref}) of the
    Heartbeat Request to which this Heartbeat Acknowledgement is
    responding.[¶](#section-3.3.6-4.6.1){.pilcrow}

    []{#name-variable-length-parameters-of-}

      Variable Parameters   Status      Type Value
      --------------------- ----------- ------------
      Heartbeat Info        Mandatory   1

      : [Table 10](#table-10){.selfRef}: [Variable-Length Parameters of
      HEARTBEAT ACK
      Chunks](#name-variable-length-parameters-of-){.selfRef}

:   
:::
:::

::: {#sec_abort_chunk}
::: {#section-3.3.7 .section}
#### [3.3.7.](#section-3.3.7){.section-number .selfRef} [Abort Association (ABORT) (6)](#name-abort-association-abort-6){.section-name .selfRef} {#name-abort-association-abort-6}

The ABORT chunk is sent to the peer of an association to close the
association. The ABORT chunk [MAY]{.bcp14} contain error causes to
inform the receiver about the reason of the abort. DATA chunks [MUST
NOT]{.bcp14} be bundled with ABORT chunks. Control chunks (except for
INIT, INIT ACK, and SHUTDOWN COMPLETE) [MAY]{.bcp14} be bundled with an
ABORT chunk, but they [MUST]{.bcp14} be placed before the ABORT chunk in
the SCTP packet; otherwise, they will be ignored by the
receiver.[¶](#section-3.3.7-1){.pilcrow}

If an endpoint receives an ABORT chunk with a format error or no TCB is
found, it [MUST]{.bcp14} silently discard it. Moreover, under any
circumstances, an endpoint that receives an ABORT chunk [MUST
NOT]{.bcp14} respond to that ABORT chunk by sending an ABORT chunk of
its own.[¶](#section-3.3.7-2){.pilcrow}

::: {#section-3.3.7-3 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 6    |  Reserved   |T|            Length             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    \                                                               \
    /                   zero or more Error Causes                   /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.7-3){.pilcrow}
:::

[]{.break}

Chunk Flags: 8 bits
:   []{.break}

    Reserved: 7 bits
    :   Set to 0 on transmit and ignored on
        receipt.[¶](#section-3.3.7-4.2.1.2){.pilcrow}
    :   

    T bit: 1 bit
    :   The T bit is set to 0 if the sender filled in the Verification
        Tag expected by the peer. If the Verification Tag is reflected,
        the T bit [MUST]{.bcp14} be set to 1. Reflecting means that the
        sent Verification Tag is the same as the received
        one.[¶](#section-3.3.7-4.2.1.4){.pilcrow}
    :   
:   

Length: 16 bits (unsigned integer)
:   Set to the size of the chunk in bytes, including the chunk header
    and all the Error Cause fields
    present.[¶](#section-3.3.7-4.4){.pilcrow}
:   

See [Section 3.3.10](#sec_error_chunk){.xref} for Error Cause
definitions.[¶](#section-3.3.7-5){.pilcrow}

Note: Special rules apply to this chunk for verification; please see
[Section 8.5.1](#sec_exceptions_in_verification_tag_rules){.xref} for
details.[¶](#section-3.3.7-6){.pilcrow}
:::
:::

::: {#sec_shutdown_chunk}
::: {#section-3.3.8 .section}
#### [3.3.8.](#section-3.3.8){.section-number .selfRef} [Shutdown Association (SHUTDOWN) (7)](#name-shutdown-association-shutdo){.section-name .selfRef} {#name-shutdown-association-shutdo}

An endpoint in an association [MUST]{.bcp14} use this chunk to initiate
a graceful close of the association with its peer. This chunk has the
following format.[¶](#section-3.3.8-1){.pilcrow}

::: {#section-3.3.8-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 7    |  Chunk Flags  |          Length = 8           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                      Cumulative TSN Ack                       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.8-2){.pilcrow}
:::

[]{.break}

Chunk Flags: 8 bits
:   Set to 0 on transmit and ignored on
    receipt.[¶](#section-3.3.8-3.2){.pilcrow}
:   

Length: 16 bits (unsigned integer)
:   Indicates the length of the parameter. Set to
    8.[¶](#section-3.3.8-3.4){.pilcrow}
:   

Cumulative TSN Ack: 32 bits (unsigned integer)
:   The largest TSN, such that all TSNs smaller than or equal to it have
    been received and the next one has not been
    received.[¶](#section-3.3.8-3.6){.pilcrow}
:   

Note: Since the SHUTDOWN chunk does not contain Gap Ack Blocks, it
cannot be used to acknowledge TSNs received out of order. In a SACK
chunk, lack of Gap Ack Blocks that were previously included indicates
that the data receiver reneged on the associated DATA
chunks.[¶](#section-3.3.8-4){.pilcrow}

Since the SHUTDOWN chunk does not contain Gap Ack Blocks, the receiver
of the SHUTDOWN chunk [MUST NOT]{.bcp14} interpret the lack of a Gap Ack
Block as a renege. (See [Section
6.2](#sec_acknowledgements_of_reception_of_data_chunks){.xref} for
information on reneging.)[¶](#section-3.3.8-5){.pilcrow}

The sender of the SHUTDOWN chunk [MAY]{.bcp14} bundle a SACK chunk to
indicate any gaps in the received TSNs.[¶](#section-3.3.8-6){.pilcrow}
:::
:::

::: {#sec_shutdown_ack_chunk}
::: {#section-3.3.9 .section}
#### [3.3.9.](#section-3.3.9){.section-number .selfRef} [Shutdown Acknowledgement (SHUTDOWN ACK) (8)](#name-shutdown-acknowledgement-sh){.section-name .selfRef} {#name-shutdown-acknowledgement-sh}

This chunk [MUST]{.bcp14} be used to acknowledge the receipt of the
SHUTDOWN chunk at the completion of the shutdown process; see [Section
9.2](#sec_shutdown_of_an_association){.xref} for
details.[¶](#section-3.3.9-1){.pilcrow}

The SHUTDOWN ACK chunk has no parameters.[¶](#section-3.3.9-2){.pilcrow}

::: {#section-3.3.9-3 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 8    |  Chunk Flags  |          Length = 4           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.9-3){.pilcrow}
:::

[]{.break}

Chunk Flags: 8 bits
:   Set to 0 on transmit and ignored on
    receipt.[¶](#section-3.3.9-4.2){.pilcrow}
:   
:::
:::

::: {#sec_error_chunk}
::: {#section-3.3.10 .section}
#### [3.3.10.](#section-3.3.10){.section-number .selfRef} [Operation Error (ERROR) (9)](#name-operation-error-error-9){.section-name .selfRef} {#name-operation-error-error-9}

An endpoint sends this chunk to its peer endpoint to notify it of
certain error conditions. It contains one or more error causes. An
Operation Error is not considered fatal in and of itself, but the
corresponding error cause [MAY]{.bcp14} be used with an ABORT chunk to
report a fatal condition. An ERROR chunk has the following
format:[¶](#section-3.3.10-1){.pilcrow}

::: {#section-3.3.10-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 9    |  Chunk Flags  |            Length             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    \                                                               \
    /                   one or more Error Causes                    /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.10-2){.pilcrow}
:::

[]{.break}

Chunk Flags: 8 bits
:   Set to 0 on transmit and ignored on
    receipt.[¶](#section-3.3.10-3.2){.pilcrow}
:   

Length: 16 bits (unsigned integer)
:   Set to the size of the chunk in bytes, including the chunk header
    and all the Error Cause fields
    present.[¶](#section-3.3.10-3.4){.pilcrow}
:   

Error causes are defined as variable-length parameters using the format
described in [Section 3.2.1](#sec_parameter_format){.xref}, that
is:[¶](#section-3.3.10-4){.pilcrow}

::: {#section-3.3.10-5 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          Cause Code           |         Cause Length          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                  Cause-Specific Information                   /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.10-5){.pilcrow}
:::

[]{.break}

Cause Code: 16 bits (unsigned integer)

:   Defines the type of error conditions being
    reported.[¶](#section-3.3.10-6.2.1){.pilcrow}

    []{#name-cause-code}

      Value   Cause Code
      ------- ----------------------------------------------
      1       Invalid Stream Identifier
      2       Missing Mandatory Parameter
      3       Stale Cookie
      4       Out of Resource
      5       Unresolvable Address
      6       Unrecognized Chunk Type
      7       Invalid Mandatory Parameter
      8       Unrecognized Parameters
      9       No User Data
      10      Cookie Received While Shutting Down
      11      Restart of an Association with New Addresses
      12      User-Initiated Abort
      13      Protocol Violation

      : [Table 11](#table-11){.selfRef}: [Cause
      Code](#name-cause-code){.selfRef}

:   

Cause Length: 16 bits (unsigned integer)
:   Set to the size of the parameter in bytes, including the Cause Code,
    Cause Length, and Cause-Specific Information
    fields.[¶](#section-3.3.10-6.4){.pilcrow}
:   

Cause-Specific Information: variable length
:   This field carries the details of the error
    condition.[¶](#section-3.3.10-6.6){.pilcrow}
:   

Sections [3.3.10.1](#sec_invalid_stream_identifier_cause){.xref} -
[3.3.10.13](#sec_protocol_violation_cause){.xref} define error causes
for SCTP. Guidelines for the IETF to define new error cause values are
discussed in [Section
15.4](#sec_ietf_defined_additional_error_causes){.xref}.[¶](#section-3.3.10-7){.pilcrow}

::: {#sec_invalid_stream_identifier_cause}
::: {#section-3.3.10.1 .section}
##### [3.3.10.1.](#section-3.3.10.1){.section-number .selfRef} [Invalid Stream Identifier (1)](#name-invalid-stream-identifier-1){.section-name .selfRef} {#name-invalid-stream-identifier-1}

Indicates that the endpoint received a DATA chunk sent using a
nonexistent stream.[¶](#section-3.3.10.1-1){.pilcrow}

::: {#section-3.3.10.1-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Cause Code = 1         |       Cause Length = 8        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |       Stream Identifier       |          (Reserved)           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.10.1-2){.pilcrow}
:::

[]{.break}

Stream Identifier: 16 bits (unsigned integer)
:   Contains the Stream Identifier of the DATA chunk received in
    error.[¶](#section-3.3.10.1-3.2){.pilcrow}
:   

Reserved: 16 bits
:   This field is reserved. It is set to all 0\'s on transmit and
    ignored on receipt.[¶](#section-3.3.10.1-3.4){.pilcrow}
:   
:::
:::

::: {#sec_missing_mandatory_parameter_cause}
::: {#section-3.3.10.2 .section}
##### [3.3.10.2.](#section-3.3.10.2){.section-number .selfRef} [Missing Mandatory Parameter (2)](#name-missing-mandatory-parameter){.section-name .selfRef} {#name-missing-mandatory-parameter}

Indicates that one or more mandatory TLV parameters are missing in a
received INIT or INIT ACK chunk.[¶](#section-3.3.10.2-1){.pilcrow}

::: {#section-3.3.10.2-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Cause Code = 2         |   Cause Length = 8 + N * 2    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                 Number of missing params = N                  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Missing Param Type #1     |     Missing Param Type #2     |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Missing Param Type #N-1    |     Missing Param Type #N     |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.10.2-2){.pilcrow}
:::

[]{.break}

Number of Missing params: 32 bits (unsigned integer)
:   This field contains the number of parameters contained in the
    Cause-Specific Information
    field.[¶](#section-3.3.10.2-3.2){.pilcrow}
:   

Missing Param Type: 16 bits (unsigned integer)
:   Each field will contain the missing mandatory parameter
    number.[¶](#section-3.3.10.2-3.4){.pilcrow}
:   
:::
:::

::: {#sec_stale_cookie_error_cause}
::: {#section-3.3.10.3 .section}
##### [3.3.10.3.](#section-3.3.10.3){.section-number .selfRef} [Stale Cookie (3)](#name-stale-cookie-3){.section-name .selfRef} {#name-stale-cookie-3}

Indicates the receipt of a valid State Cookie that has
expired.[¶](#section-3.3.10.3-1){.pilcrow}

::: {#section-3.3.10.3-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Cause Code = 3         |       Cause Length = 8        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                 Measure of Staleness (usec.)                  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.10.3-2){.pilcrow}
:::

[]{.break}

Measure of Staleness: 32 bits (unsigned integer)

:   This field contains the difference, rounded up in microseconds,
    between the current time and the time the State Cookie
    expired.[¶](#section-3.3.10.3-3.2.1){.pilcrow}

    The sender of this error cause [MAY]{.bcp14} choose to report how
    long past expiration the State Cookie is by including a non-zero
    value in the Measure of Staleness field. If the sender does not wish
    to provide the Measure of Staleness, it [SHOULD]{.bcp14} set this
    field to the value of zero.[¶](#section-3.3.10.3-3.2.2){.pilcrow}

:   
:::
:::

::: {#sec_out_of_resource_cause}
::: {#section-3.3.10.4 .section}
##### [3.3.10.4.](#section-3.3.10.4){.section-number .selfRef} [Out of Resource (4)](#name-out-of-resource-4){.section-name .selfRef} {#name-out-of-resource-4}

Indicates that the sender is out of resource. This is usually sent in
combination with or within an ABORT
chunk.[¶](#section-3.3.10.4-1){.pilcrow}

::: {#section-3.3.10.4-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Cause Code = 4         |       Cause Length = 4        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.10.4-2){.pilcrow}
:::
:::
:::

::: {#sec_unresolvable_address_cause}
::: {#section-3.3.10.5 .section}
##### [3.3.10.5.](#section-3.3.10.5){.section-number .selfRef} [Unresolvable Address (5)](#name-unresolvable-address-5){.section-name .selfRef} {#name-unresolvable-address-5}

Indicates that the sender is not able to resolve the specified address
parameter (e.g., type of address is not supported by the sender). This
is usually sent in combination with or within an ABORT
chunk.[¶](#section-3.3.10.5-1){.pilcrow}

::: {#section-3.3.10.5-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Cause Code = 5         |         Cause Length          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                     Unresolvable Address                      /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.10.5-2){.pilcrow}
:::

[]{.break}

Unresolvable Address: variable length
:   The Unresolvable Address field contains the complete Type, Length,
    and Value of the address parameter (or Host Name parameter) that
    contains the unresolvable address or host
    name.[¶](#section-3.3.10.5-3.2){.pilcrow}
:   
:::
:::

::: {#sec_unrecognized_chunk_type_cause}
::: {#section-3.3.10.6 .section}
##### [3.3.10.6.](#section-3.3.10.6){.section-number .selfRef} [Unrecognized Chunk Type (6)](#name-unrecognized-chunk-type-6){.section-name .selfRef} {#name-unrecognized-chunk-type-6}

This error cause is returned to the originator of the chunk if the
receiver does not understand the chunk and the upper bits of the \'Chunk
Type\' are set to 01 or 11.[¶](#section-3.3.10.6-1){.pilcrow}

::: {#section-3.3.10.6-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Cause Code = 6         |         Cause Length          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                      Unrecognized Chunk                       /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.10.6-2){.pilcrow}
:::

[]{.break}

Unrecognized Chunk: variable length
:   The Unrecognized Chunk field contains the unrecognized chunk from
    the SCTP packet complete with Chunk Type, Chunk Flags, and Chunk
    Length.[¶](#section-3.3.10.6-3.2){.pilcrow}
:   
:::
:::

::: {#sec_invalid_mandatory_parameter_cause}
::: {#section-3.3.10.7 .section}
##### [3.3.10.7.](#section-3.3.10.7){.section-number .selfRef} [Invalid Mandatory Parameter (7)](#name-invalid-mandatory-parameter){.section-name .selfRef} {#name-invalid-mandatory-parameter}

This error cause is returned to the originator of an INIT or INIT ACK
chunk when one of the mandatory parameters is set to an invalid
value.[¶](#section-3.3.10.7-1){.pilcrow}

::: {#section-3.3.10.7-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Cause Code = 7         |       Cause Length = 4        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.10.7-2){.pilcrow}
:::
:::
:::

::: {#sec_unrecongnized_parameters}
::: {#section-3.3.10.8 .section}
##### [3.3.10.8.](#section-3.3.10.8){.section-number .selfRef} [Unrecognized Parameters (8)](#name-unrecognized-parameters-8){.section-name .selfRef} {#name-unrecognized-parameters-8}

This error cause is returned to the originator of the INIT ACK chunk if
the receiver does not recognize one or more Optional TLV parameters in
the INIT ACK chunk.[¶](#section-3.3.10.8-1){.pilcrow}

::: {#section-3.3.10.8-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Cause Code = 8         |         Cause Length          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                    Unrecognized Parameters                    /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.10.8-2){.pilcrow}
:::

[]{.break}

Unrecognized Parameters: variable length
:   The Unrecognized Parameters field contains the unrecognized
    parameters copied from the INIT ACK chunk complete with TLV. This
    error cause is normally contained in an ERROR chunk bundled with the
    COOKIE ECHO chunk when responding to the INIT ACK chunk, when the
    sender of the COOKIE ECHO chunk wishes to report unrecognized
    parameters.[¶](#section-3.3.10.8-3.2){.pilcrow}
:   
:::
:::

::: {#sec_no_user_data_cause}
::: {#section-3.3.10.9 .section}
##### [3.3.10.9.](#section-3.3.10.9){.section-number .selfRef} [No User Data (9)](#name-no-user-data-9){.section-name .selfRef} {#name-no-user-data-9}

This error cause is returned to the originator of a DATA chunk if a
received DATA chunk has no user data.[¶](#section-3.3.10.9-1){.pilcrow}

::: {#section-3.3.10.9-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Cause Code = 9         |       Cause Length = 8        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                              TSN                              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.10.9-2){.pilcrow}
:::

[]{.break}

TSN: 32 bits (unsigned integer)
:   This parameter contains the TSN of the DATA chunk received with no
    User Data field.[¶](#section-3.3.10.9-3.2){.pilcrow}
:   

This cause code is normally returned in an ABORT chunk (see [Section
6.2](#sec_acknowledgements_of_reception_of_data_chunks){.xref}).[¶](#section-3.3.10.9-4){.pilcrow}
:::
:::

::: {#sec_cookie_received_while_shutting_down_cause}
::: {#section-3.3.10.10 .section}
##### [3.3.10.10.](#section-3.3.10.10){.section-number .selfRef} [Cookie Received While Shutting Down (10)](#name-cookie-received-while-shutt){.section-name .selfRef} {#name-cookie-received-while-shutt}

A COOKIE ECHO chunk was received while the endpoint was in the
SHUTDOWN-ACK-SENT state. This error is usually returned in an ERROR
chunk bundled with the retransmitted SHUTDOWN ACK
chunk.[¶](#section-3.3.10.10-1){.pilcrow}

::: {#section-3.3.10.10-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Cause Code = 10        |       Cause Length = 4        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.10.10-2){.pilcrow}
:::
:::
:::

::: {#sec_restart_with_new_addresses_cause}
::: {#section-3.3.10.11 .section}
##### [3.3.10.11.](#section-3.3.10.11){.section-number .selfRef} [Restart of an Association with New Addresses (11)](#name-restart-of-an-association-w){.section-name .selfRef} {#name-restart-of-an-association-w}

An INIT chunk was received on an existing association. But the INIT
chunk added addresses to the association that were previously not part
of the association. The new addresses are listed in the error cause.
This error cause is normally sent as part of an ABORT chunk refusing the
INIT chunk (see [Section
5.2](#sec_handle_duplicate_or_unexpected_chunks){.xref}).[¶](#section-3.3.10.11-1){.pilcrow}

::: {#section-3.3.10.11-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Cause Code = 11        |         Cause Length          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                       New Address TLVs                        /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.10.11-2){.pilcrow}
:::

Note: Each New Address TLV is an exact copy of the TLV that was found in
the INIT chunk that was new, including the Parameter Type and the
Parameter Length.[¶](#section-3.3.10.11-3){.pilcrow}
:::
:::

::: {#sec_user_initiated_abort_cause}
::: {#section-3.3.10.12 .section}
##### [3.3.10.12.](#section-3.3.10.12){.section-number .selfRef} [User-Initiated Abort (12)](#name-user-initiated-abort-12){.section-name .selfRef} {#name-user-initiated-abort-12}

This error cause [MAY]{.bcp14} be included in ABORT chunks that are sent
because of an upper-layer request. The upper layer can specify an Upper
Layer Abort Reason that is transported by SCTP transparently and
[MAY]{.bcp14} be delivered to the upper-layer protocol at the
peer.[¶](#section-3.3.10.12-1){.pilcrow}

::: {#section-3.3.10.12-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Cause Code = 12        |         Cause Length          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                   Upper Layer Abort Reason                    /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.10.12-2){.pilcrow}
:::
:::
:::

::: {#sec_protocol_violation_cause}
::: {#section-3.3.10.13 .section}
##### [3.3.10.13.](#section-3.3.10.13){.section-number .selfRef} [Protocol Violation (13)](#name-protocol-violation-13){.section-name .selfRef} {#name-protocol-violation-13}

This error cause [MAY]{.bcp14} be included in ABORT chunks that are sent
because an SCTP endpoint detects a protocol violation of the peer that
is not covered by the error causes described in Sections
[3.3.10.1](#sec_invalid_stream_identifier_cause){.xref} -
[3.3.10.12](#sec_user_initiated_abort_cause){.xref}. An implementation
[MAY]{.bcp14} provide additional information specifying what kind of
protocol violation has been detected.[¶](#section-3.3.10.13-1){.pilcrow}

::: {#section-3.3.10.13-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |         Cause Code = 13         |        Cause Length         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                    Additional Information                     /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.10.13-2){.pilcrow}
:::
:::
:::
:::
:::

::: {#sec_cookie_echo_chunk}
::: {#section-3.3.11 .section}
#### [3.3.11.](#section-3.3.11){.section-number .selfRef} [Cookie Echo (COOKIE ECHO) (10)](#name-cookie-echo-cookie-echo-10){.section-name .selfRef} {#name-cookie-echo-cookie-echo-10}

This chunk is used only during the initialization of an association. It
is sent by the initiator of an association to its peer to complete the
initialization process. This chunk [MUST]{.bcp14} precede any DATA chunk
sent within the association but [MAY]{.bcp14} be bundled with one or
more DATA chunks in the same packet.[¶](#section-3.3.11-1){.pilcrow}

::: {#section-3.3.11-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 10   |  Chunk Flags  |            Length             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                            Cookie                             /
    \                                                               \
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.11-2){.pilcrow}
:::

[]{.break}

Chunk Flags: 8 bits
:   Set to 0 on transmit and ignored on
    receipt.[¶](#section-3.3.11-3.2){.pilcrow}
:   

Length: 16 bits (unsigned integer)
:   Set to the size of the chunk in bytes, including the 4 bytes of the
    chunk header and the size of the
    cookie.[¶](#section-3.3.11-3.4){.pilcrow}
:   

Cookie: variable size

:   This field [MUST]{.bcp14} contain the exact cookie received in the
    State Cookie parameter from the previous INIT ACK
    chunk.[¶](#section-3.3.11-3.6.1){.pilcrow}

    An implementation [SHOULD]{.bcp14} make the cookie as small as
    possible to ensure
    interoperability.[¶](#section-3.3.11-3.6.2){.pilcrow}

    Note: A Cookie Echo does not contain a State Cookie parameter;
    instead, the data within the State Cookie\'s Parameter Value becomes
    the data within the Cookie Echo\'s Chunk Value. This allows an
    implementation to change only the first 2 bytes of the State Cookie
    parameter to become a COOKIE ECHO
    chunk.[¶](#section-3.3.11-3.6.3){.pilcrow}

:   
:::
:::

::: {#sec_cookie_ack_chunk}
::: {#section-3.3.12 .section}
#### [3.3.12.](#section-3.3.12){.section-number .selfRef} [Cookie Acknowledgement (COOKIE ACK) (11)](#name-cookie-acknowledgement-cook){.section-name .selfRef} {#name-cookie-acknowledgement-cook}

This chunk is used only during the initialization of an association. It
is used to acknowledge the receipt of a COOKIE ECHO chunk. This chunk
[MUST]{.bcp14} precede any DATA or SACK chunk sent within the
association but [MAY]{.bcp14} be bundled with one or more DATA chunks or
SACK chunk\'s in the same SCTP packet.[¶](#section-3.3.12-1){.pilcrow}

::: {#section-3.3.12-2 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 11   |  Chunk Flags  |          Length = 4           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.12-2){.pilcrow}
:::

[]{.break}

Chunk Flags: 8 bits
:   Set to 0 on transmit and ignored on
    receipt.[¶](#section-3.3.12-3.2){.pilcrow}
:   
:::
:::

::: {#sec_shutdown_complete_chunk}
::: {#section-3.3.13 .section}
#### [3.3.13.](#section-3.3.13){.section-number .selfRef} [Shutdown Complete (SHUTDOWN COMPLETE) (14)](#name-shutdown-complete-shutdown-){.section-name .selfRef} {#name-shutdown-complete-shutdown-}

This chunk [MUST]{.bcp14} be used to acknowledge the receipt of the
SHUTDOWN ACK chunk at the completion of the shutdown process; see
[Section 9.2](#sec_shutdown_of_an_association){.xref} for
details.[¶](#section-3.3.13-1){.pilcrow}

The SHUTDOWN COMPLETE chunk has no
parameters.[¶](#section-3.3.13-2){.pilcrow}

::: {#section-3.3.13-3 .alignCenter .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 14   |  Reserved   |T|          Length = 4           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-3.3.13-3){.pilcrow}
:::

[]{.break}

Chunk Flags: 8 bits
:   []{.break}

    Reserved: 7 bits
    :   Set to 0 on transmit and ignored on
        receipt.[¶](#section-3.3.13-4.2.1.2){.pilcrow}
    :   

    T bit: 1 bit
    :   The T bit is set to 0 if the sender filled in the Verification
        Tag expected by the peer. If the Verification Tag is reflected,
        the T bit [MUST]{.bcp14} be set to 1. Reflecting means that the
        sent Verification Tag is the same as the received
        one.[¶](#section-3.3.13-4.2.1.4){.pilcrow}
    :   
:   

Note: Special rules apply to this chunk for verification; please see
[Section 8.5.1](#sec_exceptions_in_verification_tag_rules){.xref} for
details.[¶](#section-3.3.13-5){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#sec_sctp_assoc_diagram}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [SCTP Association State Diagram](#name-sctp-association-state-diag){.section-name .selfRef} {#name-sctp-association-state-diag}

During the life time of an SCTP association, the SCTP endpoint\'s
association progresses from one state to another in response to various
events. The events that might potentially advance an association\'s
state include:[¶](#section-4-1){.pilcrow}

-   ::: {#section-4-2.1}
    SCTP user primitive calls, e.g., \[ASSOCIATE\], \[SHUTDOWN\], or
    \[ABORT\],[¶](#section-4-2.1.1){.pilcrow}
    :::

-   ::: {#section-4-2.2}
    reception of INIT, COOKIE ECHO, ABORT, SHUTDOWN, etc., and control
    chunks, or[¶](#section-4-2.2.1){.pilcrow}
    :::

-   ::: {#section-4-2.3}
    some timeout events.[¶](#section-4-2.3.1){.pilcrow}
    :::

The state diagram in the figures below illustrates state changes,
together with the causing events and resulting actions. Note that some
of the error conditions are not shown in the state diagram. Full
descriptions of all special cases are found in the
text.[¶](#section-4-3){.pilcrow}

Note: Chunk names are given in all capital letters, while parameter
names have the first letter capitalized, e.g., COOKIE ECHO chunk type
vs. State Cookie parameter. If more than one event/message can occur
that causes a state transition, it is labeled (A) or
(B).[¶](#section-4-4){.pilcrow}

[]{#name-state-transition-diagram-of}

::: {#fig_state_diagram}
::: {#section-4-5.1 .alignCenter .art-text .artwork}
                            -----          -------- (from any state)
                          /       \      /receive ABORT      [ABORT]
            receive INIT |         |    |--------------  or ----------
    ---------------------|         v    v    delete TCB     send ABORT
    generate State Cookie \    +---------+                  delete TCB
            send INIT ACK   ---|  CLOSED |
                               +---------+
                                 /      \
                                /        \  [ASSOCIATE]
                               |          |-----------------
                               |          | create TCB
                               |          | send INIT
              receive valid    |          | start T1-init timer
              COOKIE  ECHO     |          v
          (1) -----------------|    +-----------+
              create TCB       |    |COOKIE-WAIT| (2)
              send COOKIE ACK  |    +-----------+
                               |          |
                               |          | receive INIT ACK
                               |          |-------------------
                               |          | send COOKIE ECHO
                               |          | stop T1-init timer
                               |          | start T1-cookie timer
                               |          v
                               |   +-------------+
                               |   |COOKIE-ECHOED| (3)
                               |   +-------------+
                               |          |
                               |          | receive COOKIE ACK
                               |          |-------------------
                               |          | stop T1-cookie timer
                               v          v
                             +---------------+
                             |  ESTABLISHED  |
                             +---------------+
                                     |
                                     |
                            /--------+--------\
        [SHUTDOWN]         /                   \
        -------------------|                   |
        check outstanding  |                   |
        DATA chunks        |                   |
                           v                   |
                  +----------------+           |
                  |SHUTDOWN-PENDING|           | receive SHUTDOWN
                  +----------------+           |------------------
                                               | check outstanding
                           |                   | DATA chunks
    No more outstanding    |                   |
    -----------------------|                   |
    send SHUTDOWN          |                   |
    start T2-shutdown timer|                   |
                           v                   v
                    +-------------+   +-----------------+
                (4) |SHUTDOWN-SENT|   |SHUTDOWN-RECEIVED| (5,6)
                    +-------------+   +-----------------+
                           |  \                |
    receive SHUTDOWN ACK   |   \               |
    -----------------------|    \              |
    stop T2-shutdown timer |     \             |
    send SHUTDOWN COMPLETE |      \            |
    delete TCB             |       \           |
                           |        \          | No more outstanding
                           |         \         |--------------------
                           |          \        | send SHUTDOWN ACK
    receive SHUTDOWN      -|-          \       | start T2-shutdown timer
    --------------------/  | \----------\      |
    send SHUTDOWN ACK      |             \     |
    start T2-shutdown timer|              \    |
                           |               \   |
                           |                |  |
                           |                v  v
                           |          +-----------------+
                           |          |SHUTDOWN-ACK-SENT| (7)
                           |          +-----------------+
                           |                   | (A)
                           |                   |receive SHUTDOWN COMPLETE
                           |                   |-------------------------
                           |                   | stop T2-shutdown timer
                           |                   | delete TCB
                           |                   |
                           |                   | (B)
                           |                   | receive SHUTDOWN ACK
                           |                   |-----------------------
                           |                   | stop T2-shutdown timer
                           |                   | send SHUTDOWN COMPLETE
                           |                   | delete TCB
                           |                   |
                           \    +---------+    /
                            \-->| CLOSED  |<--/
                                +---------+
:::

[Figure 3](#figure-3){.selfRef}: [State Transition Diagram of
SCTP](#name-state-transition-diagram-of){.selfRef}
:::

The following applies:[¶](#section-4-6){.pilcrow}

[]{.break}

1\)

:   If the State Cookie in the received COOKIE ECHO chunk is invalid
    (i.e., failed to pass the integrity check), the receiver
    [MUST]{.bcp14} silently discard the packet. Or, if the received
    State Cookie is expired (see [Section
    5.1.5](#sec_state_coockie_authentication){.xref}), the receiver
    [MUST]{.bcp14} send back an ERROR chunk. In either case, the
    receiver stays in the CLOSED state.[¶](#section-4-7.1.1){.pilcrow}

:   

2\)

:   If the T1-init timer expires, the endpoint [MUST]{.bcp14} retransmit
    the INIT chunk and restart the T1-init timer. The endpoint stays in
    the COOKIE-WAIT state. This [MUST]{.bcp14} be repeated up to
    \'Max.Init.Retransmits\' times. After that, the endpoint
    [MUST]{.bcp14} abort the initialization process and report the error
    to the SCTP user.[¶](#section-4-7.2.1){.pilcrow}

:   

3\)

:   If the T1-cookie timer expires, the endpoint [MUST]{.bcp14}
    retransmit COOKIE ECHO chunk and restart the T1-cookie timer. The
    endpoint stays in the COOKIE-ECHOED state. This [MUST]{.bcp14} be
    repeated up to \'Max.Init.Retransmits\' times. After that, the
    endpoint [MUST]{.bcp14} abort the initialization process and report
    the error to the SCTP user.[¶](#section-4-7.3.1){.pilcrow}

:   

4\)

:   In the SHUTDOWN-SENT state, the endpoint [MUST]{.bcp14} acknowledge
    any received DATA chunks without
    delay.[¶](#section-4-7.4.1){.pilcrow}

:   

5\)

:   In the SHUTDOWN-RECEIVED state, the endpoint [MUST NOT]{.bcp14}
    accept any new send requests from its SCTP
    user.[¶](#section-4-7.5.1){.pilcrow}

:   

6\)

:   In the SHUTDOWN-RECEIVED state, the endpoint [MUST]{.bcp14} transmit
    or retransmit data and leave this state when all data in queue is
    transmitted.[¶](#section-4-7.6.1){.pilcrow}

:   

7\)

:   In the SHUTDOWN-ACK-SENT state, the endpoint [MUST NOT]{.bcp14}
    accept any new send requests from its SCTP
    user.[¶](#section-4-7.7.1){.pilcrow}

:   

The CLOSED state is used to indicate that an association is not created
(i.e., does not exist).[¶](#section-4-8){.pilcrow}
:::
:::

::: {#sec_assoc_initialization}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Association Initialization](#name-association-initialization){.section-name .selfRef} {#name-association-initialization}

Before the first data transmission can take place from one SCTP endpoint
(\"A\") to another SCTP endpoint (\"Z\"), the two endpoints
[MUST]{.bcp14} complete an initialization process in order to set up an
SCTP association between them.[¶](#section-5-1){.pilcrow}

The SCTP user at an endpoint can use the ASSOCIATE primitive to
initialize an SCTP association to another SCTP
endpoint.[¶](#section-5-2){.pilcrow}

Implementation Note: From an SCTP user\'s point of view, an association
might be implicitly opened, without an ASSOCIATE primitive (see [Section
11.1.2](#sec_associate){.xref}) being invoked, by the initiating
endpoint\'s sending of the first user data to the destination endpoint.
The initiating SCTP will assume default values for all mandatory and
optional parameters for the INIT/INIT ACK
chunk.[¶](#section-5-3){.pilcrow}

Once the association is established, unidirectional streams are open for
data transfer on both ends (see [Section
5.1.1](#sec_handle_stream_parameters){.xref}).[¶](#section-5-4){.pilcrow}

::: {#sec_normal_establishment}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Normal Establishment of an Association](#name-normal-establishment-of-an-){.section-name .selfRef} {#name-normal-establishment-of-an-}

The initialization process consists of the following steps (assuming
that SCTP endpoint \"A\" tries to set up an association with SCTP
endpoint \"Z\" and \"Z\" accepts the new
association):[¶](#section-5.1-1){.pilcrow}

[]{.break}

A\)

:   \"A\" first builds a TCB and sends an INIT chunk to \"Z\". In the
    INIT chunk, \"A\" [MUST]{.bcp14} provide its Verification Tag
    (Tag_A) in the Initiate Tag field. Tag_A [SHOULD]{.bcp14} be a
    random number in the range of 1 to 4294967295 (see [Section
    5.3.1](#sec_selection_of_tag_value){.xref} for Tag value selection).
    After sending the INIT chunk, \"A\" starts the T1-init timer and
    enters the COOKIE-WAIT state.[¶](#section-5.1-2.1.1){.pilcrow}

:   

B\)

:   \"Z\" responds immediately with an INIT ACK chunk. The destination
    IP address of the INIT ACK chunk [MUST]{.bcp14} be set to the source
    IP address of the INIT chunk to which this INIT ACK chunk is
    responding. In the response, besides filling in other parameters,
    \"Z\" [MUST]{.bcp14} set the Verification Tag field to Tag_A and
    also provide its own Verification Tag (Tag_Z) in the Initiate Tag
    field.[¶](#section-5.1-2.2.1){.pilcrow}

    Moreover, \"Z\" [MUST]{.bcp14} generate and send along with the INIT
    ACK chunk a State Cookie. See [Section
    5.1.3](#sec_generating_state_cookie){.xref} for State Cookie
    generation.[¶](#section-5.1-2.2.2){.pilcrow}

    After sending an INIT ACK chunk with the State Cookie parameter,
    \"Z\" [MUST NOT]{.bcp14} allocate any resources or keep any states
    for the new association. Otherwise, \"Z\" will be vulnerable to
    resource attacks.[¶](#section-5.1-2.2.3){.pilcrow}

:   

C\)

:   Upon reception of the INIT ACK chunk from \"Z\", \"A\" stops the
    T1-init timer and leaves the COOKIE-WAIT state. \"A\" then sends the
    State Cookie received in the INIT ACK chunk in a COOKIE ECHO chunk,
    starts the T1-cookie timer, and enters the COOKIE-ECHOED
    state.[¶](#section-5.1-2.3.1){.pilcrow}

    The COOKIE ECHO chunk [MAY]{.bcp14} be bundled with any pending
    outbound DATA chunks, but it [MUST]{.bcp14} be the first chunk in
    the packet and, until the COOKIE ACK chunk is returned, the sender
    [MUST NOT]{.bcp14} send any other packets to the
    peer.[¶](#section-5.1-2.3.2){.pilcrow}

:   

D\)

:   Upon reception of the COOKIE ECHO chunk, endpoint \"Z\" replies with
    a COOKIE ACK chunk after building a TCB and moving to the
    ESTABLISHED state. A COOKIE ACK chunk [MAY]{.bcp14} be bundled with
    any pending DATA chunks (and/or SACK chunks), but the COOKIE ACK
    chunk [MUST]{.bcp14} be the first chunk in the
    packet.[¶](#section-5.1-2.4.1){.pilcrow}

    Implementation Note: An implementation can choose to send the
    COMMUNICATION UP notification to the SCTP user upon reception of a
    valid COOKIE ECHO chunk.[¶](#section-5.1-2.4.2){.pilcrow}

:   

E\)

:   Upon reception of the COOKIE ACK chunk, endpoint \"A\" moves from
    the COOKIE-ECHOED state to the ESTABLISHED state, stopping the
    T1-cookie timer. It can also notify its ULP about the successful
    establishment of the association with a COMMUNICATION UP
    notification (see [Section
    11](#sec_api){.xref}).[¶](#section-5.1-2.5.1){.pilcrow}

:   

An INIT or INIT ACK chunk [MUST NOT]{.bcp14} be bundled with any other
chunk. They [MUST]{.bcp14} be the only chunks present in the SCTP
packets that carry them.[¶](#section-5.1-3){.pilcrow}

An endpoint [MUST]{.bcp14} send the INIT ACK chunk to the IP address
from which it received the INIT chunk.[¶](#section-5.1-4){.pilcrow}

The T1-init timer and T1-cookie timer [SHOULD]{.bcp14} follow the same
rules given in [Section
6.3](#sec_management_of_retransission_timer){.xref}. If the application
provided multiple IP addresses of the peer, there [SHOULD]{.bcp14} be a
T1-init and T1-cookie timer for each address of the peer.
Retransmissions of INIT chunks and COOKIE ECHO chunks [SHOULD]{.bcp14}
use all addresses of the peer similar to retransmissions of DATA
chunks.[¶](#section-5.1-5){.pilcrow}

If an endpoint receives an INIT, INIT ACK, or COOKIE ECHO chunk but
decides not to establish the new association due to missing mandatory
parameters in the received INIT or INIT ACK chunk, invalid parameter
values, or lack of local resources, it [SHOULD]{.bcp14} respond with an
ABORT chunk. It [SHOULD]{.bcp14} also specify the cause of abort, such
as the type of the missing mandatory parameters, etc., by including an
error cause in the ABORT chunk. The Verification Tag field in the common
header of the outbound SCTP packet containing the ABORT chunk
[MUST]{.bcp14} be set to the Initiate Tag value of the received INIT or
INIT ACK chunk this ABORT chunk is responding
to.[¶](#section-5.1-6){.pilcrow}

Note that a COOKIE ECHO chunk that does not pass the integrity check is
not considered an \'invalid mandatory parameter\' and requires special
handling; see [Section
5.1.5](#sec_state_coockie_authentication){.xref}.[¶](#section-5.1-7){.pilcrow}

After the reception of the first DATA chunk in an association, the
endpoint [MUST]{.bcp14} immediately respond with a SACK chunk to
acknowledge the DATA chunk. Subsequent acknowledgements [SHOULD]{.bcp14}
be done as described in [Section
6.2](#sec_acknowledgements_of_reception_of_data_chunks){.xref}.[¶](#section-5.1-8){.pilcrow}

When the TCB is created, each endpoint [MUST]{.bcp14} set its internal
Cumulative TSN Ack Point to the value of its transmitted Initial TSN
minus one.[¶](#section-5.1-9){.pilcrow}

Implementation Note: The IP addresses and SCTP port are generally used
as the key to find the TCB within an SCTP
instance.[¶](#section-5.1-10){.pilcrow}

::: {#sec_handle_stream_parameters}
::: {#section-5.1.1 .section}
#### [5.1.1.](#section-5.1.1){.section-number .selfRef} [Handle Stream Parameters](#name-handle-stream-parameters){.section-name .selfRef} {#name-handle-stream-parameters}

In the INIT and INIT ACK chunks, the sender of the chunk [MUST]{.bcp14}
indicate the number of outbound streams (OS) it wishes to have in the
association, as well as the maximum inbound streams (MIS) it will accept
from the other endpoint.[¶](#section-5.1.1-1){.pilcrow}

After receiving the stream configuration information from the other
side, each endpoint [MUST]{.bcp14} perform the following check: If the
peer\'s MIS is less than the endpoint\'s OS, meaning that the peer is
incapable of supporting all the outbound streams the endpoint wants to
configure, the endpoint [MUST]{.bcp14} use MIS outbound streams and
[MAY]{.bcp14} report any shortage to the upper layer. The upper layer
can then choose to abort the association if the resource shortage is
unacceptable.[¶](#section-5.1.1-2){.pilcrow}

After the association is initialized, the valid outbound stream
identifier range for either endpoint [MUST]{.bcp14} be 0 to min(local
OS, remote MIS) - 1.[¶](#section-5.1.1-3){.pilcrow}
:::
:::

::: {#sec_handle_address_parameters}
::: {#section-5.1.2 .section}
#### [5.1.2.](#section-5.1.2){.section-number .selfRef} [Handle Address Parameters](#name-handle-address-parameters){.section-name .selfRef} {#name-handle-address-parameters}

During the association initialization, an endpoint uses the following
rules to discover and collect the destination transport address(es) of
its peer.[¶](#section-5.1.2-1){.pilcrow}

[]{.break}

A\)

:   If there are no address parameters present in the received INIT or
    INIT ACK chunk, the endpoint [MUST]{.bcp14} take the source IP
    address from which the chunk arrives and record it, in combination
    with the SCTP Source Port Number, as the only destination transport
    address for this peer.[¶](#section-5.1.2-2.1.1){.pilcrow}

:   

B\)

:   If there is a Host Name Address parameter present in the received
    INIT or INIT ACK chunk, the endpoint [MUST]{.bcp14} immediately send
    an ABORT chunk and [MAY]{.bcp14} include an \"Unresolvable Address\"
    error cause to its peer. The ABORT chunk [SHOULD]{.bcp14} be sent to
    the source IP address from which the last peer packet was
    received.[¶](#section-5.1.2-2.2.1){.pilcrow}

:   

C\)

:   If there are only IPv4/IPv6 addresses present in the received INIT
    or INIT ACK chunk, the receiver [MUST]{.bcp14} derive and record all
    the transport addresses from the received chunk AND the source IP
    address that sent the INIT or INIT ACK chunk. The transport
    addresses are derived by the combination of SCTP Source Port Number
    (from the common header) and the IP Address parameter(s) carried in
    the INIT or INIT ACK chunk and the source IP address of the IP
    datagram. The receiver [SHOULD]{.bcp14} use only these transport
    addresses as destination transport addresses when sending subsequent
    packets to its peer.[¶](#section-5.1.2-2.3.1){.pilcrow}

:   

D\)

:   An INIT or INIT ACK chunk [MUST]{.bcp14} be treated as belonging to
    an already established association (or one in the process of being
    established) if the use of any of the valid address parameters
    contained within the chunk would identify an existing
    TCB.[¶](#section-5.1.2-2.4.1){.pilcrow}

:   

Implementation Note: In some cases (e.g., when the implementation does
not control the source IP address that is used for transmitting), an
endpoint might need to include in its INIT or INIT ACK chunk all
possible IP addresses from which packets to the peer could be
transmitted.[¶](#section-5.1.2-3){.pilcrow}

After all transport addresses are derived from the INIT or INIT ACK
chunk using the above rules, the endpoint selects one of the transport
addresses as the initial primary path.[¶](#section-5.1.2-4){.pilcrow}

The packet containing the INIT ACK chunk [MUST]{.bcp14} be sent to the
source address of the packet containing the INIT
chunk.[¶](#section-5.1.2-5){.pilcrow}

The sender of INIT chunks [MAY]{.bcp14} include a \'Supported Address
Types\' parameter in the INIT chunk to indicate what types of addresses
are acceptable.[¶](#section-5.1.2-6){.pilcrow}

Implementation Note: In the case that the receiver of an INIT ACK chunk
fails to resolve the address parameter due to an unsupported type, it
can abort the initiation process and then attempt a reinitiation by
using a \'Supported Address Types\' parameter in the new INIT chunk to
indicate what types of address it
prefers.[¶](#section-5.1.2-7){.pilcrow}

If an SCTP endpoint that only supports either IPv4 or IPv6 receives IPv4
and IPv6 addresses in an INIT or INIT ACK chunk from its peer, it
[MUST]{.bcp14} use all the addresses belonging to the supported address
family. The other addresses [MAY]{.bcp14} be ignored. The endpoint
[SHOULD NOT]{.bcp14} respond with any kind of error
indication.[¶](#section-5.1.2-8){.pilcrow}

If an SCTP endpoint lists in the \'Supported Address Types\' parameter
either IPv4 or IPv6 but uses the other family for sending the packet
containing the INIT chunk, or if it also lists addresses of the other
family in the INIT chunk, then the address family that is not listed in
the \'Supported Address Types\' parameter [SHOULD]{.bcp14} also be
considered as supported by the receiver of the INIT chunk. The receiver
of the INIT chunk [SHOULD NOT]{.bcp14} respond with any kind of error
indication.[¶](#section-5.1.2-9){.pilcrow}
:::
:::

::: {#sec_generating_state_cookie}
::: {#section-5.1.3 .section}
#### [5.1.3.](#section-5.1.3){.section-number .selfRef} [Generating State Cookie](#name-generating-state-cookie){.section-name .selfRef} {#name-generating-state-cookie}

When sending an INIT ACK chunk as a response to an INIT chunk, the
sender of the INIT ACK chunk creates a State Cookie and sends it in the
State Cookie parameter of the INIT ACK chunk. Inside this State Cookie,
the sender [MUST]{.bcp14} include a MAC (see
\[[RFC2104](#RFC2104){.xref}\] for an example) to provide integrity
protection on the State Cookie. The State Cookie [SHOULD]{.bcp14} also
contain a timestamp on when the State Cookie is created and the lifespan
of the State Cookie, along with all the information necessary for it to
establish the association, including the port numbers and the
Verification Tags.[¶](#section-5.1.3-1){.pilcrow}

The method used to generate the MAC is strictly a private matter for the
receiver of the INIT chunk. The use of a MAC is mandatory to prevent
denial-of-service attacks. MAC algorithms can have different
performances depending on the platform. Choosing a high-performance MAC
algorithm increases the resistance against cookie flooding attacks. A
MAC with acceptable security properties [SHOULD]{.bcp14} be used. The
secret key [SHOULD]{.bcp14} be random (\[[RFC4086](#RFC4086){.xref}\]
provides some information on randomness guidelines). The secret keys
need to have an appropriate size. The secret key [SHOULD]{.bcp14} be
changed reasonably frequently (e.g., hourly), and the timestamp in the
State Cookie [MAY]{.bcp14} be used to determine which key is used to
verify the MAC.[¶](#section-5.1.3-2){.pilcrow}

If the State Cookie is not encrypted, it [MUST NOT]{.bcp14} contain
information that is not being envisioned to be
shared.[¶](#section-5.1.3-3){.pilcrow}

An implementation [SHOULD]{.bcp14} make the cookie as small as possible
to ensure interoperability.[¶](#section-5.1.3-4){.pilcrow}
:::
:::

::: {#sec_state_coockie_processing}
::: {#section-5.1.4 .section}
#### [5.1.4.](#section-5.1.4){.section-number .selfRef} [State Cookie Processing](#name-state-cookie-processing){.section-name .selfRef} {#name-state-cookie-processing}

When an endpoint (in the COOKIE-WAIT state) receives an INIT ACK chunk
with a State Cookie parameter, it [MUST]{.bcp14} immediately send a
COOKIE ECHO chunk to its peer with the received State Cookie. The sender
[MAY]{.bcp14} also add any pending DATA chunks to the packet after the
COOKIE ECHO chunk.[¶](#section-5.1.4-1){.pilcrow}

The endpoint [MUST]{.bcp14} also start the T1-cookie timer after sending
the COOKIE ECHO chunk. If the timer expires, the endpoint [MUST]{.bcp14}
retransmit the COOKIE ECHO chunk and restart the T1-cookie timer. This
is repeated until either a COOKIE ACK chunk is received or
\'Max.Init.Retransmits\' (see [Section
16](#sec_parameter_values){.xref}) is reached, causing the peer endpoint
to be marked unreachable (and thus the association enters the CLOSED
state).[¶](#section-5.1.4-2){.pilcrow}
:::
:::

::: {#sec_state_coockie_authentication}
::: {#section-5.1.5 .section}
#### [5.1.5.](#section-5.1.5){.section-number .selfRef} [State Cookie Authentication](#name-state-cookie-authentication){.section-name .selfRef} {#name-state-cookie-authentication}

When an endpoint receives a COOKIE ECHO chunk from another endpoint with
which it has no association, it takes the following
actions:[¶](#section-5.1.5-1){.pilcrow}

[]{.break}

1\)

:   Compute a MAC using the information carried in the State Cookie and
    the secret key. The timestamp in the State Cookie [MAY]{.bcp14} be
    used to determine which secret key to use. If secrets are kept only
    for a limited amount of time and the secret key to use is not
    available anymore, the packet containing the COOKIE ECHO chunk
    [MUST]{.bcp14} be silently discarded. \[[RFC2104](#RFC2104){.xref}\]
    can be used as a guideline for generating the
    MAC.[¶](#section-5.1.5-2.1.1){.pilcrow}

:   

2\)

:   Authenticate the State Cookie as one that it previously generated by
    comparing the computed MAC against the one carried in the State
    Cookie. If this comparison fails, the SCTP packet, including the
    COOKIE ECHO chunk and any DATA chunks, [MUST]{.bcp14} be silently
    discarded.[¶](#section-5.1.5-2.2.1){.pilcrow}

:   

3\)

:   Compare the port numbers and the Verification Tag contained within
    the COOKIE ECHO chunk to the actual port numbers and the
    Verification Tag within the SCTP common header of the received
    packet. If these values do not match, the packet [MUST]{.bcp14} be
    silently discarded.[¶](#section-5.1.5-2.3.1){.pilcrow}

:   

4\)

:   Compare the creation timestamp in the State Cookie to the current
    local time. If the elapsed time is longer than the lifespan carried
    in the State Cookie, then the packet, including the COOKIE ECHO
    chunk and any attached DATA chunks, [SHOULD]{.bcp14} be discarded,
    and the endpoint [MUST]{.bcp14} transmit an ERROR chunk with a
    \"Stale Cookie\" error cause to the peer
    endpoint.[¶](#section-5.1.5-2.4.1){.pilcrow}

:   

5\)

:   If the State Cookie is valid, create an association to the sender of
    the COOKIE ECHO chunk with the information in the State Cookie
    carried in the COOKIE ECHO chunk and enter the ESTABLISHED
    state.[¶](#section-5.1.5-2.5.1){.pilcrow}

:   

6\)

:   Send a COOKIE ACK chunk to the peer acknowledging receipt of the
    COOKIE ECHO chunk. The COOKIE ACK chunk [MAY]{.bcp14} be bundled
    with an outbound DATA chunk or SACK chunk; however, the COOKIE ACK
    chunk [MUST]{.bcp14} be the first chunk in the SCTP
    packet.[¶](#section-5.1.5-2.6.1){.pilcrow}

:   

7\)

:   Immediately acknowledge any DATA chunk bundled with the COOKIE ECHO
    chunk with a SACK chunk (subsequent DATA chunk acknowledgement
    [SHOULD]{.bcp14} follow the rules defined in [Section
    6.2](#sec_acknowledgements_of_reception_of_data_chunks){.xref}). As
    mentioned in step 6, if the SACK chunk is bundled with the COOKIE
    ACK chunk, the COOKIE ACK chunk [MUST]{.bcp14} appear first in the
    SCTP packet.[¶](#section-5.1.5-2.7.1){.pilcrow}

:   

If a COOKIE ECHO chunk is received from an endpoint with which the
receiver of the COOKIE ECHO chunk has an existing association, the
procedures in [Section
5.2](#sec_handle_duplicate_or_unexpected_chunks){.xref} [SHOULD]{.bcp14}
be followed.[¶](#section-5.1.5-3){.pilcrow}
:::
:::

::: {#sec_example_of_normal_association_establishment}
::: {#section-5.1.6 .section}
#### [5.1.6.](#section-5.1.6){.section-number .selfRef} [An Example of Normal Association Establishment](#name-an-example-of-normal-associ){.section-name .selfRef} {#name-an-example-of-normal-associ}

In the following example, \"A\" initiates the association and then sends
a user message to \"Z\"; then, \"Z\" sends two user messages to \"A\"
later (assuming no bundling or fragmentation
occurs):[¶](#section-5.1.6-1){.pilcrow}

[]{#name-a-setup-example}

::: {#fig_initiation_example}
::: {#section-5.1.6-2.1 .alignCenter .art-text .artwork}
    Endpoint A                                          Endpoint Z
    {app sets association with Z}
    (build TCB)
    INIT [I-Tag=Tag_A
          & other info]  ------\
    (Start T1-init timer)       \
    (Enter COOKIE-WAIT state)    \---> (compose Cookie_Z)
                                    /-- INIT ACK [Veri Tag=Tag_A,
                                   /             I-Tag=Tag_Z,
    (Cancel T1-init timer) <------/              Cookie_Z, & other info]

    COOKIE ECHO [Cookie_Z] ------\
    (Start T1-cookie timer)       \
    (Enter COOKIE-ECHOED state)    \---> (build TCB, enter ESTABLISHED
                                          state)
                                   /---- COOKIE ACK
                                  /
    (Cancel T1-cookie timer, <---/
     enter ESTABLISHED state)
    {app sends 1st user data; strm 0}
    DATA [TSN=init TSN_A
        Strm=0,Seq=0 & user data]--\
    (Start T3-rtx timer)            \
                                     \->
                                   /----- SACK [TSN Ack=init TSN_A,
                                                Block=0]
    (Cancel T3-rtx timer) <------/
                                          ...
                                         {app sends 2 messages;strm 0}
                                   /---- DATA
                                  /        [TSN=init TSN_Z,
                              <--/          Strm=0,Seq=0 & user data 1]
    SACK [TSN Ack=init TSN_Z,      /---- DATA
          Block=0]     --------\  /        [TSN=init TSN_Z +1,
                                \/          Strm=0,Seq=1 & user data 2]
                         <------/\
                                  \
                                   \------>
:::

[Figure 4](#figure-4){.selfRef}: [A Setup
Example](#name-a-setup-example){.selfRef}
:::

If the T1-init timer expires at \"A\" after the INIT or COOKIE ECHO
chunks are sent, the same INIT or COOKIE ECHO chunk with the same
Initiate Tag (i.e., Tag_A) or State Cookie is retransmitted and the
timer is restarted. This is repeated \'Max.Init.Retransmits\' times
before \"A\" considers \"Z\" unreachable and reports the failure to its
upper layer (and thus the association enters the CLOSED
state).[¶](#section-5.1.6-3){.pilcrow}

When retransmitting the INIT chunk, the endpoint [MUST]{.bcp14} follow
the rules defined in [Section
6.3](#sec_management_of_retransission_timer){.xref} to determine the
proper timer value.[¶](#section-5.1.6-4){.pilcrow}
:::
:::
:::
:::

::: {#sec_handle_duplicate_or_unexpected_chunks}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Handle Duplicate or Unexpected INIT, INIT ACK, COOKIE ECHO, and COOKIE ACK Chunks](#name-handle-duplicate-or-unexpec){.section-name .selfRef} {#name-handle-duplicate-or-unexpec}

During the life time of an association (in one of the possible states),
an endpoint can receive from its peer endpoint one of the setup chunks
(INIT, INIT ACK, COOKIE ECHO, or COOKIE ACK). The receiver treats such a
setup chunk as a duplicate and process it as described in this
section.[¶](#section-5.2-1){.pilcrow}

Note: An endpoint will not receive the chunk unless the chunk was sent
to an SCTP transport address and is from an SCTP transport address
associated with this endpoint. Therefore, the endpoint processes such a
chunk as part of its current association.[¶](#section-5.2-2){.pilcrow}

The following scenarios can cause duplicated or unexpected
chunks:[¶](#section-5.2-3){.pilcrow}

[]{.break}

A\)

:   the peer has crashed without being detected, restarted itself, and
    sent a new INIT chunk trying to restore the
    association,[¶](#section-5.2-4.1.1){.pilcrow}

:   

B\)

:   both sides are trying to initialize the association at about the
    same time,[¶](#section-5.2-4.2.1){.pilcrow}

:   

C\)

:   the chunk is from a stale packet that was used to establish the
    present association or a past association that is no longer in
    existence,[¶](#section-5.2-4.3.1){.pilcrow}

:   

D\)

:   the chunk is a false packet generated by an attacker,
    or[¶](#section-5.2-4.4.1){.pilcrow}

:   

E\)

:   the peer never received the COOKIE ACK chunk and is retransmitting
    its COOKIE ECHO chunk.[¶](#section-5.2-4.5.1){.pilcrow}

:   

The rules in the following sections are applied in order to identify and
correctly handle these cases.[¶](#section-5.2-5){.pilcrow}

::: {#section-5.2.1 .section}
#### [5.2.1.](#section-5.2.1){.section-number .selfRef} [INIT Chunk Received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)](#name-init-chunk-received-in-cook){.section-name .selfRef} {#name-init-chunk-received-in-cook}

This usually indicates an initialization collision, i.e., each endpoint
is attempting, at about the same time, to establish an association with
the other endpoint.[¶](#section-5.2.1-1){.pilcrow}

Upon receipt of an INIT chunk in the COOKIE-WAIT state, an endpoint
[MUST]{.bcp14} respond with an INIT ACK chunk using the same parameters
it sent in its original INIT chunk (including its Initiate Tag,
unchanged). When responding, the following rules [MUST]{.bcp14} be
applied:[¶](#section-5.2.1-2){.pilcrow}

[]{.break}

1\)

:   The packet containing the INIT ACK chunk [MUST]{.bcp14} only be sent
    to an address passed by the upper layer in the request to initialize
    the association.[¶](#section-5.2.1-3.1.1){.pilcrow}

:   

2\)

:   The packet containing the INIT ACK chunk [MUST]{.bcp14} only be sent
    to an address reported in the incoming INIT
    chunk.[¶](#section-5.2.1-3.2.1){.pilcrow}

:   

3\)

:   The packet containing the INIT ACK chunk [SHOULD]{.bcp14} be sent to
    the source address of the received packet containing the INIT
    chunk.[¶](#section-5.2.1-3.3.1){.pilcrow}

:   

Upon receipt of an INIT chunk in the COOKIE-ECHOED state, an endpoint
[MUST]{.bcp14} respond with an INIT ACK chunk using the same parameters
it sent in its original INIT chunk (including its Initiate Tag,
unchanged), provided that no new address has been added to the forming
association. If the INIT chunk indicates that a new address has been
added to the association, then the entire INIT chunk [MUST]{.bcp14} be
discarded, and the state of the existing association [SHOULD
NOT]{.bcp14} be changed. An ABORT chunk [SHOULD]{.bcp14} be sent in a
response that [MAY]{.bcp14} include the \"Restart of an Association with
New Addresses\" error cause. The error [SHOULD]{.bcp14} list the
addresses that were added to the restarting
association.[¶](#section-5.2.1-4){.pilcrow}

When responding in either state (COOKIE-WAIT or COOKIE-ECHOED) with an
INIT ACK chunk, the original parameters are combined with those from the
newly received INIT chunk. The endpoint [MUST]{.bcp14} also generate a
State Cookie with the INIT ACK chunk. The endpoint uses the parameters
sent in its INIT chunk to calculate the State
Cookie.[¶](#section-5.2.1-5){.pilcrow}

After that, the endpoint [MUST NOT]{.bcp14} change its state, the
T1-init timer [MUST]{.bcp14} be left running, and the corresponding TCB
[MUST NOT]{.bcp14} be destroyed. The normal procedures for handling
State Cookies when a TCB exists will resolve the duplicate INIT chunks
to a single association.[¶](#section-5.2.1-6){.pilcrow}

For an endpoint that is in the COOKIE-ECHOED state, it [MUST]{.bcp14}
populate its Tie-Tags within both the association TCB and inside the
State Cookie (see [Section
5.2.2](#sec_unexpected_init_in_states_other_than_closed_cookie_echoed){.xref}
for a description of the Tie-Tags).[¶](#section-5.2.1-7){.pilcrow}
:::

::: {#sec_unexpected_init_in_states_other_than_closed_cookie_echoed}
::: {#section-5.2.2 .section}
#### [5.2.2.](#section-5.2.2){.section-number .selfRef} [Unexpected INIT Chunk in States Other than CLOSED, COOKIE-ECHOED, COOKIE-WAIT, and SHUTDOWN-ACK-SENT](#name-unexpected-init-chunk-in-st){.section-name .selfRef} {#name-unexpected-init-chunk-in-st}

Unless otherwise stated, upon receipt of an unexpected INIT chunk for
this association, the endpoint [MUST]{.bcp14} generate an INIT ACK chunk
with a State Cookie. Before responding, the endpoint [MUST]{.bcp14}
check to see if the unexpected INIT chunk adds new addresses to the
association. If new addresses are added to the association, the endpoint
[MUST]{.bcp14} respond with an ABORT chunk, copying the \'Initiate Tag\'
of the unexpected INIT chunk into the \'Verification Tag\' of the
outbound packet carrying the ABORT chunk. In the ABORT chunk, the error
cause [MAY]{.bcp14} be set to \"Restart of an Association with New
Addresses\". The error [SHOULD]{.bcp14} list the addresses that were
added to the restarting association. If no new addresses are added, when
responding to the INIT chunk in the outbound INIT ACK chunk, the
endpoint [MUST]{.bcp14} copy its current Tie-Tags to a reserved place
within the State Cookie and the association\'s TCB. We refer to these
locations inside the cookie as the Peer\'s-Tie-Tag and the
Local-Tie-Tag. We will refer to the copy within an association\'s TCB as
the Local Tag and Peer\'s Tag. The outbound SCTP packet containing this
INIT ACK chunk [MUST]{.bcp14} carry a Verification Tag value equal to
the Initiate Tag found in the unexpected INIT chunk. And the INIT ACK
chunk [MUST]{.bcp14} contain a new Initiate Tag (randomly generated; see
[Section 5.3.1](#sec_selection_of_tag_value){.xref}). Other parameters
for the endpoint [SHOULD]{.bcp14} be copied from the existing parameters
of the association (e.g., number of outbound streams) into the INIT ACK
chunk and cookie.[¶](#section-5.2.2-1){.pilcrow}

After sending the INIT ACK or ABORT chunk, the endpoint [MUST]{.bcp14}
take no further actions, i.e., the existing association, including its
current state, and the corresponding TCB [MUST NOT]{.bcp14} be
changed.[¶](#section-5.2.2-2){.pilcrow}

Only when a TCB exists and the association is not in a COOKIE-WAIT or
SHUTDOWN-ACK-SENT state are the Tie-Tags populated with a random value
other than 0. For a normal association INIT chunk (i.e., the endpoint is
in the CLOSED state), the Tie-Tags [MUST]{.bcp14} be set to 0
(indicating that no previous TCB
existed).[¶](#section-5.2.2-3){.pilcrow}
:::
:::

::: {#sec_unexpected_init_ack}
::: {#section-5.2.3 .section}
#### [5.2.3.](#section-5.2.3){.section-number .selfRef} [Unexpected INIT ACK Chunk](#name-unexpected-init-ack-chunk){.section-name .selfRef} {#name-unexpected-init-ack-chunk}

If an INIT ACK chunk is received by an endpoint in any state other than
the COOKIE-WAIT or CLOSED state, the endpoint [SHOULD]{.bcp14} discard
the INIT ACK chunk. An unexpected INIT ACK chunk usually indicates the
processing of an old or duplicated INIT
chunk.[¶](#section-5.2.3-1){.pilcrow}
:::
:::

::: {#sec_handle_a_cookie_echo_when_a_tcp_exists}
::: {#section-5.2.4 .section}
#### [5.2.4.](#section-5.2.4){.section-number .selfRef} [Handle a COOKIE ECHO Chunk When a TCB Exists](#name-handle-a-cookie-echo-chunk-){.section-name .selfRef} {#name-handle-a-cookie-echo-chunk-}

When a COOKIE ECHO chunk is received by an endpoint in any state for an
existing association (i.e., not in the CLOSED state), the following
rules are applied:[¶](#section-5.2.4-1){.pilcrow}

[]{.break}

1\)

:   Compute a MAC as described in step 1 of [Section
    5.1.5](#sec_state_coockie_authentication){.xref}.[¶](#section-5.2.4-2.1.1){.pilcrow}

:   

2\)

:   Authenticate the State Cookie as described in step 2 of [Section
    5.1.5](#sec_state_coockie_authentication){.xref} (this is case C or
    D above).[¶](#section-5.2.4-2.2.1){.pilcrow}

:   

3\)

:   Compare the timestamp in the State Cookie to the current time. If
    the State Cookie is older than the lifespan carried in the State
    Cookie and the Verification Tags contained in the State Cookie do
    not match the current association\'s Verification Tags, the packet,
    including the COOKIE ECHO chunk and any DATA chunks,
    [SHOULD]{.bcp14} be discarded. The endpoint also [MUST]{.bcp14}
    transmit an ERROR chunk with a \"Stale Cookie\" error cause to the
    peer endpoint (this is case C or D in [Section
    5.2](#sec_handle_duplicate_or_unexpected_chunks){.xref}).[¶](#section-5.2.4-2.3.1){.pilcrow}

    If both Verification Tags in the State Cookie match the Verification
    Tags of the current association, consider the State Cookie valid
    (this is case E in [Section
    5.2](#sec_handle_duplicate_or_unexpected_chunks){.xref}), even if
    the lifespan is exceeded.[¶](#section-5.2.4-2.3.2){.pilcrow}

:   

4\)

:   If the State Cookie proves to be valid, unpack the TCB into a
    temporary TCB.[¶](#section-5.2.4-2.4.1){.pilcrow}

:   

5\)

:   Refer to [Table 12](#table_handling_of_cookie_echo){.xref} to
    determine the correct action to be
    taken.[¶](#section-5.2.4-2.5.1){.pilcrow}

:   

[]{#name-handling-of-a-cookie-echo-c}

::: {#table_handling_of_cookie_echo}
  Local Tag   Peer\'s Tag   Local-Tie-Tag   Peer\'s-Tie-Tag   Action
  ----------- ------------- --------------- ----------------- --------
  X           X             M               M                 \(A\)
  M           X             A               A                 \(B\)
  M           0             A               A                 \(B\)
  X           M             0               0                 \(C\)
  M           M             A               A                 \(D\)

  : [Table 12](#table-12){.selfRef}: [Handling of a COOKIE ECHO Chunk
  When a TCB Exists](#name-handling-of-a-cookie-echo-c){.selfRef}
:::

Legend:[¶](#section-5.2.4-4){.pilcrow}

[]{.break}

X -
:   Tag does not match the existing
    TCB.[¶](#section-5.2.4-5.2){.pilcrow}
:   

M -
:   Tag matches the existing TCB.[¶](#section-5.2.4-5.4){.pilcrow}
:   

0 -
:   Tag unknown (Peer\'s Tag not known yet / No Tie-Tag in
    cookie).[¶](#section-5.2.4-5.6){.pilcrow}
:   

A -
:   All cases, i.e., M, X, or 0.[¶](#section-5.2.4-5.8){.pilcrow}
:   

For any case not shown in [Table
12](#table_handling_of_cookie_echo){.xref}, the cookie [SHOULD]{.bcp14}
be silently discarded.[¶](#section-5.2.4-6){.pilcrow}

Action:[¶](#section-5.2.4-7){.pilcrow}

[]{.break}

A\)

:   In this case, the peer might have restarted. When the endpoint
    recognizes this potential \'restart\', the existing session is
    treated the same as if it received an ABORT chunk followed by a new
    COOKIE ECHO chunk with the following
    exceptions:[¶](#section-5.2.4-8.1.1){.pilcrow}

    -   ::: {#section-5.2.4-8.1.2.1}
        Any SCTP DATA chunks [MAY]{.bcp14} be retained (this is an
        implementation-specific
        option).[¶](#section-5.2.4-8.1.2.1.1){.pilcrow}
        :::

    -   ::: {#section-5.2.4-8.1.2.2}
        A RESTART notification [SHOULD]{.bcp14} be sent to the ULP
        instead of a COMMUNICATION LOST
        notification.[¶](#section-5.2.4-8.1.2.2.1){.pilcrow}
        :::

    All the congestion control parameters (e.g., cwnd, ssthresh) related
    to this peer [MUST]{.bcp14} be reset to their initial values (see
    [Section
    6.2.1](#sec_processing_of_received_sack){.xref}).[¶](#section-5.2.4-8.1.3){.pilcrow}

    After this, the endpoint enters the ESTABLISHED
    state.[¶](#section-5.2.4-8.1.4){.pilcrow}

    If the endpoint is in the SHUTDOWN-ACK-SENT state and recognizes
    that the peer has restarted (Action A), it [MUST NOT]{.bcp14} set up
    a new association but instead resend the SHUTDOWN ACK chunk and send
    an ERROR chunk with a \"Cookie Received While Shutting Down\" error
    cause to its peer.[¶](#section-5.2.4-8.1.5){.pilcrow}

:   

B\)

:   In this case, both sides might be attempting to start an association
    at about the same time, but the peer endpoint sent its INIT chunk
    after responding to the local endpoint\'s INIT chunk. Thus, it might
    have picked a new Verification Tag, not being aware of the previous
    tag it had sent this endpoint. The endpoint [SHOULD]{.bcp14} stay in
    or enter the ESTABLISHED state, but it [MUST]{.bcp14} update its
    peer\'s Verification Tag from the State Cookie, stop any T1-init or
    T1-cookie timers that might be running, and send a COOKIE ACK
    chunk.[¶](#section-5.2.4-8.2.1){.pilcrow}

:   

C\)

:   In this case, the local endpoint\'s cookie has arrived late. Before
    it arrived, the local endpoint sent an INIT chunk and received an
    INIT ACK chunk and finally sent a COOKIE ECHO chunk with the peer\'s
    same tag but a new tag of its own. The cookie [SHOULD]{.bcp14} be
    silently discarded. The endpoint [SHOULD NOT]{.bcp14} change states
    and [SHOULD]{.bcp14} leave any timers
    running.[¶](#section-5.2.4-8.3.1){.pilcrow}

:   

D\)

:   When both local and remote tags match, the endpoint [SHOULD]{.bcp14}
    enter the ESTABLISHED state if it is in the COOKIE-ECHOED state. It
    [SHOULD]{.bcp14} stop any T1-cookie timer that is running and send a
    COOKIE ACK chunk.[¶](#section-5.2.4-8.4.1){.pilcrow}

:   

Note: The \"peer\'s Verification Tag\" is the tag received in the
Initiate Tag field of the INIT or INIT ACK
chunk.[¶](#section-5.2.4-9){.pilcrow}

::: {#section-5.2.4.1 .section}
##### [5.2.4.1.](#section-5.2.4.1){.section-number .selfRef} [An Example of an Association Restart](#name-an-example-of-an-associatio){.section-name .selfRef} {#name-an-example-of-an-associatio}

In the following example, \"A\" initiates the association after a
restart has occurred. Endpoint \"Z\" had no knowledge of the restart
until the exchange (i.e., Heartbeats had not yet detected the failure of
\"A\") (assuming no bundling or fragmentation
occurs):[¶](#section-5.2.4.1-1){.pilcrow}

[]{#name-a-restart-example}

::: {#fig_restart_example}
::: {#section-5.2.4.1-2.1 .alignCenter .art-text .artwork}
    Endpoint A                                          Endpoint Z
    <-------------- Association is established---------------------->
    Tag=Tag_A                                             Tag=Tag_Z
    <--------------------------------------------------------------->
    {A crashes and restarts}
    {app sets up an association with Z}
    (build TCB)
    INIT [I-Tag=Tag_A'
          & other info]  --------\
    (Start T1-init timer)         \
    (Enter COOKIE-WAIT state)      \---> (find an existing TCB,
                                          populate TieTags if needed,
                                          compose Cookie_Z with Tie-Tags
                                          and other info)
                                    /--- INIT ACK [Veri Tag=Tag_A',
                                   /               I-Tag=Tag_Z',
    (Cancel T1-init timer) <------/                Cookie_Z]
                                         (leave original TCB in place)
    COOKIE ECHO [Veri=Tag_Z',
                 Cookie_Z]-------\
    (Start T1-init timer)         \
    (Enter COOKIE-ECHOED state)    \---> (Find existing association,
                                          Tie-Tags in Cookie_Z match
                                          Tie-Tags in TCB,
                                          Tags do not match, i.e.,
                                          case X X M M above,
                                          Announce Restart to ULP
                                          and reset association).
                                   /---- COOKIE ACK
    (Cancel T1-init timer, <------/
     Enter ESTABLISHED state)
    {app sends 1st user data; strm 0}
    DATA [TSN=Initial TSN_A
        Strm=0,Seq=0 & user data]--\
    (Start T3-rtx timer)            \
                                     \->
                                  /--- SACK [TSN Ack=init TSN_A,Block=0]
    (Cancel T3-rtx timer) <------/
:::

[Figure 5](#figure-5){.selfRef}: [A Restart
Example](#name-a-restart-example){.selfRef}
:::
:::
:::
:::

::: {#sec_handle_duplicate_cookie_ack}
::: {#section-5.2.5 .section}
#### [5.2.5.](#section-5.2.5){.section-number .selfRef} [Handle Duplicate COOKIE ACK Chunk](#name-handle-duplicate-cookie-ack){.section-name .selfRef} {#name-handle-duplicate-cookie-ack}

At any state other than COOKIE-ECHOED, an endpoint [SHOULD]{.bcp14}
silently discard a received COOKIE ACK
chunk.[¶](#section-5.2.5-1){.pilcrow}
:::
:::

::: {#sec_handle_stale_cookie_error}
::: {#section-5.2.6 .section}
#### [5.2.6.](#section-5.2.6){.section-number .selfRef} [Handle Stale Cookie Error](#name-handle-stale-cookie-error){.section-name .selfRef} {#name-handle-stale-cookie-error}

Receipt of an ERROR chunk with a \"Stale Cookie\" error cause indicates
one of a number of possible events:[¶](#section-5.2.6-1){.pilcrow}

[]{.break}

A\)

:   The association failed to completely set up before the State Cookie
    issued by the sender was
    processed.[¶](#section-5.2.6-2.1.1){.pilcrow}

:   

B\)

:   An old State Cookie was processed after setup
    completed.[¶](#section-5.2.6-2.2.1){.pilcrow}

:   

C\)

:   An old State Cookie is received from someone that the receiver is
    not interested in having an association with and the ABORT chunk was
    lost.[¶](#section-5.2.6-2.3.1){.pilcrow}

:   

When processing an ERROR chunk with a \"Stale Cookie\" error cause, an
endpoint [SHOULD]{.bcp14} first examine if an association is in the
process of being set up, i.e., the association is in the COOKIE-ECHOED
state. In all cases, if the association is not in the COOKIE-ECHOED
state, the ERROR chunk [SHOULD]{.bcp14} be silently
discarded.[¶](#section-5.2.6-3){.pilcrow}

If the association is in the COOKIE-ECHOED state, the endpoint
[MAY]{.bcp14} elect one of the following three
alternatives.[¶](#section-5.2.6-4){.pilcrow}

[]{.break}

1\)

:   Send a new INIT chunk to the endpoint to generate a new State Cookie
    and reattempt the setup
    procedure.[¶](#section-5.2.6-5.1.1){.pilcrow}

:   

2\)

:   Discard the TCB and report to the upper layer the inability to set
    up the association.[¶](#section-5.2.6-5.2.1){.pilcrow}

:   

3\)

:   Send a new INIT chunk to the endpoint, adding a Cookie Preservative
    parameter requesting an extension to the life time of the State
    Cookie. When calculating the time extension, an implementation
    [SHOULD]{.bcp14} use the RTT information measured based on the
    previous COOKIE ECHO/ERROR chunk exchange and [SHOULD]{.bcp14} add
    no more than 1 second beyond the measured RTT, due to long State
    Cookie life times making the endpoint more subject to a replay
    attack.[¶](#section-5.2.6-5.3.1){.pilcrow}

:   
:::
:::
:::
:::

::: {#sec_other_initialization_issues}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Other Initialization Issues](#name-other-initialization-issues){.section-name .selfRef} {#name-other-initialization-issues}

::: {#sec_selection_of_tag_value}
::: {#section-5.3.1 .section}
#### [5.3.1.](#section-5.3.1){.section-number .selfRef} [Selection of Tag Value](#name-selection-of-tag-value){.section-name .selfRef} {#name-selection-of-tag-value}

Initiate Tag values [SHOULD]{.bcp14} be selected from the range of 1 to
2^32^ - 1. It is very important that the Initiate Tag value be
randomized to help protect against off-path attacks. The methods
described in \[[RFC4086](#RFC4086){.xref}\] can be used for the Initiate
Tag randomization. Careful selection of Initiate Tags is also necessary
to prevent old duplicate packets from previous associations being
mistakenly processed as belonging to the current
association.[¶](#section-5.3.1-1){.pilcrow}

Moreover, the Verification Tag value used by either endpoint in a given
association [MUST NOT]{.bcp14} change during the life time of an
association. A new Verification Tag value [MUST]{.bcp14} be used each
time the endpoint tears down and then reestablishes an association to
the same peer.[¶](#section-5.3.1-2){.pilcrow}
:::
:::
:::
:::

::: {#sec_path_verifiation}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [Path Verification](#name-path-verification){.section-name .selfRef} {#name-path-verification}

During association establishment, the two peers exchange a list of
addresses. In the predominant case, these lists accurately represent the
addresses owned by each peer. However, a misbehaving peer might supply
addresses that it does not own. To prevent this, the following rules are
applied to all addresses of the new
association:[¶](#section-5.4-1){.pilcrow}

[]{.break}

1\)

:   Any addresses passed to the sender of the INIT chunk by its upper
    layer in the request to initialize an association are automatically
    considered to be CONFIRMED.[¶](#section-5.4-2.1.1){.pilcrow}

:   

2\)

:   For the receiver of the COOKIE ECHO chunk, the only CONFIRMED
    address is the address to which the packet containing the INIT ACK
    chunk was sent.[¶](#section-5.4-2.2.1){.pilcrow}

:   

3\)

:   All other addresses not covered by rules 1 and 2 are considered
    UNCONFIRMED and are subject to probing for
    verification.[¶](#section-5.4-2.3.1){.pilcrow}

:   

To probe an address for verification, an endpoint will send HEARTBEAT
chunks including a 64-bit random nonce and a path indicator (to identify
the address that the HEARTBEAT chunk is sent to) within the Heartbeat
Info parameter.[¶](#section-5.4-3){.pilcrow}

Upon receipt of the HEARTBEAT ACK chunk, a verification is made that the
nonce included in the Heartbeat Info parameter is the one sent to the
address indicated inside the Heartbeat Info parameter. When this match
occurs, the address that the original HEARTBEAT was sent to is now
considered CONFIRMED and available for normal data
transfer.[¶](#section-5.4-4){.pilcrow}

These probing procedures are started when an association moves to the
ESTABLISHED state and are ended when all paths are
confirmed.[¶](#section-5.4-5){.pilcrow}

In each RTO, a probe [MAY]{.bcp14} be sent on an active UNCONFIRMED path
in an attempt to move it to the CONFIRMED state. If during this probing
the path becomes inactive, this rate is lowered to the normal HEARTBEAT
rate. At the expiration of the RTO timer, the error counter of any path
that was probed but not CONFIRMED is incremented by one and subjected to
path failure detection, as defined in [Section
8.2](#sec_path_failure_detection){.xref}. When probing UNCONFIRMED
addresses, however, the association overall error count is not
incremented.[¶](#section-5.4-6){.pilcrow}

The number of packets containing HEARTBEAT chunks sent at each RTO
[SHOULD]{.bcp14} be limited by the \'HB.Max.Burst\' parameter. It is an
implementation decision as to how to distribute packets containing
HEARTBEAT chunks to the peer\'s addresses for path
verification.[¶](#section-5.4-7){.pilcrow}

Whenever a path is confirmed, an indication [MAY]{.bcp14} be given to
the upper layer.[¶](#section-5.4-8){.pilcrow}

An endpoint [MUST NOT]{.bcp14} send any chunks to an UNCONFIRMED
address, with the following exceptions:[¶](#section-5.4-9){.pilcrow}

-   ::: {#section-5.4-10.1}
    A HEARTBEAT chunk including a nonce [MAY]{.bcp14} be sent to an
    UNCONFIRMED address.[¶](#section-5.4-10.1.1){.pilcrow}
    :::

-   ::: {#section-5.4-10.2}
    A HEARTBEAT ACK chunk [MAY]{.bcp14} be sent to an UNCONFIRMED
    address.[¶](#section-5.4-10.2.1){.pilcrow}
    :::

-   ::: {#section-5.4-10.3}
    A COOKIE ACK chunk [MAY]{.bcp14} be sent to an UNCONFIRMED address,
    but it [MUST]{.bcp14} be bundled with a HEARTBEAT chunk including a
    nonce. An implementation that does not support bundling [MUST
    NOT]{.bcp14} send a COOKIE ACK chunk to an UNCONFIRMED
    address.[¶](#section-5.4-10.3.1){.pilcrow}
    :::

-   ::: {#section-5.4-10.4}
    A COOKIE ECHO chunk [MAY]{.bcp14} be sent to an UNCONFIRMED address,
    but it [MUST]{.bcp14} be bundled with a HEARTBEAT chunk including a
    nonce, and the size of the SCTP packet [MUST NOT]{.bcp14} exceed the
    PMTU. If the implementation does not support bundling or if the
    bundled COOKIE ECHO chunk plus HEARTBEAT chunk (including nonce)
    would result in an SCTP packet larger than the PMTU, then the
    implementation [MUST NOT]{.bcp14} send a COOKIE ECHO chunk to an
    UNCONFIRMED address.[¶](#section-5.4-10.4.1){.pilcrow}
    :::
:::
:::
:::
:::

::: {#sec_user_data_transfer}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [User Data Transfer](#name-user-data-transfer){.section-name .selfRef} {#name-user-data-transfer}

Data transmission [MUST]{.bcp14} only happen in the ESTABLISHED,
SHUTDOWN-PENDING, and SHUTDOWN-RECEIVED states. The only exception to
this is that DATA chunks are allowed to be bundled with an outbound
COOKIE ECHO chunk when in the COOKIE-WAIT
state.[¶](#section-6-1){.pilcrow}

DATA chunks [MUST]{.bcp14} only be received according to the rules below
in ESTABLISHED, SHUTDOWN-PENDING, and SHUTDOWN-SENT states. A DATA chunk
received in CLOSED is out of the blue and [SHOULD]{.bcp14} be handled
per [Section 8.4](#sec_handle_out_of_the_blue_packets){.xref}. A DATA
chunk received in any other state [SHOULD]{.bcp14} be
discarded.[¶](#section-6-2){.pilcrow}

A SACK chunk [MUST]{.bcp14} be processed in ESTABLISHED,
SHUTDOWN-PENDING, and SHUTDOWN-RECEIVED states. An incoming SACK chunk
[MAY]{.bcp14} be processed in COOKIE-ECHOED. A SACK chunk in the CLOSED
state is out of the blue and [SHOULD]{.bcp14} be processed according to
the rules in [Section 8.4](#sec_handle_out_of_the_blue_packets){.xref}.
A SACK chunk received in any other state [SHOULD]{.bcp14} be
discarded.[¶](#section-6-3){.pilcrow}

For transmission efficiency, SCTP defines mechanisms for bundling of
small user messages and fragmentation of large user messages. The
following diagram depicts the flow of user messages through
SCTP.[¶](#section-6-4){.pilcrow}

In this section, the term \"data sender\" refers to the endpoint that
transmits a DATA chunk, and the term \"data receiver\" refers to the
endpoint that receives a DATA chunk. A data receiver will transmit SACK
chunks.[¶](#section-6-5){.pilcrow}

[]{#name-illustration-of-user-data-t}

::: {#fig_user_data_transfer}
::: {#section-6-6.1 .alignCenter .art-text .artwork}
               +-------------------------+
               |      User Messages      |
               +-------------------------+
     SCTP user        ^  |
    ==================|==|=======================================
                      |  v (1)
           +------------------+    +---------------------+
           | SCTP DATA Chunks |    | SCTP Control Chunks |
           +------------------+    +---------------------+
                      ^  |             ^  |
                      |  v (2)         |  v (2)
                   +--------------------------+
                   |       SCTP packets       |
                   +--------------------------+
     SCTP                      ^  |
    ===========================|==|===========================
                               |  v
           Connectionless Packet Transfer Service (e.g., IP)
:::

[Figure 6](#figure-6){.selfRef}: [Illustration of User Data
Transfer](#name-illustration-of-user-data-t){.selfRef}
:::

The following applies:[¶](#section-6-7){.pilcrow}

[]{.break}

1\)

:   When converting user messages into DATA chunks, an endpoint
    [MUST]{.bcp14} fragment large user messages into multiple DATA
    chunks. The size of each DATA chunk [SHOULD]{.bcp14} be smaller than
    or equal to the Association Maximum DATA Chunk Size (AMDCS). The
    data receiver will normally reassemble the fragmented message from
    DATA chunks before delivery to the user (see [Section
    6.9](#sec_frag_reass){.xref} for
    details).[¶](#section-6-8.1.1){.pilcrow}

:   

2\)

:   Multiple DATA and control chunks [MAY]{.bcp14} be bundled by the
    sender into a single SCTP packet for transmission, as long as the
    final size of the SCTP packet does not exceed the current PMTU. The
    receiver will unbundle the packet back into the original chunks.
    Control chunks [MUST]{.bcp14} come before DATA chunks in the
    packet.[¶](#section-6-8.2.1){.pilcrow}

:   

The fragmentation and bundling mechanisms, as detailed in Sections
[6.9](#sec_frag_reass){.xref} and [6.10](#sec_bundling){.xref}, are
[OPTIONAL]{.bcp14} to implement by the data sender, but they
[MUST]{.bcp14} be implemented by the data receiver, i.e., an endpoint
[MUST]{.bcp14} properly receive and process bundled or fragmented
data.[¶](#section-6-9){.pilcrow}

::: {#sec_transmission_of_data_chunks}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Transmission of DATA Chunks](#name-transmission-of-data-chunks){.section-name .selfRef} {#name-transmission-of-data-chunks}

This section specifies the rules for sending DATA chunks. In particular,
it defines zero window probing, which is required to avoid the
indefinite stalling of an association in case of a loss of packets
containing SACK chunks performing window
updates.[¶](#section-6.1-1){.pilcrow}

This document is specified as if there is a single retransmission timer
per destination transport address, but implementations [MAY]{.bcp14}
have a retransmission timer for each DATA
chunk.[¶](#section-6.1-2){.pilcrow}

The following general rules [MUST]{.bcp14} be applied by the data sender
for transmission and/or retransmission of outbound DATA
chunks:[¶](#section-6.1-3){.pilcrow}

[]{.break}

A\)

:   At any given time, the data sender [MUST NOT]{.bcp14} transmit new
    data to any destination transport address if its peer\'s rwnd
    indicates that the peer has no buffer space (i.e., rwnd is smaller
    than the size of the next DATA chunk; see [Section
    6.2.1](#sec_processing_of_received_sack){.xref}), except for zero
    window probes.[¶](#section-6.1-4.1.1){.pilcrow}

    A zero window probe is a DATA chunk sent when the receiver has no
    buffer space. This rule allows the sender to probe for a change in
    rwnd that the sender missed due to the SACK chunks having been lost
    in transit from the data receiver to the data sender. A zero window
    probe [MUST]{.bcp14} only be sent when the cwnd allows (see rule B
    below). A zero window probe [SHOULD]{.bcp14} only be sent when all
    outstanding DATA chunks have been cumulatively acknowledged and no
    DATA chunks are in flight. Senders [MUST]{.bcp14} support zero
    window probing.[¶](#section-6.1-4.1.2){.pilcrow}

    If the sender continues to receive SACK chunks from the peer while
    doing zero window probing, the unacknowledged window probes [SHOULD
    NOT]{.bcp14} increment the error counter for the association or any
    destination transport address. This is because the receiver could
    keep its window closed for an indefinite time. [Section
    6.2](#sec_acknowledgements_of_reception_of_data_chunks){.xref}
    describes the receiver behavior when it advertises a zero window.
    The sender [SHOULD]{.bcp14} send the first zero window probe after 1
    RTO when it detects that the receiver has closed its window and
    [SHOULD]{.bcp14} increase the probe interval exponentially
    afterwards. Also note that the cwnd [SHOULD]{.bcp14} be adjusted
    according to [Section 7.2.1](#sec_slow_start){.xref}. Zero window
    probing does not affect the calculation of
    cwnd.[¶](#section-6.1-4.1.3){.pilcrow}

    The sender [MUST]{.bcp14} also have an algorithm for sending new
    DATA chunks to avoid silly window syndrome (SWS) as described in
    \[[RFC1122](#RFC1122){.xref}\]. The algorithm can be similar to the
    one described in [Section
    4.2.3.4](https://www.rfc-editor.org/rfc/rfc1122#section-4.2.3.4){.relref}
    of \[[RFC1122](#RFC1122){.xref}\].[¶](#section-6.1-4.1.4){.pilcrow}

:   

B\)

:   At any given time, the sender [MUST NOT]{.bcp14} transmit new data
    to a given transport address if it has cwnd + (PMDCS - 1) or more
    bytes of data outstanding to that transport address. If data is
    available, the sender [SHOULD]{.bcp14} exceed cwnd by up to (PMDCS -
    1) bytes on a new data transmission if the flightsize does not
    currently reach cwnd. The breach of cwnd [MUST]{.bcp14} constitute
    one packet only.[¶](#section-6.1-4.2.1){.pilcrow}

:   

C\)

:   When the time comes for the sender to transmit, before sending new
    DATA chunks, the sender [MUST]{.bcp14} first transmit any DATA
    chunks that are marked for retransmission (limited by the current
    cwnd).[¶](#section-6.1-4.3.1){.pilcrow}

:   

D\)

:   When the time comes for the sender to transmit new DATA chunks, the
    protocol parameter \'Max.Burst\' [SHOULD]{.bcp14} be used to limit
    the number of packets sent. The limit [MAY]{.bcp14} be applied by
    adjusting cwnd temporarily, as
    follows:[¶](#section-6.1-4.4.1){.pilcrow}

    ::: {#section-6.1-4.4.2}
    ``` {.lang-pseudocode .sourcecode}
    if ((flightsize + Max.Burst * PMDCS) < cwnd)
        cwnd = flightsize + Max.Burst * PMDCS
    ```

    [¶](#section-6.1-4.4.2){.pilcrow}
    :::

    Or, it [MAY]{.bcp14} be applied by strictly limiting the number of
    packets emitted by the output routine. When calculating the number
    of packets to transmit, and particularly when using the formula
    above, cwnd [SHOULD NOT]{.bcp14} be changed
    permanently.[¶](#section-6.1-4.4.3){.pilcrow}

:   

E\)

:   Then, the sender can send as many new DATA chunks as rule A and rule
    B allow.[¶](#section-6.1-4.5.1){.pilcrow}

:   

Multiple DATA chunks committed for transmission [MAY]{.bcp14} be bundled
in a single packet. Furthermore, DATA chunks being retransmitted
[MAY]{.bcp14} be bundled with new DATA chunks, as long as the resulting
SCTP packet size does not exceed the PMTU. A ULP can request that no
bundling is performed, but this only turns off any delays that an SCTP
implementation might be using to increase bundling efficiency. It does
not in itself stop all bundling from occurring (i.e., in case of
congestion or retransmission).[¶](#section-6.1-5){.pilcrow}

Before an endpoint transmits a DATA chunk, if any received DATA chunks
have not been acknowledged (e.g., due to delayed ack), the sender
[SHOULD]{.bcp14} create a SACK chunk and bundle it with the outbound
DATA chunk, as long as the size of the final SCTP packet does not exceed
the current PMTU. See [Section
6.2](#sec_acknowledgements_of_reception_of_data_chunks){.xref}.[¶](#section-6.1-6){.pilcrow}

When the window is full (i.e., transmission is disallowed by rule A
and/or rule B), the sender [MAY]{.bcp14} still accept send requests from
its upper layer but [MUST]{.bcp14} transmit no more DATA chunks until
some or all of the outstanding DATA chunks are acknowledged and
transmission is allowed by rule A and rule B
again.[¶](#section-6.1-7){.pilcrow}

Whenever a transmission or retransmission is made to any address, if the
T3-rtx timer of that address is not currently running, the sender
[MUST]{.bcp14} start that timer. If the timer for that address is
already running, the sender [MUST]{.bcp14} restart the timer if the
earliest (i.e., lowest TSN) outstanding DATA chunk sent to that address
is being retransmitted. Otherwise, the data sender [MUST NOT]{.bcp14}
restart the timer.[¶](#section-6.1-8){.pilcrow}

When starting or restarting the T3-rtx timer, the timer value
[SHOULD]{.bcp14} be adjusted according to the timer rules defined in
Sections [6.3.2](#sec_retransmission_timer_rules){.xref} and
[6.3.3](#sec_handle_t3_rtx_expiration){.xref}.[¶](#section-6.1-9){.pilcrow}

The data sender [MUST NOT]{.bcp14} use a TSN that is more than 2^31^ - 1
above the beginning TSN of the current send
window.[¶](#section-6.1-10){.pilcrow}

For each stream, the data sender [MUST NOT]{.bcp14} have more than 2^16^
- 1 ordered user messages in the current send
window.[¶](#section-6.1-11){.pilcrow}

Whenever the sender of a DATA chunk can benefit from the corresponding
SACK chunk being sent back without delay, the sender [MAY]{.bcp14} set
the I bit in the DATA chunk header. Please note that why the sender has
set the I bit is irrelevant to the
receiver.[¶](#section-6.1-12){.pilcrow}

Reasons for setting the I bit include, but are not limited to, the
following (see [Section
4](https://www.rfc-editor.org/rfc/rfc7053#section-4){.relref} of
\[[RFC7053](#RFC7053){.xref}\] for a discussion of the
benefits):[¶](#section-6.1-13){.pilcrow}

-   ::: {#section-6.1-14.1}
    The application requests that the I bit of the last DATA chunk of a
    user message be set when providing the user message to the SCTP
    implementation (see [Section
    11.1](#sec_ulp_to_sctp){.xref}).[¶](#section-6.1-14.1.1){.pilcrow}
    :::

-   ::: {#section-6.1-14.2}
    The sender is in the SHUTDOWN-PENDING
    state.[¶](#section-6.1-14.2.1){.pilcrow}
    :::

-   ::: {#section-6.1-14.3}
    The sending of a DATA chunk fills the congestion or receiver
    window.[¶](#section-6.1-14.3.1){.pilcrow}
    :::
:::
:::

::: {#sec_acknowledgements_of_reception_of_data_chunks}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Acknowledgement on Reception of DATA Chunks](#name-acknowledgement-on-receptio){.section-name .selfRef} {#name-acknowledgement-on-receptio}

The SCTP endpoint [MUST]{.bcp14} always acknowledge the reception of
each valid DATA chunk when the DATA chunk received is inside its receive
window.[¶](#section-6.2-1){.pilcrow}

When the receiver\'s advertised window is 0, the receiver [MUST]{.bcp14}
drop any new incoming DATA chunk with a TSN larger than the largest TSN
received so far. Also, if the new incoming DATA chunk holds a TSN value
less than the largest TSN received so far, then the receiver
[SHOULD]{.bcp14} drop the largest TSN held for reordering and accept the
new incoming DATA chunk. In either case, if such a DATA chunk is
dropped, the receiver [MUST]{.bcp14} immediately send back a SACK chunk
with the current receive window showing only DATA chunks received and
accepted so far. The dropped DATA chunk(s) [MUST NOT]{.bcp14} be
included in the SACK chunk, as they were not accepted. The receiver
[MUST]{.bcp14} also have an algorithm for advertising its receive window
to avoid receiver silly window syndrome (SWS), as described in
\[[RFC1122](#RFC1122){.xref}\]. The algorithm can be similar to the one
described in [Section
4.2.3.3](https://www.rfc-editor.org/rfc/rfc1122#section-4.2.3.3){.relref}
of \[[RFC1122](#RFC1122){.xref}\].[¶](#section-6.2-2){.pilcrow}

The guidelines on the delayed acknowledgement algorithm specified in
[Section
4.2](https://www.rfc-editor.org/rfc/rfc5681#section-4.2){.relref} of
\[[RFC5681](#RFC5681){.xref}\] [SHOULD]{.bcp14} be followed.
Specifically, an acknowledgement [SHOULD]{.bcp14} be generated for at
least every second packet (not every second DATA chunk) received and
[SHOULD]{.bcp14} be generated within 200 ms of the arrival of any
unacknowledged DATA chunk. In some situations, it might be beneficial
for an SCTP transmitter to be more conservative than the algorithms
detailed in this document allow. However, an SCTP transmitter [MUST
NOT]{.bcp14} be more aggressive in sending SACK chunks than the
following algorithms allow.[¶](#section-6.2-3){.pilcrow}

An SCTP receiver [MUST NOT]{.bcp14} generate more than one SACK chunk
for every incoming packet, other than to update the offered window as
the receiving application consumes new data. When the window opens up,
an SCTP receiver [SHOULD]{.bcp14} send additional SACK chunks to update
the window even if no new data is received. The receiver [MUST]{.bcp14}
avoid sending a large number of window updates \-- in particular, large
bursts of them. One way to achieve this is to send a window update only
if the window can be increased by at least a quarter of the receive
buffer size of the association.[¶](#section-6.2-4){.pilcrow}

Implementation Note: The maximum delay for generating an acknowledgement
[MAY]{.bcp14} be configured by the SCTP administrator, either statically
or dynamically, in order to meet the specific timing requirement of the
protocol being carried.[¶](#section-6.2-5){.pilcrow}

An implementation [MUST NOT]{.bcp14} allow the maximum delay (protocol
parameter \'SACK.Delay\') to be configured to be more than 500 ms. In
other words, an implementation [MAY]{.bcp14} lower the value of
\'SACK.Delay\' below 500 ms but [MUST NOT]{.bcp14} raise it above 500
ms.[¶](#section-6.2-6){.pilcrow}

Acknowledgements [MUST]{.bcp14} be sent in SACK chunks unless shutdown
was requested by the ULP, in which case an endpoint [MAY]{.bcp14} send
an acknowledgement in the SHUTDOWN chunk. A SACK chunk can acknowledge
the reception of multiple DATA chunks. See [Section
3.3.4](#sec_sack_chunk){.xref} for SACK chunk format. In particular, the
SCTP endpoint [MUST]{.bcp14} fill in the Cumulative TSN Ack field to
indicate the latest sequential TSN (of a valid DATA chunk) it has
received. Any received DATA chunks with TSN greater than the value in
the Cumulative TSN Ack field are reported in the Gap Ack Block fields.
The SCTP endpoint [MUST]{.bcp14} report as many Gap Ack Blocks as can
fit in a single SACK chunk such that the size of the SCTP packet does
not exceed the current PMTU.[¶](#section-6.2-7){.pilcrow}

The SHUTDOWN chunk does not contain Gap Ack Block fields. Therefore, the
endpoint [SHOULD]{.bcp14} use a SACK chunk instead of the SHUTDOWN chunk
to acknowledge DATA chunks received out of
order.[¶](#section-6.2-8){.pilcrow}

Upon receipt of an SCTP packet containing a DATA chunk with the I bit
set, the receiver [SHOULD NOT]{.bcp14} delay the sending of the
corresponding SACK chunk, i.e., the receiver [SHOULD]{.bcp14}
immediately respond with the corresponding SACK
chunk.[¶](#section-6.2-9){.pilcrow}

When a packet arrives with duplicate DATA chunk(s) and with no new DATA
chunk(s), the endpoint [MUST]{.bcp14} immediately send a SACK chunk with
no delay. If a packet arrives with duplicate DATA chunk(s) bundled with
new DATA chunks, the endpoint [MAY]{.bcp14} immediately send a SACK
chunk. Normally, receipt of duplicate DATA chunks will occur when the
original SACK chunk was lost and the peer\'s RTO has expired. The
duplicate TSN number(s) [SHOULD]{.bcp14} be reported in the SACK chunk
as duplicate.[¶](#section-6.2-10){.pilcrow}

When an endpoint receives a SACK chunk, it [MAY]{.bcp14} use the
duplicate TSN information to determine if SACK chunk loss is occurring.
Further use of this data is for future
study.[¶](#section-6.2-11){.pilcrow}

The data receiver is responsible for maintaining its receive buffers.
The data receiver [SHOULD]{.bcp14} notify the data sender in a timely
manner of changes in its ability to receive data. How an implementation
manages its receive buffers is dependent on many factors (e.g.,
operating system, memory management system, amount of memory, etc.).
However, the data sender strategy defined in [Section
6.2.1](#sec_processing_of_received_sack){.xref} is based on the
assumption of receiver operation similar to the
following:[¶](#section-6.2-12){.pilcrow}

[]{.break}

A\)

:   At initialization of the association, the endpoint tells the peer
    how much receive buffer space it has allocated to the association in
    the INIT or INIT ACK chunk. The endpoint sets a_rwnd to this
    value.[¶](#section-6.2-13.1.1){.pilcrow}

:   

B\)

:   As DATA chunks are received and buffered, decrement a_rwnd by the
    number of bytes received and buffered. This is, in effect, closing
    rwnd at the data sender and restricting the amount of data it can
    transmit.[¶](#section-6.2-13.2.1){.pilcrow}

:   

C\)

:   As DATA chunks are delivered to the ULP and released from the
    receive buffers, increment a_rwnd by the number of bytes delivered
    to the upper layer. This is, in effect, opening up rwnd on the data
    sender and allowing it to send more data. The data receiver [SHOULD
    NOT]{.bcp14} increment a_rwnd unless it has released bytes from its
    receive buffer. For example, if the receiver is holding fragmented
    DATA chunks in a reassembly queue, it [SHOULD NOT]{.bcp14} increment
    a_rwnd.[¶](#section-6.2-13.3.1){.pilcrow}

:   

D\)

:   When sending a SACK chunk, the data receiver [SHOULD]{.bcp14} place
    the current value of a_rwnd into the a_rwnd field. The data receiver
    [SHOULD]{.bcp14} take into account that the data sender will not
    retransmit DATA chunks that are acked via the Cumulative TSN Ack
    (i.e., will drop from its retransmit
    queue).[¶](#section-6.2-13.4.1){.pilcrow}

:   

Under certain circumstances, the data receiver [MAY]{.bcp14} drop DATA
chunks that it has received but has not released from its receive
buffers (i.e., delivered to the ULP). These DATA chunks might have been
acked in Gap Ack Blocks. For example, the data receiver might be holding
data in its receive buffers while reassembling a fragmented user message
from its peer when it runs out of receive buffer space. It [MAY]{.bcp14}
drop these DATA chunks even though it has acknowledged them in Gap Ack
Blocks. If a data receiver drops DATA chunks, it [MUST NOT]{.bcp14}
include them in Gap Ack Blocks in subsequent SACK chunks until they are
received again via retransmission. In addition, the endpoint
[SHOULD]{.bcp14} take into account the dropped data when calculating its
a_rwnd.[¶](#section-6.2-14){.pilcrow}

An endpoint [SHOULD NOT]{.bcp14} revoke a SACK chunk and discard data.
Only in extreme circumstances might an endpoint use this procedure (such
as out of buffer space). The data receiver [SHOULD]{.bcp14} take into
account that dropping data that has been acked in Gap Ack Blocks can
result in suboptimal retransmission strategies in the data sender and
thus in suboptimal performance.[¶](#section-6.2-15){.pilcrow}

The following example illustrates the use of delayed
acknowledgements:[¶](#section-6.2-16){.pilcrow}

[]{#name-delayed-acknowledgement-exa}

::: {#fig_delayed_ack_example}
::: {#section-6.2-17.1 .alignCenter .art-text .artwork}
    Endpoint A                                      Endpoint Z

    {App sends 3 messages; strm 0}
    DATA [TSN=7,Strm=0,Seq=3] ------------> (ack delayed)
    (Start T3-rtx timer)

    DATA [TSN=8,Strm=0,Seq=4] ------------> (send ack)
                                  /------- SACK [TSN Ack=8,block=0]
    (cancel T3-rtx timer)  <-----/

    DATA [TSN=9,Strm=0,Seq=5] ------------> (ack delayed)
    (Start T3-rtx timer)
                                           ...
                                           {App sends 1 message; strm 1}
                                           (bundle SACK with DATA)
                                    /----- SACK [TSN Ack=9,block=0] \
                                   /         DATA [TSN=6,Strm=1,Seq=2]
    (cancel T3-rtx timer)  <------/        (Start T3-rtx timer)

    (ack delayed)
    (send ack)
    SACK [TSN Ack=6,block=0] -------------> (cancel T3-rtx timer)
:::

[Figure 7](#figure-7){.selfRef}: [Delayed Acknowledgement
Example](#name-delayed-acknowledgement-exa){.selfRef}
:::

If an endpoint receives a DATA chunk with no user data (i.e., the Length
field is set to 16), it [SHOULD]{.bcp14} send an ABORT chunk with a \"No
User Data\" error cause.[¶](#section-6.2-18){.pilcrow}

An endpoint [SHOULD NOT]{.bcp14} send a DATA chunk with no user data
part. This avoids the need to be able to return a zero-length user
message in the API, especially in the socket API as specified in
\[[RFC6458](#RFC6458){.xref}\] for
details.[¶](#section-6.2-19){.pilcrow}

::: {#sec_processing_of_received_sack}
::: {#section-6.2.1 .section}
#### [6.2.1.](#section-6.2.1){.section-number .selfRef} [Processing a Received SACK Chunk](#name-processing-a-received-sack-){.section-name .selfRef} {#name-processing-a-received-sack-}

Each SACK chunk an endpoint receives contains an a_rwnd value. This
value represents the amount of buffer space the data receiver, at the
time of transmitting the SACK chunk, has left of its total receive
buffer space (as specified in the INIT/INIT ACK chunk). Using a_rwnd,
Cumulative TSN Ack, and Gap Ack Blocks, the data sender can develop a
representation of the peer\'s receive buffer
space.[¶](#section-6.2.1-1){.pilcrow}

One of the problems the data sender takes into account when processing a
SACK chunk is that a SACK chunk can be received out of order. That is, a
SACK chunk sent by the data receiver can pass an earlier SACK chunk and
be received first by the data sender. If a SACK chunk is received out of
order, the data sender can develop an incorrect view of the peer\'s
receive buffer space.[¶](#section-6.2.1-2){.pilcrow}

Since there is no explicit identifier that can be used to detect
out-of-order SACK chunks, the data sender uses heuristics to determine
if a SACK chunk is new.[¶](#section-6.2.1-3){.pilcrow}

An endpoint [SHOULD]{.bcp14} use the following rules to calculate the
rwnd, using the a_rwnd value, the Cumulative TSN Ack, and Gap Ack Blocks
in a received SACK chunk.[¶](#section-6.2.1-4){.pilcrow}

[]{.break}

A\)

:   At the establishment of the association, the endpoint initializes
    the rwnd to the Advertised Receiver Window Credit (a_rwnd) the peer
    specified in the INIT or INIT ACK
    chunk.[¶](#section-6.2.1-5.1.1){.pilcrow}

:   

B\)

:   Any time a DATA chunk is transmitted (or retransmitted) to a peer,
    the endpoint subtracts the data size of the chunk from the rwnd of
    that peer.[¶](#section-6.2.1-5.2.1){.pilcrow}

:   

C\)

:   Any time a DATA chunk is marked for retransmission, either via
    T3-rtx timer expiration ([Section
    6.3.3](#sec_handle_t3_rtx_expiration){.xref}) or via Fast Retransmit
    ([Section 7.2.4](#sec_fast_retransmit_on_gap_reports){.xref}), add
    the data size of those chunks to the
    rwnd.[¶](#section-6.2.1-5.3.1){.pilcrow}

:   

D\)

:   Any time a SACK chunk arrives, the endpoint performs the
    following:[¶](#section-6.2.1-5.4.1){.pilcrow}

    []{.break}

    i\)

    :   If Cumulative TSN Ack is less than the Cumulative TSN Ack Point,
        then drop the SACK chunk. Since Cumulative TSN Ack is
        monotonically increasing, a SACK chunk whose Cumulative TSN Ack
        is less than the Cumulative TSN Ack Point indicates an
        out-of-order SACK chunk.[¶](#section-6.2.1-5.4.2.1.1){.pilcrow}

    :   

    ii\)

    :   Set rwnd equal to the newly received a_rwnd minus the number of
        bytes still outstanding after processing the Cumulative TSN Ack
        and the Gap Ack Blocks.[¶](#section-6.2.1-5.4.2.2.1){.pilcrow}

    :   

    iii\)

    :   If the SACK chunk is missing a TSN that was previously
        acknowledged via a Gap Ack Block (e.g., the data receiver
        reneged on the data), then consider the corresponding DATA that
        might be possibly missing: Count one miss indication towards
        Fast Retransmit as described in [Section
        7.2.4](#sec_fast_retransmit_on_gap_reports){.xref}, and if no
        retransmit timer is running for the destination address to which
        the DATA chunk was originally transmitted, then T3-rtx is
        started for that destination
        address.[¶](#section-6.2.1-5.4.2.3.1){.pilcrow}

    :   

    iv\)

    :   If the Cumulative TSN Ack matches or exceeds the Fast Recovery
        exit point ([Section
        7.2.4](#sec_fast_retransmit_on_gap_reports){.xref}), Fast
        Recovery is exited.[¶](#section-6.2.1-5.4.2.4.1){.pilcrow}

    :   

:   
:::
:::
:::
:::

::: {#sec_management_of_retransission_timer}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Management of Retransmission Timer](#name-management-of-retransmissio){.section-name .selfRef} {#name-management-of-retransmissio}

An SCTP endpoint uses a retransmission timer T3-rtx to ensure data
delivery in the absence of any feedback from its peer. The duration of
this timer is referred to as RTO (retransmission
timeout).[¶](#section-6.3-1){.pilcrow}

When an endpoint\'s peer is multi-homed, the endpoint will calculate a
separate RTO for each different destination transport address of its
peer endpoint.[¶](#section-6.3-2){.pilcrow}

The computation and management of RTO in SCTP follow closely how TCP
manages its retransmission timer. To compute the current RTO, an
endpoint maintains two state variables per destination transport
address: SRTT (smoothed round-trip time) and RTTVAR (round-trip time
variation).[¶](#section-6.3-3){.pilcrow}

::: {#sec_rto_calculation}
::: {#section-6.3.1 .section}
#### [6.3.1.](#section-6.3.1){.section-number .selfRef} [RTO Calculation](#name-rto-calculation){.section-name .selfRef} {#name-rto-calculation}

The rules governing the computation of SRTT, RTTVAR, and RTO are as
follows:[¶](#section-6.3.1-1){.pilcrow}

[]{.break}

C1)

:   Until an RTT measurement has been made for a packet sent to the
    given destination transport address, set RTO to the protocol
    parameter \'RTO.Initial\'.[¶](#section-6.3.1-2.1.1){.pilcrow}

:   

C2)

:   When the first RTT measurement R is made,
    perform:[¶](#section-6.3.1-2.2.1){.pilcrow}

    ::: {#section-6.3.1-2.2.2}
    ``` {.lang-pseudocode .sourcecode}
    SRTT = R
    RTTVAR = R/2
    RTO = SRTT + 4 * RTTVAR
    ```

    [¶](#section-6.3.1-2.2.2){.pilcrow}
    :::

:   

C3)

:   When a new RTT measurement R\' is made,
    perform:[¶](#section-6.3.1-2.3.1){.pilcrow}

    ::: {#section-6.3.1-2.3.2}
    ``` {.lang-pseudocode .sourcecode}
    RTTVAR = (1 - RTO.Beta) * RTTVAR + RTO.Beta * |SRTT - R'|
    SRTT = (1 - RTO.Alpha) * SRTT + RTO.Alpha * R'
    ```

    [¶](#section-6.3.1-2.3.2){.pilcrow}
    :::

    Note: The value of SRTT used in the update to RTTVAR is its value
    before updating SRTT itself using the second
    assignment.[¶](#section-6.3.1-2.3.3){.pilcrow}

    After the computation, update:[¶](#section-6.3.1-2.3.4){.pilcrow}

    ::: {#section-6.3.1-2.3.5}
    ``` {.lang-pseudocode .sourcecode}
    RTO = SRTT + 4 * RTTVAR
    ```

    [¶](#section-6.3.1-2.3.5){.pilcrow}
    :::

:   

C4)

:   When data is in flight and when allowed by rule C5 below, a new RTT
    measurement [MUST]{.bcp14} be made each round trip. Furthermore, new
    RTT measurements [SHOULD]{.bcp14} be made no more than once per
    round trip for a given destination transport address. There are two
    reasons for this recommendation: First, it appears that measuring
    more frequently often does not in practice yield any significant
    benefit \[[ALLMAN99](#ALLMAN99){.xref}\]; second, if measurements
    are made more often, then the values of \'RTO.Alpha\' and
    \'RTO.Beta\' in rule C3 above [SHOULD]{.bcp14} be adjusted so that
    SRTT and RTTVAR still adjust to changes at roughly the same rate (in
    terms of how many round trips it takes them to reflect new values)
    as they would if making only one measurement per round trip and
    using \'RTO.Alpha\' and \'RTO.Beta\' as given in rule C3. However,
    the exact nature of these adjustments remains a research
    issue.[¶](#section-6.3.1-2.4.1){.pilcrow}

:   

C5)

:   Karn\'s algorithm: RTT measurements [MUST NOT]{.bcp14} be made using
    chunks that were retransmitted (and thus for which it is ambiguous
    whether the reply was for the first instance of the chunk or for a
    later instance).[¶](#section-6.3.1-2.5.1){.pilcrow}

    RTT measurements [SHOULD]{.bcp14} only be made using a DATA chunk
    with TSN r if no DATA chunk with TSN less than or equal to r was
    retransmitted since the DATA chunk with TSN r was sent
    first.[¶](#section-6.3.1-2.5.2){.pilcrow}

:   

C6)

:   Whenever RTO is computed, if it is less than \'RTO.Min\' seconds,
    then it is rounded up to \'RTO.Min\' seconds. The reason for this
    rule is that RTOs that do not have a high minimum value are
    susceptible to unnecessary timeouts
    \[[ALLMAN99](#ALLMAN99){.xref}\].[¶](#section-6.3.1-2.6.1){.pilcrow}

:   

C7)

:   A maximum value [MAY]{.bcp14} be placed on RTO, provided it is at
    least \'RTO.Max\' seconds.[¶](#section-6.3.1-2.7.1){.pilcrow}

:   

There is no requirement for the clock granularity G used for computing
RTT measurements and the different state variables, other
than:[¶](#section-6.3.1-3){.pilcrow}

[]{.break}

G1)

:   Whenever RTTVAR is computed, if RTTVAR == 0, then adjust RTTVAR =
    G.[¶](#section-6.3.1-4.1.1){.pilcrow}

:   

Experience \[[ALLMAN99](#ALLMAN99){.xref}\] has shown that finer clock
granularities (less than 100 msec) perform somewhat better than more
coarse granularities.[¶](#section-6.3.1-5){.pilcrow}

See [Section 16](#sec_parameter_values){.xref} for suggested parameter
values.[¶](#section-6.3.1-6){.pilcrow}
:::
:::

::: {#sec_retransmission_timer_rules}
::: {#section-6.3.2 .section}
#### [6.3.2.](#section-6.3.2){.section-number .selfRef} [Retransmission Timer Rules](#name-retransmission-timer-rules){.section-name .selfRef} {#name-retransmission-timer-rules}

The rules for managing the retransmission timer are as
follows:[¶](#section-6.3.2-1){.pilcrow}

[]{.break}

R1)

:   Every time a DATA chunk is sent to any address (including a
    retransmission), if the T3-rtx timer of that address is not running,
    start it running so that it will expire after the RTO of that
    address. The RTO used here is that obtained after any doubling due
    to previous T3-rtx timer expirations on the corresponding
    destination address as discussed in rule E2
    below.[¶](#section-6.3.2-2.1.1){.pilcrow}

:   

R2)

:   Whenever all outstanding data sent to an address have been
    acknowledged, turn off the T3-rtx timer of that
    address.[¶](#section-6.3.2-2.2.1){.pilcrow}

:   

R3)

:   Whenever a SACK chunk is received that acknowledges the DATA chunk
    with the earliest outstanding TSN for that address, restart the
    T3-rtx timer for that address with its current RTO (if there is
    still outstanding data on that
    address).[¶](#section-6.3.2-2.3.1){.pilcrow}

:   

R4)

:   Whenever a SACK chunk is received missing a TSN that was previously
    acknowledged via a Gap Ack Block, start the T3-rtx for the
    destination address to which the DATA chunk was originally
    transmitted if it is not already
    running.[¶](#section-6.3.2-2.4.1){.pilcrow}

:   

The following example shows the use of various timer rules (assuming
that the receiver uses delayed acks).[¶](#section-6.3.2-3){.pilcrow}

[]{#name-timer-rule-examples}

::: {#fig_timer_rule_examples}
::: {#section-6.3.2-4.1 .alignCenter .art-text .artwork}
    Endpoint A                                         Endpoint Z
    {App begins to send}
    Data [TSN=7,Strm=0,Seq=3] ------------> (ack delayed)
    (Start T3-rtx timer)
                                            {App sends 1 message; strm 1}
                                            (bundle ack with data)
    DATA [TSN=8,Strm=0,Seq=4] ----\     /-- SACK [TSN Ack=7,Block=0]
                                   \   /      DATA [TSN=6,Strm=1,Seq=2]
                                    \ /     (Start T3-rtx timer)
                                     \
                                    / \
    (Restart T3-rtx timer)  <------/   \--> (ack delayed)
    (ack delayed)
    {send ack}
    SACK [TSN Ack=6,Block=0] --------------> (Cancel T3-rtx timer)
                                            ..
                                            (send ack)
    (Cancel T3-rtx timer)  <-------------- SACK [TSN Ack=8,Block=0]
:::

[Figure 8](#figure-8){.selfRef}: [Timer Rule
Examples](#name-timer-rule-examples){.selfRef}
:::
:::
:::

::: {#sec_handle_t3_rtx_expiration}
::: {#section-6.3.3 .section}
#### [6.3.3.](#section-6.3.3){.section-number .selfRef} [Handle T3-rtx Expiration](#name-handle-t3-rtx-expiration){.section-name .selfRef} {#name-handle-t3-rtx-expiration}

Whenever the retransmission timer T3-rtx expires for a destination
address, do the following:[¶](#section-6.3.3-1){.pilcrow}

[]{.break}

E1)

:   For the destination address for which the timer expires, adjust its
    ssthresh with rules defined in [Section
    7.2.3](#sec_congestion_control_sub){.xref} and set cwnd =
    PMDCS.[¶](#section-6.3.3-2.1.1){.pilcrow}

:   

E2)

:   For the destination address for which the timer expires, set RTO =
    RTO \* 2 (\"back off the timer\"). The maximum value discussed in
    rule C7 above (\'RTO.Max\') [MAY]{.bcp14} be used to provide an
    upper bound to this doubling
    operation.[¶](#section-6.3.3-2.2.1){.pilcrow}

:   

E3)

:   Determine how many of the earliest (i.e., lowest TSN) outstanding
    DATA chunks for the address for which the T3-rtx has expired will
    fit into a single SCTP packet, subject to the PMTU corresponding to
    the destination transport address to which the retransmission is
    being sent (this might be different from the address for which the
    timer expires; see [Section
    6.4](#sec_multi_homed_sctp_endpoints){.xref}). Call this value K.
    Bundle and retransmit those K DATA chunks in a single packet to the
    destination endpoint.[¶](#section-6.3.3-2.3.1){.pilcrow}

:   

E4)

:   Start the retransmission timer T3-rtx on the destination address to
    which the retransmission is sent if rule R1 above indicates to do
    so. The RTO to be used for starting T3-rtx [SHOULD]{.bcp14} be the
    one for the destination address to which the retransmission is sent,
    which, when the receiver is multi-homed, might be different from the
    destination address for which the timer expired (see [Section
    6.4](#sec_multi_homed_sctp_endpoints){.xref}
    below).[¶](#section-6.3.3-2.4.1){.pilcrow}

:   

After retransmitting, once a new RTT measurement is obtained (which can
happen only when new data has been sent and acknowledged, per rule C5,
or for a measurement made from a HEARTBEAT chunk; see [Section
8.3](#sec_path_heartbeat){.xref}), the computation in rule C3 is
performed, including the computation of RTO, which might result in
\"collapsing\" RTO back down after it has been subject to doubling (rule
E2).[¶](#section-6.3.3-3){.pilcrow}

Any DATA chunks that were sent to the address for which the T3-rtx timer
expired but did not fit in an SCTP packet of size smaller than or equal
to the PMTU (rule E3 above) [SHOULD]{.bcp14} be marked for
retransmission and sent as soon as cwnd allows (normally, when a SACK
chunk arrives).[¶](#section-6.3.3-4){.pilcrow}

The final rule for managing the retransmission timer concerns failover
(see [Section
6.4.1](#sec_failover_from_an_inavtive_destination_address){.xref}):[¶](#section-6.3.3-5){.pilcrow}

[]{.break}

F1)

:   Whenever an endpoint switches from the current destination transport
    address to a different one, the current retransmission timers are
    left running. As soon as the endpoint transmits a packet containing
    DATA chunk(s) to the new transport address, start the timer on that
    transport address, using the RTO value of the destination address to
    which the data is being sent, if rule R1 indicates to do
    so.[¶](#section-6.3.3-6.1.1){.pilcrow}

:   
:::
:::
:::
:::

::: {#sec_multi_homed_sctp_endpoints}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [Multi-Homed SCTP Endpoints](#name-multi-homed-sctp-endpoints){.section-name .selfRef} {#name-multi-homed-sctp-endpoints}

An SCTP endpoint is considered multi-homed if there is more than one
transport address that can be used as a destination address to reach
that endpoint.[¶](#section-6.4-1){.pilcrow}

Moreover, the ULP of an endpoint selects one of the multiple destination
addresses of a multi-homed peer endpoint as the primary path (see
Sections [5.1.2](#sec_handle_address_parameters){.xref} and
[11.1](#sec_ulp_to_sctp){.xref} for
details).[¶](#section-6.4-2){.pilcrow}

By default, an endpoint [SHOULD]{.bcp14} always transmit to the primary
path, unless the SCTP user explicitly specifies the destination
transport address (and possibly source transport address) to
use.[¶](#section-6.4-3){.pilcrow}

An endpoint [SHOULD]{.bcp14} transmit reply chunks (e.g., INIT ACK,
COOKIE ACK, and HEARTBEAT ACK) in response to control chunks to the same
destination transport address from which it received the control chunk
to which it is replying.[¶](#section-6.4-4){.pilcrow}

The selection of the destination transport address for packets
containing SACK chunks is implementation dependent. However, an endpoint
[SHOULD NOT]{.bcp14} vary the destination transport address of a SACK
chunk when it receives DATA chunks coming from the same source
address.[¶](#section-6.4-5){.pilcrow}

When acknowledging multiple DATA chunks received in packets from
different source addresses in a single SACK chunk, the SACK chunk
[MAY]{.bcp14} be transmitted to one of the destination transport
addresses from which the DATA or control chunks being acknowledged were
received.[¶](#section-6.4-6){.pilcrow}

When a receiver of a duplicate DATA chunk sends a SACK chunk to a
multi-homed endpoint, it [MAY]{.bcp14} be beneficial to vary the
destination address and not use the source address of the DATA chunk.
The reason is that receiving a duplicate from a multi-homed endpoint
might indicate that the return path (as specified in the source address
of the DATA chunk) for the SACK chunk is
broken.[¶](#section-6.4-7){.pilcrow}

Furthermore, when its peer is multi-homed, an endpoint [SHOULD]{.bcp14}
try to retransmit a chunk that timed out to an active destination
transport address that is different from the last destination address to
which the chunk was sent.[¶](#section-6.4-8){.pilcrow}

When its peer is multi-homed, an endpoint [SHOULD]{.bcp14} send fast
retransmissions to the same destination transport address to which the
original data was sent. If the primary path has been changed and the
original data was sent to the old primary path before the Fast
Retransmit, the implementation [MAY]{.bcp14} send it to the new primary
path.[¶](#section-6.4-9){.pilcrow}

Retransmissions do not affect the total outstanding data count. However,
if the DATA chunk is retransmitted onto a different destination address,
both the outstanding data counts on the new destination address and the
old destination address to which the data chunk was last sent is
adjusted accordingly.[¶](#section-6.4-10){.pilcrow}

::: {#sec_failover_from_an_inavtive_destination_address}
::: {#section-6.4.1 .section}
#### [6.4.1.](#section-6.4.1){.section-number .selfRef} [Failover from an Inactive Destination Address](#name-failover-from-an-inactive-d){.section-name .selfRef} {#name-failover-from-an-inactive-d}

Some of the transport addresses of a multi-homed SCTP endpoint might
become inactive due to either the occurrence of certain error conditions
(see [Section 8.2](#sec_path_failure_detection){.xref}) or adjustments
from the SCTP user.[¶](#section-6.4.1-1){.pilcrow}

When there is outbound data to send and the primary path becomes
inactive (e.g., due to failures) or where the SCTP user explicitly
requests to send data to an inactive destination transport address
before reporting an error to its ULP, the SCTP endpoint [SHOULD]{.bcp14}
try to send the data to an alternate active destination transport
address if one exists.[¶](#section-6.4.1-2){.pilcrow}

When retransmitting data that timed out, if the endpoint is multi-homed,
it needs to consider each source-destination address pair in its
retransmission selection policy. When retransmitting timed-out data, the
endpoint [SHOULD]{.bcp14} attempt to pick the most divergent
source-destination pair from the original source-destination pair to
which the packet was transmitted.[¶](#section-6.4.1-3){.pilcrow}

Note: Rules for picking the most divergent source-destination pair are
an implementation decision and are not specified within this
document.[¶](#section-6.4.1-4){.pilcrow}
:::
:::
:::
:::

::: {#sec_stream_identifier_and_stream_sequence_number}
::: {#section-6.5 .section}
### [6.5.](#section-6.5){.section-number .selfRef} [Stream Identifier and Stream Sequence Number](#name-stream-identifier-and-strea){.section-name .selfRef} {#name-stream-identifier-and-strea}

Every DATA chunk [MUST]{.bcp14} carry a valid stream identifier. If an
endpoint receives a DATA chunk with an invalid stream identifier, it
[SHOULD]{.bcp14} acknowledge the reception of the DATA chunk following
the normal procedure, immediately send an ERROR chunk with cause set to
\"Invalid Stream Identifier\" (see [Section
3.3.10](#sec_error_chunk){.xref}), and discard the DATA chunk. The
endpoint [MAY]{.bcp14} bundle the ERROR chunk and the SACK chunk in the
same packet.[¶](#section-6.5-1){.pilcrow}

The Stream Sequence Number in all the outgoing streams [MUST]{.bcp14}
start from 0 when the association is established. The Stream Sequence
Number of an outgoing stream [MUST]{.bcp14} be incremented by 1 for each
ordered user message sent on that outgoing stream. In particular, when
the Stream Sequence Number reaches the value 65535, the next Stream
Sequence Number [MUST]{.bcp14} be set to 0. For unordered user messages,
the Stream Sequence Number [MUST NOT]{.bcp14} be
changed.[¶](#section-6.5-2){.pilcrow}
:::
:::

::: {#sec_ordered_and_unordered_delivery}
::: {#section-6.6 .section}
### [6.6.](#section-6.6){.section-number .selfRef} [Ordered and Unordered Delivery](#name-ordered-and-unordered-deliv){.section-name .selfRef} {#name-ordered-and-unordered-deliv}

Within a stream, an endpoint [MUST]{.bcp14} deliver DATA chunks received
with the U flag set to 0 to the upper layer according to the order of
their Stream Sequence Number. If DATA chunks arrive out of order of
their Stream Sequence Number, the endpoint [MUST]{.bcp14} hold the
received DATA chunks from delivery to the ULP until they are
reordered.[¶](#section-6.6-1){.pilcrow}

However, an SCTP endpoint can indicate that no ordered delivery is
required for a particular DATA chunk transmitted within the stream by
setting the U flag of the DATA chunk to 1.[¶](#section-6.6-2){.pilcrow}

When an endpoint receives a DATA chunk with the U flag set to 1, it
bypasses the ordering mechanism and immediately deliver the data to the
upper layer (after reassembly if the user data is fragmented by the data
sender).[¶](#section-6.6-3){.pilcrow}

This provides an effective way of transmitting \"out-of-band\" data in a
given stream. Also, a stream can be used as an \"unordered\" stream by
simply setting the U flag to 1 in all DATA chunks sent through that
stream.[¶](#section-6.6-4){.pilcrow}

Implementation Note: When sending an unordered DATA chunk, an
implementation [MAY]{.bcp14} choose to place the DATA chunk in an
outbound packet that is at the head of the outbound transmission queue
if possible.[¶](#section-6.6-5){.pilcrow}

The \'Stream Sequence Number\' field in a DATA chunk with U flag set to
1 has no significance. The sender can fill the \'Stream Sequence
Number\' with arbitrary value, but the receiver [MUST]{.bcp14} ignore
the field.[¶](#section-6.6-6){.pilcrow}

Note: When transmitting ordered and unordered data, an endpoint does not
increment its Stream Sequence Number when transmitting a DATA chunk with
U flag set to 1.[¶](#section-6.6-7){.pilcrow}
:::
:::

::: {#sec_report_gaps_in_received_data_tsns}
::: {#section-6.7 .section}
### [6.7.](#section-6.7){.section-number .selfRef} [Report Gaps in Received DATA TSNs](#name-report-gaps-in-received-dat){.section-name .selfRef} {#name-report-gaps-in-received-dat}

Upon the reception of a new DATA chunk, an endpoint examines the
continuity of the TSNs received. If the endpoint detects a gap in the
received DATA chunk sequence, it [SHOULD]{.bcp14} send a SACK chunk with
Gap Ack Blocks immediately. The data receiver continues sending a SACK
chunk after receipt of each SCTP packet that does not fill the
gap.[¶](#section-6.7-1){.pilcrow}

Based on the Gap Ack Block from the received SACK chunk, the endpoint
can calculate the missing DATA chunks and make decisions on whether to
retransmit them (see [Section
6.2.1](#sec_processing_of_received_sack){.xref} for
details).[¶](#section-6.7-2){.pilcrow}

Multiple gaps can be reported in one single SACK chunk (see [Section
3.3.4](#sec_sack_chunk){.xref}).[¶](#section-6.7-3){.pilcrow}

When its peer is multi-homed, the SCTP endpoint [SHOULD]{.bcp14} always
try to send the SACK chunk to the same destination address from which
the last DATA chunk was received.[¶](#section-6.7-4){.pilcrow}

Upon the reception of a SACK chunk, the endpoint [MUST]{.bcp14} remove
all DATA chunks that have been acknowledged by the SACK chunk\'s
Cumulative TSN Ack from its transmit queue. All DATA chunks with TSNs
not included in the Gap Ack Blocks that are smaller than the
highest-acknowledged TSN reported in the SACK chunk [MUST]{.bcp14} be
treated as \"missing\" by the sending endpoint. The number of
\"missing\" reports for each outstanding DATA chunk [MUST]{.bcp14} be
recorded by the data sender to make retransmission decisions. See
[Section 7.2.4](#sec_fast_retransmit_on_gap_reports){.xref} for
details.[¶](#section-6.7-5){.pilcrow}

The following example shows the use of SACK chunk to report a
gap.[¶](#section-6.7-6){.pilcrow}

[]{#name-reporting-a-gap-using-sack-}

::: {#fig_report_gap_using_sack}
::: {#section-6.7-7.1 .alignCenter .art-text .artwork}
    Endpoint A                                    Endpoint Z
    {App sends 3 messages; strm 0}
    DATA [TSN=6,Strm=0,Seq=2] ---------------> (ack delayed)
    (Start T3-rtx timer)

    DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)

    DATA [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,
                                                immediately send ack)
                                    /----- SACK [TSN Ack=6,Block=1,
                                   /             Start=2,End=2]
                            <-----/
    (remove 6 from out-queue,
     and mark 7 as "1" missing report)
:::

[Figure 9](#figure-9){.selfRef}: [Reporting a Gap Using SACK
Chunk](#name-reporting-a-gap-using-sack-){.selfRef}
:::

The maximum number of Gap Ack Blocks that can be reported within a
single SACK chunk is limited by the current PMTU. When a single SACK
chunk cannot cover all the Gap Ack Blocks needed to be reported due to
the PMTU limitation, the endpoint [MUST]{.bcp14} send only one SACK
chunk. This single SACK chunk [MUST]{.bcp14} report the Gap Ack Blocks
from the lowest to highest TSNs, within the size limit set by the PMTU,
and leave the remaining highest TSN numbers
unacknowledged.[¶](#section-6.7-8){.pilcrow}
:::
:::

::: {#sec_crc32c_checksum_calculation}
::: {#section-6.8 .section}
### [6.8.](#section-6.8){.section-number .selfRef} [CRC32c Checksum Calculation](#name-crc32c-checksum-calculation){.section-name .selfRef} {#name-crc32c-checksum-calculation}

When sending an SCTP packet, the endpoint [MUST]{.bcp14} strengthen the
data integrity of the transmission by including the CRC32c checksum
value calculated on the packet, as described
below.[¶](#section-6.8-1){.pilcrow}

After the packet is constructed (containing the SCTP common header and
one or more control or DATA chunks), the transmitter
[MUST]{.bcp14}:[¶](#section-6.8-2){.pilcrow}

[]{.break}

1\)

:   fill in the proper Verification Tag in the SCTP common header and
    initialize the checksum field to 0,[¶](#section-6.8-3.1.1){.pilcrow}

:   

2\)

:   calculate the CRC32c checksum of the whole packet, including the
    SCTP common header and all the chunks (refer to [Appendix
    A](#sec_crc32c){.xref} for details of the CRC32c algorithm),
    and[¶](#section-6.8-3.2.1){.pilcrow}

:   

3\)

:   put the resultant value into the checksum field in the common header
    and leave the rest of the bits
    unchanged.[¶](#section-6.8-3.3.1){.pilcrow}

:   

When an SCTP packet is received, the receiver [MUST]{.bcp14} first check
the CRC32c checksum as follows:[¶](#section-6.8-4){.pilcrow}

[]{.break}

1\)

:   Store the received CRC32c checksum value
    aside.[¶](#section-6.8-5.1.1){.pilcrow}

:   

2\)

:   Replace the 32 bits of the checksum field in the received SCTP
    packet with 0 and calculate a CRC32c checksum value of the whole
    received packet.[¶](#section-6.8-5.2.1){.pilcrow}

:   

3\)

:   Verify that the calculated CRC32c checksum is the same as the
    received CRC32c checksum. If it is not, the receiver [MUST]{.bcp14}
    treat the packet as an invalid SCTP
    packet.[¶](#section-6.8-5.3.1){.pilcrow}

:   

The default procedure for handling invalid SCTP packets is to silently
discard them.[¶](#section-6.8-6){.pilcrow}

Any hardware implementation [SHOULD]{.bcp14} permit alternative
verification of the CRC in software.[¶](#section-6.8-7){.pilcrow}
:::
:::

::: {#sec_frag_reass}
::: {#section-6.9 .section}
### [6.9.](#section-6.9){.section-number .selfRef} [Fragmentation and Reassembly](#name-fragmentation-and-reassembl){.section-name .selfRef} {#name-fragmentation-and-reassembl}

An endpoint [MAY]{.bcp14} support fragmentation when sending DATA
chunks, but it [MUST]{.bcp14} support reassembly when receiving DATA
chunks. If an endpoint supports fragmentation, it [MUST]{.bcp14}
fragment a user message if the size of the user message to be sent
causes the outbound SCTP packet size to exceed the current PMTU. An
endpoint that does not support fragmentation and is requested to send a
user message such that the outbound SCTP packet size would exceed the
current PMTU [MUST]{.bcp14} return an error to its upper layer and [MUST
NOT]{.bcp14} attempt to send the user
message.[¶](#section-6.9-1){.pilcrow}

An SCTP implementation [MAY]{.bcp14} provide a mechanism to the upper
layer that disables fragmentation when sending DATA chunks. When
fragmentation of DATA chunks is disabled, the SCTP implementation
[MUST]{.bcp14} behave in the same way an implementation that does not
support fragmentation, i.e., it rejects calls that would result in
sending SCTP packets that exceed the current
PMTU.[¶](#section-6.9-2){.pilcrow}

Implementation Note: In this error case, the SEND primitive discussed in
[Section 11.1.5](#sec_send){.xref} would need to return an error to the
upper layer.[¶](#section-6.9-3){.pilcrow}

If its peer is multi-homed, the endpoint [SHOULD]{.bcp14} choose a DATA
chunk size smaller than or equal to the
AMDCS.[¶](#section-6.9-4){.pilcrow}

Once a user message is fragmented, it cannot be re-fragmented. Instead,
if the PMTU has been reduced, then IP fragmentation [MUST]{.bcp14} be
used. Therefore, an SCTP association can fail if IP fragmentation is not
working on any path. Please see [Section
7.3](#sec_path_mtu_discovery){.xref} for details of PMTU
discovery.[¶](#section-6.9-5){.pilcrow}

When determining when to fragment, the SCTP implementation
[MUST]{.bcp14} take into account the SCTP packet header as well as the
DATA chunk header(s). The implementation [MUST]{.bcp14} also take into
account the space required for a SACK chunk if bundling a SACK chunk
with the DATA chunk.[¶](#section-6.9-6){.pilcrow}

Fragmentation takes the following steps:[¶](#section-6.9-7){.pilcrow}

[]{.break}

1\)

:   The data sender [MUST]{.bcp14} break the user message into a series
    of DATA chunks. The sender [SHOULD]{.bcp14} choose a size of DATA
    chunks that is smaller than or equal to the
    AMDCS.[¶](#section-6.9-8.1.1){.pilcrow}

:   

2\)

:   The transmitter [MUST]{.bcp14} then assign, in sequence, a separate
    TSN to each of the DATA chunks in the series. The transmitter
    assigns the same Stream Sequence Number to each of the DATA chunks.
    If the user indicates that the user message is to be delivered using
    unordered delivery, then the U flag of each DATA chunk of the user
    message [MUST]{.bcp14} be set to 1.[¶](#section-6.9-8.2.1){.pilcrow}

:   

3\)

:   The transmitter [MUST]{.bcp14} also set the B/E bits of the first
    DATA chunk in the series to 10, the B/E bits of the last DATA chunk
    in the series to 01, and the B/E bits of all other DATA chunks in
    the series to 00.[¶](#section-6.9-8.3.1){.pilcrow}

:   

An endpoint [MUST]{.bcp14} recognize fragmented DATA chunks by examining
the B/E bits in each of the received DATA chunks and queue the
fragmented DATA chunks for reassembly. Once the user message is
reassembled, SCTP passes the reassembled user message to the specific
stream for possible reordering and final
dispatching.[¶](#section-6.9-9){.pilcrow}

If the data receiver runs out of buffer space while still waiting for
more fragments to complete the reassembly of the message, it
[SHOULD]{.bcp14} dispatch part of its inbound message through a partial
delivery API (see [Section 11](#sec_api){.xref}), freeing some of its
receive buffer space so that the rest of the message can be
received.[¶](#section-6.9-10){.pilcrow}
:::
:::

::: {#sec_bundling}
::: {#section-6.10 .section}
### [6.10.](#section-6.10){.section-number .selfRef} [Bundling](#name-bundling){.section-name .selfRef} {#name-bundling}

An endpoint bundles chunks by simply including multiple chunks in one
outbound SCTP packet. The total size of the resultant SCTP packet
[MUST]{.bcp14} be less that or equal to the current
PMTU.[¶](#section-6.10-1){.pilcrow}

If its peer endpoint is multi-homed, the sending endpoint
[SHOULD]{.bcp14} choose a size no larger than the PMTU of the current
primary path.[¶](#section-6.10-2){.pilcrow}

When bundling control chunks with DATA chunks, an endpoint
[MUST]{.bcp14} place control chunks first in the outbound SCTP packet.
The transmitter [MUST]{.bcp14} transmit DATA chunks within an SCTP
packet in increasing order of TSN.[¶](#section-6.10-3){.pilcrow}

Note: Since control chunks are placed first in a packet and since DATA
chunks are transmitted before SHUTDOWN or SHUTDOWN ACK chunks, DATA
chunks cannot be bundled with SHUTDOWN or SHUTDOWN ACK
chunks.[¶](#section-6.10-4){.pilcrow}

Partial chunks [MUST NOT]{.bcp14} be placed in an SCTP packet. A partial
chunk is a chunk that is not completely contained in the SCTP packet;
i.e., the SCTP packet is too short to contain all the bytes of the chunk
as indicated by the chunk length.[¶](#section-6.10-5){.pilcrow}

An endpoint [MUST]{.bcp14} process received chunks in their order in the
packet. The receiver uses the Chunk Length field to determine the end of
a chunk and beginning of the next chunk, taking account of the fact that
all chunks end on a 4-byte boundary. If the receiver detects a partial
chunk, it [MUST]{.bcp14} drop the chunk.[¶](#section-6.10-6){.pilcrow}

An endpoint [MUST NOT]{.bcp14} bundle INIT, INIT ACK, or SHUTDOWN
COMPLETE chunks with any other chunks.[¶](#section-6.10-7){.pilcrow}
:::
:::
:::
:::

::: {#sec_congestion_control}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Congestion Control](#name-congestion-control){.section-name .selfRef} {#name-congestion-control}

Congestion control is one of the basic functions in SCTP. To manage
congestion, the mechanisms and algorithms in this section are to be
employed.[¶](#section-7-1){.pilcrow}

Implementation Note: As far as its specific performance requirements are
met, an implementation is always allowed to adopt a more conservative
congestion control algorithm than the one defined
below.[¶](#section-7-2){.pilcrow}

The congestion control algorithms used by SCTP are based on
\[[RFC5681](#RFC5681){.xref}\]. This section describes how the
algorithms defined in \[[RFC5681](#RFC5681){.xref}\] are adapted for use
in SCTP. We first list differences in protocol designs between TCP and
SCTP and then describe SCTP\'s congestion control scheme. The
description will use the same terminology as in TCP congestion control
whenever appropriate.[¶](#section-7-3){.pilcrow}

SCTP congestion control is always applied to the entire association and
not to individual streams.[¶](#section-7-4){.pilcrow}

::: {#sec_sctp_differences_from_tcp_congestion_control}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [SCTP Differences from TCP Congestion Control](#name-sctp-differences-from-tcp-c){.section-name .selfRef} {#name-sctp-differences-from-tcp-c}

Gap Ack Blocks in the SCTP SACK chunk carry the same semantic meaning as
the TCP SACK. TCP considers the information carried in the SACK as
advisory information only. SCTP considers the information carried in the
Gap Ack Blocks in the SACK chunk as advisory. In SCTP, any DATA chunk
that has been acknowledged by a SACK chunk, including DATA that arrived
at the receiving end out of order, is not considered fully delivered
until the Cumulative TSN Ack Point passes the TSN of the DATA chunk
(i.e., the DATA chunk has been acknowledged by the Cumulative TSN Ack
field in the SACK chunk). Consequently, the value of cwnd controls the
amount of outstanding data, rather than (as in the case of non-SACK TCP)
the upper bound between the highest acknowledged sequence number and the
latest DATA chunk that can be sent within the congestion window. SCTP
SACK leads to different implementations of Fast Retransmit and Fast
Recovery than non-SACK TCP. As an example, see
\[[FALL96](#FALL96){.xref}\].[¶](#section-7.1-1){.pilcrow}

The biggest difference between SCTP and TCP, however, is multi-homing.
SCTP is designed to establish robust communication associations between
two endpoints, each of which might be reachable by more than one
transport address. Potentially different addresses might lead to
different data paths between the two endpoints; thus, ideally, one needs
a separate set of congestion control parameters for each of the paths.
The treatment here of congestion control for multi-homed receivers is
new with SCTP and might require refinement in the future. The current
algorithms make the following assumptions:[¶](#section-7.1-2){.pilcrow}

-   ::: {#section-7.1-3.1}
    The sender usually uses the same destination address until being
    instructed by the upper layer to do otherwise; however, SCTP
    [MAY]{.bcp14} change to an alternate destination in the event an
    address is marked inactive (see [Section
    8.2](#sec_path_failure_detection){.xref}). Also, SCTP [MAY]{.bcp14}
    retransmit to a different transport address than the original
    transmission.[¶](#section-7.1-3.1.1){.pilcrow}
    :::

-   ::: {#section-7.1-3.2}
    The sender keeps a separate congestion control parameter set for
    each of the destination addresses it can send to (not each
    source-destination pair but for each destination). The parameters
    [SHOULD]{.bcp14} decay if the address is not used for a long enough
    time period. \[[RFC5681](#RFC5681){.xref}\] specifies this period of
    time as a retransmission timeout.[¶](#section-7.1-3.2.1){.pilcrow}
    :::

-   ::: {#section-7.1-3.3}
    For each of the destination addresses, an endpoint does slow start
    upon the first transmission to that
    address.[¶](#section-7.1-3.3.1){.pilcrow}
    :::

Note: TCP guarantees in-sequence delivery of data to its upper-layer
protocol within a single TCP session. This means that when TCP notices a
gap in the received sequence number, it waits until the gap is filled
before delivering the data that was received with sequence numbers
higher than that of the missing data. On the other hand, SCTP can
deliver data to its upper-layer protocol, even if there is a gap in TSN
if the Stream Sequence Numbers are in sequence for a particular stream
(i.e., the missing DATA chunks are for a different stream) or if
unordered delivery is indicated. Although this does not affect cwnd, it
might affect rwnd calculation.[¶](#section-7.1-4){.pilcrow}
:::
:::

::: {#sec_sctp_slow_start_and_congestion_avoidance}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [SCTP Slow-Start and Congestion Avoidance](#name-sctp-slow-start-and-congest){.section-name .selfRef} {#name-sctp-slow-start-and-congest}

The slow-start and congestion avoidance algorithms [MUST]{.bcp14} be
used by an endpoint to control the amount of data being injected into
the network. The congestion control in SCTP is employed in regard to the
association, not to an individual stream. In some situations, it might
be beneficial for an SCTP sender to be more conservative than the
algorithms allow; however, an SCTP sender [MUST NOT]{.bcp14} be more
aggressive than the following algorithms
allow.[¶](#section-7.2-1){.pilcrow}

Like TCP, an SCTP endpoint uses the following three control variables to
regulate its transmission rate.[¶](#section-7.2-2){.pilcrow}

-   ::: {#section-7.2-3.1}
    Receiver advertised window size (rwnd, in bytes), which is set by
    the receiver based on its available buffer space for incoming
    packets.[¶](#section-7.2-3.1.1){.pilcrow}

    Note: This variable is kept on the entire
    association.[¶](#section-7.2-3.1.2){.pilcrow}
    :::

-   ::: {#section-7.2-3.2}
    Congestion control window (cwnd, in bytes), which is adjusted by the
    sender based on observed network
    conditions.[¶](#section-7.2-3.2.1){.pilcrow}

    Note: This variable is maintained on a per-destination-address
    basis.[¶](#section-7.2-3.2.2){.pilcrow}
    :::

-   ::: {#section-7.2-3.3}
    Slow-start threshold (ssthresh, in bytes), which is used by the
    sender to distinguish slow-start and congestion avoidance
    phases.[¶](#section-7.2-3.3.1){.pilcrow}

    Note: This variable is maintained on a per-destination-address
    basis.[¶](#section-7.2-3.3.2){.pilcrow}
    :::

SCTP also requires one additional control variable, partial_bytes_acked,
which is used during the congestion avoidance phase to facilitate cwnd
adjustment.[¶](#section-7.2-4){.pilcrow}

Unlike TCP, an SCTP sender [MUST]{.bcp14} keep a set of the control
variables cwnd, ssthresh, and partial_bytes_acked for EACH destination
address of its peer (when its peer is multi-homed). When calculating one
of these variables, the length of the DATA chunk, including the padding,
[SHOULD]{.bcp14} be used.[¶](#section-7.2-5){.pilcrow}

Only one rwnd is kept for the whole association (no matter if the peer
is multi-homed or has a single address).[¶](#section-7.2-6){.pilcrow}

::: {#sec_slow_start}
::: {#section-7.2.1 .section}
#### [7.2.1.](#section-7.2.1){.section-number .selfRef} [Slow-Start](#name-slow-start){.section-name .selfRef} {#name-slow-start}

Beginning data transmission into a network with unknown conditions or
after a sufficiently long idle period requires SCTP to probe the network
to determine the available capacity. The slow-start algorithm is used
for this purpose at the beginning of a transfer or after repairing loss
detected by the retransmission timer.[¶](#section-7.2.1-1){.pilcrow}

-   ::: {#section-7.2.1-2.1}
    The initial cwnd before data transmission [MUST]{.bcp14} be set to
    min(4 \* PMDCS, max(2 \* PMDCS, 4404)) bytes if the peer address is
    an IPv4 address and to min(4 \* PMDCS, max(2 \* PMDCS, 4344)) bytes
    if the peer address is an IPv6
    address.[¶](#section-7.2.1-2.1.1){.pilcrow}
    :::

-   ::: {#section-7.2.1-2.2}
    The initial cwnd after a retransmission timeout [MUST]{.bcp14} be no
    more than PMDCS, and only one packet is allowed to be in flight
    until successful acknowledgement.[¶](#section-7.2.1-2.2.1){.pilcrow}
    :::

-   ::: {#section-7.2.1-2.3}
    The initial value of ssthresh [SHOULD]{.bcp14} be arbitrarily high
    (e.g., the size of the largest-possible advertised
    window).[¶](#section-7.2.1-2.3.1){.pilcrow}
    :::

-   ::: {#section-7.2.1-2.4}
    Whenever cwnd is greater than zero, the endpoint is allowed to have
    cwnd bytes of data outstanding on that transport address. A limited
    overbooking as described in rule B in [Section
    6.1](#sec_transmission_of_data_chunks){.xref} [SHOULD]{.bcp14} be
    supported.[¶](#section-7.2.1-2.4.1){.pilcrow}
    :::

-   ::: {#section-7.2.1-2.5}
    When cwnd is less than or equal to ssthresh, an SCTP endpoint
    [MUST]{.bcp14} use the slow-start algorithm to increase cwnd only if
    the current congestion window is being fully utilized and the data
    sender is not in Fast Recovery. Only when these two conditions are
    met can the cwnd be increased; otherwise, the cwnd [MUST
    NOT]{.bcp14} be increased. If these conditions are met, then cwnd
    [MUST]{.bcp14} be increased by, at most, the lesser
    of[¶](#section-7.2.1-2.5.1){.pilcrow}

    1.  ::: {#section-7.2.1-2.5.2.1}
        the total size of the previously outstanding DATA chunk(s)
        acknowledged and[¶](#section-7.2.1-2.5.2.1.1){.pilcrow}
        :::

    2.  ::: {#section-7.2.1-2.5.2.2}
        L times the destination\'s
        PMDCS.[¶](#section-7.2.1-2.5.2.2.1){.pilcrow}
        :::

    The first upper bound protects against the ACK-Splitting attack
    outlined in \[[SAVAGE99](#SAVAGE99){.xref}\]. The positive integer L
    [SHOULD]{.bcp14} be 1 and [MAY]{.bcp14} be larger than 1. See
    \[[RFC3465](#RFC3465){.xref}\] for details of choosing
    L.[¶](#section-7.2.1-2.5.3){.pilcrow}

    In instances where its peer endpoint is multi-homed, if an endpoint
    receives a SACK chunk that results in updating the cwnd, then it
    [SHOULD]{.bcp14} update its cwnd (or cwnds) apportioned to the
    destination addresses to which it transmitted the acknowledged
    data.[¶](#section-7.2.1-2.5.4){.pilcrow}
    :::

-   ::: {#section-7.2.1-2.6}
    While the endpoint does not transmit data on a given transport
    address, the cwnd of the transport address [SHOULD]{.bcp14} be
    adjusted to max(cwnd / 2, 4 \* PMDCS) once per RTO. Before the first
    cwnd adjustment, the ssthresh of the transport address
    [SHOULD]{.bcp14} be set to the
    cwnd.[¶](#section-7.2.1-2.6.1){.pilcrow}
    :::
:::
:::

::: {#sec_congestion_avoidance}
::: {#section-7.2.2 .section}
#### [7.2.2.](#section-7.2.2){.section-number .selfRef} [Congestion Avoidance](#name-congestion-avoidance){.section-name .selfRef} {#name-congestion-avoidance}

When cwnd is greater than ssthresh, cwnd [SHOULD]{.bcp14} be incremented
by PMDCS per RTT if the sender has cwnd or more bytes of data
outstanding for the corresponding transport address. The basic
recommendations for incrementing cwnd during congestion avoidance are as
follows:[¶](#section-7.2.2-1){.pilcrow}

-   ::: {#section-7.2.2-2.1}
    SCTP [MAY]{.bcp14} increment cwnd by
    PMDCS.[¶](#section-7.2.2-2.1.1){.pilcrow}
    :::

-   ::: {#section-7.2.2-2.2}
    SCTP [SHOULD]{.bcp14} increment cwnd by PMDCS once per RTT when the
    sender has cwnd or more bytes of data outstanding for the
    corresponding transport address.[¶](#section-7.2.2-2.2.1){.pilcrow}
    :::

-   ::: {#section-7.2.2-2.3}
    SCTP [MUST NOT]{.bcp14} increment cwnd by more than PMDCS per
    RTT.[¶](#section-7.2.2-2.3.1){.pilcrow}
    :::

In practice, an implementation can achieve this goal in the following
way:[¶](#section-7.2.2-3){.pilcrow}

-   ::: {#section-7.2.2-4.1}
    partial_bytes_acked is initialized to
    0.[¶](#section-7.2.2-4.1.1){.pilcrow}
    :::

-   ::: {#section-7.2.2-4.2}
    Whenever cwnd is greater than ssthresh, upon each SACK chunk
    arrival, increase partial_bytes_acked by the total number of bytes
    (including the chunk header and the padding) of all new DATA chunks
    acknowledged in that SACK chunk, including chunks acknowledged by
    the new Cumulative TSN Ack, by Gap Ack Blocks, and by the number of
    bytes of duplicated chunks reported in Duplicate
    TSNs.[¶](#section-7.2.2-4.2.1){.pilcrow}
    :::

-   ::: {#section-7.2.2-4.3}
    When (1) partial_bytes_acked is greater than cwnd and (2) before the
    arrival of the SACK chunk the sender had less than cwnd bytes of
    data outstanding (i.e., before the arrival of the SACK chunk,
    flightsize was less than cwnd), reset partial_bytes_acked to
    cwnd.[¶](#section-7.2.2-4.3.1){.pilcrow}
    :::

-   ::: {#section-7.2.2-4.4}
    When (1) partial_bytes_acked is equal to or greater than cwnd
    and (2) before the arrival of the SACK chunk the sender had cwnd or
    more bytes of data outstanding (i.e., before the arrival of the SACK
    chunk, flightsize was greater than or equal to cwnd),
    partial_bytes_acked is reset to (partial_bytes_acked - cwnd). Next,
    cwnd is increased by PMDCS.[¶](#section-7.2.2-4.4.1){.pilcrow}
    :::

-   ::: {#section-7.2.2-4.5}
    Same as in the slow start, when the sender does not transmit DATA
    chunks on a given transport address, the cwnd of the transport
    address [SHOULD]{.bcp14} be adjusted to max(cwnd / 2, 4 \* PMDCS)
    per RTO.[¶](#section-7.2.2-4.5.1){.pilcrow}
    :::

-   ::: {#section-7.2.2-4.6}
    When all of the data transmitted by the sender has been acknowledged
    by the receiver, partial_bytes_acked is initialized to
    0.[¶](#section-7.2.2-4.6.1){.pilcrow}
    :::
:::
:::

::: {#sec_congestion_control_sub}
::: {#section-7.2.3 .section}
#### [7.2.3.](#section-7.2.3){.section-number .selfRef} [Congestion Control](#name-congestion-control-2){.section-name .selfRef} {#name-congestion-control-2}

Upon detection of packet losses from SACK chunks (see [Section
7.2.4](#sec_fast_retransmit_on_gap_reports){.xref}), an endpoint
[SHOULD]{.bcp14} do the following:[¶](#section-7.2.3-1){.pilcrow}

::: {#section-7.2.3-2}
``` {.lang-pseudocode .sourcecode}
ssthresh = max(cwnd / 2, 4 * PMDCS)
cwnd = ssthresh
partial_bytes_acked = 0
```

[¶](#section-7.2.3-2){.pilcrow}
:::

Basically, a packet loss causes cwnd to be cut in
half.[¶](#section-7.2.3-3){.pilcrow}

When the T3-rtx timer expires on an address, SCTP [SHOULD]{.bcp14}
perform slow start by:[¶](#section-7.2.3-4){.pilcrow}

::: {#section-7.2.3-5}
``` {.lang-pseudocode .sourcecode}
ssthresh = max(cwnd / 2, 4 * PMDCS)
cwnd = PMDCS
partial_bytes_acked = 0
```

[¶](#section-7.2.3-5){.pilcrow}
:::

and ensure that no more than one SCTP packet will be in flight for that
address until the endpoint receives acknowledgement for successful
delivery of data to that address.[¶](#section-7.2.3-6){.pilcrow}
:::
:::

::: {#sec_fast_retransmit_on_gap_reports}
::: {#section-7.2.4 .section}
#### [7.2.4.](#section-7.2.4){.section-number .selfRef} [Fast Retransmit on Gap Reports](#name-fast-retransmit-on-gap-repo){.section-name .selfRef} {#name-fast-retransmit-on-gap-repo}

In the absence of data loss, an endpoint performs delayed
acknowledgement. However, whenever an endpoint notices a hole in the
arriving TSN sequence, it [SHOULD]{.bcp14} start sending a SACK chunk
back every time a packet arrives carrying data until the hole is
filled.[¶](#section-7.2.4-1){.pilcrow}

Whenever an endpoint receives a SACK chunk that indicates that some TSNs
are missing, it [SHOULD]{.bcp14} wait for two further miss indications
(via subsequent SACK chunks for a total of three missing reports) on the
same TSNs before taking action with regard to Fast
Retransmit.[¶](#section-7.2.4-2){.pilcrow}

Miss indications [SHOULD]{.bcp14} follow the Highest TSN Newly
Acknowledged (HTNA) algorithm. For each incoming SACK chunk, miss
indications are incremented only for missing TSNs prior to the HTNA in
the SACK chunk. A newly acknowledged DATA chunk is one not previously
acknowledged in a SACK chunk. If an endpoint is in Fast Recovery and a
SACK chunks arrives that advances the Cumulative TSN Ack Point, the miss
indications are incremented for all TSNs reported missing in the SACK
chunk.[¶](#section-7.2.4-3){.pilcrow}

When the third consecutive miss indication is received for one or more
TSNs, the data sender does the following:[¶](#section-7.2.4-4){.pilcrow}

[]{.break}

1\)

:   Mark the DATA chunk(s) with three miss indications for
    retransmission.[¶](#section-7.2.4-5.1.1){.pilcrow}

:   

2\)

:   If not in Fast Recovery, adjust the ssthresh and cwnd of the
    destination address(es) to which the missing DATA chunks were last
    sent, according to the formula described in [Section
    7.2.3](#sec_congestion_control_sub){.xref}.[¶](#section-7.2.4-5.2.1){.pilcrow}

:   

3\)

:   If not in Fast Recovery, determine how many of the earliest (i.e.,
    lowest TSN) DATA chunks marked for retransmission will fit into a
    single packet, subject to constraint of the PMTU of the destination
    transport address to which the packet is being sent. Call this value
    K. Retransmit those K DATA chunks in a single packet. When a Fast
    Retransmit is being performed, the sender [SHOULD]{.bcp14} ignore
    the value of cwnd and [SHOULD NOT]{.bcp14} delay retransmission for
    this single packet.[¶](#section-7.2.4-5.3.1){.pilcrow}

:   

4\)

:   Restart the T3-rtx timer only if the last SACK chunk acknowledged
    the lowest outstanding TSN number sent to that address or the
    endpoint is retransmitting the first outstanding DATA chunk sent to
    that address.[¶](#section-7.2.4-5.4.1){.pilcrow}

:   

5\)

:   Mark the DATA chunk(s) as being fast retransmitted and thus
    ineligible for a subsequent Fast Retransmit. Those TSNs marked for
    retransmission due to the Fast-Retransmit algorithm that did not fit
    in the sent datagram carrying K other TSNs are also marked as
    ineligible for a subsequent Fast Retransmit. However, as they are
    marked for retransmission, they will be retransmitted later on as
    soon as cwnd allows.[¶](#section-7.2.4-5.5.1){.pilcrow}

:   

6\)

:   If not in Fast Recovery, enter Fast Recovery and mark the highest
    outstanding TSN as the Fast Recovery exit point. When a SACK chunk
    acknowledges all TSNs up to and including this exit point, Fast
    Recovery is exited. While in Fast Recovery, the ssthresh and cwnd
    [SHOULD NOT]{.bcp14} change for any destinations due to a subsequent
    Fast Recovery event (i.e., one [SHOULD NOT]{.bcp14} reduce the cwnd
    further due to a subsequent Fast
    Retransmit).[¶](#section-7.2.4-5.6.1){.pilcrow}

:   

Note: Before the above adjustments, if the received SACK chunk also
acknowledges new DATA chunks and advances the Cumulative TSN Ack Point,
the cwnd adjustment rules defined in Sections
[7.2.1](#sec_slow_start){.xref} and
[7.2.2](#sec_congestion_avoidance){.xref} [MUST]{.bcp14} be applied
first.[¶](#section-7.2.4-6){.pilcrow}
:::
:::

::: {#section-7.2.5 .section}
#### [7.2.5.](#section-7.2.5){.section-number .selfRef} [Reinitialization](#name-reinitialization){.section-name .selfRef} {#name-reinitialization}

During the lifetime of an SCTP association, events can happen that
result in using the network under unknown new conditions. When detected
by an SCTP implementation, the congestion control [MUST]{.bcp14} be
reinitialized.[¶](#section-7.2.5-1){.pilcrow}

::: {#section-7.2.5.1 .section}
##### [7.2.5.1.](#section-7.2.5.1){.section-number .selfRef} [Change of Differentiated Services Code Points](#name-change-of-differentiated-se){.section-name .selfRef} {#name-change-of-differentiated-se}

SCTP implementations [MAY]{.bcp14} allow an application to configure the
Differentiated Services Code Point (DSCP) used for sending packets. If a
DSCP change might result in outgoing packets being queued in different
queues, the congestion control parameters for all affected destination
addresses [MUST]{.bcp14} be reset to their initial
values.[¶](#section-7.2.5.1-1){.pilcrow}
:::

::: {#section-7.2.5.2 .section}
##### [7.2.5.2.](#section-7.2.5.2){.section-number .selfRef} [Change of Routes](#name-change-of-routes){.section-name .selfRef} {#name-change-of-routes}

SCTP implementations [MAY]{.bcp14} be aware of routing changes affecting
packets sent to a destination address. In particular, this includes the
selection of a different source address used for sending packets to a
destination address. If such a routing change happens, the congestion
control parameters for the affected destination addresses [MUST]{.bcp14}
be reset to their initial values.[¶](#section-7.2.5.2-1){.pilcrow}
:::
:::
:::
:::

::: {#sec_path_mtu_discovery}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [PMTU Discovery](#name-pmtu-discovery){.section-name .selfRef} {#name-pmtu-discovery}

\[[RFC8899](#RFC8899){.xref}\], \[[RFC8201](#RFC8201){.xref}\], and
\[[RFC1191](#RFC1191){.xref}\] specify \"Packetization Layer Path MTU
Discovery\", whereby an endpoint maintains an estimate of PMTU along a
given Internet path and refrains from sending packets along that path
that exceed the PMTU, other than occasional attempts to probe for a
change in the PMTU. \[[RFC8899](#RFC8899){.xref}\] is thorough in its
discussion of the PMTU discovery mechanism and strategies for
determining the current end-to-end PMTU setting as well as detecting
changes in this value.[¶](#section-7.3-1){.pilcrow}

An endpoint [SHOULD]{.bcp14} apply these techniques and [SHOULD]{.bcp14}
do so on a per-destination-address basis.[¶](#section-7.3-2){.pilcrow}

There are two important SCTP-specific points regarding PMTU
discovery:[¶](#section-7.3-3){.pilcrow}

[]{.break}

1\)

:   SCTP associations can span multiple addresses. An endpoint
    [MUST]{.bcp14} maintain separate PMTU estimates for each destination
    address of its peer.[¶](#section-7.3-4.1.1){.pilcrow}

:   

2\)

:   The sender [SHOULD]{.bcp14} track an AMDCS that will be the smallest
    PMDCS discovered for all of the peer\'s destination addresses. When
    fragmenting messages into multiple parts, this AMDCS
    [SHOULD]{.bcp14} be used to calculate the size of each DATA chunk.
    This will allow retransmissions to be seamlessly sent to an
    alternate address without encountering IP
    fragmentation.[¶](#section-7.3-4.2.1){.pilcrow}

:   
:::
:::
:::
:::

::: {#sec_fault_management}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Fault Management](#name-fault-management){.section-name .selfRef} {#name-fault-management}

::: {#sec_endpoint_failure_detection}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Endpoint Failure Detection](#name-endpoint-failure-detection){.section-name .selfRef} {#name-endpoint-failure-detection}

An endpoint [SHOULD]{.bcp14} keep a counter on the total number of
consecutive retransmissions to its peer (this includes data
retransmissions to all the destination transport addresses of the peer
if it is multi-homed), including the number of unacknowledged HEARTBEAT
chunks observed on the path that is currently used for data transfer.
Unacknowledged HEARTBEAT chunks observed on paths different from the
path currently used for data transfer [SHOULD NOT]{.bcp14} increment the
association error counter, as this could lead to association closure
even if the path that is currently used for data transfer is available
(but idle). If the value of this counter exceeds the limit indicated in
the protocol parameter \'Association.Max.Retrans\', the endpoint
[SHOULD]{.bcp14} consider the peer endpoint unreachable and
[SHALL]{.bcp14} stop transmitting any more data to it (and thus the
association enters the CLOSED state). In addition, the endpoint
[SHOULD]{.bcp14} report the failure to the upper layer and optionally
report back all outstanding user data remaining in its outbound queue.
The association is automatically closed when the peer endpoint becomes
unreachable.[¶](#section-8.1-1){.pilcrow}

The counter used for endpoint failure detection [MUST]{.bcp14} be reset
each time a DATA chunk sent to that peer endpoint is acknowledged (by
the reception of a SACK chunk). When a HEARTBEAT ACK chunk is received
from the peer endpoint, the counter [SHOULD]{.bcp14} also be reset. The
receiver of the HEARTBEAT ACK chunk [MAY]{.bcp14} choose not to clear
the counter if there is outstanding data on the association. This allows
for handling the possible difference in reachability based on DATA
chunks and HEARTBEAT chunks.[¶](#section-8.1-2){.pilcrow}
:::
:::

::: {#sec_path_failure_detection}
::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Path Failure Detection](#name-path-failure-detection){.section-name .selfRef} {#name-path-failure-detection}

When its peer endpoint is multi-homed, an endpoint [SHOULD]{.bcp14} keep
an error counter for each of the destination transport addresses of the
peer endpoint.[¶](#section-8.2-1){.pilcrow}

Each time the T3-rtx timer expires on any address, or when a HEARTBEAT
chunk sent to an idle address is not acknowledged within an RTO, the
error counter of that destination address will be incremented. When the
value in the error counter exceeds the protocol parameter
\'Path.Max.Retrans\' of that destination address, the endpoint
[SHOULD]{.bcp14} mark the destination transport address as inactive, and
a notification [SHOULD]{.bcp14} be sent to the upper
layer.[¶](#section-8.2-2){.pilcrow}

When an outstanding TSN is acknowledged or a HEARTBEAT chunk sent to
that address is acknowledged with a HEARTBEAT ACK chunk, the endpoint
[SHOULD]{.bcp14} clear the error counter of the destination transport
address to which the DATA chunk was last sent (or HEARTBEAT chunk was
sent) and [SHOULD]{.bcp14} also report to the upper layer when an
inactive destination address is marked as active. When the peer endpoint
is multi-homed and the last chunk sent to it was a retransmission to an
alternate address, there exists an ambiguity as to whether or not the
acknowledgement could be credited to the address of the last chunk sent.
However, this ambiguity does not seem to have significant consequences
for SCTP behavior. If this ambiguity is undesirable, the transmitter
[MAY]{.bcp14} choose not to clear the error counter if the last chunk
sent was a retransmission.[¶](#section-8.2-3){.pilcrow}

Note: When configuring the SCTP endpoint, the user ought to avoid having
the value of \'Association.Max.Retrans\' larger than the summation of
the \'Path.Max.Retrans\' of all the destination addresses for the remote
endpoint. Otherwise, all the destination addresses might become inactive
while the endpoint still considers the peer endpoint reachable. When
this condition occurs, how SCTP chooses to function is implementation
specific.[¶](#section-8.2-4){.pilcrow}

When the primary path is marked inactive (due to excessive
retransmissions, for instance), the sender [MAY]{.bcp14} automatically
transmit new packets to an alternate destination address if one exists
and is active. If more than one alternate address is active when the
primary path is marked inactive, only ONE transport address
[SHOULD]{.bcp14} be chosen and used as the new destination transport
address.[¶](#section-8.2-5){.pilcrow}
:::
:::

::: {#sec_path_heartbeat}
::: {#section-8.3 .section}
### [8.3.](#section-8.3){.section-number .selfRef} [Path Heartbeat](#name-path-heartbeat){.section-name .selfRef} {#name-path-heartbeat}

By default, an SCTP endpoint [SHOULD]{.bcp14} monitor the reachability
of the idle destination transport address(es) of its peer by sending a
HEARTBEAT chunk periodically to the destination transport address(es).
The sending of HEARTBEAT chunks [MAY]{.bcp14} begin upon reaching the
ESTABLISHED state and is discontinued after sending either a SHUTDOWN
chunk or SHUTDOWN ACK chunk. A receiver of a HEARTBEAT chunk
[MUST]{.bcp14} respond to a HEARTBEAT chunk with a HEARTBEAT ACK chunk
after entering the COOKIE-ECHOED state (sender of the INIT chunk) or the
ESTABLISHED state (receiver of the INIT chunk), up until reaching the
SHUTDOWN-SENT state (sender of the SHUTDOWN chunk) or the
SHUTDOWN-ACK-SENT state (receiver of the SHUTDOWN
chunk).[¶](#section-8.3-1){.pilcrow}

A destination transport address is considered \"idle\" if no new chunk
that can be used for updating path RTT (usually including first
transmission DATA, INIT, COOKIE ECHO, or HEARTBEAT chunks, etc.) and no
HEARTBEAT chunk has been sent to it within the current heartbeat period
of that address. This applies to both active and inactive destination
addresses.[¶](#section-8.3-2){.pilcrow}

The upper layer can optionally initiate the following
functions:[¶](#section-8.3-3){.pilcrow}

[]{.break}

A\)

:   Disable heartbeat on a specific destination transport address of a
    given association,[¶](#section-8.3-4.1.1){.pilcrow}

:   

B\)

:   Change the \'HB.interval\',[¶](#section-8.3-4.2.1){.pilcrow}

:   

C\)

:   Re-enable heartbeat on a specific destination transport address of a
    given association, and[¶](#section-8.3-4.3.1){.pilcrow}

:   

D\)

:   Request the sending of an on-demand HEARTBEAT chunk on a specific
    destination transport address of a given
    association.[¶](#section-8.3-4.4.1){.pilcrow}

:   

The endpoint [SHOULD]{.bcp14} increment the respective error counter of
the destination transport address each time a HEARTBEAT chunk is sent to
that address and not acknowledged within one
RTO.[¶](#section-8.3-5){.pilcrow}

When the value of this counter exceeds the protocol parameter
\'Path.Max.Retrans\', the endpoint [SHOULD]{.bcp14} mark the
corresponding destination address as inactive if it is not so marked and
[SHOULD]{.bcp14} also report to the upper layer the change in
reachability of this destination address. After this, the endpoint
[SHOULD]{.bcp14} continue sending HEARTBEAT chunks on this destination
address but [SHOULD]{.bcp14} stop increasing the
counter.[¶](#section-8.3-6){.pilcrow}

The sender of the HEARTBEAT chunk [SHOULD]{.bcp14} include in the
Heartbeat Information field of the chunk the current time when the
packet is sent and the destination address to which the packet is
sent.[¶](#section-8.3-7){.pilcrow}

Implementation Note: An alternative implementation of the heartbeat
mechanism that can be used is to increment the error counter variable
every time a HEARTBEAT chunk is sent to a destination. Whenever a
HEARTBEAT ACK chunk arrives, the sender [SHOULD]{.bcp14} clear the error
counter of the destination that the HEARTBEAT chunk was sent to. This,
in effect, would clear the previously stroked error (and any other error
counts as well).[¶](#section-8.3-8){.pilcrow}

The receiver of the HEARTBEAT chunk [SHOULD]{.bcp14} immediately respond
with a HEARTBEAT ACK chunk that contains the Heartbeat Information TLV,
together with any other received TLVs, copied unchanged from the
received HEARTBEAT chunk.[¶](#section-8.3-9){.pilcrow}

Upon the receipt of the HEARTBEAT ACK chunk, the sender of the HEARTBEAT
chunk [SHOULD]{.bcp14} clear the error counter of the destination
transport address to which the HEARTBEAT chunk was sent and mark the
destination transport address as active if it is not so marked. The
endpoint [SHOULD]{.bcp14} report to the upper layer when an inactive
destination address is marked as active due to the reception of the
latest HEARTBEAT ACK chunk. The receiver of the HEARTBEAT ACK chunk
[SHOULD]{.bcp14} also clear the association overall error count (as
defined in [Section
8.1](#sec_endpoint_failure_detection){.xref}).[¶](#section-8.3-10){.pilcrow}

The receiver of the HEARTBEAT ACK chunk [SHOULD]{.bcp14} also perform an
RTT measurement for that destination transport address using the time
value carried in the HEARTBEAT ACK chunk.[¶](#section-8.3-11){.pilcrow}

On an idle destination address that is allowed to heartbeat, it is
[RECOMMENDED]{.bcp14} that a HEARTBEAT chunk is sent once per RTO of
that destination address plus the protocol parameter \'HB.interval\',
with jittering of +/- 50% of the RTO value and exponential backoff of
the RTO if the previous HEARTBEAT chunk is
unanswered.[¶](#section-8.3-12){.pilcrow}

A primitive is provided for the SCTP user to change the \'HB.interval\'
and turn on or off the heartbeat on a given destination address. The
\'HB.interval\' set by the SCTP user is added to the RTO of that
destination (including any exponential backoff). Only one heartbeat
[SHOULD]{.bcp14} be sent each time the heartbeat timer expires (if
multiple destinations are idle). It is an implementation decision on how
to choose which of the candidate idle destinations to heartbeat to (if
more than one destination is idle).[¶](#section-8.3-13){.pilcrow}

When tuning the \'HB.interval\', there is a side effect that
[SHOULD]{.bcp14} be taken into account. When this value is increased,
i.e., the time between the sending of HEARTBEAT chunks is longer, the
detection of lost ABORT chunks takes longer as well. If a peer endpoint
sends an ABORT chunk for any reason and the ABORT chunk is lost, the
local endpoint will only discover the lost ABORT chunk by sending a DATA
chunk or HEARTBEAT chunk (thus causing the peer to send another ABORT
chunk). This is to be considered when tuning the heartbeat timer. If the
sending of HEARTBEAT chunks is disabled, only sending DATA chunks to the
association will discover a lost ABORT chunk from the
peer.[¶](#section-8.3-14){.pilcrow}
:::
:::

::: {#sec_handle_out_of_the_blue_packets}
::: {#section-8.4 .section}
### [8.4.](#section-8.4){.section-number .selfRef} [Handle \"Out of the Blue\" Packets](#name-handle-out-of-the-blue-pack){.section-name .selfRef} {#name-handle-out-of-the-blue-pack}

An SCTP packet is called an \"Out of the Blue\" (OOTB) packet if it is
correctly formed (i.e., passed the receiver\'s CRC32c check; see
[Section 6.8](#sec_crc32c_checksum_calculation){.xref}), but the
receiver is not able to identify the association to which this packet
belongs.[¶](#section-8.4-1){.pilcrow}

The receiver of an OOTB packet does the
following:[¶](#section-8.4-2){.pilcrow}

[]{.break}

1\)

:   If the OOTB packet is to or from a non-unicast address, a receiver
    [SHOULD]{.bcp14} silently discard the packet.
    Otherwise,[¶](#section-8.4-3.1.1){.pilcrow}

:   

2\)

:   If the OOTB packet contains an ABORT chunk, the receiver
    [MUST]{.bcp14} silently discard the OOTB packet and take no further
    action. Otherwise,[¶](#section-8.4-3.2.1){.pilcrow}

:   

3\)

:   If the packet contains an INIT chunk with a Verification Tag set to
    0, it [SHOULD]{.bcp14} be processed as described in [Section
    5.1](#sec_normal_establishment){.xref}. If, for whatever reason, the
    INIT chunk cannot be processed normally and an ABORT chunk has to be
    sent in response, the Verification Tag of the packet containing the
    ABORT chunk [MUST]{.bcp14} be the Initiate Tag of the received INIT
    chunk, and the T bit of the ABORT chunk has to be set to 0,
    indicating that the Verification Tag is not reflected.
    Otherwise,[¶](#section-8.4-3.3.1){.pilcrow}

:   

4\)

:   If the packet contains a COOKIE ECHO chunk as the first chunk, it
    [MUST]{.bcp14} be processed as described in [Section
    5.1](#sec_normal_establishment){.xref}.
    Otherwise,[¶](#section-8.4-3.4.1){.pilcrow}

:   

5\)

:   If the packet contains a SHUTDOWN ACK chunk, the receiver
    [SHOULD]{.bcp14} respond to the sender of the OOTB packet with a
    SHUTDOWN COMPLETE chunk. When sending the SHUTDOWN COMPLETE chunk,
    the receiver of the OOTB packet [MUST]{.bcp14} fill in the
    Verification Tag field of the outbound packet with the Verification
    Tag received in the SHUTDOWN ACK chunk and set the T bit in the
    Chunk Flags to indicate that the Verification Tag is reflected.
    Otherwise,[¶](#section-8.4-3.5.1){.pilcrow}

:   

6\)

:   If the packet contains a SHUTDOWN COMPLETE chunk, the receiver
    [SHOULD]{.bcp14} silently discard the packet and take no further
    action. Otherwise,[¶](#section-8.4-3.6.1){.pilcrow}

:   

7\)

:   If the packet contains an ERROR chunk with the \"Stale Cookie\"
    error cause or a COOKIE ACK chunk, the SCTP packet [SHOULD]{.bcp14}
    be silently discarded. Otherwise,[¶](#section-8.4-3.7.1){.pilcrow}

:   

8\)

:   The receiver [SHOULD]{.bcp14} respond to the sender of the OOTB
    packet with an ABORT chunk. When sending the ABORT chunk, the
    receiver of the OOTB packet [MUST]{.bcp14} fill in the Verification
    Tag field of the outbound packet with the value found in the
    Verification Tag field of the OOTB packet and set the T bit in the
    Chunk Flags to indicate that the Verification Tag is reflected.
    After sending this ABORT chunk, the receiver of the OOTB packet
    [MUST]{.bcp14} discard the OOTB packet and [MUST NOT]{.bcp14} take
    any further action.[¶](#section-8.4-3.8.1){.pilcrow}

:   
:::
:::

::: {#sec_verification_tag}
::: {#section-8.5 .section}
### [8.5.](#section-8.5){.section-number .selfRef} [Verification Tag](#name-verification-tag){.section-name .selfRef} {#name-verification-tag}

The Verification Tag rules defined in this section apply when sending or
receiving SCTP packets that do not contain an INIT, SHUTDOWN COMPLETE,
COOKIE ECHO (see [Section 5.1](#sec_normal_establishment){.xref}),
ABORT, or SHUTDOWN ACK chunk. The rules for sending and receiving SCTP
packets containing one of these chunk types are discussed separately in
[Section
8.5.1](#sec_exceptions_in_verification_tag_rules){.xref}.[¶](#section-8.5-1){.pilcrow}

When sending an SCTP packet, the endpoint [MUST]{.bcp14} fill in the
Verification Tag field of the outbound packet with the tag value in the
Initiate Tag parameter of the INIT or INIT ACK chunk received from its
peer.[¶](#section-8.5-2){.pilcrow}

When receiving an SCTP packet, the endpoint [MUST]{.bcp14} ensure that
the value in the Verification Tag field of the received SCTP packet
matches its own tag. If the received Verification Tag value does not
match the receiver\'s own tag value, the receiver [MUST]{.bcp14}
silently discard the packet and [MUST NOT]{.bcp14} process it any
further, except for those cases listed in [Section
8.5.1](#sec_exceptions_in_verification_tag_rules){.xref}
below.[¶](#section-8.5-3){.pilcrow}

::: {#sec_exceptions_in_verification_tag_rules}
::: {#section-8.5.1 .section}
#### [8.5.1.](#section-8.5.1){.section-number .selfRef} [Exceptions in Verification Tag Rules](#name-exceptions-in-verification-){.section-name .selfRef} {#name-exceptions-in-verification-}

[]{.break}

A\) Rules for packets carrying an INIT chunk:

:   -   [The sender [MUST]{.bcp14} set the Verification Tag of the
        packet to
        0.[¶](#section-8.5.1-1.2.1.1){.pilcrow}]{#section-8.5.1-1.2.1.1}
    -   [When an endpoint receives an SCTP packet with the Verification
        Tag set to 0, it [SHOULD]{.bcp14} verify that the packet
        contains only an INIT chunk. Otherwise, the receiver
        [MUST]{.bcp14} silently discard the
        packet.[¶](#section-8.5.1-1.2.1.2){.pilcrow}]{#section-8.5.1-1.2.1.2}

:   

B\) Rules for packets carrying an ABORT chunk:

:   -   [The endpoint [MUST]{.bcp14} always fill in the Verification Tag
        field of the outbound packet with the destination endpoint\'s
        tag value if it is
        known.[¶](#section-8.5.1-1.4.1.1){.pilcrow}]{#section-8.5.1-1.4.1.1}
    -   [If the ABORT chunk is sent in response to an OOTB packet, the
        endpoint [MUST]{.bcp14} follow the procedure described in
        [Section
        8.4](#sec_handle_out_of_the_blue_packets){.xref}.[¶](#section-8.5.1-1.4.1.2){.pilcrow}]{#section-8.5.1-1.4.1.2}
    -   [The receiver of an ABORT chunk [MUST]{.bcp14} accept the packet
        if the Verification Tag field of the packet matches its own tag
        and the T bit is not set OR if it is set to its Peer\'s Tag and
        the T bit is set in the Chunk Flags. Otherwise, the receiver
        [MUST]{.bcp14} silently discard the packet and take no further
        action.[¶](#section-8.5.1-1.4.1.3){.pilcrow}]{#section-8.5.1-1.4.1.3}

:   

C\) Rules for packets carrying a SHUTDOWN COMPLETE chunk:

:   -   [When sending a SHUTDOWN COMPLETE chunk, if the receiver of the
        SHUTDOWN ACK chunk has a TCB, then the destination endpoint\'s
        tag [MUST]{.bcp14} be used and the T bit [MUST NOT]{.bcp14} be
        set. Only where no TCB exists [SHOULD]{.bcp14} the sender use
        the Verification Tag from the SHUTDOWN ACK chunk and
        [MUST]{.bcp14} set the T
        bit.[¶](#section-8.5.1-1.6.1.1){.pilcrow}]{#section-8.5.1-1.6.1.1}
    -   [The receiver of a SHUTDOWN COMPLETE chunk accepts the packet if
        the Verification Tag field of the packet matches its own tag and
        the T bit is not set OR if it is set to its Peer\'s Tag and the
        T bit is set in the Chunk Flags. Otherwise, the receiver
        [MUST]{.bcp14} silently discard the packet and take no further
        action. An endpoint [MUST]{.bcp14} ignore the SHUTDOWN COMPLETE
        chunk if it is not in the SHUTDOWN-ACK-SENT
        state.[¶](#section-8.5.1-1.6.1.2){.pilcrow}]{#section-8.5.1-1.6.1.2}

:   

D\) Rules for packets carrying a COOKIE ECHO chunk:

:   -   [When sending a COOKIE ECHO chunk, the endpoint [MUST]{.bcp14}
        use the value of the Initiate Tag received in the INIT ACK
        chunk.[¶](#section-8.5.1-1.8.1.1){.pilcrow}]{#section-8.5.1-1.8.1.1}
    -   [The receiver of a COOKIE ECHO chunk follows the procedures in
        [Section
        5](#sec_assoc_initialization){.xref}.[¶](#section-8.5.1-1.8.1.2){.pilcrow}]{#section-8.5.1-1.8.1.2}

:   

E\) Rules for packets carrying a SHUTDOWN ACK chunk:

:   -   [If the receiver is in COOKIE-ECHOED or COOKIE-WAIT state, the
        procedures in [Section
        8.4](#sec_handle_out_of_the_blue_packets){.xref}
        [SHOULD]{.bcp14} be followed; in other words, it is treated as
        an OOTB
        packet.[¶](#section-8.5.1-1.10.1.1){.pilcrow}]{#section-8.5.1-1.10.1.1}

:   
:::
:::
:::
:::
:::
:::

::: {#sec_assoc_termination}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Termination of Association](#name-termination-of-association){.section-name .selfRef} {#name-termination-of-association}

An endpoint [SHOULD]{.bcp14} terminate its association when it exits
from service. An association can be terminated by either abort or
shutdown. An abort of an association is abortive by definition in that
any data pending on either end of the association is discarded and not
delivered to the peer. A shutdown of an association is considered a
graceful close where all data in queue by either endpoint is delivered
to the respective peers. However, in the case of a shutdown, SCTP does
not support a half-open state (like TCP), wherein one side might
continue sending data while the other end is closed. When either
endpoint performs a shutdown, the association on each peer will stop
accepting new data from its user and only deliver data in queue at the
time of sending or receiving the SHUTDOWN
chunk.[¶](#section-9-1){.pilcrow}

::: {#sec_abort_of_an_association}
::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Abort of an Association](#name-abort-of-an-association){.section-name .selfRef} {#name-abort-of-an-association}

When an endpoint decides to abort an existing association, it
[MUST]{.bcp14} send an ABORT chunk to its peer endpoint. The sender
[MUST]{.bcp14} fill in the peer\'s Verification Tag in the outbound
packet and [MUST NOT]{.bcp14} bundle any DATA chunk with the ABORT
chunk. If the association is aborted on request of the upper layer, a
\"User-Initiated Abort\" error cause (see [Section
3.3.10.12](#sec_user_initiated_abort_cause){.xref}) [SHOULD]{.bcp14} be
present in the ABORT chunk.[¶](#section-9.1-1){.pilcrow}

An endpoint [MUST NOT]{.bcp14} respond to any received packet that
contains an ABORT chunk (also see [Section
8.4](#sec_handle_out_of_the_blue_packets){.xref}).[¶](#section-9.1-2){.pilcrow}

An endpoint receiving an ABORT chunk [MUST]{.bcp14} apply the special
Verification Tag check rules described in [Section
8.5.1](#sec_exceptions_in_verification_tag_rules){.xref}.[¶](#section-9.1-3){.pilcrow}

After checking the Verification Tag, the receiving endpoint
[MUST]{.bcp14} remove the association from its record and
[SHOULD]{.bcp14} report the termination to its upper layer. If a
\"User-Initiated Abort\" error cause is present in the ABORT chunk, the
Upper Layer Abort Reason [SHOULD]{.bcp14} be made available to the upper
layer.[¶](#section-9.1-4){.pilcrow}
:::
:::

::: {#sec_shutdown_of_an_association}
::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Shutdown of an Association](#name-shutdown-of-an-association){.section-name .selfRef} {#name-shutdown-of-an-association}

Using the SHUTDOWN primitive (see [Section
11.1](#sec_ulp_to_sctp){.xref}), the upper layer of an endpoint in an
association can gracefully close the association. This will allow all
outstanding DATA chunks from the peer of the shutdown initiator to be
delivered before the association
terminates.[¶](#section-9.2-1){.pilcrow}

Upon receipt of the SHUTDOWN primitive from its upper layer, the
endpoint enters the SHUTDOWN-PENDING state and remains there until all
outstanding data has been acknowledged by its peer. The endpoint accepts
no new data from its upper layer but retransmits data to the peer
endpoint if necessary to fill gaps.[¶](#section-9.2-2){.pilcrow}

Once all its outstanding data has been acknowledged, the endpoint sends
a SHUTDOWN chunk to its peer, including in the Cumulative TSN Ack field
the last sequential TSN it has received from the peer. It
[SHOULD]{.bcp14} then start the T2-shutdown timer and enter the
SHUTDOWN-SENT state. If the timer expires, the endpoint [MUST]{.bcp14}
resend the SHUTDOWN chunk with the updated last sequential TSN received
from its peer.[¶](#section-9.2-3){.pilcrow}

The rules in [Section
6.3](#sec_management_of_retransission_timer){.xref} [MUST]{.bcp14} be
followed to determine the proper timer value for T2-shutdown. To
indicate any gaps in TSN, the endpoint [MAY]{.bcp14} also bundle a SACK
chunk with the SHUTDOWN chunk in the same SCTP
packet.[¶](#section-9.2-4){.pilcrow}

An endpoint [SHOULD]{.bcp14} limit the number of retransmissions of the
SHUTDOWN chunk to the protocol parameter \'Association.Max.Retrans\'. If
this threshold is exceeded, the endpoint [SHOULD]{.bcp14} destroy the
TCB and [SHOULD]{.bcp14} report the peer endpoint unreachable to the
upper layer (and thus the association enters the CLOSED state). The
reception of any packet from its peer (i.e., as the peer sends all of
its queued DATA chunks) [SHOULD]{.bcp14} clear the endpoint\'s
retransmission count and restart the T2-shutdown timer, giving its peer
ample opportunity to transmit all of its queued DATA chunks that have
not yet been sent.[¶](#section-9.2-5){.pilcrow}

Upon reception of the SHUTDOWN chunk, the peer endpoint does the
following:[¶](#section-9.2-6){.pilcrow}

-   ::: {#section-9.2-7.1}
    enter the SHUTDOWN-RECEIVED state,[¶](#section-9.2-7.1.1){.pilcrow}
    :::

-   ::: {#section-9.2-7.2}
    stop accepting new data from its SCTP user,
    and[¶](#section-9.2-7.2.1){.pilcrow}
    :::

-   ::: {#section-9.2-7.3}
    verify, by checking the Cumulative TSN Ack field of the chunk, that
    all its outstanding DATA chunks have been received by the SHUTDOWN
    chunk sender.[¶](#section-9.2-7.3.1){.pilcrow}
    :::

Once an endpoint has reached the SHUTDOWN-RECEIVED state, it
[MUST]{.bcp14} ignore ULP shutdown requests but [MUST]{.bcp14} continue
responding to SHUTDOWN chunks from its
peer.[¶](#section-9.2-8){.pilcrow}

If there are still outstanding DATA chunks left, the SHUTDOWN chunk
receiver [MUST]{.bcp14} continue to follow normal data transmission
procedures defined in [Section 6](#sec_user_data_transfer){.xref}, until
all outstanding DATA chunks are acknowledged; however, the SHUTDOWN
chunk receiver [MUST NOT]{.bcp14} accept new data from its SCTP
user.[¶](#section-9.2-9){.pilcrow}

While in the SHUTDOWN-SENT state, the SHUTDOWN chunk sender
[MUST]{.bcp14} immediately respond to each received packet containing
one or more DATA chunks with a SHUTDOWN chunk and restart the
T2-shutdown timer. If a SHUTDOWN chunk by itself cannot acknowledge all
of the received DATA chunks (i.e., there are TSNs that can be
acknowledged that are larger than the cumulative TSN and thus gaps exist
in the TSN sequence) or if duplicate TSNs have been received, then a
SACK chunk [MUST]{.bcp14} also be sent.[¶](#section-9.2-10){.pilcrow}

The sender of the SHUTDOWN chunk [MAY]{.bcp14} also start an overall
guard timer T5-shutdown-guard to bound the overall time for the shutdown
sequence. At the expiration of this timer, the sender [SHOULD]{.bcp14}
abort the association by sending an ABORT chunk. If the
T5-shutdown-guard timer is used, it [SHOULD]{.bcp14} be set to the
[RECOMMENDED]{.bcp14} value of 5 times
\'RTO.Max\'.[¶](#section-9.2-11){.pilcrow}

If the receiver of the SHUTDOWN chunk has no more outstanding DATA
chunks, the SHUTDOWN chunk receiver [MUST]{.bcp14} send a SHUTDOWN ACK
chunk and start a T2-shutdown timer of its own, entering the
SHUTDOWN-ACK-SENT state. If the timer expires, the endpoint
[MUST]{.bcp14} resend the SHUTDOWN ACK
chunk.[¶](#section-9.2-12){.pilcrow}

The sender of the SHUTDOWN ACK chunk [SHOULD]{.bcp14} limit the number
of retransmissions of the SHUTDOWN ACK chunk to the protocol parameter
\'Association.Max.Retrans\'. If this threshold is exceeded, the endpoint
[SHOULD]{.bcp14} destroy the TCB and [SHOULD]{.bcp14} report the peer
endpoint unreachable to the upper layer (and thus the association enters
the CLOSED state).[¶](#section-9.2-13){.pilcrow}

Upon the receipt of the SHUTDOWN ACK chunk, the sender of the SHUTDOWN
chunk [MUST]{.bcp14} stop the T2-shutdown timer, send a SHUTDOWN
COMPLETE chunk to its peer, and remove all record of the
association.[¶](#section-9.2-14){.pilcrow}

Upon reception of the SHUTDOWN COMPLETE chunk, the endpoint verifies
that it is in the SHUTDOWN-ACK-SENT state; if it is not, the chunk
[SHOULD]{.bcp14} be discarded. If the endpoint is in the
SHUTDOWN-ACK-SENT state, the endpoint [SHOULD]{.bcp14} stop the
T2-shutdown timer and remove all knowledge of the association (and thus
the association enters the CLOSED state).[¶](#section-9.2-15){.pilcrow}

An endpoint [SHOULD]{.bcp14} ensure that all its outstanding DATA chunks
have been acknowledged before initiating the shutdown
procedure.[¶](#section-9.2-16){.pilcrow}

An endpoint [SHOULD]{.bcp14} reject any new data request from its upper
layer if it is in the SHUTDOWN-PENDING, SHUTDOWN-SENT,
SHUTDOWN-RECEIVED, or SHUTDOWN-ACK-SENT
state.[¶](#section-9.2-17){.pilcrow}

If an endpoint is in the SHUTDOWN-ACK-SENT state and receives an INIT
chunk (e.g., if the SHUTDOWN COMPLETE chunk was lost) with source and
destination transport addresses (either in the IP addresses or in the
INIT chunk) that belong to this association, it [SHOULD]{.bcp14} discard
the INIT chunk and retransmit the SHUTDOWN ACK
chunk.[¶](#section-9.2-18){.pilcrow}

Note: Receipt of a packet containing an INIT chunk with the same source
and destination IP addresses as used in transport addresses assigned to
an endpoint but with a different port number indicates the
initialization of a separate association.[¶](#section-9.2-19){.pilcrow}

The sender of the INIT or COOKIE ECHO chunk [SHOULD]{.bcp14} respond to
the receipt of a SHUTDOWN ACK chunk with a stand-alone SHUTDOWN COMPLETE
chunk in an SCTP packet with the Verification Tag field of its common
header set to the same tag that was received in the packet containing
the SHUTDOWN ACK chunk. This is considered an OOTB packet as defined in
[Section 8.4](#sec_handle_out_of_the_blue_packets){.xref}. The sender of
the INIT chunk lets T1-init continue running and remains in the
COOKIE-WAIT or COOKIE-ECHOED state. Normal T1-init timer expiration will
cause the INIT or COOKIE chunk to be retransmitted and thus start a new
association.[¶](#section-9.2-20){.pilcrow}

If a SHUTDOWN chunk is received in the COOKIE-WAIT or COOKIE ECHOED
state, the SHUTDOWN chunk [SHOULD]{.bcp14} be silently
discarded.[¶](#section-9.2-21){.pilcrow}

If an endpoint is in the SHUTDOWN-SENT state and receives a SHUTDOWN
chunk from its peer, the endpoint [SHOULD]{.bcp14} respond immediately
with a SHUTDOWN ACK chunk to its peer and move into the
SHUTDOWN-ACK-SENT state, restarting its T2-shutdown
timer.[¶](#section-9.2-22){.pilcrow}

If an endpoint is in the SHUTDOWN-ACK-SENT state and receives a SHUTDOWN
ACK, it [MUST]{.bcp14} stop the T2-shutdown timer, send a SHUTDOWN
COMPLETE chunk to its peer, and remove all record of the
association.[¶](#section-9.2-23){.pilcrow}
:::
:::
:::
:::

::: {#sec_icmp}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [ICMP Handling](#name-icmp-handling){.section-name .selfRef} {#name-icmp-handling}

Whenever an ICMP message is received by an SCTP endpoint, the following
procedures [MUST]{.bcp14} be followed to ensure proper utilization of
the information being provided by layer 3.[¶](#section-10-1){.pilcrow}

[]{.break}

ICMP1)

:   An implementation [MAY]{.bcp14} ignore all ICMPv4 messages where the
    type field is not set to \"Destination
    Unreachable\".[¶](#section-10-2.1.1){.pilcrow}

:   

ICMP2)

:   An implementation [MAY]{.bcp14} ignore all ICMPv6 messages where the
    type field is not \"Destination Unreachable\", \"Parameter
    Problem\", or \"Packet Too Big\".[¶](#section-10-2.2.1){.pilcrow}

:   

ICMP3)

:   An implementation [SHOULD]{.bcp14} ignore any ICMP messages where
    the code indicates \"Port
    Unreachable\".[¶](#section-10-2.3.1){.pilcrow}

:   

ICMP4)

:   An implementation [MAY]{.bcp14} ignore all ICMPv6 messages of type
    \"Parameter Problem\" if the code is not \"Unrecognized Next Header
    Type Encountered\".[¶](#section-10-2.4.1){.pilcrow}

:   

ICMP5)

:   An implementation [MUST]{.bcp14} use the payload of the ICMP message
    (v4 or v6) to locate the association that sent the message to which
    ICMP is responding. If the association cannot be found, an
    implementation [SHOULD]{.bcp14} ignore the ICMP
    message.[¶](#section-10-2.5.1){.pilcrow}

:   

ICMP6)

:   An implementation [MUST]{.bcp14} validate that the Verification Tag
    contained in the ICMP message matches the Verification Tag of the
    peer. If the Verification Tag is not 0 and does not match, discard
    the ICMP message. If it is 0 and the ICMP message contains enough
    bytes to verify that the chunk type is an INIT chunk and that the
    Initiate Tag matches the tag of the peer, continue with ICMP7. If
    the ICMP message is too short or the chunk type or the Initiate Tag
    does not match, silently discard the
    packet.[¶](#section-10-2.6.1){.pilcrow}

:   

ICMP7)

:   If the ICMP message is either an ICMPv6 message of type \"Packet Too
    Big\" or an ICMPv4 message of type \"Destination Unreachable\" and
    code \"Fragmentation Needed\", an implementation [SHOULD]{.bcp14}
    process this information as defined for PMTU
    discovery.[¶](#section-10-2.7.1){.pilcrow}

:   

ICMP8)

:   If the ICMP code is \"Unrecognized Next Header Type Encountered\" or
    \"Protocol Unreachable\", an implementation [MUST]{.bcp14} treat
    this message as an abort with the T bit set if it does not contain
    an INIT chunk. If it does contain an INIT chunk and the association
    is in the COOKIE-WAIT state, handle the ICMP message like an ABORT
    chunk.[¶](#section-10-2.8.1){.pilcrow}

:   

ICMP9)

:   If the ICMP type is \"Destination Unreachable\", the implementation
    [MAY]{.bcp14} move the destination to the unreachable state or,
    alternatively, increment the path error counter. SCTP [MAY]{.bcp14}
    provide information to the upper layer indicating the reception of
    ICMP messages when reporting a network status
    change.[¶](#section-10-2.9.1){.pilcrow}

:   

These procedures differ from \[[RFC1122](#RFC1122){.xref}\] and from its
requirements for processing of port-unreachable messages and the
requirements that an implementation [MUST]{.bcp14} abort associations in
response to a protocol unreachable message. Port-unreachable messages
are not processed, since an implementation will send an ABORT chunk, not
a port-unreachable message. The stricter handling of the protocol
unreachable message is due to security concerns for hosts that do not
support SCTP.[¶](#section-10-3){.pilcrow}
:::
:::

::: {#sec_api}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [Interface with Upper Layer](#name-interface-with-upper-layer){.section-name .selfRef} {#name-interface-with-upper-layer}

The Upper Layer Protocols (ULPs) request services by passing primitives
to SCTP and receive notifications from SCTP for various
events.[¶](#section-11-1){.pilcrow}

The primitives and notifications described in this section can be used
as a guideline for implementing SCTP. The following functional
description of ULP interface primitives is shown for illustrative
purposes. Different SCTP implementations can have different ULP
interfaces. However, all SCTP implementations are expected to provide a
certain minimum set of services to guarantee that all SCTP
implementations can support the same protocol
hierarchy.[¶](#section-11-2){.pilcrow}

Please note that this section is informational
only.[¶](#section-11-3){.pilcrow}

\[[RFC6458](#RFC6458){.xref}\] and Section
[7](https://www.rfc-editor.org/rfc/rfc7053#section-7){.relref}
([\"Socket API
Considerations\"](https://www.rfc-editor.org/rfc/rfc7053#section-7){.relref})
of \[[RFC7053](#RFC7053){.xref}\] define an extension of the socket API
for SCTP as described in this document.[¶](#section-11-4){.pilcrow}

::: {#sec_ulp_to_sctp}
::: {#section-11.1 .section}
### [11.1.](#section-11.1){.section-number .selfRef} [ULP-to-SCTP](#name-ulp-to-sctp){.section-name .selfRef} {#name-ulp-to-sctp}

The following sections functionally characterize a ULP/SCTP interface.
The notation used is similar to most procedure or function calls in
high-level languages.[¶](#section-11.1-1){.pilcrow}

The ULP primitives described below specify the basic functions that SCTP
performs to support inter-process communication. Individual
implementations define their own exact format and provide combinations
or subsets of the basic functions in single
calls.[¶](#section-11.1-2){.pilcrow}

::: {#section-11.1.1 .section}
#### [11.1.1.](#section-11.1.1){.section-number .selfRef} [Initialize](#name-initialize){.section-name .selfRef} {#name-initialize}

::: {#section-11.1.1-1}
``` {.lang-pseudocode .sourcecode}
INITIALIZE ([local port],[local eligible address list])
-> local SCTP instance name
```

[¶](#section-11.1.1-1){.pilcrow}
:::

This primitive allows SCTP to initialize its internal data structures
and allocate necessary resources for setting up its operation
environment. Once SCTP is initialized, ULP can communicate directly with
other endpoints without re-invoking this
primitive.[¶](#section-11.1.1-2){.pilcrow}

SCTP will return a local SCTP instance name to the
ULP.[¶](#section-11.1.1-3){.pilcrow}

[]{.break}

Mandatory attributes:
:   None.[¶](#section-11.1.1-4.2){.pilcrow}
:   

Optional attributes:
:   []{.break}

    local port:
    :   SCTP port number, if ULP wants it to be
        specified.[¶](#section-11.1.1-4.4.1.2){.pilcrow}
    :   

    local eligible address list:
    :   an address list that the local SCTP endpoint binds. By default,
        if an address list is not included, all IP addresses assigned to
        the host are used by the local
        endpoint.[¶](#section-11.1.1-4.4.1.4){.pilcrow}
    :   
:   

Implementation Note: If this optional attribute is supported by an
implementation, it will be the responsibility of the implementation to
enforce that the IP source address field of any SCTP packets sent by
this endpoint contains one of the IP addresses indicated in the local
eligible address list.[¶](#section-11.1.1-5){.pilcrow}
:::

::: {#sec_associate}
::: {#section-11.1.2 .section}
#### [11.1.2.](#section-11.1.2){.section-number .selfRef} [Associate](#name-associate){.section-name .selfRef} {#name-associate}

::: {#section-11.1.2-1}
``` {.lang-pseudocode .sourcecode}
ASSOCIATE(local SCTP instance name,
initial destination transport addr list, outbound stream count)
-> association id [,destination transport addr list]
[,outbound stream count]
```

[¶](#section-11.1.2-1){.pilcrow}
:::

This primitive allows the upper layer to initiate an association to a
specific peer endpoint.[¶](#section-11.1.2-2){.pilcrow}

The peer endpoint is specified by one or more of the transport addresses
that defines the endpoint (see [Section 1.3](#sec_key_terms){.xref}). If
the local SCTP instance has not been initialized, the ASSOCIATE is
considered an error.[¶](#section-11.1.2-3){.pilcrow}

An association id, which is a local handle to the SCTP association, will
be returned on successful establishment of the association. If SCTP is
not able to open an SCTP association with the peer endpoint, an error is
returned.[¶](#section-11.1.2-4){.pilcrow}

Other association parameters can be returned, including the complete
destination transport addresses of the peer as well as the outbound
stream count of the local endpoint. One of the transport addresses from
the returned destination addresses will be selected by the local
endpoint as the default primary path for sending SCTP packets to this
peer. The returned \"destination transport addr list\" can be used by
the ULP to change the default primary path or to force sending a packet
to a specific transport address.[¶](#section-11.1.2-5){.pilcrow}

Implementation Note: If the ASSOCIATE primitive is implemented as a
blocking function call, the ASSOCIATE primitive can return association
parameters in addition to the association id upon successful
establishment. If ASSOCIATE primitive is implemented as a non-blocking
call, only the association id is returned and association parameters are
passed using the COMMUNICATION UP
notification.[¶](#section-11.1.2-6){.pilcrow}

[]{.break}

Mandatory attributes:
:   []{.break}

    local SCTP instance name:
    :   obtained from the INITIALIZE
        operation.[¶](#section-11.1.2-7.2.1.2){.pilcrow}
    :   

    initial destination transport addr list:
    :   a non-empty list of transport addresses of the peer endpoint
        with which the association is to be
        established.[¶](#section-11.1.2-7.2.1.4){.pilcrow}
    :   

    outbound stream count:
    :   the number of outbound streams the ULP would like to open
        towards this peer
        endpoint.[¶](#section-11.1.2-7.2.1.6){.pilcrow}
    :   
:   

Optional attributes:
:   None.[¶](#section-11.1.2-7.4){.pilcrow}
:   
:::
:::

::: {#sec_shutdown}
::: {#section-11.1.3 .section}
#### [11.1.3.](#section-11.1.3){.section-number .selfRef} [Shutdown](#name-shutdown){.section-name .selfRef} {#name-shutdown}

::: {#section-11.1.3-1}
``` {.lang-pseudocode .sourcecode}
SHUTDOWN(association id) -> result
```

[¶](#section-11.1.3-1){.pilcrow}
:::

Gracefully closes an association. Any locally queued user data will be
delivered to the peer. The association will be terminated only after the
peer acknowledges all the SCTP packets sent. A success code will be
returned on successful termination of the association. If attempting to
terminate the association results in a failure, an error code is
returned.[¶](#section-11.1.3-2){.pilcrow}

[]{.break}

Mandatory attributes:
:   []{.break}

    association id:
    :   local handle to the SCTP
        association.[¶](#section-11.1.3-3.2.1.2){.pilcrow}
    :   
:   

Optional attributes:
:   None.[¶](#section-11.1.3-3.4){.pilcrow}
:   
:::
:::

::: {#section-11.1.4 .section}
#### [11.1.4.](#section-11.1.4){.section-number .selfRef} [Abort](#name-abort){.section-name .selfRef} {#name-abort}

::: {#section-11.1.4-1}
``` {.lang-pseudocode .sourcecode}
ABORT(association id [, Upper Layer Abort Reason]) -> result
```

[¶](#section-11.1.4-1){.pilcrow}
:::

Ungracefully closes an association. Any locally queued user data will be
discarded, and an ABORT chunk is sent to the peer. A success code will
be returned on successful abort of the association. If attempting to
abort the association results in a failure, an error code is
returned.[¶](#section-11.1.4-2){.pilcrow}

[]{.break}

Mandatory attributes:
:   []{.break}

    association id:
    :   local handle to the SCTP
        association.[¶](#section-11.1.4-3.2.1.2){.pilcrow}
    :   
:   

Optional attributes:
:   []{.break}

    Upper Layer Abort Reason:
    :   reason of the abort to be passed to the
        peer.[¶](#section-11.1.4-3.4.1.2){.pilcrow}
    :   
:   
:::

::: {#sec_send}
::: {#section-11.1.5 .section}
#### [11.1.5.](#section-11.1.5){.section-number .selfRef} [Send](#name-send){.section-name .selfRef} {#name-send}

::: {#section-11.1.5-1}
``` {.lang-pseudocode .sourcecode}
SEND(association id, buffer address, byte count [,context]
[,stream id] [,life time] [,destination transport address]
[,unordered flag] [,no-bundle flag] [,payload protocol-id]
[,sack-immediately flag]) -> result
```

[¶](#section-11.1.5-1){.pilcrow}
:::

This is the main method to send user data via
SCTP.[¶](#section-11.1.5-2){.pilcrow}

[]{.break}

Mandatory attributes:
:   []{.break}

    association id:
    :   local handle to the SCTP
        association.[¶](#section-11.1.5-3.2.1.2){.pilcrow}
    :   

    buffer address:
    :   the location where the user message to be transmitted is
        stored.[¶](#section-11.1.5-3.2.1.4){.pilcrow}
    :   

    byte count:
    :   the size of the user data in number of
        bytes.[¶](#section-11.1.5-3.2.1.6){.pilcrow}
    :   
:   

Optional attributes:
:   []{.break}

    context:
    :   optional information provided that will be carried in the SEND
        FAILURE notification to the ULP if the transportation of this
        user message fails.[¶](#section-11.1.5-3.4.1.2){.pilcrow}
    :   

    stream id:
    :   indicates which stream to send the data on. If not specified,
        stream 0 will be used.[¶](#section-11.1.5-3.4.1.4){.pilcrow}
    :   

    life time:

    :   specifies the life time of the user data. The user data will not
        be sent by SCTP after the life time expires. This parameter can
        be used to avoid efforts to transmit stale user messages. SCTP
        notifies the ULP if the data cannot be initiated to transport
        (i.e., sent to the destination via SCTP\'s SEND primitive)
        within the life time variable. However, the user data will be
        transmitted if SCTP has attempted to transmit a chunk before the
        life time expired.[¶](#section-11.1.5-3.4.1.6.1){.pilcrow}

        Implementation Note: In order to better support the data life
        time option, the transmitter can hold back the assigning of the
        TSN number to an outbound DATA chunk to the last moment. And,
        for implementation simplicity, once a TSN number has been
        assigned, the sender considers the send of this DATA chunk as
        committed, overriding any life time option attached to the DATA
        chunk.[¶](#section-11.1.5-3.4.1.6.2){.pilcrow}

    :   

    destination transport address:
    :   specified as one of the destination transport addresses of the
        peer endpoint to which this packet is sent. Whenever possible,
        SCTP uses this destination transport address for sending the
        packets, instead of the current primary
        path.[¶](#section-11.1.5-3.4.1.8){.pilcrow}
    :   

    unordered flag:
    :   this flag, if present, indicates that the user would like the
        data delivered in an unordered fashion to the peer (i.e., the U
        flag is set to 1 on all DATA chunks carrying this
        message).[¶](#section-11.1.5-3.4.1.10){.pilcrow}
    :   

    no-bundle flag:
    :   instructs SCTP not to delay the sending of DATA chunks for this
        user data just to allow it to be bundled with other outbound
        DATA chunks. When faced with network congestion, SCTP might
        still bundle the data, even when this flag is
        present.[¶](#section-11.1.5-3.4.1.12){.pilcrow}
    :   

    payload protocol-id:
    :   a 32-bit unsigned integer that is to be passed to the peer,
        indicating the type of payload protocol data being transmitted.
        Note that the upper layer is responsible for the host to network
        byte order conversion of this field, which is passed by SCTP as
        4 bytes of opaque data.[¶](#section-11.1.5-3.4.1.14){.pilcrow}
    :   

    sack-immediately flag:
    :   set the I bit on the last DATA chunk used for the user message
        to be transmitted.[¶](#section-11.1.5-3.4.1.16){.pilcrow}
    :   
:   
:::
:::

::: {#section-11.1.6 .section}
#### [11.1.6.](#section-11.1.6){.section-number .selfRef} [Set Primary](#name-set-primary){.section-name .selfRef} {#name-set-primary}

::: {#section-11.1.6-1}
``` {.lang-pseudocode .sourcecode}
SETPRIMARY(association id, destination transport address,
[source transport address]) -> result
```

[¶](#section-11.1.6-1){.pilcrow}
:::

Instructs the local SCTP to use the specified destination transport
address as the primary path for sending
packets.[¶](#section-11.1.6-2){.pilcrow}

The result of attempting this operation is returned. If the specified
destination transport address is not present in the \"destination
transport address list\" returned earlier in an ASSOCIATE primitive or
COMMUNICATION UP notification, an error is
returned.[¶](#section-11.1.6-3){.pilcrow}

[]{.break}

Mandatory attributes:
:   []{.break}

    association id:
    :   local handle to the SCTP
        association.[¶](#section-11.1.6-4.2.1.2){.pilcrow}
    :   

    destination transport address:
    :   specified as one of the transport addresses of the peer
        endpoint, which is used as the primary address for sending
        packets. This overrides the current primary address information
        maintained by the local SCTP
        endpoint.[¶](#section-11.1.6-4.2.1.4){.pilcrow}
    :   
:   

Optional attributes:
:   []{.break}

    source transport address:
    :   optionally, some implementations can allow you to set the
        default source address placed in all outgoing IP
        datagrams.[¶](#section-11.1.6-4.4.1.2){.pilcrow}
    :   
:   
:::

::: {#section-11.1.7 .section}
#### [11.1.7.](#section-11.1.7){.section-number .selfRef} [Receive](#name-receive){.section-name .selfRef} {#name-receive}

::: {#section-11.1.7-1}
``` {.lang-pseudocode .sourcecode}
RECEIVE(association id, buffer address, buffer size [,stream id])
-> byte count [,transport address] [,stream id]
[,stream sequence number] [,partial flag] [,payload protocol-id]
```

[¶](#section-11.1.7-1){.pilcrow}
:::

This primitive reads the first user message in the SCTP in-queue into
the buffer specified by ULP, if there is one available. The size of the
message read, in bytes, will be returned. It might, depending on the
specific implementation, also return other information, such as the
sender\'s address, the stream id on which it is received, whether there
are more messages available for retrieval, etc. For ordered messages,
their Stream Sequence Number might also be
returned.[¶](#section-11.1.7-2){.pilcrow}

Depending upon the implementation, if this primitive is invoked when no
message is available, the implementation returns an indication of this
condition or blocks the invoking process until data does become
available.[¶](#section-11.1.7-3){.pilcrow}

[]{.break}

Mandatory attributes:
:   []{.break}

    association id:
    :   local handle to the SCTP
        association.[¶](#section-11.1.7-4.2.1.2){.pilcrow}
    :   

    buffer address:
    :   the memory location indicated by the ULP to store the received
        message.[¶](#section-11.1.7-4.2.1.4){.pilcrow}
    :   

    buffer size:
    :   the maximum size of data to be received, in
        bytes.[¶](#section-11.1.7-4.2.1.6){.pilcrow}
    :   
:   

Optional attributes:
:   []{.break}

    stream id:
    :   to indicate which stream to receive the data
        on.[¶](#section-11.1.7-4.4.1.2){.pilcrow}
    :   

    stream sequence number:
    :   the Stream Sequence Number assigned by the sending SCTP
        peer.[¶](#section-11.1.7-4.4.1.4){.pilcrow}
    :   

    partial flag:
    :   if this returned flag is set to 1, then this primitive contains
        a partial delivery of the whole message. When this flag is set,
        the stream id and stream sequence number accompanies this
        primitive. When this flag is set to 0, it indicates that no more
        deliveries will be received for this stream sequence
        number.[¶](#section-11.1.7-4.4.1.6){.pilcrow}
    :   

    payload protocol-id:
    :   a 32-bit unsigned integer that is received from the peer
        indicating the type of payload protocol of the received data.
        Note that the upper layer is responsible for the host to network
        byte order conversion of this field, which is passed by SCTP as
        4 bytes of opaque data.[¶](#section-11.1.7-4.4.1.8){.pilcrow}
    :   
:   
:::

::: {#section-11.1.8 .section}
#### [11.1.8.](#section-11.1.8){.section-number .selfRef} [Status](#name-status){.section-name .selfRef} {#name-status}

::: {#section-11.1.8-1}
``` {.lang-pseudocode .sourcecode}
STATUS(association id) -> status data
```

[¶](#section-11.1.8-1){.pilcrow}
:::

This primitive returns a data block containing the following
information:[¶](#section-11.1.8-2){.pilcrow}

-   ::: {#section-11.1.8-3.1}
    association connection state,[¶](#section-11.1.8-3.1.1){.pilcrow}
    :::

-   ::: {#section-11.1.8-3.2}
    destination transport address
    list,[¶](#section-11.1.8-3.2.1){.pilcrow}
    :::

-   ::: {#section-11.1.8-3.3}
    destination transport address reachability
    states,[¶](#section-11.1.8-3.3.1){.pilcrow}
    :::

-   ::: {#section-11.1.8-3.4}
    current receiver window size,[¶](#section-11.1.8-3.4.1){.pilcrow}
    :::

-   ::: {#section-11.1.8-3.5}
    current congestion window sizes,[¶](#section-11.1.8-3.5.1){.pilcrow}
    :::

-   ::: {#section-11.1.8-3.6}
    number of unacknowledged DATA
    chunks,[¶](#section-11.1.8-3.6.1){.pilcrow}
    :::

-   ::: {#section-11.1.8-3.7}
    number of DATA chunks pending
    receipt,[¶](#section-11.1.8-3.7.1){.pilcrow}
    :::

-   ::: {#section-11.1.8-3.8}
    primary path,[¶](#section-11.1.8-3.8.1){.pilcrow}
    :::

-   ::: {#section-11.1.8-3.9}
    most recent SRTT on primary
    path,[¶](#section-11.1.8-3.9.1){.pilcrow}
    :::

-   ::: {#section-11.1.8-3.10}
    RTO on primary path,[¶](#section-11.1.8-3.10.1){.pilcrow}
    :::

-   ::: {#section-11.1.8-3.11}
    SRTT and RTO on other destination addresses,
    etc.[¶](#section-11.1.8-3.11.1){.pilcrow}
    :::

[]{.break}

Mandatory attributes:
:   []{.break}

    association id:
    :   local handle to the SCTP
        association.[¶](#section-11.1.8-4.2.1.2){.pilcrow}
    :   
:   

Optional attributes:
:   None.[¶](#section-11.1.8-4.4){.pilcrow}
:   
:::

::: {#section-11.1.9 .section}
#### [11.1.9.](#section-11.1.9){.section-number .selfRef} [Change Heartbeat](#name-change-heartbeat){.section-name .selfRef} {#name-change-heartbeat}

::: {#section-11.1.9-1}
``` {.lang-pseudocode .sourcecode}
CHANGE HEARTBEAT(association id, destination transport address,
new state [,interval]) -> result
```

[¶](#section-11.1.9-1){.pilcrow}
:::

Instructs the local endpoint to enable or disable heartbeat on the
specified destination transport address.[¶](#section-11.1.9-2){.pilcrow}

The result of attempting this operation is
returned.[¶](#section-11.1.9-3){.pilcrow}

Note: Even when enabled, heartbeat will not take place if the
destination transport address is not
idle.[¶](#section-11.1.9-4){.pilcrow}

[]{.break}

Mandatory attributes:
:   []{.break}

    association id:
    :   local handle to the SCTP
        association.[¶](#section-11.1.9-5.2.1.2){.pilcrow}
    :   

    destination transport address:
    :   specified as one of the transport addresses of the peer
        endpoint.[¶](#section-11.1.9-5.2.1.4){.pilcrow}
    :   

    new state:
    :   the new state of heartbeat for this destination transport
        address (either enabled or
        disabled).[¶](#section-11.1.9-5.2.1.6){.pilcrow}
    :   
:   

Optional attributes:
:   []{.break}

    interval:
    :   if present, indicates the frequency of the heartbeat if this is
        to enable heartbeat on a destination transport address. This
        value is added to the RTO of the destination transport address.
        This value, if present, affects all
        destinations.[¶](#section-11.1.9-5.4.1.2){.pilcrow}
    :   
:   
:::

::: {#section-11.1.10 .section}
#### [11.1.10.](#section-11.1.10){.section-number .selfRef} [Request Heartbeat](#name-request-heartbeat){.section-name .selfRef} {#name-request-heartbeat}

::: {#section-11.1.10-1}
``` {.lang-pseudocode .sourcecode}
REQUESTHEARTBEAT(association id, destination transport address)
-> result
```

[¶](#section-11.1.10-1){.pilcrow}
:::

Instructs the local endpoint to perform a heartbeat on the specified
destination transport address of the given association. The returned
result indicates whether the transmission of the HEARTBEAT chunk to the
destination address is successful.[¶](#section-11.1.10-2){.pilcrow}

[]{.break}

Mandatory attributes:
:   []{.break}

    association id:
    :   local handle to the SCTP
        association.[¶](#section-11.1.10-3.2.1.2){.pilcrow}
    :   

    destination transport address:
    :   the transport address of the association on which a heartbeat is
        issued.[¶](#section-11.1.10-3.2.1.4){.pilcrow}
    :   
:   

Optional attributes:
:   None.[¶](#section-11.1.10-3.4){.pilcrow}
:   
:::

::: {#section-11.1.11 .section}
#### [11.1.11.](#section-11.1.11){.section-number .selfRef} [Get SRTT Report](#name-get-srtt-report){.section-name .selfRef} {#name-get-srtt-report}

::: {#section-11.1.11-1}
``` {.lang-pseudocode .sourcecode}
GETSRTTREPORT(association id, destination transport address)
-> srtt result
```

[¶](#section-11.1.11-1){.pilcrow}
:::

Instructs the local SCTP to report the current SRTT measurement on the
specified destination transport address of the given association. The
returned result can be an integer containing the most recent SRTT in
milliseconds.[¶](#section-11.1.11-2){.pilcrow}

[]{.break}

Mandatory attributes:
:   []{.break}

    association id:
    :   local handle to the SCTP
        association.[¶](#section-11.1.11-3.2.1.2){.pilcrow}
    :   

    destination transport address:
    :   the transport address of the association on which the SRTT
        measurement is to be
        reported.[¶](#section-11.1.11-3.2.1.4){.pilcrow}
    :   
:   

Optional attributes:
:   None.[¶](#section-11.1.11-3.4){.pilcrow}
:   
:::

::: {#section-11.1.12 .section}
#### [11.1.12.](#section-11.1.12){.section-number .selfRef} [Set Failure Threshold](#name-set-failure-threshold){.section-name .selfRef} {#name-set-failure-threshold}

::: {#section-11.1.12-1}
``` {.lang-pseudocode .sourcecode}
SETFAILURETHRESHOLD(association id, destination transport address,
failure threshold) -> result
```

[¶](#section-11.1.12-1){.pilcrow}
:::

This primitive allows the local SCTP to customize the reachability
failure detection threshold \'Path.Max.Retrans\' for the specified
destination address. Note that this can also be done using the
SETPROTOCOLPARAMETERS primitive ([Section
11.1.13](#sec_set_protocol_parameters){.xref}).[¶](#section-11.1.12-2){.pilcrow}

[]{.break}

Mandatory attributes:
:   []{.break}

    association id:
    :   local handle to the SCTP
        association.[¶](#section-11.1.12-3.2.1.2){.pilcrow}
    :   

    destination transport address:
    :   the transport address of the association on which the failure
        detection threshold is to be
        set.[¶](#section-11.1.12-3.2.1.4){.pilcrow}
    :   

    failure threshold:
    :   the new value of \'Path.Max.Retrans\' for the destination
        address.[¶](#section-11.1.12-3.2.1.6){.pilcrow}
    :   
:   

Optional attributes:

:   None.[¶](#section-11.1.12-3.4.1){.pilcrow}

:   
:::

::: {#sec_set_protocol_parameters}
::: {#section-11.1.13 .section}
#### [11.1.13.](#section-11.1.13){.section-number .selfRef} [Set Protocol Parameters](#name-set-protocol-parameters){.section-name .selfRef} {#name-set-protocol-parameters}

::: {#section-11.1.13-1}
``` {.lang-pseudocode .sourcecode}
SETPROTOCOLPARAMETERS(association id,
[destination transport address,] protocol parameter list)
-> result
```

[¶](#section-11.1.13-1){.pilcrow}
:::

This primitive allows the local SCTP to customize the protocol
parameters.[¶](#section-11.1.13-2){.pilcrow}

[]{.break}

Mandatory attributes:
:   []{.break}

    association id:
    :   local handle to the SCTP
        association.[¶](#section-11.1.13-3.2.1.2){.pilcrow}
    :   

    protocol parameter list:
    :   the specific names and values of the protocol parameters (e.g.,
        \'Association.Max.Retrans\' (see [Section
        16](#sec_parameter_values){.xref}) or other parameters like the
        DSCP) that the SCTP user wishes to
        customize.[¶](#section-11.1.13-3.2.1.4){.pilcrow}
    :   
:   

Optional attributes:
:   []{.break}

    destination transport address:
    :   some of the protocol parameters might be set on a
        per-destination-transport-address
        basis.[¶](#section-11.1.13-3.4.1.2){.pilcrow}
    :   
:   
:::
:::

::: {#section-11.1.14 .section}
#### [11.1.14.](#section-11.1.14){.section-number .selfRef} [Receive Unsent Message](#name-receive-unsent-message){.section-name .selfRef} {#name-receive-unsent-message}

::: {#section-11.1.14-1}
``` {.lang-pseudocode .sourcecode}
RECEIVE_UNSENT(data retrieval id, buffer address, buffer size
[,stream id] [, stream sequence number] [,partial flag]
[,payload protocol-id])
```

[¶](#section-11.1.14-1){.pilcrow}
:::

This primitive reads a user message that has never been sent into the
buffer specified by ULP.[¶](#section-11.1.14-2){.pilcrow}

[]{.break}

Mandatory attributes:
:   []{.break}

    data retrieval id:
    :   the identification passed to the ULP in the SEND FAILURE
        notification.[¶](#section-11.1.14-3.2.1.2){.pilcrow}
    :   

    buffer address:
    :   the memory location indicated by the ULP to store the received
        message.[¶](#section-11.1.14-3.2.1.4){.pilcrow}
    :   

    buffer size:
    :   the maximum size of data to be received, in
        bytes.[¶](#section-11.1.14-3.2.1.6){.pilcrow}
    :   
:   

Optional attributes:
:   []{.break}

    stream id:
    :   this is a return value that is set to indicate which stream the
        data was sent to.[¶](#section-11.1.14-3.4.1.2){.pilcrow}
    :   

    stream sequence number:
    :   this value is returned, indicating the Stream Sequence Number
        that was associated with the
        message.[¶](#section-11.1.14-3.4.1.4){.pilcrow}
    :   

    partial flag:
    :   if this returned flag is set to 1, then this message is a
        partial delivery of the whole message. When this flag is set,
        the stream id and stream sequence number accompanies this
        primitive. When this flag is set to 0, it indicates that no more
        deliveries will be received for this stream sequence
        number.[¶](#section-11.1.14-3.4.1.6){.pilcrow}
    :   

    payload protocol-id:
    :   The 32-bit unsigned integer that was set to be sent to the peer,
        indicating the type of payload protocol of the received
        data.[¶](#section-11.1.14-3.4.1.8){.pilcrow}
    :   
:   
:::

::: {#section-11.1.15 .section}
#### [11.1.15.](#section-11.1.15){.section-number .selfRef} [Receive Unacknowledged Message](#name-receive-unacknowledged-mess){.section-name .selfRef} {#name-receive-unacknowledged-mess}

::: {#section-11.1.15-1}
``` {.lang-pseudocode .sourcecode}
RECEIVE_UNACKED(data retrieval id, buffer address, buffer size,
[,stream id] [,stream sequence number] [,partial flag]
[,payload protocol-id])
```

[¶](#section-11.1.15-1){.pilcrow}
:::

This primitive reads a user message that has been sent and has not been
acknowledged by the peer into the buffer specified by
ULP.[¶](#section-11.1.15-2){.pilcrow}

[]{.break}

Mandatory attributes:
:   []{.break}

    data retrieval id:
    :   the identification passed to the ULP in the SEND FAILURE
        notification.[¶](#section-11.1.15-3.2.1.2){.pilcrow}
    :   

    buffer address:
    :   the memory location indicated by the ULP to store the received
        message.[¶](#section-11.1.15-3.2.1.4){.pilcrow}
    :   

    buffer size:
    :   the maximum size of data to be received, in
        bytes.[¶](#section-11.1.15-3.2.1.6){.pilcrow}
    :   
:   

Optional attributes:
:   []{.break}

    stream id:
    :   this is a return value that is set to indicate which stream the
        data was sent to.[¶](#section-11.1.15-3.4.1.2){.pilcrow}
    :   

    stream sequence number:
    :   this value is returned, indicating the Stream Sequence Number
        that was associated with the
        message.[¶](#section-11.1.15-3.4.1.4){.pilcrow}
    :   

    partial flag:
    :   if this returned flag is set to 1, then this message is a
        partial delivery of the whole message. When this flag is set,
        the stream id and stream sequence number accompanies this
        primitive. When this flag is set to 0, it indicates that no more
        deliveries will be received for this stream sequence
        number.[¶](#section-11.1.15-3.4.1.6){.pilcrow}
    :   

    payload protocol-id:
    :   the 32-bit unsigned integer that was sent to the peer indicating
        the type of payload protocol of the received
        data.[¶](#section-11.1.15-3.4.1.8){.pilcrow}
    :   
:   
:::

::: {#section-11.1.16 .section}
#### [11.1.16.](#section-11.1.16){.section-number .selfRef} [Destroy SCTP Instance](#name-destroy-sctp-instance){.section-name .selfRef} {#name-destroy-sctp-instance}

::: {#section-11.1.16-1}
``` {.lang-pseudocode .sourcecode}
DESTROY(local SCTP instance name)
```

[¶](#section-11.1.16-1){.pilcrow}
:::

[]{.break}

Mandatory attributes:
:   []{.break}

    local SCTP instance name:
    :   this is the value that was passed to the application in the
        initialize primitive and it indicates which SCTP instance is to
        be destroyed.[¶](#section-11.1.16-2.2.1.2){.pilcrow}
    :   
:   

Optional attributes:
:   None.[¶](#section-11.1.16-2.4){.pilcrow}
:   
:::
:::
:::

::: {#sec_sctp_to_ulp}
::: {#section-11.2 .section}
### [11.2.](#section-11.2){.section-number .selfRef} [SCTP-to-ULP](#name-sctp-to-ulp){.section-name .selfRef} {#name-sctp-to-ulp}

It is assumed that the operating system or application environment
provides a means for the SCTP to asynchronously signal the ULP process.
When SCTP does signal a ULP process, certain information is passed to
the ULP.[¶](#section-11.2-1){.pilcrow}

Implementation Note: In some cases, this might be done through a
separate socket or error channel.[¶](#section-11.2-2){.pilcrow}

::: {#section-11.2.1 .section}
#### [11.2.1.](#section-11.2.1){.section-number .selfRef} [DATA ARRIVE Notification](#name-data-arrive-notification){.section-name .selfRef} {#name-data-arrive-notification}

SCTP invokes this notification on the ULP when a user message is
successfully received and ready for
retrieval.[¶](#section-11.2.1-1){.pilcrow}

The following might optionally be passed with the
notification:[¶](#section-11.2.1-2){.pilcrow}

[]{.break}

association id:
:   local handle to the SCTP
    association.[¶](#section-11.2.1-3.2){.pilcrow}
:   

stream id:
:   to indicate which stream the data is received
    on.[¶](#section-11.2.1-3.4){.pilcrow}
:   
:::

::: {#section-11.2.2 .section}
#### [11.2.2.](#section-11.2.2){.section-number .selfRef} [SEND FAILURE Notification](#name-send-failure-notification){.section-name .selfRef} {#name-send-failure-notification}

If a message cannot be delivered, SCTP invokes this notification on the
ULP.[¶](#section-11.2.2-1){.pilcrow}

The following might optionally be passed with the
notification:[¶](#section-11.2.2-2){.pilcrow}

[]{.break}

association id:
:   local handle to the SCTP
    association.[¶](#section-11.2.2-3.2){.pilcrow}
:   

data retrieval id:
:   an identification used to retrieve unsent and unacknowledged
    data.[¶](#section-11.2.2-3.4){.pilcrow}
:   

mode:
:   indicates whether no part of the message never has been sent or if
    at least part of it has been sent but it is not completely
    acknowledged.[¶](#section-11.2.2-3.6){.pilcrow}
:   

cause code:
:   indicating the reason of the failure, e.g., size too large, message
    life time expiration, etc.[¶](#section-11.2.2-3.8){.pilcrow}
:   

context:
:   optional information associated with this message (see [Section
    11.1.5](#sec_send){.xref}).[¶](#section-11.2.2-3.10){.pilcrow}
:   
:::

::: {#section-11.2.3 .section}
#### [11.2.3.](#section-11.2.3){.section-number .selfRef} [NETWORK STATUS CHANGE Notification](#name-network-status-change-notif){.section-name .selfRef} {#name-network-status-change-notif}

When a destination transport address is marked inactive (e.g., when SCTP
detects a failure) or marked active (e.g., when SCTP detects a
recovery), SCTP invokes this notification on the
ULP.[¶](#section-11.2.3-1){.pilcrow}

The following is passed with the
notification:[¶](#section-11.2.3-2){.pilcrow}

[]{.break}

association id:
:   local handle to the SCTP
    association.[¶](#section-11.2.3-3.2){.pilcrow}
:   

destination transport address:
:   this indicates the destination transport address of the peer
    endpoint affected by the change.[¶](#section-11.2.3-3.4){.pilcrow}
:   

new-status:
:   this indicates the new status.[¶](#section-11.2.3-3.6){.pilcrow}
:   
:::

::: {#section-11.2.4 .section}
#### [11.2.4.](#section-11.2.4){.section-number .selfRef} [COMMUNICATION UP Notification](#name-communication-up-notificati){.section-name .selfRef} {#name-communication-up-notificati}

This notification is used when SCTP becomes ready to send or receive
user messages or when a lost communication to an endpoint is
restored.[¶](#section-11.2.4-1){.pilcrow}

Implementation Note: If the ASSOCIATE primitive is implemented as a
blocking function call, the association parameters are returned as a
result of the ASSOCIATE primitive itself. In that case, the
COMMUNICATION UP notification is optional at the association
initiator\'s side.[¶](#section-11.2.4-2){.pilcrow}

The following is passed with the
notification:[¶](#section-11.2.4-3){.pilcrow}

[]{.break}

association id:
:   local handle to the SCTP
    association.[¶](#section-11.2.4-4.2){.pilcrow}
:   

status:
:   this indicates what type of event has
    occurred.[¶](#section-11.2.4-4.4){.pilcrow}
:   

destination transport address list:
:   the complete set of transport addresses of the
    peer.[¶](#section-11.2.4-4.6){.pilcrow}
:   

outbound stream count:
:   the maximum number of streams allowed to be used in this association
    by the ULP.[¶](#section-11.2.4-4.8){.pilcrow}
:   

inbound stream count:
:   the number of streams the peer endpoint has requested with this
    association (this might not be the same number as \'outbound stream
    count\').[¶](#section-11.2.4-4.10){.pilcrow}
:   
:::

::: {#section-11.2.5 .section}
#### [11.2.5.](#section-11.2.5){.section-number .selfRef} [COMMUNICATION LOST Notification](#name-communication-lost-notifica){.section-name .selfRef} {#name-communication-lost-notifica}

When SCTP loses communication to an endpoint completely (e.g., via
Heartbeats) or detects that the endpoint has performed an abort
operation, it invokes this notification on the
ULP.[¶](#section-11.2.5-1){.pilcrow}

The following is passed with the
notification:[¶](#section-11.2.5-2){.pilcrow}

[]{.break}

association id:
:   local handle to the SCTP
    association.[¶](#section-11.2.5-3.2){.pilcrow}
:   

status:
:   this indicates what type of event has occurred; the status might
    indicate that a failure OR a normal termination event occurred in
    response to a shutdown or abort
    request.[¶](#section-11.2.5-3.4){.pilcrow}
:   

The following might be passed with the
notification:[¶](#section-11.2.5-4){.pilcrow}

[]{.break}

last-acked:
:   the TSN last acked by that peer
    endpoint.[¶](#section-11.2.5-5.2){.pilcrow}
:   

last-sent:
:   the TSN last sent to that peer
    endpoint.[¶](#section-11.2.5-5.4){.pilcrow}
:   

Upper Layer Abort Reason:
:   the abort reason specified in case of a user-initiated
    abort.[¶](#section-11.2.5-5.6){.pilcrow}
:   
:::

::: {#section-11.2.6 .section}
#### [11.2.6.](#section-11.2.6){.section-number .selfRef} [COMMUNICATION ERROR Notification](#name-communication-error-notific){.section-name .selfRef} {#name-communication-error-notific}

When SCTP receives an ERROR chunk from its peer and decides to notify
its ULP, it can invoke this notification on the
ULP.[¶](#section-11.2.6-1){.pilcrow}

The following can be passed with the
notification:[¶](#section-11.2.6-2){.pilcrow}

[]{.break}

association id:
:   local handle to the SCTP
    association.[¶](#section-11.2.6-3.2){.pilcrow}
:   

error info:
:   this indicates the type of error and optionally some additional
    information received through the ERROR
    chunk.[¶](#section-11.2.6-3.4){.pilcrow}
:   
:::

::: {#section-11.2.7 .section}
#### [11.2.7.](#section-11.2.7){.section-number .selfRef} [RESTART Notification](#name-restart-notification){.section-name .selfRef} {#name-restart-notification}

When SCTP detects that the peer has restarted, it might send this
notification to its ULP.[¶](#section-11.2.7-1){.pilcrow}

The following can be passed with the
notification:[¶](#section-11.2.7-2){.pilcrow}

[]{.break}

association id:
:   local handle to the SCTP
    association.[¶](#section-11.2.7-3.2){.pilcrow}
:   
:::

::: {#section-11.2.8 .section}
#### [11.2.8.](#section-11.2.8){.section-number .selfRef} [SHUTDOWN COMPLETE Notification](#name-shutdown-complete-notificat){.section-name .selfRef} {#name-shutdown-complete-notificat}

When SCTP completes the shutdown procedures ([Section
9.2](#sec_shutdown_of_an_association){.xref}), this notification is
passed to the upper layer.[¶](#section-11.2.8-1){.pilcrow}

The following can be passed with the
notification:[¶](#section-11.2.8-2){.pilcrow}

[]{.break}

association id:
:   local handle to the SCTP
    association.[¶](#section-11.2.8-3.2){.pilcrow}
:   
:::
:::
:::
:::
:::

::: {#sec_security}
::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

::: {#sec_security_objectives}
::: {#section-12.1 .section}
### [12.1.](#section-12.1){.section-number .selfRef} [Security Objectives](#name-security-objectives){.section-name .selfRef} {#name-security-objectives}

As a common transport protocol designed to reliably carry time-sensitive
user messages, such as billing or signaling messages for telephony
services, between two networked endpoints, SCTP has the following
security objectives:[¶](#section-12.1-1){.pilcrow}

-   [availability of reliable and timely data transport
    services[¶](#section-12.1-2.1){.pilcrow}]{#section-12.1-2.1}
-   [integrity of the user-to-user information carried by
    SCTP[¶](#section-12.1-2.2){.pilcrow}]{#section-12.1-2.2}
:::
:::

::: {#sctp_responses_to_potential_threats}
::: {#section-12.2 .section}
### [12.2.](#section-12.2){.section-number .selfRef} [SCTP Responses to Potential Threats](#name-sctp-responses-to-potential){.section-name .selfRef} {#name-sctp-responses-to-potential}

SCTP could potentially be used in a wide variety of risk situations. It
is important for operators of systems running SCTP to analyze their
particular situations and decide on the appropriate
counter-measures.[¶](#section-12.2-1){.pilcrow}

Operators of systems running SCTP might consult
\[[RFC2196](#RFC2196){.xref}\] for guidance in securing their
site.[¶](#section-12.2-2){.pilcrow}

::: {#section-12.2.1 .section}
#### [12.2.1.](#section-12.2.1){.section-number .selfRef} [Countering Insider Attacks](#name-countering-insider-attacks){.section-name .selfRef} {#name-countering-insider-attacks}

The principles of \[[RFC2196](#RFC2196){.xref}\] might be applied to
minimize the risk of theft of information or sabotage by insiders. Such
procedures include publication of security policies, control of access
at the physical, software, and network levels, and separation of
services.[¶](#section-12.2.1-1){.pilcrow}
:::

::: {#section-12.2.2 .section}
#### [12.2.2.](#section-12.2.2){.section-number .selfRef} [Protecting against Data Corruption in the Network](#name-protecting-against-data-cor){.section-name .selfRef} {#name-protecting-against-data-cor}

Where the risk of undetected errors in datagrams delivered by the
lower-layer transport services is considered to be too great, additional
integrity protection is required. If this additional protection were
provided in the application layer, the SCTP header would remain
vulnerable to deliberate integrity attacks. While the existing SCTP
mechanisms for detection of packet replays are considered sufficient for
normal operation, stronger protections are needed to protect SCTP when
the operating environment contains significant risk of deliberate
attacks from a sophisticated adversary.[¶](#section-12.2.2-1){.pilcrow}

The SCTP Authentication extension SCTP-AUTH
\[[RFC4895](#RFC4895){.xref}\] [MAY]{.bcp14} be used when the threat
environment requires stronger integrity protections but does not require
confidentiality.[¶](#section-12.2.2-2){.pilcrow}
:::

::: {#section-12.2.3 .section}
#### [12.2.3.](#section-12.2.3){.section-number .selfRef} [Protecting Confidentiality](#name-protecting-confidentiality){.section-name .selfRef} {#name-protecting-confidentiality}

In most cases, the risk of breach of confidentiality applies to the
signaling data payload, not to the SCTP or lower-layer protocol
overheads. If that is true, encryption of the SCTP user data only might
be considered. As with the supplementary checksum service, user data
encryption [MAY]{.bcp14} be performed by the SCTP user application.
\[[RFC6083](#RFC6083){.xref}\] [MAY]{.bcp14} be used for this.
Alternately, the user application [MAY]{.bcp14} use an
implementation-specific API to request that the IP Encapsulating
Security Payload (ESP) \[[RFC4303](#RFC4303){.xref}\] be used to provide
confidentiality and integrity.[¶](#section-12.2.3-1){.pilcrow}

Particularly for mobile users, the requirement for confidentiality might
include the masking of IP addresses and ports. In this case, ESP
[SHOULD]{.bcp14} be used instead of application-level confidentiality.
If ESP is used to protect confidentiality of SCTP traffic, an ESP
cryptographic transform that includes cryptographic integrity protection
[MUST]{.bcp14} be used, because, if there is a confidentiality threat,
there will also be a strong integrity
threat.[¶](#section-12.2.3-2){.pilcrow}

Regardless of where confidentiality is provided, the Internet Key
Exchange Protocol version 2 (IKEv2) \[[RFC7296](#RFC7296){.xref}\]
[SHOULD]{.bcp14} be used for key management of
ESP.[¶](#section-12.2.3-3){.pilcrow}

Operators might consult \[[RFC4301](#RFC4301){.xref}\] for more
information on the security services available at and immediately above
the Internet Protocol layer.[¶](#section-12.2.3-4){.pilcrow}
:::

::: {#section-12.2.4 .section}
#### [12.2.4.](#section-12.2.4){.section-number .selfRef} [Protecting against Blind Denial-of-Service Attacks](#name-protecting-against-blind-de){.section-name .selfRef} {#name-protecting-against-blind-de}

A blind attack is one where the attacker is unable to intercept or
otherwise see the content of data flows passing to and from the target
SCTP node. Blind denial-of-service attacks can take the form of
flooding, masquerade, or improper monopolization of
services.[¶](#section-12.2.4-1){.pilcrow}

::: {#section-12.2.4.1 .section}
##### [12.2.4.1.](#section-12.2.4.1){.section-number .selfRef} [Flooding](#name-flooding){.section-name .selfRef} {#name-flooding}

The objective of flooding is to cause loss of service and incorrect
behavior at target systems through resource exhaustion, interference
with legitimate transactions, and exploitation of buffer-related
software bugs. Flooding can be directed either at the SCTP node or at
resources in the intervening IP Access Links or the Internet. Where the
latter entities are the target, flooding will manifest itself as loss of
network services, including potentially the breach of any firewalls in
place.[¶](#section-12.2.4.1-1){.pilcrow}

In general, protection against flooding begins at the equipment design
level, where it includes measures such
as:[¶](#section-12.2.4.1-2){.pilcrow}

-   ::: {#section-12.2.4.1-3.1}
    avoiding commitment of limited resources before determining that the
    request for service is
    legitimate.[¶](#section-12.2.4.1-3.1.1){.pilcrow}
    :::

-   ::: {#section-12.2.4.1-3.2}
    giving priority to completion of processing in progress over the
    acceptance of new work.[¶](#section-12.2.4.1-3.2.1){.pilcrow}
    :::

-   ::: {#section-12.2.4.1-3.3}
    identification and removal of duplicate or stale queued requests for
    service.[¶](#section-12.2.4.1-3.3.1){.pilcrow}
    :::

-   ::: {#section-12.2.4.1-3.4}
    not responding to unexpected packets sent to non-unicast
    addresses.[¶](#section-12.2.4.1-3.4.1){.pilcrow}
    :::

Network equipment is expected to be capable of generating an alarm and
log if a suspicious increase in traffic occurs. The log provides
information, such as the identity of the incoming link and source
address(es) used, which will help the network or SCTP system operator to
take protective measures. Procedures are expected to be in place for the
operator to act on such alarms if a clear pattern of abuse
emerges.[¶](#section-12.2.4.1-4){.pilcrow}

The design of SCTP is resistant to flooding attacks, particularly in its
use of a four-way startup handshake, its use of a cookie to defer
commitment of resources at the responding SCTP node until the handshake
is completed, and its use of a Verification Tag to prevent insertion of
extraneous packets into the flow of an established
association.[¶](#section-12.2.4.1-5){.pilcrow}

ESP might be useful in reducing the risk of certain kinds of
denial-of-service attacks.[¶](#section-12.2.4.1-6){.pilcrow}

Support for the Host Name Address parameter has been removed from the
protocol. Endpoints receiving INIT or INIT ACK chunks containing the
Host Name Address parameter [MUST]{.bcp14} send an ABORT chunk in
response and [MAY]{.bcp14} include an \"Unresolvable Address\" error
cause.[¶](#section-12.2.4.1-7){.pilcrow}
:::

::: {#section-12.2.4.2 .section}
##### [12.2.4.2.](#section-12.2.4.2){.section-number .selfRef} [Blind Masquerade](#name-blind-masquerade){.section-name .selfRef} {#name-blind-masquerade}

Masquerade can be used to deny service in several
ways:[¶](#section-12.2.4.2-1){.pilcrow}

-   ::: {#section-12.2.4.2-2.1}
    by tying up resources at the target SCTP node to which the
    impersonated node has limited access. For example, the target node
    can by policy permit a maximum of one SCTP association with the
    impersonated SCTP node. The masquerading attacker can attempt to
    establish an association purporting to come from the impersonated
    node so that the latter cannot do so when it requires
    it.[¶](#section-12.2.4.2-2.1.1){.pilcrow}
    :::

-   ::: {#section-12.2.4.2-2.2}
    by deliberately allowing the impersonation to be detected, thereby
    provoking counter-measures that cause the impersonated node to be
    locked out of the target SCTP
    node.[¶](#section-12.2.4.2-2.2.1){.pilcrow}
    :::

-   ::: {#section-12.2.4.2-2.3}
    by interfering with an established association by inserting
    extraneous content such as a SHUTDOWN
    chunk.[¶](#section-12.2.4.2-2.3.1){.pilcrow}
    :::

SCTP reduces the risk of blind masquerade attacks through IP spoofing by
use of the four-way startup handshake. Because the initial exchange is
memoryless, no lockout mechanism is triggered by blind masquerade
attacks. In addition, the packet containing the INIT ACK chunk with the
State Cookie is transmitted back to the IP address from which it
received the packet containing the INIT chunk. Thus, the attacker would
not receive the INIT ACK chunk containing the State Cookie. SCTP
protects against insertion of extraneous packets into the flow of an
established association by use of the Verification
Tag.[¶](#section-12.2.4.2-3){.pilcrow}

Logging of received INIT chunks and abnormalities, such as unexpected
INIT ACK chunks, might be considered as a way to detect patterns of
hostile activity. However, the potential usefulness of such logging has
to be weighed against the increased SCTP startup processing it implies,
rendering the SCTP node more vulnerable to flooding attacks. Logging is
pointless without the establishment of operating procedures to review
and analyze the logs on a routine
basis.[¶](#section-12.2.4.2-4){.pilcrow}
:::

::: {#section-12.2.4.3 .section}
##### [12.2.4.3.](#section-12.2.4.3){.section-number .selfRef} [Improper Monopolization of Services](#name-improper-monopolization-of-){.section-name .selfRef} {#name-improper-monopolization-of-}

Attacks under this heading are performed openly and legitimately by the
attacker. They are directed against fellow users of the target SCTP node
or of the shared resources between the attacker and the target node.
Possible attacks include the opening of a large number of associations
between the attacker\'s node and the target or transfer of large volumes
of information within a legitimately established
association.[¶](#section-12.2.4.3-1){.pilcrow}

Policy limits are expected to be placed on the number of associations
per adjoining SCTP node. SCTP user applications are expected to be
capable of detecting large volumes of illegitimate or \"no-op\" messages
within a given association and either logging or terminating the
association as a result, based on local
policy.[¶](#section-12.2.4.3-2){.pilcrow}
:::
:::
:::
:::

::: {#sec_sctp_interaction_with_firewalls}
::: {#section-12.3 .section}
### [12.3.](#section-12.3){.section-number .selfRef} [SCTP Interactions with Firewalls](#name-sctp-interactions-with-fire){.section-name .selfRef} {#name-sctp-interactions-with-fire}

It is helpful for some firewalls if they can inspect just the first
fragment of a fragmented SCTP packet and unambiguously determine whether
it corresponds to an INIT chunk (for further information, please refer
to \[[RFC1858](#RFC1858){.xref}\]). Accordingly, we stress the
requirements, as stated in [Section
3.1](#sec_sctp_common_header_field_desriptions){.xref}, that (1) an INIT
chunk [MUST NOT]{.bcp14} be bundled with any other chunk in a packet and
(2) a packet containing an INIT chunk [MUST]{.bcp14} have a zero
Verification Tag. The receiver of an INIT chunk [MUST]{.bcp14} silently
discard the INIT chunk and all further chunks if the INIT chunk is
bundled with other chunks or the packet has a non-zero Verification
Tag.[¶](#section-12.3-1){.pilcrow}
:::
:::

::: {#sec_protection_of_non_sctp_capable_hosts}
::: {#section-12.4 .section}
### [12.4.](#section-12.4){.section-number .selfRef} [Protection of Non-SCTP-capable Hosts](#name-protection-of-non-sctp-capa){.section-name .selfRef} {#name-protection-of-non-sctp-capa}

To provide a non-SCTP-capable host with the same level of protection
against attacks as for SCTP-capable ones, all SCTP implementations
[MUST]{.bcp14} implement the ICMP handling described in [Section
10](#sec_icmp){.xref}.[¶](#section-12.4-1){.pilcrow}

When an SCTP implementation receives a packet containing multiple
control or DATA chunks and the processing of the packet would result in
sending multiple chunks in response, the sender of the response chunk(s)
[MUST NOT]{.bcp14} send more than one packet containing chunks other
than DATA chunks. This requirement protects the network for triggering a
packet burst in response to a single packet. If bundling is supported,
multiple response chunks that fit into a single packet [MAY]{.bcp14} be
bundled together into one single response packet. If bundling is not
supported, then the sender [MUST NOT]{.bcp14} send more than one
response chunk and [MUST]{.bcp14} discard all other responses. Note that
this rule does not apply to a SACK chunk, since a SACK chunk is, in
itself, a response to DATA chunks, and a SACK chunk does not require a
response of more DATA chunks.[¶](#section-12.4-2){.pilcrow}

An SCTP implementation [MUST]{.bcp14} abort the association if it
receives a SACK chunk acknowledging a TSN that has not been
sent.[¶](#section-12.4-3){.pilcrow}

An SCTP implementation that receives an INIT chunk that would require a
large packet in response, due to the inclusion of multiple
\"Unrecognized Parameter\" parameters, [MAY]{.bcp14} (at its discretion)
elect to omit some or all of the \"Unrecognized Parameter\" parameters
to reduce the size of the INIT ACK chunk. Due to a combination of the
size of the State Cookie parameter and the number of addresses a
receiver of an INIT chunk indicates to a peer, it is always possible
that the INIT ACK chunk will be larger than the original INIT chunk. An
SCTP implementation [SHOULD]{.bcp14} attempt to make the INIT ACK chunk
as small as possible to reduce the possibility of byte amplification
attacks.[¶](#section-12.4-4){.pilcrow}
:::
:::
:::
:::

::: {#sec_network_management}
::: {#section-13 .section}
## [13.](#section-13){.section-number .selfRef} [Network Management Considerations](#name-network-management-consider){.section-name .selfRef} {#name-network-management-consider}

The MIB module for SCTP defined in \[[RFC3873](#RFC3873){.xref}\]
applies for the version of the protocol specified in this
document.[¶](#section-13-1){.pilcrow}
:::
:::

::: {#sec_tcb_parameter}
::: {#section-14 .section}
## [14.](#section-14){.section-number .selfRef} [Recommended Transmission Control Block (TCB) Parameters](#name-recommended-transmission-co){.section-name .selfRef} {#name-recommended-transmission-co}

This section details a set of parameters that are expected to be
contained within the TCB for an implementation. This section is for
illustrative purposes and is not considered to be requirements on an
implementation or as an exhaustive list of all parameters inside an SCTP
TCB. Each implementation might need its own additional parameters for
optimization.[¶](#section-14-1){.pilcrow}

::: {#sec_parameters_necessary_for_the_sctp_instance}
::: {#section-14.1 .section}
### [14.1.](#section-14.1){.section-number .selfRef} [Parameters Necessary for the SCTP Instance](#name-parameters-necessary-for-th){.section-name .selfRef} {#name-parameters-necessary-for-th}

[]{.break}

Associations:
:   A list of current associations and mappings to the data consumers
    for each association. This might be in the form of a hash table or
    other implementation-dependent structure. The data consumers might
    be process identification information, such as file descriptors,
    named pipe pointer, or table pointers dependent on how SCTP is
    implemented.[¶](#section-14.1-1.2){.pilcrow}
:   

Secret Key:
:   A secret key used by this endpoint to compute the MAC. This
    [SHOULD]{.bcp14} be a cryptographic quality random number with a
    sufficient length. Discussion in \[[RFC4086](#RFC4086){.xref}\] can
    be helpful in selection of the key.[¶](#section-14.1-1.4){.pilcrow}
:   

Address List:
:   The list of IP addresses that this instance has bound. This
    information is passed to one\'s peer(s) in INIT and INIT ACK
    chunks.[¶](#section-14.1-1.6){.pilcrow}
:   

SCTP Port:
:   The local SCTP port number to which the endpoint is
    bound.[¶](#section-14.1-1.8){.pilcrow}
:   
:::
:::

::: {#sec_parameters_necessary_per_association}
::: {#section-14.2 .section}
### [14.2.](#section-14.2){.section-number .selfRef} [Parameters Necessary per Association (i.e., the TCB)](#name-parameters-necessary-per-as){.section-name .selfRef} {#name-parameters-necessary-per-as}

[]{.break}

Peer Verification Tag:
:   Tag value to be sent in every packet and is received in the INIT or
    INIT ACK chunk.[¶](#section-14.2-1.2){.pilcrow}
:   

My Verification Tag:
:   Tag expected in every inbound packet and sent in the INIT or INIT
    ACK chunk.[¶](#section-14.2-1.4){.pilcrow}
:   

State:

:   COOKIE-WAIT, COOKIE-ECHOED, ESTABLISHED, SHUTDOWN-PENDING,
    SHUTDOWN-SENT, SHUTDOWN-RECEIVED,
    SHUTDOWN-ACK-SENT.[¶](#section-14.2-1.6.1){.pilcrow}

    Note: No \"CLOSED\" state is illustrated, since, if an association
    is \"CLOSED\", its TCB [SHOULD]{.bcp14} be
    removed.[¶](#section-14.2-1.6.2){.pilcrow}

:   

Peer Transport Address List:
:   A list of SCTP transport addresses to which the peer is bound. This
    information is derived from the INIT or INIT ACK chunk and is used
    to associate an inbound packet with a given association. Normally,
    this information is hashed or keyed for quick lookup and access of
    the TCB.[¶](#section-14.2-1.8){.pilcrow}
:   

Primary Path:
:   This is the current primary destination transport address of the
    peer endpoint. It might also specify a source transport address on
    this endpoint.[¶](#section-14.2-1.10){.pilcrow}
:   

Overall Error Count:
:   The overall association error
    count.[¶](#section-14.2-1.12){.pilcrow}
:   

Overall Error Threshold:
:   The threshold for this association that, if the Overall Error Count
    reaches, will cause this association to be torn
    down.[¶](#section-14.2-1.14){.pilcrow}
:   

Peer Rwnd:
:   Current calculated value of the peer\'s
    rwnd.[¶](#section-14.2-1.16){.pilcrow}
:   

Next TSN:
:   The next TSN number to be assigned to a new DATA chunk. This is sent
    in the INIT or INIT ACK chunk to the peer and incremented each time
    a DATA chunk is assigned a TSN (normally, just prior to transmit or
    during fragmentation).[¶](#section-14.2-1.18){.pilcrow}
:   

Last Rcvd TSN:
:   This is the last TSN received in sequence. This value is set
    initially by taking the peer\'s Initial TSN, received in the INIT or
    INIT ACK chunk, and subtracting one from
    it.[¶](#section-14.2-1.20){.pilcrow}
:   

Mapping Array:
:   An array of bits or bytes indicating which out-of-order TSNs have
    been received (relative to the Last Rcvd TSN). If no gaps exist,
    i.e., no out-of-order packets have been received, this array will be
    set to all zero. This structure might be in the form of a circular
    buffer or bit array.[¶](#section-14.2-1.22){.pilcrow}
:   

Ack State:
:   This flag indicates if the next received packet is to be responded
    to with a SACK chunk. This is initialized to 0. When a packet is
    received, it is incremented. If this value reaches 2 or more, a SACK
    chunk is sent and the value is reset to 0. Note: This is used only
    when no DATA chunks are received out of order. When DATA chunks are
    out of order, SACK chunks are not delayed (see [Section
    6](#sec_user_data_transfer){.xref}).[¶](#section-14.2-1.24){.pilcrow}
:   

Inbound Streams:
:   An array of structures to track the inbound streams, normally
    including the next sequence number expected and possibly the stream
    number.[¶](#section-14.2-1.26){.pilcrow}
:   

Outbound Streams:
:   An array of structures to track the outbound streams, normally
    including the next sequence number to be sent on the
    stream.[¶](#section-14.2-1.28){.pilcrow}
:   

Reasm Queue:
:   A reassembly queue.[¶](#section-14.2-1.30){.pilcrow}
:   

Receive Buffer:
:   A buffer to store received user data that has not been delivered to
    the upper layer.[¶](#section-14.2-1.32){.pilcrow}
:   

Local Transport Address List:
:   The list of local IP addresses bound in to this
    association.[¶](#section-14.2-1.34){.pilcrow}
:   

Association Maximum DATA Chunk Size:
:   The smallest Path Maximum DATA Chunk Size of all destination
    addresses.[¶](#section-14.2-1.36){.pilcrow}
:   
:::
:::

::: {#sec_per_transport_address_data}
::: {#section-14.3 .section}
### [14.3.](#section-14.3){.section-number .selfRef} [Per Transport Address Data](#name-per-transport-address-data){.section-name .selfRef} {#name-per-transport-address-data}

For each destination transport address in the peer\'s address list
derived from the INIT or INIT ACK chunk, a number of data elements need
to be maintained, including:[¶](#section-14.3-1){.pilcrow}

[]{.break}

Error Count:
:   The current error count for this
    destination.[¶](#section-14.3-2.2){.pilcrow}
:   

Error Threshold:
:   Current error threshold for this destination, i.e., what value marks
    the destination down if error count reaches this
    value.[¶](#section-14.3-2.4){.pilcrow}
:   

cwnd:
:   The current congestion window.[¶](#section-14.3-2.6){.pilcrow}
:   

ssthresh:
:   The current ssthresh value.[¶](#section-14.3-2.8){.pilcrow}
:   

RTO:
:   The current retransmission timeout
    value.[¶](#section-14.3-2.10){.pilcrow}
:   

SRTT:
:   The current smoothed round-trip
    time.[¶](#section-14.3-2.12){.pilcrow}
:   

RTTVAR:
:   The current RTT variation.[¶](#section-14.3-2.14){.pilcrow}
:   

partial bytes acked:
:   The tracking method for increase of cwnd when in congestion
    avoidance mode (see [Section
    7.2.2](#sec_congestion_avoidance){.xref}).[¶](#section-14.3-2.16){.pilcrow}
:   

state:
:   The current state of this destination, i.e., DOWN, UP,
    ALLOW-HEARTBEAT, NO-HEARTBEAT, etc.[¶](#section-14.3-2.18){.pilcrow}
:   

PMTU:
:   The current known PMTU.[¶](#section-14.3-2.20){.pilcrow}
:   

PMDCS:
:   The current known PMDCS.[¶](#section-14.3-2.22){.pilcrow}
:   

Per Destination Timer:
:   A timer used by each destination.[¶](#section-14.3-2.24){.pilcrow}
:   

RTO-Pending:
:   A flag used to track if one of the DATA chunks sent to this address
    is currently being used to compute an RTT. If this flag is 0, the
    next DATA chunk sent to this destination is expected to be used to
    compute an RTT and this flag is expected to be set. Every time the
    RTT calculation completes (i.e., the DATA chunk is acknowledged),
    clear this flag.[¶](#section-14.3-2.26){.pilcrow}
:   

last-time:
:   The time to which this destination was last sent. This can be used
    to determine if the sending of a HEARTBEAT chunk is
    needed.[¶](#section-14.3-2.28){.pilcrow}
:   
:::
:::

::: {#sec_general_parameters_needed}
::: {#section-14.4 .section}
### [14.4.](#section-14.4){.section-number .selfRef} [General Parameters Needed](#name-general-parameters-needed){.section-name .selfRef} {#name-general-parameters-needed}

[]{.break}

Out Queue:
:   A queue of outbound DATA chunks.[¶](#section-14.4-1.2){.pilcrow}
:   

In Queue:
:   A queue of inbound DATA chunks.[¶](#section-14.4-1.4){.pilcrow}
:   
:::
:::
:::
:::

::: {#sec_iana}
::: {#section-15 .section}
## [15.](#section-15){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document defines five registries that IANA
maintains:[¶](#section-15-1){.pilcrow}

-   ::: {#section-15-2.1}
    through definition of additional chunk
    types,[¶](#section-15-2.1.1){.pilcrow}
    :::

-   ::: {#section-15-2.2}
    through definition of additional chunk
    flags,[¶](#section-15-2.2.1){.pilcrow}
    :::

-   ::: {#section-15-2.3}
    through definition of additional parameter
    types,[¶](#section-15-2.3.1){.pilcrow}
    :::

-   ::: {#section-15-2.4}
    through definition of additional cause codes within ERROR chunks,
    or[¶](#section-15-2.4.1){.pilcrow}
    :::

-   ::: {#section-15-2.5}
    through definition of additional payload protocol
    identifiers.[¶](#section-15-2.5.1){.pilcrow}
    :::

IANA has performed the following updates for the above five
registries:[¶](#section-15-3){.pilcrow}

-   ::: {#section-15-4.1}
    In the \"Chunk Types\" registry, IANA has replaced the registry
    reference to \[[RFC4960](#RFC4960){.xref}\] and
    \[[RFC6096](#RFC6096){.xref}\] with a reference to this
    document.[¶](#section-15-4.1.1){.pilcrow}

    In addition, in the Notes section, the reference to [Section
    3.2](https://www.rfc-editor.org/rfc/rfc6096#section-3.2){.relref} of
    \[[RFC6096](#RFC6096){.xref}\] has been updated with a reference to
    [Section 15.2](#sec_ietf_chunk_flags_registration){.xref} of this
    document.[¶](#section-15-4.1.2){.pilcrow}

    Finally, each reference to \[[RFC4960](#RFC4960){.xref}\] has been
    replaced with a reference to this document for the following chunk
    types:[¶](#section-15-4.1.3){.pilcrow}

    -   ::: {#section-15-4.1.4.1}
        Payload Data (DATA)[¶](#section-15-4.1.4.1.1){.pilcrow}
        :::

    -   ::: {#section-15-4.1.4.2}
        Initiation (INIT)[¶](#section-15-4.1.4.2.1){.pilcrow}
        :::

    -   ::: {#section-15-4.1.4.3}
        Initiation Acknowledgement (INIT
        ACK)[¶](#section-15-4.1.4.3.1){.pilcrow}
        :::

    -   ::: {#section-15-4.1.4.4}
        Selective Acknowledgement
        (SACK)[¶](#section-15-4.1.4.4.1){.pilcrow}
        :::

    -   ::: {#section-15-4.1.4.5}
        Heartbeat Request
        (HEARTBEAT)[¶](#section-15-4.1.4.5.1){.pilcrow}
        :::

    -   ::: {#section-15-4.1.4.6}
        Heartbeat Acknowledgement (HEARTBEAT
        ACK)[¶](#section-15-4.1.4.6.1){.pilcrow}
        :::

    -   ::: {#section-15-4.1.4.7}
        Abort (ABORT)[¶](#section-15-4.1.4.7.1){.pilcrow}
        :::

    -   ::: {#section-15-4.1.4.8}
        Shutdown (SHUTDOWN)[¶](#section-15-4.1.4.8.1){.pilcrow}
        :::

    -   ::: {#section-15-4.1.4.9}
        Shutdown Acknowledgement (SHUTDOWN
        ACK)[¶](#section-15-4.1.4.9.1){.pilcrow}
        :::

    -   ::: {#section-15-4.1.4.10}
        Operation Error (ERROR)[¶](#section-15-4.1.4.10.1){.pilcrow}
        :::

    -   ::: {#section-15-4.1.4.11}
        State Cookie (COOKIE ECHO)[¶](#section-15-4.1.4.11.1){.pilcrow}
        :::

    -   ::: {#section-15-4.1.4.12}
        Cookie Acknowledgement (COOKIE
        ACK)[¶](#section-15-4.1.4.12.1){.pilcrow}
        :::

    -   ::: {#section-15-4.1.4.13}
        Reserved for Explicit Congestion Notification Echo
        (ECNE)[¶](#section-15-4.1.4.13.1){.pilcrow}
        :::

    -   ::: {#section-15-4.1.4.14}
        Reserved for Congestion Window Reduced
        (CWR)[¶](#section-15-4.1.4.14.1){.pilcrow}
        :::

    -   ::: {#section-15-4.1.4.15}
        Shutdown Complete (SHUTDOWN
        COMPLETE)[¶](#section-15-4.1.4.15.1){.pilcrow}
        :::

    -   ::: {#section-15-4.1.4.16}
        Reserved for IETF-defined Chunk
        Extensions[¶](#section-15-4.1.4.16.1){.pilcrow}
        :::
    :::

-   ::: {#section-15-4.2}
    In the \"Chunk Parameter Types\" registry, IANA has replaced the
    registry reference to \[[RFC4960](#RFC4960){.xref}\] with a
    reference to this document.[¶](#section-15-4.2.1){.pilcrow}

    IANA has changed the name of the \"Unrecognized Parameters\" chunk
    parameter type to \"Unrecognized Parameter\" in the \"Chunk
    Parameter Types\" registry.[¶](#section-15-4.2.2){.pilcrow}

    In addition, each reference to \[[RFC4960](#RFC4960){.xref}\] has
    been replaced with a reference to this document for the following
    chunk parameter types:[¶](#section-15-4.2.3){.pilcrow}

    -   ::: {#section-15-4.2.4.1}
        Heartbeat Info[¶](#section-15-4.2.4.1.1){.pilcrow}
        :::

    -   ::: {#section-15-4.2.4.2}
        IPv4 Address[¶](#section-15-4.2.4.2.1){.pilcrow}
        :::

    -   ::: {#section-15-4.2.4.3}
        IPv6 Address[¶](#section-15-4.2.4.3.1){.pilcrow}
        :::

    -   ::: {#section-15-4.2.4.4}
        State Cookie[¶](#section-15-4.2.4.4.1){.pilcrow}
        :::

    -   ::: {#section-15-4.2.4.5}
        Unrecognized Parameter[¶](#section-15-4.2.4.5.1){.pilcrow}
        :::

    -   ::: {#section-15-4.2.4.6}
        Cookie Preservative[¶](#section-15-4.2.4.6.1){.pilcrow}
        :::

    -   ::: {#section-15-4.2.4.7}
        Host Name Address[¶](#section-15-4.2.4.7.1){.pilcrow}
        :::

    -   ::: {#section-15-4.2.4.8}
        Supported Address Types[¶](#section-15-4.2.4.8.1){.pilcrow}
        :::

    IANA has added a reference to this document for the following chunk
    parameter type:[¶](#section-15-4.2.5){.pilcrow}

    -   ::: {#section-15-4.2.6.1}
        Reserved for ECN Capable
        (0x8000)[¶](#section-15-4.2.6.1.1){.pilcrow}
        :::

    Also, IANA has added the value 65535 to be reserved for IETF-defined
    extensions.[¶](#section-15-4.2.7){.pilcrow}
    :::

-   ::: {#section-15-4.3}
    In the \"Chunk Flags\" registry, IANA replaced the registry
    reference to \[[RFC6096](#RFC6096){.xref}\] with a reference to this
    document.[¶](#section-15-4.3.1){.pilcrow}

    In addition, each reference to \[[RFC4960](#RFC4960){.xref}\] has
    been replaced with a reference to this document for the following
    DATA chunk flags:[¶](#section-15-4.3.2){.pilcrow}

    -   ::: {#section-15-4.3.3.1}
        E bit[¶](#section-15-4.3.3.1.1){.pilcrow}
        :::

    -   ::: {#section-15-4.3.3.2}
        B bit[¶](#section-15-4.3.3.2.1){.pilcrow}
        :::

    -   ::: {#section-15-4.3.3.3}
        U bit[¶](#section-15-4.3.3.3.1){.pilcrow}
        :::

    IANA has also replaced the reference to
    \[[RFC7053](#RFC7053){.xref}\] with a reference to this document for
    the following DATA chunk flag:[¶](#section-15-4.3.4){.pilcrow}

    -   ::: {#section-15-4.3.5.1}
        I bit[¶](#section-15-4.3.5.1.1){.pilcrow}
        :::

    IANA has replaced the reference to \[[RFC4960](#RFC4960){.xref}\]
    with a reference to this document for the following ABORT chunk
    flag:[¶](#section-15-4.3.6){.pilcrow}

    -   ::: {#section-15-4.3.7.1}
        T bit[¶](#section-15-4.3.7.1.1){.pilcrow}
        :::

    IANA has replaced the reference to \[[RFC4960](#RFC4960){.xref}\]
    with a reference to this document for the following SHUTDOWN
    COMPLETE chunk flag:[¶](#section-15-4.3.8){.pilcrow}

    -   ::: {#section-15-4.3.9.1}
        T bit[¶](#section-15-4.3.9.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-15-4.4}
    In the \"Error Cause Codes\" registry, IANA has replaced the
    registry reference to \[[RFC4960](#RFC4960){.xref}\] with a
    reference to this document.[¶](#section-15-4.4.1){.pilcrow}

    IANA has changed the name of the \"User Initiated Abort\" error
    cause to \"User-Initiated Abort\" and the name of the \"Stale Cookie
    Error\" error cause to \"Stale Cookie\" in the \"Error Cause Codes\"
    registry.[¶](#section-15-4.4.2){.pilcrow}

    In addition, each reference to \[[RFC4960](#RFC4960){.xref}\] has
    been replaced with a reference to this document for the following
    cause codes:[¶](#section-15-4.4.3){.pilcrow}

    -   ::: {#section-15-4.4.4.1}
        Invalid Stream Identifier[¶](#section-15-4.4.4.1.1){.pilcrow}
        :::

    -   ::: {#section-15-4.4.4.2}
        Missing Mandatory Parameter[¶](#section-15-4.4.4.2.1){.pilcrow}
        :::

    -   ::: {#section-15-4.4.4.3}
        Stale Cookie[¶](#section-15-4.4.4.3.1){.pilcrow}
        :::

    -   ::: {#section-15-4.4.4.4}
        Out of Resource[¶](#section-15-4.4.4.4.1){.pilcrow}
        :::

    -   ::: {#section-15-4.4.4.5}
        Unresolvable Address[¶](#section-15-4.4.4.5.1){.pilcrow}
        :::

    -   ::: {#section-15-4.4.4.6}
        Unrecognized Chunk Type[¶](#section-15-4.4.4.6.1){.pilcrow}
        :::

    -   ::: {#section-15-4.4.4.7}
        Invalid Mandatory Parameter[¶](#section-15-4.4.4.7.1){.pilcrow}
        :::

    -   ::: {#section-15-4.4.4.8}
        Unrecognized Parameters[¶](#section-15-4.4.4.8.1){.pilcrow}
        :::

    -   ::: {#section-15-4.4.4.9}
        No User Data[¶](#section-15-4.4.4.9.1){.pilcrow}
        :::

    -   ::: {#section-15-4.4.4.10}
        Cookie Received While Shutting
        Down[¶](#section-15-4.4.4.10.1){.pilcrow}
        :::

    -   ::: {#section-15-4.4.4.11}
        Restart of an Association with New
        Addresses[¶](#section-15-4.4.4.11.1){.pilcrow}
        :::

    IANA has also replaced each reference to
    \[[RFC4460](#RFC4460){.xref}\] with a reference to this document for
    the following cause codes:[¶](#section-15-4.4.5){.pilcrow}

    -   ::: {#section-15-4.4.6.1}
        User-Initiated Abort[¶](#section-15-4.4.6.1.1){.pilcrow}
        :::

    -   ::: {#section-15-4.4.6.2}
        Protocol Violation[¶](#section-15-4.4.6.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-15-4.5}
    In the \"SCTP Payload Protocol Identifiers\" registry, IANA has
    replaced the registry reference to \[[RFC4960](#RFC4960){.xref}\]
    with a reference to this document.[¶](#section-15-4.5.1){.pilcrow}

    IANA has replaced the reference to \[[RFC4960](#RFC4960){.xref}\]
    with a reference to this document for the following SCTP payload
    protocol identifier:[¶](#section-15-4.5.2){.pilcrow}

    -   ::: {#section-15-4.5.3.1}
        Reserved by SCTP[¶](#section-15-4.5.3.1.1){.pilcrow}
        :::
    :::

SCTP requires that the IANA \"Port Numbers\" registry be opened for SCTP
port registrations; [Section 15.6](#sec_port_number_registry){.xref}
describes how. An IESG-appointed Expert Reviewer supports IANA in
evaluating SCTP port allocation requests.[¶](#section-15-5){.pilcrow}

In the \"Service Name and Transport Protocol Port Number Registry\",
IANA has replaced each reference to \[[RFC4960](#RFC4960){.xref}\] with
a reference to this document for the following SCTP port
numbers:[¶](#section-15-6){.pilcrow}

-   ::: {#section-15-7.1}
    9 (discard)[¶](#section-15-7.1.1){.pilcrow}
    :::

-   ::: {#section-15-7.2}
    20 (ftp-data)[¶](#section-15-7.2.1){.pilcrow}
    :::

-   ::: {#section-15-7.3}
    21 (ftp)[¶](#section-15-7.3.1){.pilcrow}
    :::

-   ::: {#section-15-7.4}
    22 (ssh)[¶](#section-15-7.4.1){.pilcrow}
    :::

-   ::: {#section-15-7.5}
    80 (http)[¶](#section-15-7.5.1){.pilcrow}
    :::

-   ::: {#section-15-7.6}
    179 (bgp)[¶](#section-15-7.6.1){.pilcrow}
    :::

-   ::: {#section-15-7.7}
    443 (https)[¶](#section-15-7.7.1){.pilcrow}
    :::

Furthermore, in the \"Hypertext Transfer Protocol (HTTP) Digest
Algorithm Values\" registry, IANA has replaced the reference to
[Appendix B](https://www.rfc-editor.org/rfc/rfc4960#appendix-B){.relref}
of \[[RFC4960](#RFC4960){.xref}\] with a reference to [Appendix
A](#sec_crc32c){.xref} of this document.[¶](#section-15-8){.pilcrow}

In addition, in the \"ONC RPC Netids (Standards Action)\" registry, IANA
has replaced each reference to \[[RFC4960](#RFC4960){.xref}\] with a
reference to this document for the following
netids:[¶](#section-15-9){.pilcrow}

-   ::: {#section-15-10.1}
    sctp[¶](#section-15-10.1.1){.pilcrow}
    :::

-   ::: {#section-15-10.2}
    sctp6[¶](#section-15-10.2.1){.pilcrow}
    :::

In the \"IPFIX Information Elements\" registry, IANA has replaced each
reference to \[[RFC4960](#RFC4960){.xref}\] with a reference to this
document for the following elements with the
name:[¶](#section-15-11){.pilcrow}

-   ::: {#section-15-12.1}
    sourceTransportPort[¶](#section-15-12.1.1){.pilcrow}
    :::

-   ::: {#section-15-12.2}
    destinationTransportPort[¶](#section-15-12.2.1){.pilcrow}
    :::

-   ::: {#section-15-12.3}
    collectorTransportPort[¶](#section-15-12.3.1){.pilcrow}
    :::

-   ::: {#section-15-12.4}
    exporterTransportPort[¶](#section-15-12.4.1){.pilcrow}
    :::

-   ::: {#section-15-12.5}
    postNAPTSourceTransportPort[¶](#section-15-12.5.1){.pilcrow}
    :::

-   ::: {#section-15-12.6}
    postNAPTDestinationTransportPort[¶](#section-15-12.6.1){.pilcrow}
    :::

::: {#sec_ietf_defined_chunks_extension}
::: {#section-15.1 .section}
### [15.1.](#section-15.1){.section-number .selfRef} [IETF-Defined Chunk Extension](#name-ietf-defined-chunk-extensio){.section-name .selfRef} {#name-ietf-defined-chunk-extensio}

The assignment of new chunk type codes is done through an IETF Review
action, as defined in \[[RFC8126](#RFC8126){.xref}\]. Documentation for
a new chunk [MUST]{.bcp14} contain the following
information:[¶](#section-15.1-1){.pilcrow}

[]{.break}

a\)

:   A long and short name for the new chunk
    type.[¶](#section-15.1-2.1.1){.pilcrow}

:   

b\)

:   A detailed description of the structure of the chunk, which
    [MUST]{.bcp14} conform to the basic structure defined in [Section
    3.2](#sec_chunk_field_descriptions){.xref}.[¶](#section-15.1-2.2.1){.pilcrow}

:   

c\)

:   A detailed definition and description of intended use of each field
    within the chunk, including the chunk flags if any. Defined chunk
    flags will be used as initial entries in the chunk flags table for
    the new chunk type.[¶](#section-15.1-2.3.1){.pilcrow}

:   

d\)

:   A detailed procedural description of the use of the new chunk type
    within the operation of the
    protocol.[¶](#section-15.1-2.4.1){.pilcrow}

:   

The last chunk type (255) is reserved for future extension if
necessary.[¶](#section-15.1-3){.pilcrow}

For each new chunk type, IANA creates a registration table for the chunk
flags of that type. The procedure for registering particular chunk flags
is described in [Section
15.2](#sec_ietf_chunk_flags_registration){.xref}.[¶](#section-15.1-4){.pilcrow}
:::
:::

::: {#sec_ietf_chunk_flags_registration}
::: {#section-15.2 .section}
### [15.2.](#section-15.2){.section-number .selfRef} [IETF-Defined Chunk Flags Registration](#name-ietf-defined-chunk-flags-re){.section-name .selfRef} {#name-ietf-defined-chunk-flags-re}

The assignment of new chunk flags is done through an RFC Required
action, as defined in \[[RFC8126](#RFC8126){.xref}\]. Documentation for
the chunk flags [MUST]{.bcp14} contain the following
information:[¶](#section-15.2-1){.pilcrow}

[]{.break}

a\)

:   A name for the new chunk flag.[¶](#section-15.2-2.1.1){.pilcrow}

:   

b\)

:   A detailed procedural description of the use of the new chunk flag
    within the operation of the protocol. It [MUST]{.bcp14} be
    considered that implementations not supporting the flag will send 0
    on transmit and just ignore it on
    receipt.[¶](#section-15.2-2.2.1){.pilcrow}

:   

IANA selects a chunk flags value. This [MUST]{.bcp14} be one of 0x01,
0x02, 0x04, 0x08, 0x10, 0x20, 0x40, or 0x80, which [MUST]{.bcp14} be
unique within the chunk flag values for the specific chunk
type.[¶](#section-15.2-3){.pilcrow}
:::
:::

::: {#sec_ietf_defined_chunk_parameter_extension}
::: {#section-15.3 .section}
### [15.3.](#section-15.3){.section-number .selfRef} [IETF-Defined Chunk Parameter Extension](#name-ietf-defined-chunk-paramete){.section-name .selfRef} {#name-ietf-defined-chunk-paramete}

The assignment of new chunk parameter type codes is done through an IETF
Review action, as defined in \[[RFC8126](#RFC8126){.xref}\].
Documentation of the chunk parameter [MUST]{.bcp14} contain the
following information:[¶](#section-15.3-1){.pilcrow}

[]{.break}

a\)

:   Name of the parameter type.[¶](#section-15.3-2.1.1){.pilcrow}

:   

b\)

:   Detailed description of the structure of the parameter field. This
    structure [MUST]{.bcp14} conform to the general Type-Length-Value
    format described in [Section
    3.2.1](#sec_parameter_format){.xref}.[¶](#section-15.3-2.2.1){.pilcrow}

:   

c\)

:   Detailed definition of each component of the parameter
    value.[¶](#section-15.3-2.3.1){.pilcrow}

:   

d\)

:   Detailed description of the intended use of this parameter type and
    an indication of whether and under what circumstances multiple
    instances of this parameter type can be found within the same
    chunk.[¶](#section-15.3-2.4.1){.pilcrow}

:   

e\)

:   Each parameter type [MUST]{.bcp14} be unique across all
    chunks.[¶](#section-15.3-2.5.1){.pilcrow}

:   
:::
:::

::: {#sec_ietf_defined_additional_error_causes}
::: {#section-15.4 .section}
### [15.4.](#section-15.4){.section-number .selfRef} [IETF-Defined Additional Error Causes](#name-ietf-defined-additional-err){.section-name .selfRef} {#name-ietf-defined-additional-err}

Additional cause codes can be allocated through a Specification Required
action as defined in \[[RFC8126](#RFC8126){.xref}\]. Provided
documentation [MUST]{.bcp14} include the following
information:[¶](#section-15.4-1){.pilcrow}

[]{.break}

a\)

:   Name of the error condition.[¶](#section-15.4-2.1.1){.pilcrow}

:   

b\)

:   Detailed description of the conditions under which an SCTP endpoint
    issues an ERROR (or ABORT) chunk with this cause
    code.[¶](#section-15.4-2.2.1){.pilcrow}

:   

c\)

:   Expected action by the SCTP endpoint that receives an ERROR (or
    ABORT) chunk containing this cause
    code.[¶](#section-15.4-2.3.1){.pilcrow}

:   

d\)

:   Detailed description of the structure and content of data fields
    that accompany this cause code.[¶](#section-15.4-2.4.1){.pilcrow}

:   

The initial word (32 bits) of a cause code parameter [MUST]{.bcp14}
conform to the format shown in [Section
3.3.10](#sec_error_chunk){.xref}, that is:[¶](#section-15.4-3){.pilcrow}

-   ::: {#section-15.4-4.1}
    first 2 bytes contain the cause code
    value[¶](#section-15.4-4.1.1){.pilcrow}
    :::

-   ::: {#section-15.4-4.2}
    last 2 bytes contain the length of the error
    cause.[¶](#section-15.4-4.2.1){.pilcrow}
    :::
:::
:::

::: {#sec_payload_prototol_identifiers}
::: {#section-15.5 .section}
### [15.5.](#section-15.5){.section-number .selfRef} [Payload Protocol Identifiers](#name-payload-protocol-identifier){.section-name .selfRef} {#name-payload-protocol-identifier}

The assignment of payload protocol identifiers is done using the First
Come First Served policy, as defined in
\[[RFC8126](#RFC8126){.xref}\].[¶](#section-15.5-1){.pilcrow}

Except for value 0, which is reserved to indicate an unspecified payload
protocol identifier in a DATA chunk, an SCTP implementation will not be
responsible for standardizing or verifying any payload protocol
identifiers. An SCTP implementation simply receives the identifier from
the upper layer and carries it with the corresponding payload
data.[¶](#section-15.5-2){.pilcrow}

The upper layer, i.e., the SCTP user, [SHOULD]{.bcp14} standardize any
specific protocol identifier with IANA if it is so desired. The use of
any specific payload protocol identifier is out of the scope of this
specification.[¶](#section-15.5-3){.pilcrow}
:::
:::

::: {#sec_port_number_registry}
::: {#section-15.6 .section}
### [15.6.](#section-15.6){.section-number .selfRef} [Port Numbers Registry](#name-port-numbers-registry){.section-name .selfRef} {#name-port-numbers-registry}

SCTP services can use contact port numbers to provide service to unknown
callers, as in TCP and UDP. An IESG-appointed Expert Reviewer supports
IANA in evaluating SCTP port allocation requests, according to the
procedure defined in \[[RFC8126](#RFC8126){.xref}\]. The details of this
process are defined in
\[[RFC6335](#RFC6335){.xref}\].[¶](#section-15.6-1){.pilcrow}
:::
:::
:::
:::

::: {#sec_parameter_values}
::: {#section-16 .section}
## [16.](#section-16){.section-number .selfRef} [Suggested SCTP Protocol Parameter Values](#name-suggested-sctp-protocol-par){.section-name .selfRef} {#name-suggested-sctp-protocol-par}

The following protocol parameters are
[RECOMMENDED]{.bcp14}:[¶](#section-16-1){.pilcrow}

[]{.break}

RTO.Initial:

:   1 second[¶](#section-16-2.2.1){.pilcrow}

:   

RTO.Min:

:   1 second[¶](#section-16-2.4.1){.pilcrow}

:   

RTO.Max:

:   60 seconds[¶](#section-16-2.6.1){.pilcrow}

:   

Max.Burst:

:   4[¶](#section-16-2.8.1){.pilcrow}

:   

RTO.Alpha:

:   1/8[¶](#section-16-2.10.1){.pilcrow}

:   

RTO.Beta:

:   1/4[¶](#section-16-2.12.1){.pilcrow}

:   

Valid.Cookie.Life:

:   60 seconds[¶](#section-16-2.14.1){.pilcrow}

:   

Association.Max.Retrans:

:   10 attempts[¶](#section-16-2.16.1){.pilcrow}

:   

Path.Max.Retrans:

:   5 attempts (per destination
    address)[¶](#section-16-2.18.1){.pilcrow}

:   

Max.Init.Retransmits:

:   8 attempts[¶](#section-16-2.20.1){.pilcrow}

:   

HB.interval:

:   30 seconds[¶](#section-16-2.22.1){.pilcrow}

:   

HB.Max.Burst:

:   1[¶](#section-16-2.24.1){.pilcrow}

:   

SACK.Delay:

:   200 milliseconds[¶](#section-16-2.26.1){.pilcrow}

:   

Implementation Note: The SCTP implementation can allow ULP to customize
some of these protocol parameters (see [Section
11](#sec_api){.xref}).[¶](#section-16-3){.pilcrow}

\'RTO.Min\' [SHOULD]{.bcp14} be set as described above in this
section.[¶](#section-16-4){.pilcrow}
:::
:::

::: {#section-17 .section}
## [17.](#section-17){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-17.1 .section}
### [17.1.](#section-17.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[ITU.V42.1994\]
:   [International Telecommunications Union]{.refAuthor},
    [\"Error-correcting Procedures for DCEs Using
    Asynchronous-to-Synchronous Conversion\"]{.refTitle}, [ITU-T
    Recommendation V.42]{.seriesInfo}, 1994.
:   

\[RFC1122\]
:   [Braden, R., Ed.]{.refAuthor}, [\"Requirements for Internet Hosts -
    Communication Layers\"]{.refTitle}, [STD 3]{.seriesInfo}, [RFC
    1122]{.seriesInfo}, [DOI 10.17487/RFC1122]{.seriesInfo}, October
    1989, \<<https://www.rfc-editor.org/info/rfc1122>\>.
:   

\[RFC1123\]
:   [Braden, R., Ed.]{.refAuthor}, [\"Requirements for Internet Hosts -
    Application and Support\"]{.refTitle}, [STD 3]{.seriesInfo}, [RFC
    1123]{.seriesInfo}, [DOI 10.17487/RFC1123]{.seriesInfo}, October
    1989, \<<https://www.rfc-editor.org/info/rfc1123>\>.
:   

\[RFC1191\]
:   [Mogul, J.]{.refAuthor} and [S. Deering]{.refAuthor}, [\"Path MTU
    discovery\"]{.refTitle}, [RFC 1191]{.seriesInfo}, [DOI
    10.17487/RFC1191]{.seriesInfo}, November 1990,
    \<<https://www.rfc-editor.org/info/rfc1191>\>.
:   

\[RFC1982\]
:   [Elz, R.]{.refAuthor} and [R. Bush]{.refAuthor}, [\"Serial Number
    Arithmetic\"]{.refTitle}, [RFC 1982]{.seriesInfo}, [DOI
    10.17487/RFC1982]{.seriesInfo}, August 1996,
    \<<https://www.rfc-editor.org/info/rfc1982>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC4291\]
:   [Hinden, R.]{.refAuthor} and [S. Deering]{.refAuthor}, [\"IP Version
    6 Addressing Architecture\"]{.refTitle}, [RFC 4291]{.seriesInfo},
    [DOI 10.17487/RFC4291]{.seriesInfo}, February 2006,
    \<<https://www.rfc-editor.org/info/rfc4291>\>.
:   

\[RFC4303\]
:   [Kent, S.]{.refAuthor}, [\"IP Encapsulating Security Payload
    (ESP)\"]{.refTitle}, [RFC 4303]{.seriesInfo}, [DOI
    10.17487/RFC4303]{.seriesInfo}, December 2005,
    \<<https://www.rfc-editor.org/info/rfc4303>\>.
:   

\[RFC4895\]
:   [Tuexen, M.]{.refAuthor}, [Stewart, R.]{.refAuthor},
    [Lei, P.]{.refAuthor}, and [E. Rescorla]{.refAuthor},
    [\"Authenticated Chunks for the Stream Control Transmission Protocol
    (SCTP)\"]{.refTitle}, [RFC 4895]{.seriesInfo}, [DOI
    10.17487/RFC4895]{.seriesInfo}, August 2007,
    \<<https://www.rfc-editor.org/info/rfc4895>\>.
:   

\[RFC5681\]
:   [Allman, M.]{.refAuthor}, [Paxson, V.]{.refAuthor}, and [E.
    Blanton]{.refAuthor}, [\"TCP Congestion Control\"]{.refTitle}, [RFC
    5681]{.seriesInfo}, [DOI 10.17487/RFC5681]{.seriesInfo}, September
    2009, \<<https://www.rfc-editor.org/info/rfc5681>\>.
:   

\[RFC6335\]
:   [Cotton, M.]{.refAuthor}, [Eggert, L.]{.refAuthor},
    [Touch, J.]{.refAuthor}, [Westerlund, M.]{.refAuthor}, and [S.
    Cheshire]{.refAuthor}, [\"Internet Assigned Numbers Authority (IANA)
    Procedures for the Management of the Service Name and Transport
    Protocol Port Number Registry\"]{.refTitle}, [BCP 165]{.seriesInfo},
    [RFC 6335]{.seriesInfo}, [DOI 10.17487/RFC6335]{.seriesInfo}, August
    2011, \<<https://www.rfc-editor.org/info/rfc6335>\>.
:   

\[RFC6083\]
:   [Tuexen, M.]{.refAuthor}, [Seggelmann, R.]{.refAuthor}, and [E.
    Rescorla]{.refAuthor}, [\"Datagram Transport Layer Security (DTLS)
    for Stream Control Transmission Protocol (SCTP)\"]{.refTitle}, [RFC
    6083]{.seriesInfo}, [DOI 10.17487/RFC6083]{.seriesInfo}, January
    2011, \<<https://www.rfc-editor.org/info/rfc6083>\>.
:   

\[RFC7296\]
:   [Kaufman, C.]{.refAuthor}, [Hoffman, P.]{.refAuthor},
    [Nir, Y.]{.refAuthor}, [Eronen, P.]{.refAuthor}, and [T.
    Kivinen]{.refAuthor}, [\"Internet Key Exchange Protocol Version 2
    (IKEv2)\"]{.refTitle}, [STD 79]{.seriesInfo}, [RFC
    7296]{.seriesInfo}, [DOI 10.17487/RFC7296]{.seriesInfo}, October
    2014, \<<https://www.rfc-editor.org/info/rfc7296>\>.
:   

\[RFC8126\]
:   [Cotton, M.]{.refAuthor}, [Leiba, B.]{.refAuthor}, and [T.
    Narten]{.refAuthor}, [\"Guidelines for Writing an IANA
    Considerations Section in RFCs\"]{.refTitle}, [BCP 26]{.seriesInfo},
    [RFC 8126]{.seriesInfo}, [DOI 10.17487/RFC8126]{.seriesInfo}, June
    2017, \<<https://www.rfc-editor.org/info/rfc8126>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8200\]
:   [Deering, S.]{.refAuthor} and [R. Hinden]{.refAuthor}, [\"Internet
    Protocol, Version 6 (IPv6) Specification\"]{.refTitle}, [STD
    86]{.seriesInfo}, [RFC 8200]{.seriesInfo}, [DOI
    10.17487/RFC8200]{.seriesInfo}, July 2017,
    \<<https://www.rfc-editor.org/info/rfc8200>\>.
:   

\[RFC8201\]
:   [McCann, J.]{.refAuthor}, [Deering, S.]{.refAuthor},
    [Mogul, J.]{.refAuthor}, and [R. Hinden, Ed.]{.refAuthor}, [\"Path
    MTU Discovery for IP version 6\"]{.refTitle}, [STD 87]{.seriesInfo},
    [RFC 8201]{.seriesInfo}, [DOI 10.17487/RFC8201]{.seriesInfo}, July
    2017, \<<https://www.rfc-editor.org/info/rfc8201>\>.
:   

\[RFC8899\]
:   [Fairhurst, G.]{.refAuthor}, [Jones, T.]{.refAuthor},
    [Tüxen, M.]{.refAuthor}, [Rüngeler, I.]{.refAuthor}, and [T.
    Völker]{.refAuthor}, [\"Packetization Layer Path MTU Discovery for
    Datagram Transports\"]{.refTitle}, [RFC 8899]{.seriesInfo}, [DOI
    10.17487/RFC8899]{.seriesInfo}, September 2020,
    \<<https://www.rfc-editor.org/info/rfc8899>\>.
:   
:::

::: {#section-17.2 .section}
### [17.2.](#section-17.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[FALL96\]
:   [Fall, K.]{.refAuthor} and [S. Floyd]{.refAuthor},
    [\"Simulation-based Comparisons of Tahoe, Reno, and SACK
    TCP\"]{.refTitle}, [SIGCOM 99, V. 26, N. 3, pp 5-21]{.refContent},
    July 1996.
:   

\[SAVAGE99\]
:   [Savage, S.]{.refAuthor}, [Cardwell, N.]{.refAuthor},
    [Wetherall, D.]{.refAuthor}, and [T. Anderson]{.refAuthor}, [\"TCP
    Congestion Control with a Misbehaving Receiver\"]{.refTitle}, [ACM
    Computer Communications Review 29(5)]{.refContent}, October 1999.
:   

\[ALLMAN99\]
:   [Allman, M.]{.refAuthor} and [V. Paxson]{.refAuthor}, [\"On
    Estimating End-to-End Network Path Properties\"]{.refTitle}, [SIGCOM
    99]{.refContent}, October 1999.
:   

\[WILLIAMS93\]
:   [Williams, R.]{.refAuthor}, [\"A PAINLESS GUIDE TO CRC ERROR
    DETECTION ALGORITHMS\"]{.refTitle}, [SIGCOM 99]{.refContent}, August
    1993, \<<https://archive.org/stream/PainlessCRC/crc_v3.txt>\>.
:   

\[RFC0768\]
:   [Postel, J.]{.refAuthor}, [\"User Datagram Protocol\"]{.refTitle},
    [STD 6]{.seriesInfo}, [RFC 768]{.seriesInfo}, [DOI
    10.17487/RFC0768]{.seriesInfo}, August 1980,
    \<<https://www.rfc-editor.org/info/rfc768>\>.
:   

\[RFC0793\]
:   [Postel, J.]{.refAuthor}, [\"Transmission Control
    Protocol\"]{.refTitle}, [STD 7]{.seriesInfo}, [RFC
    793]{.seriesInfo}, [DOI 10.17487/RFC0793]{.seriesInfo}, September
    1981, \<<https://www.rfc-editor.org/info/rfc793>\>.
:   

\[RFC1858\]
:   [Ziemba, G.]{.refAuthor}, [Reed, D.]{.refAuthor}, and [P.
    Traina]{.refAuthor}, [\"Security Considerations for IP Fragment
    Filtering\"]{.refTitle}, [RFC 1858]{.seriesInfo}, [DOI
    10.17487/RFC1858]{.seriesInfo}, October 1995,
    \<<https://www.rfc-editor.org/info/rfc1858>\>.
:   

\[RFC2104\]
:   [Krawczyk, H.]{.refAuthor}, [Bellare, M.]{.refAuthor}, and [R.
    Canetti]{.refAuthor}, [\"HMAC: Keyed-Hashing for Message
    Authentication\"]{.refTitle}, [RFC 2104]{.seriesInfo}, [DOI
    10.17487/RFC2104]{.seriesInfo}, February 1997,
    \<<https://www.rfc-editor.org/info/rfc2104>\>.
:   

\[RFC2196\]
:   [Fraser, B.]{.refAuthor}, [\"Site Security Handbook\"]{.refTitle},
    [FYI 8]{.seriesInfo}, [RFC 2196]{.seriesInfo}, [DOI
    10.17487/RFC2196]{.seriesInfo}, September 1997,
    \<<https://www.rfc-editor.org/info/rfc2196>\>.
:   

\[RFC2522\]
:   [Karn, P.]{.refAuthor} and [W. Simpson]{.refAuthor}, [\"Photuris:
    Session-Key Management Protocol\"]{.refTitle}, [RFC
    2522]{.seriesInfo}, [DOI 10.17487/RFC2522]{.seriesInfo}, March 1999,
    \<<https://www.rfc-editor.org/info/rfc2522>\>.
:   

\[RFC2960\]
:   [Stewart, R.]{.refAuthor}, [Xie, Q.]{.refAuthor},
    [Morneault, K.]{.refAuthor}, [Sharp, C.]{.refAuthor},
    [Schwarzbauer, H.]{.refAuthor}, [Taylor, T.]{.refAuthor},
    [Rytina, I.]{.refAuthor}, [Kalla, M.]{.refAuthor},
    [Zhang, L.]{.refAuthor}, and [V. Paxson]{.refAuthor}, [\"Stream
    Control Transmission Protocol\"]{.refTitle}, [RFC
    2960]{.seriesInfo}, [DOI 10.17487/RFC2960]{.seriesInfo}, October
    2000, \<<https://www.rfc-editor.org/info/rfc2960>\>.
:   

\[RFC3465\]
:   [Allman, M.]{.refAuthor}, [\"TCP Congestion Control with Appropriate
    Byte Counting (ABC)\"]{.refTitle}, [RFC 3465]{.seriesInfo}, [DOI
    10.17487/RFC3465]{.seriesInfo}, February 2003,
    \<<https://www.rfc-editor.org/info/rfc3465>\>.
:   

\[RFC3873\]
:   [Pastor, J.]{.refAuthor} and [M. Belinchon]{.refAuthor}, [\"Stream
    Control Transmission Protocol (SCTP) Management Information Base
    (MIB)\"]{.refTitle}, [RFC 3873]{.seriesInfo}, [DOI
    10.17487/RFC3873]{.seriesInfo}, September 2004,
    \<<https://www.rfc-editor.org/info/rfc3873>\>.
:   

\[RFC4086\]
:   [Eastlake 3rd, D.]{.refAuthor}, [Schiller, J.]{.refAuthor}, and [S.
    Crocker]{.refAuthor}, [\"Randomness Requirements for
    Security\"]{.refTitle}, [BCP 106]{.seriesInfo}, [RFC
    4086]{.seriesInfo}, [DOI 10.17487/RFC4086]{.seriesInfo}, June 2005,
    \<<https://www.rfc-editor.org/info/rfc4086>\>.
:   

\[RFC4301\]
:   [Kent, S.]{.refAuthor} and [K. Seo]{.refAuthor}, [\"Security
    Architecture for the Internet Protocol\"]{.refTitle}, [RFC
    4301]{.seriesInfo}, [DOI 10.17487/RFC4301]{.seriesInfo}, December
    2005, \<<https://www.rfc-editor.org/info/rfc4301>\>.
:   

\[RFC4460\]
:   [Stewart, R.]{.refAuthor}, [Arias-Rodriguez, I.]{.refAuthor},
    [Poon, K.]{.refAuthor}, [Caro, A.]{.refAuthor}, and [M.
    Tuexen]{.refAuthor}, [\"Stream Control Transmission Protocol (SCTP)
    Specification Errata and Issues\"]{.refTitle}, [RFC
    4460]{.seriesInfo}, [DOI 10.17487/RFC4460]{.seriesInfo}, April 2006,
    \<<https://www.rfc-editor.org/info/rfc4460>\>.
:   

\[RFC4960\]
:   [Stewart, R., Ed.]{.refAuthor}, [\"Stream Control Transmission
    Protocol\"]{.refTitle}, [RFC 4960]{.seriesInfo}, [DOI
    10.17487/RFC4960]{.seriesInfo}, September 2007,
    \<<https://www.rfc-editor.org/info/rfc4960>\>.
:   

\[RFC6096\]
:   [Tuexen, M.]{.refAuthor} and [R. Stewart]{.refAuthor}, [\"Stream
    Control Transmission Protocol (SCTP) Chunk Flags
    Registration\"]{.refTitle}, [RFC 6096]{.seriesInfo}, [DOI
    10.17487/RFC6096]{.seriesInfo}, January 2011,
    \<<https://www.rfc-editor.org/info/rfc6096>\>.
:   

\[RFC6458\]
:   [Stewart, R.]{.refAuthor}, [Tuexen, M.]{.refAuthor},
    [Poon, K.]{.refAuthor}, [Lei, P.]{.refAuthor}, and [V.
    Yasevich]{.refAuthor}, [\"Sockets API Extensions for the Stream
    Control Transmission Protocol (SCTP)\"]{.refTitle}, [RFC
    6458]{.seriesInfo}, [DOI 10.17487/RFC6458]{.seriesInfo}, December
    2011, \<<https://www.rfc-editor.org/info/rfc6458>\>.
:   

\[RFC6951\]
:   [Tuexen, M.]{.refAuthor} and [R. Stewart]{.refAuthor}, [\"UDP
    Encapsulation of Stream Control Transmission Protocol (SCTP) Packets
    for End-Host to End-Host Communication\"]{.refTitle}, [RFC
    6951]{.seriesInfo}, [DOI 10.17487/RFC6951]{.seriesInfo}, May 2013,
    \<<https://www.rfc-editor.org/info/rfc6951>\>.
:   

\[RFC7053\]
:   [Tuexen, M.]{.refAuthor}, [Ruengeler, I.]{.refAuthor}, and [R.
    Stewart]{.refAuthor}, [\"SACK-IMMEDIATELY Extension for the Stream
    Control Transmission Protocol\"]{.refTitle}, [RFC
    7053]{.seriesInfo}, [DOI 10.17487/RFC7053]{.seriesInfo}, November
    2013, \<<https://www.rfc-editor.org/info/rfc7053>\>.
:   

\[RFC8260\]
:   [Stewart, R.]{.refAuthor}, [Tuexen, M.]{.refAuthor},
    [Loreto, S.]{.refAuthor}, and [R. Seggelmann]{.refAuthor}, [\"Stream
    Schedulers and User Message Interleaving for the Stream Control
    Transmission Protocol\"]{.refTitle}, [RFC 8260]{.seriesInfo}, [DOI
    10.17487/RFC8260]{.seriesInfo}, November 2017,
    \<<https://www.rfc-editor.org/info/rfc8260>\>.
:   

\[RFC8261\]
:   [Tuexen, M.]{.refAuthor}, [Stewart, R.]{.refAuthor},
    [Jesup, R.]{.refAuthor}, and [S. Loreto]{.refAuthor}, [\"Datagram
    Transport Layer Security (DTLS) Encapsulation of SCTP
    Packets\"]{.refTitle}, [RFC 8261]{.seriesInfo}, [DOI
    10.17487/RFC8261]{.seriesInfo}, November 2017,
    \<<https://www.rfc-editor.org/info/rfc8261>\>.
:   

\[RFC8540\]
:   [Stewart, R.]{.refAuthor}, [Tuexen, M.]{.refAuthor}, and [M.
    Proshin]{.refAuthor}, [\"Stream Control Transmission Protocol:
    Errata and Issues in RFC 4960\"]{.refTitle}, [RFC
    8540]{.seriesInfo}, [DOI 10.17487/RFC8540]{.seriesInfo}, February
    2019, \<<https://www.rfc-editor.org/info/rfc8540>\>.
:   
:::
:::

::: {#sec_crc32c}
::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [CRC32c Checksum Calculation](#name-crc32c-checksum-calculation-2){.section-name .selfRef} {#name-crc32c-checksum-calculation-2}

We define a \'reflected value\' as one that is the opposite of the
normal bit order of the machine. The 32-bit CRC (Cyclic Redundancy
Check) is calculated, as described for CRC32c and uses the polynomial
code 0x11EDC6F41 (Castagnoli93) or
x^32^+x^28^+x^27^+x^26^+x^25^+x^23^+x^22^+x^20^+x^19^+x^18^+x^14^+x^13^+x^11^+x^10^+x^9^+x^8^+x^6^+x^0^.
The CRC is computed using a procedure similar to ETHERNET CRC
\[[ITU.V42.1994](#ITU.V42.1994){.xref}\], modified to reflect
transport-level usage.[¶](#appendix-A-1){.pilcrow}

CRC computation uses polynomial division. A message bit-string M is
transformed to a polynomial, M(X), and the CRC is calculated from M(X)
using polynomial arithmetic.[¶](#appendix-A-2){.pilcrow}

When CRCs are used at the link layer, the polynomial is derived from
on-the-wire bit ordering: the first bit \'on the wire\' is the
high-order coefficient. Since SCTP is a transport-level protocol, it
cannot know the actual serial-media bit ordering. Moreover, different
links in the path between SCTP endpoints can use different link-level
bit orders.[¶](#appendix-A-3){.pilcrow}

A convention therefore is established for mapping SCTP transport
messages to polynomials for purposes of CRC computation. The
bit-ordering for mapping SCTP messages to polynomials is that bytes are
taken most-significant first, but, within each byte, bits are taken
least-significant first. The first byte of the message provides the
eight highest coefficients. Within each byte, the least-significant SCTP
bit gives the most-significant polynomial coefficient within that byte,
and the most-significant SCTP bit is the least-significant polynomial
coefficient in that byte. (This bit ordering is sometimes called
\'mirrored\' or \'reflected\' \[[WILLIAMS93](#WILLIAMS93){.xref}\].) CRC
polynomials are to be transformed back into SCTP transport-level byte
values, using a consistent mapping.[¶](#appendix-A-4){.pilcrow}

The SCTP transport-level CRC value can be calculated as
follows:[¶](#appendix-A-5){.pilcrow}

-   ::: {#appendix-A-6.1}
    CRC input data is assigned to a byte stream, numbered from 0 to
    N-1.[¶](#appendix-A-6.1.1){.pilcrow}
    :::

-   ::: {#appendix-A-6.2}
    The transport-level byte stream is mapped to a polynomial value. An
    N-byte PDU with j bytes numbered 0 to N-1 is considered as
    coefficients of a polynomial M(x) of order 8\*N-1, with bit 0 of
    byte j being coefficient x^8\*(N-j)-8^ and bit 7 of byte j being
    coefficient x^8\*(N-j)-1^.[¶](#appendix-A-6.2.1){.pilcrow}
    :::

-   ::: {#appendix-A-6.3}
    The CRC remainder register is initialized with all 1s and the CRC is
    computed with an algorithm that simultaneously multiplies by x^32^
    and divides by the CRC polynomial.[¶](#appendix-A-6.3.1){.pilcrow}
    :::

-   ::: {#appendix-A-6.4}
    The polynomial is multiplied by x^32^ and divided by G(x), the
    generator polynomial, producing a remainder R(x) of degree less than
    or equal to 31.[¶](#appendix-A-6.4.1){.pilcrow}
    :::

-   ::: {#appendix-A-6.5}
    The coefficients of R(x) are considered a 32-bit
    sequence.[¶](#appendix-A-6.5.1){.pilcrow}
    :::

-   ::: {#appendix-A-6.6}
    The bit sequence is complemented. The result is the CRC
    polynomial.[¶](#appendix-A-6.6.1){.pilcrow}
    :::

-   ::: {#appendix-A-6.7}
    The CRC polynomial is mapped back into SCTP transport-level bytes.
    The coefficient of x^31^ gives the value of bit 7 of SCTP byte 0,
    and the coefficient of x^24^ gives the value of bit 0 of byte 0. The
    coefficient of x^7^ gives bit 7 of byte 3, and the coefficient of
    x^0^ gives bit 0 of byte 3. The resulting 4-byte transport-level
    sequence is the 32-bit SCTP checksum
    value.[¶](#appendix-A-6.7.1){.pilcrow}
    :::

Implementation Note: Standards documents, textbooks, and vendor
literature on CRCs often follow an alternative formulation, in which the
register used to hold the remainder of the long-division algorithm is
initialized to zero rather than all ones, and instead the first 32 bits
of the message are complemented. The long-division algorithm used in our
formulation is specified such that the initial multiplication by 2^32^
and the long-division are combined into one simultaneous operation. For
such algorithms, and for messages longer than 64 bits, the two
specifications are precisely equivalent. That equivalence is the intent
of this document.[¶](#appendix-A-7){.pilcrow}

Implementors of SCTP are warned that both specifications are to be found
in the literature, sometimes with no restriction on the long-division
algorithm. The choice of formulation in this document is to permit
non-SCTP usage, where the same CRC algorithm can be used to protect
messages shorter than 64 bits.[¶](#appendix-A-8){.pilcrow}

There can be a computational advantage in validating the association
against the Verification Tag, prior to performing a checksum, as invalid
tags will result in the same action as a bad checksum in most cases. The
exceptions for this technique would be packets containing INIT chunks
and some SHUTDOWN-COMPLETE chunks, as well as a stale COOKIE ECHO
chunks. These special-case exchanges represent small packets and will
minimize the effect of the checksum
calculation.[¶](#appendix-A-9){.pilcrow}

The following non-normative sample code is taken from an open-source CRC
generator \[[WILLIAMS93](#WILLIAMS93){.xref}\], using the \"mirroring\"
technique and yielding a lookup table for SCTP CRC32c with 256 entries,
each 32 bits wide. While neither especially slow nor especially fast, as
software table-lookup CRCs go, it has the advantage of working on both
big-endian and little-endian CPUs, using the same (host-order) lookup
tables, and using only the predefined ntohl() and htonl() operations.
The code is somewhat modified from \[[WILLIAMS93](#WILLIAMS93){.xref}\]
to ensure portability between big-endian and little-endian
architectures, use fixed-sized types to allow portability between 32-bit
and 64-bit platforms, and use general C code improvements. (Note that,
if the byte endian-ness of the target architecture is known to be little
endian, the final bit-reversal and byte-reversal steps can be folded
into a single operation.)[¶](#appendix-A-10){.pilcrow}

::: {#appendix-A-11}
``` {.breakable .lang-c .sourcecode}
<CODE BEGINS>
/****************************************************************/
/* Note: The definitions for Ross Williams's table generator    */
/* would be TB_WIDTH=4, TB_POLY=0x1EDC6F41, TB_REVER=TRUE.      */
/* For Mr. Williams's direct calculation code, use the settings */
/* cm_width=32, cm_poly=0x1EDC6F41, cm_init=0xFFFFFFFF,         */
/* cm_refin=TRUE, cm_refot=TRUE, cm_xorot=0x00000000.           */
/****************************************************************/

/* Example of the crc table file */
#ifndef __crc32cr_h__
#define __crc32cr_h__

#define CRC32C_POLY 0x1EDC6F41UL
#define CRC32C(c,d) (c=(c>>8)^crc_c[(c^(d))&0xFF])

uint32_t crc_c[256] = {
  0x00000000UL, 0xF26B8303UL, 0xE13B70F7UL, 0x1350F3F4UL,
  0xC79A971FUL, 0x35F1141CUL, 0x26A1E7E8UL, 0xD4CA64EBUL,
  0x8AD958CFUL, 0x78B2DBCCUL, 0x6BE22838UL, 0x9989AB3BUL,
  0x4D43CFD0UL, 0xBF284CD3UL, 0xAC78BF27UL, 0x5E133C24UL,
  0x105EC76FUL, 0xE235446CUL, 0xF165B798UL, 0x030E349BUL,
  0xD7C45070UL, 0x25AFD373UL, 0x36FF2087UL, 0xC494A384UL,
  0x9A879FA0UL, 0x68EC1CA3UL, 0x7BBCEF57UL, 0x89D76C54UL,
  0x5D1D08BFUL, 0xAF768BBCUL, 0xBC267848UL, 0x4E4DFB4BUL,
  0x20BD8EDEUL, 0xD2D60DDDUL, 0xC186FE29UL, 0x33ED7D2AUL,
  0xE72719C1UL, 0x154C9AC2UL, 0x061C6936UL, 0xF477EA35UL,
  0xAA64D611UL, 0x580F5512UL, 0x4B5FA6E6UL, 0xB93425E5UL,
  0x6DFE410EUL, 0x9F95C20DUL, 0x8CC531F9UL, 0x7EAEB2FAUL,
  0x30E349B1UL, 0xC288CAB2UL, 0xD1D83946UL, 0x23B3BA45UL,
  0xF779DEAEUL, 0x05125DADUL, 0x1642AE59UL, 0xE4292D5AUL,
  0xBA3A117EUL, 0x4851927DUL, 0x5B016189UL, 0xA96AE28AUL,
  0x7DA08661UL, 0x8FCB0562UL, 0x9C9BF696UL, 0x6EF07595UL,
  0x417B1DBCUL, 0xB3109EBFUL, 0xA0406D4BUL, 0x522BEE48UL,
  0x86E18AA3UL, 0x748A09A0UL, 0x67DAFA54UL, 0x95B17957UL,
  0xCBA24573UL, 0x39C9C670UL, 0x2A993584UL, 0xD8F2B687UL,
  0x0C38D26CUL, 0xFE53516FUL, 0xED03A29BUL, 0x1F682198UL,
  0x5125DAD3UL, 0xA34E59D0UL, 0xB01EAA24UL, 0x42752927UL,
  0x96BF4DCCUL, 0x64D4CECFUL, 0x77843D3BUL, 0x85EFBE38UL,
  0xDBFC821CUL, 0x2997011FUL, 0x3AC7F2EBUL, 0xC8AC71E8UL,
  0x1C661503UL, 0xEE0D9600UL, 0xFD5D65F4UL, 0x0F36E6F7UL,
  0x61C69362UL, 0x93AD1061UL, 0x80FDE395UL, 0x72966096UL,
  0xA65C047DUL, 0x5437877EUL, 0x4767748AUL, 0xB50CF789UL,
  0xEB1FCBADUL, 0x197448AEUL, 0x0A24BB5AUL, 0xF84F3859UL,
  0x2C855CB2UL, 0xDEEEDFB1UL, 0xCDBE2C45UL, 0x3FD5AF46UL,
  0x7198540DUL, 0x83F3D70EUL, 0x90A324FAUL, 0x62C8A7F9UL,
  0xB602C312UL, 0x44694011UL, 0x5739B3E5UL, 0xA55230E6UL,
  0xFB410CC2UL, 0x092A8FC1UL, 0x1A7A7C35UL, 0xE811FF36UL,
  0x3CDB9BDDUL, 0xCEB018DEUL, 0xDDE0EB2AUL, 0x2F8B6829UL,
  0x82F63B78UL, 0x709DB87BUL, 0x63CD4B8FUL, 0x91A6C88CUL,
  0x456CAC67UL, 0xB7072F64UL, 0xA457DC90UL, 0x563C5F93UL,
  0x082F63B7UL, 0xFA44E0B4UL, 0xE9141340UL, 0x1B7F9043UL,
  0xCFB5F4A8UL, 0x3DDE77ABUL, 0x2E8E845FUL, 0xDCE5075CUL,
  0x92A8FC17UL, 0x60C37F14UL, 0x73938CE0UL, 0x81F80FE3UL,
  0x55326B08UL, 0xA759E80BUL, 0xB4091BFFUL, 0x466298FCUL,
  0x1871A4D8UL, 0xEA1A27DBUL, 0xF94AD42FUL, 0x0B21572CUL,
  0xDFEB33C7UL, 0x2D80B0C4UL, 0x3ED04330UL, 0xCCBBC033UL,
  0xA24BB5A6UL, 0x502036A5UL, 0x4370C551UL, 0xB11B4652UL,
  0x65D122B9UL, 0x97BAA1BAUL, 0x84EA524EUL, 0x7681D14DUL,
  0x2892ED69UL, 0xDAF96E6AUL, 0xC9A99D9EUL, 0x3BC21E9DUL,
  0xEF087A76UL, 0x1D63F975UL, 0x0E330A81UL, 0xFC588982UL,
  0xB21572C9UL, 0x407EF1CAUL, 0x532E023EUL, 0xA145813DUL,
  0x758FE5D6UL, 0x87E466D5UL, 0x94B49521UL, 0x66DF1622UL,
  0x38CC2A06UL, 0xCAA7A905UL, 0xD9F75AF1UL, 0x2B9CD9F2UL,
  0xFF56BD19UL, 0x0D3D3E1AUL, 0x1E6DCDEEUL, 0xEC064EEDUL,
  0xC38D26C4UL, 0x31E6A5C7UL, 0x22B65633UL, 0xD0DDD530UL,
  0x0417B1DBUL, 0xF67C32D8UL, 0xE52CC12CUL, 0x1747422FUL,
  0x49547E0BUL, 0xBB3FFD08UL, 0xA86F0EFCUL, 0x5A048DFFUL,
  0x8ECEE914UL, 0x7CA56A17UL, 0x6FF599E3UL, 0x9D9E1AE0UL,
  0xD3D3E1ABUL, 0x21B862A8UL, 0x32E8915CUL, 0xC083125FUL,
  0x144976B4UL, 0xE622F5B7UL, 0xF5720643UL, 0x07198540UL,
  0x590AB964UL, 0xAB613A67UL, 0xB831C993UL, 0x4A5A4A90UL,
  0x9E902E7BUL, 0x6CFBAD78UL, 0x7FAB5E8CUL, 0x8DC0DD8FUL,
  0xE330A81AUL, 0x115B2B19UL, 0x020BD8EDUL, 0xF0605BEEUL,
  0x24AA3F05UL, 0xD6C1BC06UL, 0xC5914FF2UL, 0x37FACCF1UL,
  0x69E9F0D5UL, 0x9B8273D6UL, 0x88D28022UL, 0x7AB90321UL,
  0xAE7367CAUL, 0x5C18E4C9UL, 0x4F48173DUL, 0xBD23943EUL,
  0xF36E6F75UL, 0x0105EC76UL, 0x12551F82UL, 0xE03E9C81UL,
  0x34F4F86AUL, 0xC69F7B69UL, 0xD5CF889DUL, 0x27A40B9EUL,
  0x79B737BAUL, 0x8BDCB4B9UL, 0x988C474DUL, 0x6AE7C44EUL,
  0xBE2DA0A5UL, 0x4C4623A6UL, 0x5F16D052UL, 0xAD7D5351UL,
};

#endif


/* Example of table build routine */

#include <stdio.h>
#include <stdlib.h>

#define OUTPUT_FILE   "crc32cr.h"
#define CRC32C_POLY    0x1EDC6F41UL

static FILE *tf;

static uint32_t
reflect_32(uint32_t b)
{
  int i;
  uint32_t rw = 0UL;

  for (i = 0; i < 32; i++) {
    if (b & 1)
      rw |= 1UL << (31 - i);
    b >>= 1;
  }
  return (rw);
}

static uint32_t
build_crc_table (int index)
{
  int i;
  uint32_t rb;

  rb = reflect_32(index);

  for (i = 0; i < 8; i++) {
    if (rb & 0x80000000UL)
      rb = (rb << 1) ^ (uint32_t)CRC32C_POLY;
    else
      rb <<= 1;
  }
  return (reflect_32(rb));
}

int
main (void)
{
  int i;

  printf("\nGenerating CRC32c table file <%s>.\n",
  OUTPUT_FILE);
  if ((tf = fopen(OUTPUT_FILE, "w")) == NULL) {
    printf("Unable to open %s.\n", OUTPUT_FILE);
    exit (1);
  }
  fprintf(tf, "#ifndef __crc32cr_h__\n");
  fprintf(tf, "#define __crc32cr_h__\n\n");
  fprintf(tf, "#define CRC32C_POLY 0x%08XUL\n",
    (uint32_t)CRC32C_POLY);
  fprintf(tf,
    "#define CRC32C(c,d) (c=(c>>8)^crc_c[(c^(d))&0xFF])\n");
  fprintf(tf, "\nuint32_t crc_c[256] =\n{\n");
  for (i = 0; i < 256; i++) {
    fprintf(tf, "0x%08XUL,", build_crc_table (i));
    if ((i & 3) == 3)
      fprintf(tf, "\n");
    else
      fprintf(tf, " ");
  }
  fprintf(tf, "};\n\n#endif\n");

  if (fclose(tf) != 0)
    printf("Unable to close <%s>.\n", OUTPUT_FILE);
  else
    printf("\nThe CRC32c table has been written to <%s>.\n",
      OUTPUT_FILE);
  return (0);
}

/* Example of crc insertion */

#include "crc32cr.h"

uint32_t
generate_crc32c(unsigned char *buffer, unsigned int length)
{
  unsigned int i;
  uint32_t crc32 = 0xffffffffUL;
  uint32_t result;
  uint32_t byte0, byte1, byte2, byte3;

  for (i = 0; i < length; i++) {
    CRC32C(crc32, buffer[i]);
  }

  result = ~crc32;

  /*  result now holds the negated polynomial remainder,
   *  since the table and algorithm are "reflected" [williams95].
   *  That is, result has the same value as if we mapped the message
   *  to a polynomial, computed the host-bit-order polynomial
   *  remainder, performed final negation, and then did an
   *  end-for-end bit-reversal.
   *  Note that a 32-bit bit-reversal is identical to four in-place
   *  8-bit bit-reversals followed by an end-for-end byteswap.
   *  In other words, the bits of each byte are in the right order,
   *  but the bytes have been byteswapped.  So, we now do an explicit
   *  byteswap.  On a little-endian machine, this byteswap and
   *  the final ntohl cancel out and could be elided.
   */

  byte0 = result & 0xff;
  byte1 = (result>>8) & 0xff;
  byte2 = (result>>16) & 0xff;
  byte3 = (result>>24) & 0xff;
  crc32 = ((byte0 << 24) |
           (byte1 << 16) |
           (byte2 << 8)  |
           byte3);
  return (crc32);
}

int
insert_crc32(unsigned char *buffer, unsigned int length)
{
  SCTP_message *message;
  uint32_t crc32;

  message = (SCTP_message *)buffer;
  message->common_header.checksum = 0UL;
  crc32 = generate_crc32c(buffer,length);
  /* and insert it into the message */
  message->common_header.checksum = htonl(crc32);
  return (1);
}

int
validate_crc32(unsigned char *buffer, unsigned int length)
{
  SCTP_message *message;
  unsigned int i;
  uint32_t original_crc32;
  uint32_t crc32;

  /* save and zero checksum */
  message = (SCTP_message *)buffer;
  original_crc32 = ntohl(message->common_header.checksum);
  message->common_header.checksum = 0L;
  crc32 = generate_crc32c(buffer, length);
  return ((original_crc32 == crc32) ? 1 : -1);
}
<CODE ENDS>
```

[¶](#appendix-A-11){.pilcrow}
:::
:::
:::

::: {#sec_acknowledgements}
::: {#appendix-B .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

An undertaking represented by this updated document is not a small feat
and represents the summation of the initial coauthors of
\[[RFC2960](#RFC2960){.xref}\]: [Q. Xie]{.contact-name}, [K.
Morneault]{.contact-name}, [C. Sharp]{.contact-name}, [H.
Schwarzbauer]{.contact-name}, [T. Taylor]{.contact-name}, [I.
Rytina]{.contact-name}, [M. Kalla]{.contact-name}, [L.
Zhang]{.contact-name}, and
[V. Paxson]{.contact-name}.[¶](#appendix-B-1){.pilcrow}

Add to that, the comments from everyone who contributed to
\[[RFC2960](#RFC2960){.xref}\]: [Mark Allman]{.contact-name}, [R. J.
Atkinson]{.contact-name}, [Richard Band]{.contact-name}, [Scott
Bradner]{.contact-name}, [Steve Bellovin]{.contact-name}, [Peter
Butler]{.contact-name}, [Ram Dantu]{.contact-name}, [R.
Ezhirpavai]{.contact-name}, [Mike Fisk]{.contact-name}, [Sally
Floyd]{.contact-name}, [Atsushi Fukumoto]{.contact-name}, [Matt
Holdrege]{.contact-name}, [Henry Houh]{.contact-name}, [Christian
Huitema]{.contact-name}, [Gary Lehecka]{.contact-name}, [Jonathan
Lee]{.contact-name}, [David Lehmann]{.contact-name}, [John
Loughney]{.contact-name}, [Daniel Luan]{.contact-name}, [Barry
Nagelberg]{.contact-name}, [Thomas Narten]{.contact-name}, [Erik
Nordmark]{.contact-name}, [Lyndon Ong]{.contact-name}, [Shyamal
Prasad]{.contact-name}, [Kelvin Porter]{.contact-name}, [Heinz
Prantner]{.contact-name}, [Jarno Rajahalme]{.contact-name}, [Raymond E.
Reeves]{.contact-name}, [Renee Revis]{.contact-name}, [Ivan Arias
Rodriguez]{.contact-name}, [A. Sankar]{.contact-name}, [Greg
Sidebottom]{.contact-name}, [Brian Wyld]{.contact-name}, [La Monte
Yarroll]{.contact-name}, and many others for their invaluable
comments.[¶](#appendix-B-2){.pilcrow}

Then, add the coauthors of \[[RFC4460](#RFC4460){.xref}\]: [I.
Arias-Rodriguez]{.contact-name}, [K. Poon]{.contact-name}, and [A.
Caro.]{.contact-name}[¶](#appendix-B-3){.pilcrow}

Then, add to these the efforts of all the subsequent seven SCTP
interoperability tests and those who commented on
\[[RFC4460](#RFC4460){.xref}\], as shown in its acknowledgements: [Barry
Zuckerman]{.contact-name}, [La Monte Yarroll]{.contact-name}, [Qiaobing
Xie]{.contact-name}, [Wang Xiaopeng]{.contact-name}, [Jonathan
Wood]{.contact-name}, [Jeff Waskow]{.contact-name}, [Mike
Turner]{.contact-name}, [John Townsend]{.contact-name}, [Sabina
Torrente]{.contact-name}, [Cliff Thomas]{.contact-name}, [Yuji
Suzuki]{.contact-name}, [Manoj Solanki]{.contact-name}, [Sverre
Slotte]{.contact-name}, [Keyur Shah]{.contact-name}, [Jan
Rovins]{.contact-name}, [Ben Robinson]{.contact-name}, [Renee
Revis]{.contact-name}, [Ian Periam]{.contact-name}, [RC
Monee]{.contact-name}, [Sanjay Rao]{.contact-name}, [Sujith
Radhakrishnan]{.contact-name}, [Heinz Prantner]{.contact-name}, [Biren
Patel]{.contact-name}, [Nathalie Mouellic]{.contact-name}, [Mitch
Miers]{.contact-name}, [Bernward Meyknecht]{.contact-name}, [Stan
McClellan]{.contact-name}, [Oliver Mayor]{.contact-name}, [Tomas Orti
Martin]{.contact-name}, [Sandeep Mahajan]{.contact-name}, [David
Lehmann]{.contact-name}, [Jonathan Lee]{.contact-name}, [Philippe
Langlois]{.contact-name}, [Karl Knutson]{.contact-name}, [Joe
Keller]{.contact-name}, [Gareth Keily]{.contact-name}, [Andreas
Jungmaier]{.contact-name}, [Janardhan Iyengar]{.contact-name}, [Mutsuya
Irie]{.contact-name}, [John Hebert]{.contact-name}, [Kausar
Hassan]{.contact-name}, [Fred Hasle]{.contact-name}, [Dan
Harrison]{.contact-name}, [Jon Grim]{.contact-name}, [Laurent
Glaude]{.contact-name}, [Steven Furniss]{.contact-name}, [Atsushi
Fukumoto]{.contact-name}, [Ken Fujita]{.contact-name}, [Steve
Dimig]{.contact-name}, [Thomas Curran]{.contact-name}, [Serkan
Cil]{.contact-name}, [Melissa Campbell]{.contact-name}, [Peter
Butler]{.contact-name}, [Rob Brennan]{.contact-name}, [Harsh
Bhondwe]{.contact-name}, [Brian Bidulock]{.contact-name}, [Caitlin
Bestler]{.contact-name}, [Jon Berger]{.contact-name}, [Robby
Benedyk]{.contact-name}, [Stephen Baucke]{.contact-name}, [Sandeep
Balani]{.contact-name}, and [Ronnie
Sellar]{.contact-name}.[¶](#appendix-B-4){.pilcrow}

A special thanks to [Mark Allman]{.contact-name}, who actually should
have been a coauthor of \[[RFC4460](#RFC4460){.xref}\] for his work on
the max-burst but managed to wiggle out due to a
technicality.[¶](#appendix-B-5){.pilcrow}

Also, we would like to acknowledge [Lyndon Ong]{.contact-name} and [Phil
Conrad]{.contact-name} for their valuable input and many
contributions.[¶](#appendix-B-6){.pilcrow}

Furthermore, you have \[[RFC4960](#RFC4960){.xref}\] and those who have
commented upon that, including [Alfred Hönes]{.contact-name} and [Ronnie
Sellars]{.contact-name}.[¶](#appendix-B-7){.pilcrow}

Then, add the coauthor of \[[RFC8540](#RFC8540){.xref}\]: [Maksim
Proshin]{.contact-name}.[¶](#appendix-B-8){.pilcrow}

And people who have commented on \[[RFC8540](#RFC8540){.xref}\]: [Pontus
Andersson]{.contact-name}, [Eric W. Biederman]{.contact-name}, [Cedric
Bonnet]{.contact-name}, [Spencer Dawkins]{.contact-name}, [Gorry
Fairhurst]{.contact-name}, [Benjamin Kaduk]{.contact-name}, [Mirja
Kühlewind]{.contact-name}, [Peter Lei]{.contact-name}, [Gyula
Marosi]{.contact-name}, [Lionel Morand]{.contact-name}, [Jeff
Morriss]{.contact-name}, [Tom Petch]{.contact-name}, [Kacheong
Poon]{.contact-name}, [Julien Pourtet]{.contact-name}, [Irene
Rüngeler]{.contact-name}, [Michael Welzl]{.contact-name}, and [Qiaobing
Xie]{.contact-name}.[¶](#appendix-B-9){.pilcrow}

And, finally, the people who have provided comments for this document,
including [Gorry Fairhurst]{.contact-name}, [Martin
Duke]{.contact-name}, [Benjamin Kaduk]{.contact-name}, [Tero
Kivinen]{.contact-name}, [Eliot Lear]{.contact-name}, [Marcelo Ricardo
Leitner]{.contact-name}, [David Mandelberg]{.contact-name}, [John Preuß
Mattsson]{.contact-name}, [Claudio Porfiri]{.contact-name}, [Maksim
Proshin]{.contact-name}, [Ines Robles]{.contact-name}, [Timo
Völker]{.contact-name}, [Magnus Westerlund]{.contact-name}, and
[Zhouming]{.contact-name}.[¶](#appendix-B-10){.pilcrow}

Our thanks cannot be adequately expressed to all of you who have
participated in the coding, testing, and updating process of this
document. All we can say is, Thank You![¶](#appendix-B-11){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-C .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Randall R. Stewart]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Netflix, Inc.]{.org}
:::

::: {.left dir="auto"}
[2455 Heritage Green Ave]{.street-address}
:::

::: {.left dir="auto"}
[Davenport]{.locality}, [FL]{.region} [33837]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <randall@lakerest.net>
:::

::: {.left dir="auto"}
[Michael Tüxen]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Münster University of Applied Sciences]{.org}
:::

::: {.left dir="auto"}
[Stegerwaldstrasse 39]{.street-address}
:::

::: {.left dir="auto"}
[48565]{.postal-code} [Steinfurt]{.locality}
:::

::: {.left dir="auto"}
[Germany]{.country-name}
:::

::: email
Email: <tuexen@fh-muenster.de>
:::

::: {.left dir="auto"}
[Karen E. E. Nielsen]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Kamstrup A/S]{.org}
:::

::: {.left dir="auto"}
[Industrivej 28]{.street-address}
:::

::: {.left dir="auto"}
[DK-8660]{.postal-code} [Skanderborg]{.locality}
:::

::: {.left dir="auto"}
[Denmark]{.country-name}
:::

::: email
Email: <kee@kamstrup.com>
:::
:::
:::
