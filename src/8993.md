  RFC 8993            Reference Model for Autonomic Networking   May 2021
  ------------------- ------------------------------------------ ----------
  Behringer, et al.   Informational                              \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8993](https://www.rfc-editor.org/rfc/rfc8993){.eref}

Category:
:   Informational

Published:
:   May 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    M. Behringer, [Ed.]{.editor}
    :::
    :::

    ::: author
    ::: author-name
    B. Carpenter
    :::

    ::: org
    Univ. of Auckland
    :::
    :::

    ::: author
    ::: author-name
    T. Eckert
    :::

    ::: org
    Futurewei USA
    :::
    :::

    ::: author
    ::: author-name
    L. Ciavaglia
    :::

    ::: org
    Nokia
    :::
    :::

    ::: author
    ::: author-name
    J. Nobre
    :::

    ::: org
    UFRGS
    :::
    :::
:::

# RFC 8993 {#rfcnum}

# A Reference Model for Autonomic Networking {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes a reference model for Autonomic Networking for
managed networks. It defines the behavior of an autonomic node, how the
various elements in an autonomic context work together, and how
autonomic services can use the
infrastructure.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for informational
purposes.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Not all documents approved
by the IESG are candidates for any level of Internet Standard; see
Section 2 of RFC 7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8993>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Network View](#name-network-view){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Autonomic Network
    Element](#name-autonomic-network-element){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Architecture](#name-architecture){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Adjacency
        Table](#name-adjacency-table){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [State
        Machine](#name-state-machine){.xref}

        -   ::: {#section-toc.1-1.3.2.3.2.1}
            [3.3.1](#section-3.3.1){.xref}.  [State 1: Factory
            Default](#name-state-1-factory-default){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.2}
            [3.3.2](#section-3.3.2){.xref}.  [State 2:
            Enrolled](#name-state-2-enrolled){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.3}
            [3.3.3](#section-3.3.3){.xref}.  [State 3: In
            ACP](#name-state-3-in-acp){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Autonomic Networking
    Infrastructure](#name-autonomic-networking-infras){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Naming](#name-naming){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Addressing](#name-addressing){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Discovery](#name-discovery){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Signaling between Autonomic
        Nodes](#name-signaling-between-autonomic){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [Routing](#name-routing){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.6}
        [4.6](#section-4.6){.xref}.  [Autonomic Control
        Plane](#name-autonomic-control-plane){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.7}
        [4.7](#section-4.7){.xref}.  [Information Distribution
        (\*)](#name-information-distribution){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Security and Trust
    Infrastructure](#name-security-and-trust-infrastr){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Public Key
        Infrastructure](#name-public-key-infrastructure){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Domain
        Certificate](#name-domain-certificate){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [MASA](#name-masa){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [Subdomains
        (\*)](#name-subdomains){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [Cross-Domain Functionality
        (\*)](#name-cross-domain-functionality){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Autonomic Service Agents
    (ASAs)](#name-autonomic-service-agents-as){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [General Description of an
        ASA](#name-general-description-of-an-a){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [ASA Life-Cycle
        Management](#name-asa-life-cycle-management){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Specific ASAs for the Autonomic
        Networking
        Infrastructure](#name-specific-asas-for-the-auton){.xref}

        -   ::: {#section-toc.1-1.6.2.3.2.1}
            [6.3.1](#section-6.3.1){.xref}.  [Enrollment
            ASAs](#name-enrollment-asas){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.3.2.2}
            [6.3.2](#section-6.3.2){.xref}.  [ACP
            ASA](#name-acp-asa){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.3.2.3}
            [6.3.3](#section-6.3.3){.xref}.  [Information Distribution
            ASA (\*)](#name-information-distribution-as){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Management and
    Programmability](#name-management-and-programmabil){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Managing a (Partially) Autonomic
        Network](#name-managing-a-partially-autono){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Intent (\*)](#name-intent){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Aggregated Reporting
        (\*)](#name-aggregated-reporting){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [Feedback Loops to NOC
        (\*)](#name-feedback-loops-to-noc){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.5}
        [7.5](#section-7.5){.xref}.  [Control Loops
        (\*)](#name-control-loops){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.6}
        [7.6](#section-7.6){.xref}.  [APIs (\*)](#name-apis){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.7}
        [7.7](#section-7.7){.xref}.  [Data Model
        (\*)](#name-data-model){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Coordination between Autonomic Functions
    (\*)](#name-coordination-between-autono){.xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Coordination Problem
        (\*)](#name-coordination-problem){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Coordination Functional Block
        (\*)](#name-coordination-functional-blo){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Protection against Outsider
        Attacks](#name-protection-against-outsider){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Risk of Insider
        Attacks](#name-risk-of-insider-attacks){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.11.2.1}
        [11.1](#section-11.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [11.2](#section-11.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [](#section-appendix.a){.xref}[Acknowledgements](#name-acknowledgements){.xref}
    :::

-   ::: {#section-toc.1-1.13}
    [](#section-appendix.b){.xref}[Contributors](#name-contributors){.xref}
    :::

-   ::: {#section-toc.1-1.14}
    [](#section-appendix.c){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#intro}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The document \"[Autonomic Networking: Definitions and Design
Goals](#RFC7575){.xref}\" \[[RFC7575](#RFC7575){.xref}\] explains the
fundamental concepts behind Autonomic Networking and defines the
relevant terms in this space and a high-level reference model.
\[[RFC7576](#RFC7576){.xref}\] provides a gap analysis between
traditional and autonomic approaches.[¶](#section-1-1){.pilcrow}

This document defines this reference model with more detail to allow for
functional and protocol specifications to be developed in an
architecturally consistent, non-overlapping
manner.[¶](#section-1-2){.pilcrow}

As discussed in \[[RFC7575](#RFC7575){.xref}\], the goal of this work is
not to focus exclusively on fully autonomic nodes or networks. In
reality, most networks will run with some autonomic functions, while the
rest of the network is traditionally managed. This reference model
allows for this hybrid approach.[¶](#section-1-3){.pilcrow}

For example, it is possible in an existing, non-autonomic network to
enroll devices in a traditional way to bring up a trust infrastructure
with certificates. This trust infrastructure could then be used to
automatically bring up an Autonomic Control Plane (ACP) and run
traditional network operations over the secure and self-healing ACP. See
\[[RFC8368](#RFC8368){.xref}\] for a description of this use
case.[¶](#section-1-4){.pilcrow}

The scope of this model is therefore limited to networks that are to
some extent managed by skilled human operators, loosely referred to as
\"professionally managed\" networks. Unmanaged networks raise additional
security and trust issues that this model does not
cover.[¶](#section-1-5){.pilcrow}

This document describes the first phase of an Autonomic Networking
solution that is both simple and implementable. It is expected that the
experience from this phase will be used in defining updated and extended
specifications over time. Some topics are considered architecturally in
this document but are not yet reflected in the implementation
specifications. They are marked with an (\*).[¶](#section-1-6){.pilcrow}
:::
:::

::: {#network}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Network View](#name-network-view){.section-name .selfRef} {#name-network-view}

This section describes the various elements in a network with autonomic
functions and explains how these entities work together on a high level.
Subsequent sections explain the detailed inside view for each of the
Autonomic Network elements, as well as the network functions (or
interfaces) between those elements.[¶](#section-2-1){.pilcrow}

[Figure 1](#network-view){.xref} shows the high-level view of an
Autonomic Network. It consists of a number of autonomic nodes, which
interact directly with each other. Those autonomic nodes provide a
common set of capabilities across the network, called the \"Autonomic
Networking Infrastructure (ANI)\". The ANI provides functions like
naming, addressing, negotiation, synchronization, discovery, and
messaging.[¶](#section-2-2){.pilcrow}

Autonomic functions typically span several, possibly all, nodes in the
network. The atomic entities of an autonomic function are called the
\"Autonomic Service Agents (ASAs)\", which are instantiated on
nodes.[¶](#section-2-3){.pilcrow}

[]{#name-high-level-view-of-an-auton}

::: {#network-view}
::: {#section-2-4.1 .artwork .art-text .alignLeft}
    +- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    :            :       Autonomic Function 1        :                 :
    : ASA 1      :      ASA 1      :      ASA 1      :          ASA 1  :
    +- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
                 :                 :                 :
                 :   +- - - - - - - - - - - - - - +  :
                 :   :   Autonomic Function 2     :  :
                 :   :  ASA 2      :      ASA 2   :  :
                 :   +- - - - - - - - - - - - - - +  :
                 :                 :                 :
    +- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    :                Autonomic Networking Infrastructure               :
    +- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    +--------+   :    +--------+   :    +--------+   :        +--------+
    | Node 1 |--------| Node 2 |--------| Node 3 |----...-----| Node n |
    +--------+   :    +--------+   :    +--------+   :        +--------+
:::

[Figure 1](#figure-1){.selfRef}: [High-Level View of an Autonomic
Network](#name-high-level-view-of-an-auton){.selfRef}
:::

In a horizontal view, autonomic functions span across the network, as
well as the ANI. In a vertical view, a node always implements the ANI,
plus it may have one or several ASAs. ASAs may be standalone or use
other ASAs in a hierarchical way.[¶](#section-2-5){.pilcrow}

Therefore, the ANI is the foundation for autonomic
functions.[¶](#section-2-6){.pilcrow}
:::
:::

::: {#element}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Autonomic Network Element](#name-autonomic-network-element){.section-name .selfRef} {#name-autonomic-network-element}

This section explains the general architecture of an Autonomic Network
element ([Section 3.1](#element-arch){.xref}), how it tracks its
surrounding environment in an adjacency table ([Section
3.2](#adjacency-table){.xref}), and the state machine that defines the
behavior of the network element ([Section 3.3](#state-machine){.xref}),
based on that adjacency table.[¶](#section-3-1){.pilcrow}

::: {#element-arch}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Architecture](#name-architecture){.section-name .selfRef} {#name-architecture}

This section describes an Autonomic Network element and its internal
architecture. The reference model explained in the document \"[Autonomic
Networking: Definitions and Design Goals](#RFC7575){.xref}\"
\[[RFC7575](#RFC7575){.xref}\] shows the sources of information that an
ASA can leverage: self-knowledge, network knowledge (through discovery),
Intent (see [Section 7.2](#intent){.xref}), and feedback loops. There
are two levels inside an autonomic node: the level of ASAs and the level
of the ANI, with the former using the services of the latter. [Figure
2](#ref_model){.xref} illustrates this
concept.[¶](#section-3.1-1){.pilcrow}

[]{#name-model-of-an-autonomic-node}

::: {#ref_model}
::: {#section-3.1-2.1 .artwork .art-text .alignLeft}
    +------------------------------------------------------------+
    |                                                            |
    | +-----------+        +------------+        +------------+  |
    | | Autonomic |        | Autonomic  |        | Autonomic  |  |
    | | Service   |        | Service    |        | Service    |  |
    | | Agent 1   |        | Agent 2    |        | Agent 3    |  |
    | +-----------+        +------------+        +------------+  |
    |       ^                    ^                     ^         |
    | -  -  | -  - API level -  -| -  -  -  -  -  -  - |-  -  -  |
    |       V                    V                     V         |
    |------------------------------------------------------------|
    | Autonomic Networking Infrastructure                        |
    |    - Data structures (ex: certificates, peer information)  |
    |    - Generalized Autonomic Control Plane (GACP)            |
    |    - Autonomic node addressing and naming                  |
    |    - Discovery, negotiation and synchronization functions  |
    |    - Distribution of Intent and other information          |
    |    - Aggregated reporting and feedback loops               |
    |    - Routing                                               |
    |------------------------------------------------------------|
    |             Basic Operating System Functions               |
    +------------------------------------------------------------+
:::

[Figure 2](#figure-2){.selfRef}: [Model of an Autonomic
Node](#name-model-of-an-autonomic-node){.selfRef}
:::

The ANI (lower part of [Figure 2](#ref_model){.xref}) contains
node-specific data structures (for example, trust information about
itself and its peers) as well as a generic set of functions, independent
of a particular usage. This infrastructure should be generic and support
a variety of ASAs (upper part of [Figure 2](#ref_model){.xref}). It
contains addressing and naming of autonomic nodes, discovery,
negotiation and synchronization functions, distribution of information,
reporting, feedback loops, and routing inside the
ACP.[¶](#section-3.1-3){.pilcrow}

The Generalized ACP (GACP) is the summary of all interactions of the ANI
with other nodes and services. A specific implementation of the GACP is
referred to here as the ACP and described in
\[[RFC8994](#RFC8994){.xref}\].[¶](#section-3.1-4){.pilcrow}

The use cases of \"Autonomics\" (such as self-management,
self-optimization, etc.) are implemented as ASAs. They use the services
and data structures of the underlying ANI, which should be
self-managing.[¶](#section-3.1-5){.pilcrow}

The Basic Operating System Functions (lower part of [Figure
2](#ref_model){.xref}) include the normal OS (e.g., the network stack
and security functions).[¶](#section-3.1-6){.pilcrow}

Full Autonomic Network (AN) nodes have the full ANI, with the full
functionality described in this document. At a later stage, the ANIMA
Working Group may define a scope for constrained nodes with a reduced
ANI and well-defined minimal functionality. These are currently out of
scope.[¶](#section-3.1-7){.pilcrow}
:::
:::

::: {#adjacency-table}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Adjacency Table](#name-adjacency-table){.section-name .selfRef} {#name-adjacency-table}

Autonomic Networking is based on direct interactions between devices of
a domain. The ACP is normally constructed on a hop-by-hop basis.
Therefore, many interactions in the ANI are based on the ANI adjacency
table. There are interactions that provide input into the adjacency
table and other interactions that leverage the information contained in
it.[¶](#section-3.2-1){.pilcrow}

The ANI adjacency table contains, at a minimum, information about
adjacent autonomic nodes: Node-ID, IP address in data plane, IP address
in ACP, domain, and certificate. An autonomic node maintains this
adjacency table up to date. The adjacency table only contains
information about other nodes that are capable of Autonomic Networking;
non-autonomic nodes are normally not tracked here. However, the
information is tracked independently of the status of the peer nodes;
specifically, the adjacency table contains information about
non-enrolled nodes of the same and other domains. The adjacency table
may contain information about the validity and trust level of the
adjacent autonomic nodes.[¶](#section-3.2-2){.pilcrow}

The adjacency table is fed by the following
inputs:[¶](#section-3.2-3){.pilcrow}

-   [Link-local discovery: This interaction happens in the data plane,
    using IPv6 link-local addressing only, because this addressing type
    is itself autonomic. This way the node learns about all autonomic
    nodes around itself. The related Standards Track documents
    (\[[RFC8990](#RFC8990){.xref}\], \[[RFC8995](#RFC8995){.xref}\], and
    \[[RFC8994](#RFC8994){.xref}\]) describe in detail how link-local
    discovery is used.[¶](#section-3.2-4.1){.pilcrow}]{#section-3.2-4.1}
-   [Vendor redirect: A new device may receive information on where its
    home network is through a vendor-based Manufacturer Authorized
    Signing Authority (MASA) (see [Section 5.3](#masa){.xref}) redirect;
    this is typically a routable
    address.[¶](#section-3.2-4.2){.pilcrow}]{#section-3.2-4.2}
-   [Non-autonomic input: A node may be configured manually with an
    autonomic peer; it could learn about autonomic nodes through DHCP
    options, DNS, and other non-autonomic mechanisms. Generally, such
    non-autonomic mechanisms require some administrator intervention.
    The key purpose is to bypass a non-autonomic device or network. As
    this pertains to new devices, it is covered in Appendices
    [A](https://www.rfc-editor.org/rfc/rfc8995#appendix-A){.relref} and
    [B](https://www.rfc-editor.org/rfc/rfc8995#appendix-B){.relref} of
    \[[RFC8995](#RFC8995){.xref}\].[¶](#section-3.2-4.3){.pilcrow}]{#section-3.2-4.3}

The adjacency table defines the behavior of an autonomic
node:[¶](#section-3.2-5){.pilcrow}

-   [If the node has not bootstrapped into a domain (i.e., doesn\'t have
    a domain certificate), it rotates through all nodes in the adjacency
    table that claim to have a domain and will attempt bootstrapping
    through them, one by one. One possible response is a redirect via a
    vendor MASA, which will be entered into the adjacency table (see
    second bullet above). See \[[RFC8995](#RFC8995){.xref}\] for
    details.[¶](#section-3.2-6.1){.pilcrow}]{#section-3.2-6.1}
-   [If the adjacent node has the same domain, it will authenticate that
    adjacent node and, if successful, establish the ACP. See
    \[[RFC8994](#RFC8994){.xref}\].[¶](#section-3.2-6.2){.pilcrow}]{#section-3.2-6.2}
-   [Once the node is part of the ACP of a domain, it will use GRASP
    \[[RFC8990](#RFC8990){.xref}\] to find the registrar(s) of its
    domain and potentially other
    services.[¶](#section-3.2-6.3){.pilcrow}]{#section-3.2-6.3}
-   [If the node is part of an ACP and has discovered at least one
    registrar in its domain via GRASP, it will start the join proxy ASA
    and act as a join proxy for neighboring nodes that need to be
    bootstrapped. See [Section 6.3.1.2](#join-assitant){.xref} for
    details.[¶](#section-3.2-6.4){.pilcrow}]{#section-3.2-6.4}
-   [Other behaviors are possible, for example, establishing the ACP
    with devices of a subdomain or other domains. These will likely be
    controlled by Intent and are outside the scope of this document.
    Note that Intent is distributed through the ACP; therefore, a node
    can only adapt Intent-driven behavior once it has joined the ACP. At
    the moment, the ANIMA Working Group does not consider providing
    Intent outside the ACP; this can be considered
    later.[¶](#section-3.2-6.5){.pilcrow}]{#section-3.2-6.5}

Once a node has joined the ACP, it will also learn the ACP addresses of
its adjacent nodes and add them to the adjacency table to allow for
communication inside the ACP. Further autonomic domain interactions will
now happen inside the ACP. At this moment, only negotiation and
synchronization via GRASP \[[RFC8990](#RFC8990){.xref}\] are defined.
(Note that GRASP runs in the data plane, as an input in building the
adjacency table, as well as inside the
ACP.)[¶](#section-3.2-7){.pilcrow}

Autonomic functions consist of ASAs. They run logically above the ANI
and may use the adjacency table, the ACP, negotiation and
synchronization through GRASP in the ACP, Intent, and other functions of
the ANI. Since the ANI only provides autonomic interactions within a
domain, autonomic functions can also use any other context on a node,
specifically the global data plane.[¶](#section-3.2-8){.pilcrow}
:::
:::

::: {#state-machine}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [State Machine](#name-state-machine){.section-name .selfRef} {#name-state-machine}

Autonomic Networking applies during the full life cycle of a node. This
section describes a state machine of an autonomic node throughout its
life.[¶](#section-3.3-1){.pilcrow}

A device is normally expected to store its domain-specific identity, the
Local Device Identifier (LDevID) (see [Section 5.2](#cert){.xref}), in
persistent storage to be available after a power-cycle event. For device
types that cannot store the LDevID in persistent storage, a power-cycle
event is effectively equivalent to a factory
reset.[¶](#section-3.3-2){.pilcrow}

::: {#state-1}
::: {#section-3.3.1 .section}
#### [3.3.1.](#section-3.3.1){.section-number .selfRef} [State 1: Factory Default](#name-state-1-factory-default){.section-name .selfRef} {#name-state-1-factory-default}

An autonomic node leaves the factory in this state. In this state, the
node has no domain-specific configuration, specifically no LDevID, and
could be used in any particular target network. It does, however, have a
vendor/manufacturer-specific ID, the Initial Device Identifier (IDevID)
\[[IDevID](#IDevID){.xref}\]. Nodes without IDevID cannot be
autonomically and securely enrolled into a domain; they require manual
pre-staging, in which case the pre-staging takes them directly to state
2.[¶](#section-3.3.1-1){.pilcrow}

Transitions:[¶](#section-3.3.1-2){.pilcrow}

-   [Bootstrap event: The device enrolls into a domain; as part of this
    process it receives a domain identity (LDevID). If enrollment is
    successful, the next state is state 2. See
    \[[RFC8995](#RFC8995){.xref}\] for details on
    enrollment.[¶](#section-3.3.1-3.1){.pilcrow}]{#section-3.3.1-3.1}
-   [Power-cycle event: The device loses all state tables. It remains in
    state 1.[¶](#section-3.3.1-3.2){.pilcrow}]{#section-3.3.1-3.2}
:::
:::

::: {#state-2}
::: {#section-3.3.2 .section}
#### [3.3.2.](#section-3.3.2){.section-number .selfRef} [State 2: Enrolled](#name-state-2-enrolled){.section-name .selfRef} {#name-state-2-enrolled}

An autonomic node is in the \"enrolled\" state if it has a domain
identity (LDevID) and has currently no ACP channel up. It may have
further configuration or state, for example, if it had been in state 3
before but lost all its ACP channels. The LDevID can only be removed
from a device through a factory reset, which also removes all other
state from the device. This ensures that a device has no stale
domain-specific state when entering the \"enrolled\" state from state
1.[¶](#section-3.3.2-1){.pilcrow}

Transitions:[¶](#section-3.3.2-2){.pilcrow}

-   [Joining ACP: The device establishes an ACP channel to an adjacent
    device. See \[[RFC8994](#RFC8994){.xref}\] for details. Next state:
    3.[¶](#section-3.3.2-3.1){.pilcrow}]{#section-3.3.2-3.1}
-   [Factory reset: A factory reset removes all configuration and the
    domain identity (LDevID) from the device. Next state:
    1.[¶](#section-3.3.2-3.2){.pilcrow}]{#section-3.3.2-3.2}
-   [Power-cycle event: The device loses all state tables, but not its
    domain identity (LDevID). It remains in state
    2.[¶](#section-3.3.2-3.3){.pilcrow}]{#section-3.3.2-3.3}
:::
:::

::: {#state-3}
::: {#section-3.3.3 .section}
#### [3.3.3.](#section-3.3.3){.section-number .selfRef} [State 3: In ACP](#name-state-3-in-acp){.section-name .selfRef} {#name-state-3-in-acp}

In this state, the autonomic node has at least one ACP channel to
another device. The node can now participate in further autonomic
transactions, such as starting ASAs (e.g., it must now enable the join
proxy ASA, to help other devices to join the domain). Other conditions
may apply to such interactions, for example, to serve as a join proxy,
the device must first discover a bootstrap
registrar.[¶](#section-3.3.3-1){.pilcrow}

Transitions:[¶](#section-3.3.3-2){.pilcrow}

-   [Leaving ACP: The device drops the last (or only) ACP channel to an
    adjacent device. Next state:
    2.[¶](#section-3.3.3-3.1){.pilcrow}]{#section-3.3.3-3.1}
-   [Factory reset: A factory reset removes all configuration and the
    domain identity (LDevID) from the device. Next state:
    1.[¶](#section-3.3.3-3.2){.pilcrow}]{#section-3.3.3-3.2}
-   [Power-cycle event: The device loses all state tables but not its
    domain identity (LDevID). Next state:
    2.[¶](#section-3.3.3-3.3){.pilcrow}]{#section-3.3.3-3.3}
:::
:::
:::
:::
:::
:::

::: {#ani}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Autonomic Networking Infrastructure](#name-autonomic-networking-infras){.section-name .selfRef} {#name-autonomic-networking-infras}

The ANI provides a layer of common functionality across an Autonomic
Network. It provides the elementary functions and services, as well as
extensions. An autonomic function, comprising of ASAs on nodes, uses the
functions described in this section.[¶](#section-4-1){.pilcrow}

::: {#naming}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Naming](#name-naming){.section-name .selfRef} {#name-naming}

Inside a domain, each autonomic device should be assigned a unique name.
The naming scheme should be consistent within a domain. Names are
typically assigned by a registrar at bootstrap time and are persistent
over the lifetime of the device. All registrars in a domain must follow
the same naming scheme.[¶](#section-4.1-1){.pilcrow}

In the absence of a domain-specific naming scheme, a default naming
scheme should use the same logic as the addressing scheme discussed in
\[[RFC8994](#RFC8994){.xref}\]. The device name is then composed of a
Registrar-ID (for example, taking a Media Access Control (MAC) address
of the registrar) and a device number. An example name would then look
like this:[¶](#section-4.1-2){.pilcrow}

0123-4567-89ab-0001[¶](#section-4.1-3){.pilcrow}

The first three fields are the MAC address, and the fourth field is the
sequential number for the device.[¶](#section-4.1-4){.pilcrow}
:::
:::

::: {#addressing}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Addressing](#name-addressing){.section-name .selfRef} {#name-addressing}

ASAs need to communicate with each other, using the autonomic addressing
of the ANI of the node they reside on. This section describes the
addressing approach of the ANI used by
ASAs.[¶](#section-4.2-1){.pilcrow}

Addressing approaches for the data plane of the network are outside the
scope of this document. These addressing approaches may be configured
and managed in the traditional way or negotiated as a service of an ASA.
One use case for such an autonomic function is described in
\[[RFC8992](#RFC8992){.xref}\].[¶](#section-4.2-2){.pilcrow}

Autonomic addressing is a function of the ANI (lower part of [Figure
2](#ref_model){.xref}), specifically the ACP. ASAs do not have their own
addresses. They may use either API calls or the autonomic addressing
scheme of the ANI.[¶](#section-4.2-3){.pilcrow}

An autonomic addressing scheme has the following
requirements:[¶](#section-4.2-4){.pilcrow}

-   [Zero-touch for simple networks: Simple networks should have
    complete self-management of addressing and not require any central
    address management, tools, or address
    planning.[¶](#section-4.2-5.1){.pilcrow}]{#section-4.2-5.1}
-   [Low-touch for complex networks: If complex networks require
    operator input for autonomic address management, it should be
    limited to high-level guidance only, expressed in
    Intent.[¶](#section-4.2-5.2){.pilcrow}]{#section-4.2-5.2}
-   [Flexibility: The addressing scheme must be flexible enough for
    nodes to be able to move around and for the network to grow, split,
    and merge.[¶](#section-4.2-5.3){.pilcrow}]{#section-4.2-5.3}
-   [Robustness: It should be as hard as possible for an administrator
    to negatively affect addressing (and thus connectivity) in the
    autonomic context.[¶](#section-4.2-5.4){.pilcrow}]{#section-4.2-5.4}
-   [Stability: The addressing scheme should be as stable as possible.
    However, implementations need to be able to recover from unexpected
    address changes.[¶](#section-4.2-5.5){.pilcrow}]{#section-4.2-5.5}
-   [Support for virtualization: Autonomic functions can exist either at
    the level of the physical network and physical devices or at the
    level of virtual machines, containers, and networks. In particular,
    autonomic nodes may support ASAs in virtual entities. The
    infrastructure, including the addressing scheme, should be able to
    support this
    architecture.[¶](#section-4.2-5.6){.pilcrow}]{#section-4.2-5.6}
-   [Simplicity: The addressing scheme should be simple to make
    engineering easier and to give the human administrator an easy way
    to troubleshoot autonomic
    functions.[¶](#section-4.2-5.7){.pilcrow}]{#section-4.2-5.7}
-   [Scale: The proposed scheme should work in any network of any
    size.[¶](#section-4.2-5.8){.pilcrow}]{#section-4.2-5.8}
-   [Upgradability: The scheme must be able to support different
    addressing concepts in the
    future.[¶](#section-4.2-5.9){.pilcrow}]{#section-4.2-5.9}

The proposed addressing scheme is described in the document \"[An
Autonomic Control Plane (ACP)](#RFC8994){.xref}\"
\[[RFC8994](#RFC8994){.xref}\].[¶](#section-4.2-6){.pilcrow}
:::
:::

::: {#discovery}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Discovery](#name-discovery){.section-name .selfRef} {#name-discovery}

Traditionally, most of the information a node requires is provided
through configuration or northbound interfaces. An autonomic function
should rely on such northbound interfaces minimally or not at all;
therefore, it needs to discover peers and other resources in the
network. This section describes various discovery functions in an
Autonomic Network.[¶](#section-4.3-1){.pilcrow}

First, discovering nodes and their properties and capabilities is a core
function to establish an autonomic domain is the mutual discovery of
autonomic nodes, primarily adjacent nodes and secondarily off-link
peers. This may, in principle, either leverage existing discovery
mechanisms or use new mechanisms tailored to the autonomic context. An
important point is that discovery must work in a network with no
predefined topology, ideally no manual configuration of any kind, and
with nodes starting up from factory condition or after any form of
failure or sudden topology change.[¶](#section-4.3-2){.pilcrow}

Second, network services such as Authentication, Authorization, and
Accounting (AAA) should also be discovered and not configured. Service
discovery is required for such tasks. An Autonomic Network can leverage
existing service discovery functions, use a new approach, or use a
mixture.[¶](#section-4.3-3){.pilcrow}

Thus, the discovery mechanism could either be fully integrated with
autonomic signaling (next section) or use an independent discovery
mechanism such as DNS-based Service Discovery or the Service Location
Protocol. This choice could be made independently for each ASA, although
the infrastructure might require some minimal lowest common denominator
(e.g., for discovering the security bootstrap mechanism or the source of
information distribution ([Section
4.7](#info-distri){.xref})).[¶](#section-4.3-4){.pilcrow}

Phase 1 of Autonomic Networking uses GRASP
\[[RFC8990](#RFC8990){.xref}\] for
discovery.[¶](#section-4.3-5){.pilcrow}
:::
:::

::: {#negotiation}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Signaling between Autonomic Nodes](#name-signaling-between-autonomic){.section-name .selfRef} {#name-signaling-between-autonomic}

Autonomic nodes must communicate with each other, for example, to
negotiate and/or synchronize technical objectives (i.e., network
parameters) of any kind and complexity. This requires some form of
signaling between autonomic nodes. Autonomic nodes implementing a
specific use case might choose their own signaling protocol, as long as
it fits the overall security model. However, in the general case, any
pair of autonomic nodes might need to communicate, so there needs to be
a generic protocol for this. A prerequisite for this is that autonomic
nodes can discover each other without any preconfiguration, as mentioned
above. To be generic, discovery and signaling must be able to handle any
sort of technical objective, including ones that require complex data
structures. The document \"[GeneRic Autonomic Signaling Protocol
(GRASP)](#RFC8990){.xref}\" \[[RFC8990](#RFC8990){.xref}\] describes
more detailed requirements for discovery, negotiation, and
synchronization in an Autonomic Network. It also defines a protocol,
called GRASP, for this purpose; GRASP includes an integrated but
optional discovery process.[¶](#section-4.4-1){.pilcrow}

GRASP is normally expected to run inside the ACP (see [Section
4.6](#acp){.xref}) and to depend on the ACP for security. It may run
insecurely for a short time during
bootstrapping.[¶](#section-4.4-2){.pilcrow}

An autonomic node will normally run a single instance of GRASP, used by
multiple ASAs. However, scenarios where multiple instances of GRASP run
in a single node, perhaps with different security properties, are not
excluded.[¶](#section-4.4-3){.pilcrow}
:::
:::

::: {#routing}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [Routing](#name-routing){.section-name .selfRef} {#name-routing}

All autonomic nodes in a domain must be able to communicate with each
other, and in later phases, they must also be able to communicate with
autonomic nodes outside their own domain. Therefore, an ACP relies on a
routing function. For Autonomic Networks to be interoperable, they must
all support one common routing protocol.[¶](#section-4.5-1){.pilcrow}

The routing protocol is defined in the ACP document
\[[RFC8994](#RFC8994){.xref}\].[¶](#section-4.5-2){.pilcrow}
:::
:::

::: {#acp}
::: {#section-4.6 .section}
### [4.6.](#section-4.6){.section-number .selfRef} [Autonomic Control Plane](#name-autonomic-control-plane){.section-name .selfRef} {#name-autonomic-control-plane}

The ACP carries the control protocols in an Autonomic Network. In the
architecture described in this document, it is implemented as an overlay
network. The document \"[An Autonomic Control Plane
(ACP)](#RFC8994){.xref}\" \[[RFC8994](#RFC8994){.xref}\] describes the
implementation details suggested in this document. This document uses
the term \"overlay\" to mean a set of point-to-point adjacencies
congruent with the underlying interconnection topology. The terminology
may not be aligned with a common usage of the term \"overlay\" in the
routing context. See \[[RFC8368](#RFC8368){.xref}\] for uses cases for
the ACP.[¶](#section-4.6-1){.pilcrow}
:::
:::

::: {#info-distri}
::: {#section-4.7 .section}
### [4.7.](#section-4.7){.section-number .selfRef} [Information Distribution (\*)](#name-information-distribution){.section-name .selfRef} {#name-information-distribution}

Certain forms of information require distribution across an autonomic
domain. The distribution of information runs inside the ACP. For
example, Intent is distributed across an autonomic domain, as explained
in \[[RFC7575](#RFC7575){.xref}\].[¶](#section-4.7-1){.pilcrow}

Intent is the policy language of an Autonomic Network (see also [Section
7.2](#intent){.xref}). It is a high-level policy and should change only
infrequently (order of days). Therefore, information such as Intent
should be simply flooded to all nodes in an autonomic domain, and there
is currently no perceived need to have more targeted distribution
methods. Intent is also expected to be monolithic and flooded as a
whole. One possible method for distributing Intent, as well as other
forms of data, is discussed in
\[[GRASP-DISTRIB](#I-D.ietf-anima-grasp-distribution){.xref}\]. Intent
and information distribution are not part of the ANIMA Working Group
charter.[¶](#section-4.7-2){.pilcrow}
:::
:::
:::
:::

::: {#trust}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Security and Trust Infrastructure](#name-security-and-trust-infrastr){.section-name .selfRef} {#name-security-and-trust-infrastr}

An Autonomic Network is self-protecting. All protocols are secure by
default, without the requirement for the administrator to explicitly
configure security, with the exception of setting up a PKI
infrastructure.[¶](#section-5-1){.pilcrow}

Autonomic nodes have direct interactions between themselves, which must
be secured. Since an Autonomic Network does not rely on configuration,
it is not an option to configure, for example, pre-shared keys. A trust
infrastructure such as a PKI infrastructure must be in place. This
section describes the principles of this trust infrastructure. In this
first phase of Autonomic Networking, a device is either 1) within the
trust domain and fully trusted or 2) outside the trust domain and fully
untrusted.[¶](#section-5-2){.pilcrow}

The default method to automatically bring up a trust infrastructure is
defined in the document \"[Bootstrapping Remote Secure Key
Infrastructure (BRSKI)](#RFC8995){.xref}\"
\[[RFC8995](#RFC8995){.xref}\]. The ASAs required for this enrollment
process are described in [Section 6.3](#specific-asas){.xref}. An
autonomic node must implement the enrollment and join proxy ASAs. The
registrar ASA may be implemented only on a subset of
nodes.[¶](#section-5-3){.pilcrow}

::: {#pki}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Public Key Infrastructure](#name-public-key-infrastructure){.section-name .selfRef} {#name-public-key-infrastructure}

An autonomic domain uses a PKI model. The root of trust is a
Certification Authority (CA). A registrar acts as a Registration
Authority (RA).[¶](#section-5.1-1){.pilcrow}

A minimum implementation of an autonomic domain contains one CA, one
registrar, and network elements.[¶](#section-5.1-2){.pilcrow}
:::
:::

::: {#cert}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Domain Certificate](#name-domain-certificate){.section-name .selfRef} {#name-domain-certificate}

Each device in an autonomic domain uses a domain certificate (LDevID) to
prove its identity. A new device uses its manufacturer-provided
certificate (IDevID) during bootstrap to obtain a domain certificate.
\[[RFC8995](#RFC8995){.xref}\] describes how a new device receives a
domain certificate and defines the certificate
format.[¶](#section-5.2-1){.pilcrow}
:::
:::

::: {#masa}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [MASA](#name-masa){.section-name .selfRef} {#name-masa}

The Manufacturer Authorized Signing Authority (MASA) is a trusted
service for bootstrapping devices. The purpose of the MASA is to provide
ownership tracking of devices in a domain. The MASA provides audit,
authorization, and ownership tokens to the registrar during the
bootstrap process to assist in the authentication of devices attempting
to join an autonomic domain and to allow a joining device to validate
whether it is joining the correct domain. The details for MASA service,
security, and usage are defined in
\[[RFC8995](#RFC8995){.xref}\].[¶](#section-5.3-1){.pilcrow}
:::
:::

::: {#sub-domains}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [Subdomains (\*)](#name-subdomains){.section-name .selfRef} {#name-subdomains}

By default, subdomains are treated as different domains. This implies no
trust between a domain and its subdomains and no trust between
subdomains of the same domain. Specifically, no ACP is built, and Intent
is valid only for the domain it is defined for
explicitly.[¶](#section-5.4-1){.pilcrow}

In the ANIMA Working Group charter, alternative trust models should be
defined, for example, to allow full or limited trust between domain and
subdomain.[¶](#section-5.4-2){.pilcrow}
:::
:::

::: {#cross-domain}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [Cross-Domain Functionality (\*)](#name-cross-domain-functionality){.section-name .selfRef} {#name-cross-domain-functionality}

By default, different domains do not interoperate, no ACP is built, and
no trust is implied between them.[¶](#section-5.5-1){.pilcrow}

In the future, models can be established where other domains can be
trusted in full or for limited operations between the
domains.[¶](#section-5.5-2){.pilcrow}
:::
:::
:::
:::

::: {#asa}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Autonomic Service Agents (ASAs)](#name-autonomic-service-agents-as){.section-name .selfRef} {#name-autonomic-service-agents-as}

This section describes how autonomic services run on top of the
ANI.[¶](#section-6-1){.pilcrow}

::: {#asa-general}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [General Description of an ASA](#name-general-description-of-an-a){.section-name .selfRef} {#name-general-description-of-an-a}

An ASA is defined in \[[RFC7575](#RFC7575){.xref}\] as \"An agent
implemented on an autonomic node that implements an autonomic function,
either in part (in the case of a distributed function) or whole\". Thus,
it is a process that makes use of the features provided by the ANI to
achieve its own goals, usually including interaction with other ASAs via
GRASP \[[RFC8990](#RFC8990){.xref}\] or otherwise. Of course, it also
interacts with the specific targets of its function, using any suitable
mechanism. Unless its function is very simple, the ASA will need to
handle overlapping asynchronous operations. It may therefore be a quite
complex piece of software in its own right, forming part of the
application layer above the ANI. ASA design guidelines are available in
\[[ASA-GUIDELINES](#I-D.ietf-anima-asa-guidelines){.xref}\].[¶](#section-6.1-1){.pilcrow}

Thus, we can distinguish at least three classes of
ASAs:[¶](#section-6.1-2){.pilcrow}

-   [Simple ASAs with a small footprint that could run
    anywhere.[¶](#section-6.1-3.1){.pilcrow}]{#section-6.1-3.1}
-   [Complex, possibly multi-threaded ASAs that have a significant
    resource requirement and will only run on selected
    nodes.[¶](#section-6.1-3.2){.pilcrow}]{#section-6.1-3.2}
-   [A few \'infrastructure ASAs\' that use basic ANI features in
    support of the ANI itself, which must run in all autonomic nodes.
    These are outlined in the following
    sections.[¶](#section-6.1-3.3){.pilcrow}]{#section-6.1-3.3}

Autonomic nodes, and therefore their ASAs, know their own capabilities
and restrictions, derived from hardware, firmware, or pre-installed
software; they are \"self-aware\".[¶](#section-6.1-4){.pilcrow}

The role of an autonomic node depends on Intent and on the surrounding
network behaviors, which may include forwarding behaviors, aggregation
properties, topology location, bandwidth, tunnel or translation
properties, etc. For example, a node may decide to act as a backup node
for a neighbor, if its capabilities allow it to do
so.[¶](#section-6.1-5){.pilcrow}

Following an initial discovery phase, the node\'s properties and those
of its neighbors are the foundation of the behavior of a specific node.
A node and its ASAs have no pre-configuration for the particular network
in which they are installed.[¶](#section-6.1-6){.pilcrow}

Since all ASAs will interact with the ANI, they will depend on
appropriate application programming interfaces (APIs). It is desirable
that ASAs are portable between operating systems, so these APIs need to
be universal. An API for GRASP is described in
\[[RFC8991](#RFC8991){.xref}\].[¶](#section-6.1-7){.pilcrow}

ASAs will, in general, be designed and coded by experts in a particular
technology and use case, not by experts in the ANI and its components.
Also, they may be coded in a variety of programming languages, in
particular, languages that support object constructs as well as
traditional variables and structures. The APIs should be designed with
these factors in mind.[¶](#section-6.1-8){.pilcrow}

It must be possible to run ASAs as non-privileged (user space) processes
except for those (such as the infrastructure ASAs) that necessarily
require kernel privilege. Also, it is highly desirable that ASAs can be
dynamically loaded on a running node.[¶](#section-6.1-9){.pilcrow}

Since autonomic systems must be self-repairing, it is of great
importance that ASAs are coded using robust programming techniques. All
runtime error conditions must be caught, leading to suitable minimally
disruptive recovery actions, but a complete restart of the ASA must also
be considered. Conditions such as discovery failures or negotiation
failures must be treated as routine, with the ASA retrying the failed
operation, preferably with an exponential back-off in the case of
persistent errors. When multiple threads are started within an ASA,
these threads must be monitored for failures and hangups, and
appropriate action taken. Attention must be given to garbage collection,
so that ASAs never run out of resources. There is assumed to be no human
operator; again, in the worst case, every ASA must be capable of
restarting itself.[¶](#section-6.1-10){.pilcrow}

ASAs will automatically benefit from the security provided by the ANI,
specifically by the ACP and by GRASP. However, beyond that, they are
responsible for their own security, especially when communicating with
the specific targets of their function. Therefore, the design of an ASA
must include a security analysis beyond \'use ANI
security\'.[¶](#section-6.1-11){.pilcrow}
:::
:::

::: {#asa-life-cycle}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [ASA Life-Cycle Management](#name-asa-life-cycle-management){.section-name .selfRef} {#name-asa-life-cycle-management}

ASAs operating on a given ANI may come from different providers and
pursue different objectives. Management of ASAs and their interactions
with the ANI should follow the same operating principles and thus comply
to a generic life-cycle management model.[¶](#section-6.2-1){.pilcrow}

The ASA life cycle provides standard processes
to:[¶](#section-6.2-2){.pilcrow}

-   [install ASA: copy the ASA code onto the node and start
    it.[¶](#section-6.2-3.1){.pilcrow}]{#section-6.2-3.1}
-   [deploy ASA: associate the ASA instance with a (some) managed
    network device(s) (or network
    function).[¶](#section-6.2-3.2){.pilcrow}]{#section-6.2-3.2}
-   [control ASA execution: when and how an ASA executes its control
    loop.[¶](#section-6.2-3.3){.pilcrow}]{#section-6.2-3.3}

This life cycle will also define which interactions ASAs have with the
ANI in between the different states. The noticeable interactions
are:[¶](#section-6.2-4){.pilcrow}

-   [Self-description of ASA instances at the end of deployment: Its
    format needs to define the information required for the management
    of ASAs by ANI
    entities.[¶](#section-6.2-5.1){.pilcrow}]{#section-6.2-5.1}
-   [Control of the ASA control loop during the operation: Signaling has
    to carry formatted messages to control ASA execution (at least
    starting and stopping the control
    loop).[¶](#section-6.2-5.2){.pilcrow}]{#section-6.2-5.2}
:::
:::

::: {#specific-asas}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Specific ASAs for the Autonomic Networking Infrastructure](#name-specific-asas-for-the-auton){.section-name .selfRef} {#name-specific-asas-for-the-auton}

The following functions provide essential, required functionality in an
Autonomic Network and are therefore mandatory to implement on
unconstrained autonomic nodes. They are described here as ASAs that
include the underlying infrastructure components, but implementation
details might vary.[¶](#section-6.3-1){.pilcrow}

The first three (pledge, join proxy, join registrar) support together
the trust enrollment process described in [Section 5](#trust){.xref}.
For details see
\[[RFC8995](#RFC8995){.xref}\].[¶](#section-6.3-2){.pilcrow}

::: {#enrollment}
::: {#section-6.3.1 .section}
#### [6.3.1.](#section-6.3.1){.section-number .selfRef} [Enrollment ASAs](#name-enrollment-asas){.section-name .selfRef} {#name-enrollment-asas}

::: {#enrollment-pledge}
::: {#section-6.3.1.1 .section}
##### [6.3.1.1.](#section-6.3.1.1){.section-number .selfRef} [The Pledge ASA](#name-the-pledge-asa){.section-name .selfRef} {#name-the-pledge-asa}

This ASA includes the function of an autonomic node that bootstraps into
the domain with the help of a join proxy ASA (see below). Such a node is
known as a pledge during the enrollment process. This ASA must be
installed by default on all nodes that require an autonomic zero-touch
bootstrap.[¶](#section-6.3.1.1-1){.pilcrow}
:::
:::

::: {#join-assitant}
::: {#section-6.3.1.2 .section}
##### [6.3.1.2.](#section-6.3.1.2){.section-number .selfRef} [The Join Proxy ASA](#name-the-join-proxy-asa){.section-name .selfRef} {#name-the-join-proxy-asa}

This ASA includes the function of an autonomic node that helps
non-enrolled, adjacent devices to enroll into the domain. This ASA must
be installed on all nodes, although only one join proxy needs to be
active on a given LAN. See also
\[[RFC8995](#RFC8995){.xref}\].[¶](#section-6.3.1.2-1){.pilcrow}
:::
:::

::: {#enrollment-registrar}
::: {#section-6.3.1.3 .section}
##### [6.3.1.3.](#section-6.3.1.3){.section-number .selfRef} [The Join Registrar ASA](#name-the-join-registrar-asa){.section-name .selfRef} {#name-the-join-registrar-asa}

This ASA includes the Join Registrar function in an Autonomic Network.
This ASA does not need to be installed on all nodes, but only on nodes
that implement the Join Registrar
function.[¶](#section-6.3.1.3-1){.pilcrow}
:::
:::
:::
:::

::: {#acp-asa}
::: {#section-6.3.2 .section}
#### [6.3.2.](#section-6.3.2){.section-number .selfRef} [ACP ASA](#name-acp-asa){.section-name .selfRef} {#name-acp-asa}

This ASA includes the ACP function in an Autonomic Network. In
particular, it acts to discover other potential ACP nodes and to support
the establishment and teardown of ACP channels. This ASA must be
installed on all nodes. For details, see [Section 4.6](#acp){.xref} and
\[[RFC8994](#RFC8994){.xref}\].[¶](#section-6.3.2-1){.pilcrow}
:::
:::

::: {#intent-asa}
::: {#section-6.3.3 .section}
#### [6.3.3.](#section-6.3.3){.section-number .selfRef} [Information Distribution ASA (\*)](#name-information-distribution-as){.section-name .selfRef} {#name-information-distribution-as}

This ASA is currently out of scope in the ANIMA Working Group charter
and is provided here only as background
information.[¶](#section-6.3.3-1){.pilcrow}

This ASA includes the information distribution function in an Autonomic
Network. In particular, it acts to announce the availability of Intent
and other information to all other autonomic nodes. This ASA does not
need to be installed on all nodes, but only on nodes that implement the
information distribution function. For details, see [Section
4.7](#info-distri){.xref}.[¶](#section-6.3.3-2){.pilcrow}

Note that information distribution can be implemented as a function in
any ASA. See
\[[GRASP-DISTRIB](#I-D.ietf-anima-grasp-distribution){.xref}\] for more
details on how information is suggested to be
distributed.[¶](#section-6.3.3-3){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#management}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Management and Programmability](#name-management-and-programmabil){.section-name .selfRef} {#name-management-and-programmabil}

This section describes how an Autonomic Network is managed and
programmed.[¶](#section-7-1){.pilcrow}

::: {#management-general}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Managing a (Partially) Autonomic Network](#name-managing-a-partially-autono){.section-name .selfRef} {#name-managing-a-partially-autono}

Autonomic management usually coexists with traditional management
methods in most networks. Thus, autonomic behavior will be defined for
individual functions in most environments. Examples of overlap
are:[¶](#section-7.1-1){.pilcrow}

-   [Autonomic functions can use traditional methods and protocols
    (e.g., SNMP and the Network Configuration Protocol (NETCONF)) to
    perform management tasks, inside and outside the
    ACP.[¶](#section-7.1-2.1){.pilcrow}]{#section-7.1-2.1}
-   [Autonomic functions can conflict with behavior enforced by the same
    traditional methods and
    protocols.[¶](#section-7.1-2.2){.pilcrow}]{#section-7.1-2.2}
-   [Traditional functions can use the ACP, for example, if reachability
    on the data plane is not (yet)
    established.[¶](#section-7.1-2.3){.pilcrow}]{#section-7.1-2.3}

The autonomic Intent is defined at a high level of abstraction. However,
since it is necessary to address individual managed elements, autonomic
management needs to communicate in lower-level interactions (e.g.,
commands and requests). For example, it is expected that the
configuration of such elements be performed using NETCONF and YANG
modules as well as the monitoring be executed through SNMP and
MIBs.[¶](#section-7.1-3){.pilcrow}

Conflict can occur between autonomic default behavior, autonomic Intent,
and traditional management methods. Conflict resolution is achieved in
autonomic management through prioritization
\[[RFC7575](#RFC7575){.xref}\]. The rationale is that manual and
node-based management have a higher priority than autonomic management.
Thus, the autonomic default behavior has the lowest priority, then comes
the autonomic Intent (medium priority), and, finally, the highest
priority is taken by node-specific network management methods, such as
the use of command-line interfaces.[¶](#section-7.1-4){.pilcrow}
:::
:::

::: {#intent}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Intent (\*)](#name-intent){.section-name .selfRef} {#name-intent}

Intent is not covered in the current implementation specifications. This
section discusses a topic for further
research.[¶](#section-7.2-1){.pilcrow}

This section gives an overview of Intent and how it is managed. Intent
and Policy-Based Network Management (PBNM) is already described inside
the IETF (e.g., Policy Core Information Model (PCIM)) and in other
Standards Development Organizations (SDOs) (e.g., the Distributed
Management Task Force (DMTF)).[¶](#section-7.2-2){.pilcrow}

Intent can be described as an abstract, declarative, high-level policy
used to operate an autonomic domain, such as an enterprise network
\[[RFC7575](#RFC7575){.xref}\]. Intent should be limited to high-level
guidance only; thus, it does not directly define a policy for every
network element separately.[¶](#section-7.2-3){.pilcrow}

Intent can be refined to lower-level policies using different
approaches. This is expected in order to adapt the Intent to the
capabilities of managed devices. Intent may contain role or function
information, which can be translated to specific nodes
\[[RFC7575](#RFC7575){.xref}\]. One of the possible refinements of the
Intent is using Event-Condition-Action (ECA)
rules.[¶](#section-7.2-4){.pilcrow}

Different parameters may be configured for Intent. These parameters are
usually provided by the human operator. Some of these parameters can
influence the behavior of specific autonomic functions as well as the
way the Intent is used to manage the autonomic
domain.[¶](#section-7.2-5){.pilcrow}

Intent is discussed in more detail in
\[[ANIMA-INTENT](#I-D.du-anima-an-intent){.xref}\]. Intent as well as
other types of information are distributed via GRASP; see
\[[GRASP-DISTRIB](#I-D.ietf-anima-grasp-distribution){.xref}\].[¶](#section-7.2-6){.pilcrow}
:::
:::

::: {#reporting}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Aggregated Reporting (\*)](#name-aggregated-reporting){.section-name .selfRef} {#name-aggregated-reporting}

Aggregated reporting is not covered in the current implementation
specifications. This section discusses a topic for further
research.[¶](#section-7.3-1){.pilcrow}

An Autonomic Network should minimize the need for human intervention. In
terms of how the network should behave, this is done through an
autonomic Intent provided by the human administrator. In an analogous
manner, the reports that describe the operational status of the network
should aggregate the information produced in different network elements
in order to present the effectiveness of autonomic Intent enforcement.
Therefore, reporting in an Autonomic Network should happen on a
network-wide basis
\[[RFC7575](#RFC7575){.xref}\].[¶](#section-7.3-2){.pilcrow}

Multiple simultaneous events can occur in an Autonomic Network in the
same way they can happen in a traditional network. However, when
reporting to a human administrator, such events should be aggregated to
avoid notifications about individual managed elements. In this context,
algorithms may be used to determine what should be reported (e.g.,
filtering), how it should be reported, and how different events are
related to each other. Besides that, an event in an individual element
can be compensated by changes in other elements to maintain a
network-wide target that is described in the autonomic
Intent.[¶](#section-7.3-3){.pilcrow}

Reporting in an Autonomic Network may be at the same abstraction level
as Intent. In this context, the aggregated view of the current
operational status of an Autonomic Network can be used to switch to
different management modes. Despite the fact that autonomic management
should minimize the need for user intervention, some events may need to
be addressed by the actions of a human
administrator.[¶](#section-7.3-4){.pilcrow}
:::
:::

::: {#feedback}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [Feedback Loops to NOC (\*)](#name-feedback-loops-to-noc){.section-name .selfRef} {#name-feedback-loops-to-noc}

Feedback loops are required in an Autonomic Network to allow the
intervention of a human administrator or central control systems while
maintaining a default behavior. Through a feedback loop, an
administrator must be prompted with a default action and has the
possibility to acknowledge or override the proposed default
action.[¶](#section-7.4-1){.pilcrow}

Unidirectional notifications to the Network Operations Center (NOC) that
do not propose any default action and do not allow an override as part
of the transaction are considered like traditional notification
services, such as syslog. They are expected to coexist with autonomic
methods but are not covered in this
document.[¶](#section-7.4-2){.pilcrow}
:::
:::

::: {#control-loops}
::: {#section-7.5 .section}
### [7.5.](#section-7.5){.section-number .selfRef} [Control Loops (\*)](#name-control-loops){.section-name .selfRef} {#name-control-loops}

Control loops are not covered in the current implementation
specifications. This section discusses a topic for further
research.[¶](#section-7.5-1){.pilcrow}

Control loops are used in Autonomic Networking to provide a generic
mechanism to enable the autonomic system to adapt (on its own) to
various factors that can change the goals that the Autonomic Network is
trying to achieve or how those goals are achieved. For example, as user
needs, business goals, and the ANI itself changes, self- adaptation
enables the ANI to change the services and resources it makes available
to adapt to these changes.[¶](#section-7.5-2){.pilcrow}

Control loops operate to continuously observe and collect data that
enables the autonomic management system to understand changes to the
behavior of the system being managed and then provide actions to move
the state of the system being managed toward a common goal.
Self-adaptive systems move decision making from static, pre-defined
commands to dynamic processes computed at
runtime.[¶](#section-7.5-3){.pilcrow}

Most autonomic systems use a closed control loop with feedback. Such
control loops should be able to be dynamically changed at runtime to
adapt to changing user needs, business goals, and changes in the
ANI.[¶](#section-7.5-4){.pilcrow}
:::
:::

::: {#apis}
::: {#section-7.6 .section}
### [7.6.](#section-7.6){.section-number .selfRef} [APIs (\*)](#name-apis){.section-name .selfRef} {#name-apis}

\[[RFC8991](#RFC8991){.xref}\] defines a conceptual outline for an API
for the GeneRic Autonomic Signaling Protocol (GRASP). This conceptual
API is designed for ASAs to communicate with other ASAs through GRASP.
Full Standards Track API specifications are not covered in the current
implementation specifications.[¶](#section-7.6-1){.pilcrow}

Most APIs are static, meaning that they are pre-defined and represent an
invariant mechanism for operating with data. An Autonomic Network should
be able to use dynamic APIs in addition to static
APIs.[¶](#section-7.6-2){.pilcrow}

A dynamic API retrieves data using a generic mechanism and then enables
the client to navigate the retrieved data and operate on it. Such APIs
typically use introspection and/or reflection. Introspection enables
software to examine the type and properties of an object at runtime,
while reflection enables a program to manipulate the attributes,
methods, and/or metadata of an object.[¶](#section-7.6-3){.pilcrow}

APIs must be able to express and preserve the semantics of data models.
For example, software contracts \[[Meyer97](#Meyer97){.xref}\] are based
on the principle that a software-intensive system, such as an Autonomic
Network, is a set of communicating components whose interaction is based
on precisely defined specifications of the mutual obligations that
interacting components must respect. This typically includes
specifying:[¶](#section-7.6-4){.pilcrow}

-   [pre-conditions that must be satisfied before the method can start
    execution[¶](#section-7.6-5.1){.pilcrow}]{#section-7.6-5.1}
-   [post-conditions that must be satisfied when the method has finished
    execution[¶](#section-7.6-5.2){.pilcrow}]{#section-7.6-5.2}
-   [invariant attributes that must not change during the execution of
    the method[¶](#section-7.6-5.3){.pilcrow}]{#section-7.6-5.3}
:::
:::

::: {#data-model}
::: {#section-7.7 .section}
### [7.7.](#section-7.7){.section-number .selfRef} [Data Model (\*)](#name-data-model){.section-name .selfRef} {#name-data-model}

Data models are not covered in the current implementation
specifications. This section discusses a topic for further
research.[¶](#section-7.7-1){.pilcrow}

The following definitions of \"data model\" and \"information model\"
are adapted from
\[[SUPA-DATA](#I-D.ietf-supa-generic-policy-data-model){.xref}\].[¶](#section-7.7-2){.pilcrow}

An information model is a representation of concepts of interest to an
environment in a form that is independent of data repository, data
definition language, query language, implementation language, and
protocol. In contrast, a data model is a representation of concepts of
interest to an environment in a form that is dependent on data
repository, data definition language, query language, implementation
language, and protocol.[¶](#section-7.7-3){.pilcrow}

The utility of an information model is to define objects and their
relationships in a technology-neutral manner. This forms a consensual
vocabulary that the ANI and ASAs can use. A data model is then a
technology-specific mapping of all or part of the information model to
be used by all or part of the system.[¶](#section-7.7-4){.pilcrow}

A system may have multiple data models. Operational Support Systems, for
example, typically have multiple types of repositories, such as SQL and
NoSQL, to take advantage of the different properties of each. If
multiple data models are required by an autonomic system, then an
information model should be used to ensure that the concepts of each
data model can be related to each other without technological
bias.[¶](#section-7.7-5){.pilcrow}

A data model is essential for certain types of functions, such as a
Model-Reference Adaptive Control Loop (MRACL). More generally, a data
model can be used to define the objects, attributes, methods, and
relationships of a software system (e.g., the ANI, an autonomic node, or
an ASA). A data model can be used to help design an API, as well as any
language used to interface to the Autonomic
Network.[¶](#section-7.7-6){.pilcrow}
:::
:::
:::
:::

::: {#coordination}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Coordination between Autonomic Functions (\*)](#name-coordination-between-autono){.section-name .selfRef} {#name-coordination-between-autono}

Coordination between autonomic functions is not covered in the current
implementation specifications. This section discusses a topic for
further research.[¶](#section-8-1){.pilcrow}

::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Coordination Problem (\*)](#name-coordination-problem){.section-name .selfRef} {#name-coordination-problem}

Different autonomic functions may conflict in setting certain
parameters. For example, an energy efficiency function may want to shut
down a redundant link, while a load-balancing function would not want
that to happen. The administrator must be able to understand and resolve
such interactions to steer Autonomic Network performance to a given
(intended) operational point.[¶](#section-8.1-1){.pilcrow}

Several interaction types may exist among autonomic functions, for
example:[¶](#section-8.1-2){.pilcrow}

-   [Cooperation: An autonomic function can improve the behavior or
    performance of another autonomic function, such as a traffic
    forecasting function used by a traffic allocation
    function.[¶](#section-8.1-3.1){.pilcrow}]{#section-8.1-3.1}
-   [Dependency: An autonomic function cannot work without another one
    being present or accessible in the Autonomic
    Network.[¶](#section-8.1-3.2){.pilcrow}]{#section-8.1-3.2}
-   [Conflict: A metric value conflict is a conflict where one metric is
    influenced by parameters of different autonomic functions. A
    parameter value conflict is a conflict where one parameter is
    modified by different autonomic
    functions.[¶](#section-8.1-3.3){.pilcrow}]{#section-8.1-3.3}

Solving the coordination problem beyond one-by-one cases can rapidly
become intractable for large networks. Specifying a common functional
block on coordination is a first step to address the problem in a
systemic way. The coordination life cycle consists of three
states:[¶](#section-8.1-4){.pilcrow}

-   [At build-time, a \"static interaction map\" can be constructed on
    the relationship of functions and attributes. This map can be used
    to (pre-)define policies and priorities for identified
    conflicts.[¶](#section-8.1-5.1){.pilcrow}]{#section-8.1-5.1}
-   [At deploy-time, autonomic functions are not yet active/acting on
    the network. A \"dynamic interaction map\" is created for each
    instance of each autonomic function on a per-resource basis,
    including the actions performed and their relationships. This map
    provides the basis to identify conflicts that will happen at
    runtime, categorize them, and plan for the appropriate coordination
    strategies and
    mechanisms.[¶](#section-8.1-5.2){.pilcrow}]{#section-8.1-5.2}
-   [At runtime, when conflicts happen, arbitration is driven by the
    coordination strategies. Also, new dependencies can be observed and
    inferred, resulting in an update of the dynamic interaction map and
    adaptation of the coordination strategies and
    mechanisms.[¶](#section-8.1-5.3){.pilcrow}]{#section-8.1-5.3}

Multiple coordination strategies and mechanisms exist and can be
devised. The set ranges from basic approaches (such as random process or
token-based process), to approaches based on time separation and
hierarchical optimization, to more complex approaches (such as
multi-objective optimization and other control theory approaches and
algorithm families).[¶](#section-8.1-6){.pilcrow}
:::

::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Coordination Functional Block (\*)](#name-coordination-functional-blo){.section-name .selfRef} {#name-coordination-functional-blo}

A common coordination functional block is a desirable component of the
ANIMA reference model. It provides a means to ensure network properties
and predictable performance or behavior, such as stability and
convergence, in the presence of several interacting autonomic
functions.[¶](#section-8.2-1){.pilcrow}

A common coordination function requires:[¶](#section-8.2-2){.pilcrow}

-   [A common description of autonomic functions, their attributes, and
    life cycle.[¶](#section-8.2-3.1){.pilcrow}]{#section-8.2-3.1}
-   [A common representation of information and knowledge (e.g.,
    interaction maps).[¶](#section-8.2-3.2){.pilcrow}]{#section-8.2-3.2}
-   [A common \"control/command\" interface between the coordination
    \"agent\" and the autonomic
    functions.[¶](#section-8.2-3.3){.pilcrow}]{#section-8.2-3.3}

Guidelines, recommendations, or BCPs can also be provided for aspects
pertaining to the coordination strategies and
mechanisms.[¶](#section-8.2-4){.pilcrow}
:::
:::
:::

::: {#security}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

In this section, we distinguish outsider and insider attacks. In an
outsider attack, all network elements and protocols are securely managed
and operating, and an outside attacker can sniff packets in transit,
inject, and replay packets. In an insider attack, the attacker has
access to an autonomic node or other means (e.g., remote code execution
in the node by exploiting ACP-independent vulnerabilities in the node
platform) to produce arbitrary payloads on the protected ACP
channels.[¶](#section-9-1){.pilcrow}

If a system has vulnerabilities in the implementation or operation
(configuration), an outside attacker can exploit such vulnerabilities to
become an insider attacker.[¶](#section-9-2){.pilcrow}

::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Protection against Outsider Attacks](#name-protection-against-outsider){.section-name .selfRef} {#name-protection-against-outsider}

Here, we assume that all systems involved in an Autonomic Network are
secured and operated according to best current practices. These
protection methods comprise traditional security implementation and
operation methods (such as code security, strong randomization
algorithms, strong passwords, etc.) as well as mechanisms specific to an
Autonomic Network (such as a secured MASA
service).[¶](#section-9.1-1){.pilcrow}

Traditional security methods for both implementation and operation are
outside the scope of this document.[¶](#section-9.1-2){.pilcrow}

AN-specific protocols and methods must also follow traditional security
methods, in that all packets that can be sniffed or injected by an
outside attacker are:[¶](#section-9.1-3){.pilcrow}

-   [protected against
    modification[¶](#section-9.1-4.1){.pilcrow}]{#section-9.1-4.1}
-   [authenticated[¶](#section-9.1-4.2){.pilcrow}]{#section-9.1-4.2}
-   [protected against replay
    attacks[¶](#section-9.1-4.3){.pilcrow}]{#section-9.1-4.3}
-   [confidentiality protected
    (encrypted)[¶](#section-9.1-4.4){.pilcrow}]{#section-9.1-4.4}

In addition, the AN protocols should be robust against packet drops and
man-in-the-middle attacks.[¶](#section-9.1-5){.pilcrow}

How these requirements are met is covered in the AN Standards Track
documents that define the methods used, specifically
\[[RFC8990](#RFC8990){.xref}\], \[[RFC8994](#RFC8994){.xref}\], and
\[[RFC8995](#RFC8995){.xref}\].[¶](#section-9.1-6){.pilcrow}

Most AN messages run inside the cryptographically protected ACP. The
unprotected AN messages outside the ACP are limited to a simple
discovery method, defined in [Section
2.5.2](https://www.rfc-editor.org/rfc/rfc8990#section-2.5.2){.relref} of
\[[RFC8990](#RFC8990){.xref}\]: the Discovery Unsolicited Link-Local
(DULL) message, with detailed rules on its
usage.[¶](#section-9.1-7){.pilcrow}

If AN messages can be observed by a third party, they might reveal
valuable information about network configuration, security precautions
in use, individual users, and their traffic patterns. If encrypted, AN
messages might still reveal some information via traffic
analysis.[¶](#section-9.1-8){.pilcrow}
:::

::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Risk of Insider Attacks](#name-risk-of-insider-attacks){.section-name .selfRef} {#name-risk-of-insider-attacks}

An Autonomic Network consists of autonomic devices that form a
distributed self-managing system. Devices within a domain have
credentials issued from a common trust anchor and can use them to create
mutual trust. This means that any device inside a trust domain can by
default use all distributed functions in the entire autonomic domain in
a malicious way.[¶](#section-9.2-1){.pilcrow}

An inside attacker, or an outsider in the presence of protocol
vulnerabilities or insecure operation, has the following generic ways to
take control of an Autonomic Network:[¶](#section-9.2-2){.pilcrow}

-   [Introducing a fake device into the trust domain by subverting the
    authentication methods. This depends on the correct specification,
    implementation, and operation of the AN
    protocols.[¶](#section-9.2-3.1){.pilcrow}]{#section-9.2-3.1}
-   [Subverting a device that is already part of a trust domain and
    modifying its behavior. This threat is not specific to the solution
    discussed in this document and applies to all network
    solutions.[¶](#section-9.2-3.2){.pilcrow}]{#section-9.2-3.2}
-   [Exploiting potentially yet unknown protocol vulnerabilities in the
    AN or other protocols. This is also a generic threat that applies to
    all network
    solutions.[¶](#section-9.2-3.3){.pilcrow}]{#section-9.2-3.3}

The above threats are, in principle, comparable to other solutions: in
the presence of design, implementation, or operational errors, security
is no longer guaranteed. However, the distributed nature of AN,
specifically the ACP, increases the threat surface significantly. For
example, a compromised device may have full IP reachability to all other
devices inside the ACP and can use all AN methods and
protocols.[¶](#section-9.2-4){.pilcrow}

For the next phase of the ANIMA Working Group, it is therefore
recommended to introduce a subdomain security model to reduce the attack
surface and not expose a full domain to a potential intruder.
Furthermore, additional security mechanisms on the ASA level should be
considered for high-risk autonomic
functions.[¶](#section-9.2-5){.pilcrow}
:::
:::
:::

::: {#iana}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-10-1){.pilcrow}
:::
:::

::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-11.1 .section}
### [11.1.](#section-11.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[IDevID\]
:   [IEEE]{.refAuthor}, [\"IEEE Standard for Local and metropolitan area
    networks - Secure Device Identity\"]{.refTitle}, [IEEE
    802.1AR]{.seriesInfo}, \<<https://1.ieee802.org/security/802-1ar>\>.
:   

\[RFC8990\]
:   [Bormann, C.]{.refAuthor}, [Carpenter, B., Ed.]{.refAuthor}, and [B.
    Liu, Ed.]{.refAuthor}, [\"GeneRic Autonomic Signaling Protocol
    (GRASP)\"]{.refTitle}, [RFC 8990]{.seriesInfo}, [DOI
    10.17487/RFC8990]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc8990>\>.
:   

\[RFC8994\]
:   [Eckert, T., Ed.]{.refAuthor}, [Behringer, M., Ed.]{.refAuthor}, and
    [S. Bjarnason]{.refAuthor}, [\"An Autonomic Control Plane
    (ACP)\"]{.refTitle}, [RFC 8994]{.seriesInfo}, [DOI
    10.17487/RFC8994]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc8994>\>.
:   

\[RFC8995\]
:   [Pritikin, M.]{.refAuthor}, [Richardson, M.]{.refAuthor},
    [Eckert, T.]{.refAuthor}, [Behringer, M.]{.refAuthor}, and [K.
    Watsen]{.refAuthor}, [\"Bootstrapping Remote Secure Key
    Infrastructure (BRSKI)\"]{.refTitle}, [RFC 8995]{.seriesInfo}, [DOI
    10.17487/RFC8995]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc8995>\>.
:   
:::

::: {#section-11.2 .section}
### [11.2.](#section-11.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[ANIMA-INTENT\]
:   [Du, Z.]{.refAuthor}, [Jiang, S.]{.refAuthor}, [Nobre, J.
    C.]{.refAuthor}, [Ciavaglia, L.]{.refAuthor}, and [M.
    Behringer]{.refAuthor}, [\"ANIMA Intent Policy and
    Format\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-du-anima-an-intent-05]{.seriesInfo}, 14
    February 2017,
    \<<https://tools.ietf.org/html/draft-du-anima-an-intent-05>\>.
:   

\[ASA-GUIDELINES\]
:   [Carpenter, B.]{.refAuthor}, [Ciavaglia, L.]{.refAuthor},
    [Jiang, S.]{.refAuthor}, and [P. Peloso]{.refAuthor}, [\"Guidelines
    for Autonomic Service Agents\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-anima-asa-guidelines-00]{.seriesInfo}, 14 November 2020,
    \<<https://tools.ietf.org/html/draft-ietf-anima-asa-guidelines-00>\>.
:   

\[GRASP-DISTRIB\]
:   [Liu, B., Ed.]{.refAuthor}, [Xiao, X., Ed.]{.refAuthor},
    [Hecker, A.]{.refAuthor}, [Jiang, S.]{.refAuthor},
    [Despotovic, Z.]{.refAuthor}, and [B. Carpenter]{.refAuthor},
    [\"Information Distribution over GRASP\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-anima-grasp-distribution-02]{.seriesInfo}, 8 March 2021,
    \<<https://tools.ietf.org/html/draft-ietf-anima-grasp-distribution-02>\>.
:   

\[Meyer97\]
:   [Meyer, B.]{.refAuthor}, [\"Object-Oriented Software Construction
    (2nd edition)\"]{.refTitle}, [Prentice Hall]{.refContent}, [ISBN
    978-0136291558]{.seriesInfo}, 1997.
:   

\[RFC7575\]
:   [Behringer, M.]{.refAuthor}, [Pritikin, M.]{.refAuthor},
    [Bjarnason, S.]{.refAuthor}, [Clemm, A.]{.refAuthor},
    [Carpenter, B.]{.refAuthor}, [Jiang, S.]{.refAuthor}, and [L.
    Ciavaglia]{.refAuthor}, [\"Autonomic Networking: Definitions and
    Design Goals\"]{.refTitle}, [RFC 7575]{.seriesInfo}, [DOI
    10.17487/RFC7575]{.seriesInfo}, June 2015,
    \<<https://www.rfc-editor.org/info/rfc7575>\>.
:   

\[RFC7576\]
:   [Jiang, S.]{.refAuthor}, [Carpenter, B.]{.refAuthor}, and [M.
    Behringer]{.refAuthor}, [\"General Gap Analysis for Autonomic
    Networking\"]{.refTitle}, [RFC 7576]{.seriesInfo}, [DOI
    10.17487/RFC7576]{.seriesInfo}, June 2015,
    \<<https://www.rfc-editor.org/info/rfc7576>\>.
:   

\[RFC8368\]
:   [Eckert, T., Ed.]{.refAuthor} and [M. Behringer]{.refAuthor},
    [\"Using an Autonomic Control Plane for Stable Connectivity of
    Network Operations, Administration, and Maintenance
    (OAM)\"]{.refTitle}, [RFC 8368]{.seriesInfo}, [DOI
    10.17487/RFC8368]{.seriesInfo}, May 2018,
    \<<https://www.rfc-editor.org/info/rfc8368>\>.
:   

\[RFC8991\]
:   [Carpenter, B.]{.refAuthor}, [Liu, B., Ed.]{.refAuthor},
    [Wang, W.]{.refAuthor}, and [X. Gong]{.refAuthor}, [\"GeneRic
    Autonomic Signaling Protocol Application Program Interface (GRASP
    API)\"]{.refTitle}, [RFC 8991]{.seriesInfo}, [DOI
    10.17487/RFC8991]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc8991>\>.
:   

\[RFC8992\]
:   [Jiang, S., Ed.]{.refAuthor}, [Du, Z.]{.refAuthor},
    [Carpenter, B.]{.refAuthor}, and [Q. Sun]{.refAuthor}, [\"Autonomic
    IPv6 Edge Prefix Management in Large-Scale Networks\"]{.refTitle},
    [RFC 8992]{.seriesInfo}, [DOI 10.17487/RFC8992]{.seriesInfo}, May
    2021, \<<https://www.rfc-editor.org/info/rfc8992>\>.
:   

\[SUPA-DATA\]
:   [Halpern, J.]{.refAuthor} and [J. Strassner]{.refAuthor}, [\"Generic
    Policy Data Model for Simplified Use of Policy Abstractions
    (SUPA)\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft,
    draft-ietf-supa-generic-policy-data-model-04]{.seriesInfo}, 18 June
    2017,
    \<<https://tools.ietf.org/html/draft-ietf-supa-generic-policy-data-model-04>\>.
:   
:::
:::

::: {#ack}
::: {#section-appendix.a .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

The following people provided feedback and input to this document:
[Sheng Jiang]{.contact-name}, [Roberta Maglione]{.contact-name},
[Jonathan Hansford]{.contact-name}, [Jason Coleman]{.contact-name}, and
[Artur Hecker]{.contact-name}. Useful reviews were made by [Joel
Halpern]{.contact-name}, [Radia Perlman]{.contact-name}, [Tianran
Zhou]{.contact-name}, and [Christian
Hopps]{.contact-name}.[¶](#section-appendix.a-1){.pilcrow}
:::
:::

::: {#contributors}
::: {#section-appendix.b .section}
## [Contributors](#name-contributors){.section-name .selfRef} {#name-contributors}

Significant contributions to this document were made by [John
Strassner]{.contact-name} (Huawei), [Bing Liu]{.contact-name} (Huawei),
and [Pierre Peloso]{.contact-name}
(Nokia).[¶](#section-appendix.b-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.c .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Michael H. Behringer ([editor]{.role})]{.fn .nameRole}
:::

::: email
Email: <Michael.H.Behringer@gmail.com>
:::

::: {.left dir="auto"}
[Brian Carpenter]{.fn .nameRole}
:::

::: {.left dir="auto"}
[School of Computer Science\
University of Auckland\
PB 92019]{.street-address}
:::

::: {.left dir="auto"}
[Auckland]{.locality} [1142]{.postal-code}
:::

::: {.left dir="auto"}
[New Zealand]{.country-name}
:::

::: email
Email: <brian.e.carpenter@gmail.com>
:::

::: {.left dir="auto"}
[Toerless Eckert]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Futurewei USA]{.org}
:::

::: {.left dir="auto"}
[2330 Central Expy]{.street-address}
:::

::: {.left dir="auto"}
[Santa Clara]{.locality}, [CA]{.region} [95050]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <tte+ietf@cs.fau.de>
:::

::: {.left dir="auto"}
[Laurent Ciavaglia]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Nokia]{.org}
:::

::: {.left dir="auto"}
[Villarceaux]{.street-address}
:::

::: {.left dir="auto"}
[91460]{.postal-code} [Nozay]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <laurent.ciavaglia@nokia.com>
:::

::: {.left dir="auto"}
[Jéferson Campos Nobre]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Federal University of Rio Grande do Sul (UFRGS)]{.org}
:::

::: {.left dir="auto"}
[Av. Bento Gonçalves, 9500]{.street-address}
:::

::: {.left dir="auto"}
[Porto Alegre]{.locality}-[RS]{.region}
:::

::: {.left dir="auto"}
[91501-970]{.postal-code}
:::

::: {.left dir="auto"}
[Brazil]{.country-name}
:::

::: email
Email: <jcnobre@inf.ufrgs.br>
:::
:::
:::
