  RFC 8844             SDP UKS           January 2021
  -------------------- ----------------- --------------
  Thomson & Rescorla   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8844](https://www.rfc-editor.org/rfc/rfc8844){.eref}

Updates:
:   [8122](https://www.rfc-editor.org/rfc/rfc8122){.eref}

Category:
:   Standards Track

Published:
:   January 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    M. Thomson
    :::

    ::: org
    Mozilla
    :::
    :::

    ::: author
    ::: author-name
    E. Rescorla
    :::

    ::: org
    Mozilla
    :::
    :::
:::

# RFC 8844 {#rfcnum}

# Unknown Key-Share Attacks on Uses of TLS with the Session Description Protocol (SDP) {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes unknown key-share attacks on the use of Datagram
Transport Layer Security for the Secure Real-Time Transport Protocol
(DTLS-SRTP). Similar attacks are described on the use of DTLS-SRTP with
the identity bindings used in Web Real-Time Communications (WebRTC) and
SIP identity. These attacks are difficult to mount, but they cause a
victim to be misled about the identity of a communicating peer. This
document defines mitigation techniques that implementations of RFC 8122
are encouraged to deploy.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8844>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Unknown Key-Share
    Attack](#name-unknown-key-share-attack){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Limits on Attack
        Feasibility](#name-limits-on-attack-feasibilit){.xref}[¶](#section-toc.1-1.2.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [Interactions with Key
        Continuity](#name-interactions-with-key-conti){.xref}[¶](#section-toc.1-1.2.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.3}
        [2.3](#section-2.3){.xref}.  [Third-Party Call
        Control](#name-third-party-call-control){.xref}[¶](#section-toc.1-1.2.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Unknown Key-Share Attack with Identity
    Bindings](#name-unknown-key-share-attack-wi){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Example](#name-example){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [The `external_id_hash` TLS
        Extension](#name-the-external_id_hash-tls-ex){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.3.2.2.2.1}
            [3.2.1](#section-3.2.1){.xref}.  [Calculating
            `external_id_hash` for WebRTC
            Identity](#name-calculating-external_id_has){.xref}[¶](#section-toc.1-1.3.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.2}
            [3.2.2](#section-3.2.2){.xref}.  [Calculating
            external_id_hash for
            PASSporT](#name-calculating-external_id_hash){.xref}[¶](#section-toc.1-1.3.2.2.2.2.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Unknown Key-Share Attack with
    Fingerprints](#name-unknown-key-share-attack-wit){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Example](#name-example-2){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Unique Session Identity
        Solution](#name-unique-session-identity-sol){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [The external_session_id TLS
        Extension](#name-the-external_session_id-tls){.xref}[¶](#section-toc.1-1.4.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Session
    Concatenation](#name-session-concatenation){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [References](#name-references){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.8.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.8.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [](#section-appendix.a){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [](#section-appendix.b){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The use of Transport Layer Security (TLS) \[[TLS13](#RFC8446){.xref}\]
with the Session Description Protocol (SDP) \[[SDP](#RFC4566){.xref}\]
is defined in \[[FINGERPRINT](#RFC8122){.xref}\]. Further use with
Datagram Transport Layer Security (DTLS) \[[DTLS](#RFC6347){.xref}\] and
the Secure Real-time Transport Protocol (SRTP)
\[[SRTP](#RFC3711){.xref}\] is defined as DTLS-SRTP
\[[DTLS-SRTP](#RFC5763){.xref}\].[¶](#section-1-1){.pilcrow}

In these specifications, key agreement is performed using TLS or DTLS,
with authentication being tied back to the session description (or SDP)
through the use of certificate fingerprints. Communication peers check
that a hash, or fingerprint, provided in the SDP matches the certificate
that is used in the TLS or DTLS handshake.[¶](#section-1-2){.pilcrow}

WebRTC identity (see [Section
7](https://www.rfc-editor.org/rfc/rfc8827#section-7){.relref} of
\[[WEBRTC-SEC](#RFC8827){.xref}\]) and SIP identity
\[[SIP-ID](#RFC8224){.xref}\] both provide a mechanism that binds an
external identity to the certificate fingerprints from a session
description. However, this binding is not integrity protected and is
therefore vulnerable to an identity misbinding attack, also known as an
unknown key-share (UKS) attack, where the attacker binds their identity
to the fingerprint of another entity. A successful attack leads to the
creation of sessions where peers are confused about the identity of the
participants.[¶](#section-1-3){.pilcrow}

This document describes a TLS extension that can be used in combination
with these identity bindings to prevent this
attack.[¶](#section-1-4){.pilcrow}

A similar attack is possible with the use of certificate fingerprints
alone. Though attacks in this setting are likely infeasible in existing
deployments due to the narrow preconditions (see [Section
2.1](#limits){.xref}), this document also describes mitigations for this
attack.[¶](#section-1-5){.pilcrow}

The mechanisms defined in this document are intended to strengthen the
protocol by preventing the use of unknown key-share attacks in
combination with other protocol or implementation vulnerabilities. RFC
8122 \[[FINGERPRINT](#RFC8122){.xref}\] is updated by this document to
recommend the use of these mechanisms.[¶](#section-1-6){.pilcrow}

This document assumes that signaling is integrity protected. However, as
[Section 7](https://www.rfc-editor.org/rfc/rfc8122#section-7){.relref}
of \[[FINGERPRINT](#RFC8122){.xref}\] explains, many deployments that
use SDP do not guarantee integrity of session signaling and so are
vulnerable to other attacks. \[[FINGERPRINT](#RFC8122){.xref}\] offers
key continuity mechanisms as a potential means of reducing exposure to
attack in the absence of integrity protection. [Section
2.2](#continuity){.xref} provides some analysis of the effect of key
continuity in relation to the described
attacks.[¶](#section-1-7){.pilcrow}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1-8){.pilcrow}
:::
:::

::: {#uks}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Unknown Key-Share Attack](#name-unknown-key-share-attack){.section-name .selfRef} {#name-unknown-key-share-attack}

In an unknown key-share attack \[[UKS](#UKS){.xref}\], a malicious
participant in a protocol claims to control a key that is in reality
controlled by some other actor. This arises when the identity associated
with a key is not properly bound to the key.[¶](#section-2-1){.pilcrow}

An endpoint that can acquire the certificate fingerprint of another
entity can advertise that fingerprint as their own in SDP. An attacker
can use a copy of that fingerprint to cause a victim to communicate with
another unaware victim, even though the first victim believes that it is
communicating with the attacker.[¶](#section-2-2){.pilcrow}

When the identity of communicating peers is established by higher-layer
signaling constructs, such as those in SIP identity
\[[SIP-ID](#RFC8224){.xref}\] or WebRTC
\[[WEBRTC-SEC](#RFC8827){.xref}\], this allows an attacker to bind their
own identity to a session with any other
entity.[¶](#section-2-3){.pilcrow}

The attacker obtains an identity assertion for an identity it controls,
but binds that to the fingerprint of one peer. The attacker is then able
to cause a TLS connection to be established where two victim endpoints
communicate. The victim that has its fingerprint copied by the attack
correctly believes that it is communicating with the other victim;
however, the other victim incorrectly believes that it is communicating
with the attacker.[¶](#section-2-4){.pilcrow}

An unknown key-share attack does not result in the attacker having
access to any confidential information exchanged between victims.
However, the failure in mutual authentication can enable other attacks.
A victim might send information to the wrong entity as a result. Where
information is interpreted in context, misrepresenting that context
could lead to the information being
misinterpreted.[¶](#section-2-5){.pilcrow}

A similar attack can be mounted based solely on the SDP `fingerprint`
attribute \[[FINGERPRINT](#RFC8122){.xref}\] without compromising the
integrity of the signaling channel.[¶](#section-2-6){.pilcrow}

This attack is an aspect of SDP-based protocols upon which the technique
known as third-party call control (3PCC) \[[RFC3725](#RFC3725){.xref}\]
relies. 3PCC exploits the potential for the identity of a signaling peer
to be different than the media peer, allowing the media peer to be
selected by the signaling peer. [Section 2.3](#byebye-3pcc){.xref}
describes the consequences of the mitigations described here for systems
that use 3PCC.[¶](#section-2-7){.pilcrow}

::: {#limits}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Limits on Attack Feasibility](#name-limits-on-attack-feasibilit){.section-name .selfRef} {#name-limits-on-attack-feasibilit}

The use of TLS with SDP depends on the integrity of session signaling.
Assuming signaling integrity limits the capabilities of an attacker in
several ways. In particular:[¶](#section-2.1-1){.pilcrow}

1.  [An attacker can only modify the parts of the session signaling that
    they are responsible for producing, namely their own offers and
    answers.[¶](#section-2.1-2.1){.pilcrow}]{#section-2.1-2.1}
2.  [No entity will successfully establish a session with a peer unless
    they are willing to participate in a session with that
    peer.[¶](#section-2.1-2.2){.pilcrow}]{#section-2.1-2.2}

The combination of these two constraints make the spectrum of possible
attacks quite limited. An attacker is only able to switch its own
certificate fingerprint for a valid certificate that is acceptable to
its peer. Attacks therefore rely on joining two separate sessions into a
single session. [Section 4](#fp){.xref} describes an attack on SDP
signaling under these constraints.[¶](#section-2.1-3){.pilcrow}

Systems that rely on strong identity bindings, such as those defined in
\[[WEBRTC](#WEBRTC){.xref}\] or \[[SIP-ID](#RFC8224){.xref}\], have a
different threat model, which admits the possibility of attack by an
entity with access to the signaling channel. Attacks under these
conditions are more feasible as an attacker is assumed to be able both
to observe and to modify signaling messages. [Section 3](#id){.xref}
describes an attack that assumes this threat
model.[¶](#section-2.1-4){.pilcrow}
:::
:::

::: {#continuity}
::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [Interactions with Key Continuity](#name-interactions-with-key-conti){.section-name .selfRef} {#name-interactions-with-key-conti}

Systems that use key continuity (as defined in [Section
15.1](https://www.rfc-editor.org/rfc/rfc6189#section-15.1){.relref} of
\[[ZRTP](#RFC6189){.xref}\] or as recommended in [Section
7](https://www.rfc-editor.org/rfc/rfc8122#section-7){.relref} of
\[[FINGERPRINT](#RFC8122){.xref}\]) might be able to detect an unknown
key-share attack if a session with either the attacker or the genuine
peer (i.e., the victim whose fingerprint was copied by an attacker) was
established in the past. Whether this is possible depends on how key
continuity is implemented.[¶](#section-2.2-1){.pilcrow}

Implementations that maintain a single database of identities with an
index of peer keys could discover that the identity saved for the peer
key does not match the claimed identity. Such an implementation could
notice the disparity between the actual keys (those copied from a
victim) and the expected keys (those of the
attacker).[¶](#section-2.2-2){.pilcrow}

In comparison, implementations that first match based on peer identity
could treat an unknown key-share attack as though their peer had used a
newly configured device. The apparent addition of a new device could
generate user-visible notices (e.g., \"Mallory appears to have a new
device\"). However, such an event is not always considered alarming;
some implementations might silently save a new
key.[¶](#section-2.2-3){.pilcrow}
:::
:::

::: {#byebye-3pcc}
::: {#section-2.3 .section}
### [2.3.](#section-2.3){.section-number .selfRef} [Third-Party Call Control](#name-third-party-call-control){.section-name .selfRef} {#name-third-party-call-control}

Third-party call control (3PCC) \[[RFC3725](#RFC3725){.xref}\] is a
technique where a signaling peer establishes a call that is terminated
by a different entity. An unknown key-share attack is very similar in
effect to some 3PCC practices, so use of 3PCC could appear to be an
attack. However, 3PCC that follows RFC 3725 guidance is unaffected, and
peers that are aware of changes made by a 3PCC controller can correctly
distinguish actions of a 3PCC controller from an
attack.[¶](#section-2.3-1){.pilcrow}

3PCC as described in RFC 3725 is incompatible with SIP identity
\[[SIP-ID](#RFC8224){.xref}\], as SIP Identity relies on creating a
binding between SIP requests and SDP. The controller is the only entity
that generates SIP requests in RFC 3725. Therefore, in a 3PCC context,
only the use of the `fingerprint` attribute without additional bindings
or WebRTC identity \[[WEBRTC-SEC](#RFC8827){.xref}\] is
possible.[¶](#section-2.3-2){.pilcrow}

The attack mitigation mechanisms described in this document will prevent
the use of 3PCC if peers have different views of the involved identities
or the value of SDP `tls-id` attributes.[¶](#section-2.3-3){.pilcrow}

For 3PCC to work with the proposed mechanisms, TLS peers need to be
aware of the signaling so that they can correctly generate and check the
TLS extensions. For a connection to be successfully established, a 3PCC
controller needs either to forward SDP without modification or to avoid
modifications to `fingerprint`, `tls-id`, and `identity` attributes. A
controller that follows the best practices in RFC 3725 is expected to
forward SDP without modification, thus ensuring the integrity of these
attributes.[¶](#section-2.3-4){.pilcrow}
:::
:::
:::
:::

::: {#id}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Unknown Key-Share Attack with Identity Bindings](#name-unknown-key-share-attack-wi){.section-name .selfRef} {#name-unknown-key-share-attack-wi}

The identity assertions used for WebRTC ([Section
7](https://www.rfc-editor.org/rfc/rfc8827#section-7){.relref} of
\[[WEBRTC-SEC](#RFC8827){.xref}\]) and the Personal Assertion Token
(PASSporT) used in SIP identity (\[[SIP-ID](#RFC8224){.xref}\],
\[[PASSPORT](#RFC8225){.xref}\]) are bound to the certificate
fingerprint of an endpoint. An attacker can cause an identity binding to
be created that binds an identity they control to the fingerprint of a
first victim.[¶](#section-3-1){.pilcrow}

An attacker can thereby cause a second victim to believe that they are
communicating with an attacker-controlled identity, when they are really
talking to the first victim. The attacker does this by creating an
identity assertion that covers a certificate fingerprint of the first
victim.[¶](#section-3-2){.pilcrow}

A variation on the same technique can be used to cause both victims to
believe they are talking to the attacker when they are talking to each
other. In this case, the attacker performs the identity misbinding once
for each victim.[¶](#section-3-3){.pilcrow}

The authority certifying the identity binding is not required to verify
that the entity requesting the binding actually controls the keys
associated with the fingerprints, and this might appear to be the cause
of the problem. SIP and WebRTC identity providers are not required to
perform this validation.[¶](#section-3-4){.pilcrow}

A simple solution to this problem is suggested by
\[[SIGMA](#SIGMA){.xref}\]. The identity of endpoints is included under
a message authentication code (MAC) during the cryptographic handshake.
Endpoints then validate that their peer has provided an identity that
matches their expectations. In TLS, the Finished message provides a MAC
over the entire handshake, so that including the identity in a TLS
extension is sufficient to implement this
solution.[¶](#section-3-5){.pilcrow}

Rather than include a complete identity binding, which could be sizable,
a collision- and preimage-resistant hash of the binding is included in a
TLS extension as described in [Section 3.2](#external_id_hash){.xref}.
Endpoints then need only validate that the extension contains a hash of
the identity binding they received in signaling. If the identity binding
is successfully validated, the identity of a peer is verified and bound
to the session.[¶](#section-3-6){.pilcrow}

This form of unknown key-share attack is possible without compromising
signaling integrity, unless the defenses described in [Section
4](#fp){.xref} are used. In order to prevent both forms of attack,
endpoints [MUST]{.bcp14} use the `external_session_id` extension (see
[Section 4.3](#external_session_id){.xref}) in addition to the
`external_id_hash` ([Section 3.2](#external_id_hash){.xref}) so that two
calls between the same parties can\'t be altered by an
attacker.[¶](#section-3-7){.pilcrow}

::: {#id-example}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Example](#name-example){.section-name .selfRef} {#name-example}

In the example shown in [Figure 1](#identity-attack){.xref}, it is
assumed that the attacker also controls the signaling
channel.[¶](#section-3.1-1){.pilcrow}

Mallory (the attacker) presents two victims, Norma and Patsy, with two
separate sessions. In the first session, Norma is presented with the
option to communicate with Mallory; a second session with Norma is
presented to Patsy.[¶](#section-3.1-2){.pilcrow}

[]{#name-example-attack-on-identity-}

::: {#identity-attack}
::: {#section-3.1-3.1 .artwork .art-text .alignLeft}
      Norma                   Mallory                   Patsy
      (fp=N)                   -----                    (fp=P)
        |                        |                        |
        |<---- Signaling1 ------>|                        |
        |   Norma=N Mallory=P    |                        |
        |                        |<---- Signaling2 ------>|
        |                        |   Norma=N Patsy=P      |
        |                                                 |
        |<=================DTLS (fp=N,P)=================>|
        |                                                 |
      (peer = Mallory!)                         (peer = Norma)
:::

[Figure 1](#figure-1){.selfRef}: [Example Attack on Identity
Bindings](#name-example-attack-on-identity-){.selfRef}
:::

The attack requires that Mallory obtain an identity binding for her own
identity with the fingerprints presented by Patsy (P), which Mallory
might have obtained previously. This false binding is then presented to
Norma (\'Signaling1\' in [Figure
1](#identity-attack){.xref}).[¶](#section-3.1-4){.pilcrow}

Patsy could be similarly duped, but in this example, a correct binding
between Norma\'s identity and fingerprint (N) is faithfully presented by
Mallory. This session (\'Signaling2\' in [Figure
1](#identity-attack){.xref}) can be entirely
legitimate.[¶](#section-3.1-5){.pilcrow}

A DTLS session is established directly between Norma and Patsy. In order
for this to happen, Mallory can substitute transport-level information
in both sessions, though this is not necessary if Mallory is on the
network path between Norma and Patsy.[¶](#section-3.1-6){.pilcrow}

As a result, Patsy correctly believes that she is communicating with
Norma. However, Norma incorrectly believes that she is talking to
Mallory. As stated in [Section 2](#uks){.xref}, Mallory cannot access
media, but Norma might send information to Patsy that Norma might not
intend or that Patsy might misinterpret.[¶](#section-3.1-7){.pilcrow}
:::
:::

::: {#external_id_hash}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [The `external_id_hash` TLS Extension](#name-the-external_id_hash-tls-ex){.section-name .selfRef} {#name-the-external_id_hash-tls-ex}

The `external_id_hash` TLS extension carries a hash of the identity
assertion that the endpoint sending the extension has asserted to its
peer. Both peers include a hash of their own identity
assertion.[¶](#section-3.2-1){.pilcrow}

The `extension_data` for the `external_id_hash` extension contains a
`ExternalIdentityHash` struct, described below using the syntax defined
in [Section
3](https://www.rfc-editor.org/rfc/rfc8446#section-3){.relref} of
\[[TLS13](#RFC8446){.xref}\]:[¶](#section-3.2-2){.pilcrow}

::: {#section-3.2-3}
``` {.sourcecode .lang-tls-presentation}
   struct {
      opaque binding_hash<0..32>;
   } ExternalIdentityHash;
```

[¶](#section-3.2-3){.pilcrow}
:::

Where an identity assertion has been asserted by a peer, this extension
includes a SHA-⁠256 hash of the assertion. An empty value is used to
indicate support for the extension.[¶](#section-3.2-4){.pilcrow}

[]{.break}

Note:
:   For both types of identity assertion, if SHA-⁠256 should prove to be
    inadequate in the future (see \[[AGILITY](#RFC7696){.xref}\]), a new
    TLS extension that uses a different hash function can be
    defined.[¶](#section-3.2-5.2){.pilcrow}
:   

Identity bindings might be provided by only one peer. An endpoint that
does not produce an identity binding [MUST]{.bcp14} generate an empty
`external_id_hash` extension in its ClientHello or \-- if a client
provides the extension \-- in ServerHello or EncryptedExtensions. An
empty extension has a zero-length `binding_hash`
field.[¶](#section-3.2-6){.pilcrow}

A peer that receives an `external_id_hash` extension that does not match
the value of the identity binding from its peer [MUST]{.bcp14}
immediately fail the TLS handshake with an `illegal_parameter` alert.
The absence of an identity binding does not relax this requirement; if a
peer provided no identity binding, a zero-length extension
[MUST]{.bcp14} be present to be considered
valid.[¶](#section-3.2-7){.pilcrow}

Implementations written prior to the definition of the extensions in
this document will not support this extension for some time. A peer that
receives an identity binding but does not receive an `external_id_hash`
extension [MAY]{.bcp14} accept a TLS connection rather than fail a
connection where the extension is absent.[¶](#section-3.2-8){.pilcrow}

The endpoint performs the validation of the `external_id_hash` extension
in addition to the validation required by
\[[FINGERPRINT](#RFC8122){.xref}\] and any verification of the identity
assertion \[[WEBRTC-SEC](#RFC8827){.xref}\]
\[[SIP-ID](#RFC8224){.xref}\]. An endpoint [MUST]{.bcp14} validate any
external_session_id value that is present; see [Section
4.3](#external_session_id){.xref}.[¶](#section-3.2-9){.pilcrow}

An `external_id_hash` extension with a `binding_hash` field that is any
length other than 0 or 32 is invalid and [MUST]{.bcp14} cause the
receiving endpoint to generate a fatal `decode_error`
alert.[¶](#section-3.2-10){.pilcrow}

In TLS 1.3, an `external_id_hash` extension sent by a server
[MUST]{.bcp14} be sent in the EncryptedExtensions
message.[¶](#section-3.2-11){.pilcrow}

::: {#calculating-externalidhash-for-webrtc-identity}
::: {#section-3.2.1 .section}
#### [3.2.1.](#section-3.2.1){.section-number .selfRef} [Calculating `external_id_hash` for WebRTC Identity](#name-calculating-external_id_has){.section-name .selfRef} {#name-calculating-external_id_has}

A WebRTC identity assertion ([Section
7](https://www.rfc-editor.org/rfc/rfc8827#section-7){.relref} of
\[[WEBRTC-SEC](#RFC8827){.xref}\]) is provided as a JSON
\[[JSON](#RFC8259){.xref}\] object that is encoded into a JSON text. The
JSON text is encoded using UTF-8 \[[UTF8](#RFC3629){.xref}\] as
described by [Section
8.1](https://www.rfc-editor.org/rfc/rfc8259#section-8.1){.relref} of
\[[JSON](#RFC8259){.xref}\]. The content of the `external_id_hash`
extension is produced by hashing the resulting octets with SHA-⁠256
\[[SHA](#RFC6234){.xref}\]. This produces the 32 octets of the
`binding_hash` parameter, which is the sole contents of the
extension.[¶](#section-3.2.1-1){.pilcrow}

The SDP `identity` attribute includes the base64
\[[BASE64](#RFC4648){.xref}\] encoding of the UTF-8 encoding of the same
JSON text. The `external_id_hash` extension is validated by performing
base64 decoding on the value of the SDP `identity` attribute, hashing
the resulting octets using SHA-⁠256, and comparing the results with the
content of the extension. In pseudocode form, using the
`identity-assertion-value` field from the SDP `identity` attribute
grammar as defined in
\[[WEBRTC-SEC](#RFC8827){.xref}\]:[¶](#section-3.2.1-2){.pilcrow}

::: {#section-3.2.1-3}
``` {.sourcecode .lang-pseudocode}
external_id_hash = SHA-256(b64decode(identity-assertion-value))
```

[¶](#section-3.2.1-3){.pilcrow}
:::

[]{.break}

Note:
:   The base64 of the SDP `identity` attribute is decoded to avoid
    capturing variations in padding. The base64-decoded identity
    assertion could include leading or trailing whitespace octets.
    WebRTC identity assertions are not canonicalized; all octets are
    hashed.[¶](#section-3.2.1-4.2){.pilcrow}
:   
:::
:::

::: {#calculating-externalidhash-for-passport}
::: {#section-3.2.2 .section}
#### [3.2.2.](#section-3.2.2){.section-number .selfRef} [Calculating external_id_hash for PASSporT](#name-calculating-external_id_hash){.section-name .selfRef} {#name-calculating-external_id_hash}

Where the compact form of PASSporT \[[PASSPORT](#RFC8225){.xref}\] is
used, it [MUST]{.bcp14} be expanded into the full form. The base64
encoding used in the SIP Identity (or \'y\') header field [MUST]{.bcp14}
be decoded then used as input to SHA-⁠256. This produces the 32-octet
`binding_hash` value used for creating or validating the extension. In
pseudocode, using the `signed-identity-digest` parameter from the
`Identity` header field grammar defined
\[[SIP-ID](#RFC8224){.xref}\]:[¶](#section-3.2.2-1){.pilcrow}

::: {#section-3.2.2-2}
``` {.sourcecode .lang-pseudocode}
external_id_hash = SHA-256(b64decode(signed-identity-digest))
```

[¶](#section-3.2.2-2){.pilcrow}
:::
:::
:::
:::
:::
:::
:::

::: {#fp}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Unknown Key-Share Attack with Fingerprints](#name-unknown-key-share-attack-wit){.section-name .selfRef} {#name-unknown-key-share-attack-wit}

An attack on DTLS-SRTP is possible because the identity of peers
involved is not established prior to establishing the call. Endpoints
use certificate fingerprints as a proxy for authentication, but as long
as fingerprints are used in multiple calls, they are vulnerable to
attack.[¶](#section-4-1){.pilcrow}

Even if the integrity of session signaling can be relied upon, an
attacker might still be able to create a session where there is
confusion about the communicating endpoints by substituting the
fingerprint of a communicating endpoint.[¶](#section-4-2){.pilcrow}

An endpoint that is configured to reuse a certificate can be attacked if
it is willing to initiate two calls at the same time, one of which is
with an attacker. The attacker can arrange for the victim to incorrectly
believe that it is calling the attacker when it is in fact calling a
second party. The second party correctly believes that it is talking to
the victim.[¶](#section-4-3){.pilcrow}

As with the attack on identity bindings, this can be used to cause two
victims to both believe they are talking to the attacker when they are
talking to each other.[¶](#section-4-4){.pilcrow}

::: {#fp-example}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Example](#name-example-2){.section-name .selfRef} {#name-example-2}

To mount this attack, two sessions need to be created with the same
endpoint at almost precisely the same time. One of those sessions is
initiated with the attacker, the second session is created toward
another honest endpoint. The attacker convinces the first endpoint that
their session with the attacker has been successfully established, but
media is exchanged with the other honest endpoint. The attacker permits
the session with the other honest endpoint to complete only to the
extent necessary to convince the other honest endpoint to participate in
the attacked session.[¶](#section-4.1-1){.pilcrow}

In addition to the constraints described in [Section
2.1](#limits){.xref}, the attacker in this example also needs the
ability to view and drop packets between victims. That is, the attacker
needs to be on path for media.[¶](#section-4.1-2){.pilcrow}

The attack shown in [Figure 2](#implausible-attack){.xref} depends on a
somewhat implausible set of conditions. It is intended to demonstrate
what sort of attack is possible and what conditions are necessary to
exploit this weakness in the protocol.[¶](#section-4.1-3){.pilcrow}

[]{#name-example-attack-scenario-usi}

::: {#implausible-attack}
::: {#section-4.1-4.1 .artwork .art-text .alignLeft}
      Norma                   Mallory                 Patsy
      (fp=N)                   -----                  (fp=P)
        |                        |                      |
        +---Signaling1 (fp=N)--->|                      |
        +-----Signaling2 (fp=N)------------------------>|
        |<-------------------------Signaling2 (fp=P)----+
        |<---Signaling1 (fp=P)---+                      |
        |                        |                      |
        |=======DTLS1=======>(Forward)======DTLS1======>|
        |<======DTLS2========(Forward)<=====DTLS2=======|
        |=======Media1======>(Forward)======Media1=====>|
        |<======Media2=======(Forward)<=====Media2======|
        |                       |                       |
        |=======DTLS2========>(Drop)                    |
        |                       |                       |
:::

[Figure 2](#figure-2){.selfRef}: [Example Attack Scenario Using
Fingerprints](#name-example-attack-scenario-usi){.selfRef}
:::

In this scenario, there are two sessions initiated at the same time by
Norma. Signaling is shown with single lines (\'-\'), DTLS and media with
double lines (\'=\').[¶](#section-4.1-5){.pilcrow}

The first session is established with Mallory, who falsely uses Patsy\'s
certificate fingerprint (denoted with \'fp=P\'). A second session is
initiated between Norma and Patsy. Signaling for both sessions is
permitted to complete.[¶](#section-4.1-6){.pilcrow}

Once signaling is complete on the first session, a DTLS connection is
established. Ostensibly, this connection is between Mallory and Norma,
but Mallory forwards DTLS and media packets sent to her by Norma to
Patsy. These packets are denoted \'DTLS1\' because Norma associates
these with the first signaling session
(\'Signaling1\').[¶](#section-4.1-7){.pilcrow}

Mallory also intercepts packets from Patsy and forwards those to Norma
at the transport address that Norma associates with Mallory. These
packets are denoted \'DTLS2\' to indicate that Patsy associates these
with the second signaling session (\'Signaling2\'); however, Norma will
interpret these as being associated with the first signaling session
(\'Signaling1\').[¶](#section-4.1-8){.pilcrow}

The second signaling exchange (\'Signaling2\'), which is between Norma
and Patsy, is permitted to continue to the point where Patsy believes
that it has succeeded. This ensures that Patsy believes that she is
communicating with Norma. In the end, Norma believes that she is
communicating with Mallory, when she is really communicating with Patsy.
Just like the example in [Section 3.1](#id-example){.xref}, Mallory
cannot access media, but Norma might send information to Patsy that
Norma might not intend or that Patsy might
misinterpret.[¶](#section-4.1-9){.pilcrow}

Though Patsy needs to believe that the second signaling session has been
successfully established, Mallory has no real interest in seeing that
session also be established. Mallory only needs to ensure that Patsy
maintains the active session and does not abandon the session
prematurely. For this reason, it might be necessary to permit the
signaling from Patsy to reach Norma in order to allow Patsy to receive a
call setup completion signal, such as a SIP ACK. Once the second session
is established, Mallory might cause DTLS packets sent by Norma to Patsy
to be dropped. However, if Mallory allows DTLS packets to pass, it is
likely that Patsy will discard them as Patsy will already have a
successful DTLS connection established.[¶](#section-4.1-10){.pilcrow}

For the attacked session to be sustained beyond the point that Norma
detects errors in the second session, Mallory also needs to block any
signaling that Norma might send to Patsy asking for the call to be
abandoned. Otherwise, Patsy might receive a notice that the call has
failed and thereby abort the call.[¶](#section-4.1-11){.pilcrow}

This attack creates an asymmetry in the beliefs about the identity of
peers. However, this attack is only possible if the victim (Norma) is
willing to conduct two sessions nearly simultaneously; if the attacker
(Mallory) is on the network path between the victims; and if the same
certificate \-- and therefore the SDP `fingerprint` attribute value \--
is used by Norma for both sessions.[¶](#section-4.1-12){.pilcrow}

Where Interactive Connectivity Establishment (ICE)
\[[ICE](#RFC8445){.xref}\] is used, Mallory also needs to ensure that
connectivity checks between Patsy and Norma succeed, either by
forwarding checks or by answering and generating the necessary
messages.[¶](#section-4.1-13){.pilcrow}
:::
:::

::: {#sess-id}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Unique Session Identity Solution](#name-unique-session-identity-sol){.section-name .selfRef} {#name-unique-session-identity-sol}

The solution to this problem is to assign a new identifier to
communicating peers. Each endpoint assigns their peer a unique
identifier during call signaling. The peer echoes that identifier in the
TLS handshake, binding that identity into the session. Including this
new identity in the TLS handshake means that it will be covered by the
TLS Finished message, which is necessary to authenticate it (see
\[[SIGMA](#SIGMA){.xref}\]).[¶](#section-4.2-1){.pilcrow}

Successfully validating that the identifier matches the expected value
means that the connection corresponds to the signaled session and is
therefore established between the correct two
endpoints.[¶](#section-4.2-2){.pilcrow}

This solution relies on the unique identifier given to DTLS sessions
using the SDP `tls-id` attribute \[[DTLS-SDP](#RFC8842){.xref}\]. This
field is already required to be unique. Thus, no two offers or answers
from the same client will have the same
value.[¶](#section-4.2-3){.pilcrow}

A new `external_session_id` extension is added to the TLS or DTLS
handshake for connections that are established as part of the same call
or real-time session. This carries the value of the `tls-id` attribute
and provides integrity protection for its exchange as part of the TLS or
DTLS handshake.[¶](#section-4.2-4){.pilcrow}
:::
:::

::: {#external_session_id}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [The external_session_id TLS Extension](#name-the-external_session_id-tls){.section-name .selfRef} {#name-the-external_session_id-tls}

The `external_session_id` TLS extension carries the unique identifier
that an endpoint selects. When used with SDP, the value [MUST]{.bcp14}
include the `tls-id` attribute from the SDP that the endpoint generated
when negotiating the session. This document only defines use of this
extension for SDP; other methods of external session negotiation can use
this extension to include a unique session
identifier.[¶](#section-4.3-1){.pilcrow}

The `extension_data` for the `external_session_id` extension contains an
ExternalSessionId struct, described below using the syntax defined in
\[[TLS13](#RFC8446){.xref}\]:[¶](#section-4.3-2){.pilcrow}

::: {#section-4.3-3}
``` {.sourcecode .lang-tls-presentation}
   struct {
      opaque session_id<20..255>;
   } ExternalSessionId;
```

[¶](#section-4.3-3){.pilcrow}
:::

For SDP, the `session_id` field of the extension includes the value of
the `tls-id` SDP attribute as defined in \[[DTLS-SDP](#RFC8842){.xref}\]
(that is, the `tls-id-value` ABNF production). The value of the `tls-id`
attribute is encoded using ASCII
\[[ASCII](#RFC0020){.xref}\].[¶](#section-4.3-4){.pilcrow}

Where RTP and RTCP \[[RTP](#RFC3550){.xref}\] are not multiplexed, it is
possible that the two separate DTLS connections carrying RTP and RTCP
can be switched. This is considered benign since these protocols are
designed to be distinguishable as SRTP \[[SRTP](#RFC3711){.xref}\]
provides key separation. Using RTP/RTCP multiplexing
\[[RTCP-MUX](#RFC5761){.xref}\] further avoids this
problem.[¶](#section-4.3-5){.pilcrow}

The `external_session_id` extension is included in a ClientHello, and if
the extension is present in the ClientHello, either ServerHello (for TLS
and DTLS versions older than 1.3) or EncryptedExtensions (for TLS
1.3).[¶](#section-4.3-6){.pilcrow}

Endpoints [MUST]{.bcp14} check that the `session_id` parameter in the
extension that they receive includes the `tls-id` attribute value that
they received in their peer\'s session description. Endpoints can
perform string comparison by ASCII decoding the TLS extension value and
comparing it to the SDP attribute value or by comparing the encoded TLS
extension octets with the encoded SDP attribute value. An endpoint that
receives an `external_session_id` extension that is not identical to the
value that it expects [MUST]{.bcp14} abort the connection with a fatal
`illegal_parameter` alert.[¶](#section-4.3-7){.pilcrow}

The endpoint performs the validation of the `external_id_hash` extension
in addition to the validation required by
\[[FINGERPRINT](#RFC8122){.xref}\].[¶](#section-4.3-8){.pilcrow}

If an endpoint communicates with a peer that does not support this
extension, it will receive a ClientHello, ServerHello, or
EncryptedExtensions message that does not include this extension. An
endpoint [MAY]{.bcp14} choose to continue a session without this
extension in order to interoperate with peers that do not implement this
specification.[¶](#section-4.3-9){.pilcrow}

In TLS 1.3, an `external_session_id` extension sent by a server
[MUST]{.bcp14} be sent in the EncryptedExtensions
message.[¶](#section-4.3-10){.pilcrow}

This defense is not effective if an attacker can rewrite `tls-id` values
in signaling. Only the mechanism in `external_id_hash` is able to defend
against an attacker that can compromise session
integrity.[¶](#section-4.3-11){.pilcrow}
:::
:::
:::
:::

::: {#concat}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Session Concatenation](#name-session-concatenation){.section-name .selfRef} {#name-session-concatenation}

Use of session identifiers does not prevent an attacker from
establishing two concurrent sessions with different peers and forwarding
signaling from those peers to each other. Concatenating two signaling
sessions in this way creates two signaling sessions, with two session
identifiers, but only the TLS connections from a single session are
established as a result. In doing so, the attacker creates a situation
where both peers believe that they are talking to the attacker when they
are talking to each other.[¶](#section-5-1){.pilcrow}

In the absence of any higher-level concept of peer identity, an attacker
who is able to copy the session identifier from one signaling session to
another can cause the peers to establish a direct TLS connection even
while they think that they are connecting to the attacker. This differs
from the attack described in the previous section in that there is only
one TLS connection rather than two. This kind of attack is prevented by
systems that enable peer authentication, such as WebRTC identity
\[[WEBRTC-SEC](#RFC8827){.xref}\] or SIP identity
\[[SIP-ID](#RFC8224){.xref}\]; however, these systems do not prevent
establishing two back-to-back connections as described in the previous
paragraph.[¶](#section-5-2){.pilcrow}

Use of the `external_session_id` does not guarantee that the identity of
the peer at the TLS layer is the same as the identity of the signaling
peer. The advantage that an attacker gains by concatenating sessions is
limited unless data is exchanged based on the assumption that signaling
and TLS peers are the same. If a secondary protocol uses the signaling
channel with the assumption that the signaling and TLS peers are the
same, then that protocol is vulnerable to attack. While out of scope for
this document, a signaling system that can defend against session
concatenation requires that the signaling layer is authenticated and
bound to any TLS connections.[¶](#section-5-3){.pilcrow}

It is important to note that multiple connections can be created within
the same signaling session. An attacker might concatenate only part of a
session, choosing to terminate some connections (and optionally forward
data) while arranging to have peers interact directly for other
connections. It is even possible to have different peers interact for
each connection. This means that the actual identity of the peer for one
connection might differ from the peer on another
connection.[¶](#section-5-4){.pilcrow}

Critically, information about the identity of TLS peers provides no
assurances about the identity of signaling peers and does not transfer
between TLS connections in the same session. Information extracted from
a TLS connection therefore [MUST NOT]{.bcp14} be used in a secondary
protocol outside of that connection if that protocol assumes that the
signaling protocol has the same peers. Similarly, security-sensitive
information from one TLS connection [MUST NOT]{.bcp14} be used in other
TLS connections even if they are established as a result of the same
signaling session.[¶](#section-5-5){.pilcrow}
:::
:::

::: {#security-considerations}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

When combined with identity assertions, the mitigations in this document
ensure that there is no opportunity to misrepresent the identity of TLS
peers. This assurance is provided even if an attacker can modify
signaling messages.[¶](#section-6-1){.pilcrow}

Without identity assertions, the mitigations in this document prevent
the session splicing attack described in [Section 4](#fp){.xref}.
Defense against session concatenation ([Section 5](#concat){.xref})
additionally requires that protocol peers are not able to claim the
certificate fingerprints of other entities.[¶](#section-6-2){.pilcrow}
:::
:::

::: {#iana-considerations}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document registers two extensions in the \"TLS ExtensionType
Values\" registry established in
\[[TLS13](#RFC8446){.xref}\]:[¶](#section-7-1){.pilcrow}

-   [The `external_id_hash` extension defined in [Section
    3.2](#external_id_hash){.xref} has been assigned a code point of 55;
    it is recommended and is marked as \"CH, EE\" in TLS
    1.3.[¶](#section-7-2.1){.pilcrow}]{#section-7-2.1}
-   [The `external_session_id` extension defined in [Section
    4.3](#external_session_id){.xref} has been assigned a code point of
    56; it is recommended and is marked as \"CH, EE\" in TLS
    1.3.[¶](#section-7-2.2){.pilcrow}]{#section-7-2.2}
:::
:::

::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[ASCII\]
:   [Cerf, V.]{.refAuthor}, [\"ASCII format for network
    interchange\"]{.refTitle}, [STD 80]{.seriesInfo}, [RFC
    20]{.seriesInfo}, [DOI 10.17487/RFC0020]{.seriesInfo}, October 1969,
    \<<https://www.rfc-editor.org/info/rfc20>\>.
:   

\[BASE64\]
:   [Josefsson, S.]{.refAuthor}, [\"The Base16, Base32, and Base64 Data
    Encodings\"]{.refTitle}, [RFC 4648]{.seriesInfo}, [DOI
    10.17487/RFC4648]{.seriesInfo}, October 2006,
    \<<https://www.rfc-editor.org/info/rfc4648>\>.
:   

\[DTLS\]
:   [Rescorla, E.]{.refAuthor}[ and N. Modadugu]{.refAuthor},
    [\"Datagram Transport Layer Security Version 1.2\"]{.refTitle}, [RFC
    6347]{.seriesInfo}, [DOI 10.17487/RFC6347]{.seriesInfo}, January
    2012, \<<https://www.rfc-editor.org/info/rfc6347>\>.
:   

\[DTLS-SDP\]
:   [Holmberg, C.]{.refAuthor}[ and R. Shpount]{.refAuthor}, [\"Session
    Description Protocol (SDP) Offer/Answer Considerations for Datagram
    Transport Layer Security (DTLS) and Transport Layer Security
    (TLS)\"]{.refTitle}, [RFC 8842]{.seriesInfo}, [DOI
    10.17487/RFC8842]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8842>\>.
:   

\[DTLS-SRTP\]
:   [Fischl, J.]{.refAuthor}[, Tschofenig, H.]{.refAuthor}[, and E.
    Rescorla]{.refAuthor}, [\"Framework for Establishing a Secure
    Real-time Transport Protocol (SRTP) Security Context Using Datagram
    Transport Layer Security (DTLS)\"]{.refTitle}, [RFC
    5763]{.seriesInfo}, [DOI 10.17487/RFC5763]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5763>\>.
:   

\[FINGERPRINT\]
:   [Lennox, J.]{.refAuthor}[ and C. Holmberg]{.refAuthor},
    [\"Connection-Oriented Media Transport over the Transport Layer
    Security (TLS) Protocol in the Session Description Protocol
    (SDP)\"]{.refTitle}, [RFC 8122]{.seriesInfo}, [DOI
    10.17487/RFC8122]{.seriesInfo}, March 2017,
    \<<https://www.rfc-editor.org/info/rfc8122>\>.
:   

\[JSON\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The JavaScript Object Notation
    (JSON) Data Interchange Format\"]{.refTitle}, [STD 90]{.seriesInfo},
    [RFC 8259]{.seriesInfo}, [DOI 10.17487/RFC8259]{.seriesInfo},
    December 2017, \<<https://www.rfc-editor.org/info/rfc8259>\>.
:   

\[PASSPORT\]
:   [Wendt, C.]{.refAuthor}[ and J. Peterson]{.refAuthor}, [\"PASSporT:
    Personal Assertion Token\"]{.refTitle}, [RFC 8225]{.seriesInfo},
    [DOI 10.17487/RFC8225]{.seriesInfo}, February 2018,
    \<<https://www.rfc-editor.org/info/rfc8225>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[SDP\]
:   [Handley, M.]{.refAuthor}[, Jacobson, V.]{.refAuthor}[, and C.
    Perkins]{.refAuthor}, [\"SDP: Session Description
    Protocol\"]{.refTitle}, [RFC 4566]{.seriesInfo}, [DOI
    10.17487/RFC4566]{.seriesInfo}, July 2006,
    \<<https://www.rfc-editor.org/info/rfc4566>\>.
:   

\[SHA\]
:   [Eastlake 3rd, D.]{.refAuthor}[ and T. Hansen]{.refAuthor}, [\"US
    Secure Hash Algorithms (SHA and SHA-based HMAC and
    HKDF)\"]{.refTitle}, [RFC 6234]{.seriesInfo}, [DOI
    10.17487/RFC6234]{.seriesInfo}, May 2011,
    \<<https://www.rfc-editor.org/info/rfc6234>\>.
:   

\[SIP-ID\]
:   [Peterson, J.]{.refAuthor}[, Jennings, C.]{.refAuthor}[,
    Rescorla, E.]{.refAuthor}[, and C. Wendt]{.refAuthor},
    [\"Authenticated Identity Management in the Session Initiation
    Protocol (SIP)\"]{.refTitle}, [RFC 8224]{.seriesInfo}, [DOI
    10.17487/RFC8224]{.seriesInfo}, February 2018,
    \<<https://www.rfc-editor.org/info/rfc8224>\>.
:   

\[SRTP\]
:   [Baugher, M.]{.refAuthor}[, McGrew, D.]{.refAuthor}[,
    Naslund, M.]{.refAuthor}[, Carrara, E.]{.refAuthor}[, and K.
    Norrman]{.refAuthor}, [\"The Secure Real-time Transport Protocol
    (SRTP)\"]{.refTitle}, [RFC 3711]{.seriesInfo}, [DOI
    10.17487/RFC3711]{.seriesInfo}, March 2004,
    \<<https://www.rfc-editor.org/info/rfc3711>\>.
:   

\[TLS13\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   

\[UTF8\]
:   [Yergeau, F.]{.refAuthor}, [\"UTF-8, a transformation format of ISO
    10646\"]{.refTitle}, [STD 63]{.seriesInfo}, [RFC 3629]{.seriesInfo},
    [DOI 10.17487/RFC3629]{.seriesInfo}, November 2003,
    \<<https://www.rfc-editor.org/info/rfc3629>\>.
:   

\[WEBRTC-SEC\]
:   [Rescorla, E.]{.refAuthor}, [\"WebRTC Security
    Architecture\"]{.refTitle}, [RFC 8827]{.seriesInfo}, [DOI
    10.17487/RFC8827]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8827>\>.
:   
:::

::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[AGILITY\]
:   [Housley, R.]{.refAuthor}, [\"Guidelines for Cryptographic Algorithm
    Agility and Selecting Mandatory-to-Implement
    Algorithms\"]{.refTitle}, [BCP 201]{.seriesInfo}, [RFC
    7696]{.seriesInfo}, [DOI 10.17487/RFC7696]{.seriesInfo}, November
    2015, \<<https://www.rfc-editor.org/info/rfc7696>\>.
:   

\[ICE\]
:   [Keranen, A.]{.refAuthor}[, Holmberg, C.]{.refAuthor}[, and J.
    Rosenberg]{.refAuthor}, [\"Interactive Connectivity Establishment
    (ICE): A Protocol for Network Address Translator (NAT)
    Traversal\"]{.refTitle}, [RFC 8445]{.seriesInfo}, [DOI
    10.17487/RFC8445]{.seriesInfo}, July 2018,
    \<<https://www.rfc-editor.org/info/rfc8445>\>.
:   

\[RFC3725\]
:   [Rosenberg, J.]{.refAuthor}[, Peterson, J.]{.refAuthor}[,
    Schulzrinne, H.]{.refAuthor}[, and G. Camarillo]{.refAuthor},
    [\"Best Current Practices for Third Party Call Control (3pcc) in the
    Session Initiation Protocol (SIP)\"]{.refTitle}, [BCP
    85]{.seriesInfo}, [RFC 3725]{.seriesInfo}, [DOI
    10.17487/RFC3725]{.seriesInfo}, April 2004,
    \<<https://www.rfc-editor.org/info/rfc3725>\>.
:   

\[RTCP-MUX\]
:   [Perkins, C.]{.refAuthor}[ and M. Westerlund]{.refAuthor},
    [\"Multiplexing RTP Data and Control Packets on a Single
    Port\"]{.refTitle}, [RFC 5761]{.seriesInfo}, [DOI
    10.17487/RFC5761]{.seriesInfo}, April 2010,
    \<<https://www.rfc-editor.org/info/rfc5761>\>.
:   

\[RTP\]
:   [Schulzrinne, H.]{.refAuthor}[, Casner, S.]{.refAuthor}[,
    Frederick, R.]{.refAuthor}[, and V. Jacobson]{.refAuthor}, [\"RTP: A
    Transport Protocol for Real-Time Applications\"]{.refTitle}, [STD
    64]{.seriesInfo}, [RFC 3550]{.seriesInfo}, [DOI
    10.17487/RFC3550]{.seriesInfo}, July 2003,
    \<<https://www.rfc-editor.org/info/rfc3550>\>.
:   

\[SIGMA\]
:   [Krawczyk, H.]{.refAuthor}, [\"SIGMA: The \'SIGn-and-MAc\' Approach
    to Authenticated Diffie-Hellman and Its Use in the IKE
    Protocols\"]{.refTitle}, [Advances in Cryptology \-- CRYPTO
    2003]{.refContent}, [Lecture Notes in Computer
    Science]{.refContent}, [Vol. 2729]{.refContent}, [DOI
    10.1007/978-3-540-45146-4_24]{.seriesInfo}, August 2003,
    \<<https://doi.org/10.1007/978-3-540-45146-4_24>\>.
:   

\[UKS\]
:   [Blake-Wilson, S.]{.refAuthor}[ and A. Menezes]{.refAuthor},
    [\"Unknown Key-Share Attacks on the Station-to-Station (STS)
    Protocol\"]{.refTitle}, [Public Key Cryptography]{.refContent},
    [Lecture Notes in Computer Science]{.refContent}, [Vol.
    1560]{.refContent}, [DOI 10.1007/3-540-49162-7_12]{.seriesInfo},
    March 1999, \<<https://doi.org/10.1007/3-540-49162-7_12>\>.
:   

\[WEBRTC\]
:   [Jennings, C.]{.refAuthor}[, Boström, H.]{.refAuthor}[, and J-I.
    Bruaroey]{.refAuthor}, [\"WebRTC 1.0: Real-time Communication
    Between Browsers\"]{.refTitle}, [W3C Proposed
    Recommendation]{.refContent}, \<<https://www.w3.org/TR/webrtc/>\>.
:   

\[ZRTP\]
:   [Zimmermann, P.]{.refAuthor}[, Johnston, A., Ed.]{.refAuthor}[,
    and J. Callas]{.refAuthor}, [\"ZRTP: Media Path Key Agreement for
    Unicast Secure RTP\"]{.refTitle}, [RFC 6189]{.seriesInfo}, [DOI
    10.17487/RFC6189]{.seriesInfo}, April 2011,
    \<<https://www.rfc-editor.org/info/rfc6189>\>.
:   
:::
:::

::: {#acknowledgements}
::: {#section-appendix.a .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

This problem would not have been discovered if it weren\'t for
discussions with [Sam Scott]{.contact-name}, [Hugo
Krawczyk]{.contact-name}, and [Richard Barnes]{.contact-name}. A
solution similar to the one presented here was first proposed by
[Karthik Bhargavan]{.contact-name}, who provided valuable input on this
document. [Thyla van der Merwe]{.contact-name} assisted with a formal
model of the solution. [Adam Roach]{.contact-name} and [Paul E.
Jones]{.contact-name} provided significant review and
input.[¶](#section-appendix.a-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.b .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Martin Thomson]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Mozilla]{.org}
:::

::: email
Email: <mt@lowentropy.net>
:::

::: {.left dir="auto"}
[Eric Rescorla]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Mozilla]{.org}
:::

::: email
Email: <ekr@rtfm.com>
:::
:::
:::
