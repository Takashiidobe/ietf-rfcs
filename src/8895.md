  RFC 8895       ALTO Incremental Updates   November 2020
  -------------- -------------------------- ---------------
  Roome & Yang   Standards Track            \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8895](https://www.rfc-editor.org/rfc/rfc8895){.eref}

Category:
:   Standards Track

Published:
:   November 2020

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    W. Roome
    :::

    ::: org
    Nokia Bell Labs
    :::
    :::

    ::: author
    ::: author-name
    Y. Yang
    :::

    ::: org
    Yale University
    :::
    :::
:::

# RFC 8895 {#rfcnum}

# Application-Layer Traffic Optimization (ALTO) Incremental Updates Using Server-Sent Events (SSE) {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

The Application-Layer Traffic Optimization (ALTO) protocol (RFC 7285)
provides network-related information, called network information
resources, to client applications so that clients can make informed
decisions in utilizing network resources. This document presents a
mechanism to allow an ALTO server to push updates to ALTO clients to
achieve two benefits: (1) updates can be incremental, in that if only a
small section of an information resource changes, the ALTO server can
send just the changes and (2) updates can be immediate, in that the ALTO
server can send updates as soon as they are
available.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8895>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terms](#name-terms){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Requirements
        Language](#name-requirements-language){.xref}[¶](#section-toc.1-1.2.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Background](#name-background){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Incremental Encoding: JSON Merge
        Patch](#name-incremental-encoding-json-m){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.3.2.1.2.1}
            [3.1.1](#section-3.1.1){.xref}.  [JSON Merge Patch
            Encoding](#name-json-merge-patch-encoding){.xref}[¶](#section-toc.1-1.3.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.1.2.2}
            [3.1.2](#section-3.1.2){.xref}.  [JSON Merge Patch ALTO
            Messages](#name-json-merge-patch-alto-messa){.xref}[¶](#section-toc.1-1.3.2.1.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Incremental Encoding: JSON
        Patch](#name-incremental-encoding-json-p){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.3.2.2.2.1}
            [3.2.1](#section-3.2.1){.xref}.  [JSON Patch
            Encoding](#name-json-patch-encoding){.xref}[¶](#section-toc.1-1.3.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.2}
            [3.2.2](#section-3.2.2){.xref}.  [JSON Patch ALTO
            Messages](#name-json-patch-alto-messages){.xref}[¶](#section-toc.1-1.3.2.2.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Multiplexing and Server Push:
        HTTP/2](#name-multiplexing-and-server-pus){.xref}[¶](#section-toc.1-1.3.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [Server Push: Server-Sent
        Event](#name-server-push-server-sent-eve){.xref}[¶](#section-toc.1-1.3.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Overview of Approach and High-Level
    Protocol Message
    Flow](#name-overview-of-approach-and-hi){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Update Stream Service Message
        Flow](#name-update-stream-service-messa){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Stream Control Service Message
        Flow](#name-stream-control-service-mess){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Service Announcement and
        Management Message
        Flow](#name-service-announcement-and-ma){.xref}[¶](#section-toc.1-1.4.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Update Messages: Data Update and Control
    Update
    Messages](#name-update-messages-data-update){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Generic ALTO Update Message
        Structure](#name-generic-alto-update-message){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [ALTO Data Update
        Message](#name-alto-data-update-message){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [ALTO Control Update
        Message](#name-alto-control-update-message){.xref}[¶](#section-toc.1-1.5.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Update Stream
    Service](#name-update-stream-service){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Media
        Type](#name-media-type){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [HTTP
        Method](#name-http-method){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Capabilities](#name-capabilities){.xref}[¶](#section-toc.1-1.6.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [Uses](#name-uses){.xref}[¶](#section-toc.1-1.6.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.5}
        [6.5](#section-6.5){.xref}.  [Request: Accept Input
        Parameters](#name-request-accept-input-parame){.xref}[¶](#section-toc.1-1.6.2.5.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.6}
        [6.6](#section-6.6){.xref}.  [Response](#name-response){.xref}[¶](#section-toc.1-1.6.2.6.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.7}
        [6.7](#section-6.7){.xref}.  [Additional Requirements on Update
        Stream
        Service](#name-additional-requirements-on-){.xref}[¶](#section-toc.1-1.6.2.7.1){.pilcrow}

        -   ::: {#section-toc.1-1.6.2.7.2.1}
            [6.7.1](#section-6.7.1){.xref}.  [Event Sequence
            Requirements](#name-event-sequence-requirements){.xref}[¶](#section-toc.1-1.6.2.7.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.6.2.7.2.2}
            [6.7.2](#section-6.7.2){.xref}.  [Cross-Stream Consistency
            Requirements](#name-cross-stream-consistency-re){.xref}[¶](#section-toc.1-1.6.2.7.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.6.2.7.2.3}
            [6.7.3](#section-6.7.3){.xref}.  [Multipart Update
            Requirements](#name-multipart-update-requiremen){.xref}[¶](#section-toc.1-1.6.2.7.2.3.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.6.2.8}
        [6.8](#section-6.8){.xref}.  [Keep-Alive
        Messages](#name-keep-alive-messages){.xref}[¶](#section-toc.1-1.6.2.8.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Stream Control
    Service](#name-stream-control-service){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [URI](#name-uri){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Media
        Type](#name-media-type-2){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [HTTP
        Method](#name-http-method-2){.xref}[¶](#section-toc.1-1.7.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [IRD Capabilities &
        Uses](#name-ird-capabilities-uses){.xref}[¶](#section-toc.1-1.7.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.5}
        [7.5](#section-7.5){.xref}.  [Request: Accept Input
        Parameters](#name-request-accept-input-paramet){.xref}[¶](#section-toc.1-1.7.2.5.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.6}
        [7.6](#section-7.6){.xref}.  [Response](#name-response-2){.xref}[¶](#section-toc.1-1.7.2.6.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Examples](#name-examples){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Example: IRD Announcing Update
        Stream
        Services](#name-example-ird-announcing-upda){.xref}[¶](#section-toc.1-1.8.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Example: Simple Network and Cost
        Map
        Updates](#name-example-simple-network-and-){.xref}[¶](#section-toc.1-1.8.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [8.3](#section-8.3){.xref}.  [Example: Advanced Network and Cost
        Map
        Updates](#name-example-advanced-network-an){.xref}[¶](#section-toc.1-1.8.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.4}
        [8.4](#section-8.4){.xref}.  [Example: Endpoint Property
        Updates](#name-example-endpoint-property-u){.xref}[¶](#section-toc.1-1.8.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.5}
        [8.5](#section-8.5){.xref}.  [Example: Multipart Message
        Updates](#name-example-multipart-message-u){.xref}[¶](#section-toc.1-1.8.2.5.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Operation and Processing
    Considerations](#name-operation-and-processing-co){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Considerations for Choosing Data
        Update
        Messages](#name-considerations-for-choosing){.xref}[¶](#section-toc.1-1.9.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Considerations for Client
        Processing Data Update
        Messages](#name-considerations-for-client-p){.xref}[¶](#section-toc.1-1.9.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.3}
        [9.3](#section-9.3){.xref}.  [Considerations for Updates to
        Filtered Cost
        Maps](#name-considerations-for-updates-){.xref}[¶](#section-toc.1-1.9.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.4}
        [9.4](#section-9.4){.xref}.  [Considerations for Updates to
        Ordinal Mode
        Costs](#name-considerations-for-updates-t){.xref}[¶](#section-toc.1-1.9.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.5}
        [9.5](#section-9.5){.xref}.  [Considerations for SSE Text
        Formatting and
        Processing](#name-considerations-for-sse-text){.xref}[¶](#section-toc.1-1.9.2.5.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}

    -   ::: {#section-toc.1-1.10.2.1}
        [10.1](#section-10.1){.xref}.  [Update Stream Server:
        Denial-of-Service
        Attacks](#name-update-stream-server-denial){.xref}[¶](#section-toc.1-1.10.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [10.2](#section-10.2){.xref}.  [ALTO Client: Update Overloading
        or
        Instability](#name-alto-client-update-overload){.xref}[¶](#section-toc.1-1.10.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.3}
        [10.3](#section-10.3){.xref}.  [Stream Control: Spoofed Control
        Requests and Information
        Breakdown](#name-stream-control-spoofed-cont){.xref}[¶](#section-toc.1-1.10.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [Requirements on Future ALTO Services to
    Use This
    Design](#name-requirements-on-future-alto){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}

    -   ::: {#section-toc.1-1.12.2.1}
        [12.1](#section-12.1){.xref}.  [application/alto-updatestreamparams+json
        Media
        Type](#name-application-alto-updatestre){.xref}[¶](#section-toc.1-1.12.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [12.2](#section-12.2){.xref}.  [application/alto-updatestreamcontrol+json
        Media
        Type](#name-application-alto-updatestrea){.xref}[¶](#section-toc.1-1.12.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [13](#section-13){.xref}. [Appendix: Design Decision: Not Allowing
    Stream
    Restart](#name-appendix-design-decision-no){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.14}
    [14](#section-14){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}

    -   ::: {#section-toc.1-1.14.2.1}
        [14.1](#section-14.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.14.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.14.2.2}
        [14.2](#section-14.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.14.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.15}
    [](#section-appendix.a){.xref}[Acknowledgments](#name-acknowledgments){.xref}[¶](#section-toc.1-1.15.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.16}
    [](#section-appendix.b){.xref}[Contributors](#name-contributors){.xref}[¶](#section-toc.1-1.16.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.17}
    [](#section-appendix.c){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.17.1){.pilcrow}
    :::
:::
:::

::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The Application-Layer Traffic Optimization (ALTO) protocol
\[[RFC7285](#RFC7285){.xref}\] provides network-related information,
called network information resources, to client applications so that
clients may make informed decisions in utilizing network resources. For
example, an ALTO server provides network and cost maps, where a network
map partitions the set of endpoints into a manageable number of sets
each defined by a Provider-Defined Identifier (PID) and a cost map
provides directed costs between PIDs. Given network and cost maps, an
ALTO client can obtain costs between endpoints by first using the
network map to get the PID for each endpoint and then using the cost map
to get the costs between those PIDs. Such costs can be used by the
client to choose communicating endpoints with low network
costs.[¶](#section-1-1){.pilcrow}

The ALTO protocol defines only an ALTO client pull model without
defining a mechanism to allow an ALTO client to obtain updates to
network information resources, other than by periodically re-fetching
them. In settings where an information resource may be large but only
parts of it may change frequently (e.g., some entries of a cost map),
complete re-fetching can be inefficient.[¶](#section-1-2){.pilcrow}

This document presents a mechanism to allow an ALTO server to push
incremental updates to ALTO clients. Integrating server push and
incremental updates provides two benefits: (1) updates can be small, in
that if only a small section of an information resource changes, the
ALTO server can send just the changes and (2) updates can be immediate,
in that the ALTO server can send updates as soon as they are
available.[¶](#section-1-3){.pilcrow}

While primarily intended to provide updates to GET-mode network and cost
maps, the mechanism defined in this document can also provide updates to
POST-mode ALTO services, such as the ALTO endpoint property and endpoint
cost services. The mechanism can also support new ALTO services to be
defined by future extensions, but a future service needs to satisfy
requirements specified in [Section
11](#FutureDesignConsiderations){.xref}.[¶](#section-1-4){.pilcrow}

The rest of this document is organized as follows. [Section
3](#Background){.xref} gives background on the basic techniques used in
this design: (1) JSON merge patch and JSON patch to allow incremental
updates and (2) Server-Sent Events (SSE) \[[SSE](#SSE){.xref}\] to allow
server push. With the background, [Section 4](#Overview){.xref} gives a
non-normative overview of the design. [Section
5](#ALTO.SSE.Events){.xref} defines individual messages in an update
stream. [Section 6](#UpdateStreamService){.xref} defines the update
stream service. [Section 7](#UpdateStreamController){.xref} defines the
stream control service. [Section 8](#Examples){.xref} gives several
examples to illustrate the two types of services. [Section
9](#OperationProcessingConsiderations){.xref} describes operation and
processing considerations by both ALTO servers and clients. [Section
13](#DesignDecisions){.xref} discusses a design feature that is not
supported. [Section 10](#Security){.xref} discusses security issues.
Sections [11](#FutureDesignConsiderations){.xref} and [12](#IANA){.xref}
review the requirements for future ALTO services to use SSE and IANA
considerations, respectively.[¶](#section-1-5){.pilcrow}
:::

::: {#Terms}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terms](#name-terms){.section-name .selfRef} {#name-terms}

Besides the terminologies as defined in \[[RFC7285](#RFC7285){.xref}\],
this document also uses additional terminologies defined as
follows:[¶](#section-2-1){.pilcrow}

[]{.break}

Update Stream:
:   A reliable, in-order connection compatible with HTTP/1.x between an
    ALTO client and an ALTO server so that the server can push a
    sequence of update messages using \[[SSE](#SSE){.xref}\] to the
    client.[¶](#section-2-2.2){.pilcrow}
:   

Update Stream Server:
:   This document refers to an ALTO server providing an update stream as
    an ALTO update stream server, or update stream server for short.
    Note that the ALTO server mentioned in this document refers to a
    general server that provides various kinds of services; it can be an
    update stream server or stream control server (see below). It can
    also be a server providing ALTO Information Resource Directory
    (IRD).[¶](#section-2-2.4){.pilcrow}
:   

Update Message:
:   A message that is either a data update message or a control update
    message.[¶](#section-2-2.6){.pilcrow}
:   

Data Update Message:
:   An update message that is for a single ALTO information resource and
    sent from the update stream server to the ALTO client when the
    resource changes. A data update message can be either a
    full-replacement message or an incremental-change message. Full
    replacement is a shorthand for a full-replacement message, and
    incremental change is a shorthand for an incremental-change
    message.[¶](#section-2-2.8){.pilcrow}
:   

Full Replacement:
:   A data update message for a resource that encodes the content of the
    resource in its original ALTO
    encoding.[¶](#section-2-2.10){.pilcrow}
:   

Incremental Change:
:   A data update message that specifies only the difference between the
    new content and the previous version. An incremental change can be
    encoded using either JSON merge patch or JSON patch in this
    document.[¶](#section-2-2.12){.pilcrow}
:   

Stream Control Service:
:   A service that provides an HTTP URI so that the ALTO client of an
    update stream can use it to send stream control requests to the ALTO
    server on the addition or removal of resources receiving update
    messages from the update stream. The ALTO server creates a new
    stream control resource for each update stream instance, assigns a
    unique URI to it, and sends the URI to the client as the first event
    in the stream. (Note that the stream control service in ALTO has no
    association with the similarly named Stream Control Transmission
    Protocol
    \[[RFC4960](#RFC4960){.xref}\].)[¶](#section-2-2.14){.pilcrow}
:   

Stream Control:
:   A shorthand for stream control
    service.[¶](#section-2-2.16){.pilcrow}
:   

Stream Control Server:
:   An ALTO server providing the stream control
    service.[¶](#section-2-2.18){.pilcrow}
:   

Substream-ID:
:   An ALTO client can assign a unique substream-id when requesting the
    addition of a resource receiving update messages from an update
    stream. The server puts the substream-id in each update event for
    that resource. The substream-id allows a client to use one update
    stream to receive updates to multiple requests for the same resource
    (i.e., with the same resource-id in an ALTO IRD), for example, for a
    POST-mode resource with different input
    parameters.[¶](#section-2-2.20){.pilcrow}
:   

Data-ID:
:   A subfield of the \"event\" field of \[[SSE](#SSE){.xref}\] to
    identify the ALTO data (object) to be updated. For an ALTO resource
    returning a multipart response, the data-id to identify the data
    (object) is the substream-id, in addition to the Content-ID of the
    object in the multipart response. The data-id of a single-part
    response is just the substream-id.[¶](#section-2-2.22){.pilcrow}
:   

Control Update Message:
:   An update message for the update stream server to notify the ALTO
    client of related control information of the update stream. A
    control update message may be triggered by an internal event at the
    server, such as server overloading and hence the update stream
    server will no longer send updates for an information resource, or
    as a result of a client sending a request through the stream control
    service. The first message of an update stream is a control update
    message that provides a control URI to the ALTO client. The ALTO
    client can use the URI to send stream control requests to the stream
    control server.[¶](#section-2-2.24){.pilcrow}
:   

::: {#ReqLang}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Requirements Language](#name-requirements-language){.section-name .selfRef} {#name-requirements-language}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2.1-1){.pilcrow}
:::
:::
:::
:::

::: {#Background}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Background](#name-background){.section-name .selfRef} {#name-background}

The design requires two basic techniques: encoding of incremental
changes and server push. For incremental changes, existing techniques
include JSON merge patch and JSON patch; this design uses both. For
server push, existing techniques include HTTP/2 and
\[[SSE](#SSE){.xref}\]; this design adopts some design features of
HTTP/2 but uses \[[SSE](#SSE){.xref}\] as the basic server-push design.
The rest of this section gives a non-normative summary of JSON merge
patch, JSON patch, HTTP/2, and
\[[SSE](#SSE){.xref}\].[¶](#section-3-1){.pilcrow}

::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Incremental Encoding: JSON Merge Patch](#name-incremental-encoding-json-m){.section-name .selfRef} {#name-incremental-encoding-json-m}

To avoid always sending complete data, a server needs mechanisms to
encode incremental changes, and JSON merge patch is one mechanism.
\[[RFC7396](#RFC7396){.xref}\] defines the encoding of incremental
changes (called JSON merge patch objects) to be used by the HTTP PATCH
method \[[RFC5789](#RFC5789){.xref}\]. From
\[[RFC7396](#RFC7396){.xref}\], this document adopts only the JSON merge
patch object encoding and does not use the HTTP PATCH method, as the
updates are sent as events instead of HTTP methods; also, the updates
are server to client, and PATCH semantics are more for client to server.
Below is a non-normative summary of JSON merge patch objects; see
\[[RFC7396](#RFC7396){.xref}\] for the normative
definition.[¶](#section-3.1-1){.pilcrow}

::: {#MergePatchOverview}
::: {#section-3.1.1 .section}
#### [3.1.1.](#section-3.1.1){.section-number .selfRef} [JSON Merge Patch Encoding](#name-json-merge-patch-encoding){.section-name .selfRef} {#name-json-merge-patch-encoding}

Informally, a JSON merge patch message consists of a JSON merge patch
object (referred to as a patch in \[[RFC7396](#RFC7396){.xref}\]), which
defines how to transform one JSON value into another using a recursive
merge patch algorithm. Specifically, the patch is computed by treating
two JSON values (first one being the original and the second being the
updated) as trees of nested JSON objects (dictionaries of name/value
pairs), where the leaves are values (e.g., JSON arrays, strings, and
numbers), other than JSON objects, and the path for each leaf is the
sequence of keys leading to that leaf. When the second tree has a
different value for a leaf at a path or adds a new leaf, the patch has a
leaf, at that path, with the new value. When a leaf in the first tree
does not exist in the second tree, the JSON merge patch tree has a leaf
with a JSON \"null\" value. Hence, in the patch, null as the value of a
name/value pair will delete the element with \"name\" in the original
JSON value. The patch does not have an entry for any leaf that has the
same value in both versions. See the MergePatch pseudocode at the
beginning of [Section
2](https://www.rfc-editor.org/rfc/rfc7396#section-2){.relref} of
\[[RFC7396](#RFC7396){.xref}\] for the formal specification of how to
apply a given patch. As a result, if all leaf values are simple scalars,
JSON merge patch is a quite efficient representation of incremental
changes. It is less efficient when leaf values are arrays, because JSON
merge patch replaces arrays in their entirety, even if only one entry
changes.[¶](#section-3.1.1-1){.pilcrow}
:::
:::

::: {#MergePatchALTO}
::: {#section-3.1.2 .section}
#### [3.1.2.](#section-3.1.2){.section-number .selfRef} [JSON Merge Patch ALTO Messages](#name-json-merge-patch-alto-messa){.section-name .selfRef} {#name-json-merge-patch-alto-messa}

To provide both examples of JSON merge patch and a demonstration of the
feasibility of applying JSON merge patch to ALTO, the sections below
show the application of JSON merge patch to two key ALTO
messages.[¶](#section-3.1.2-1){.pilcrow}

::: {#MergePatchNetMapExample}
::: {#section-3.1.2.1 .section}
##### [3.1.2.1.](#section-3.1.2.1){.section-number .selfRef} [JSON Merge Patch Network Map Messages](#name-json-merge-patch-network-ma){.section-name .selfRef} {#name-json-merge-patch-network-ma}

[Section
11.2.1.6](https://www.rfc-editor.org/rfc/rfc7285#section-11.2.1.6){.relref}
of \[[RFC7285](#RFC7285){.xref}\] defines the format of an ALTO network
map message. Assume a simple example ALTO message sending an initial
network map:[¶](#section-3.1.2.1-1){.pilcrow}

::: {#section-3.1.2.1-2}
``` {.sourcecode .lang-json}
  {
    "meta" : {
      "vtag": {
        "resource-id" : "my-network-map",
        "tag" : "da65eca2eb7a10ce8b059740b0b2e3f8eb1d4785"
      }
    },
    "network-map" : {
      "PID1" : {
        "ipv4" : [ "192.0.2.0/24", "198.51.100.0/25" ]
      },
      "PID2" : {
        "ipv4" : [ "198.51.100.128/25" ]
      },
      "PID3" : {
        "ipv4" : [ "0.0.0.0/0" ],
        "ipv6" : [ "::/0" ]
      }
    }
  }
```

[¶](#section-3.1.2.1-2){.pilcrow}
:::

Consider the following JSON merge patch update message, which (1) adds
an ipv4 prefix \"203.0.113.0/25\" and an ipv6 prefix
\"2001:db8:8000::/33\" to \"PID1\", (2) deletes \"PID2\", and (3)
assigns a new \"tag\" to the network
map:[¶](#section-3.1.2.1-3){.pilcrow}

::: {#section-3.1.2.1-4}
``` {.sourcecode .lang-json}
  {
    "meta" : {
      "vtag" : {
        "tag" : "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe"
      }
    },
    "network-map": {
      "PID1" : {
        "ipv4" : [ "192.0.2.0/24", "198.51.100.0/25",
                   "203.0.113.0/25" ],
        "ipv6" : [ "2001:db8:8000::/33" ]
      },
      "PID2" : null
    }
  }
```

[¶](#section-3.1.2.1-4){.pilcrow}
:::

Applying the JSON merge patch update to the initial network map is
equivalent to the following ALTO network
map:[¶](#section-3.1.2.1-5){.pilcrow}

::: {#section-3.1.2.1-6}
``` {.sourcecode .lang-json}
  {
    "meta" : {
      "vtag": {
        "resource-id" : "my-network-map",
        "tag" : "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe"
      }
    },
    "network-map" : {
      "PID1" : {
        "ipv4" : [ "192.0.2.0/24", "198.51.100.0/25",
                   "203.0.113.0/25" ],
        "ipv6" : [ "2001:db8:8000::/33" ]
      },
      "PID3" : {
        "ipv4" : [ "0.0.0.0/0" ],
        "ipv6" : [ "::/0" ]
      }
    }
  }
```

[¶](#section-3.1.2.1-6){.pilcrow}
:::
:::
:::

::: {#MergePatchCostMapExample}
::: {#section-3.1.2.2 .section}
##### [3.1.2.2.](#section-3.1.2.2){.section-number .selfRef} [JSON Merge Patch Cost Map Messages](#name-json-merge-patch-cost-map-m){.section-name .selfRef} {#name-json-merge-patch-cost-map-m}

[Section
11.2.3.6](https://www.rfc-editor.org/rfc/rfc7285#section-11.2.3.6){.relref}
of \[[RFC7285](#RFC7285){.xref}\] defines the format of an ALTO cost map
message. Assume a simple example ALTO message for an initial cost
map:[¶](#section-3.1.2.2-1){.pilcrow}

::: {#section-3.1.2.2-2}
``` {.sourcecode .lang-json}
  {
    "meta" : {
      "dependent-vtags" : [
        {"resource-id": "my-network-map",
         "tag": "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe"
        }
      ],
      "cost-type" : {
        "cost-mode"  : "numerical",
        "cost-metric": "routingcost"
      },
      "vtag": {
        "resource-id" : "my-cost-map",
        "tag" : "3ee2cb7e8d63d9fab71b9b34cbf764436315542e"
      }
    },
    "cost-map" : {
      "PID1": { "PID1": 1,  "PID2": 5,  "PID3": 10 },
      "PID2": { "PID1": 5,  "PID2": 1,  "PID3": 15 },
      "PID3": { "PID1": 20, "PID2": 15  }
    }
  }
```

[¶](#section-3.1.2.2-2){.pilcrow}
:::

The following JSON merge patch message updates the example cost map so
that (1) the \"tag\" field of the cost map is updated, (2) the cost of
PID1-\>PID2 is 9 instead of 5, (3) the cost of PID3-\>PID1 is no longer
available, and (4) the cost of PID3-\>PID3 is defined as
1.[¶](#section-3.1.2.2-3){.pilcrow}

::: {#section-3.1.2.2-4}
``` {.sourcecode .lang-json}
  {
    "meta" : {
      "vtag": {
        "tag": "c0ce023b8678a7b9ec00324673b98e54656d1f6d"
      }
    }
    "cost-map" : {
      "PID1" : { "PID2" : 9 },
      "PID3" : { "PID1" : null, "PID3" : 1 }
    }
  }
```

[¶](#section-3.1.2.2-4){.pilcrow}
:::

Hence, applying the JSON merge patch to the initial cost map is
equivalent to the following ALTO cost
map:[¶](#section-3.1.2.2-5){.pilcrow}

::: {#section-3.1.2.2-6}
``` {.sourcecode .lang-json}
  {
    "meta" : {
      "dependent-vtags" : [
        {"resource-id": "my-network-map",
         "tag": "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe"
        }
      ],
      "cost-type" : {
        "cost-mode"  : "numerical",
        "cost-metric": "routingcost"
      },
      "vtag": {
        "resource-id": "my-cost-map",
        "tag": "c0ce023b8678a7b9ec00324673b98e54656d1f6d"
      }
    },
    "cost-map" : {
      "PID1": { "PID1": 1,  "PID2": 9,  "PID3": 10 },
      "PID2": { "PID1": 5,  "PID2": 1,  "PID3": 15 },
      "PID3": {             "PID2": 15, "PID3": 1  }
    }
  }
```

[¶](#section-3.1.2.2-6){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Incremental Encoding: JSON Patch](#name-incremental-encoding-json-p){.section-name .selfRef} {#name-incremental-encoding-json-p}

::: {#JSONPatchOverview}
::: {#section-3.2.1 .section}
#### [3.2.1.](#section-3.2.1){.section-number .selfRef} [JSON Patch Encoding](#name-json-patch-encoding){.section-name .selfRef} {#name-json-patch-encoding}

One issue of JSON merge patch is that it does not handle array changes
well. In particular, JSON merge patch considers an array as a single
object and hence can only replace an array in its entirety. When the
change is to make a small change to an array, such as the deletion of an
element from a large array, whole-array replacement is inefficient.
Consider the example in [Section
3.1.2.1](#MergePatchNetMapExample){.xref}. To add a new entry to the
ipv4 array for PID1, the server needs to send a whole new array. Another
issue is that JSON merge patch cannot change a value to be null, as the
JSON merge patch processing algorithm (MergePatch in [Section
3.1.1](#MergePatchOverview){.xref}) interprets a null as a removal
instruction. On the other hand, some ALTO resources can have null
values, and it is possible that the update will want to change the new
value to be null.[¶](#section-3.2.1-1){.pilcrow}

JSON patch \[[RFC6902](#RFC6902){.xref}\] can address the preceding
issues. It defines a set of operators to modify a JSON object. See
\[[RFC6902](#RFC6902){.xref}\] for the normative
definition.[¶](#section-3.2.1-2){.pilcrow}
:::
:::

::: {#section-3.2.2 .section}
#### [3.2.2.](#section-3.2.2){.section-number .selfRef} [JSON Patch ALTO Messages](#name-json-patch-alto-messages){.section-name .selfRef} {#name-json-patch-alto-messages}

To provide both examples of JSON patch and a demonstration of the
difference between JSON patch and JSON merge patch, the sections below
show the application of JSON patch to the same updates shown in [Section
3.1.2](#MergePatchALTO){.xref}.[¶](#section-3.2.2-1){.pilcrow}

::: {#section-3.2.2.1 .section}
##### [3.2.2.1.](#section-3.2.2.1){.section-number .selfRef} [JSON Patch Network Map Messages](#name-json-patch-network-map-mess){.section-name .selfRef} {#name-json-patch-network-map-mess}

First, consider the same update as in [Section
3.1.2.1](#MergePatchNetMapExample){.xref} for the network map. Below is
the encoding using JSON patch:[¶](#section-3.2.2.1-1){.pilcrow}

::: {#section-3.2.2.1-2}
``` {.sourcecode .lang-json}
  [
    {
      "op": "replace",
      "path": "/meta/vtag/tag",
      "value": "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe"
    },
    {
      "op": "add",
      "path": "/network-map/PID1/ipv4/2",
      "value": "203.0.113.0/25"
    }
    {
      "op": "add",
      "path": "/network-map/PID1/ipv6",
      "value": ["2001:db8:8000::/33"]
    },
    {
      "op": "remove",
      "path": "/network-map/PID2"
    }
  ]
```

[¶](#section-3.2.2.1-2){.pilcrow}
:::
:::

::: {#section-3.2.2.2 .section}
##### [3.2.2.2.](#section-3.2.2.2){.section-number .selfRef} [JSON Patch Cost Map Messages](#name-json-patch-cost-map-message){.section-name .selfRef} {#name-json-patch-cost-map-message}

Compared with JSON merge patch, JSON patch does not encode cost map
updates efficiently. Consider the cost map update shown in [Section
3.1.2.2](#MergePatchCostMapExample){.xref}, the encoding using JSON
patch is:[¶](#section-3.2.2.2-1){.pilcrow}

::: {#section-3.2.2.2-2}
``` {.sourcecode .lang-json}
  [
    {
      "op": "replace",
      "path": "/meta/vtag/tag",
      "value": "c0ce023b8678a7b9ec00324673b98e54656d1f6d"
    },
    {
      "op": "replace",
      "path": "/cost-map/PID1/PID2",
      "value": 9
    },
    {
      "op": "remove",
      "path": "/cost-map/PID3/PID1"
    },
    {
      "op": "replace",
      "path": "/cost-map/PID3/PID3",
      "value": 1
    }
  ]
```

[¶](#section-3.2.2.2-2){.pilcrow}
:::
:::
:::
:::

::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Multiplexing and Server Push: HTTP/2](#name-multiplexing-and-server-pus){.section-name .selfRef} {#name-multiplexing-and-server-pus}

HTTP/2 \[[RFC7540](#RFC7540){.xref}\] provides two related features:
multiplexing and server push. In particular, HTTP/2 allows a client and
a server to multiplex multiple HTTP requests and responses over a single
TCP connection. The requests and responses can be interleaved on a block
(frame) by block (frame) basis, by indicating the requests and responses
in HTTP/2 messages, avoiding the head-of-line blocking problem
encountered with HTTP/1.1. To achieve the same goal, this design
introduces substream-id to allow a client to receive updates to multiple
resources. HTTP/2 also provides a server-push facility to allow a server
to send asynchronous updates.[¶](#section-3.3-1){.pilcrow}

Despite the two features of HTTP/2, this design chooses a design
compatible with HTTP/1.x for the simplicity of HTTP/1.x. A design based
on HTTP/2 may more likely need to be implemented using a more complex
HTTP/2 client library. In such a case, one approach for using server
push for updates is for the update stream server to send each data
update message as a separate server-push item and let the client apply
those updates as they arrive. An HTTP/2 client library may not
necessarily inform a client application when the server pushes a
resource. Instead, the library might cache the pushed resource and only
deliver it to the client when the client explicitly requests that URI.
Further, it is more likely that a design based on HTTP/2 may encounter
issues with a proxy between the client and the server, in that server
push is optional and can be disabled by any proxy between the client and
the server. This is not a problem for the intended use of server push;
eventually, the client will request those resources, so disabling server
push just adds a delay. But this means that Server Push is not suitable
for resources that the client does not know to
request.[¶](#section-3.3-2){.pilcrow}

Thus, this design leaves a design based on HTTP/2 as a future work and
focuses on ALTO updates on HTTP/1.x and
\[[SSE](#SSE){.xref}\].[¶](#section-3.3-3){.pilcrow}
:::

::: {#SSEOverview}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [Server Push: Server-Sent Event](#name-server-push-server-sent-eve){.section-name .selfRef} {#name-server-push-server-sent-eve}

Server-Sent Events (SSE) are techniques that can work with HTTP/1.1. The
following is a non-normative summary of SSE; see \[[SSE](#SSE){.xref}\]
for its normative definition.[¶](#section-3.4-1){.pilcrow}

SSE enable a server to send new data to a client by \"server push\". The
client establishes an HTTP \[[RFC7230](#RFC7230){.xref}\]
\[[RFC7231](#RFC7231){.xref}\] connection to the server and keeps the
connection open. The server continually sends messages. Each message has
one or more lines, where a line is terminated by a carriage return
immediately followed by a new line, a carriage return not immediately
followed by a new line, or a new line not immediately preceded by a
carriage return. A message is terminated by a blank line (two line
terminators in a row).[¶](#section-3.4-2){.pilcrow}

Each line in a message is of the form \"field-name: string value\".
Lines with a blank field name (that is, lines that start with a colon)
are ignored, as are lines that do not have a colon. The protocol defines
three field names: event, id, and data. If a message has more than one
\"data\" line, the value of the data field is the concatenation of the
values on those lines. There can be only one \"event\" and \"id\" line
per message. The \"data\" field is required; the others are
optional.[¶](#section-3.4-3){.pilcrow}

[Figure 1](#sse-example){.xref} is a sample SSE stream, starting with
the client request. The server sends three events and then closes the
stream.[¶](#section-3.4-4){.pilcrow}

[]{#name-a-sample-sse-stream}

::: {#sse-example}
::: {#section-3.4-5.1}
``` sourcecode
  (Client request)
  GET /stream HTTP/1.1
  Host: example.com
  Accept: text/event-stream

  (Server response)
  HTTP/1.1 200 OK
  Connection: keep-alive
  Content-Type: text/event-stream

  event: start
  id: 1
  data: hello there

  event: middle
  id: 2
  data: let's chat some more ...
  data: and more and more and ...

  event: end
  id: 3
  data: goodbye
```
:::

[Figure 1](#figure-1){.selfRef}: [A Sample SSE
Stream](#name-a-sample-sse-stream){.selfRef}
:::
:::
:::
:::
:::

::: {#Overview}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Overview of Approach and High-Level Protocol Message Flow](#name-overview-of-approach-and-hi){.section-name .selfRef} {#name-overview-of-approach-and-hi}

With the preceding background, this section now gives a non-normative
overview of the update mechanisms and message flow to be defined in
later sections of this document. [Figure 2](#FigOverview){.xref} gives
the main components and overall message flow.[¶](#section-4-1){.pilcrow}

[]{#name-alto-sse-architecture-and-m}

::: {#FigOverview}
::: {#section-4-2.1 .artwork .art-text .alignLeft}
     -------------------------------------------------------------------
    |                                                                   |
    |          +-------+         +-------+ 1. init request   +------+   |
    |          |       |         |       | <--------------   |      |   |
    |          |       |         |       | -------------->   |      |   |
    | 3.add/   |       |         |       | 1'. control URI   |      |   |
    | remove   |       |         |       |                   |      |   |
    | resource |Stream |         |Update |                   |      |   |
      -------->|Control| private |Stream | 2a. data update   |Client| --
               |Server |<------->|Server | messages          |      |
      -------- |       |         |       | --------------->  |      | <-
    | response |       |         |       | --------------->  |      |   |
    |          |       |         |       | 2b. control update|      |   |
    |          +-------+         +-------+ messages          +------+   |
    |                                                                   |
     -------------------------------------------------------------------
:::

[Figure 2](#figure-2){.selfRef}: [ALTO SSE Architecture and Message
Flow](#name-alto-sse-architecture-and-m){.selfRef}
:::

::: {#USSMF}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Update Stream Service Message Flow](#name-update-stream-service-messa){.section-name .selfRef} {#name-update-stream-service-messa}

The building block of the update mechanism defined in this document is
the update stream service (defined in [Section
6](#UpdateStreamService){.xref}), where each update stream service is a
POST-mode service that provides update
streams.[¶](#section-4.1-1){.pilcrow}

Note that the lines of the format \"\*\* \... \*\*\" are used to
describe message flows in this section and the following
sections.[¶](#section-4.1-2){.pilcrow}

[]{.break}

\*\* Initial request: client -\> update server \*\*:

:   When an ALTO client requests an update stream service, the ALTO
    client establishes a persistent connection to the update stream
    server and submits an initial update-stream request (defined in
    [Section 6.5](#UpdateInput.media-type){.xref}), creating an update
    stream. This initial request creating the update stream is labeled
    \"1. init request\" in [Figure
    2](#FigOverview){.xref}.[¶](#section-4.1-3.2.1){.pilcrow}

    An update stream can provide updates to both GET-mode resources,
    such as ALTO network and cost maps, and POST-mode resources, such as
    ALTO endpoint property service. Also, to avoid creating too many
    update streams, this design allows an ALTO client to use one update
    stream to receive updates to multiple requests. In particular, the
    client may request to receive updates for the same resource but with
    different parameters for a POST-mode resource, in addition to being
    able to consolidate updates for multiple resources into a single
    stream. The updates for each request is called a substream and hence
    the update server needs an identifier to indicate the substream when
    sending an update. To achieve this goal, the client assigns a unique
    substream-id when requesting updates to a resource in an update
    stream, and the server puts the substream-id in each
    update.[¶](#section-4.1-3.2.2){.pilcrow}

:   

\*\* Data updates: update server -\> client \*\*:
:   The objective of an update stream is to continuously push (to an
    ALTO client) the data value changes for a set of resources, where
    the set of resources is specified by the ALTO client\'s requests.
    This document refers to messages sending such data-value changes as
    data update messages (defined in [Section
    5.2](#ALTO.SSE.UpdateEvents){.xref}). Although an update stream may
    update one or more requests, each data update message updates only
    one request and is sent as a Server-Sent Event (SSE), as defined by
    \[[SSE](#SSE){.xref}\]. A data update message is encoded either as a
    full replacement or as an incremental change. A full replacement
    uses the JSON message format defined by the ALTO protocol. There can
    be multiple encodings for incremental changes. The current design
    supports incremental changes using JSON merge patch
    \[[RFC7396](#RFC7396){.xref}\] or JSON patch
    \[[RFC6902](#RFC6902){.xref}\] to describe the changes of the
    resource. Future documents may define additional mechanisms for
    incremental changes. The update stream server decides when to send
    data update messages and whether to send full replacements or
    incremental changes. These decisions can vary from resource to
    resource and from update to update. Since the transport is a design
    compatible with HTTP/1.x, data update messages are delivered
    reliably and in order, and the lossless, sequential delivery of its
    messages allows the server to know the exact state of the client to
    compute the correct incremental updates. [Figure
    2](#FigOverview){.xref} shows examples of data update messages
    (labeled \"2a. data update messages\") in the overall message
    flow.[¶](#section-4.1-3.4){.pilcrow}
:   

\*\* Control updates: update server -\> client \*\*:
:   An update stream can run for a long time and hence there can be
    status changes at the update stream server side during the lifetime
    of an update stream; for example, the update stream server may
    encounter an error or need to shut down for maintenance. To support
    a robust, flexible protocol design, this document allows the update
    stream server to send control update messages (defined in [Section
    5.3](#ALTO.SSE.ControlEvents){.xref}) in addition to data update
    messages to the ALTO client. [Figure 2](#FigOverview){.xref} shows
    that both data updates and control updates can be sent by the server
    to the client (labeled \"2b. control update
    messages\").[¶](#section-4.1-3.6){.pilcrow}
:   
:::
:::

::: {#SCSMF}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Stream Control Service Message Flow](#name-stream-control-service-mess){.section-name .selfRef} {#name-stream-control-service-mess}

[]{.break}

\*\* Stream control: client -\> stream control server \*\*:

:   In addition to control changes triggered from the update stream
    server side, in a flexible design, an ALTO client may initiate
    control changes as well, in particular, by adding or removing ALTO
    resources receiving updates. An ALTO client initiates such changes
    using the stream control service (defined in [Section
    7](#UpdateStreamController){.xref}). Although one may use a design
    that the client uses as the same HTTP connection to send the control
    requests, it requires stronger server support, such as HTTP
    pipeline. For more flexibility, this document introduces stream
    control service. In particular, the update stream server of an
    update stream uses the first message to provide the URI of the
    stream control service (labeled \"1\': control URI\" in [Figure
    2](#FigOverview){.xref}).[¶](#section-4.2-1.2.1){.pilcrow}

    The ALTO client can then use the URI to ask the stream control
    server specified in the URI to request the update stream server
    to (1) send data update messages for additional resources, (2) stop
    sending data update messages for previously requested resources,
    or (3) gracefully stop and close the update stream
    altogether.[¶](#section-4.2-1.2.2){.pilcrow}

:   
:::
:::

::: {#SAMMF}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Service Announcement and Management Message Flow](#name-service-announcement-and-ma){.section-name .selfRef} {#name-service-announcement-and-ma}

[]{.break}

\*\* Service announcements: IRD server -\> client \*\*:
:   An update server may provide any number of update stream services,
    where each update stream may provide updates for a given subset of
    the ALTO server\'s resources. An ALTO server\'s Information Resource
    Directory (IRD) defines the update stream services and declares the
    set of resources for which each update stream service provides
    updates. The ALTO server selects the resource set for each update
    stream service. It is recommended that if a resource depends on one
    or more other resource(s) (indicated with the \"uses\" attribute
    defined in \[[RFC7285](#RFC7285){.xref}\]), these other resource(s)
    should also be part of that update stream. Thus, the update stream
    for a cost map should also provide updates for the network map on
    which that cost map depends.[¶](#section-4.3-1.2){.pilcrow}
:   

\*\* Service management (server) \*\*:
:   An ALTO client may request any number of update streams
    simultaneously. Because each update stream consumes resources on the
    update stream server, an update stream server may require client
    authorization and/or authentication, limit the number of open update
    streams, close inactive streams, or redirect an ALTO client to
    another update stream server.[¶](#section-4.3-1.4){.pilcrow}
:   
:::
:::
:::
:::

::: {#ALTO.SSE.Events}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Update Messages: Data Update and Control Update Messages](#name-update-messages-data-update){.section-name .selfRef} {#name-update-messages-data-update}

This section defines the format of update messages sent from the server
to the client. It first defines the generic structure of update messages
([Section 5.1](#ALTO.SSE.EventFormat){.xref}). It then defines the
details of the data update messages ([Section
5.2](#ALTO.SSE.UpdateEvents){.xref}) and the control update messages
([Section 5.3](#ALTO.SSE.ControlEvents){.xref}). These messages will be
used in the next two sections to define the update stream service
([Section 6](#UpdateStreamService){.xref}) and the stream control
service ([Section
7](#UpdateStreamController){.xref}).[¶](#section-5-1){.pilcrow}

::: {#ALTO.SSE.EventFormat}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Generic ALTO Update Message Structure](#name-generic-alto-update-message){.section-name .selfRef} {#name-generic-alto-update-message}

Both data update and control update messages from the server to the
client have the same basic structure. Each message includes a data field
to provide data information, which is typically a JSON object, and an
event field preceding the data field, to specify the media type
indicating the encoding of the data field.[¶](#section-5.1-1){.pilcrow}

A data update message needs additional information to identify the ALTO
data (object) to which the update message applies. To be generic, this
document uses a data-id to identify the ALTO data (object) to be
updated; see below.[¶](#section-5.1-2){.pilcrow}

Hence, the event field of ALTO update message can include two subfields
(media-type and data-id), where the two subfields are separated by a
comma (\',\', U+002C):[¶](#section-5.1-3){.pilcrow}

::: {#section-5.1-4}
``` sourcecode
      media-type [ ',' data-id ]
```

[¶](#section-5.1-4){.pilcrow}
:::

According to [Section
4.2](https://www.rfc-editor.org/rfc/rfc6838#section-4.2){.relref} of
\[[RFC6838](#RFC6838){.xref}\], the comma character is not allowed in a
media-type name so there is no ambiguity when decoding of the two
subfields.[¶](#section-5.1-5){.pilcrow}

Note that an update message does not use the SSE \"id\"
field.[¶](#section-5.1-6){.pilcrow}
:::
:::

::: {#ALTO.SSE.UpdateEvents}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [ALTO Data Update Message](#name-alto-data-update-message){.section-name .selfRef} {#name-alto-data-update-message}

A data update message is sent when a monitored resource changes. As
discussed in the preceding section, the event field of a data update
message includes two subfields: \'media-type\' and
\'data-id\'.[¶](#section-5.2-1){.pilcrow}

The \'media-type\' subfield depends on whether the data update is a
complete specification of the identified data or an incremental patch
(e.g., a JSON merge patch or JSON patch), if possible, describing the
changes from the last version of the data. This document refers to these
as full replacement and incremental change, respectively. The encoding
of a full replacement is defined by its defining document (e.g., network
and cost map messages by \[[RFC7285](#RFC7285){.xref}\]) and uses the
media type defined in that document. The encoding of JSON merge patch is
defined by \[[RFC7396](#RFC7396){.xref}\], with the media type
\"application/merge-patch+json\"; the encoding of JSON patch is defined
by \[[RFC6902](#RFC6902){.xref}\], with media type
\"application/json-patch+json\".[¶](#section-5.2-2){.pilcrow}

The \'data-id\' subfield identifies the ALTO data to which the data
update message applies.[¶](#section-5.2-3){.pilcrow}

First, consider the case that the resource contains only a single JSON
object. For example, since an ALTO client can request data updates for
both a cost map resource (object) and its dependent network map resource
(object) in the same update stream, to distinguish the updates, the
client assigns a substream-id for each resource receiving data updates.
Substream-ids [MUST]{.bcp14} be unique within an update stream but need
not be globally unique. A substream-id is encoded as a JSON string with
the same format as that of the type ResourceID ([Section
10.2](https://www.rfc-editor.org/rfc/rfc7285#section-10.2){.relref} of
\[[RFC7285](#RFC7285){.xref}\]). The type SubstreamID is used in this
document to indicate a string of this format. The substream-id of a
single JSON object is the \'data-id\'.[¶](#section-5.2-4){.pilcrow}

As an example, assume that the ALTO client assigns substream-id \"1\" in
its request to receive updates to the network map and substream-id \"2\"
to the cost map. Then, the substream-ids are the data-ids indicating
which objects will be updated. [Figure 3](#alto-sse-example){.xref}
shows some examples of ALTO data update
messages:[¶](#section-5.2-5){.pilcrow}

[]{#name-examples-of-alto-data-updat}

::: {#alto-sse-example}
::: {#section-5.2-6.1}
``` sourcecode
  event: application/alto-networkmap+json,1
  data: { ... full network map message ... }

  event: application/alto-costmap+json,2
  data: { ... full cost map message ... }

  event: application/merge-patch+json,2
  data: { ... JSON merge patch update for the cost map ... }
```
:::

[Figure 3](#figure-3){.selfRef}: [Examples of ALTO Data Update
Messages](#name-examples-of-alto-data-updat){.selfRef}
:::

Next, consider the case that a resource may include multiple JSON
objects. This document considers the case that a resource may contain
multiple components (parts), and they are encoded using the media type
\"multipart/related\" \[[RFC2387](#RFC2387){.xref}\]. Each part of this
multipart response [MUST]{.bcp14} be an HTTP message including a
Content-ID header and a JSON object body. Each component requiring the
update stream service (defined in [Section
6](#UpdateStreamService){.xref}) [MUST]{.bcp14} be identified by a
unique Content-ID to be defined in its defining
document.[¶](#section-5.2-7){.pilcrow}

For a resource using the media type \"multipart/related\", the
\'data-id\' subfield [MUST]{.bcp14} be the concatenation of the
substream-id, the \'.\' separator (U+002E), and the unique Content-ID,
in order.[¶](#section-5.2-8){.pilcrow}
:::
:::

::: {#ALTO.SSE.ControlEvents}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [ALTO Control Update Message](#name-alto-control-update-message){.section-name .selfRef} {#name-alto-control-update-message}

Control update messages have the media type
\"application/alto-updatestreamcontrol+json\", and the data is of type
UpdateStreamControlEvent:[¶](#section-5.3-1){.pilcrow}

::: {#section-5.3-2}
``` sourcecode
  object {
     [String          control-uri;]
     [SubstreamID     started<1..*>;]
     [SubstreamID     stopped<1..*>;]
     [String          description;]
  } UpdateStreamControlEvent;
```

[¶](#section-5.3-2){.pilcrow}
:::

[]{.break}

control-uri:
:   the URI providing stream control for this update stream (see
    [Section 7](#UpdateStreamController){.xref}). The server sends a
    control update message notifying the client of the control-uri. This
    control update message notifying the control-uri will be sent once
    and [MUST]{.bcp14} be the first event in an update stream. If the
    URI value is NULL, the update stream server does not support stream
    control for this update stream; otherwise, the update stream server
    provides stream control through the given
    URI.[¶](#section-5.3-3.2){.pilcrow}
:   

started:
:   a list of substream-ids of resources. It notifies the ALTO client
    that the update stream server will start sending data update
    messages for each resource listed.[¶](#section-5.3-3.4){.pilcrow}
:   

stopped:
:   a list of substream-ids of resources. It notifies the ALTO client
    that the update stream server will no longer send data update
    messages for the listed resources. There can be multiple reasons for
    an update stream server to stop sending data update messages for a
    resource, including a request from the ALTO client using stream
    control ([Section
    6.7.1](#UpdateStreamService.Response.Sequence){.xref}) or an
    internal server event.[¶](#section-5.3-3.6){.pilcrow}
:   

description:
:   a non-normative, human-readable text providing an explanation for
    the control event. When an update stream server stops sending data
    update messages for a resource, it is [RECOMMENDED]{.bcp14} that the
    update stream server use the description field to provide details.
    There can be multiple reasons that trigger a \"stopped\" event; see
    above. The intention of this field is to provide a human-readable
    text for the developer and/or the administrator to diagnose
    potential problems.[¶](#section-5.3-3.8){.pilcrow}
:   
:::
:::
:::
:::

::: {#UpdateStreamService}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Update Stream Service](#name-update-stream-service){.section-name .selfRef} {#name-update-stream-service}

An update stream service returns a stream of update messages, as defined
in [Section 5](#ALTO.SSE.Events){.xref}. An ALTO server\'s IRD
(Information Resource Directory) [MAY]{.bcp14} define one or more update
stream services, which ALTO clients use to request new update stream
instances. An IRD entry defining an update stream service [MUST]{.bcp14}
define the media type, HTTP method, and capabilities and uses as
follows.[¶](#section-6-1){.pilcrow}

::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Media Type](#name-media-type){.section-name .selfRef} {#name-media-type}

The media type of an ALTO update stream service is
\"text/event-stream\", as defined by
\[[SSE](#SSE){.xref}\].[¶](#section-6.1-1){.pilcrow}
:::

::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [HTTP Method](#name-http-method){.section-name .selfRef} {#name-http-method}

An ALTO update stream service is requested using the HTTP POST
method.[¶](#section-6.2-1){.pilcrow}
:::

::: {#UpdateStreamService.Capabilities}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Capabilities](#name-capabilities){.section-name .selfRef} {#name-capabilities}

The capabilities are defined as an object of type
UpdateStreamCapabilities:[¶](#section-6.3-1){.pilcrow}

::: {#section-6.3-2}
``` sourcecode
  object {
    IncrementalUpdateMediaTypes incremental-change-media-types;
    Boolean                     support-stream-control;
  } UpdateStreamCapabilities;

  object-map {
     ResourceID -> String;
  } IncrementalUpdateMediaTypes;
```

[¶](#section-6.3-2){.pilcrow}
:::

If this update stream can provide data update messages with incremental
changes for a resource, the \"incremental-change-media-types\" field has
an entry for that resource-id, and the value is the supported media
types of the incremental change separated by commas. Normally, this will
be \"application/merge-patch+json\", \"application/json-patch+json\", or
\"application/merge-patch+json,application/json-patch+json\", because,
as described in [Section 5](#ALTO.SSE.Events){.xref}, they are the only
incremental change types defined by this document. However, future
extensions may define other types of incremental
changes.[¶](#section-6.3-3){.pilcrow}

When choosing the media types to encode incremental changes for a
resource, the update stream server [MUST]{.bcp14} consider the
limitations of the encoding. For example, when a JSON merge patch
specifies that the value of a field is null, its semantics are that the
field is removed from the target and hence the field is no longer
defined (i.e., undefined); see the MergePatch algorithm in [Section
3.1.1](#MergePatchOverview){.xref} on how null value is processed. This,
however, may not be the intended result for the resource, when null and
undefined have different semantics for the resource. In such a case, the
update stream server [MUST]{.bcp14} choose JSON patch over JSON merge
patch if JSON patch is indicated as a capability of the update stream
server. If the server does not support JSON patch to handle such a case,
the server then need to send a full
replacement.[¶](#section-6.3-4){.pilcrow}

The \"support-stream-control\" field specifies whether the given update
stream supports stream control. If the \"support-stream-control\" field
is \"true\", the update stream server will use the stream control
specified in this document; otherwise, the update stream server may use
other mechanisms to provide the same functionality as stream
control.[¶](#section-6.3-5){.pilcrow}
:::
:::

::: {#UpdateStreamService.Uses}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [Uses](#name-uses){.section-name .selfRef} {#name-uses}

The \"uses\" attribute [MUST]{.bcp14} be an array with the resource-ids
of every resource for which this update stream can provide updates. Each
resource specified in the \"uses\" [MUST]{.bcp14} support full
replacement; the update stream server can always send full replacement,
and the ALTO client [MUST]{.bcp14} accept full
replacement.[¶](#section-6.4-1){.pilcrow}

This set may be any subset of the ALTO server\'s resources and may
include resources defined in linked IRDs. However, it is
[RECOMMENDED]{.bcp14} that the ALTO server selects a set that is closed
under the resource dependency relationship. That is, if an update
stream\'s \"uses\" set includes resource R1 and resource R1 depends on
(\"uses\") resource R0, then the update stream\'s \"uses\" set
[SHOULD]{.bcp14} include R0 as well as R1. For example, an update stream
for a cost map [SHOULD]{.bcp14} also provide updates for the network map
upon which that cost map depends.[¶](#section-6.4-2){.pilcrow}
:::
:::

::: {#UpdateInput.media-type}
::: {#section-6.5 .section}
### [6.5.](#section-6.5){.section-number .selfRef} [Request: Accept Input Parameters](#name-request-accept-input-parame){.section-name .selfRef} {#name-request-accept-input-parame}

An ALTO client specifies the parameters for the new update stream by
sending an HTTP POST body with the media type
\"application/alto-updatestreamparams+json\". That body contains a JSON
object of type UpdateStreamReq, where:[¶](#section-6.5-1){.pilcrow}

::: {#section-6.5-2}
``` sourcecode
  object {
     [AddUpdatesReq   add;]
     [SubstreamID     remove<0..*>;]
  } UpdateStreamReq;

  object-map {
     SubstreamID -> AddUpdateReq;
  } AddUpdatesReq;

  object {
     ResourceID   resource-id;
     [JSONString  tag;]
     [Boolean     incremental-changes;]
     [Object      input;]
  } AddUpdateReq;
```

[¶](#section-6.5-2){.pilcrow}
:::

[]{.break}

add:
:   Specifies the resources (and the parameters for the resources) for
    which the ALTO client wants updates. In the scope of the same update
    stream, the ALTO client [MUST]{.bcp14} assign a substream-id that is
    unique in the scope of the update stream ([Section
    5.2](#ALTO.SSE.UpdateEvents){.xref}) for each entry and use those
    substream-ids as the keys in the \"add\"
    field.[¶](#section-6.5-3.2){.pilcrow}
:   

resource-id:
:   The resource-id of an ALTO resource and [MUST]{.bcp14} be in the
    update stream\'s \"uses\" list ([Section
    6.4](#UpdateStreamService.Uses){.xref}). If the resource-id is a
    GET-mode resource with a version tag (or \"vtag\"), as defined in
    Sections
    [6.3](https://www.rfc-editor.org/rfc/rfc7285#section-6.3){.relref}
    and
    [10.3](https://www.rfc-editor.org/rfc/rfc7285#section-10.3){.relref}
    of \[[RFC7285](#RFC7285){.xref}\], and the ALTO client has
    previously retrieved a version of that resource from the update
    stream server, the ALTO client [MAY]{.bcp14} set the \"tag\" field
    to the tag part of the client\'s version of that resource. If that
    version is not current, the update stream server [MUST]{.bcp14} send
    a full replacement before sending any incremental changes, as
    described in [Section
    6.7.1](#UpdateStreamService.Response.Sequence){.xref}. If that
    version is still current, the update stream server [MAY]{.bcp14}
    omit the initial full replacement.[¶](#section-6.5-3.4){.pilcrow}
:   

incremental-changes:
:   The ALTO client specifies whether it is willing to receive
    incremental changes from the update stream server for this
    substream. If the \"incremental-changes\" field is \"true\", the
    update stream server [MAY]{.bcp14} send incremental changes for this
    substream. In this case, the client [MUST]{.bcp14} support all
    incremental methods from the set announced in the server\'s
    capabilities for this resource; see [Section
    6.3](#UpdateStreamService.Capabilities){.xref} for the server\'s
    announcement of potential incremental methods. If a client does not
    support all incremental methods from the set announced in the
    server\'s capabilities, the client can set \"incremental-changes\"
    to \"false\", and the update stream server then [MUST NOT]{.bcp14}
    send incremental changes for that substream. The default value for
    \"incremental-changes\" is \"true\", so to suppress incremental
    changes, the ALTO client [MUST]{.bcp14} explicitly set
    \"incremental-changes\" to \"false\". An alternative design of
    incremental-changes control is a more fine-grained control, by
    allowing a client to select a subset of incremental methods from the
    set announced in the server\'s capabilities. But this alternative
    design is not adopted in this document, because it adds complexity
    to the server, which is more likely to be the bottleneck. Note that
    the ALTO client cannot suppress full replacement. When the ALTO
    client sets \"incremental-changes\" to \"false\", the update stream
    server [MUST]{.bcp14} send a full replacement instead of an
    incremental change to the ALTO client. The update stream server
    [MAY]{.bcp14} wait until more changes are available and send a
    single full replacement with those changes. Thus, an ALTO client
    that declines to accept incremental changes may not get updates as
    quickly as an ALTO client that does.[¶](#section-6.5-3.6){.pilcrow}
:   

input:
:   If the resource is a POST-mode service that requires input, the ALTO
    client [MUST]{.bcp14} set the \"input\" field to a JSON object with
    the parameters that the resource
    expects.[¶](#section-6.5-3.8){.pilcrow}
:   

remove:
:   It is used in update stream control requests ([Section
    7](#UpdateStreamController){.xref}) and is not allowed in the update
    stream request. The update stream server [SHOULD]{.bcp14} ignore
    this field if it is included in the
    request.[¶](#section-6.5-3.10){.pilcrow}
:   

If a request has any errors, the update stream server [MUST NOT]{.bcp14}
create an update stream. Also, the update stream server will send an
error response to the ALTO client, as specified in [Section
6.6](#UpdateStreamService.Response){.xref}.[¶](#section-6.5-4){.pilcrow}
:::
:::

::: {#UpdateStreamService.Response}
::: {#section-6.6 .section}
### [6.6.](#section-6.6){.section-number .selfRef} [Response](#name-response){.section-name .selfRef} {#name-response}

If the update stream request has any errors, the update stream server
[MUST]{.bcp14} return an HTTP \"400 Bad Request\" to the ALTO client;
the body of the response follows the generic ALTO error response format
specified in [Section
8.5.2](https://www.rfc-editor.org/rfc/rfc7285#section-8.5.2){.relref} of
\[[RFC7285](#RFC7285){.xref}\]. Hence, an example ALTO error response
has the format:[¶](#section-6.6-1){.pilcrow}

::: {#section-6.6-2}
``` sourcecode
       HTTP/1.1 400 Bad Request
       Content-Length: 131
       Content-Type: application/alto-error+json
       Connection: Closed

       {
           "meta":{
               "code":  "E_INVALID_FIELD_VALUE",
               "field": "add/my-network-map/resource-id",
               "value": "my-networkmap/#"
           }
       }
```

[¶](#section-6.6-2){.pilcrow}
:::

Note that \"field\" and \"value\" are optional fields. If the \"value\"
field exists, the \"field\" field [MUST]{.bcp14}
exist.[¶](#section-6.6-3){.pilcrow}

-   [If an update stream request does not have an \"add\" field
    specifying one or more resources, the error code of the error
    message [MUST]{.bcp14} be E_MISSING_FIELD and the \"field\" field
    [SHOULD]{.bcp14} be \"add\". The update stream server [MUST]{.bcp14}
    close the stream without sending any
    events.[¶](#section-6.6-4.1){.pilcrow}]{#section-6.6-4.1}
-   [If the \"resource-id\" field is invalid or is not associated with
    the update stream, the error code of the error message
    [MUST]{.bcp14} be E_INVALID_FIELD_VALUE. The \"field\" field
    [SHOULD]{.bcp14} be the full path of the \"resource-id\" field, and
    the \"value\" field [SHOULD]{.bcp14} be the invalid resource-id. If
    there are more than one invalid resource-ids, the update stream
    server [SHOULD]{.bcp14} pick one and return it. The update stream
    server [MUST]{.bcp14} close the stream (i.e., TCP connection)
    without sending any
    events.[¶](#section-6.6-4.2){.pilcrow}]{#section-6.6-4.2}
-   [If the resource is a POST-mode service that requires input, the
    client [MUST]{.bcp14} set the \"input\" field to a JSON object with
    the parameters that that resource expects. If the \"input\" field is
    missing or invalid, the update stream server [MUST]{.bcp14} return
    the same error response that that resource would return for missing
    or invalid input (see \[[RFC7285](#RFC7285){.xref}\]). In this case,
    the update stream server [MUST]{.bcp14} close the update stream
    without sending any events. If the input for several POST-mode
    resources is missing or invalid, the update stream server
    [MUST]{.bcp14} pick one and return
    it.[¶](#section-6.6-4.3){.pilcrow}]{#section-6.6-4.3}

The response to a valid request is a stream of update messages. [Section
5](#ALTO.SSE.Events){.xref} defines the update messages, and
\[[SSE](#SSE){.xref}\] defines how they are encoded into a
stream.[¶](#section-6.6-5){.pilcrow}

An update stream server [SHOULD]{.bcp14} send updates only when the
underlying values change. However, it may be difficult for an update
stream server to guarantee that in all circumstances. Therefore, a
client [MUST NOT]{.bcp14} assume that an update message represents an
actual change.[¶](#section-6.6-6){.pilcrow}
:::
:::

::: {#AddReq}
::: {#section-6.7 .section}
### [6.7.](#section-6.7){.section-number .selfRef} [Additional Requirements on Update Stream Service](#name-additional-requirements-on-){.section-name .selfRef} {#name-additional-requirements-on-}

::: {#UpdateStreamService.Response.Sequence}
::: {#section-6.7.1 .section}
#### [6.7.1.](#section-6.7.1){.section-number .selfRef} [Event Sequence Requirements](#name-event-sequence-requirements){.section-name .selfRef} {#name-event-sequence-requirements}

-   [The first event [MUST]{.bcp14} be a control update message with the
    URI of the update stream control service (see [Section
    7](#UpdateStreamController){.xref}) for this update stream. Note
    that the value of the control-uri can be \"null\", indicating that
    there is no control stream
    service.[¶](#section-6.7.1-1.1){.pilcrow}]{#section-6.7.1-1.1}
-   [As soon as possible, after the ALTO client initiates the
    connection, the update stream server checks the \"tag\" field for
    each added update request. If the \"tag\" field is not specified in
    an added update request, the update stream server [MUST]{.bcp14}
    first send a full replacement for the request. If the \"tag\" field
    is specified, the client can accept incremental changes, and the
    server can compute an incremental update based on the \"tag\" (the
    server needs to ensure that for a POST resource with input, the
    \"tag\" should indicate the correct result for different inputs);
    the update stream server [MAY]{.bcp14} omit the initial full
    replacement.[¶](#section-6.7.1-1.2){.pilcrow}]{#section-6.7.1-1.2}
-   [If this update stream provides updates for resource-ids R0 and R1
    and if R1 depends on R0, then the update stream server
    [MUST]{.bcp14} send the update for R0 before sending the related
    updates for R1. For example, suppose an update stream provides
    updates to a network map and its dependent cost maps. When the
    network map changes, the update stream server [MUST]{.bcp14} send
    the network map update before sending the cost map
    updates.[¶](#section-6.7.1-1.3){.pilcrow}]{#section-6.7.1-1.3}
-   [When the ALTO client uses the stream control service to stop
    updates for one or more resources ([Section
    7](#UpdateStreamController){.xref}), the ALTO client [MUST]{.bcp14}
    send a stream control request. The update stream server
    [MUST]{.bcp14} send a control update message whose \"stopped\" field
    has the substream-ids of all stopped
    resources.[¶](#section-6.7.1-1.4){.pilcrow}]{#section-6.7.1-1.4}
:::
:::

::: {#UpdateStream.Response.Consistency}
::: {#section-6.7.2 .section}
#### [6.7.2.](#section-6.7.2){.section-number .selfRef} [Cross-Stream Consistency Requirements](#name-cross-stream-consistency-re){.section-name .selfRef} {#name-cross-stream-consistency-re}

If multiple ALTO clients create multiple update streams from the same
update stream resource and with the same update request parameters
(i.e., same resource and same input), the update stream server
[MUST]{.bcp14} send the same updates to all of them. However, the update
stream server [MAY]{.bcp14} pack data items into different patch events,
as long as the net result of applying those updates is the
same.[¶](#section-6.7.2-1){.pilcrow}

For example, suppose two different ALTO clients create two different
update streams for the same cost map, and suppose the update stream
server processes three separate cost point updates with a brief pause
between each update. The server [MUST]{.bcp14} send all three new cost
points to both clients. But the update stream server [MAY]{.bcp14} send
a single patch event (with all three cost points) to one ALTO client
while sending three separate patch events (with one cost point per
event) to the other ALTO client.[¶](#section-6.7.2-2){.pilcrow}

An update stream server [MAY]{.bcp14} offer several different update
stream resources that provide updates to the same underlying resource
(that is, a resource-id may appear in the \"uses\" field of more than
one update stream resource). In this case, those update stream resources
[MUST]{.bcp14} return the same update.[¶](#section-6.7.2-3){.pilcrow}
:::
:::

::: {#UpdateStreamService.Response.Multipart}
::: {#section-6.7.3 .section}
#### [6.7.3.](#section-6.7.3){.section-number .selfRef} [Multipart Update Requirements](#name-multipart-update-requiremen){.section-name .selfRef} {#name-multipart-update-requiremen}

This design allows any valid media type for full replacement. Hence, it
supports ALTO resources using multipart to contain multiple JSON
objects. This realizes the push benefit but not the incremental encoding
benefit of SSE.[¶](#section-6.7.3-1){.pilcrow}

JSON patch and merge patch provide the incremental encoding benefit but
can be applied to only a single JSON object. If an update stream service
supports a resource providing a multipart media type, which we refer to
as a multipart resource, then the update stream service needs to handle
the issue that the message of a full multipart resource can include
multiple JSON objects. To address the issue, when an update stream
service specifies that it supports JSON patch or merge patch incremental
updates for a multipart resource, the service [MUST]{.bcp14} ensure that
(1) each part of a multipart message is a single JSON object, (2) each
part is specified by a static Content-ID in the initial full message,
(3) each data update event applies to only one part, and (4) each data
update specifies substream-id.content-id as the \"event\" field of the
event, to identify the part to be
updated.[¶](#section-6.7.3-2){.pilcrow}
:::
:::
:::
:::

::: {#UpdateStreamService.keep-alive}
::: {#section-6.8 .section}
### [6.8.](#section-6.8){.section-number .selfRef} [Keep-Alive Messages](#name-keep-alive-messages){.section-name .selfRef} {#name-keep-alive-messages}

In an SSE stream, any line that starts with a colon (U+003A) character
is a comment, and an ALTO client [MUST]{.bcp14} ignore that line
\[[SSE](#SSE){.xref}\]. As recommended in \[[SSE](#SSE){.xref}\], an
update stream server [SHOULD]{.bcp14} send a comment line (or an event)
every 15 seconds to prevent ALTO clients and proxy servers from dropping
the HTTP connection. Note that although TCP also provides a Keep-Alive
function, the interval between TCP Keep-Alive messages can depend on the
OS configuration and varies. The preceding recommended SSE Keep-Alive
allows the SSE client to detect the status of the update stream server
with more certainty.[¶](#section-6.8-1){.pilcrow}
:::
:::
:::
:::

::: {#UpdateStreamController}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Stream Control Service](#name-stream-control-service){.section-name .selfRef} {#name-stream-control-service}

A stream control service allows an ALTO client to remove resources from
the set of resources that are monitored by an update stream or add
additional resources to that set. The service also allows an ALTO client
to gracefully shut down an update stream.[¶](#section-7-1){.pilcrow}

When an update stream server creates a new update stream and if the
update stream server supports stream control for the update stream, the
update stream server creates a stream control service for that update
stream. An ALTO client uses the stream control service to remove
resources from the update stream instance or to request updates for
additional resources. An ALTO client cannot obtain the stream control
service through the IRD. Instead, the first event that the update stream
server sends to the ALTO client has the URI for the associated stream
control service (see [Section
5.3](#ALTO.SSE.ControlEvents){.xref}).[¶](#section-7-2){.pilcrow}

Each stream control request is an individual HTTP request. The ALTO
client [MAY]{.bcp14} send multiple stream control requests to the stream
control server using the same HTTP
connection.[¶](#section-7-3){.pilcrow}

::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [URI](#name-uri){.section-name .selfRef} {#name-uri}

The URI for a stream control service, by itself, [MUST]{.bcp14} uniquely
specify the update stream instance that it controls. The stream control
server [MUST NOT]{.bcp14} use other properties of an HTTP request, such
as cookies or the client\'s IP address, to determine the update stream.
Furthermore, an update stream server [MUST NOT]{.bcp14} reuse a control
service URI once the associated update stream has been
closed.[¶](#section-7.1-1){.pilcrow}

The ALTO client [MUST]{.bcp14} evaluate a relative control URI reference
\[[RFC3986](#RFC3986){.xref}\] (for example, a URI reference without a
host or with a relative path) in the context of the URI used to create
the update stream. The stream control service\'s host [MAY]{.bcp14} be
different from the update stream\'s host.[¶](#section-7.1-2){.pilcrow}

It is expected that there is an internal mechanism to map a stream
control URI to the unique update stream instance to be controlled. For
example, the update stream service may assign a unique, internal stream
id to each update stream instance. However, the exact mechanism is left
to the update stream service provider.[¶](#section-7.1-3){.pilcrow}

To prevent an attacker from forging a stream control URI and sending
bogus requests to disrupt other update streams, the service should
consider two security issues. First, if http, not https, is used, the
stream control URI can be exposed to an on-path attacker. To address
this issue, in a setting where the path from the server to the client
can traverse such an attacker, the server [SHOULD]{.bcp14} use https.
Second, even without direct exposure, an off-path attacker may guess
valid stream control URIs. To address this issue, the server
[SHOULD]{.bcp14} choose stream control URIs with enough randomness to
make guessing difficult; the server [SHOULD]{.bcp14} introduce
mechanisms that detect repeated guesses indicating an attack (e.g.,
keeping track of the number of failed stream control attempts). Please
see the W3C\'s \"Good Practices for Capability URLs\"
\<<https://www.w3.org/TR/capability-urls/>\>.[¶](#section-7.1-4){.pilcrow}
:::

::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Media Type](#name-media-type-2){.section-name .selfRef} {#name-media-type-2}

An ALTO stream control response does not have a specific media
type.[¶](#section-7.2-1){.pilcrow}
:::

::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [HTTP Method](#name-http-method-2){.section-name .selfRef} {#name-http-method-2}

An ALTO update stream control resource is requested using the HTTP POST
method.[¶](#section-7.3-1){.pilcrow}
:::

::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [IRD Capabilities & Uses](#name-ird-capabilities-uses){.section-name .selfRef} {#name-ird-capabilities-uses}

None (Stream control services do not appear in the
IRD).[¶](#section-7.4-1){.pilcrow}
:::

::: {#ControlStream.media-type}
::: {#section-7.5 .section}
### [7.5.](#section-7.5){.section-number .selfRef} [Request: Accept Input Parameters](#name-request-accept-input-paramet){.section-name .selfRef} {#name-request-accept-input-paramet}

A stream control service accepts the same input media type and input
parameters as the update stream service ([Section
6.5](#UpdateInput.media-type){.xref}). The only difference is that a
stream control service also accepts the \"remove\"
field.[¶](#section-7.5-1){.pilcrow}

If specified, the \"remove\" field is an array of substream-ids the ALTO
client previously added to this update stream. An empty \"remove\" array
is equivalent to a list of all currently active resources; the update
stream server responds by removing all resources and closing the
stream.[¶](#section-7.5-2){.pilcrow}

An ALTO client [MAY]{.bcp14} use the \"add\" field to add additional
resources. The ALTO client [MUST]{.bcp14} assign a unique substream-id
to each additional resource. Substream-ids [MUST]{.bcp14} be unique over
the lifetime of this update stream; an ALTO client [MUST NOT]{.bcp14}
reuse a previously removed substream-id. The processing of an \"add\"
resource is the same as discussed in Sections
[6.5](#UpdateInput.media-type){.xref} and
[6.6](#UpdateStreamService.Response){.xref}.[¶](#section-7.5-3){.pilcrow}

If a request has any errors, the update stream server [MUST NOT]{.bcp14}
add or remove any resources from the associated update stream. Also, the
stream control server will return an error response to the client, as
specified in [Section
7.6](#ControlStream.Response){.xref}.[¶](#section-7.5-4){.pilcrow}
:::
:::

::: {#ControlStream.Response}
::: {#section-7.6 .section}
### [7.6.](#section-7.6){.section-number .selfRef} [Response](#name-response-2){.section-name .selfRef} {#name-response-2}

The stream control server [MUST]{.bcp14} process the \"add\" field
before the \"remove\" field. If the request removes all active resources
without adding any additional resources, the update stream server
[MUST]{.bcp14} close the update stream. Thus, an update stream cannot
have zero resources.[¶](#section-7.6-1){.pilcrow}

If the request has any errors, the stream control server [MUST]{.bcp14}
return an HTTP \"400 Bad Request\" to the ALTO client. The body part of
the response follows the generic ALTO error response format specified in
[Section
8.5.2](https://www.rfc-editor.org/rfc/rfc7285#section-8.5.2){.relref} of
\[[RFC7285](#RFC7285){.xref}\]. An error response has the same format as
specified in [Section 6.6](#UpdateStreamService.Response){.xref}.
Detailed error code and error information are specified as
below.[¶](#section-7.6-2){.pilcrow}

-   [If the \"add\" request does not satisfy the requirements in
    [Section 6.5](#UpdateInput.media-type){.xref}, the stream control
    server [MUST]{.bcp14} return the ALTO error message defined in
    [Section
    6.6](#UpdateStreamService.Response){.xref}.[¶](#section-7.6-3.1){.pilcrow}]{#section-7.6-3.1}
-   [If any substream-id in the \"remove\" field was not added in a
    prior request, the error code of the error message [MUST]{.bcp14} be
    E_INVALID_FIELD_VALUE, the \"field\" field [SHOULD]{.bcp14} be
    \"remove\", and the \"value\" field [SHOULD]{.bcp14} be an array of
    the invalid substream-ids. Thus, it is illegal to \"add\" and
    \"remove\" the same substream-id in the same request. However, it is
    legal to remove a substream-id twice. To support the preceding
    checking, the update stream server [MUST]{.bcp14} keep track of
    previously used but now closed
    substream-ids.[¶](#section-7.6-3.2){.pilcrow}]{#section-7.6-3.2}
-   [If any substream-id in the \"add\" field has been used before in
    this stream, the error code of the error message [MUST]{.bcp14} be
    E_INVALID_FIELD_VALUE, the \"field\" field [SHOULD]{.bcp14} be
    \"add\", and the \"value\" field [SHOULD]{.bcp14} be an array of
    invalid
    substream-ids.[¶](#section-7.6-3.3){.pilcrow}]{#section-7.6-3.3}
-   [If the request has a non-empty \"add\" field and a \"remove\" field
    with an empty list of substream-ids (to replace all active resources
    with a new set, the client [MUST]{.bcp14} explicitly enumerate the
    substream-ids to be removed), the error code of the error message
    [MUST]{.bcp14} be E_INVALID_FIELD_VALUE, the \"field\" field
    [SHOULD]{.bcp14} be \"remove\", and the \"value\" field
    [SHOULD]{.bcp14} be an empty
    array.[¶](#section-7.6-3.4){.pilcrow}]{#section-7.6-3.4}

If the request is valid but the associated update stream has been
closed, then the stream control server [MUST]{.bcp14} return an HTTP
\"404 Not Found\".[¶](#section-7.6-4){.pilcrow}

If the request is valid and the stream control server successfully
processes the request without error, the stream control server should
return either an HTTP \"202 Accepted\" response or an HTTP \"204 No
Content\" response. The difference is that for the latter case, the
stream control server is sure that the update stream server has also
processed the request. Regardless of a 202 or 204 HTTP response, the
final updates of related resources will be notified by the update stream
server using its control update message(s), due to the modular
design.[¶](#section-7.6-5){.pilcrow}
:::
:::
:::
:::

::: {#Examples}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Examples](#name-examples){.section-name .selfRef} {#name-examples}

::: {#IRD.example}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Example: IRD Announcing Update Stream Services](#name-example-ird-announcing-upda){.section-name .selfRef} {#name-example-ird-announcing-upda}

Below is an example IRD announcing three update stream services. The
first, which is named \"update-my-costs\", provides updates for the
network map, the \"routingcost\" and \"hopcount\" cost maps, and a
Filtered Cost Map resource. The second, which is named
\"update-my-prop\", provides updates to the endpoint properties service.
The third, which is named \"update-my-pv\", provides updates to a
nonstandard ALTO service returning a multipart
response.[¶](#section-8.1-1){.pilcrow}

Note that in the \"update-my-costs\" update stream shown in the example
IRD, the update stream server uses JSON patch for network map, and it
uses JSON merge patch to update the other resources. Also, the update
stream will only provide full replacements for
\"my-simple-filtered-cost-map\".[¶](#section-8.1-2){.pilcrow}

Also, note that this IRD defines two Filtered Cost Map resources. They
use the same cost types, but \"my-filtered-cost-map\" accepts cost
constraint tests, while \"my-simple-filtered-cost-map\" does not. To
avoid the issues discussed in [Section
9.3](#UpdateStreamService.FCMConsiderations){.xref}, the update stream
provides updates for the second but not the
first.[¶](#section-8.1-3){.pilcrow}

This IRD also announces a nonstandard ALTO service, which is named
\"my-pv\". This service accepts an extended endpoint cost request as an
input and returns a multipart response, including an endpoint cost
resource and a property map resource. This document does not rely on any
other design details of this new service. In this document, the
\"my-pv\" service is only used to illustrate how the update stream
service provides updates to an ALTO resource returning a multipart
response.[¶](#section-8.1-4){.pilcrow}

::: {#section-8.1-5}
``` {.sourcecode .lang-json}
  "my-network-map": {
    "uri": "https://alto.example.com/networkmap",
    "media-type": "application/alto-networkmap+json",
  },
  "my-routingcost-map": {
    "uri": "https://alto.example.com/costmap/routingcost",
    "media-type": "application/alto-costmap+json",
    "uses": ["my-networkmap"],
    "capabilities": {
      "cost-type-names": ["num-routingcost"]
    }
  },
  "my-hopcount-map": {
    "uri": "https://alto.example.com/costmap/hopcount",
    "media-type": "application/alto-costmap+json",
    "uses": ["my-networkmap"],
    "capabilities": {
      "cost-type-names": ["num-hopcount"]
    }
  },
  "my-filtered-cost-map": {
    "uri": "https://alto.example.com/costmap/filtered/constraints",
    "media-type": "application/alto-costmap+json",
    "accepts": "application/alto-costmapfilter+json",
    "uses": ["my-networkmap"],
    "capabilities": {
      "cost-type-names": ["num-routingcost", "num-hopcount"],
      "cost-constraints": true
    }
  },
  "my-simple-filtered-cost-map": {
    "uri": "https://alto.example.com/costmap/filtered/simple",
    "media-type": "application/alto-costmap+json",
    "accepts": "application/alto-costmapfilter+json",
    "uses": ["my-networkmap"],
    "capabilities": {
      "cost-type-names": ["num-routingcost", "num-hopcount"],
      "cost-constraints": false
    }
  },
  "my-props": {
    "uri": "https://alto.example.com/properties",
    "media-type": "application/alto-endpointprops+json",
    "accepts": "application/alto-endpointpropparams+json",
    "capabilities": {
      "prop-types": ["priv:ietf-bandwidth"]
    }
  },
  "my-pv": {
    "uri": "https://alto.example.com/endpointcost/pv",
    "media-type": "multipart/related;
                   type=application/alto-endpointcost+json",
    "accepts": "application/alto-endpointcostparams+json",
    "capabilities": {
      "cost-type-names": [ "path-vector" ],
      "ane-properties": [ "maxresbw", "persistent-entities" ]
    }
  },
  "update-my-costs": {
    "uri": "https://alto.example.com/updates/costs",
    "media-type": "text/event-stream",
    "accepts": "application/alto-updatestreamparams+json",
    "uses": [
       "my-network-map",
       "my-routingcost-map",
       "my-hopcount-map",
       "my-simple-filtered-cost-map"
    ],
    "capabilities": {
      "incremental-change-media-types": {
        "my-network-map": "application/json-patch+json",
        "my-routingcost-map": "application/merge-patch+json",
        "my-hopcount-map": "application/merge-patch+json"
      },
      "support-stream-control": true
    }
  },
  "update-my-props": {
    "uri": "https://alto.example.com/updates/properties",
    "media-type": "text/event-stream",
    "uses": [ "my-props" ],
    "accepts": "application/alto-updatestreamparams+json",
    "capabilities": {
      "incremental-change-media-types": {
        "my-props": "application/merge-patch+json"
      },
      "support-stream-control": true
    }
  },
  "update-my-pv": {
    "uri": "https://alto.example.com/updates/pv",
    "media-type": "text/event-stream",
    "uses": [ "my-pv" ],
    "accepts": "application/alto-updatestreamparams+json",
    "capabilities": {
      "incremental-change-media-types": {
        "my-pv": "application/merge-patch+json"
      },
      "support-stream-control": true
    }
  }
```

[¶](#section-8.1-5){.pilcrow}
:::
:::
:::

::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Example: Simple Network and Cost Map Updates](#name-example-simple-network-and-){.section-name .selfRef} {#name-example-simple-network-and-}

Given the update streams announced in the preceding example IRD, the
section below shows an example of an ALTO client\'s request and the
update stream server\'s immediate response, using the update stream
resource \"update-my-costs\". In the example, the ALTO client requests
updates for the network map and \"routingcost\" cost map but not for the
\"hopcount\" cost map. The ALTO client uses the ALTO server\'s
resource-ids as the substream-ids. Because the client does not provide a
\"tag\" for the network map, the update stream server must send a full
replacement for the network map as well as for the cost map. The ALTO
client does not set \"incremental-changes\" to \"false\", so it defaults
to \"true\". Thus, the update stream server will send patch updates for
the cost map and the network map.[¶](#section-8.2-1){.pilcrow}

::: {#section-8.2-2}
``` sourcecode
  POST /updates/costs HTTP/1.1
  Host: alto.example.com
  Accept: text/event-stream,application/alto-error+json
  Content-Type: application/alto-updatestreamparams+json
  Content-Length: 155

  { "add": {
      "my-network-map": {
        "resource-id": "my-network-map"
        },
      "my-routingcost-map": {
        "resource-id": "my-routingcost-map"
      }
    }
  }
```

[¶](#section-8.2-2){.pilcrow}
:::

::: {#section-8.2-3}
``` sourcecode
  HTTP/1.1 200 OK
  Connection: keep-alive
  Content-Type: text/event-stream

  event: application/alto-updatestreamcontrol+json
  data: {"control-uri":
  data: "https://alto.example.com/updates/streams/3141592653589"}

  event: application/alto-networkmap+json,my-network-map
  data: {
  data:   "meta" : {
  data:     "vtag": {
  data:       "resource-id" : "my-network-map",
  data:         "tag" : "da65eca2eb7a10ce8b059740b0b2e3f8eb1d4785"
  data:       }
  data:     },
  data:     "network-map" : {
  data:       "PID1" : {
  data:         "ipv4" : [ "192.0.2.0/24", "198.51.100.0/25" ]
  data:       },
  data:       "PID2" : {
  data:         "ipv4" : [ "198.51.100.128/25" ]
  data:       },
  data:       "PID3" : {
  data:         "ipv4" : [ "0.0.0.0/0" ],
  data:         "ipv6" : [ "::/0" ]
  data:       }
  data:     }
  data:   }
  data: }

  event: application/alto-costmap+json,my-routingcost-map
  data: {
  data:   "meta" : {
  data:     "dependent-vtags" : [{
  data:       "resource-id": "my-network-map",
  data:       "tag": "da65eca2eb7a10ce8b059740b0b2e3f8eb1d4785"
  data:     }],
  data:     "cost-type" : {
  data:       "cost-mode"  : "numerical",
  data:       "cost-metric": "routingcost"
  data:     },
  data:     "vtag": {
  data:       "resource-id" : "my-routingcost-map",
  data:       "tag" : "3ee2cb7e8d63d9fab71b9b34cbf764436315542e"
  data:     }
  data:   },
  data:   "cost-map" : {
  data:     "PID1": { "PID1": 1,  "PID2": 5,  "PID3": 10 },
  data:     "PID2": { "PID1": 5,  "PID2": 1,  "PID3": 15 },
  data:     "PID3": { "PID1": 20, "PID2": 15  }
  data:   }
  data: }
```

[¶](#section-8.2-3){.pilcrow}
:::

After sending those events immediately, the update stream server will
send additional events as the maps change. For example, the following
represents a small change to the cost map. PID1-\>PID2 is changed to 9
from 5, PID3-\>PID1 is no longer available, and PID3-\>PID3 is now
defined as 1:[¶](#section-8.2-4){.pilcrow}

::: {#section-8.2-5}
``` sourcecode
  event: application/merge-patch+json,my-routingcost-map
  data: {
  data:   "meta" : {
  data:     "vtag": {
  data:       "tag": "c0ce023b8678a7b9ec00324673b98e54656d1f6d"
  data:     }
  data:   },
  data:   "cost-map": {
  data:     "PID1" : { "PID2" : 9 },
  data:     "PID3" : { "PID1" : null, "PID3" : 1 }
  data:   }
  data: }
```

[¶](#section-8.2-5){.pilcrow}
:::

As another example, the following represents a change to the network
map: an ipv4 prefix \"203.0.113.0/25\" is added to PID1. It triggers
changes to the cost map. The update stream server chooses to send an
incremental change for the network map and send a full replacement
instead of an incremental change for the cost
map:[¶](#section-8.2-6){.pilcrow}

::: {#section-8.2-7}
``` sourcecode
      event: application/json-patch+json,my-network-map
      data: {
      data:   {
      data:     "op": "replace",
      data:     "path": "/meta/vtag/tag",
      data:     "value" :"a10ce8b059740b0b2e3f8eb1d4785acd42231bfe"
      data:   },
      data:   {
      data:     "op": "add",
      data:     "path": "/network-map/PID1/ipv4/2",
      data:     "value": "203.0.113.0/25"
      data:   }
      data: }

      event: application/alto-costmap+json,my-routingcost-map
      data: {
      data:   "meta" : {
      data:     "vtag": {
      data:       "tag": "c0ce023b8678a7b9ec00324673b98e54656d1f6d"
      data:     }
      data:   },
      data:   "cost-map" : {
      data:     "PID1": { "PID1": 1,  "PID2": 3,  "PID3": 7 },
      data:     "PID2": { "PID1": 12, "PID2": 1,  "PID3": 9 },
      data:     "PID3": { "PID1": 14, "PID2": 8  }
      data:   }
      data: }
```

[¶](#section-8.2-7){.pilcrow}
:::
:::

::: {#section-8.3 .section}
### [8.3.](#section-8.3){.section-number .selfRef} [Example: Advanced Network and Cost Map Updates](#name-example-advanced-network-an){.section-name .selfRef} {#name-example-advanced-network-an}

This example is similar to the previous one, except that the ALTO client
requests updates for the \"hopcount\" cost map as well as the
\"routingcost\" cost map and provides the current version tag of the
network map, so the update stream server is not required to send the
full network map data update message at the beginning of the stream. In
this example, the client uses the substream-ids \"net\", \"routing\",
and \"hops\" for those resources. The update stream server sends the
stream control URI and the full cost maps, followed by updates for the
network map and cost maps as they become
available:[¶](#section-8.3-1){.pilcrow}

::: {#section-8.3-2}
``` sourcecode
  POST /updates/costs HTTP/1.1
  Host: alto.example.com
  Accept: text/event-stream,application/alto-error+json
  Content-Type: application/alto-updatestreamparams+json
  Content-Length: 244

  { "add": {
      "net": {
        "resource-id": "my-network-map",
        "tag": "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe"
      },
      "routing": {
        "resource-id": "my-routingcost-map"
      },
      "hops": {
        "resource-id": "my-hopcount-map"
      }
    }
  }
```

[¶](#section-8.3-2){.pilcrow}
:::

::: {#section-8.3-3}
``` sourcecode
  HTTP/1.1 200 OK
  Connection: keep-alive
  Content-Type: text/event-stream

  event: application/alto-updatestreamcontrol+json
  data: {"control-uri":
  data: "https://alto.example.com/updates/streams/2718281828459"}

  event: application/alto-costmap+json,routing
  data: { ... full routingcost cost map message ... }

  event: application/alto-costmap+json,hops
  data: { ... full hopcount cost map message ... }

     (pause)

  event: application/merge-patch+json,routing
  data: {"cost-map": {"PID2" : {"PID3" : 31}}}

  event: application/merge-patch+json,hops
  data: {"cost-map": {"PID2" : {"PID3" : 4}}}
```

[¶](#section-8.3-3){.pilcrow}
:::

If the ALTO client wishes to stop receiving updates for the \"hopcount\"
cost map, the ALTO client can send a \"remove\" request on the stream
control URI:[¶](#section-8.3-4){.pilcrow}

::: {#section-8.3-5}
``` sourcecode
  POST /updates/streams/2718281828459 HTTP/1.1
  Host: alto.example.com
  Accept: text/plain,application/alto-error+json
  Content-Type: application/alto-updatestreamparams+json
  Content-Length: 24

  {
    "remove": [ "hops" ]
  }


  HTTP/1.1 204 No Content
  Content-Length: 0

      (stream closed without sending data content)
```

[¶](#section-8.3-5){.pilcrow}
:::

The update stream server sends a \"stopped\" control update message on
the original request stream to inform the ALTO client that updates are
stopped for that resource:[¶](#section-8.3-6){.pilcrow}

::: {#section-8.3-7}
``` sourcecode
  event: application/alto-updatestreamcontrol+json
  data: {
  data:   "stopped": ["hops"]
  data: }
```

[¶](#section-8.3-7){.pilcrow}
:::

Below is an example of an invalid stream control request. The \"remove\"
field of the request includes an undefined substream-id, and the stream
control server will return an error response to the ALTO
client.[¶](#section-8.3-8){.pilcrow}

::: {#section-8.3-9}
``` sourcecode
      POST /updates/streams/2718281828459 HTTP/1.1
      Host: alto.example.com
      Accept: text/plain,application/alto-error+json
      Content-Type: application/alto-updatestreamparams+json
      Content-Length: 31
      {
        "remove": [ "properties" ]
      }

      HTTP/1.1 400 Bad Request
      Content-Length: 89
      Content-Type: application/alto-error+json

      {
        "meta":{
        "code": "E_INVALID_FIELD_VALUE",
        "field": "remove",
        "value": "properties"
      }
```

[¶](#section-8.3-9){.pilcrow}
:::

If the ALTO client no longer needs any updates and wishes to shut the
update stream down gracefully, the client can send a \"remove\" request
with an empty array:[¶](#section-8.3-10){.pilcrow}

::: {#section-8.3-11}
``` sourcecode
  POST /updates/streams/2718281828459 HTTP/1.1
  Host: alto.example.com
  Accept: text/plain,application/alto-error+json
  Content-Type: application/alto-updatestreamparams+json
  Content-Length: 17

  {
    "remove": [ ]
  }


  HTTP/1.1 204 No Content
  Content-Length: 0

      (stream closed without sending data content)
```

[¶](#section-8.3-11){.pilcrow}
:::

The update stream server sends a final control update message on the
original request stream to inform the ALTO client that all updates are
stopped and then closes the stream:[¶](#section-8.3-12){.pilcrow}

::: {#section-8.3-13}
``` sourcecode
  event: application/alto-updatestreamcontrol+json
  data: {
  data:   "stopped": ["net", "routing"]
  data: }

      (server closes stream)
```

[¶](#section-8.3-13){.pilcrow}
:::
:::

::: {#section-8.4 .section}
### [8.4.](#section-8.4){.section-number .selfRef} [Example: Endpoint Property Updates](#name-example-endpoint-property-u){.section-name .selfRef} {#name-example-endpoint-property-u}

As another example, here is how an ALTO client can request updates for
the property \"priv:ietf-bandwidth\" for one set of endpoints and
\"priv:ietf-load\" for another. The update stream server immediately
sends full replacements with the property values for all endpoints.
After that, the update stream server sends data update messages for the
individual endpoints as their property values
change.[¶](#section-8.4-1){.pilcrow}

::: {#section-8.4-2}
``` sourcecode
  POST /updates/properties HTTP/1.1
  Host: alto.example.com
  Accept: text/event-stream
  Content-Type: application/alto-updatestreamparams+json
  Content-Length: 511

  { "add": {
      "props-1": {
        "resource-id": "my-props",
        "input": {
          "properties" : [ "priv:ietf-bandwidth" ],
          "endpoints" : [
            "ipv4:198.51.100.1",
            "ipv4:198.51.100.2",
            "ipv4:198.51.100.3"
          ]
        }
      },
      "props-2": {
        "resource-id": "my-props",
        "input": {
          "properties" : [ "priv:ietf-load" ],
          "endpoints" : [
            "ipv6:2001:db8:100::1",
            "ipv6:2001:db8:100::2",
            "ipv6:2001:db8:100::3"
          ]
        }
      }
    }
  }
```

[¶](#section-8.4-2){.pilcrow}
:::

::: {#section-8.4-3}
``` sourcecode
  HTTP/1.1 200 OK
  Connection: keep-alive
  Content-Type: text/event-stream

  event: application/alto-updatestreamcontrol+json
  data: {"control-uri":
  data: "https://alto.example.com/updates/streams/1414213562373"}

  event: application/alto-endpointprops+json,props-1
  data: { "endpoint-properties": {
  data:     "ipv4:198.51.100.1" : { "priv:ietf-bandwidth": "13" },
  data:     "ipv4:198.51.100.2" : { "priv:ietf-bandwidth": "42" },
  data:     "ipv4:198.51.100.3" : { "priv:ietf-bandwidth": "27" }
  data:  } }

  event: application/alto-endpointprops+json,props-2
  data: { "endpoint-properties": {
  data:     "ipv6:2001:db8:100::1" : { "priv:ietf-load": "8" },
  data:     "ipv6:2001:db8:100::2" : { "priv:ietf-load": "2" },
  data:     "ipv6:2001:db8:100::3" : { "priv:ietf-load": "9" }
  data:  } }

     (pause)

  event: application/merge-patch+json,props-1
  data: { "endpoint-properties":
  data:   {"ipv4:198.51.100.1" : {"priv:ietf-bandwidth": "3"}}
  data: }

     (pause)

  event: application/merge-patch+json,props-2
  data: { "endpoint-properties":
  data:   {"ipv6:2001:db8:100::3" : {"priv:ietf-load": "7"}}
  data: }
```

[¶](#section-8.4-3){.pilcrow}
:::

If the ALTO client needs the \"priv:ietf-bandwidth\" property and the
\"priv:ietf-load\" property for additional endpoints, the ALTO client
can send an \"add\" request on the stream control
URI:[¶](#section-8.4-4){.pilcrow}

::: {#section-8.4-5}
``` sourcecode
  POST /updates/streams/1414213562373" HTTP/1.1
  Host: alto.example.com
  Accept: text/plain,application/alto-error+json
  Content-Type: application/alto-updatestreamparams+json
  Content-Length: 448

  { "add": {
      "props-3": {
        "resource-id": "my-props",
        "input": {
          "properties" : [ "priv:ietf-bandwidth" ],
          "endpoints" : [
            "ipv4:198.51.100.4",
            "ipv4:198.51.100.5"
          ]
        }
      },
      "props-4": {
        "resource-id": "my-props",
        "input": {
          "properties" : [ "priv:ietf-load" ],
          "endpoints" : [
            "ipv6:2001:db8:100::4",
            "ipv6:2001:db8:100::5"
          ]
        }
      }
    }
  }


  HTTP/1.1 204 No Content
  Content-Length: 0

      (stream closed without sending data content)
```

[¶](#section-8.4-5){.pilcrow}
:::

The update stream server sends full replacements for the two new
resources, followed by incremental changes for all four requests as they
arrive:[¶](#section-8.4-6){.pilcrow}

::: {#section-8.4-7}
``` sourcecode
  event: application/alto-endpointprops+json,props-3
  data: { "endpoint-properties": {
  data:     "ipv4:198.51.100.4" : { "priv:ietf-bandwidth": "25" },
  data:     "ipv4:198.51.100.5" : { "priv:ietf-bandwidth": "31" },
  data:  } }

  event: application/alto-endpointprops+json,props-4
  data: { "endpoint-properties": {
  data:     "ipv6:2001:db8:100::4" : { "priv:ietf-load": "6" },
  data:     "ipv6:2001:db8:100::5" : { "priv:ietf-load": "4" },
  data:  } }

     (pause)

  event: application/merge-patch+json,props-3
  data: { "endpoint-properties":
  data:   {"ipv4:198.51.100.5" : {"priv:ietf-bandwidth": "15"}}
  data: }

     (pause)

  event: application/merge-patch+json,props-2
  data: { "endpoint-properties":
  data:   {"ipv6:2001:db8:100::2" : {"priv:ietf-load": "9"}}
  data: }

     (pause)

  event: application/merge-patch+json,props-4
  data: { "endpoint-properties":
  data:   {"ipv6:2001:db8:100::4" : {"priv:ietf-load": "3"}}
  data: }
```

[¶](#section-8.4-7){.pilcrow}
:::
:::

::: {#Multipart.Example}
::: {#section-8.5 .section}
### [8.5.](#section-8.5){.section-number .selfRef} [Example: Multipart Message Updates](#name-example-multipart-message-u){.section-name .selfRef} {#name-example-multipart-message-u}

This example shows how an ALTO client can request a nonstandard ALTO
service returning a multipart response. The update stream server
immediately sends full replacements of the multipart response. After
that, the update stream server sends data update messages for the
individual parts of the response as the ALTO data (object) in each part
changes.[¶](#section-8.5-1){.pilcrow}

::: {#section-8.5-2}
``` sourcecode
   POST /updates/pv HTTP/1.1
   Host: alto.example.com
   Accept: text/event-stream
   Content-Type: application/alto-updatestreamparams+json
   Content-Length: 382

   {
     "add": {
       "ecspvsub1": {
         "resource-id": "my-pv",
         "input": {
           "cost-type": {
             "cost-mode": "array",
             "cost-metric": "ane-path"
           },
           "endpoints": {
             "srcs": [ "ipv4:192.0.2.2" ],
             "dsts": [ "ipv4:192.0.2.89", "ipv4:203.0.113.45" ]
           },
           "ane-properties": [ "maxresbw", "persistent-entities" ]
         }
       }
     }
   }
```

[¶](#section-8.5-2){.pilcrow}
:::

::: {#section-8.5-3}
``` sourcecode
   HTTP/1.1 200 OK
   Connection: keep-alive
   Content-Type: text/event-stream

   event: application/alto-updatestreamcontrol+json
   data: {"control-uri":
   data:    "https://alto.example.com/updates/streams/1414"}

   event: multipart/related;boundary=example-pv;
          type=application/alto-endpointcost+json,ecspvsub1
   data: --example-pv
   data: Content-ID: ecsmap
   data: Content-Type: application/alto-endpointcost+json
   data:
   data: { ... data (object) of an endpoint cost map ... }
   data: --example-pv
   data: Content-ID: propmap
   data: Content-Type: application/alto-propmap+json
   data:
   data: { ... data (object) of a property map ... }
   data: --example-pv--

      (pause)

   event: application/merge-patch+json,ecspvsub1.ecsmap
   data: { ... merge patch for updates of ecspvsub1.ecsmap ... }

   event: application/merge-patch+json,ecspvsub1.propmap
   data: { ... merge patch for updates of ecspvsub1.propmap ... }
```

[¶](#section-8.5-3){.pilcrow}
:::
:::
:::
:::
:::

::: {#OperationProcessingConsiderations}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Operation and Processing Considerations](#name-operation-and-processing-co){.section-name .selfRef} {#name-operation-and-processing-co}

::: {#IncrUpdChoice}
::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Considerations for Choosing Data Update Messages](#name-considerations-for-choosing){.section-name .selfRef} {#name-considerations-for-choosing}

The update stream server should be cognizant of the effects of its
update schedule, which includes both the choice of timing (i.e.,
when/what to trigger an update) and the choice of message format (i.e.,
given an update, send a full replacement or an incremental change). In
particular, the update schedule can have effects on both the overhead
and the freshness of information. To minimize overhead, the server may
choose to batch a sequence of updates for resources that frequently
change by sending cumulative updates or a full replacement after a
while. The update stream server should be cognizant that batching
reduces the freshness of information. The server should also consider
the effect of such delays on client behaviors (see below on client
timeout on waiting for updates of dependent
resources).[¶](#section-9.1-1){.pilcrow}

For incremental updates, this design allows both JSON patch and JSON
merge patch for incremental changes. JSON merge patch is clearly
superior to JSON patch for describing incremental changes to cost maps,
endpoint costs, and endpoint properties. For these data structures, JSON
merge patch is more space efficient, as well as simpler to apply. There
is no advantage allowing a server to use JSON patch for those
resources.[¶](#section-9.1-2){.pilcrow}

The case is not as clear for incremental changes to network
maps.[¶](#section-9.1-3){.pilcrow}

First, consider small changes, such as moving a prefix from one PID to
another. JSON patch could encode that as a simple insertion and
deletion, while JSON merge patch would have to replace the entire array
of prefixes for both PIDs. On the other hand, to process a JSON patch
update, the ALTO client would have to retain the indexes of the prefixes
for each PID. Logically, the prefixes in a PID are an unordered set, not
an array; aside from handling updates, a client has no need to retain
the array indexes of the prefixes. Hence, to take advantage of JSON
patch for network maps, ALTO clients would have to retain additional,
otherwise unnecessary, data.[¶](#section-9.1-4){.pilcrow}

Second, consider more involved changes, such as removing half of the
prefixes from a PID. JSON merge patch would send a new array for that
PID, while JSON patch would have to send a list of remove operations and
delete the prefix one by one.[¶](#section-9.1-5){.pilcrow}

Therefore, each update stream server may decide on its own whether to
use JSON merge patch or JSON patch according to the changes in network
maps.[¶](#section-9.1-6){.pilcrow}
:::
:::

::: {#ClientActions}
::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Considerations for Client Processing Data Update Messages](#name-considerations-for-client-p){.section-name .selfRef} {#name-considerations-for-client-p}

In general, when an ALTO client receives a full replacement for a
resource, the ALTO client should replace the current version with the
new version. When an ALTO client receives an incremental change for a
resource, the ALTO client should apply those patches to the current
version of the resource.[¶](#section-9.2-1){.pilcrow}

However, because resources can depend on other resources (e.g., cost
maps depend on network maps), an ALTO client [MUST NOT]{.bcp14} use a
dependent resource if the resource on which it depends has changed.
There are at least two ways an ALTO client can do that. The following
paragraphs illustrate these techniques by referring to network and cost
map messages, although these techniques apply to any dependent
resources.[¶](#section-9.2-2){.pilcrow}

Note that when a network map changes, the update stream server
[MUST]{.bcp14} send the network map update message before sending the
updates for the dependent cost maps (see [Section
6.7.1](#UpdateStreamService.Response.Sequence){.xref}).[¶](#section-9.2-3){.pilcrow}

One approach is for the ALTO client to save the network map update
message in a buffer and continue to use the previous network map and the
associated cost maps until the ALTO client receives the update messages
for all dependent cost maps. The ALTO client then applies all network
and cost map updates atomically.[¶](#section-9.2-4){.pilcrow}

Alternatively, the ALTO client [MAY]{.bcp14} update the network map
immediately. In this case, the cost maps using the network map become
invalid because they are inconsistent with the current network map;
hence, the ALTO client [MUST]{.bcp14} mark each such dependent cost map
as temporarily invalid and [MUST NOT]{.bcp14} use each such cost map
until the ALTO client receives a cost map update message indicating that
it is based on the new network map version
tag.[¶](#section-9.2-5){.pilcrow}

The update stream server [SHOULD]{.bcp14} send updates for dependent
resources (i.e., the cost maps in the preceding example) in a timely
fashion. However, if the ALTO client does not receive the expected
updates, a simple recovery method is that the ALTO client closes the
update stream connection, discards the dependent resources, and
reestablishes the update stream. The ALTO client [MAY]{.bcp14} retain
the version tag of the last version of any tagged resources and give
those version tags when requesting the new update stream. In this case,
if a version is still current, the update stream server will not resend
that resource.[¶](#section-9.2-6){.pilcrow}

Although not as efficient as possible, this recovery method is simple
and reliable.[¶](#section-9.2-7){.pilcrow}
:::
:::

::: {#UpdateStreamService.FCMConsiderations}
::: {#section-9.3 .section}
### [9.3.](#section-9.3){.section-number .selfRef} [Considerations for Updates to Filtered Cost Maps](#name-considerations-for-updates-){.section-name .selfRef} {#name-considerations-for-updates-}

If an update stream provides updates to a Filtered Cost Map that allows
constraint tests, then an ALTO client [MAY]{.bcp14} request updates to a
Filtered Cost Map request with a constraint test. In this case, when a
cost changes, the update stream server [MUST]{.bcp14} send an update if
the new value satisfies the test. If the new value does not, whether the
update stream server sends an update depends on whether the previous
value satisfied the test. If it did not, the update stream server
[SHOULD NOT]{.bcp14} send an update to the ALTO client. But if the
previous value did, then the update stream server [MUST]{.bcp14} send an
update with a \"null\" value to inform the ALTO client that this cost no
longer satisfies the criteria.[¶](#section-9.3-1){.pilcrow}

An update stream server can avoid having to handle such a complicated
behavior by offering update streams only for Filtered Cost Maps that do
not allow constraint tests.[¶](#section-9.3-2){.pilcrow}
:::
:::

::: {#UpdateStreamService.OrdinalConsiderations}
::: {#section-9.4 .section}
### [9.4.](#section-9.4){.section-number .selfRef} [Considerations for Updates to Ordinal Mode Costs](#name-considerations-for-updates-t){.section-name .selfRef} {#name-considerations-for-updates-t}

For an ordinal mode cost map, a change to a single cost point may
require updating many other costs. As an extreme example, suppose the
lowest cost changes to the highest cost. For a numerical mode cost map,
only that one cost changes. But for an ordinal mode cost map, every cost
might change. While this document allows an update stream server to
offer incremental updates for ordinal mode cost maps, update stream
server implementors should be aware that incremental updates for ordinal
costs are more complicated than for numerical costs, and ALTO clients
should be aware that small changes may result in large
updates.[¶](#section-9.4-1){.pilcrow}

An update stream server can avoid this complication by only offering
full replacements for ordinal cost maps.[¶](#section-9.4-2){.pilcrow}
:::
:::

::: {#UpdateStreamService.SSELineLengthConsiderations}
::: {#section-9.5 .section}
### [9.5.](#section-9.5){.section-number .selfRef} [Considerations for SSE Text Formatting and Processing](#name-considerations-for-sse-text){.section-name .selfRef} {#name-considerations-for-sse-text}

SSE was designed for events that consist of relatively small amounts of
line-oriented text data, and SSE clients frequently read input one line
at a time. However, an update stream sends a full cost map as a single
events, and a cost map may involve megabytes, if not tens of megabytes,
of text. This has implications that the ALTO client and the update
stream server may consider.[¶](#section-9.5-1){.pilcrow}

First, some SSE client libraries read all data for an event into memory
and then present it to the client as a character array. However, a
client may not have enough memory to hold the entire JSON text for a
large cost map. Hence, an ALTO client [SHOULD]{.bcp14} consider using an
SSE library that presents the event data in manageable chunks, so the
ALTO client can parse the cost map incrementally and store the
underlying data in a more compact format.[¶](#section-9.5-2){.pilcrow}

Second, an SSE client library may use a low-level, generic socket read
library that stores each line of an event data, just in case the
higher-level parser may need the line delimiters as part of the protocol
formatting. A server sending a complete cost map as a single line may
then generate a multi-megabyte data \"line\", and such a long line may
then require complex memory management at the client. It is
[RECOMMENDED]{.bcp14} that an update stream server limit the lengths of
data lines.[¶](#section-9.5-3){.pilcrow}

Third, an SSE server may use a library, which may put line breaks in
places that would have semantic consequences for the ALTO updates; see
[Section 11](#FutureDesignConsiderations){.xref}. The update stream
server implementation [MUST]{.bcp14} ensure that no line breaks are
introduced to change the semantics.[¶](#section-9.5-4){.pilcrow}
:::
:::
:::
:::

::: {#Security}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

The security considerations ([Section
15](https://www.rfc-editor.org/rfc/rfc7285#section-15){.relref} of
\[[RFC7285](#RFC7285){.xref}\]) of the base protocol fully apply to this
extension. For example, the same authenticity and integrity
considerations ([Section
15.1](https://www.rfc-editor.org/rfc/rfc7285#section-15.1){.relref} of
\[[RFC7285](#RFC7285){.xref}\]) still fully apply; the same
considerations for the privacy of ALTO users ([Section
15.4](https://www.rfc-editor.org/rfc/rfc7285#section-15.4){.relref} of
\[[RFC7285](#RFC7285){.xref}\]) also still fully
apply.[¶](#section-10-1){.pilcrow}

The additional services (addition of update streams and stream control
URIs) provided by this extension extend the attack surface described in
[Section
15.1.1](https://www.rfc-editor.org/rfc/rfc7285#section-15.1.1){.relref}
of \[[RFC7285](#RFC7285){.xref}\]. Below, we discuss the additional
risks and their remedies.[¶](#section-10-2){.pilcrow}

::: {#section-10.1 .section}
### [10.1.](#section-10.1){.section-number .selfRef} [Update Stream Server: Denial-of-Service Attacks](#name-update-stream-server-denial){.section-name .selfRef} {#name-update-stream-server-denial}

Allowing persistent update stream connections enables a new class of
Denial-of-Service attacks.[¶](#section-10.1-1){.pilcrow}

For the update stream server, an ALTO client might create an
unreasonable number of update stream connections or add an unreasonable
number of substream-ids to one update
stream.[¶](#section-10.1-2){.pilcrow}

To avoid these attacks on the update stream server, the server
[SHOULD]{.bcp14} choose to limit the number of active streams and reject
new requests when that threshold is reached. An update stream server
[SHOULD]{.bcp14} also choose to limit the number of active substream-ids
on any given stream or limit the total number of substream-ids used over
the lifetime of a stream and reject any stream control request that
would exceed those limits. In these cases, the update stream server
[SHOULD]{.bcp14} return the HTTP status \"503 Service
Unavailable\".[¶](#section-10.1-3){.pilcrow}

It is important to note that the preceding approaches are not the only
possibilities. For example, it may be possible for the update stream
server to use somewhat more clever logic involving IP reputation,
rate-limiting, and compartmentalization of the overall threshold into
smaller thresholds that apply to subsets of potential
clients.[¶](#section-10.1-4){.pilcrow}

While the preceding techniques prevent update stream DoS attacks from
disrupting an update stream server\'s other services, it does make it
easier for a DoS attack to disrupt the update stream service. Therefore,
an update stream server [MAY]{.bcp14} prefer to restrict update stream
services to authorized clients, as discussed in [Section
15](https://www.rfc-editor.org/rfc/rfc7285#section-15){.relref} of
\[[RFC7285](#RFC7285){.xref}\].[¶](#section-10.1-5){.pilcrow}

Alternatively, an update stream server [MAY]{.bcp14} return the HTTP
status \"307 Temporary Redirect\" to redirect the client to another ALTO
server that can better handle a large number of update
streams.[¶](#section-10.1-6){.pilcrow}
:::

::: {#section-10.2 .section}
### [10.2.](#section-10.2){.section-number .selfRef} [ALTO Client: Update Overloading or Instability](#name-alto-client-update-overload){.section-name .selfRef} {#name-alto-client-update-overload}

The availability of continuous updates can also cause overload for an
ALTO client, in particular, an ALTO client with limited processing
capabilities. The current design does not include any flow control
mechanisms for the client to reduce the update rates from the server.
Under overloading, the client [MAY]{.bcp14} choose to remove the
information resources with high update
rates.[¶](#section-10.2-1){.pilcrow}

Also, under overloading, the client may no longer be able to detect
whether information is still fresh or has become stale. In such a case,
the client should be careful in how it uses the information to avoid
stability or efficiency issues.[¶](#section-10.2-2){.pilcrow}
:::

::: {#section-10.3 .section}
### [10.3.](#section-10.3){.section-number .selfRef} [Stream Control: Spoofed Control Requests and Information Breakdown](#name-stream-control-spoofed-cont){.section-name .selfRef} {#name-stream-control-spoofed-cont}

An outside party that can read the update stream response or that can
observe stream control requests can obtain the control URI and use that
to send a fraudulent \"remove\" requests, thus disabling updates for the
valid ALTO client. This can be avoided by encrypting the update stream
and stream control requests (see [Section
15](https://www.rfc-editor.org/rfc/rfc7285#section-15){.relref} of
\[[RFC7285](#RFC7285){.xref}\]). Also, the update stream server echoes
the \"remove\" requests on the update stream, so the valid ALTO client
can detect unauthorized requests.[¶](#section-10.3-1){.pilcrow}

In general, as the architecture allows the possibility for the update
stream server and the stream control server to be different entities,
the additional risks should be evaluated and remedied. For example, the
private communication path between the servers may be attacked,
resulting in a risk of communications breakdown between them, as well as
invalid or spoofed messages claiming to be on that private
communications path. Proper security mechanisms, including
confidentiality, authenticity, and integrity mechanisms, should be
considered.[¶](#section-10.3-2){.pilcrow}
:::
:::
:::

::: {#FutureDesignConsiderations}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [Requirements on Future ALTO Services to Use This Design](#name-requirements-on-future-alto){.section-name .selfRef} {#name-requirements-on-future-alto}

Although this design is quite flexible, it has underlying
requirements.[¶](#section-11-1){.pilcrow}

The key requirements are that (1) each data update message is for a
single resource and (2) an incremental change can be applied only to a
resource that is a single JSON object, as both JSON merge patch and JSON
patch can apply only to a single JSON object. Hence, if a future ALTO
resource can contain multiple objects, then either each individual
object also has a resource-id or an extension to this design is
made.[¶](#section-11-2){.pilcrow}

At the low-level encoding level, new line in SSE has its own semantics.
Hence, this design requires that resource encoding does not include new
lines that can be confused with SSE encoding. In particular, the data
update message [MUST NOT]{.bcp14} include \"event: \" or \"data: \" at a
new line as part of data message.[¶](#section-11-3){.pilcrow}

If an update stream provides updates to a Filtered Cost Map that allows
constraint tests, the requirements for such services are stated in
[Section
9.3](#UpdateStreamService.FCMConsiderations){.xref}.[¶](#section-11-4){.pilcrow}
:::
:::

::: {#IANA}
::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document defines two new media types:
\"application/alto-updatestreamparams+json\", as described in [Section
6.5](#UpdateInput.media-type){.xref}, and
\"application/alto-updatestreamcontrol+json\", as described in [Section
5.3](#ALTO.SSE.ControlEvents){.xref}. All other media types used in this
document have already been registered, either for ALTO, JSON merge
patch, or JSON patch.[¶](#section-12-1){.pilcrow}

::: {#IANA.UpsateStreamParams}
::: {#section-12.1 .section}
### [12.1.](#section-12.1){.section-number .selfRef} [application/alto-updatestreamparams+json Media Type](#name-application-alto-updatestre){.section-name .selfRef} {#name-application-alto-updatestre}

[]{.break}

Type name:
:   application[¶](#section-12.1-1.2){.pilcrow}
:   

Subtype name:
:   alto-updatestreamparams+json[¶](#section-12.1-1.4){.pilcrow}
:   

Required parameters:
:   N/A[¶](#section-12.1-1.6){.pilcrow}
:   

Optional parameters:
:   N/A[¶](#section-12.1-1.8){.pilcrow}
:   

Encoding considerations:
:   Encoding considerations are identical to those specified for the
    \"application/json\" media type. See
    \[[RFC8259](#RFC8259){.xref}\].[¶](#section-12.1-1.10){.pilcrow}
:   

Security considerations:
:   Security considerations relating to the generation and consumption
    of ALTO Protocol messages are discussed in [Section
    10](#Security){.xref} of RFC 8895 and [Section
    15](https://www.rfc-editor.org/rfc/rfc7285#section-15){.relref} of
    \[[RFC7285](#RFC7285){.xref}\].[¶](#section-12.1-1.12){.pilcrow}
:   

Interoperability considerations:
:   RFC 8895 specifies format of conforming messages and the
    interpretation thereof.[¶](#section-12.1-1.14){.pilcrow}
:   

Published specification:
:   [Section 6.5](#UpdateInput.media-type){.xref} of RFC
    8895.[¶](#section-12.1-1.16){.pilcrow}
:   

Applications that use this media type:
:   ALTO servers and ALTO clients either stand alone or are embedded
    within other applications.[¶](#section-12.1-1.18){.pilcrow}
:   

Fragment identifier considerations:
:   N/A[¶](#section-12.1-1.20){.pilcrow}
:   

Additional information:

:   \

    []{.break}

    Deprecated alias names for this type:
    :   N/A[¶](#section-12.1-1.22.2.2){.pilcrow}
    :   

    Magic number(s):
    :   N/A[¶](#section-12.1-1.22.2.4){.pilcrow}
    :   

    File extension(s):
    :   RFC 8895 uses the media type to refer to protocol messages and
        thus does not require a file
        extension.[¶](#section-12.1-1.22.2.6){.pilcrow}
    :   

    Macintosh file type code(s):
    :   N/A[¶](#section-12.1-1.22.2.8){.pilcrow}
    :   

:   

Person & email address to contact for further information:
:   See Authors\' Addresses section.[¶](#section-12.1-1.24){.pilcrow}
:   

Intended usage:
:   COMMON[¶](#section-12.1-1.26){.pilcrow}
:   

Restrictions on usage:
:   N/A[¶](#section-12.1-1.28){.pilcrow}
:   

Author:
:   See Authors\' Addresses section.[¶](#section-12.1-1.30){.pilcrow}
:   

Change controller:
:   Internet Engineering Task Force
    (mailto:iesg\@ietf.org).[¶](#section-12.1-1.32){.pilcrow}
:   
:::
:::

::: {#IANA.UpsateStreamControl}
::: {#section-12.2 .section}
### [12.2.](#section-12.2){.section-number .selfRef} [application/alto-updatestreamcontrol+json Media Type](#name-application-alto-updatestrea){.section-name .selfRef} {#name-application-alto-updatestrea}

[]{.break}

Type name:
:   application[¶](#section-12.2-1.2){.pilcrow}
:   

Subtype name:
:   alto-updatestreamcontrol+json[¶](#section-12.2-1.4){.pilcrow}
:   

Required parameters:
:   N/A[¶](#section-12.2-1.6){.pilcrow}
:   

Optional parameters:
:   N/A[¶](#section-12.2-1.8){.pilcrow}
:   

Encoding considerations:
:   Encoding considerations are identical to those specified for the
    \"application/json\" media type. See
    \[[RFC8259](#RFC8259){.xref}\].[¶](#section-12.2-1.10){.pilcrow}
:   

Security considerations:
:   Security considerations relating to the generation and consumption
    of ALTO Protocol messages are discussed in [Section
    10](#Security){.xref} of RFC 8895 and [Section
    15](https://www.rfc-editor.org/rfc/rfc7285#section-15){.relref} of
    \[[RFC7285](#RFC7285){.xref}\].[¶](#section-12.2-1.12){.pilcrow}
:   

Interoperability considerations:
:   RFC 8895 specifies format of conforming messages and the
    interpretation thereof.[¶](#section-12.2-1.14){.pilcrow}
:   

Published specification:
:   [Section 5.3](#ALTO.SSE.ControlEvents){.xref} of RFC
    8895.[¶](#section-12.2-1.16){.pilcrow}
:   

Applications that use this media type:
:   ALTO servers and ALTO clients either stand alone or are embedded
    within other applications.[¶](#section-12.2-1.18){.pilcrow}
:   

Fragment identifier considerations:
:   N/A[¶](#section-12.2-1.20){.pilcrow}
:   

Additional information:

:   \

    []{.break}

    Deprecated alias names for this type:
    :   N/A[¶](#section-12.2-1.22.2.2){.pilcrow}
    :   

    Magic number(s):
    :   N/A[¶](#section-12.2-1.22.2.4){.pilcrow}
    :   

    File extension(s):
    :   RFC 8895 uses the media type to refer to protocol messages and
        thus does not require a file
        extension.[¶](#section-12.2-1.22.2.6){.pilcrow}
    :   

    Macintosh file type code(s):
    :   N/A[¶](#section-12.2-1.22.2.8){.pilcrow}
    :   

:   

Person & email address to contact for further information:
:   See Authors\' Addresses section.[¶](#section-12.2-1.24){.pilcrow}
:   

Intended usage:
:   COMMON[¶](#section-12.2-1.26){.pilcrow}
:   

Restrictions on usage:
:   N/A[¶](#section-12.2-1.28){.pilcrow}
:   

Author:
:   See Authors\' Addresses section.[¶](#section-12.2-1.30){.pilcrow}
:   

Change controller:
:   Internet Engineering Task Force
    (mailto:iesg\@ietf.org).[¶](#section-12.2-1.32){.pilcrow}
:   
:::
:::
:::
:::

::: {#DesignDecisions}
::: {#section-13 .section}
## [13.](#section-13){.section-number .selfRef} [Appendix: Design Decision: Not Allowing Stream Restart](#name-appendix-design-decision-no){.section-name .selfRef} {#name-appendix-design-decision-no}

If an update stream is closed accidentally, when the ALTO client
reconnects, the update stream server must resend the full maps. This is
clearly inefficient. To avoid that inefficiency, the SSE specification
allows an update stream server to assign an id to each event. When an
ALTO client reconnects, the ALTO client can present the id of the last
successfully received event, and the update stream server restarts with
the next event.[¶](#section-13-1){.pilcrow}

However, that mechanism adds additional complexity. The update stream
server must save SSE messages in a buffer in case ALTO clients
reconnect. But that mechanism will never be perfect: If the ALTO client
waits too long to reconnect or if the ALTO client sends an invalid ID,
then the update stream server will have to resend the complete maps
anyway.[¶](#section-13-2){.pilcrow}

Furthermore, this is unlikely to be a problem in practice. ALTO clients
who want continuous updates for large resources, such as full network
and cost maps, are likely to be things like P2P trackers. These ALTO
clients will be well connected to the network; they will rarely drop
connections.[¶](#section-13-3){.pilcrow}

Mobile devices certainly can and do drop connections and will have to
reconnect. But mobile devices will not need continuous updates for
multi-megabyte cost maps. If mobile devices need continuous updates at
all, they will need them for small queries, such as the costs from a
small set of media servers from which the device can stream the
currently playing movie. If the mobile device drops the connection and
reestablishes the update stream, the update stream server will have to
retransmit only a small amount of redundant
data.[¶](#section-13-4){.pilcrow}

In short, using event ids to avoid resending the full map adds a
considerable amount of complexity to avoid a situation that is very
rare. The complexity is not worth the
benefit.[¶](#section-13-5){.pilcrow}

The update stream service does allow the ALTO client to specify the tag
of the last received version of any tagged resource, and if that is
still current, the update stream server need not retransmit the full
resource. Hence, ALTO clients can use this to avoid retransmitting full
network maps. Cost maps are not tagged, so this will not work for them.
Of course, the ALTO protocol could be extended by adding version tags to
cost maps, which would solve the retransmission-on-reconnect problem.
However, adding tags to cost maps might add a new set of
complications.[¶](#section-13-6){.pilcrow}
:::
:::

::: {#section-14 .section}
## [14.](#section-14){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-14.1 .section}
### [14.1.](#section-14.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC2387\]
:   [Levinson, E.]{.refAuthor}, [\"The MIME Multipart/Related
    Content-type\"]{.refTitle}, [RFC 2387]{.seriesInfo}, [DOI
    10.17487/RFC2387]{.seriesInfo}, August 1998,
    \<<https://www.rfc-editor.org/info/rfc2387>\>.
:   

\[RFC3986\]
:   [Berners-Lee, T.]{.refAuthor}[, Fielding, R.]{.refAuthor}[, and L.
    Masinter]{.refAuthor}, [\"Uniform Resource Identifier (URI): Generic
    Syntax\"]{.refTitle}, [STD 66]{.seriesInfo}, [RFC
    3986]{.seriesInfo}, [DOI 10.17487/RFC3986]{.seriesInfo}, January
    2005, \<<https://www.rfc-editor.org/info/rfc3986>\>.
:   

\[RFC6838\]
:   [Freed, N.]{.refAuthor}[, Klensin, J.]{.refAuthor}[, and T.
    Hansen]{.refAuthor}, [\"Media Type Specifications and Registration
    Procedures\"]{.refTitle}, [BCP 13]{.seriesInfo}, [RFC
    6838]{.seriesInfo}, [DOI 10.17487/RFC6838]{.seriesInfo}, January
    2013, \<<https://www.rfc-editor.org/info/rfc6838>\>.
:   

\[RFC6902\]
:   [Bryan, P., Ed.]{.refAuthor}[ and M. Nottingham, Ed.]{.refAuthor},
    [\"JavaScript Object Notation (JSON) Patch\"]{.refTitle}, [RFC
    6902]{.seriesInfo}, [DOI 10.17487/RFC6902]{.seriesInfo}, April 2013,
    \<<https://www.rfc-editor.org/info/rfc6902>\>.
:   

\[RFC7285\]
:   [Alimi, R., Ed.]{.refAuthor}[, Penno, R., Ed.]{.refAuthor}[, Yang,
    Y., Ed.]{.refAuthor}[, Kiesel, S.]{.refAuthor}[,
    Previdi, S.]{.refAuthor}[, Roome, W.]{.refAuthor}[,
    Shalunov, S.]{.refAuthor}[, and R. Woundy]{.refAuthor},
    [\"Application-Layer Traffic Optimization (ALTO)
    Protocol\"]{.refTitle}, [RFC 7285]{.seriesInfo}, [DOI
    10.17487/RFC7285]{.seriesInfo}, September 2014,
    \<<https://www.rfc-editor.org/info/rfc7285>\>.
:   

\[RFC7396\]
:   [Hoffman, P.]{.refAuthor}[ and J. Snell]{.refAuthor}, [\"JSON Merge
    Patch\"]{.refTitle}, [RFC 7396]{.seriesInfo}, [DOI
    10.17487/RFC7396]{.seriesInfo}, October 2014,
    \<<https://www.rfc-editor.org/info/rfc7396>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8259\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The JavaScript Object Notation
    (JSON) Data Interchange Format\"]{.refTitle}, [STD 90]{.seriesInfo},
    [RFC 8259]{.seriesInfo}, [DOI 10.17487/RFC8259]{.seriesInfo},
    December 2017, \<<https://www.rfc-editor.org/info/rfc8259>\>.
:   

\[SSE\]
:   [Hickson, I.]{.refAuthor}, [\"Server-Sent Events\"]{.refTitle}, [W3C
    Recommendation]{.refContent}, February 2015,
    \<<https://www.w3.org/TR/eventsource/>\>.
:   
:::

::: {#section-14.2 .section}
### [14.2.](#section-14.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[RFC4960\]
:   [Stewart, R., Ed.]{.refAuthor}, [\"Stream Control Transmission
    Protocol\"]{.refTitle}, [RFC 4960]{.seriesInfo}, [DOI
    10.17487/RFC4960]{.seriesInfo}, September 2007,
    \<<https://www.rfc-editor.org/info/rfc4960>\>.
:   

\[RFC5789\]
:   [Dusseault, L.]{.refAuthor}[ and J. Snell]{.refAuthor}, [\"PATCH
    Method for HTTP\"]{.refTitle}, [RFC 5789]{.seriesInfo}, [DOI
    10.17487/RFC5789]{.seriesInfo}, March 2010,
    \<<https://www.rfc-editor.org/info/rfc5789>\>.
:   

\[RFC7230\]
:   [Fielding, R., Ed.]{.refAuthor}[ and J. Reschke, Ed.]{.refAuthor},
    [\"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and
    Routing\"]{.refTitle}, [RFC 7230]{.seriesInfo}, [DOI
    10.17487/RFC7230]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7230>\>.
:   

\[RFC7231\]
:   [Fielding, R., Ed.]{.refAuthor}[ and J. Reschke, Ed.]{.refAuthor},
    [\"Hypertext Transfer Protocol (HTTP/1.1): Semantics and
    Content\"]{.refTitle}, [RFC 7231]{.seriesInfo}, [DOI
    10.17487/RFC7231]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7231>\>.
:   

\[RFC7540\]
:   [Belshe, M.]{.refAuthor}[, Peon, R.]{.refAuthor}[, and M. Thomson,
    Ed.]{.refAuthor}, [\"Hypertext Transfer Protocol Version 2
    (HTTP/2)\"]{.refTitle}, [RFC 7540]{.seriesInfo}, [DOI
    10.17487/RFC7540]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7540>\>.
:   
:::
:::

::: {#Acknowledgments}
::: {#section-appendix.a .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

Thank you to [Dawn Chen]{.contact-name} (Tongji University), [Shawn
Lin]{.contact-name} (Tongji University), and [Xiao Shi]{.contact-name}
(Yale University) for their contributions to an earlier version of this
document.[¶](#section-appendix.a-1){.pilcrow}
:::
:::

::: {#Contributors}
::: {#section-appendix.b .section}
## [Contributors](#name-contributors){.section-name .selfRef} {#name-contributors}

Sections [2](#Terms){.xref}, [5.1](#ALTO.SSE.EventFormat){.xref},
[5.2](#ALTO.SSE.UpdateEvents){.xref}, and
[8.5](#Multipart.Example){.xref} of this document are based on
contributions from [Jingxuan Jensen Zhang]{.contact-name}, and he is
considered an author.[¶](#section-appendix.b-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.c .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Wendy Roome]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Nokia Bell Labs (Retired)]{.org}
:::

::: {.left dir="auto"}
[124 Burlington Rd]{.street-address}
:::

::: {.left dir="auto"}
[Murray Hill]{.locality}, [NJ]{.region} [07974]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: tel
Phone: [+1-908-464-6975](tel:+1-908-464-6975){.tel}
:::

::: email
Email: <wendy@wdroome.com>
:::

::: {.left dir="auto"}
[Y. Richard Yang]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Yale University]{.org}
:::

::: {.left dir="auto"}
[51 Prospect St]{.street-address}
:::

::: {.left dir="auto"}
[New Haven]{.locality}, [CT]{.region}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <yry@cs.yale.edu>
:::
:::
:::
