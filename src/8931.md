  RFC 8931   Selective RFRAG   November 2020
  ---------- ----------------- ---------------
  Thubert    Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8931](https://www.rfc-editor.org/rfc/rfc8931){.eref}

Updates:
:   [4944](https://www.rfc-editor.org/rfc/rfc4944){.eref}

Category:
:   Standards Track

Published:
:   November 2020

ISSN:
:   2070-1721

Author:

:   ::: author
    ::: author-name
    P. Thubert, [Ed.]{.editor}
    :::

    ::: org
    Cisco Systems
    :::
    :::
:::

# RFC 8931 {#rfcnum}

# IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Selective Fragment Recovery {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document updates RFC 4944 with a protocol that forwards individual
fragments across a route-over mesh and recovers them end to end, with
congestion control capabilities to protect the
network.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8931>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Requirements
        Language](#name-requirements-language){.xref}[¶](#section-toc.1-1.2.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [Background](#name-background){.xref}[¶](#section-toc.1-1.2.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.3}
        [2.3](#section-2.3){.xref}.  [Other
        Terms](#name-other-terms){.xref}[¶](#section-toc.1-1.2.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Updating RFC
    4944](#name-updating-rfc-4944){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Extending RFC
    8930](#name-extending-rfc-8930){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Slack in the First
        Fragment](#name-slack-in-the-first-fragment){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Gap between
        Frames](#name-gap-between-frames){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Congestion
        Control](#name-congestion-control){.xref}[¶](#section-toc.1-1.4.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Modifying the First
        Fragment](#name-modifying-the-first-fragmen){.xref}[¶](#section-toc.1-1.4.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [New Dispatch Types and
    Headers](#name-new-dispatch-types-and-head){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Recoverable Fragment Dispatch Type
        and
        Header](#name-recoverable-fragment-dispat){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [RFRAG Acknowledgment Dispatch Type
        and
        Header](#name-rfrag-acknowledgment-dispat){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Fragment
    Recovery](#name-fragment-recovery){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Forwarding
        Fragments](#name-forwarding-fragments){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.6.2.1.2.1}
            [6.1.1](#section-6.1.1){.xref}.  [Receiving the First
            Fragment](#name-receiving-the-first-fragmen){.xref}[¶](#section-toc.1-1.6.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.6.2.1.2.2}
            [6.1.2](#section-6.1.2){.xref}.  [Receiving the Next
            Fragments](#name-receiving-the-next-fragment){.xref}[¶](#section-toc.1-1.6.2.1.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Receiving RFRAG
        Acknowledgments](#name-receiving-rfrag-acknowledgm){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Aborting the Transmission of a
        Fragmented
        Packet](#name-aborting-the-transmission-o){.xref}[¶](#section-toc.1-1.6.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [Applying Recoverable Fragmentation
        along a Diverse
        Path](#name-applying-recoverable-fragme){.xref}[¶](#section-toc.1-1.6.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Management
    Considerations](#name-management-considerations){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Protocol
        Parameters](#name-protocol-parameters){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Observing the
        Network](#name-observing-the-network){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}

    -   ::: {#section-toc.1-1.10.2.1}
        [10.1](#section-10.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.10.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [10.2](#section-10.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.10.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [Appendix
    A](#section-appendix.a){.xref}.  [Rationale](#name-rationale){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.12}
    [Appendix
    B](#section-appendix.b){.xref}.  [Requirements](#name-requirements){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.13}
    [Appendix C](#section-appendix.c){.xref}.  [Considerations on
    Congestion
    Control](#name-considerations-on-congestio){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.14}
    [](#section-appendix.d){.xref}[Acknowledgments](#name-acknowledgments){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.15}
    [](#section-appendix.e){.xref}[Author\'s
    Address](#name-authors-address){.xref}[¶](#section-toc.1-1.15.1){.pilcrow}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

In most Low-Power and Lossy Network (LLN) applications, the bulk of the
traffic consists of small chunks of data (on the order of a few bytes to
a few tens of bytes) at a time. Given that an [IEEE Std
802.15.4](#IEEE.802.15.4){.xref}
\[[IEEE.802.15.4](#IEEE.802.15.4){.xref}\] frame can carry a payload of
74 bytes or more, fragmentation is usually not required. However, and
though this happens only occasionally, a number of mission-critical
applications do require the capability to transfer larger chunks of
data, for instance, to support the firmware upgrade of the LLN nodes or
the extraction of logs from LLN nodes.[¶](#section-1-1){.pilcrow}

In the former case, the large chunk of data is transferred to the LLN
node, whereas in the latter case, the large chunk flows away from the
LLN node. In both cases, the size can be on the order of 10 KB or more,
and an end-to-end reliable transport is
required.[¶](#section-1-2){.pilcrow}

[\"Transmission of IPv6 Packets over IEEE 802.15.4
Networks\"](#RFC4944){.xref} \[[RFC4944](#RFC4944){.xref}\] defines the
original IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN)
datagram fragmentation mechanism for LLNs. One critical issue with this
original design is that routing an IPv6 \[[RFC8200](#RFC8200){.xref}\]
packet across a route-over mesh requires the reassembly of the packet at
each hop. [\"An Architecture for IPv6 over the TSCH mode of IEEE
802.15.4\"](#I-D.ietf-6tisch-architecture){.xref}
\[[6TiSCH](#I-D.ietf-6tisch-architecture){.xref}\] indicates that this
may cause latency along a path and impact critical resources such as
memory and battery; to alleviate those undesirable effects, it
recommends using a 6LoWPAN Fragment Forwarding (6LFF)
technique.[¶](#section-1-3){.pilcrow}

[\"On Forwarding 6LoWPAN Fragments over a Multihop IPv6
Network\"](#RFC8930){.xref} \[[RFC8930](#RFC8930){.xref}\] specifies the
generic behavior that all 6LFF techniques including this specification
follow, and it presents the associated caveats. In particular, the
routing information is fully indicated in the first fragment, which is
always forwarded first. With this specification, the first fragment is
identified by a Sequence of 0 as opposed to a dispatch type in
\[[RFC4944](#RFC4944){.xref}\]. A state is formed and used to forward
all the next fragments along the same path. The Datagram_Tag is locally
significant to the Layer 2 source of the packet and is swapped at each
hop; see [Section 6](#ffc){.xref}. This specification encodes the
Datagram_Tag in 1 byte, which will saturate if more than 256 datagrams
transit in fragmented form over a single hop at the same time. This is
not realistic at the time of this writing. Should this happen in a new
6LoWPAN technology, a node will need to use several link-layer addresses
to increase its indexing capacity.[¶](#section-1-4){.pilcrow}

[\"Virtual reassembly buffers in
6LoWPAN\"](#I-D.ietf-lwig-6lowpan-virtual-reassembly){.xref}
\[[LWIG-FRAG](#I-D.ietf-lwig-6lowpan-virtual-reassembly){.xref}\]
proposes a 6LFF technique that is compatible with
\[[RFC4944](#RFC4944){.xref}\] without the need to define a new
protocol. However, adding that capability alone to the local
implementation of the original 6LoWPAN fragmentation would not address
the inherent fragility of fragmentation (see
\[[RFC8900](#RFC8900){.xref}\]), in particular, the issues of resources
locked on the reassembling endpoint and the wasted transmissions due to
the loss of a single fragment in a whole datagram.
\[[Kent](#Kent){.xref}\] compares the unreliable delivery of fragments
with a mechanism it calls \"selective acknowledgments\" that recovers
the loss of a fragment individually. The paper illustrates the benefits
that can be derived from such a method; see Figures 1, 2, and 3 in
Section 2.3 of \[[Kent](#Kent){.xref}\]. \[[RFC4944](#RFC4944){.xref}\]
has no selective recovery, and the whole datagram fails when one
fragment is not delivered to the reassembling endpoint. Constrained
memory resources are blocked on the reassembling endpoint until it times
out, possibly causing the loss of subsequent packets that cannot be
received for the lack of buffers.[¶](#section-1-5){.pilcrow}

That problem is exacerbated when forwarding fragments over multiple hops
since a loss at an intermediate hop will not be discovered by either the
fragmenting or the reassembling endpoints. Should this happen, the
source will keep on sending fragments, wasting even more resources in
the network since the datagram cannot arrive in its entirety, which
possibly contributes to the condition that caused the loss.
\[[RFC4944](#RFC4944){.xref}\] is lacking a congestion control to avoid
participating in a saturation that may have caused the loss of the
fragment. It has no signaling to abort a multi-fragment transmission at
any time and from either end, and if the capability to forward fragments
is implemented, clean up the related state in the
network.[¶](#section-1-6){.pilcrow}

This specification provides a method to forward fragments over,
typically, a few hops in a route-over 6LoWPAN mesh and a selective
acknowledgment to recover individual fragments between 6LoWPAN
endpoints. The method can help limit the congestion loss in the network
and addresses the requirements in [Appendix B](#req){.xref}. Flow
control is out of scope since the endpoints are expected to be able to
store the full datagram. Deployments are expected to be managed and
homogeneous, and an incremental transition requires a flag
day.[¶](#section-1-7){.pilcrow}
:::
:::

::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

::: {#bcp}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Requirements Language](#name-requirements-language){.section-name .selfRef} {#name-requirements-language}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2.1-1){.pilcrow}
:::
:::

::: {#lo}
::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [Background](#name-background){.section-name .selfRef} {#name-background}

This document uses 6LoWPAN terms and concepts that are presented in
[\"IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs):
Overview, Assumptions, Problem Statement, and Goals\"](#RFC4919){.xref}
\[[RFC4919](#RFC4919){.xref}\]; [\"Transmission of IPv6 Packets over
IEEE 802.15.4 Networks\"](#RFC4944){.xref}
\[[RFC4944](#RFC4944){.xref}\]; and [\"Problem Statement and
Requirements for IPv6 over Low-Power Wireless Personal Area Network
(6LoWPAN) Routing\"](#RFC6606){.xref}
\[[RFC6606](#RFC6606){.xref}\].[¶](#section-2.2-1){.pilcrow}

\[[RFC8930](#RFC8930){.xref}\] discusses the generic concept of a
Virtual Reassembly Buffer (VRB) and specifies behaviors and caveats that
are common to a large family of 6LFF techniques including the mechanism
specified by this document, which is fully inherited from that
specification. It also defines terms used in this document: Compressed
Form, Datagram_Tag, Datagram_Size, Fragment_Offset, and 6LoWPAN Fragment
Forwarding endpoint (commonly abbreviated as only
\"endpoint\").[¶](#section-2.2-2){.pilcrow}

Past experience with fragmentation has shown that misassociated or lost
fragments can lead to poor network behavior and, occasionally, trouble
at the application layer. The reader is encouraged to read [\"IPv4
Reassembly Errors at High Data Rates\"](#RFC4963){.xref}
\[[RFC4963](#RFC4963){.xref}\] and follow the references for more
information. That experience led to the definition of the [\"Path MTU
Discovery for IP version 6\"](#RFC8201){.xref}
\[[RFC8201](#RFC8201){.xref}\] protocol that limits fragmentation over
the Internet. Specifically, in the case of UDP, valuable additional
information can be found in [\"UDP Usage Guidelines\"](#RFC8085){.xref}
\[[RFC8085](#RFC8085){.xref}\].[¶](#section-2.2-3){.pilcrow}

[\"The Benefits of Using Explicit Congestion Notification
(ECN)\"](#RFC8087){.xref} \[[RFC8087](#RFC8087){.xref}\] provides useful
information on the potential benefits and pitfalls of using
ECN.[¶](#section-2.2-4){.pilcrow}

Quoting [\"Multiprotocol Label Switching
Architecture\"](#RFC3031){.xref}
\[[RFC3031](#RFC3031){.xref}\]:[¶](#section-2.2-5){.pilcrow}

> With MPLS, \"packets are \"labeled\" before they are forwarded \[along
> a Label Switched Path (LSP)\]. At subsequent hops, there is no further
> analysis of the packet\'s network layer header. Rather, the label is
> used as an index into a table which specifies the next hop, and a new
> label\".[¶](#section-2.2-6){.pilcrow}

\[[RFC8930](#RFC8930){.xref}\] leverages MPLS to forward fragments that
actually do not have a network-layer header, since the fragmentation
occurs below IP, and this specification makes it reversible so the
reverse path can be followed as well.[¶](#section-2.2-7){.pilcrow}
:::
:::

::: {#new}
::: {#section-2.3 .section}
### [2.3.](#section-2.3){.section-number .selfRef} [Other Terms](#name-other-terms){.section-name .selfRef} {#name-other-terms}

This specification uses the following
terms:[¶](#section-2.3-1){.pilcrow}

[]{.break}

RFRAG:
:   Recoverable Fragment[¶](#section-2.3-2.2){.pilcrow}
:   

RFRAG-ACK:
:   Recoverable Fragment Acknowledgment[¶](#section-2.3-2.4){.pilcrow}
:   

RFRAG Acknowledgment Request:
:   An RFRAG with the Acknowledgment Request flag (\"X\" flag)
    set.[¶](#section-2.3-2.6){.pilcrow}
:   

NULL bitmap:
:   Refers to a bitmap with all bits set to
    zero.[¶](#section-2.3-2.8){.pilcrow}
:   

FULL bitmap:
:   Refers to a bitmap with all bits set to
    one.[¶](#section-2.3-2.10){.pilcrow}
:   

Reassembling endpoint:
:   The receiving endpoint.[¶](#section-2.3-2.12){.pilcrow}
:   

Fragmenting endpoint:
:   The sending endpoint.[¶](#section-2.3-2.14){.pilcrow}
:   

Forward direction:
:   The direction of a path, which is followed by the
    RFRAG.[¶](#section-2.3-2.16){.pilcrow}
:   

Reverse direction:
:   The reverse direction of a path, which is taken by the
    RFRAG-ACK.[¶](#section-2.3-2.18){.pilcrow}
:   
:::
:::
:::

::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Updating RFC 4944](#name-updating-rfc-4944){.section-name .selfRef} {#name-updating-rfc-4944}

This specification updates the fragmentation mechanism that is specified
in \[[RFC4944](#RFC4944){.xref}\] for use in route-over LLNs by
providing a model where fragments can be forwarded end to end across a
6LoWPAN LLN and where fragments that are lost on the way can be
recovered individually. A new format for fragments is introduced, and
new dispatch types are defined in [Section
5](#dispatch){.xref}.[¶](#section-3-1){.pilcrow}

\[[RFC8138](#RFC8138){.xref}\] allows modifying the size of a packet en
route by removing the consumed hops in a compressed Routing Header. This
requires that Fragment_Offset and Datagram_Size (defined in [Section
5.1](#RF2){.xref}) also be modified en route, which is difficult to do
in the uncompressed form. This specification expresses those fields in
the compressed form and allows modifying them en route easily (more in
[Section 4.4](#mod){.xref}).[¶](#section-3-2){.pilcrow}

To be consistent with [Section
2](https://www.rfc-editor.org/rfc/rfc6282#section-2){.relref} of
\[[RFC6282](#RFC6282){.xref}\], for the fragmentation mechanism
described in [Section
5.3](https://www.rfc-editor.org/rfc/rfc4944#section-5.3){.relref} of
\[[RFC4944](#RFC4944){.xref}\], any header that cannot fit within the
first fragment [MUST NOT]{.bcp14} be compressed when using the
fragmentation mechanism described in this
specification.[¶](#section-3-3){.pilcrow}
:::

::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Extending RFC 8930](#name-extending-rfc-8930){.section-name .selfRef} {#name-extending-rfc-8930}

This specification implements the generic 6LFF technique defined in
\[[RFC8930](#RFC8930){.xref}\] and provides end-to-end fragment recovery
and congestion control mechanisms.[¶](#section-4-1){.pilcrow}

::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Slack in the First Fragment](#name-slack-in-the-first-fragment){.section-name .selfRef} {#name-slack-in-the-first-fragment}

\[[RFC8930](#RFC8930){.xref}\] allows for a refragmentation operation in
intermediate nodes, whereby the trailing bytes from a given fragment may
be left in the VRB to be added as the heading bytes in the next
fragment. This solves the case when the outgoing fragment needs more
space than the incoming fragment; that case may arise when the 6LoWPAN
header compression is not as efficient on the outgoing link or if the
Link MTU is reduced.[¶](#section-4.1-1){.pilcrow}

This specification cannot allow that refragmentation operation since the
fragments are recovered end to end based on a sequence number. The
Fragment_Size [MUST]{.bcp14} be tailored to fit the minimal MTU along
the path, and the first fragment that contains a 6LoWPAN compressed
header [MUST]{.bcp14} have enough slack to enable a less-efficient
compression in the next hops to still fit within the Link
MTU.[¶](#section-4.1-2){.pilcrow}

For instance, if the fragmenting endpoint is also the 6LoWPAN
compression endpoint, it will elide the Interface ID (IID) of the source
IPv6 address when it matches the link-layer address
\[[RFC6282](#RFC6282){.xref}\]. In that case, it [MUST]{.bcp14} leave
slack in the first fragment as the if MTU on the first hop was 8 bytes
less, so the next hop can expand the IID within the same fragment within
MTU.[¶](#section-4.1-3){.pilcrow}
:::

::: {#gap}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Gap between Frames](#name-gap-between-frames){.section-name .selfRef} {#name-gap-between-frames}

\[[RFC8930](#RFC8930){.xref}\] requires that a configurable interval of
time be inserted between transmissions to the same next hop and, in
particular, between fragments of a same datagram. In the case of half
duplex interfaces, this inter-frame gap ensures that the next hop is
done forwarding the previous frame and is capable of receiving the next
one.[¶](#section-4.2-1){.pilcrow}

In the case of a mesh operating at a single frequency with
omnidirectional antennas, a larger inter-frame gap is required to
protect the frame against hidden terminal collisions with the previous
frame of the same flow that is still progressing along a common
path.[¶](#section-4.2-2){.pilcrow}

The inter-frame gap is useful even for unfragmented datagrams, but it
becomes a necessity for fragments that are typically generated in a fast
sequence and are all sent over the exact same
path.[¶](#section-4.2-3){.pilcrow}
:::
:::

::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Congestion Control](#name-congestion-control){.section-name .selfRef} {#name-congestion-control}

The inter-frame gap is the only protection that
\[[RFC8930](#RFC8930){.xref}\] imposes by default. This document enables
grouping fragments in windows and requesting intermediate
acknowledgments, so the number of in-flight fragments can be bounded.
This document also adds an ECN mechanism that can be used to protect the
network by adapting the size of the window, the size of the fragments,
and/or the inter-frame gap.[¶](#section-4.3-1){.pilcrow}

This specification enables the fragmenting endpoint to apply a
congestion control mechanism to tune those parameters, but the mechanism
itself is out of scope. In most cases, the expectation is that most
datagrams will require only a few fragments, and that only the last
fragment will be acknowledged. A basic implementation of the fragmenting
endpoint is NOT [REQUIRED]{.bcp14} to vary the size of the window, the
duration of the inter-frame gap, or the size of a fragment in the middle
of the transmission of a datagram, and it [MAY]{.bcp14} ignore the ECN
signal or simply reset the window to 1 (see [Appendix C](#onECN){.xref})
until the end of this datagram upon detecting a
congestion.[¶](#section-4.3-2){.pilcrow}

An intermediate node that experiences a congestion [MAY]{.bcp14} set the
ECN bit in a fragment, and the reassembling endpoint echoes the ECN bit
at most once at the next opportunity to acknowledge
back.[¶](#section-4.3-3){.pilcrow}

The size of the fragments is typically computed from the Link MTU to
maximize the size of the resulting frames. The size of the window and
the duration of the inter-frame gap [SHOULD]{.bcp14} be configurable, to
reduce the chances of congestion and to follow the general
recommendations in \[[RFC8930](#RFC8930){.xref}\],
respectively.[¶](#section-4.3-4){.pilcrow}
:::

::: {#mod}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Modifying the First Fragment](#name-modifying-the-first-fragmen){.section-name .selfRef} {#name-modifying-the-first-fragmen}

The compression of the hop limit, of the source and destination
addresses in the IPv6 header, and of the Routing Header, which are all
in the first fragment, may change en route in a route-over mesh LLN. If
the size of the first fragment is modified, then the intermediate node
[MUST]{.bcp14} adapt the Datagram_Size, encoded in the Fragment_Size
field, to reflect that difference.[¶](#section-4.4-1){.pilcrow}

The intermediate node [MUST]{.bcp14} also save the difference of
Datagram_Size of the first fragment in the VRB and add it to the
Fragment_Offset of all the subsequent fragments that it forwards for
that datagram. In the case of a Source Routing Header 6LoWPAN Routing
Header (SRH-6LoRH) \[[RFC8138](#RFC8138){.xref}\] being consumed and
thus reduced, that difference is negative, meaning that the
Fragment_Offset is decremented by the number of bytes that were
consumed.[¶](#section-4.4-2){.pilcrow}
:::
:::
:::

::: {#dispatch}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [New Dispatch Types and Headers](#name-new-dispatch-types-and-head){.section-name .selfRef} {#name-new-dispatch-types-and-head}

This document specifies an alternative to the 6LoWPAN fragmentation
sub-layer \[[RFC4944](#RFC4944){.xref}\] to emulate a Link MTU up to
2048 bytes for the upper layer, which can be the 6LoWPAN header
compression sub-layer that is defined in [\"Compression Format for IPv6
Datagrams over IEEE 802.15.4-Based Networks\"](#RFC6282){.xref}
\[[RFC6282](#RFC6282){.xref}\]. This specification also provides a
reliable transmission of the fragments over a multi-hop 6LoWPAN
route-over mesh network and a minimal congestion control to reduce the
chances of congestion loss.[¶](#section-5-1){.pilcrow}

A 6LoWPAN Fragment Forwarding \[[RFC8930](#RFC8930){.xref}\] technique
derived from MPLS enables the forwarding of individual fragments across
a 6LoWPAN route-over mesh without reassembly at each hop. The
Datagram_Tag is used as a label; it is locally unique to the node that
owns the source link-layer address of the fragment, so together the
link-layer address and the label can identify the fragment globally
within the lifetime of the datagram. A node may build the Datagram_Tag
in its own locally significant way, as long as the chosen Datagram_Tag
stays unique to the particular datagram for its lifetime. The result is
that the label does not need to be globally unique, but it must be
swapped at each hop as the source link-layer address
changes.[¶](#section-5-2){.pilcrow}

In the following sections, a Datagram_Tag extends the semantics defined
in \"Fragmentation Type and Header\" (see [Section
5.3](https://www.rfc-editor.org/rfc/rfc4944#section-5.3){.relref} of
\[[RFC4944](#RFC4944){.xref}\]). The Datagram_Tag is a locally unique
identifier for the datagram from the perspective of the sender. This
means that the Datagram_Tag identifies a datagram uniquely in the
network when associated with the source of the datagram. As the datagram
gets forwarded, the source changes, and the Datagram_Tag must be swapped
as detailed in
\[[RFC8930](#RFC8930){.xref}\].[¶](#section-5-3){.pilcrow}

This specification extends \[[RFC4944](#RFC4944){.xref}\] with two new
dispatch types for RFRAG and the RFRAG-ACK that is received back. The
new 6LoWPAN dispatch types are taken from
\[[RFC8025](#RFC8025){.xref}\], as indicated in [Table 1](#difig){.xref}
of [Section 9](#ianacon){.xref}.[¶](#section-5-4){.pilcrow}

::: {#RF2}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Recoverable Fragment Dispatch Type and Header](#name-recoverable-fragment-dispat){.section-name .selfRef} {#name-recoverable-fragment-dispat}

In this specification, if the packet is compressed, the size and offset
of the fragments are expressed with respect to the compressed form of
the packet, as opposed to the uncompressed (native)
form.[¶](#section-5.1-1){.pilcrow}

The format of the fragment header is shown in [Figure
1](#RFfigalt){.xref}. It is the same for all fragments even though the
Fragment_Offset is overloaded. The format has a length and an offset, as
well as a Sequence field. This would be redundant if the offset was
computed as the product of the Sequence by the length, but this is not
the case. The position of a fragment in the reassembly buffer is
correlated with neither the value of the Sequence field nor the order in
which the fragments are received. This enables splitting fragments to
cope with an MTU deduction; see the example of fragment Sequence 5 that
is retried end to end as smaller fragment Sequences 13 and 14 in
[Section 6.2](#ura){.xref}.[¶](#section-5.1-2){.pilcrow}

The first fragment is recognized by a Sequence of 0; it carries its
Fragment_Size and the Datagram_Size of the compressed packet before it
is fragmented, whereas the other fragments carry their Fragment_Size and
Fragment_Offset. The last fragment for a datagram is recognized when its
Fragment_Offset and its Fragment_Size add up to the stored Datagram_Size
of the packet identified by the sender link-layer address and the
Datagram_Tag.[¶](#section-5.1-3){.pilcrow}

[]{#name-rfrag-dispatch-type-and-hea}

::: {#RFfigalt}
::: {#section-5.1-4.1 .artwork .art-text .alignCenter}
                               1                   2                   3
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                        |1 1 1 0 1 0 0|E|  Datagram_Tag |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |X| Sequence|   Fragment_Size   |       Fragment_Offset         |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                                 X set == Ack-Request
:::

[Figure 1](#figure-1){.selfRef}: [RFRAG Dispatch Type and
Header](#name-rfrag-dispatch-type-and-hea){.selfRef}
:::

[]{.break}

X:
:   1 bit; Ack-Request. When set, the fragmenting endpoint requires an
    RFRAG Acknowledgment from the reassembling
    endpoint.[¶](#section-5.1-5.2){.pilcrow}
:   

E:
:   1 bit; Explicit Congestion Notification. The \"E\" flag is cleared
    by the source of the fragment and set by intermediate routers to
    signal that this fragment experienced congestion along its
    path.[¶](#section-5.1-5.4){.pilcrow}
:   

Fragment_Size:
:   10-bit unsigned integer. The size of this fragment in a unit that
    depends on link-layer technology. Unless overridden by a more
    specific specification, that unit is the byte, which allows
    fragments up to 1023 bytes.[¶](#section-5.1-5.6){.pilcrow}
:   

Datagram_Tag:
:   8 bits. An identifier of the datagram that is locally unique to the
    link-layer sender.[¶](#section-5.1-5.8){.pilcrow}
:   

Sequence:
:   5-bit unsigned integer. The sequence number of the fragment in the
    acknowledgment bitmap. Fragments are numbered as \[0..N\], where N
    is in \[0..31\]. A Sequence of 0 indicates the first fragment in a
    datagram, but non-zero values are not indicative of the position in
    the reassembly buffer.[¶](#section-5.1-5.10){.pilcrow}
:   

Fragment_Offset:

:   16-bit unsigned integer.[¶](#section-5.1-5.12.1){.pilcrow}

    When the Fragment_Offset is set to a non-zero value, its semantics
    depend on the value of the Sequence field as
    follows:[¶](#section-5.1-5.12.2){.pilcrow}

    -   [For a first fragment (i.e., with a Sequence of 0), this field
        indicates the Datagram_Size of the compressed datagram, to help
        the reassembling endpoint allocate an adapted buffer for the
        reception and reassembly operations. The fragment may be stored
        for local reassembly. Alternatively, it may be routed based on
        the destination IPv6 address. In that case, a VRB state must be
        installed as described in [Section
        6.1.1](#ff){.xref}.[¶](#section-5.1-5.12.3.1){.pilcrow}]{#section-5.1-5.12.3.1}
    -   [When the Sequence is not 0, this field indicates the offset of
        the fragment in the compressed form of the datagram. The
        fragment may be added to a local reassembly buffer or forwarded
        based on an existing VRB as described in [Section
        6.1.2](#nf){.xref}.[¶](#section-5.1-5.12.3.2){.pilcrow}]{#section-5.1-5.12.3.2}

    A Fragment_Offset that is set to a value of 0 indicates an abort
    condition, and all states regarding the datagram should be cleaned
    up once the processing of the fragment is complete; the processing
    of the fragment depends on whether there is a VRB already
    established for this datagram and if the next hop is still
    reachable:[¶](#section-5.1-5.12.4){.pilcrow}

    -   [if a VRB already exists and the next hop is still reachable,
        the fragment is to be forwarded along the associated LSP as
        described in [Section 6.1.2](#nf){.xref}, without checking the
        value of the Sequence
        field.[¶](#section-5.1-5.12.5.1){.pilcrow}]{#section-5.1-5.12.5.1}
    -   [else, if the Sequence is 0, then the fragment is to be routed
        as described in [Section 6.1.1](#ff){.xref}, but no state is
        conserved afterwards. In that case, the session, if it exists,
        is aborted, and the packet is also forwarded in an attempt to
        clean up the next hops along the path indicated by the IPv6
        header (possibly including a Routing
        Header).[¶](#section-5.1-5.12.5.2){.pilcrow}]{#section-5.1-5.12.5.2}
    -   [else (the Sequence is non-zero and either no VRB exists or the
        next hop is unavailable), the fragment cannot be forwarded or
        routed; the fragment is discarded and an abort RFRAG-ACK is sent
        back to the source as described in [Section
        6.1.2](#nf){.xref}.[¶](#section-5.1-5.12.5.3){.pilcrow}]{#section-5.1-5.12.5.3}

:   

Recoverable Fragments are sequenced, and a bitmap is used in the RFRAG
Acknowledgment to indicate the received fragments by setting the
individual bits that correspond to their
sequence.[¶](#section-5.1-6){.pilcrow}

There is no requirement on the reassembling endpoint to check that the
received fragments are consecutive and non-overlapping. This may be
useful, in particular, in the case where the MTU changes and a fragment
Sequence is retried with a smaller Fragment_Size, with the remainder of
the original fragment being retried with new Sequence values. The
fragmenting endpoint knows that the datagram is fully received when the
acknowledged fragments cover the whole datagram, which is implied by a
FULL bitmap.[¶](#section-5.1-7){.pilcrow}
:::
:::

::: {#ackfrag}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [RFRAG Acknowledgment Dispatch Type and Header](#name-rfrag-acknowledgment-dispat){.section-name .selfRef} {#name-rfrag-acknowledgment-dispat}

This specification also defines a 4-byte RFRAG Acknowledgment Bitmap
that is used by the reassembling endpoint to selectively confirm the
reception of individual fragments. A given offset in the bitmap maps one
to one with a given sequence number and indicates which fragment is
acknowledged as follows:[¶](#section-5.2-1){.pilcrow}

[]{#name-rfrag-acknowledgment-bitmap}

::: {#dCack3}
::: {#section-5.2-2.1 .artwork .art-text .alignCenter}
                             1                   2                   3
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |           RFRAG Acknowledgment Bitmap                         |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         ^                 ^
         |                 |    bitmap indicating whether:
         |                 +----- Fragment with Sequence 9 was received
         +----------------------- Fragment with Sequence 0 was received
:::

[Figure 2](#figure-2){.selfRef}: [RFRAG Acknowledgment Bitmap
Encoding](#name-rfrag-acknowledgment-bitmap){.selfRef}
:::

[Figure 3](#dCack2){.xref} shows an example RFRAG Acknowledgment Bitmap
that indicates that all fragments from Sequence 0 to 20 were received,
except for fragments 1, 2, and 16, which were lost and must be
retried.[¶](#section-5.2-3){.pilcrow}

[]{#name-example-rfrag-acknowledgmen}

::: {#dCack2}
::: {#section-5.2-4.1 .artwork .art-text .alignCenter}
                             1                   2                   3
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |1|0|0|1|1|1|1|1|1|1|1|1|1|1|1|1|0|1|1|1|1|0|0|0|0|0|0|0|0|0|0|0|
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 3](#figure-3){.selfRef}: [Example RFRAG Acknowledgment
Bitmap](#name-example-rfrag-acknowledgmen){.selfRef}
:::

The RFRAG Acknowledgment Bitmap is included in an RFRAG Acknowledgment
header, as follows:[¶](#section-5.2-5){.pilcrow}

[]{#name-rfrag-acknowledgment-dispatc}

::: {#ackfig}
::: {#section-5.2-6.1 .artwork .art-text .alignCenter}

                             1                   2                   3
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                        |1 1 1 0 1 0 1|E|  Datagram_Tag |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |          RFRAG Acknowledgment Bitmap (32 bits)                |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 4](#figure-4){.selfRef}: [RFRAG Acknowledgment Dispatch Type and
Header](#name-rfrag-acknowledgment-dispatc){.selfRef}
:::

[]{.break}

E:
:   1 bit; Explicit Congestion Notification
    Echo.[¶](#section-5.2-7.2){.pilcrow}
:   

:   When set, the fragmenting endpoint indicates that at least one of
    the acknowledged fragments was received with an Explicit Congestion
    Notification, indicating that the path followed by the fragments is
    subject to congestion. See more details in [Appendix
    C](#onECN){.xref}.[¶](#section-5.2-7.4){.pilcrow}
:   

Datagram_Tag:
:   8 bits; an identifier of the datagram that is locally unique to the
    link-layer recipient.[¶](#section-5.2-7.6){.pilcrow}
:   

RFRAG Acknowledgment Bitmap:
:   An RFRAG Acknowledgment Bitmap, whereby setting the bit at offset x
    indicates that fragment x was received, as shown in [Figure
    2](#dCack3){.xref}. A NULL bitmap indicates that the fragmentation
    process is aborted. A FULL bitmap indicates that the fragmentation
    process is complete; all fragments were received at the reassembly
    endpoint.[¶](#section-5.2-7.8){.pilcrow}
:   
:::
:::
:::
:::

::: {#ffc}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Fragment Recovery](#name-fragment-recovery){.section-name .selfRef} {#name-fragment-recovery}

The RFRAG header is used to transport a fragment and optionally request
an RFRAG-ACK that confirms the reception of one or more fragments. An
RFRAG-ACK is carried as a standalone fragment header (i.e., with no
6LoWPAN payload) in a message that is propagated back to the fragmenting
endpoint. To achieve this, each hop that performed an MPLS-like
operation on fragments reverses that operation for the RFRAG-ACK by
sending a frame from the next hop to the previous hop as known by its
link-layer address in the VRB. The Datagram_Tag in the RFRAG-ACK is
unique to the reassembling endpoint and is enough information for an
intermediate hop to locate the VRB that contains the Datagram_Tag used
by the previous hop and the Layer 2 information associated with it
(interface and link-layer address).[¶](#section-6-1){.pilcrow}

The fragmenting endpoint (i.e., the node that fragments the packets at
the 6LoWPAN level) also controls the number of acknowledgments by
setting the Ack-Request flag in the RFRAG
packets.[¶](#section-6-2){.pilcrow}

The fragmenting endpoint may set the Ack-Request flag on any fragment to
perform congestion control by limiting the number of outstanding
fragments, which are the fragments that have been sent but for which
reception or loss was not positively confirmed by the reassembling
endpoint. The maximum number of outstanding fragments is controlled by
the Window-Size. It is configurable and may vary in case of ECN
notification. When the endpoint that reassembles the packets at the
6LoWPAN level receives a fragment with the Ack-Request flag set, it
[MUST]{.bcp14} send an RFRAG-ACK back to the originator to confirm
reception of all the fragments it has received so
far.[¶](#section-6-3){.pilcrow}

The Ack-Request (\"X\") set in an RFRAG marks the end of a window. This
flag [MUST]{.bcp14} be set on the last fragment if the fragmenting
endpoint wishes to perform an automatic repeat request (ARQ) process for
the datagram, and it [MAY]{.bcp14} be set in any intermediate fragment
for the purpose of congestion control.[¶](#section-6-4){.pilcrow}

This ARQ process [MUST]{.bcp14} be protected by a Retransmission Timeout
(RTO) timer, and the fragment that carries the \"X\" flag [MAY]{.bcp14}
be retried upon a timeout for a configurable number of times (see
[Section 7.1](#protp){.xref}) with an exponential backoff. Upon
exhaustion of the retries, the fragmenting endpoint may either abort the
transmission of the datagram or resend the first fragment with an \"X\"
flag set in order to establish a new path for the datagram and obtain
the list of fragments that were received over the old path in the
acknowledgment bitmap. When the fragmenting endpoint knows that an
underlying link-layer mechanism protects the fragments, it may refrain
from using the RFRAG Acknowledgment mechanism and never set the
Ack-Request bit.[¶](#section-6-5){.pilcrow}

The reassembling endpoint [MAY]{.bcp14} issue unsolicited
acknowledgments. An unsolicited acknowledgment signals to the
fragmenting endpoint that it can resume sending in case it has reached
its maximum number of outstanding fragments. Another use is to inform
the fragmenting endpoint that the reassembling endpoint aborted the
processing of an individual datagram.[¶](#section-6-6){.pilcrow}

The RFRAG Acknowledgment carries an ECN indication for congestion
control (see [Appendix C](#onECN){.xref}). The reassembling endpoint of
a fragment with the \"E\" (ECN) flag set [MUST]{.bcp14} echo that
information at most once by setting the \"E\" (ECN) flag in the next
RFRAG-ACK.[¶](#section-6-7){.pilcrow}

In order to protect the datagram, the fragmenting endpoint transfers a
controlled number of fragments and flags to the last fragment of a
window with an RFRAG Acknowledgment Request. The reassembling endpoint
[MUST]{.bcp14} acknowledge a fragment with the acknowledgment request
bit set. If any fragment immediately preceding an acknowledgment request
is still missing, the reassembling endpoint [MAY]{.bcp14} intentionally
delay its acknowledgment to allow in-transit fragments to arrive.
Because it might defeat the round-trip time computation, delaying the
acknowledgment should be configurable and not enabled by
default.[¶](#section-6-8){.pilcrow}

When enough fragments are received to cover the whole datagram, the
reassembling endpoint reconstructs the packet, passes it to the upper
layer, sends an RFRAG-ACK on the reverse path with a FULL bitmap, and
arms a short timer, e.g., on the order of an average round-trip time in
the network. The FULL bitmap is used as opposed to a bitmap that
acknowledges only the received fragments to let the intermediate nodes
know that the datagram is fully received. As the timer runs, the
reassembling endpoint absorbs the fragments that were still in flight
for that datagram without creating a new state, acknowledging the ones
that bear an Ack-Request with an FRAG Acknowledgment and the FULL
bitmap. The reassembling endpoint aborts the communication if fragments
with a matching source and Datagram-Tag continue to be received after
the timer expires.[¶](#section-6-9){.pilcrow}

Note that acknowledgments might consume precious resources, so the use
of unsolicited acknowledgments [SHOULD]{.bcp14} be configurable and not
enabled by default.[¶](#section-6-10){.pilcrow}

An observation is that streamlining the forwarding of fragments
generally reduces the latency over the LLN mesh, providing room for
retries within existing upper-layer reliability mechanisms. The
fragmenting endpoint protects the transmission over the LLN mesh with a
retry timer that is configured for a use case and may be adapted
dynamically, e.g., according to the method detailed in
\[[RFC6298](#RFC6298){.xref}\]. It is expected that the upper-layer
retry mechanism obeys the recommendations in
\[[RFC8085](#RFC8085){.xref}\], in which case a single round of fragment
recovery should fit within the upper-layer recovery
timers.[¶](#section-6-11){.pilcrow}

Fragments [MUST]{.bcp14} be sent in a round-robin fashion: the sender
[MUST]{.bcp14} send all the fragments for a first time before it retries
any lost fragment; lost fragments [MUST]{.bcp14} be retried in sequence,
oldest first. This mechanism enables the receiver to acknowledge
fragments that were delayed in the network before they are
retried.[¶](#section-6-12){.pilcrow}

When a single radio frequency is used by contiguous hops, the
fragmenting endpoint [SHOULD]{.bcp14} insert a delay between the frames
(e.g., carrying fragments) that are sent to the same next hop. The delay
[SHOULD]{.bcp14} cover multiple transmissions so as to let a frame
progress a few hops and avoid hidden terminal issues. This precaution is
not required on channel hopping technologies such as Time-Slotted
Channel Hopping (TSCH) \[[RFC6554](#RFC6554){.xref}\], where nodes that
communicate at Layer 2 are scheduled to send and receive, respectively,
and different hops operate on different
channels.[¶](#section-6-13){.pilcrow}

::: {#ffg}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Forwarding Fragments](#name-forwarding-fragments){.section-name .selfRef} {#name-forwarding-fragments}

This specification inherits from \[[RFC8930](#RFC8930){.xref}\] and
proposes a Virtual Reassembly Buffer technique to forward fragments with
no intermediate reconstruction of the entire
datagram.[¶](#section-6.1-1){.pilcrow}

The IPv6 header [MUST]{.bcp14} be placed in the first fragment in full
to enable the routing decision. The first fragment is routed and creates
an LSP from the fragmenting endpoint to the reassembling endpoint. The
next fragments are label switched along that LSP. As a consequence, the
next fragments can only follow the path that was set up by the first
fragment; they cannot follow an alternate route. The Datagram_Tag is
used to carry the label, which is swapped in each
hop.[¶](#section-6.1-2){.pilcrow}

If the first fragment is too large for the path MTU, it will repeatedly
fail and never establish an LSP. In that case, the fragmenting endpoint
[MAY]{.bcp14} retry the same datagram with a smaller Fragment_Size, in
which case it [MUST]{.bcp14} abort the original attempt and use a new
Datagram_Tag for the new attempt.[¶](#section-6.1-3){.pilcrow}

::: {#ff}
::: {#section-6.1.1 .section}
#### [6.1.1.](#section-6.1.1){.section-number .selfRef} [Receiving the First Fragment](#name-receiving-the-first-fragmen){.section-name .selfRef} {#name-receiving-the-first-fragmen}

In route-over mode, the source and destination link-layer addresses in a
frame change at each hop. The label that is formed and placed in the
Datagram_Tag by the sender is associated with the source link-layer
address and only valid (and temporarily unique) for that source
link-layer address.[¶](#section-6.1.1-1){.pilcrow}

Upon receiving the first fragment (i.e., with a Sequence of 0), an
intermediate router creates a VRB and the associated LSP state indexed
by the incoming interface, the previous-hop link-layer address, and the
Datagram_Tag and forwards the fragment along the IPv6 route that matches
the destination IPv6 address in the IPv6 header until it reaches the
reassembling endpoint, as prescribed by \[[RFC8930](#RFC8930){.xref}\].
The LSP state enables matching the next incoming fragments of a datagram
to the abstract forwarding information of the next interface, source and
next-hop link-layer addresses, and the swapped
Datagram_Tag.[¶](#section-6.1.1-2){.pilcrow}

In addition, the router also forms a reverse LSP state indexed by the
interface to the next hop, the link-layer address the router uses as
source for that datagram, and the swapped Datagram_Tag. This reverse LSP
state enables matching the tuple (interface, destination link-layer
address, Datagram_Tag) found in an RFRAG-ACK to the abstract forwarding
information (previous interface, previous link-layer address,
Datagram_Tag) used to forward the RFRAG-ACK back to the fragmenting
endpoint.[¶](#section-6.1.1-3){.pilcrow}
:::
:::

::: {#nf}
::: {#section-6.1.2 .section}
#### [6.1.2.](#section-6.1.2){.section-number .selfRef} [Receiving the Next Fragments](#name-receiving-the-next-fragment){.section-name .selfRef} {#name-receiving-the-next-fragment}

Upon receiving the next fragment (i.e., with a non-zero Sequence), an
intermediate router looks up an LSP indexed by the tuple (incoming
interface, previous-hop link-layer address, Datagram_Tag) found in the
fragment. If it is found, the router forwards the fragment using the
associated VRB as prescribed by
\[[RFC8930](#RFC8930){.xref}\].[¶](#section-6.1.2-1){.pilcrow}

If the VRB for the tuple is not found, the router builds an RFRAG-ACK to
abort the transmission of the packet. The resulting message has the
following information:[¶](#section-6.1.2-2){.pilcrow}

-   [The source and destination link-layer addresses are swapped from
    those found in the fragment, and the same interface is
    used[¶](#section-6.1.2-3.1){.pilcrow}]{#section-6.1.2-3.1}
-   [The Datagram_Tag is set to the Datagram_Tag found in the
    fragment[¶](#section-6.1.2-3.2){.pilcrow}]{#section-6.1.2-3.2}
-   [A NULL bitmap is used to signal the abort
    condition[¶](#section-6.1.2-3.3){.pilcrow}]{#section-6.1.2-3.3}

At this point, the router is all set and can send the RFRAG-ACK back to
the previous router. The RFRAG-ACK should normally be forwarded all the
way to the source using the reverse LSP state in the VRBs in the
intermediate routers as described in the next
section.[¶](#section-6.1.2-4){.pilcrow}

\[[RFC8930](#RFC8930){.xref}\] indicates that the reassembling endpoint
stores \"the actual packet data from the fragments received so far, in a
form that makes it possible to detect when the whole packet has been
received and can be processed or forwarded\". How this is computed is
implementation specific, but it relies on receiving all the bytes up to
the Datagram_Size indicated in the first fragment. An implementation may
receive overlapping fragments as the result of retries after an MTU
change.[¶](#section-6.1.2-5){.pilcrow}
:::
:::
:::
:::

::: {#ura}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Receiving RFRAG Acknowledgments](#name-receiving-rfrag-acknowledgm){.section-name .selfRef} {#name-receiving-rfrag-acknowledgm}

Upon receipt of an RFRAG-ACK, the router looks up a reverse LSP indexed
by the interface and destination link-layer address of the received
frame and the received Datagram_Tag in the RFRAG-ACK. If it is found,
the router forwards the fragment using the associated VRB as prescribed
by \[[RFC8930](#RFC8930){.xref}\], but it uses the reverse LSP so that
the RFRAG-ACK flows back to the fragmenting
endpoint.[¶](#section-6.2-1){.pilcrow}

If the reverse LSP is not found, the router [MUST]{.bcp14} silently drop
the RFRAG-ACK message.[¶](#section-6.2-2){.pilcrow}

Either way, if the RFRAG-ACK indicates that the fragment was entirely
received (FULL bitmap), it arms a short timer, and upon timeout, the VRB
and all the associated states are destroyed. Until the timer elapses,
fragments of that datagram may still be received, e.g., if the RFRAG-ACK
was lost on the path back, and the source retried the last fragment. In
that case, the router generates an RFRAG-ACK with a FULL bitmap back to
the fragmenting endpoint if an acknowledgment was requested; else, it
silently drops the fragment.[¶](#section-6.2-3){.pilcrow}

This specification does not provide a method to discover the number of
hops or the minimal value of MTU along those hops. In a typical case,
the MTU is constant and is the same across the network. But should the
minimal MTU along the path decrease, it is possible to retry a long
fragment (say a Sequence of 5) with several shorter fragments with a
Sequence that was not used before (e.g., 13 and 14). Fragment 5 is
marked as abandoned and will not be retried anymore. Note that when this
mechanism is in place, it is hard to predict the total number of
fragments that will be needed or the final shape of the bitmap that
would cover the whole packet. This is why the FULL bitmap is used when
the reassembling endpoint gets the whole datagram regardless of which
fragments were actually used to do so. Intermediate nodes will know
unambiguously that the process is complete. Note that Path MTU Discovery
is out of scope for this document.[¶](#section-6.2-4){.pilcrow}
:::
:::

::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Aborting the Transmission of a Fragmented Packet](#name-aborting-the-transmission-o){.section-name .selfRef} {#name-aborting-the-transmission-o}

A reset is signaled on the forward path with a pseudo fragment that has
the Fragment_Offset set to 0. The sender of a reset [SHOULD]{.bcp14}
also set the Sequence and Fragment_Size field to
0.[¶](#section-6.3-1){.pilcrow}

When the fragmenting endpoint or a router on the path decides that a
packet should be dropped and the fragmentation process aborted, it
generates a reset pseudo fragment and forwards it down the fragment
path.[¶](#section-6.3-2){.pilcrow}

Each router along the path forwards the pseudo fragment in turn based on
the VRB state. If an acknowledgment is not requested, the VRB and all
associated states are destroyed.[¶](#section-6.3-3){.pilcrow}

Upon reception of the pseudo fragment, the reassembling endpoint cleans
up all resources for the packet associated with the Datagram_Tag. If an
acknowledgment is requested, the reassembling endpoint responds with a
NULL bitmap.[¶](#section-6.3-4){.pilcrow}

On the other hand, the reassembling endpoint might need to abort the
processing of a fragmented packet for internal reasons, for instance, if
it is out of reassembly buffers, already uses all 256 possible values of
the Datagram_Tag, or keeps receiving fragments beyond a reasonable time
while it considers that this packet is already fully reassembled and was
passed to the upper layer. In that case, the reassembling endpoint
[SHOULD]{.bcp14} indicate so to the fragmenting endpoint with a NULL
bitmap in an RFRAG-ACK.[¶](#section-6.3-5){.pilcrow}

The RFRAG-ACK is forwarded all the way back to the source of the packet
and cleans up all resources on the path. Upon an acknowledgment with a
NULL bitmap, the fragmenting endpoint [MUST]{.bcp14} abort the
transmission of the fragmented datagram with one exception: in the
particular case of the first fragment, it [MAY]{.bcp14} decide to retry
via an alternate next hop instead.[¶](#section-6.3-6){.pilcrow}
:::

::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [Applying Recoverable Fragmentation along a Diverse Path](#name-applying-recoverable-fragme){.section-name .selfRef} {#name-applying-recoverable-fragme}

The text above can be read with the assumption of a serial path between
a source and a destination. The IPv6 over the TSCH mode of IEEE
802.15.4e (6TiSCH) architecture (see [Section
4.5.3](https://tools.ietf.org/html/draft-ietf-6tisch-architecture-29#section-4.5.3){.relref}
of \[[6TiSCH](#I-D.ietf-6tisch-architecture){.xref}\]) defines the
concept of a Track that can be a complex path between a source and a
destination with Packet ARQ, Replication, Elimination, and Overhearing
(PAREO) along the Track. This specification can be used along any subset
of the complex Track where the first fragment is flooded. The last RFRAG
Acknowledgment is flooded on that same subset in the reverse direction.
Intermediate RFRAG Acknowledgments can be flooded on any sub-subset of
that reverse subset that reaches back to the
source.[¶](#section-6.4-1){.pilcrow}
:::
:::
:::

::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Management Considerations](#name-management-considerations){.section-name .selfRef} {#name-management-considerations}

This specification extends \[[RFC8930](#RFC8930){.xref}\] and requires
the same parameters in the reassembling endpoint and on intermediate
nodes. There is no new parameter as echoing ECN is always on. These
parameters typically include the reassembly timeout at the reassembling
endpoint, an inactivity cleanup timer on the intermediate nodes, and the
number of messages that can be processed in parallel in all
nodes.[¶](#section-7-1){.pilcrow}

The configuration settings introduced by this specification only apply
to the fragmenting endpoint, which is in full control of the
transmission. LLNs vary a lot in size (there can be thousands of nodes
in a mesh), in speed (from 10 Kbps to several Mbps at the PHY layer), in
traffic density, and in optimizations that are desired (e.g., the
selection of a Routing Protocol for LLNs (RPL)
\[[RFC6550](#RFC6550){.xref}\] Objective Function
\[[RFC6552](#RFC6552){.xref}\] impacts the shape of the routing
graph).[¶](#section-7-2){.pilcrow}

For that reason, only very generic guidance can be given on the settings
of the fragmenting endpoint and on whether complex algorithms are needed
to perform congestion control or to estimate the round-trip time. To
cover the most complex use cases, this specification enables the
fragmenting endpoint to vary the fragment size, the window size, and the
inter-frame gap based on the number of losses, the observed variations
of the round-trip time, and the setting of the ECN
bit.[¶](#section-7-3){.pilcrow}

::: {#protp}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Protocol Parameters](#name-protocol-parameters){.section-name .selfRef} {#name-protocol-parameters}

The management system [SHOULD]{.bcp14} be capable of providing the
parameters listed in this section, and an implementation [MUST]{.bcp14}
abide by those parameters and, in particular, never exceed the minimum
and maximum configured boundaries.[¶](#section-7.1-1){.pilcrow}

An implementation should consider the generic recommendations from the
IETF in the matter of congestion control and rate management for IP
datagrams in \[[RFC8085](#RFC8085){.xref}\]. An implementation may
perform congestion control by using a dynamic value of the window size
(Window_Size), adapting the fragment size (Fragment_Size), and
potentially reducing the load by inserting an inter-frame gap that is
longer than necessary. In a large network where nodes contend for the
bandwidth, a larger Fragment_Size consumes less bandwidth but also
reduces fluidity and incurs higher chances of loss in
transmission.[¶](#section-7.1-2){.pilcrow}

This is controlled by the following
parameters:[¶](#section-7.1-3){.pilcrow}

[]{.break}

inter-frame gap:
:   The inter-frame gap indicates the minimum amount of time between
    transmissions. The inter-frame gap controls the rate at which
    fragments are sent, the ratio of air time, and the amount of memory
    in intermediate nodes that a particular datagram will use. It can be
    used as a flow control, a congestion control, and/or a collision
    control measure. It [MUST]{.bcp14} be set at a minimum to a value
    that protects the propagation of one transmission against collision
    with next \[[RFC8930](#RFC8930){.xref}\]. In a wireless network that
    uses the same frequency along a path, this may represent the time
    for a frame to progress over multiple hops (see more in [Section
    4.2](#gap){.xref}). It [SHOULD]{.bcp14} be augmented beyond this as
    necessary to protect the network against
    congestion.[¶](#section-7.1-4.2){.pilcrow}
:   

MinFragmentSize:
:   The MinFragmentSize is the minimum value for the Fragment_Size. It
    [MUST]{.bcp14} be lower than the minimum value of smallest 1-hop MTU
    that can be encountered along the
    path.[¶](#section-7.1-4.4){.pilcrow}
:   

OptFragmentSize:
:   The OptFragmentSize is the value for the Fragment_Size that the
    fragmenting endpoint should use to start with. It is greater than or
    equal to MinFragmentSize. It is less than or equal to
    MaxFragmentSize. For the first fragment, it must account for the
    expansion of the IPv6 addresses and of the Hop Limit field within
    MTU. For all fragments, it is a balance between the expected
    fluidity and the overhead of link-layer and 6LoWPAN headers. For a
    small MTU, the idea is to keep it close to the maximum, whereas for
    larger MTUs, it might make sense to keep it short enough so that the
    duty cycle of the transmitter is bounded, e.g., to transmit at least
    10 frames per second.[¶](#section-7.1-4.6){.pilcrow}
:   

MaxFragmentSize:
:   The MaxFragmentSize is the maximum value for the Fragment_Size. It
    [MUST]{.bcp14} be lower than the maximum value of the smallest 1-hop
    MTU that can be encountered along the path. A large value augments
    the chances of buffer bloat and transmission loss. The value
    [MUST]{.bcp14} be less than 512 if the unit that is defined for the
    PHY layer is the byte.[¶](#section-7.1-4.8){.pilcrow}
:   

Window_Size:

:   The Window_Size [MUST]{.bcp14} be at least 1 and less than
    33.[¶](#section-7.1-4.10.1){.pilcrow}

    -   [If the round-trip time is known, the Window_Size
        [SHOULD]{.bcp14} be set to the round-trip time divided by the
        time per fragment; that is, the time to transmit a fragment plus
        the inter-frame
        gap.[¶](#section-7.1-4.10.2.1){.pilcrow}]{#section-7.1-4.10.2.1}

    Otherwise:[¶](#section-7.1-4.10.3){.pilcrow}

    -   [A window_size of 32 indicates that only the last fragment is to
        be acknowledged in each round. This is the [RECOMMENDED]{.bcp14}
        value in a half-duplex LLN where the fragment acknowledgment
        consumes roughly the same bandwidth on the same links as the
        fragments
        themselves.[¶](#section-7.1-4.10.4.1){.pilcrow}]{#section-7.1-4.10.4.1}
    -   [If it is set to a smaller value, more acks are generated. In a
        full-duplex network, the load on the forward path will be lower,
        and a small value of 3 [SHOULD]{.bcp14} be
        configured.[¶](#section-7.1-4.10.4.2){.pilcrow}]{#section-7.1-4.10.4.2}

:   

An implementation may perform its estimate of the RTO or use a
configured one. The ARQ process is controlled by the following
parameters:[¶](#section-7.1-5){.pilcrow}

[]{.break}

MinARQTimeOut:
:   The minimum amount of time a node should wait for an RFRAG
    Acknowledgment before it takes the next action. It [MUST]{.bcp14} be
    more than the maximum expected round-trip time in the respective
    network.[¶](#section-7.1-6.2){.pilcrow}
:   

OptARQTimeOut:
:   The initial value of the RTO, which is the amount of time that a
    fragmenting endpoint should wait for an RFRAG Acknowledgment before
    it takes the next action. It is greater than or equal to
    MinARQTimeOut. It is less than or equal to MaxARQTimeOut. See
    [Appendix C](#onECN){.xref} for recommendations on computing the
    round-trip time. By default, a value of 3 times the maximum expected
    round-trip time in the respective network is
    [RECOMMENDED]{.bcp14}.[¶](#section-7.1-6.4){.pilcrow}
:   

MaxARQTimeOut:
:   The maximum amount of time a node should wait for the RFRAG
    Acknowledgment before it takes the next action. It must cover the
    longest expected round-trip time and be several times less than the
    timeout that covers the recomposition buffer at the reassembling
    endpoint, which is typically on the order of the minute. An upper
    bound can be estimated to ensure that the datagram is either fully
    transmitted or dropped before an upper layer decides to retry
    it.[¶](#section-7.1-6.6){.pilcrow}
:   

MaxFragRetries:
:   The maximum number of retries for a particular fragment. A default
    value of 3 is [RECOMMENDED]{.bcp14}. An upper bound can be estimated
    to ensure that the datagram is either fully transmitted or dropped
    before an upper layer decides to retry
    it.[¶](#section-7.1-6.8){.pilcrow}
:   

MaxDatagramRetries:
:   The maximum number of retries from scratch for a particular
    datagram. A default value of 1 is [RECOMMENDED]{.bcp14}. An upper
    bound can be estimated to ensure that the datagram is either fully
    transmitted or dropped before an upper layer decides to retry
    it.[¶](#section-7.1-6.10){.pilcrow}
:   

An implementation may be capable of performing congestion control based
on ECN; see [Appendix C](#onECN){.xref}. This is controlled by the
following parameter:[¶](#section-7.1-7){.pilcrow}

[]{.break}

UseECN:
:   Indicates whether the fragmenting endpoint should react to ECN. The
    fragmenting endpoint may react to ECN by varying the Window_Size
    between MinWindowSize and MaxWindowSize, varying the Fragment_Size
    between MinFragmentSize and MaxFragmentSize, and/or increasing or
    reducing the inter-frame gap. With this specification, if UseECN is
    set and a fragmenting endpoint detects a congestion, it may apply a
    congestion control method until the end of the datagram, whereas if
    UseECN is reset, the endpoint does not react to congestion. Future
    specifications may provide additional parameters and
    capabilities.[¶](#section-7.1-8.2){.pilcrow}
:   
:::
:::

::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Observing the Network](#name-observing-the-network){.section-name .selfRef} {#name-observing-the-network}

The management system should monitor the number of retries and ECN
settings that can be observed from the perspective of the fragmenting
endpoint with respect to the reassembling endpoint and reciprocally. It
may then tune the optimum size of Fragment_Size and of Window_Size,
OptFragmentSize, and OptWindowSize, respectively, at the fragmenting
endpoint towards a particular reassembling endpoint, which is applicable
to the next datagrams. It will preferably tune the inter-frame gap to
increase the spacing between fragments of the same datagram and reduce
the buffer bloat in the intermediate node that holds one or more
fragments of that datagram.[¶](#section-7.2-1){.pilcrow}
:::
:::

::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

This document specifies an instantiation of a 6LFF technique and
inherits from the generic description in \[[RFC8930](#RFC8930){.xref}\].
The considerations in the Security Considerations section of
\[[RFC8930](#RFC8930){.xref}\] equally apply to this
document.[¶](#section-8-1){.pilcrow}

In addition to the threats detailed therein, an attacker that is on path
can prematurely end the transmission of a datagram by sending a RFRAG
Acknowledgment to the fragmenting endpoint. It can also cause extra
transmissions of fragments by resetting bits in the RFRAG Acknowledgment
Bitmap and of RFRAG Acknowledgments by forcing the Ack-Request bit in
fragments that it forwards.[¶](#section-8-2){.pilcrow}

As indicated in \[[RFC8930](#RFC8930){.xref}\], secure joining and
link-layer security are [REQUIRED]{.bcp14} to protect against those
attacks, as the fragmentation protocol does not include any native
security mechanisms.[¶](#section-8-3){.pilcrow}

This specification does not recommend a particular algorithm for the
estimation of the duration of the RTO that covers the detection of the
loss of a fragment with the \"X\" flag set; regardless, an attacker on
the path may slow down or discard packets, which in turn can affect the
throughput of fragmented packets.[¶](#section-8-4){.pilcrow}

Compared to \[[RFC4944](#RFC4944){.xref}\], this specification reduces
the Datagram_Tag to 8 bits, and the tag wraps faster than with
\[[RFC4944](#RFC4944){.xref}\]. But for a constrained network where a
node is expected to be able to hold only one or a few large packets in
memory, 256 is still a large number. Also, the acknowledgment mechanism
allows cleaning up the state rapidly once the packet is fully
transmitted or aborted.[¶](#section-8-5){.pilcrow}

The abstract Virtual Recovery Buffer from \[[RFC8930](#RFC8930){.xref}\]
may be used to perform a Denial-of-Service (DoS) attack against the
intermediate routers since the routers need to maintain a state per
flow. The particular VRB implementation technique described in
\[[LWIG-FRAG](#I-D.ietf-lwig-6lowpan-virtual-reassembly){.xref}\] allows
realigning which data goes in which fragment; this causes the
intermediate node to store a portion of the data, which adds an attack
vector that is not present with this specification. With this
specification, the data that is transported in each fragment is
conserved, and the state to keep does not include any data that would
not fit in the previous fragment.[¶](#section-8-6){.pilcrow}
:::

::: {#ianacon}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document allocates two patterns for a total of four dispatch values
for Recoverable Fragments from the \"Dispatch Type Field\" registry that
was created by \[[RFC4944](#RFC4944){.xref}\] and reformatted by [\"IPv6
over Low-Power Wireless Personal Area Network (6LoWPAN) Paging
Dispatch\"](#RFC8025){.xref}
\[[RFC8025](#RFC8025){.xref}\].[¶](#section-9-1){.pilcrow}

[]{#name-additional-dispatch-value-b}

::: {#difig}
  Bit Pattern   Page   Header Type                        Reference
  ------------- ------ ---------------------------------- -----------
  11 10100x     0      RFRAG - Recoverable Fragment       RFC 8931
  11 10100x     1-14   Unassigned                         
  11 10100x     15     Reserved for Experimental Use      RFC 8025
  11 10101x     0      RFRAG-ACK - RFRAG Acknowledgment   RFC 8931
  11 10101x     1-14   Unassigned                         
  11 10101x     15     Reserved for Experimental Use      RFC 8025

  : [Table 1](#table-1){.selfRef}: [Additional Dispatch Value Bit
  Patterns](#name-additional-dispatch-value-b){.selfRef}
:::
:::
:::

::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-10.1 .section}
### [10.1.](#section-10.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC4919\]
:   [Kushalnagar, N.]{.refAuthor}[, Montenegro, G.]{.refAuthor}[, and C.
    Schumacher]{.refAuthor}, [\"IPv6 over Low-Power Wireless Personal
    Area Networks (6LoWPANs): Overview, Assumptions, Problem Statement,
    and Goals\"]{.refTitle}, [RFC 4919]{.seriesInfo}, [DOI
    10.17487/RFC4919]{.seriesInfo}, August 2007,
    \<<https://www.rfc-editor.org/info/rfc4919>\>.
:   

\[RFC4944\]
:   [Montenegro, G.]{.refAuthor}[, Kushalnagar, N.]{.refAuthor}[,
    Hui, J.]{.refAuthor}[, and D. Culler]{.refAuthor}, [\"Transmission
    of IPv6 Packets over IEEE 802.15.4 Networks\"]{.refTitle}, [RFC
    4944]{.seriesInfo}, [DOI 10.17487/RFC4944]{.seriesInfo}, September
    2007, \<<https://www.rfc-editor.org/info/rfc4944>\>.
:   

\[RFC6282\]
:   [Hui, J., Ed.]{.refAuthor}[ and P. Thubert]{.refAuthor},
    [\"Compression Format for IPv6 Datagrams over IEEE 802.15.4-Based
    Networks\"]{.refTitle}, [RFC 6282]{.seriesInfo}, [DOI
    10.17487/RFC6282]{.seriesInfo}, September 2011,
    \<<https://www.rfc-editor.org/info/rfc6282>\>.
:   

\[RFC6298\]
:   [Paxson, V.]{.refAuthor}[, Allman, M.]{.refAuthor}[,
    Chu, J.]{.refAuthor}[, and M. Sargent]{.refAuthor}, [\"Computing
    TCP\'s Retransmission Timer\"]{.refTitle}, [RFC 6298]{.seriesInfo},
    [DOI 10.17487/RFC6298]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6298>\>.
:   

\[RFC6606\]
:   [Kim, E.]{.refAuthor}[, Kaspar, D.]{.refAuthor}[,
    Gomez, C.]{.refAuthor}[, and C. Bormann]{.refAuthor}, [\"Problem
    Statement and Requirements for IPv6 over Low-Power Wireless Personal
    Area Network (6LoWPAN) Routing\"]{.refTitle}, [RFC
    6606]{.seriesInfo}, [DOI 10.17487/RFC6606]{.seriesInfo}, May 2012,
    \<<https://www.rfc-editor.org/info/rfc6606>\>.
:   

\[RFC8025\]
:   [Thubert, P., Ed.]{.refAuthor}[ and R. Cragie]{.refAuthor}, [\"IPv6
    over Low-Power Wireless Personal Area Network (6LoWPAN) Paging
    Dispatch\"]{.refTitle}, [RFC 8025]{.seriesInfo}, [DOI
    10.17487/RFC8025]{.seriesInfo}, November 2016,
    \<<https://www.rfc-editor.org/info/rfc8025>\>.
:   

\[RFC8138\]
:   [Thubert, P., Ed.]{.refAuthor}[, Bormann, C.]{.refAuthor}[,
    Toutain, L.]{.refAuthor}[, and R. Cragie]{.refAuthor}, [\"IPv6 over
    Low-Power Wireless Personal Area Network (6LoWPAN) Routing
    Header\"]{.refTitle}, [RFC 8138]{.seriesInfo}, [DOI
    10.17487/RFC8138]{.seriesInfo}, April 2017,
    \<<https://www.rfc-editor.org/info/rfc8138>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8200\]
:   [Deering, S.]{.refAuthor}[ and R. Hinden]{.refAuthor}, [\"Internet
    Protocol, Version 6 (IPv6) Specification\"]{.refTitle}, [STD
    86]{.seriesInfo}, [RFC 8200]{.seriesInfo}, [DOI
    10.17487/RFC8200]{.seriesInfo}, July 2017,
    \<<https://www.rfc-editor.org/info/rfc8200>\>.
:   

\[RFC8930\]
:   [Watteyne, T., Ed.]{.refAuthor}[, Thubert, P., Ed.]{.refAuthor}[,
    and C. Bormann]{.refAuthor}, [\"On Forwarding 6LoWPAN (IPv6 over
    Low-Power Wireless Personal Area Network) Fragments over a Multi-Hop
    IPv6 Network\"]{.refTitle}, [RFC 8930]{.seriesInfo}, [DOI
    10.17487/RFC8930]{.seriesInfo}, November 2020,
    \<<https://www.rfc-editor.org/info/rfc8930>\>.
:   
:::

::: {#section-10.2 .section}
### [10.2.](#section-10.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[6TiSCH\]
:   [Thubert, P.]{.refAuthor}, [\"An Architecture for IPv6 over the TSCH
    mode of IEEE 802.15.4\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-6tisch-architecture-29]{.seriesInfo}, 27 August 2020,
    \<<https://tools.ietf.org/html/draft-ietf-6tisch-architecture-29>\>.
:   

\[IEEE.802.15.4\]
:   [IEEE]{.refAuthor}, [\"IEEE Standard for Low-Rate Wireless
    Networks\"]{.refTitle}, [IEEE Standard 802.15.4-2015]{.seriesInfo},
    [DOI 10.1109/IEEESTD.2016.7460875]{.seriesInfo}, April 2016,
    \<<http://ieeexplore.ieee.org/document/7460875/>\>.
:   

\[Kent\]
:   [Kent, C.]{.refAuthor}[ and J. Mogul]{.refAuthor}, [\"Fragmentation
    Considered Harmful\"]{.refTitle}, [SIGCOMM \'87: Proceedings of the
    ACM workshop on Frontiers in computer communications technology, pp.
    390-401]{.refContent}, [DOI 10.1145/55483.55524]{.seriesInfo},
    August 1987,
    \<<http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-87-3.pdf>\>.
:   

\[LWIG-FRAG\]
:   [Bormann, C.]{.refAuthor}[ and T. Watteyne]{.refAuthor}, [\"Virtual
    reassembly buffers in 6LoWPAN\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-lwig-6lowpan-virtual-reassembly-02]{.seriesInfo}, 9 March
    2020,
    \<<https://tools.ietf.org/html/draft-ietf-lwig-6lowpan-virtual-reassembly-02>\>.
:   

\[RFC2914\]
:   [Floyd, S.]{.refAuthor}, [\"Congestion Control
    Principles\"]{.refTitle}, [BCP 41]{.seriesInfo}, [RFC
    2914]{.seriesInfo}, [DOI 10.17487/RFC2914]{.seriesInfo}, September
    2000, \<<https://www.rfc-editor.org/info/rfc2914>\>.
:   

\[RFC3031\]
:   [Rosen, E.]{.refAuthor}[, Viswanathan, A.]{.refAuthor}[, and R.
    Callon]{.refAuthor}, [\"Multiprotocol Label Switching
    Architecture\"]{.refTitle}, [RFC 3031]{.seriesInfo}, [DOI
    10.17487/RFC3031]{.seriesInfo}, January 2001,
    \<<https://www.rfc-editor.org/info/rfc3031>\>.
:   

\[RFC3168\]
:   [Ramakrishnan, K.]{.refAuthor}[, Floyd, S.]{.refAuthor}[, and D.
    Black]{.refAuthor}, [\"The Addition of Explicit Congestion
    Notification (ECN) to IP\"]{.refTitle}, [RFC 3168]{.seriesInfo},
    [DOI 10.17487/RFC3168]{.seriesInfo}, September 2001,
    \<<https://www.rfc-editor.org/info/rfc3168>\>.
:   

\[RFC4963\]
:   [Heffner, J.]{.refAuthor}[, Mathis, M.]{.refAuthor}[, and B.
    Chandler]{.refAuthor}, [\"IPv4 Reassembly Errors at High Data
    Rates\"]{.refTitle}, [RFC 4963]{.seriesInfo}, [DOI
    10.17487/RFC4963]{.seriesInfo}, July 2007,
    \<<https://www.rfc-editor.org/info/rfc4963>\>.
:   

\[RFC5033\]
:   [Floyd, S.]{.refAuthor}[ and M. Allman]{.refAuthor}, [\"Specifying
    New Congestion Control Algorithms\"]{.refTitle}, [BCP
    133]{.seriesInfo}, [RFC 5033]{.seriesInfo}, [DOI
    10.17487/RFC5033]{.seriesInfo}, August 2007,
    \<<https://www.rfc-editor.org/info/rfc5033>\>.
:   

\[RFC5681\]
:   [Allman, M.]{.refAuthor}[, Paxson, V.]{.refAuthor}[, and E.
    Blanton]{.refAuthor}, [\"TCP Congestion Control\"]{.refTitle}, [RFC
    5681]{.seriesInfo}, [DOI 10.17487/RFC5681]{.seriesInfo}, September
    2009, \<<https://www.rfc-editor.org/info/rfc5681>\>.
:   

\[RFC6550\]
:   [Winter, T., Ed.]{.refAuthor}[, Thubert, P., Ed.]{.refAuthor}[,
    Brandt, A.]{.refAuthor}[, Hui, J.]{.refAuthor}[,
    Kelsey, R.]{.refAuthor}[, Levis, P.]{.refAuthor}[,
    Pister, K.]{.refAuthor}[, Struik, R.]{.refAuthor}[, Vasseur,
    JP.]{.refAuthor}[, and R. Alexander]{.refAuthor}, [\"RPL: IPv6
    Routing Protocol for Low-Power and Lossy Networks\"]{.refTitle},
    [RFC 6550]{.seriesInfo}, [DOI 10.17487/RFC6550]{.seriesInfo}, March
    2012, \<<https://www.rfc-editor.org/info/rfc6550>\>.
:   

\[RFC6552\]
:   [Thubert, P., Ed.]{.refAuthor}, [\"Objective Function Zero for the
    Routing Protocol for Low-Power and Lossy Networks
    (RPL)\"]{.refTitle}, [RFC 6552]{.seriesInfo}, [DOI
    10.17487/RFC6552]{.seriesInfo}, March 2012,
    \<<https://www.rfc-editor.org/info/rfc6552>\>.
:   

\[RFC6554\]
:   [Hui, J.]{.refAuthor}[, Vasseur, JP.]{.refAuthor}[,
    Culler, D.]{.refAuthor}[, and V. Manral]{.refAuthor}, [\"An IPv6
    Routing Header for Source Routes with the Routing Protocol for
    Low-Power and Lossy Networks (RPL)\"]{.refTitle}, [RFC
    6554]{.seriesInfo}, [DOI 10.17487/RFC6554]{.seriesInfo}, March 2012,
    \<<https://www.rfc-editor.org/info/rfc6554>\>.
:   

\[RFC7554\]
:   [Watteyne, T., Ed.]{.refAuthor}[, Palattella, M.]{.refAuthor}[,
    and L. Grieco]{.refAuthor}, [\"Using IEEE 802.15.4e Time-Slotted
    Channel Hopping (TSCH) in the Internet of Things (IoT): Problem
    Statement\"]{.refTitle}, [RFC 7554]{.seriesInfo}, [DOI
    10.17487/RFC7554]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7554>\>.
:   

\[RFC7567\]
:   [Baker, F., Ed.]{.refAuthor}[ and G. Fairhurst, Ed.]{.refAuthor},
    [\"IETF Recommendations Regarding Active Queue
    Management\"]{.refTitle}, [BCP 197]{.seriesInfo}, [RFC
    7567]{.seriesInfo}, [DOI 10.17487/RFC7567]{.seriesInfo}, July 2015,
    \<<https://www.rfc-editor.org/info/rfc7567>\>.
:   

\[RFC8085\]
:   [Eggert, L.]{.refAuthor}[, Fairhurst, G.]{.refAuthor}[, and G.
    Shepherd]{.refAuthor}, [\"UDP Usage Guidelines\"]{.refTitle}, [BCP
    145]{.seriesInfo}, [RFC 8085]{.seriesInfo}, [DOI
    10.17487/RFC8085]{.seriesInfo}, March 2017,
    \<<https://www.rfc-editor.org/info/rfc8085>\>.
:   

\[RFC8087\]
:   [Fairhurst, G.]{.refAuthor}[ and M. Welzl]{.refAuthor}, [\"The
    Benefits of Using Explicit Congestion Notification
    (ECN)\"]{.refTitle}, [RFC 8087]{.seriesInfo}, [DOI
    10.17487/RFC8087]{.seriesInfo}, March 2017,
    \<<https://www.rfc-editor.org/info/rfc8087>\>.
:   

\[RFC8201\]
:   [McCann, J.]{.refAuthor}[, Deering, S.]{.refAuthor}[,
    Mogul, J.]{.refAuthor}[, and R. Hinden, Ed.]{.refAuthor}, [\"Path
    MTU Discovery for IP version 6\"]{.refTitle}, [STD 87]{.seriesInfo},
    [RFC 8201]{.seriesInfo}, [DOI 10.17487/RFC8201]{.seriesInfo}, July
    2017, \<<https://www.rfc-editor.org/info/rfc8201>\>.
:   

\[RFC8900\]
:   [Bonica, R.]{.refAuthor}[, Baker, F.]{.refAuthor}[,
    Huston, G.]{.refAuthor}[, Hinden, R.]{.refAuthor}[,
    Troan, O.]{.refAuthor}[, and F. Gont]{.refAuthor}, [\"IP
    Fragmentation Considered Fragile\"]{.refTitle}, [BCP
    230]{.seriesInfo}, [RFC 8900]{.seriesInfo}, [DOI
    10.17487/RFC8900]{.seriesInfo}, September 2020,
    \<<https://www.rfc-editor.org/info/rfc8900>\>.
:   
:::
:::

::: {#rationale}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Rationale](#name-rationale){.section-name .selfRef} {#name-rationale}

There are a number of uses for large packets in Wireless Sensor
Networks. Such usages may not be the most typical or represent the
largest amount of traffic over the LLN; however, the associated
functionality can be critical enough to justify extra care for ensuring
effective transport of large packets across the
LLN.[¶](#section-appendix.a-1){.pilcrow}

The list of those usages includes:[¶](#section-appendix.a-2){.pilcrow}

Towards the LLN node:[¶](#section-appendix.a-3){.pilcrow}

-   [[]{.break}]{#section-appendix.a-4.1}

    Firmware update:
    :   For example, a new version of the LLN node software is
        downloaded from a system manager over unicast or multicast
        services. Such a reflashing operation typically involves
        updating a large number of similar LLN nodes over a relatively
        short period of time.[¶](#section-appendix.a-4.1.1.2){.pilcrow}
    :   

    Packages of commands:
    :   A number of commands or a full configuration can be packaged as
        a single message to ensure consistency and enable atomic
        execution or complete rollback. Until such commands are fully
        received and interpreted, the intended operation will not take
        effect.[¶](#section-appendix.a-4.1.1.4){.pilcrow}
    :   

From the LLN node:[¶](#section-appendix.a-5){.pilcrow}

-   [[]{.break}]{#section-appendix.a-6.1}

    Waveform captures:
    :   A number of consecutive samples are measured at a high rate for
        a short time and then are transferred from a sensor to a gateway
        or an edge server as a single large
        report.[¶](#section-appendix.a-6.1.1.2){.pilcrow}
    :   

    Data logs:
    :   LLN nodes may generate large logs of sampled data for later
        extraction. LLN nodes may also generate system logs to assist in
        diagnosing problems on the node or
        network.[¶](#section-appendix.a-6.1.1.4){.pilcrow}
    :   

    Large data packets:
    :   Rich data types might require more than one
        fragment.[¶](#section-appendix.a-6.1.1.6){.pilcrow}
    :   

Uncontrolled firmware download or waveform upload can easily result in a
massive increase of the traffic and saturate the
network.[¶](#section-appendix.a-7){.pilcrow}

When a fragment is lost in transmission, the lack of recovery in the
original fragmentation system of RFC 4944 implies that all fragments
would need to be resent, further contributing to the congestion that
caused the initial loss and potentially leading to congestion
collapse.[¶](#section-appendix.a-8){.pilcrow}

This saturation may lead to excessive radio interference or random early
discard (leaky bucket) in relaying nodes. Additional queuing and memory
congestion may result while waiting for a low-power next hop to emerge
from its sleep state.[¶](#section-appendix.a-9){.pilcrow}

Considering that RFC 4944 defines an MTU as 1280 bytes, and that in most
incarnations (except 802.15.4g) an IEEE Std 802.15.4 frame can limit the
link-layer payload to as few as 74 bytes, a packet might be fragmented
into at least 18 fragments at the 6LoWPAN shim layer. Taking into
account the worst-case header overhead for 6LoWPAN Fragmentation and
Mesh Addressing headers will increase the number of required fragments
to around 32. This level of fragmentation is much higher than that
traditionally experienced over the Internet with IPv4 fragments. At the
same time, the use of radios increases the probability of transmission
loss, and mesh-under techniques compound that risk over multiple
hops.[¶](#section-appendix.a-10){.pilcrow}

Mechanisms such as TCP or application-layer segmentation could be used
to support end-to-end reliable transport. One option to support bulk
data transfer over a frame-size-constrained LLN is to set the Maximum
Segment Size to fit within the link maximum frame size. However, doing
so can add significant header overhead to each 802.15.4 frame and cause
extraneous acknowledgments across the LLN compared to the method in this
specification.[¶](#section-appendix.a-11){.pilcrow}
:::
:::

::: {#req}
::: {#section-appendix.b .section}
## [Appendix B.](#section-appendix.b){.section-number .selfRef} [Requirements](#name-requirements){.section-name .selfRef} {#name-requirements}

For one-hop communications, a number of LLN link layers propose a local
acknowledgment mechanism that is enough to detect and recover the loss
of fragments. In a multi-hop environment, an end-to-end fragment
recovery mechanism might be a good complement to a hop-by-hop Medium
Access Control (MAC) recovery. This document introduces a simple
protocol to recover individual fragments between 6LFF endpoints that may
be multiple hops away.[¶](#section-appendix.b-1){.pilcrow}

The method addresses the following requirements of an
LLN:[¶](#section-appendix.b-2){.pilcrow}

[]{.break}

Number of fragments:
:   The recovery mechanism must support highly fragmented packets, with
    a maximum of 32 fragments per
    packet.[¶](#section-appendix.b-3.2){.pilcrow}
:   

Minimum acknowledgment overhead:
:   Because the radio is half duplex, and because of silent time spent
    in the various medium access mechanisms, an acknowledgment consumes
    roughly as many resources as a data
    fragment.[¶](#section-appendix.b-3.4){.pilcrow}
:   

:   The new end-to-end fragment recovery mechanism should be able to
    acknowledge multiple fragments in a single message and not require
    an acknowledgment at all if fragments are already protected at a
    lower layer.[¶](#section-appendix.b-3.6){.pilcrow}
:   

Controlled latency:
:   The recovery mechanism must succeed or give up within the time
    boundary imposed by the recovery process of the upper-layer
    protocols.[¶](#section-appendix.b-3.8){.pilcrow}
:   

Optional congestion control:
:   The aggregation of multiple concurrent flows may lead to the
    saturation of the radio network and congestion
    collapse.[¶](#section-appendix.b-3.10){.pilcrow}
:   

:   The recovery mechanism should provide means for controlling the
    number of fragments in transit over the
    LLN.[¶](#section-appendix.b-3.12){.pilcrow}
:   
:::
:::

::: {#onECN}
::: {#section-appendix.c .section}
## [Appendix C.](#section-appendix.c){.section-number .selfRef} [Considerations on Congestion Control](#name-considerations-on-congestio){.section-name .selfRef} {#name-considerations-on-congestio}

Considering that a multi-hop LLN can be a very sensitive environment due
to the limited queuing capabilities of a large population of its nodes,
this document recommends a simple and conservative approach to
congestion control, based on TCP congestion
avoidance.[¶](#section-appendix.c-1){.pilcrow}

Congestion on the forward path is assumed in case of packet loss, and
packet loss is assumed upon timeout. This document allows controlling
the number of outstanding fragments that have been transmitted, but for
which an acknowledgment was not yet received, and that are still covered
by the ARQ timer.[¶](#section-appendix.c-2){.pilcrow}

Congestion on the forward path can also be indicated by an ECN
mechanism. Though whether and how ECN \[[RFC3168](#RFC3168){.xref}\] is
carried out over the LoWPAN is out of scope, this document provides a
way for the destination endpoint to echo an ECN indication back to the
fragmenting endpoint in an acknowledgment message as represented in
[Figure 4](#ackfig){.xref} in [Section
5.2](#ackfrag){.xref}.[¶](#section-appendix.c-3){.pilcrow}

While the support of echoing the ECN at the reassembling endpoint is
mandatory, this specification only provides a minimalistic behavior on
the fragmenting endpoint. If an \"E\" flag is received, the window
[SHOULD]{.bcp14} be reduced at least by 1 and at max to 1. Halving the
window for each \"E\" flag received could be a good compromise, but it
needs further experimentation. A very simple implementation may just
reset the window to 1, so the fragments are sent and acknowledged one by
one.[¶](#section-appendix.c-4){.pilcrow}

Note that any action that has been performed upon detection of
congestion only applies for the transmission of one datagram, and the
next datagram starts with the configured Window_Size
again.[¶](#section-appendix.c-5){.pilcrow}

The exact use of the Acknowledgment Request flag and of the window are
left to implementation. An optimistic implementation could send all the
fragments up to Window_Size, setting the Acknowledgment Request \"X\"
flag only on the last fragment; wait for the bitmap, which means a gap
of half a round-trip time; and resend the losses. A pessimistic
implementation could set the \"X\" flag on the first fragment to check
that the path works and open the window only upon receiving the
RFRAG-ACK. It could then set an \"X\" flag again on the second fragment
and use the window as a credit to send up to Window_Size before it is
blocked. In that case, if the RFRAG-ACK comes back before the window
starves, the gating factor is the inter-frame gap. If the RFRAG-ACK does
not arrive in time, the Window_Size is the gating factor, and the
transmission of the datagram is
delayed.[¶](#section-appendix.c-6){.pilcrow}

It must be noted that even though the inter-frame gap can be used as a
flow control or a congestion control measure, it also plays a critical
role in wireless collision avoidance. In particular, when a mesh
operates on the same channel over multiple hops, the forwarding of a
fragment over a certain hop may collide with the forwarding of the next
fragment that is following over a previous hop but that is in the same
interference domain. To prevent this, the fragmenting endpoint is
required to pace individual fragments within a transmit window with an
inter-frame gap. This is needed to ensure that a given fragment is sent
only when the previous fragment has had a chance to progress beyond the
interference domain of this hop. In the case of 6TiSCH
\[[6TiSCH](#I-D.ietf-6tisch-architecture){.xref}\], which operates over
the Time-Slotted Channel Hopping (TSCH) mode of operation of IEEE
802.15.4 \[[RFC7554](#RFC7554){.xref}\], a fragment is forwarded over a
different channel at a different time, and it makes full sense to
transmit the next fragment as soon as the previous fragment has had its
chance to be forwarded at the next
hop.[¶](#section-appendix.c-7){.pilcrow}

Depending on the setting of the Window_Size and the inter-frame gap, how
the window is used, and the number of hops, the Window_Size may or may
not become the gating factor that blocks the transmission. If the sender
uses the Window_Size as a credit:[¶](#section-appendix.c-8){.pilcrow}

-   [a conservative Window_Size of, say, 3 will be the gating factor
    that limits the transmission rate of the sender \-- and causes
    transmission gaps longer than the inter-frame gap \-- as soon as the
    number of hops exceeds 3 in a TSCH network and 5-9 in a single
    frequency mesh. The more hops the more the starving window will add
    to latency of the
    transmission.[¶](#section-appendix.c-9.1){.pilcrow}]{#section-appendix.c-9.1}
-   [The recommendation to align the Window-Size to the round-trip time
    divided by the time per fragment aligns the Window-Size to the time
    it takes to get the RFAG_ACK before the window starves. A
    Window-Size that is higher than that increases the chances of a
    congestion but does not improve the forward throughput. Considering
    that the RFRAG-ACK takes the same path as the fragment with the
    assumption that it travels at roughly the same speed, an inter-frame
    gap that separates fragments by 2 hops leads to a Window_Size that
    is roughly the number of
    hops.[¶](#section-appendix.c-9.2){.pilcrow}]{#section-appendix.c-9.2}
-   [Setting the Window-Size to 32 minimizes the cost of the
    acknowledgment in a constrained network and frees bandwidth for the
    fragments in a half-duplex network. Using it increases the risk of
    congestion if a bottleneck forms, but it optimizes the use of
    resources under normal conditions. When it is used, the only
    protection for the network is the inter-frame gap, which must be
    chosen wisely to prevent the formation of a
    bottleneck.[¶](#section-appendix.c-9.3){.pilcrow}]{#section-appendix.c-9.3}

From the standpoint of a source 6LoWPAN endpoint, an outstanding
fragment is a fragment that was sent but for which no explicit
acknowledgment was yet received. This means that the fragment might be
on the path or received but not yet acknowledged, or the acknowledgment
might be on the path back. It is also possible that either the fragment
or the acknowledgment was lost on the
way.[¶](#section-appendix.c-10){.pilcrow}

From the fragmenting endpoint standpoint, all outstanding fragments
might still be in the network and contribute to its congestion. There is
an assumption, though, that after a certain amount of time, a frame is
either received or lost, so it is not causing congestion anymore. This
amount of time can be estimated based on the round-trip time between the
6LoWPAN endpoints. For the lack of a more adapted technique, the method
detailed in [\"Computing TCP\'s Retransmission Timer\"](#RFC6298){.xref}
\[[RFC6298](#RFC6298){.xref}\] may be used for that
computation.[¶](#section-appendix.c-11){.pilcrow}

This specification provides the necessary tools for the fragmenting
endpoint to take congestion control actions and protect the network, but
it leaves the implementation free to select the action to be taken. The
intention is to use it to build experience and specify more precisely
the congestion control actions in one or more future specifications.
[\"Congestion Control Principles\"](#RFC2914){.xref}
\[[RFC2914](#RFC2914){.xref}\] and [\"Specifying New Congestion Control
Algorithms\"](#RFC5033){.xref} \[[RFC5033](#RFC5033){.xref}\] provide
indications and wisdom that should help through this
process.[¶](#section-appendix.c-12){.pilcrow}

\[[RFC7567](#RFC7567){.xref}\] and \[[RFC5681](#RFC5681){.xref}\]
provide deeper information on why congestion control is needed and how
TCP handles it. Basically, the goal here is to manage the number of
fragments present in the network; this is achieved by reducing the
number of outstanding fragments over a congested path by throttling the
sources.[¶](#section-appendix.c-13){.pilcrow}
:::
:::

::: {#section-appendix.d .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

The author wishes to thank [Michel Veillette]{.contact-name}, [Dario
Tedeschi]{.contact-name}, [Laurent Toutain]{.contact-name}, [Carles
Gomez Montenegro]{.contact-name}, [Thomas Watteyne]{.contact-name}, and
[Michael Richardson]{.contact-name} for their in-depth reviews and
comments. Also, many thanks to [Roman Danyliw]{.contact-name}, [Peter
Yee]{.contact-name}, [Colin Perkins]{.contact-name}, [Tirumaleswar
Reddy.K]{.contact-name}, [Éric Vyncke]{.contact-name}, [Warren
Kumari]{.contact-name}, [Magnus Westerlund]{.contact-name}, [Erik
Nordmark]{.contact-name}, and especially [Benjamin Kaduk]{.contact-name}
and [Mirja Kühlewind]{.contact-name} for their careful reviews and help
during the IETF Last Call and IESG review process. Thanks to [Jonathan
Hui]{.contact-name}, [Jay Werb]{.contact-name}, [Christos
Polyzois]{.contact-name}, [Soumitri Kolavennu]{.contact-name}, [Pat
Kinney]{.contact-name}, [Margaret Wasserman]{.contact-name}, [Richard
Kelsey]{.contact-name}, [Carsten Bormann]{.contact-name}, and [Harry
Courtice]{.contact-name} for their various contributions in the long
process that lead to this document.[¶](#section-appendix.d-1){.pilcrow}
:::

::: {#authors-addresses}
::: {#section-appendix.e .section}
## [Author\'s Address](#name-authors-address){.section-name .selfRef} {#name-authors-address}

::: {.left dir="auto"}
[Pascal Thubert ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Cisco Systems, Inc.]{.org}
:::

::: {.left dir="auto"}
[Building D]{.extended-address}
:::

::: {.left dir="auto"}
[45 Allee des Ormes - BP1200]{.street-address}
:::

::: {.left dir="auto"}
[06254]{.postal-code} [MOUGINS - Sophia Antipolis]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: tel
Phone: [+33 497 23 26 34](tel:+33%20497%2023%2026%2034){.tel}
:::

::: email
Email: <pthubert@cisco.com>
:::
:::
:::
