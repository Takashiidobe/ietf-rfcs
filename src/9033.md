  RFC 9033        6TiSCH MSF        May 2021
  --------------- ----------------- ----------
  Chang, et al.   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9033](https://www.rfc-editor.org/rfc/rfc9033){.eref}

Category:
:   Standards Track

Published:
:   May 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    T. Chang, [Ed.]{.editor}
    :::

    ::: org
    Inria
    :::
    :::

    ::: author
    ::: author-name
    M. Vučinić
    :::

    ::: org
    Inria
    :::
    :::

    ::: author
    ::: author-name
    X. Vilajosana
    :::

    ::: org
    Universitat Oberta de Catalunya
    :::
    :::

    ::: author
    ::: author-name
    S. Duquennoy
    :::

    ::: org
    RISE SICS
    :::
    :::

    ::: author
    ::: author-name
    D. Dujovne
    :::

    ::: org
    Universidad Diego Portales
    :::
    :::
:::

# RFC 9033 {#rfcnum}

# 6TiSCH Minimal Scheduling Function (MSF) {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This specification defines the \"IPv6 over the TSCH mode of IEEE
802.15.4\" (6TiSCH) Minimal Scheduling Function (MSF). This Scheduling
Function describes both the behavior of a node when joining the network
and how the communication schedule is managed in a distributed fashion.
MSF is built upon the 6TiSCH Operation Sublayer Protocol (6P) and the
minimal security framework for 6TiSCH.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9033>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Requirements
        Language](#name-requirements-language){.xref}
        :::

    -   ::: {#section-toc.1-1.1.2.2}
        [1.2](#section-1.2){.xref}.  [Related
        Documents](#name-related-documents){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Interface to the Minimal 6TiSCH
    Configuration](#name-interface-to-the-minimal-6t){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Autonomous
    Cells](#name-autonomous-cells){.xref}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Node Behavior at
    Boot](#name-node-behavior-at-boot){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Start
        State](#name-start-state){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Step 1 - Choosing
        Frequency](#name-step-1-choosing-frequency){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Step 2 - Receiving
        EBs](#name-step-2-receiving-ebs){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Step 3 - Setting up Autonomous
        Cells for the Join
        Process](#name-step-3-setting-up-autonomou){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [Step 4 - Acquiring a RPL
        Rank](#name-step-4-acquiring-a-rpl-rank){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.6}
        [4.6](#section-4.6){.xref}.  [Step 5 - Setting up First Tx
        Negotiated Cells](#name-step-5-setting-up-first-tx-){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.7}
        [4.7](#section-4.7){.xref}.  [Step 6 - Sending EBs and
        DIOs](#name-step-6-sending-ebs-and-dios){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.8}
        [4.8](#section-4.8){.xref}.  [End State](#name-end-state){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Rules for Adding and Deleting
    Cells](#name-rules-for-adding-and-deleti){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Adapting to
        Traffic](#name-adapting-to-traffic){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Switching
        Parent](#name-switching-parent){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Handling Schedule
        Collisions](#name-handling-schedule-collision){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [6P SIGNAL
    Command](#name-6p-signal-command){.xref}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Scheduling Function
    Identifier](#name-scheduling-function-identif){.xref}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Rules for
    CellList](#name-rules-for-celllist){.xref}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [6P Timeout
    Value](#name-6p-timeout-value){.xref}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Rule for Ordering
    Cells](#name-rule-for-ordering-cells){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [Meaning of the Metadata
    Field](#name-meaning-of-the-metadata-fie){.xref}
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [6P Error
    Handling](#name-6p-error-handling){.xref}
    :::

-   ::: {#section-toc.1-1.13}
    [13](#section-13){.xref}. [Schedule Inconsistency
    Handling](#name-schedule-inconsistency-hand){.xref}
    :::

-   ::: {#section-toc.1-1.14}
    [14](#section-14){.xref}. [MSF
    Constants](#name-msf-constants){.xref}
    :::

-   ::: {#section-toc.1-1.15}
    [15](#section-15){.xref}. [MSF
    Statistics](#name-msf-statistics){.xref}
    :::

-   ::: {#section-toc.1-1.16}
    [16](#section-16){.xref}. [Security
    Considerations](#name-security-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.17}
    [17](#section-17){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}

    -   ::: {#section-toc.1-1.17.2.1}
        [17.1](#section-17.1){.xref}.  [MSF Scheduling Function
        Identifiers](#name-msf-scheduling-function-ide){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.18}
    [18](#section-18){.xref}. [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.18.2.1}
        [18.1](#section-18.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.18.2.2}
        [18.2](#section-18.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.19}
    [Appendix A](#section-appendix.a){.xref}.  [Example Implementation
    of the SAX Hash Function](#name-example-implementation-of-t){.xref}
    :::

-   ::: {#section-toc.1-1.20}
    [](#section-appendix.b){.xref}[Contributors](#name-contributors){.xref}
    :::

-   ::: {#section-toc.1-1.21}
    [](#section-appendix.c){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#sec_intro}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The 6TiSCH Minimal Scheduling Function (MSF), defined in this
specification, is a 6TiSCH Scheduling Function (SF). The role of an SF
is entirely defined in \[[RFC8480](#RFC8480){.xref}\]. This
specification complements \[[RFC8480](#RFC8480){.xref}\] by providing
the rules of when to add and delete cells in the communication schedule.
This specification satisfies all the requirements for an SF listed in
[Section
4.2](https://www.rfc-editor.org/rfc/rfc8480#section-4.2){.relref} of
\[[RFC8480](#RFC8480){.xref}\].[¶](#section-1-1){.pilcrow}

MSF builds on top of the following specifications: \"[Minimal IPv6 over
the TSCH Mode of IEEE 802.15.4e (6TiSCH)
Configuration](#RFC8180){.xref}\" \[[RFC8180](#RFC8180){.xref}\],
\"[6TiSCH Operation Sublayer (6top) Protocol (6P)](#RFC8480){.xref}\"
\[[RFC8480](#RFC8480){.xref}\], and \"[Constrained Join Protocol (CoJP)
for 6TiSCH](#RFC9031){.xref}\"
\[[RFC9031](#RFC9031){.xref}\].[¶](#section-1-2){.pilcrow}

MSF defines both the behavior of a node when joining the network, and
how the communication schedule is managed in a distributed fashion. When
a node running MSF boots up, it joins the network by following the six
steps described in [Section 4](#sec_boot){.xref}. The end state of the
join process is that the node is synchronized to the network, has
mutually authenticated with the network, has identified a routing
parent, and has scheduled one negotiated Tx cell (defined in [Section
5.1](#sec_traffic){.xref}) to/from its routing parent. After the join
process, the node can continuously add, delete, and relocate cells as
described in [Section 5](#sec_add_delete){.xref}. It does so for three
reasons: to match the link-layer resources to the traffic, to handle
changing parent, and to handle a schedule
collision.[¶](#section-1-3){.pilcrow}

MSF works closely with the IPv6 Routing Protocol for Low-Power and Lossy
Networks (RPL), specifically the routing parent defined in
\[[RFC6550](#RFC6550){.xref}\]. This specification only describes how
MSF works with the routing parent; this parent is referred to as the
\"selected parent\". The activity of MSF towards the single routing
parent is called a \"MSF session\". Though the performance of MSF is
evaluated only when the \"selected parent\" represents the node\'s
preferred parent, there should be no restrictions to use multiple MSF
sessions, one per parent. The distribution of traffic over multiple
parents is a routing decision that is out of scope for
MSF.[¶](#section-1-4){.pilcrow}

MSF is designed to operate in a wide range of application domains. It is
optimized for applications with regular upstream traffic, from the nodes
to the Destination-Oriented Directed Acyclic Graph (DODAG) root
\[[RFC6550](#RFC6550){.xref}\].[¶](#section-1-5){.pilcrow}

This specification follows the recommended structure of an SF
specification, given in [Appendix
A](https://www.rfc-editor.org/rfc/rfc8480#appendix-A){.relref} of
\[[RFC8480](#RFC8480){.xref}\], with the following
adaptations:[¶](#section-1-6){.pilcrow}

-   [We have reordered some sections, in particular to have the section
    on the node behavior at boot ([Section 4](#sec_boot){.xref}) appear
    early in this
    specification.[¶](#section-1-7.1){.pilcrow}]{#section-1-7.1}
-   [We added sections on the interface to the minimal 6TiSCH
    configuration ([Section 2](#sec_minimal){.xref}), the use of the
    SIGNAL command ([Section 6](#sec_signal){.xref}), the MSF constants
    ([Section 14](#sec_constants){.xref}), and the MSF statistics
    ([Section
    15](#sec_stats){.xref}).[¶](#section-1-7.2){.pilcrow}]{#section-1-7.2}

::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Requirements Language](#name-requirements-language){.section-name .selfRef} {#name-requirements-language}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-1){.pilcrow}
:::

::: {#section-1.2 .section}
### [1.2.](#section-1.2){.section-number .selfRef} [Related Documents](#name-related-documents){.section-name .selfRef} {#name-related-documents}

This specification uses messages and variables defined in IEEE Std
802.15.4-2015 \[[IEEE802154](#IEEE802154){.xref}\]. It is expected that
those resources will remain in the future versions of IEEE Std 802.15.4;
in which case, this specification also applies to those future versions.
In the remainder of the document, we use
\[[IEEE802154](#IEEE802154){.xref}\] to refer to IEEE Std 802.15.4-2015
as well as future versions of IEEE Std 802.15.4 that remain
compatible.[¶](#section-1.2-1){.pilcrow}
:::
:::
:::

::: {#sec_minimal}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Interface to the Minimal 6TiSCH Configuration](#name-interface-to-the-minimal-6t){.section-name .selfRef} {#name-interface-to-the-minimal-6t}

In a Time-Slotted Channel Hopping (TSCH) network, time is sliced up into
time slots. The time slots are grouped as one or multiple slotframes
that repeat over time. The TSCH schedule instructs a node what to do at
each time slot, such as transmit, receive, or sleep
\[[RFC7554](#RFC7554){.xref}\]. For time slots for transmitting or
receiving, a channel is assigned to the time slot. The tuple (slot,
channel) is indicated as a cell of the TSCH schedule. MSF is one of the
policies defining how to manage the TSCH
schedule.[¶](#section-2-1){.pilcrow}

A node implementing MSF [SHOULD]{.bcp14} implement the minimal 6TiSCH
configuration \[[RFC8180](#RFC8180){.xref}\], which defines the
\"minimal cell\", a single shared cell providing minimal connectivity
between the nodes in the network. The MSF implementation provided in
this specification is based on the implementation of the minimal 6TiSCH
configuration. However, an implementor [MAY]{.bcp14} implement MSF based
on other specifications as long as the specification defines a way to
advertise the Enhanced Beacons (EBs) and DODAG Information Objects
(DIOs) among the network.[¶](#section-2-2){.pilcrow}

MSF uses the minimal cell for broadcast frames such as Enhanced Beacons
(EBs) \[[IEEE802154](#IEEE802154){.xref}\] and broadcast DODAG
Information Objects (DIOs) \[[RFC6550](#RFC6550){.xref}\]. Cells
scheduled by MSF are meant to be used only for unicast
frames.[¶](#section-2-3){.pilcrow}

To ensure there is enough bandwidth available on the minimal cell, a
node implementing MSF [SHOULD]{.bcp14} enforce some rules for limiting
the traffic of broadcast frames. For example, the overall broadcast
traffic among the node and its neighbors [SHOULD NOT]{.bcp14} exceed
one-third of the bandwidth of minimal cell. One of the algorithms that
fulfills this requirement is the Trickle timer defined in
\[[RFC6206](#RFC6206){.xref}\], which is applied to DIO messages
\[[RFC6550](#RFC6550){.xref}\]. However, any such algorithm of limiting
the broadcast traffic to meet those rules is implementation-specific and
is out of the scope of MSF.[¶](#section-2-4){.pilcrow}

Three slotframes are used in MSF. MSF schedules autonomous cells at
Slotframe 1 ([Section 3](#sec_autonomous_cells){.xref}) and 6P
negotiated cells at Slotframe 2 ([Section 5](#sec_add_delete){.xref}),
while Slotframe 0 is used for the bootstrap traffic as defined in the
minimal 6TiSCH configuration. The same slotframe length for Slotframe 0,
1, and 2 is [RECOMMENDED]{.bcp14}. Thus it is possible to avoid the
scheduling collision between the autonomous cells and 6P negotiated
cells ([Section 3](#sec_autonomous_cells){.xref}). The default slotframe
length (SLOTFRAME_LENGTH) is [RECOMMENDED]{.bcp14} for Slotframe 0, 1,
and 2, although any value can be advertised in the
EBs.[¶](#section-2-5){.pilcrow}
:::
:::

::: {#sec_autonomous_cells}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Autonomous Cells](#name-autonomous-cells){.section-name .selfRef} {#name-autonomous-cells}

MSF nodes initialize Slotframe 1 with a set of default cells for unicast
communication with their neighbors. These cells are called \"autonomous
cells\", because they are maintained autonomously by each node without
negotiation through 6P. Cells scheduled by 6P Transaction are called
\"negotiated cells\", which are reserved on Slotframe 2. How to schedule
negotiated cells is detailed in [Section 5](#sec_add_delete){.xref}.
There are two types of autonomous cells:[¶](#section-3-1){.pilcrow}

[]{.break}

Autonomous Rx Cell (AutoRxCell):
:   One cell at a \[slotOffset,channelOffset\] computed as a hash of the
    64-bit Extended Unique Identifier (EUI-64) of the node itself
    (detailed next). Its cell options bits are assigned as TX=0, RX=1,
    SHARED=0.[¶](#section-3-2.2){.pilcrow}
:   

Autonomous Tx Cell (AutoTxCell):
:   One cell at a \[slotOffset,channelOffset\] computed as a hash of the
    Layer 2 EUI-64 destination address in the unicast frame to be
    transmitted (detailed in [Section 4.4](#sec_join){.xref}). Its cell
    options bits are assigned as TX=1, RX=0,
    SHARED=1.[¶](#section-3-2.4){.pilcrow}
:   

To compute a \[slotOffset,channelOffset\] from an EUI-64 address, nodes
[MUST]{.bcp14} use the hash function SAX as defined in Section 2 of
\[[SAX-DASFAA](#SAX-DASFAA){.xref}\] with consistent input parameters,
for example, those defined in [Appendix A](#sec_hash_function){.xref}.
The coordinates are computed to distribute the cells across all channel
offsets, and all but the first slot offset of Slotframe 1. The first
time offset is skipped to avoid colliding with the minimal cell in
Slotframe 0. The slot coordinates derived from a given EUI-64 address
are computed as follows:[¶](#section-3-3){.pilcrow}

slotOffset(MAC) = 1 + hash(EUI64, length(Slotframe_1) -
1)[¶](#section-3-4){.pilcrow}

channelOffset(MAC) = hash(EUI64,
NUM_CH_OFFSET)[¶](#section-3-5){.pilcrow}

The second input parameter defines the maximum return value of the hash
function. Other optional parameters defined in SAX determine the
performance of SAX hash function. Those parameters could be broadcast in
an EB frame or preconfigured. For interoperability purposes, [Appendix
A](#sec_hash_function){.xref} provides the reference values of those
parameters.[¶](#section-3-6){.pilcrow}

AutoTxCell is not permanently installed in the schedule but is added or
deleted on demand when there is a frame to be sent. Throughout the
network lifetime, nodes maintain the autonomous cells as
follows:[¶](#section-3-7){.pilcrow}

-   [Add an AutoTxCell to the Layer 2 destination address, which is
    indicated in a frame when there is no 6P negotiated Tx cell in the
    schedule for that frame to
    transmit.[¶](#section-3-8.1){.pilcrow}]{#section-3-8.1}

-   ::: {#section-3-8.2}
    Remove an AutoTxCell when:[¶](#section-3-8.2.1){.pilcrow}

    -   [there is no frame to transmit on that cell,
        or[¶](#section-3-8.2.2.1){.pilcrow}]{#section-3-8.2.2.1}
    -   [there is at least one 6P negotiated Tx cell in the schedule for
        the frames to
        transmit.[¶](#section-3-8.2.2.2){.pilcrow}]{#section-3-8.2.2.2}
    :::

The AutoRxCell [MUST]{.bcp14} always remain scheduled after
synchronization. 6P CLEAR [MUST NOT]{.bcp14} erase any autonomous
cells.[¶](#section-3-9){.pilcrow}

Because of hash collisions, there will be cases that the AutoTxCell and
AutoRxCell are scheduled at the same slot offset and/or channel offset.
In such cases, AutoTxCell always take precedence over AutoRxCell. Notice
AutoTxCell is a shared type cell that applies a back-off mechanism. When
the AutoTxCell and AutoRxCell collide, AutoTxCell takes precedence if
there is a packet to transmit. When in a back-off period, AutoRxCell is
used. In the case of conflict with a negotiated cell, autonomous cells
take precedence over negotiated cells, which is stated in
\[[IEEE802154](#IEEE802154){.xref}\]. However, when the Slotframe 0, 1,
and 2 use the same length value, it is possible for a negotiated cell to
avoid the collision with AutoRxCell. Hence, the same slotframe length
for Slotframe 0, 1, and 2 is
[RECOMMENDED]{.bcp14}.[¶](#section-3-10){.pilcrow}
:::
:::

::: {#sec_boot}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Node Behavior at Boot](#name-node-behavior-at-boot){.section-name .selfRef} {#name-node-behavior-at-boot}

This section details the behavior the node [SHOULD]{.bcp14} follow from
the moment it is switched on until it has successfully joined the
network. Alternative behaviors may be involved, for example, when
alternative security solutions are used for the network. [Section
4.1](#sec_start_state){.xref} details the start state; [Section
4.8](#sec_end_state){.xref} details the end state. The other sections
detail the six steps of the joining process. We use the term \"pledge\"
and \"joined node\", as defined in
\[[RFC9031](#RFC9031){.xref}\].[¶](#section-4-1){.pilcrow}

::: {#sec_start_state}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Start State](#name-start-state){.section-name .selfRef} {#name-start-state}

A node implementing MSF [SHOULD]{.bcp14} implement the Constrained Join
Protocol (CoJP) for 6TiSCH \[[RFC9031](#RFC9031){.xref}\]. As a
corollary, this means that a pledge, before being switched on, may be
preconfigured with the Pre-Shared Key (PSK) for joining, as well as any
other configuration detailed in \[[RFC9031](#RFC9031){.xref}\]. This is
not necessary if the node implements a security solution that is not
based on PSKs, such as
\[[ZEROTOUCH-JOIN](#I-D.ietf-6tisch-dtsecurity-zerotouch-join){.xref}\].[¶](#section-4.1-1){.pilcrow}
:::
:::

::: {#sec_frequency}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Step 1 - Choosing Frequency](#name-step-1-choosing-frequency){.section-name .selfRef} {#name-step-1-choosing-frequency}

When switched on, the pledge randomly chooses a frequency from the
channels through which the network cycles and starts listening for EBs
on that frequency.[¶](#section-4.2-1){.pilcrow}
:::
:::

::: {#sec_ebs}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Step 2 - Receiving EBs](#name-step-2-receiving-ebs){.section-name .selfRef} {#name-step-2-receiving-ebs}

Upon receiving the first EB, the pledge continues listening for
additional EBs to learn:[¶](#section-4.3-1){.pilcrow}

1.  [the number of neighbors N in its vicinity,
    and[¶](#section-4.3-2.1){.pilcrow}]{#section-4.3-2.1}
2.  [which neighbor to choose as a Join Proxy (JP) for the joining
    process.[¶](#section-4.3-2.2){.pilcrow}]{#section-4.3-2.2}

After having received the first EB, a node [MAY]{.bcp14} keep listening
for at most MAX_EB_DELAY seconds or until it has received EBs from
NUM_NEIGHBOURS_TO_WAIT distinct neighbors. This behavior is defined in
\[[RFC8180](#RFC8180){.xref}\].[¶](#section-4.3-3){.pilcrow}

During this step, the pledge only gets synchronized when it has received
enough EB from the network it wishes to join. How to decide whether an
EB originates from a node from the network it wishes to join is
implementation-specific, but [MAY]{.bcp14} involve filtering EBs by the
PANID field it contains, the presence and contents of the Information
Element (IE) defined in \[[RFC9032](#RFC9032){.xref}\], or the key used
to authenticate it.[¶](#section-4.3-4){.pilcrow}

The decision of which neighbor to use as a JP is implementation-specific
and is discussed in
\[[RFC9031](#RFC9031){.xref}\].[¶](#section-4.3-5){.pilcrow}
:::
:::

::: {#sec_join}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Step 3 - Setting up Autonomous Cells for the Join Process](#name-step-3-setting-up-autonomou){.section-name .selfRef} {#name-step-3-setting-up-autonomou}

After having selected a JP, a node generates a Join Request and installs
an AutoTxCell to the JP. The Join Request is then sent by the pledge to
its selected JP over the AutoTxCell. The AutoTxCell is removed by the
pledge when the Join Request is sent out. The JP receives the Join
Request through its AutoRxCell. Then it forwards the Join Request to the
Join Registrar/Coordinator (JRC), possibly over multiple hops, over the
6P negotiated Tx cells. Similarly, the JRC sends the Join Response to
the JP, possibly over multiple hops, over AutoTxCells or the 6P
negotiated Tx cells. When the JP receives the Join Response from the
JRC, it installs an AutoTxCell to the pledge and sends that Join
Response to the pledge over AutoTxCell. The AutoTxCell is removed by the
JP when the Join Response is sent out. The pledge receives the Join
Response from its AutoRxCell, thereby learns the keying material used in
the network, as well as other configuration settings, and becomes a
\"joined node\".[¶](#section-4.4-1){.pilcrow}

When 6LoWPAN Neighbor Discovery (ND) \[[RFC8505](#RFC8505){.xref}\] is
implemented, the unicast packets used by ND are sent on the AutoTxCell.
The specific process how the ND works during the join process is
detailed in \[[RFC9030](#RFC9030){.xref}\].[¶](#section-4.4-2){.pilcrow}
:::
:::

::: {#sec_rank}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [Step 4 - Acquiring a RPL Rank](#name-step-4-acquiring-a-rpl-rank){.section-name .selfRef} {#name-step-4-acquiring-a-rpl-rank}

Per \[[RFC6550](#RFC6550){.xref}\], the joined node receives DIOs,
computes its own Rank, and selects a routing
parent.[¶](#section-4.5-1){.pilcrow}
:::
:::

::: {#sec_negotiated_cells}
::: {#section-4.6 .section}
### [4.6.](#section-4.6){.section-number .selfRef} [Step 5 - Setting up First Tx Negotiated Cells](#name-step-5-setting-up-first-tx-){.section-name .selfRef} {#name-step-5-setting-up-first-tx-}

Once it has selected a routing parent, the joined node [MUST]{.bcp14}
generate a 6P ADD Request and install an AutoTxCell to that parent. The
6P ADD Request is sent out through the AutoTxCell, containing the
following fields:[¶](#section-4.6-1){.pilcrow}

[]{.break}

CellOptions:
:   Set to TX=1, RX=0, SHARED=0.[¶](#section-4.6-2.2){.pilcrow}
:   

NumCells:
:   Set to 1.[¶](#section-4.6-2.4){.pilcrow}
:   

CellList:
:   At least 5 cells, chosen according to [Section
    8](#sec_celllist){.xref}.[¶](#section-4.6-2.6){.pilcrow}
:   

The joined node removes the AutoTxCell to the selected parent when the
6P Request is sent out. That parent receives the 6P ADD Request from its
AutoRxCell. Then it generates a 6P ADD Response and installs an
AutoTxCell to the joined node. When the parent sends out the 6P ADD
Response, it [MUST]{.bcp14} remove that AutoTxCell. The joined node
receives the 6P ADD Response from its AutoRxCell and completes the 6P
Transaction. In the case that the 6P ADD transaction failed, the node
[MUST]{.bcp14} issue another 6P ADD Request and repeat until the Tx cell
is installed to the parent.[¶](#section-4.6-3){.pilcrow}
:::
:::

::: {#sec_eb_dio}
::: {#section-4.7 .section}
### [4.7.](#section-4.7){.section-number .selfRef} [Step 6 - Sending EBs and DIOs](#name-step-6-sending-ebs-and-dios){.section-name .selfRef} {#name-step-6-sending-ebs-and-dios}

The node starts sending EBs and DIOs on the minimal cell, while
following the transmit rules for broadcast frames from [Section
2](#sec_minimal){.xref}.[¶](#section-4.7-1){.pilcrow}
:::
:::

::: {#sec_end_state}
::: {#section-4.8 .section}
### [4.8.](#section-4.8){.section-number .selfRef} [End State](#name-end-state){.section-name .selfRef} {#name-end-state}

At the end state of the joining process, a new
node:[¶](#section-4.8-1){.pilcrow}

-   [is synchronized to the
    network,[¶](#section-4.8-2.1){.pilcrow}]{#section-4.8-2.1}
-   [is using the link-layer keying material it learned through the
    secure joining
    process,[¶](#section-4.8-2.2){.pilcrow}]{#section-4.8-2.2}
-   [has selected one neighbor as its routing
    parent,[¶](#section-4.8-2.3){.pilcrow}]{#section-4.8-2.3}
-   [has one
    AutoRxCell,[¶](#section-4.8-2.4){.pilcrow}]{#section-4.8-2.4}
-   [has one negotiated Tx cell to the selected
    parent,[¶](#section-4.8-2.5){.pilcrow}]{#section-4.8-2.5}
-   [starts to send DIOs, potentially serving as a router for other
    nodes\' traffic,
    and[¶](#section-4.8-2.6){.pilcrow}]{#section-4.8-2.6}
-   [starts to send EBs, potentially serving as a JP for new
    pledges.[¶](#section-4.8-2.7){.pilcrow}]{#section-4.8-2.7}
:::
:::
:::
:::

::: {#sec_add_delete}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Rules for Adding and Deleting Cells](#name-rules-for-adding-and-deleti){.section-name .selfRef} {#name-rules-for-adding-and-deleti}

Once a node has joined the 6TiSCH network, it adds/deletes/relocates
cells with the selected parent for three
reasons:[¶](#section-5-1){.pilcrow}

-   [to match the link-layer resources to the traffic between the node
    and the selected parent ([Section
    5.1](#sec_traffic){.xref}),[¶](#section-5-2.1){.pilcrow}]{#section-5-2.1}
-   [to handle switching the parent ([Section
    5.2](#sec_switching_parent){.xref}),
    or[¶](#section-5-2.2){.pilcrow}]{#section-5-2.2}
-   [to handle a schedule collision ([Section
    5.3](#sec_collision){.xref}).[¶](#section-5-2.3){.pilcrow}]{#section-5-2.3}

These cells are called \"negotiated cells\" as they are scheduled
through 6P and negotiated with the node\'s parent. Without specific
declaration, all cells mentioned in this section are negotiated cells,
and they are installed at Slotframe 2.[¶](#section-5-3){.pilcrow}

::: {#sec_traffic}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Adapting to Traffic](#name-adapting-to-traffic){.section-name .selfRef} {#name-adapting-to-traffic}

A node implementing MSF [MUST]{.bcp14} implement the behavior described
in this section.[¶](#section-5.1-1){.pilcrow}

The goal of MSF is to manage the communication schedule in the 6TiSCH
schedule in a distributed manner. For a node, this translates into
monitoring the current usage of the cells it has to one of its
neighbors, in most cases to the selected
parent.[¶](#section-5.1-2){.pilcrow}

-   [If the node determines that the number of link-layer frames it is
    attempting to exchange with the selected parent per unit of time is
    larger than the capacity offered by the TSCH negotiated cells it has
    scheduled with it, the node issues a 6P ADD command to that parent
    to add cells to the TSCH
    schedule.[¶](#section-5.1-3.1){.pilcrow}]{#section-5.1-3.1}
-   [If the traffic is lower than the capacity, the node issues a 6P
    DELETE command to that parent to delete cells from the TSCH
    schedule.[¶](#section-5.1-3.2){.pilcrow}]{#section-5.1-3.2}

The node [MUST]{.bcp14} maintain two separate pairs of the following
counters for the selected parent: one for the negotiated Tx cells to
that parent and one for the negotiated Rx cells to that
parent.[¶](#section-5.1-4){.pilcrow}

[]{.break}

NumCellsElapsed:
:   Counts the number of negotiated cells that have elapsed since the
    counter was initialized. This counter is initialized at 0. When the
    current cell is declared as a negotiated cell to the selected
    parent, NumCellsElapsed is incremented by exactly 1, regardless of
    whether the cell is used to transmit or receive a
    frame.[¶](#section-5.1-5.2){.pilcrow}
:   

NumCellsUsed:

:   Counts the number of negotiated cells that have been used. This
    counter is initialized at 0. NumCellsUsed is incremented by exactly
    1 when, during a negotiated cell to the selected parent, either of
    the following happens:[¶](#section-5.1-5.4.1){.pilcrow}

    -   [The node sends a frame to the parent. The counter increments
        regardless of whether a link-layer acknowledgment was received
        or
        not.[¶](#section-5.1-5.4.2.1){.pilcrow}]{#section-5.1-5.4.2.1}
    -   [The node receives a valid frame from the parent. The counter
        increments only when a valid frame per
        \[[IEEE802154](#IEEE802154){.xref}\] is received by the node
        from its
        parent.[¶](#section-5.1-5.4.2.2){.pilcrow}]{#section-5.1-5.4.2.2}

:   

The cell option of cells listed in CellList in a 6P Request frame
[SHOULD]{.bcp14} be either (Tx=1, Rx=0) only or (Tx=0, Rx=1) only. Both
NumCellsElapsed and NumCellsUsed counters can be used for both types of
negotiated cells.[¶](#section-5.1-6){.pilcrow}

As there is no negotiated Rx cell installed at initial time, the
AutoRxCell is taken into account as well for downstream traffic
adaptation. In this case:[¶](#section-5.1-7){.pilcrow}

-   [NumCellsElapsed is incremented by exactly 1 when the current cell
    is AutoRxCell.[¶](#section-5.1-8.1){.pilcrow}]{#section-5.1-8.1}
-   [NumCellsUsed is incremented by exactly 1 when the node receives a
    frame from the selected parent on
    AutoRxCell.[¶](#section-5.1-8.2){.pilcrow}]{#section-5.1-8.2}

Implementors [MAY]{.bcp14} choose to create the same counters for each
neighbor and add them as additional statistics in the neighbor
table.[¶](#section-5.1-9){.pilcrow}

The counters are used as follows:[¶](#section-5.1-10){.pilcrow}

1.  [Both NumCellsElapsed and NumCellsUsed are initialized to 0 when the
    node boots.[¶](#section-5.1-11.1){.pilcrow}]{#section-5.1-11.1}

2.  ::: {#section-5.1-11.2}
    ::: {#counter_step2}
    When the value of NumCellsElapsed reaches
    MAX_NUM_CELLS:[¶](#section-5.1-11.2.1){.pilcrow}

    -   [If NumCellsUsed is greater than LIM_NUMCELLSUSED_HIGH, trigger
        6P to add a single cell to the selected
        parent.[¶](#section-5.1-11.2.2.1){.pilcrow}]{#section-5.1-11.2.2.1}
    -   [If NumCellsUsed is less than LIM_NUMCELLSUSED_LOW, trigger 6P
        to remove a single cell to the selected
        parent.[¶](#section-5.1-11.2.2.2){.pilcrow}]{#section-5.1-11.2.2.2}
    -   [Reset both NumCellsElapsed and NumCellsUsed to 0 and restart
        [#2](#counter_step2){.xref}.[¶](#section-5.1-11.2.2.3){.pilcrow}]{#section-5.1-11.2.2.3}
    :::
    :::

The value of MAX_NUM_CELLS is chosen according to the traffic type of
the network. Generally speaking, the larger the value MAX_NUM_CELLS is,
the more accurately the cell usage is calculated. By using a larger
value of MAX_NUM_CELLS, the 6P traffic overhead could be reduced as
well. Meanwhile, the latency won\'t increase much by using a larger
value of MAX_NUM_CELLS for periodic traffic type. For bursty traffic, a
larger value of MAX_NUM_CELLS indeed introduces higher latency. The
latency caused by slight changes of traffic load can be alleviated by
the additional scheduled cells. In this sense, MSF is a Scheduling
Function that trades latency with energy by scheduling more cells than
needed. Setting MAX_NUM_CELLS to a value at least four times the recent
maximum number of cells used in a slotframe is [RECOMMENDED]{.bcp14}.
For example, a two packets/slotframe traffic load results in an average
of four cells scheduled (two cells are used), using at least the value
of double the number of scheduled cells (which is eight) as
MAX_NUM_CELLS gives a good resolution on the cell usage
calculation.[¶](#section-5.1-12){.pilcrow}

In the case that a node has booted or has disappeared from the network,
the cell reserved at the selected parent may be kept in the schedule
forever. A cleanup mechanism [MUST]{.bcp14} be provided to resolve this
issue. The cleanup mechanism is implementation-specific. The goal is to
confirm that those negotiated cells are not used anymore by the
associated neighbors and remove them from the
schedule.[¶](#section-5.1-13){.pilcrow}
:::
:::

::: {#sec_switching_parent}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Switching Parent](#name-switching-parent){.section-name .selfRef} {#name-switching-parent}

A node implementing MSF [SHOULD]{.bcp14} implement the behavior
described in this section.[¶](#section-5.2-1){.pilcrow}

As part of its normal operation, RPL can have a node switch parent. The
procedure for switching from the old parent to the new parent is the
following:[¶](#section-5.2-2){.pilcrow}

1.  [The node counts the number of negotiated cells it has per slotframe
    to the old parent.[¶](#section-5.2-3.1){.pilcrow}]{#section-5.2-3.1}
2.  [The node triggers one or more 6P ADD commands to schedule the same
    number of negotiated cells with same cell options to the new
    parent.[¶](#section-5.2-3.2){.pilcrow}]{#section-5.2-3.2}
3.  [When that successfully completes, the node issues a 6P CLEAR
    command to its old
    parent.[¶](#section-5.2-3.3){.pilcrow}]{#section-5.2-3.3}

The type of negotiated cell that should be installed first depends on
which traffic has the higher priority, upstream or downstream, which is
application-specific and out of scope of
MSF.[¶](#section-5.2-4){.pilcrow}
:::
:::

::: {#sec_collision}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Handling Schedule Collisions](#name-handling-schedule-collision){.section-name .selfRef} {#name-handling-schedule-collision}

A node implementing MSF [SHOULD]{.bcp14} implement the behavior
described in this section. Other algorithms for handling schedule
collisions can be an alternative to the algorithm proposed in this
section.[¶](#section-5.3-1){.pilcrow}

Since scheduling is entirely distributed, there is a nonzero probability
that two pairs of nearby neighbor nodes schedule a negotiated cell at
the same \[slotOffset,channelOffset\] location in the TSCH schedule. In
that case, data exchanged by the two pairs may collide on that cell. We
call this case a \"schedule collision\".[¶](#section-5.3-2){.pilcrow}

The node [MUST]{.bcp14} maintain the following counters for each
negotiated Tx cell to the selected parent:[¶](#section-5.3-3){.pilcrow}

[]{.break}

NumTx:
:   Counts the number of transmission attempts on that cell. Each time
    the node attempts to transmit a frame on that cell, NumTx is
    incremented by exactly 1.[¶](#section-5.3-4.2){.pilcrow}
:   

NumTxAck:
:   Counts the number of successful transmission attempts on that cell.
    Each time the node receives an acknowledgment for a transmission
    attempt, NumTxAck is incremented by exactly
    1.[¶](#section-5.3-4.4){.pilcrow}
:   

Since both NumTx and NumTxAck are initialized to 0, we necessarily have
NumTxAck less than or equal to NumTx. We call Packet Delivery Ratio
(PDR) the ratio NumTxAck/NumTx and represent it as a percentage. A cell
with a PDR equal to 50% means that half of the frames transmitted are
not acknowledged.[¶](#section-5.3-5){.pilcrow}

Each time the node switches parent (or during the join process when the
node selects a parent for the first time), both NumTx and NumTxAck
[MUST]{.bcp14} be reset to 0. They increment over time, as the schedule
is executed, and the node sends frames to that parent. When NumTx
reaches MAX_NUMTX, both NumTx and NumTxAck [MUST]{.bcp14} be divided by
2. MAX_NUMTX needs to be a power of two to avoid division error. For
example, when MAX_NUMTX is set to 256, and NumTx=255 and NumTxAck=127,
the counters become NumTx=128 and NumTxAck=64 if one frame is sent to
the parent with an acknowledgment received. This operation does not
change the value of the PDR but allows the counters to keep
incrementing. The value of MAX_NUMTX is
implementation-specific.[¶](#section-5.3-6){.pilcrow}

The key for detecting a schedule collision is that, if a node has
several cells to the selected parent, all cells should exhibit the same
PDR. A cell that exhibits a PDR significantly lower than the others
indicates that there are collisions on that
cell.[¶](#section-5.3-7){.pilcrow}

Every HOUSEKEEPINGCOLLISION_PERIOD, the node executes the following
steps:[¶](#section-5.3-8){.pilcrow}

1.  [It computes, for each negotiated Tx cell with the parent (not for
    the autonomous cell), that cell\'s
    PDR.[¶](#section-5.3-9.1){.pilcrow}]{#section-5.3-9.1}
2.  [Any cell that hasn\'t yet had NumTx divided by 2 since it was last
    reset is skipped in steps 3 and 4. This avoids triggering cell
    relocation when the values of NumTx and NumTxAck are not
    statistically significant
    yet.[¶](#section-5.3-9.2){.pilcrow}]{#section-5.3-9.2}
3.  [It identifies the cell with the highest
    PDR.[¶](#section-5.3-9.3){.pilcrow}]{#section-5.3-9.3}
4.  [For any other cell, it compares its PDR against that of the cell
    with the highest PDR. If the subtraction difference between the PDR
    of the cell and the highest PDR is larger than RELOCATE_PDRTHRES, it
    triggers the relocation of that cell using a 6P RELOCATE
    command.[¶](#section-5.3-9.4){.pilcrow}]{#section-5.3-9.4}

The RELOCATION for negotiated Rx cells is not supported by
MSF.[¶](#section-5.3-10){.pilcrow}
:::
:::
:::
:::

::: {#sec_signal}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [6P SIGNAL Command](#name-6p-signal-command){.section-name .selfRef} {#name-6p-signal-command}

The 6P SIGNAL command is not used by MSF.[¶](#section-6-1){.pilcrow}
:::
:::

::: {#sec_sfid}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Scheduling Function Identifier](#name-scheduling-function-identif){.section-name .selfRef} {#name-scheduling-function-identif}

The Scheduling Function Identifier (SFID) of MSF is 0. How the value of
0 was chosen is described in [Section
17](#sec_iana){.xref}.[¶](#section-7-1){.pilcrow}
:::
:::

::: {#sec_celllist}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Rules for CellList](#name-rules-for-celllist){.section-name .selfRef} {#name-rules-for-celllist}

MSF uses two-step 6P Transactions exclusively. 6P Transactions are only
initiated by a node towards its parent. As a result, the cells to put in
the CellList of a 6P ADD command, and in the candidate CellList of a
RELOCATE command, are chosen by the node initiating the 6P Transaction.
In both cases, the same rules apply:[¶](#section-8-1){.pilcrow}

-   [The CellList is [RECOMMENDED]{.bcp14} to have five or more
    cells.[¶](#section-8-2.1){.pilcrow}]{#section-8-2.1}
-   [Each cell in the CellList [MUST]{.bcp14} have a different
    slotOffset value.[¶](#section-8-2.2){.pilcrow}]{#section-8-2.2}
-   [For each cell in the CellList, the node [MUST NOT]{.bcp14} have any
    scheduled cell on the same
    slotOffset.[¶](#section-8-2.3){.pilcrow}]{#section-8-2.3}
-   [The slotOffset value of any cell in the CellList [MUST NOT]{.bcp14}
    be the same as the slotOffset of the minimal cell
    (slotOffset=0).[¶](#section-8-2.4){.pilcrow}]{#section-8-2.4}
-   [The slotOffset of a cell in the CellList [SHOULD]{.bcp14} be
    randomly and uniformly chosen among all the slotOffset values that
    satisfy the restrictions
    above.[¶](#section-8-2.5){.pilcrow}]{#section-8-2.5}
-   [The channelOffset of a cell in the CellList [SHOULD]{.bcp14} be
    randomly and uniformly chosen from \[0..numFrequencies\], where
    numFrequencies represents the number of frequencies a node can
    communicate on.[¶](#section-8-2.6){.pilcrow}]{#section-8-2.6}

As a consequence of random cell selection, there is a nonzero chance
that nodes in the vicinity have installed cells with same slotOffset and
channelOffset. An implementer [MAY]{.bcp14} implement a strategy to
monitor the candidate cells before adding them in CellList to avoid
collision. For example, a node [MAY]{.bcp14} maintain a candidate cell
pool for the CellList. The candidate cells in the pool are preconfigured
as Rx cells to promiscuously listen to detect transmissions on those
cells. If transmissions that rely on
\[[IEEE802154](#IEEE802154){.xref}\] are observed on one cell over
multiple iterations of the schedule, that cell is probably used by a
TSCH neighbor. It is moved out from the pool, and a new cell is selected
as a candidate cell. The cells in CellList are picked from the candidate
pool directly when required.[¶](#section-8-3){.pilcrow}
:::
:::

::: {#sec_timeout}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [6P Timeout Value](#name-6p-timeout-value){.section-name .selfRef} {#name-6p-timeout-value}

The timeout value is calculated for the worst case that a 6P response is
received, which means the 6P response is sent out successfully at the
very latest retransmission. And for each retransmission, it backs off
with largest value. Hence the 6P timeout value is calculated as
((2^MAXBE^) - 1) \* MAXRETRIES \* SLOTFRAME_LENGTH,
where:[¶](#section-9-1){.pilcrow}

-   [MAXBE, defined in \[[IEEE802154](#IEEE802154){.xref}\], is the
    maximum backoff exponent
    used.[¶](#section-9-2.1){.pilcrow}]{#section-9-2.1}
-   [MAXRETRIES, defined in \[[IEEE802154](#IEEE802154){.xref}\], is the
    maximum retransmission
    times.[¶](#section-9-2.2){.pilcrow}]{#section-9-2.2}
-   [SLOTFRAME_LENGTH represents the length of
    slotframe.[¶](#section-9-2.3){.pilcrow}]{#section-9-2.3}
:::
:::

::: {#sec_ordering}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Rule for Ordering Cells](#name-rule-for-ordering-cells){.section-name .selfRef} {#name-rule-for-ordering-cells}

Cells are ordered by slotOffset first, channelOffset
second.[¶](#section-10-1){.pilcrow}

The following sequence is correctly ordered (each element represents the
\[slotOffset,channelOffset\] of a cell in the
schedule):[¶](#section-10-2){.pilcrow}

\[1,3\],\[1,4\],\[2,0\],\[5,3\],\[6,0\],\[6,3\],\[7,9\][¶](#section-10-3){.pilcrow}
:::
:::

::: {#sec_metadata}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [Meaning of the Metadata Field](#name-meaning-of-the-metadata-fie){.section-name .selfRef} {#name-meaning-of-the-metadata-fie}

The Metadata field is not used by MSF.[¶](#section-11-1){.pilcrow}
:::
:::

::: {#sec_error}
::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [6P Error Handling](#name-6p-error-handling){.section-name .selfRef} {#name-6p-error-handling}

[Section
6.2.4](https://www.rfc-editor.org/rfc/rfc8480#section-6.2.4){.relref} of
\[[RFC8480](#RFC8480){.xref}\] lists the 6P return codes. [Table
1](#tab_error){.xref} lists the same error codes and the behavior a node
implementing MSF [SHOULD]{.bcp14} follow.[¶](#section-12-1){.pilcrow}

[]{#name-recommended-behavior-for-ea}

::: {#tab_error}
  Code              [RECOMMENDED]{.bcp14} Behavior
  ----------------- --------------------------------
  RC_SUCCESS        nothing
  RC_EOL            nothing
  RC_ERR            quarantine
  RC_RESET          quarantine
  RC_ERR_VERSION    quarantine
  RC_ERR_SFID       quarantine
  RC_ERR_SEQNUM     clear
  RC_ERR_CELLLIST   clear
  RC_ERR_BUSY       waitretry
  RC_ERR_LOCKED     waitretry

  : [Table 1](#table-1){.selfRef}: [Recommended Behavior for Each 6P
  Error Code](#name-recommended-behavior-for-ea){.selfRef}
:::

The meaning of each behavior from [Table 1](#tab_error){.xref}
is:[¶](#section-12-3){.pilcrow}

[]{.break}

nothing:
:   Indicates that this return code is not an error. No error handling
    behavior is triggered.[¶](#section-12-4.2){.pilcrow}
:   

clear:
:   Abort the 6P Transaction. Issue a 6P CLEAR command to that neighbor
    (this command may fail at the link layer). Remove all cells
    scheduled with that neighbor from the local
    schedule.[¶](#section-12-4.4){.pilcrow}
:   

quarantine:
:   Same behavior as for \"clear\". In addition, remove the node from
    the neighbor and routing tables. Place the node\'s identifier in a
    quarantine list for QUARANTINE_DURATION. When in quarantine, drop
    all frames received from that node.[¶](#section-12-4.6){.pilcrow}
:   

waitretry:
:   Abort the 6P Transaction. Wait for a duration randomly and uniformly
    chosen from \[WAIT_DURATION_MIN,WAIT_DURATION_MAX\]. Retry the same
    transaction.[¶](#section-12-4.8){.pilcrow}
:   
:::
:::

::: {#sec_inconsistency}
::: {#section-13 .section}
## [13.](#section-13){.section-number .selfRef} [Schedule Inconsistency Handling](#name-schedule-inconsistency-hand){.section-name .selfRef} {#name-schedule-inconsistency-hand}

The behavior when schedule inconsistency is detected is explained in
[Table 1](#tab_error){.xref}, for 6P return code
RC_ERR_SEQNUM.[¶](#section-13-1){.pilcrow}
:::
:::

::: {#sec_constants}
::: {#section-14 .section}
## [14.](#section-14){.section-number .selfRef} [MSF Constants](#name-msf-constants){.section-name .selfRef} {#name-msf-constants}

[Table 2](#tab_constants){.xref} lists MSF constants and their
[RECOMMENDED]{.bcp14} values.[¶](#section-14-1){.pilcrow}

[]{#name-msf-constants-and-their-rec}

::: {#tab_constants}
  Name                           [RECOMMENDED]{.bcp14} value
  ------------------------------ -----------------------------
  SLOTFRAME_LENGTH               101 slots
  NUM_CH_OFFSET                  16
  MAX_NUM_CELLS                  100
  LIM_NUMCELLSUSED_HIGH          75
  LIM_NUMCELLSUSED_LOW           25
  MAX_NUMTX                      256
  HOUSEKEEPINGCOLLISION_PERIOD   1 min
  RELOCATE_PDRTHRES              50 %
  QUARANTINE_DURATION            5 min
  WAIT_DURATION_MIN              30 s
  WAIT_DURATION_MAX              60 s

  : [Table 2](#table-2){.selfRef}: [MSF Constants and Their
  [RECOMMENDED]{.bcp14}
  Values](#name-msf-constants-and-their-rec){.selfRef}
:::
:::
:::

::: {#sec_stats}
::: {#section-15 .section}
## [15.](#section-15){.section-number .selfRef} [MSF Statistics](#name-msf-statistics){.section-name .selfRef} {#name-msf-statistics}

[Table 3](#tab_stats){.xref} lists MSF statistics and their
[RECOMMENDED]{.bcp14} widths.[¶](#section-15-1){.pilcrow}

[]{#name-msf-statistics-and-their-re}

::: {#tab_stats}
  Name              [RECOMMENDED]{.bcp14} width
  ----------------- -----------------------------
  NumCellsElapsed   1 byte
  NumCellsUsed      1 byte
  NumTx             1 byte
  NumTxAck          1 byte

  : [Table 3](#table-3){.selfRef}: [MSF Statistics and Their
  [RECOMMENDED]{.bcp14}
  Widths](#name-msf-statistics-and-their-re){.selfRef}
:::
:::
:::

::: {#sec_security}
::: {#section-16 .section}
## [16.](#section-16){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

MSF defines a series of \"rules\" for the node to follow. It triggers
several actions that are carried out by the protocols defined in the
following specifications: \"[Minimal IPv6 over the TSCH Mode of IEEE
802.15.4e (6TiSCH) Configuration](#RFC8180){.xref}\"
\[[RFC8180](#RFC8180){.xref}\], \"[6TiSCH Operation Sublayer (6top)
Protocol (6P)](#RFC8480){.xref}\" \[[RFC8480](#RFC8480){.xref}\], and
\"[Constrained Join Protocol (CoJP) for 6TiSCH](#RFC9031){.xref}\"
\[[RFC9031](#RFC9031){.xref}\]. Confidentiality and authentication of
MSF control and data traffic are provided by these specifications whose
security considerations continue to apply to MSF. In particular, MSF
does not define a new protocol or packet
format.[¶](#section-16-1){.pilcrow}

MSF uses autonomous cells for initial bootstrap and the transport of
join traffic. Autonomous cells are computed as a hash of nodes\' EUI-64
addresses. This makes the coordinates of autonomous cell an easy target
for an attacker, as EUI-64 addresses are visible on the wire and are not
encrypted by the link-layer security mechanism. With the coordinates of
autonomous cells available, the attacker can launch a selective jamming
attack against any node\'s AutoRxCell. If the attacker targets a node
acting as a JP, it can prevent pledges from using that JP to join the
network. The pledge detects such a situation through the absence of a
link-layer acknowledgment for its Join Request. As it is expected that
each pledge will have more than one JP available to join the network,
one available countermeasure for the pledge is to pseudorandomly select
a new JP when the link to the previous JP appears bad. Such a strategy
alleviates the issue of the attacker randomly jamming to disturb the
network but does not help in the case the attacker is targeting a
particular pledge. In that case, the attacker can jam the AutoRxCell of
the pledge in order to prevent it from receiving the join response. This
situation should be detected through the absence of a particular node
from the network and handled by the network administrator through
out-of-band means.[¶](#section-16-2){.pilcrow}

MSF adapts to traffic containing packets from the IP layer. It is
possible that the IP packet has a nonzero DSCP (Differentiated Services
Code Point) \[[RFC2474](#RFC2474){.xref}\] value in its IPv6 header. The
decision how to handle that packet belongs to the upper layer and is out
of scope of MSF. As long as the decision is made to hand over to MAC
layer to transmit, MSF will take that packet into account when adapting
to traffic.[¶](#section-16-3){.pilcrow}

Note that nonzero DSCP values may imply that the traffic originated at
unauthenticated pledges (see \[[RFC9031](#RFC9031){.xref}\]). The
implementation at the IPv6 layer [SHOULD]{.bcp14} rate limit this join
traffic before it is passed to the 6top sublayer where MSF can observe
it. If there is no rate limit for join traffic, intermediate nodes in
the 6TiSCH network may be prone to a resource exhaustion attack, with
the attacker injecting unauthenticated traffic from the network edge.
The assumption is that the rate-limiting function is aware of the
available bandwidth in the 6top Layer 3 bundle(s) towards a next hop,
not directly from MSF, but from an interaction with the 6top sublayer
that ultimately manages the bundles under MSF\'s guidance. How this rate
limit is implemented is out of scope of MSF.[¶](#section-16-4){.pilcrow}
:::
:::

::: {#sec_iana}
::: {#section-17 .section}
## [17.](#section-17){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

::: {#sec_iana_sfid}
::: {#section-17.1 .section}
### [17.1.](#section-17.1){.section-number .selfRef} [MSF Scheduling Function Identifiers](#name-msf-scheduling-function-ide){.section-name .selfRef} {#name-msf-scheduling-function-ide}

This document adds the following number to the \"6P Scheduling Function
Identifiers\" subregistry, part of the \"IPv6 Over the TSCH Mode of IEEE
802.15.4 (6TiSCH)\" registry, as defined by
\[[RFC8480](#RFC8480){.xref}\]:[¶](#section-17.1-1){.pilcrow}

[]{#name-new-sfid-in-the-6p-scheduli}

::: {#fig_iana_sfid}
  SFID   Name                                Reference
  ------ ----------------------------------- -----------
  0      Minimal Scheduling Function (MSF)   RFC 9033

  : [Table 4](#table-4){.selfRef}: [New SFID in the \"6P Scheduling
  Function Identifiers\"
  Subregistry](#name-new-sfid-in-the-6p-scheduli){.selfRef}
:::

The SFID was chosen from the range 0-127, which has the registration
procedure of IETF Review or IESG Approval
\[[RFC8126](#RFC8126){.xref}\].[¶](#section-17.1-3){.pilcrow}
:::
:::
:::
:::

::: {#section-18 .section}
## [18.](#section-18){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-18.1 .section}
### [18.1.](#section-18.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[IEEE802154\]
:   [IEEE]{.refAuthor}, [\"IEEE Standard for Low-Rate Wireless
    Networks\"]{.refTitle}, [IEEE Standard 802.15.4-2015]{.seriesInfo},
    [DOI 10.1109/IEEESTD.2016.7460875]{.seriesInfo}, April 2016,
    \<<https://ieeexplore.ieee.org/document/7460875>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC2474\]
:   [Nichols, K.]{.refAuthor}, [Blake, S.]{.refAuthor},
    [Baker, F.]{.refAuthor}, and [D. Black]{.refAuthor}, [\"Definition
    of the Differentiated Services Field (DS Field) in the IPv4 and IPv6
    Headers\"]{.refTitle}, [RFC 2474]{.seriesInfo}, [DOI
    10.17487/RFC2474]{.seriesInfo}, December 1998,
    \<<https://www.rfc-editor.org/info/rfc2474>\>.
:   

\[RFC6550\]
:   [Winter, T., Ed.]{.refAuthor}, [Thubert, P., Ed.]{.refAuthor},
    [Brandt, A.]{.refAuthor}, [Hui, J.]{.refAuthor},
    [Kelsey, R.]{.refAuthor}, [Levis, P.]{.refAuthor},
    [Pister, K.]{.refAuthor}, [Struik, R.]{.refAuthor}, [Vasseur,
    JP.]{.refAuthor}, and [R. Alexander]{.refAuthor}, [\"RPL: IPv6
    Routing Protocol for Low-Power and Lossy Networks\"]{.refTitle},
    [RFC 6550]{.seriesInfo}, [DOI 10.17487/RFC6550]{.seriesInfo}, March
    2012, \<<https://www.rfc-editor.org/info/rfc6550>\>.
:   

\[RFC8126\]
:   [Cotton, M.]{.refAuthor}, [Leiba, B.]{.refAuthor}, and [T.
    Narten]{.refAuthor}, [\"Guidelines for Writing an IANA
    Considerations Section in RFCs\"]{.refTitle}, [BCP 26]{.seriesInfo},
    [RFC 8126]{.seriesInfo}, [DOI 10.17487/RFC8126]{.seriesInfo}, June
    2017, \<<https://www.rfc-editor.org/info/rfc8126>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8180\]
:   [Vilajosana, X., Ed.]{.refAuthor}, [Pister, K.]{.refAuthor}, and [T.
    Watteyne]{.refAuthor}, [\"Minimal IPv6 over the TSCH Mode of IEEE
    802.15.4e (6TiSCH) Configuration\"]{.refTitle}, [BCP
    210]{.seriesInfo}, [RFC 8180]{.seriesInfo}, [DOI
    10.17487/RFC8180]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8180>\>.
:   

\[RFC8480\]
:   [Wang, Q., Ed.]{.refAuthor}, [Vilajosana, X.]{.refAuthor}, and [T.
    Watteyne]{.refAuthor}, [\"6TiSCH Operation Sublayer (6top) Protocol
    (6P)\"]{.refTitle}, [RFC 8480]{.seriesInfo}, [DOI
    10.17487/RFC8480]{.seriesInfo}, November 2018,
    \<<https://www.rfc-editor.org/info/rfc8480>\>.
:   

\[RFC9030\]
:   [Thubert, P., Ed.]{.refAuthor}, [\"An Architecture for IPv6 over the
    Time-Slotted Channel Hopping Mode of IEEE 802.15.4
    (6TiSCH)\"]{.refTitle}, [RFC 9030]{.seriesInfo}, [DOI
    10.17487/RFC9030]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc9030>\>.
:   

\[RFC9031\]
:   [Vučinić, M., Ed.]{.refAuthor}, [Simon, J.]{.refAuthor},
    [Pister, K.]{.refAuthor}, and [M. Richardson]{.refAuthor},
    [\"Constrained Join Protocol (CoJP) for 6TiSCH\"]{.refTitle}, [RFC
    9031]{.seriesInfo}, [DOI 10.17487/RFC9031]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc9031>\>.
:   

\[RFC9032\]
:   [Dujovne, D., Ed.]{.refAuthor} and [M. Richardson]{.refAuthor},
    [\"Encapsulation of 6TiSCH Join and Enrollment Information
    Elements\"]{.refTitle}, [RFC 9032]{.seriesInfo}, [DOI
    10.17487/RFC9032]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc9032>\>.
:   

\[SAX-DASFAA\]
:   [Ramakrishna, M.V.]{.refAuthor} and [J. Zobel]{.refAuthor},
    [\"Performance in Practice of String Hashing
    Functions\"]{.refTitle}, [DASFAA]{.refContent}, [DOI
    10.1142/9789812819536_0023]{.seriesInfo}, 1997,
    \<<https://doi.org/10.1142/9789812819536_0023>\>.
:   
:::

::: {#section-18.2 .section}
### [18.2.](#section-18.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[RFC6206\]
:   [Levis, P.]{.refAuthor}, [Clausen, T.]{.refAuthor},
    [Hui, J.]{.refAuthor}, [Gnawali, O.]{.refAuthor}, and [J.
    Ko]{.refAuthor}, [\"The Trickle Algorithm\"]{.refTitle}, [RFC
    6206]{.seriesInfo}, [DOI 10.17487/RFC6206]{.seriesInfo}, March 2011,
    \<<https://www.rfc-editor.org/info/rfc6206>\>.
:   

\[RFC7554\]
:   [Watteyne, T., Ed.]{.refAuthor}, [Palattella, M.]{.refAuthor}, and
    [L. Grieco]{.refAuthor}, [\"Using IEEE 802.15.4e Time-Slotted
    Channel Hopping (TSCH) in the Internet of Things (IoT): Problem
    Statement\"]{.refTitle}, [RFC 7554]{.seriesInfo}, [DOI
    10.17487/RFC7554]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7554>\>.
:   

\[RFC8505\]
:   [Thubert, P., Ed.]{.refAuthor}, [Nordmark, E.]{.refAuthor},
    [Chakrabarti, S.]{.refAuthor}, and [C. Perkins]{.refAuthor},
    [\"Registration Extensions for IPv6 over Low-Power Wireless Personal
    Area Network (6LoWPAN) Neighbor Discovery\"]{.refTitle}, [RFC
    8505]{.seriesInfo}, [DOI 10.17487/RFC8505]{.seriesInfo}, November
    2018, \<<https://www.rfc-editor.org/info/rfc8505>\>.
:   

\[ZEROTOUCH-JOIN\]
:   [Richardson, M.]{.refAuthor}, [\"6tisch Zero-Touch Secure Join
    protocol\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft,
    draft-ietf-6tisch-dtsecurity-zerotouch-join-04]{.seriesInfo}, 8 July
    2019,
    \<<https://tools.ietf.org/html/draft-ietf-6tisch-dtsecurity-zerotouch-join-04>\>.
:   
:::
:::

::: {#sec_hash_function}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Example Implementation of the SAX Hash Function](#name-example-implementation-of-t){.section-name .selfRef} {#name-example-implementation-of-t}

To support interoperability, this section provides an example
implementation of the SAX hash function
\[[SAX-DASFAA](#SAX-DASFAA){.xref}\]. The input parameters of the
function are:[¶](#section-appendix.a-1){.pilcrow}

-   [T, which is the hashing table
    length.[¶](#section-appendix.a-2.1){.pilcrow}]{#section-appendix.a-2.1}
-   [c, which is the characters of string s, to be
    hashed.[¶](#section-appendix.a-2.2){.pilcrow}]{#section-appendix.a-2.2}

In MSF, the T is replaced by the length of slotframe 1. String s is
replaced by the node EUI-64 address. The characters of the string, c0
through c7, are the eight bytes of the EUI-64
address.[¶](#section-appendix.a-3){.pilcrow}

The SAX hash function requires shift operation, which is defined as
follow:[¶](#section-appendix.a-4){.pilcrow}

-   [L_shift(v,b), which refers to the left shift of variable v by b
    bits[¶](#section-appendix.a-5.1){.pilcrow}]{#section-appendix.a-5.1}
-   [R_shift(v,b), which refers to the right shift of variable v by b
    bits[¶](#section-appendix.a-5.2){.pilcrow}]{#section-appendix.a-5.2}

The steps to calculate the hash value of SAX hash function
are:[¶](#section-appendix.a-6){.pilcrow}

1.  ::: {#section-appendix.a-7.1}
    ::: {#sax_step1}
    Initialize variable h, which is the intermediate hash value, to h0
    and variable i, which is the index of the bytes of the EUI-64
    address, to 0.[¶](#sax_step1){.pilcrow}
    :::
    :::

2.  ::: {#section-appendix.a-7.2}
    ::: {#sax_step2}
    Sum the value of L_shift(h,l_bit), R_shift(h,r_bit), and
    ci.[¶](#sax_step2){.pilcrow}
    :::
    :::

3.  ::: {#section-appendix.a-7.3}
    ::: {#sax_step3}
    Calculate the result of the exclusive OR between the sum value in
    [Step 2](#sax_step2){.xref} and h.[¶](#sax_step3){.pilcrow}
    :::
    :::

4.  ::: {#section-appendix.a-7.4}
    ::: {#sax_step4}
    Modulo the result of [Step 3](#sax_step3){.xref} by
    T.[¶](#sax_step4){.pilcrow}
    :::
    :::

5.  ::: {#section-appendix.a-7.5}
    ::: {#sax_step5}
    Assign the result of [Step 4](#sax_step4){.xref} to
    h.[¶](#sax_step5){.pilcrow}
    :::
    :::

6.  ::: {#section-appendix.a-7.6}
    ::: {#sax_step6}
    Increase i by 1.[¶](#sax_step6){.pilcrow}
    :::
    :::

7.  ::: {#section-appendix.a-7.7}
    ::: {#sax_step7}
    Repeat [Step 2](#sax_step2){.xref} to [Step 6](#sax_step6){.xref}
    until i reaches to 8.[¶](#sax_step7){.pilcrow}
    :::
    :::

The value of variable h is the hash value of the SAX hash
function.[¶](#section-appendix.a-8){.pilcrow}

The values of h0, l_bit, and r_bit in [Step 1](#sax_step1){.xref} and
[Step 2](#sax_step2){.xref} are configured
as:[¶](#section-appendix.a-9){.pilcrow}

h0 = 0[¶](#section-appendix.a-10){.pilcrow}

l_bit = 0[¶](#section-appendix.a-11){.pilcrow}

r_bit = 1[¶](#section-appendix.a-12){.pilcrow}

The appropriate values of l_bit and r_bit could vary depending on the
set of nodes\' EUI-64 address. How to find those values is out of the
scope of this specification.[¶](#section-appendix.a-13){.pilcrow}
:::
:::

::: {#sec_contributors}
::: {#section-appendix.b .section}
## [Contributors](#name-contributors){.section-name .selfRef} {#name-contributors}

::: {.left dir="auto"}
[Beshr Al Nahas]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Chalmers University]{.org}
:::

::: email
Email: <beshr@chalmers.se>
:::

::: {.left dir="auto"}
[Olaf Landsiedel]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Chalmers University]{.org}
:::

::: email
Email: <olafl@chalmers.se>
:::

::: {.left dir="auto"}
[Yasuyuki Tanaka]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Toshiba]{.org}
:::

::: email
Email: <yatch1.tanaka@toshiba.co.jp>
:::
:::
:::

::: {#authors-addresses}
::: {#section-appendix.c .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Tengfei Chang ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Inria]{.org}
:::

::: {.left dir="auto"}
[2 rue Simone Iff]{.street-address}
:::

::: {.left dir="auto"}
[75012]{.postal-code} [Paris]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <tengfei.chang@gmail.com>
:::

::: {.left dir="auto"}
[Mališa Vučinić]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Inria]{.org}
:::

::: {.left dir="auto"}
[2 rue Simone Iff]{.street-address}
:::

::: {.left dir="auto"}
[75012]{.postal-code} [Paris]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <malisa.vucinic@inria.fr>
:::

::: {.left dir="auto"}
[Xavier Vilajosana]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Universitat Oberta de Catalunya]{.org}
:::

::: {.left dir="auto"}
[156 Rambla Poblenou]{.street-address}
:::

::: {.left dir="auto"}
[08018]{.postal-code} [Barcelona]{.locality} [Catalonia]{.region}
:::

::: {.left dir="auto"}
[Spain]{.country-name}
:::

::: email
Email: <xvilajosana@uoc.edu>
:::

::: {.left dir="auto"}
[Simon Duquennoy]{.fn .nameRole}
:::

::: {.left dir="auto"}
[RISE SICS]{.org}
:::

::: {.left dir="auto"}
[Isafjordsgatan 22]{.street-address}
:::

::: {.left dir="auto"}
SE-[164 29]{.postal-code} [Kista]{.locality}
:::

::: {.left dir="auto"}
[Sweden]{.country-name}
:::

::: email
Email: <simon.duquennoy@gmail.com>
:::

::: {.left dir="auto"}
[Diego Dujovne]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Universidad Diego Portales]{.org}
:::

::: {.left dir="auto"}
[Escuela de Informática y Telecomunicaciones\
Av. Ejército 441]{.street-address}
:::

::: {.left dir="auto"}
[Santiago]{.locality}
:::

::: {.left dir="auto"}
[Región Metropolitana]{.region}
:::

::: {.left dir="auto"}
[Chile]{.country-name}
:::

::: tel
Phone: [+56 (2) 676-8121](tel:+56%20(2)%20676-8121){.tel}
:::

::: email
Email: <diego.dujovne@mail.udp.cl>
:::
:::
:::
