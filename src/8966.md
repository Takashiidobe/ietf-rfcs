  RFC 8966                The Babel Routing Protocol   January 2021
  ----------------------- ---------------------------- --------------
  Chroboczek & Schinazi   Standards Track              \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8966](https://www.rfc-editor.org/rfc/rfc8966){.eref}

Obsoletes:
:   [6126](https://www.rfc-editor.org/rfc/rfc6126){.eref},
    [7557](https://www.rfc-editor.org/rfc/rfc7557){.eref}

Category:
:   Standards Track

Published:
:   January 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    J. Chroboczek
    :::

    ::: org
    IRIF, University of Paris-Diderot
    :::
    :::

    ::: author
    ::: author-name
    D. Schinazi
    :::

    ::: org
    Google LLC
    :::
    :::
:::

# RFC 8966 {#rfcnum}

# The Babel Routing Protocol {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

Babel is a loop-avoiding, distance-vector routing protocol that is
robust and efficient both in ordinary wired networks and in wireless
mesh networks. This document describes the Babel routing protocol and
obsoletes RFC 6126 and RFC 7557.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8966>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Features](#name-features){.xref}[¶](#section-toc.1-1.1.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.1.2.2}
        [1.2](#section-1.2){.xref}.  [Limitations](#name-limitations){.xref}[¶](#section-toc.1-1.1.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.1.2.3}
        [1.3](#section-1.3){.xref}.  [Specification of
        Requirements](#name-specification-of-requiremen){.xref}[¶](#section-toc.1-1.1.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Conceptual Description of the
    Protocol](#name-conceptual-description-of-t){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Costs, Metrics, and
        Neighbourship](#name-costs-metrics-and-neighbour){.xref}[¶](#section-toc.1-1.2.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [The Bellman-Ford
        Algorithm](#name-the-bellman-ford-algorithm){.xref}[¶](#section-toc.1-1.2.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.3}
        [2.3](#section-2.3){.xref}.  [Transient Loops in
        Bellman-Ford](#name-transient-loops-in-bellman-){.xref}[¶](#section-toc.1-1.2.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.4}
        [2.4](#section-2.4){.xref}.  [Feasibility
        Conditions](#name-feasibility-conditions){.xref}[¶](#section-toc.1-1.2.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.5}
        [2.5](#section-2.5){.xref}.  [Solving Starvation: Sequencing
        Routes](#name-solving-starvation-sequenci){.xref}[¶](#section-toc.1-1.2.2.5.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.6}
        [2.6](#section-2.6){.xref}.  [Requests](#name-requests){.xref}[¶](#section-toc.1-1.2.2.6.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.7}
        [2.7](#section-2.7){.xref}.  [Multiple
        Routers](#name-multiple-routers){.xref}[¶](#section-toc.1-1.2.2.7.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.8}
        [2.8](#section-2.8){.xref}.  [Overlapping
        Prefixes](#name-overlapping-prefixes){.xref}[¶](#section-toc.1-1.2.2.8.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Protocol
    Operation](#name-protocol-operation){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Message Transmission and
        Reception](#name-message-transmission-and-re){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Data
        Structures](#name-data-structures){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Acknowledgments and Acknowledgment
        Requests](#name-acknowledgments-and-acknowl){.xref}[¶](#section-toc.1-1.3.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [Neighbour
        Acquisition](#name-neighbour-acquisition){.xref}[¶](#section-toc.1-1.3.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.5}
        [3.5](#section-3.5){.xref}.  [Routing Table
        Maintenance](#name-routing-table-maintenance){.xref}[¶](#section-toc.1-1.3.2.5.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.6}
        [3.6](#section-3.6){.xref}.  [Route
        Selection](#name-route-selection){.xref}[¶](#section-toc.1-1.3.2.6.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.7}
        [3.7](#section-3.7){.xref}.  [Sending
        Updates](#name-sending-updates){.xref}[¶](#section-toc.1-1.3.2.7.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.8}
        [3.8](#section-3.8){.xref}.  [Explicit
        Requests](#name-explicit-requests){.xref}[¶](#section-toc.1-1.3.2.8.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Protocol
    Encoding](#name-protocol-encoding){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Data
        Types](#name-data-types){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Packet
        Format](#name-packet-format){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [TLV
        Format](#name-tlv-format){.xref}[¶](#section-toc.1-1.4.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Sub-TLV
        Format](#name-sub-tlv-format){.xref}[¶](#section-toc.1-1.4.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [Parser State and Encoding of
        Updates](#name-parser-state-and-encoding-o){.xref}[¶](#section-toc.1-1.4.2.5.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.6}
        [4.6](#section-4.6){.xref}.  [Details of Specific
        TLVs](#name-details-of-specific-tlvs){.xref}[¶](#section-toc.1-1.4.2.6.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.7}
        [4.7](#section-4.7){.xref}.  [Details of specific
        sub-TLVs](#name-details-of-specific-sub-tlv){.xref}[¶](#section-toc.1-1.4.2.7.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [References](#name-references){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [Appendix A](#section-appendix.a){.xref}.  [Cost and Metric
    Computation](#name-cost-and-metric-computation){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}

    -   ::: {#section-toc.1-1.8.2.1}
        [A.1](#section-a.1){.xref}.  [Maintaining Hello
        History](#name-maintaining-hello-history){.xref}[¶](#section-toc.1-1.8.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [A.2](#section-a.2){.xref}.  [Cost
        Computation](#name-cost-computation-2){.xref}[¶](#section-toc.1-1.8.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [A.3](#section-a.3){.xref}.  [Route Selection and
        Hysteresis](#name-route-selection-and-hystere){.xref}[¶](#section-toc.1-1.8.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [Appendix B](#section-appendix.b){.xref}.  [Protocol
    Parameters](#name-protocol-parameters){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [Appendix C](#section-appendix.c){.xref}.  [Route
    Filtering](#name-route-filtering){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [Appendix D](#section-appendix.d){.xref}.  [Considerations for
    Protocol
    Extensions](#name-considerations-for-protocol){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.12}
    [Appendix E](#section-appendix.e){.xref}.  [Stub
    Implementations](#name-stub-implementations){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.13}
    [Appendix F](#section-appendix.f){.xref}.  [Compatibility with
    Previous
    Versions](#name-compatibility-with-previous){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.14}
    [](#section-appendix.g){.xref}[Acknowledgments](#name-acknowledgments){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.15}
    [](#section-appendix.h){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.15.1){.pilcrow}
    :::
:::
:::

::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Babel is a loop-avoiding distance-vector routing protocol that is
designed to be robust and efficient both in networks using prefix-based
routing and in networks using flat routing (\"mesh networks\"), and both
in relatively stable wired networks and in highly dynamic wireless
networks. This document describes the Babel routing protocol and
obsoletes \[[RFC6126](#RFC6126){.xref}\] and
\[[RFC7557](#RFC7557){.xref}\].[¶](#section-1-1){.pilcrow}

::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Features](#name-features){.section-name .selfRef} {#name-features}

The main property that makes Babel suitable for unstable networks is
that, unlike naive distance-vector routing protocols
\[[RIP](#RFC2453){.xref}\], it strongly limits the frequency and
duration of routing pathologies such as routing loops and black-holes
during reconvergence. Even after a mobility event is detected, a Babel
network usually remains loop-free. Babel then quickly reconverges to a
configuration that preserves the loop-freedom and connectedness of the
network, but is not necessarily optimal; in many cases, this operation
requires no packet exchanges at all. Babel then slowly converges, in a
time on the scale of minutes, to an optimal configuration. This is
achieved by using sequenced routes, a technique pioneered by
Destination-Sequenced Distance-Vector routing
\[[DSDV](#DSDV){.xref}\].[¶](#section-1.1-1){.pilcrow}

More precisely, Babel has the following
properties:[¶](#section-1.1-2){.pilcrow}

-   [when every prefix is originated by at most one router, Babel never
    suffers from routing
    loops;[¶](#section-1.1-3.1){.pilcrow}]{#section-1.1-3.1}
-   [when a single prefix is originated by multiple routers, Babel may
    occasionally create a transient routing loop for this particular
    prefix; this loop disappears in time proportional to the loop\'s
    diameter, and never again (up to an arbitrary garbage-collection
    (GC) time) will the routers involved participate in a routing loop
    for the same
    prefix;[¶](#section-1.1-3.2){.pilcrow}]{#section-1.1-3.2}
-   [assuming bounded packet loss rates, any routing black-holes that
    may appear after a mobility event are corrected in a time at most
    proportional to the network\'s
    diameter.[¶](#section-1.1-3.3){.pilcrow}]{#section-1.1-3.3}

Babel has provisions for link quality estimation and for fairly
arbitrary metrics. When configured suitably, Babel can implement
shortest-path routing, or it may use a metric based, for example, on
measured packet loss.[¶](#section-1.1-4){.pilcrow}

Babel nodes will successfully establish an association even when they
are configured with different parameters. For example, a mobile node
that is low on battery may choose to use larger time constants (hello
and update intervals, etc.) than a node that has access to wall power.
Conversely, a node that detects high levels of mobility may choose to
use smaller time constants. The ability to build such heterogeneous
networks makes Babel particularly adapted to the unmanaged or wireless
environment.[¶](#section-1.1-5){.pilcrow}

Finally, Babel is a hybrid routing protocol, in the sense that it can
carry routes for multiple network-layer protocols (IPv4 and IPv6),
regardless of which protocol the Babel packets are themselves being
carried over.[¶](#section-1.1-6){.pilcrow}
:::

::: {#section-1.2 .section}
### [1.2.](#section-1.2){.section-number .selfRef} [Limitations](#name-limitations){.section-name .selfRef} {#name-limitations}

Babel has two limitations that make it unsuitable for use in some
environments. First, Babel relies on periodic routing table updates
rather than using a reliable transport; hence, in large, stable networks
it generates more traffic than protocols that only send updates when the
network topology changes. In such networks, protocols such as OSPF
\[[OSPF](#RFC2328){.xref}\], IS-IS \[[IS-IS](#IS-IS){.xref}\], or the
Enhanced Interior Gateway Routing Protocol (EIGRP)
\[[EIGRP](#EIGRP){.xref}\] might be more
suitable.[¶](#section-1.2-1){.pilcrow}

Second, unless the second algorithm described in [Section
3.5.4](#hold-time){.xref} is implemented, Babel does impose a hold time
when a prefix is retracted. While this hold time does not apply to the
exact prefix being retracted, and hence does not prevent fast
reconvergence should it become available again, it does apply to any
shorter prefix that covers it. This may make those implementations of
Babel that do not implement the optional algorithm described in [Section
3.5.4](#hold-time){.xref} unsuitable for use in networks that implement
automatic prefix aggregation.[¶](#section-1.2-2){.pilcrow}
:::

::: {#section-1.3 .section}
### [1.3.](#section-1.3){.section-number .selfRef} [Specification of Requirements](#name-specification-of-requiremen){.section-name .selfRef} {#name-specification-of-requiremen}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.3-1){.pilcrow}
:::
:::

::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Conceptual Description of the Protocol](#name-conceptual-description-of-t){.section-name .selfRef} {#name-conceptual-description-of-t}

Babel is a loop-avoiding distance-vector protocol: it is based on the
Bellman-Ford algorithm, just like the venerable RIP
\[[RIP](#RFC2453){.xref}\], but includes a number of refinements that
either prevent loop formation altogether, or ensure that a loop
disappears in a timely manner and doesn\'t form
again.[¶](#section-2-1){.pilcrow}

Conceptually, Bellman-Ford is executed in parallel for every source of
routing information (destination of data traffic). In the following
discussion, we fix a source S; the reader will recall that the same
algorithm is executed for all sources.[¶](#section-2-2){.pilcrow}

::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Costs, Metrics, and Neighbourship](#name-costs-metrics-and-neighbour){.section-name .selfRef} {#name-costs-metrics-and-neighbour}

For every pair of neighbouring nodes A and B, Babel computes an abstract
value known as the cost of the link from A to B, written C(A, B). Given
a route between any two (not necessarily neighbouring) nodes, the metric
of the route is the sum of the costs of all the links along the route.
The goal of the routing algorithm is to compute, for every source S, the
tree of routes of lowest metric to S.[¶](#section-2.1-1){.pilcrow}

Costs and metrics need not be integers. In general, they can be values
in any algebra that satisfies two fairly general conditions ([Section
3.5.2](#metric-computation){.xref}).[¶](#section-2.1-2){.pilcrow}

A Babel node periodically sends Hello messages to all of its neighbours;
it also periodically sends an IHU (\"I Heard You\") message to every
neighbour from which it has recently heard a Hello. From the information
derived from Hello and IHU messages received from its neighbour B, a
node A computes the cost C(A, B) of the link from A to
B.[¶](#section-2.1-3){.pilcrow}
:::

::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [The Bellman-Ford Algorithm](#name-the-bellman-ford-algorithm){.section-name .selfRef} {#name-the-bellman-ford-algorithm}

Every node A maintains two pieces of data: its estimated distance to S,
written D(A), and its next-hop router to S, written NH(A). Initially,
D(S) = 0, D(A) is infinite, and NH(A) is
undefined.[¶](#section-2.2-1){.pilcrow}

Periodically, every node B sends to all of its neighbours a route
update, a message containing D(B). When a neighbour A of B receives the
route update, it checks whether B is its selected next hop; if that is
the case, then NH(A) is set to B, and D(A) is set to C(A, B) + D(B). If
that is not the case, then A compares C(A, B) + D(B) to its current
value of D(A). If that value is smaller, meaning that the received
update advertises a route that is better than the currently selected
route, then NH(A) is set to B, and D(A) is set to C(A, B) +
D(B).[¶](#section-2.2-2){.pilcrow}

A number of refinements to this algorithm are possible, and are used by
Babel. In particular, convergence speed may be increased by sending
unscheduled \"triggered updates\" whenever a major change in the
topology is detected, in addition to the regular, scheduled updates.
Additionally, a node may maintain a number of alternate routes, which
are being advertised by neighbours other than its selected neighbour,
and which can be used immediately if the selected route were to
fail.[¶](#section-2.2-3){.pilcrow}
:::

::: {#section-2.3 .section}
### [2.3.](#section-2.3){.section-number .selfRef} [Transient Loops in Bellman-Ford](#name-transient-loops-in-bellman-){.section-name .selfRef} {#name-transient-loops-in-bellman-}

It is well known that a naive application of Bellman-Ford to distributed
routing can cause transient loops after a topology change. Consider for
example the following topology:[¶](#section-2.3-1){.pilcrow}

::: {#section-2.3-2 .artwork .art-text .alignLeft}
             B
          1 /|
       1   / |
    S --- A  |1
           \ |
          1 \|
             C

[¶](#section-2.3-2){.pilcrow}
:::

After convergence, D(B) = D(C) = 2, with NH(B) = NH(C) =
A.[¶](#section-2.3-3){.pilcrow}

Suppose now that the link between S and A
fails:[¶](#section-2.3-4){.pilcrow}

::: {#section-2.3-5 .artwork .art-text .alignLeft}
             B
          1 /|
           / |
    S     A  |1
           \ |
          1 \|
             C

[¶](#section-2.3-5){.pilcrow}
:::

When it detects the failure of the link, A switches its next hop to B
(which is still advertising a route to S with metric 2), and advertises
a metric equal to 3, and then advertises a new route with metric 3. This
process of nodes changing selected neighbours and increasing their
metric continues until the advertised metric reaches \"infinity\", a
value larger than all the metrics that the routing protocol is able to
carry.[¶](#section-2.3-6){.pilcrow}
:::

::: {#section-2.4 .section}
### [2.4.](#section-2.4){.section-number .selfRef} [Feasibility Conditions](#name-feasibility-conditions){.section-name .selfRef} {#name-feasibility-conditions}

Bellman-Ford is a very robust algorithm: its convergence properties are
preserved when routers delay route acquisition or when they discard some
updates. Babel routers discard received route announcements unless they
can prove that accepting them cannot possibly cause a routing
loop.[¶](#section-2.4-1){.pilcrow}

More formally, we define a condition over route announcements, known as
the \"feasibility condition\", that guarantees the absence of routing
loops whenever all routers ignore route updates that do not satisfy the
feasibility condition. In effect, this makes Bellman-Ford into a family
of routing algorithms, parameterised by the feasibility
condition.[¶](#section-2.4-2){.pilcrow}

Many different feasibility conditions are possible. For example, BGP can
be modelled as being a distance-vector protocol with a (rather drastic)
feasibility condition: a routing update is only accepted when the
receiving node\'s AS number is not included in the update\'s AS_PATH
attribute (note that BGP\'s feasibility condition does not ensure the
absence of transient \"micro-loops\" during
reconvergence).[¶](#section-2.4-3){.pilcrow}

Another simple feasibility condition, used in the Destination-Sequenced
Distance-Vector (DSDV) routing protocol \[[DSDV](#DSDV){.xref}\] and in
the Ad hoc On-Demand Distance Vector (AODV) protocol
\[[RFC3561](#RFC3561){.xref}\], stems from the following observation: a
routing loop can only arise after a router has switched to a route with
a larger metric than the route that it had previously selected. Hence,
one may define that a route is feasible when its metric at the local
node would be no larger than the metric of the currently selected route,
i.e., an announcement carrying a metric D(B) is accepted by A when C(A,
B) + D(B) \<= D(A). If all routers obey this constraint, then the metric
at every router is nonincreasing, and the following invariant is always
preserved: if A has selected B as its next hop, then D(B) \< D(A), which
implies that the forwarding graph is
loop-free.[¶](#section-2.4-4){.pilcrow}

Babel uses a slightly more refined feasibility condition, derived from
EIGRP \[[DUAL](#DUAL){.xref}\]. Given a router A, define the feasibility
distance of A, written FD(A), as the smallest metric that A has ever
advertised for S to any of its neighbours. An update sent by a neighbour
B of A is feasible when the metric D(B) advertised by B is strictly
smaller than A\'s feasibility distance, i.e., when D(B) \<
FD(A).[¶](#section-2.4-5){.pilcrow}

It is easy to see that this latter condition is no more restrictive than
DSDV-feasibility. Suppose that node A obeys DSDV-feasibility; then D(A)
is nonincreasing, hence at all times D(A) \<= FD(A). Suppose now that A
receives a DSDV-feasible update that advertises a metric D(B). Since the
update is DSDV-feasible, C(A, B) + D(B) \<= D(A), hence D(B) \< D(A),
and since D(A) \<= FD(A), D(B) \< FD(A).[¶](#section-2.4-6){.pilcrow}

To see that it is strictly less restrictive, consider the following
diagram, where A has selected the route through B, and D(A) = FD(A) = 2.
Since D(C) = 1 \< FD(A), the alternate route through C is feasible for
A, although its metric C(A, C) + D(C) = 5 is larger than that of the
currently selected route:[¶](#section-2.4-7){.pilcrow}

::: {#section-2.4-8 .artwork .art-text .alignLeft}
       B
    1 / \ 1
     /   \
    S     A
     \   /
    1 \ / 4
       C

[¶](#section-2.4-8){.pilcrow}
:::

To show that this feasibility condition still guarantees loop-freedom,
recall that at the time when A accepts an update from B, the metric D(B)
announced by B is no smaller than FD(B); since it is smaller than FD(A),
at that point in time FD(B) \< FD(A). Since this property is preserved
when A sends updates and also when it picks a different next hop, it
remains true at all times, which ensures that the forwarding graph has
no loops.[¶](#section-2.4-9){.pilcrow}
:::

::: {#section-2.5 .section}
### [2.5.](#section-2.5){.section-number .selfRef} [Solving Starvation: Sequencing Routes](#name-solving-starvation-sequenci){.section-name .selfRef} {#name-solving-starvation-sequenci}

Obviously, the feasibility conditions defined above cause starvation
when a router runs out of feasible routes. Consider the following
diagram, where both A and B have selected the direct route to
S:[¶](#section-2.5-1){.pilcrow}

::: {#section-2.5-2 .artwork .art-text .alignLeft}
       A
    1 /|        D(A) = 1
     / |       FD(A) = 1
    S  |1
     \ |        D(B) = 2
    2 \|       FD(B) = 2
       B

[¶](#section-2.5-2){.pilcrow}
:::

Suppose now that the link between A and S
breaks:[¶](#section-2.5-3){.pilcrow}

::: {#section-2.5-4 .artwork .art-text .alignLeft}
       A
       |
       |       FD(A) = 1
    S  |1
     \ |        D(B) = 2
    2 \|       FD(B) = 2
       B

[¶](#section-2.5-4){.pilcrow}
:::

The only route available from A to S, the one that goes through B, is
not feasible: A suffers from spurious starvation. At that point, the
whole subtree suffering from starvation must be reset, which is
essentially what EIGRP does when it performs a global synchronisation of
all the routers in the starving subtree (the \"active\" phase of
EIGRP).[¶](#section-2.5-5){.pilcrow}

Babel reacts to starvation in a less drastic manner, by using sequenced
routes, a technique introduced by DSDV and adopted by AODV. In addition
to a metric, every route carries a sequence number, a nondecreasing
integer that is propagated unchanged through the network and is only
ever incremented by the source; a pair (s, m), where s is a sequence
number and m a metric, is called a
distance.[¶](#section-2.5-6){.pilcrow}

A received update is feasible when either it is more recent than the
feasibility distance maintained by the receiving node, or it is equally
recent and the metric is strictly smaller. More formally, if FD(A) =
(s, m), then an update carrying the distance (s\', m\') is feasible when
either s\' \> s, or s = s\' and m\' \< m.[¶](#section-2.5-7){.pilcrow}

Assuming the sequence number of S is 137, the diagram above
becomes:[¶](#section-2.5-8){.pilcrow}

::: {#section-2.5-9 .artwork .art-text .alignLeft}
       A
       |
       |       FD(A) = (137, 1)
    S  |1
     \ |        D(B) = (137, 2)
    2 \|       FD(B) = (137, 2)
       B

[¶](#section-2.5-9){.pilcrow}
:::

After S increases its sequence number, and the new sequence number is
propagated to B, we have:[¶](#section-2.5-10){.pilcrow}

::: {#section-2.5-11 .artwork .art-text .alignLeft}
       A
       |
       |       FD(A) = (137, 1)
    S  |1
     \ |        D(B) = (138, 2)
    2 \|       FD(B) = (138, 2)
       B

[¶](#section-2.5-11){.pilcrow}
:::

at which point the route through B becomes feasible
again.[¶](#section-2.5-12){.pilcrow}

Note that while sequence numbers are used for determining feasibility,
they are not used in route selection: a node ignores the sequence number
when selecting the best route to a given destination ([Section
3.6](#route-selection){.xref}). Doing otherwise would cause route
oscillation while a sequence number propagates through the network, and
might even cause persistent black-holes with some exotic
metrics.[¶](#section-2.5-13){.pilcrow}
:::

::: {#section-2.6 .section}
### [2.6.](#section-2.6){.section-number .selfRef} [Requests](#name-requests){.section-name .selfRef} {#name-requests}

In DSDV, the sequence number of a source is increased periodically. A
route becomes feasible again after the source increases its sequence
number, and the new sequence number is propagated through the network,
which may, in general, require a significant amount of
time.[¶](#section-2.6-1){.pilcrow}

Babel takes a different approach. When a node detects that it is
suffering from a potentially spurious starvation, it sends an explicit
request to the source for a new sequence number. This request is
forwarded hop by hop to the source, with no regard to the feasibility
condition. Upon receiving the request, the source increases its sequence
number and broadcasts an update, which is forwarded to the requesting
node.[¶](#section-2.6-2){.pilcrow}

Note that after a change in network topology not all such requests will,
in general, reach the source, as some will be sent over links that are
now broken. However, if the network is still connected, then at least
one among the nodes suffering from spurious starvation has an
(unfeasible) route to the source; hence, in the absence of packet loss,
at least one such request will reach the source. (Resending requests a
small number of times compensates for packet
loss.)[¶](#section-2.6-3){.pilcrow}

Since requests are forwarded with no regard to the feasibility
condition, they may, in general, be caught in a forwarding loop; this is
avoided by having nodes perform duplicate detection for the requests
that they forward.[¶](#section-2.6-4){.pilcrow}
:::

::: {#section-2.7 .section}
### [2.7.](#section-2.7){.section-number .selfRef} [Multiple Routers](#name-multiple-routers){.section-name .selfRef} {#name-multiple-routers}

The above discussion assumes that each prefix is originated by a single
router. In real networks, however, it is often necessary to have a
single prefix originated by multiple routers: for example, the default
route will be originated by all of the edge routers of a routing
domain.[¶](#section-2.7-1){.pilcrow}

Since synchronising sequence numbers between distinct routers is
problematic, Babel treats routes for the same prefix as distinct
entities when they are originated by different routers: every route
announcement carries the router-id of its originating router, and
feasibility distances are not maintained per prefix, but per source,
where a source is a pair of a router-id and a prefix. In effect, Babel
guarantees loop-freedom for the forwarding graph to every source; since
the union of multiple acyclic graphs is not in general acyclic, Babel
does not in general guarantee loop-freedom when a prefix is originated
by multiple routers, but any loops will be broken in a time at most
proportional to the diameter of the loop \-- as soon as an update has
\"gone around\" the routing loop.[¶](#section-2.7-2){.pilcrow}

Consider for example the following topology, where A has selected the
default route through S, and B has selected the one through
S\':[¶](#section-2.7-3){.pilcrow}

::: {#section-2.7-4 .artwork .art-text .alignLeft}
               1     1     1
    ::/0 -- S --- A --- B --- S' -- ::/0

[¶](#section-2.7-4){.pilcrow}
:::

Suppose that both default routes fail at the same time; then nothing
prevents A from switching to B, and B simultaneously switching to A.
However, as soon as A has successfully advertised the new route to B,
the route through A will become unfeasible for B. Conversely, as soon as
B will have advertised the route through A, the route through B will
become unfeasible for A.[¶](#section-2.7-5){.pilcrow}

In effect, the routing loop disappears at the latest when routing
information has gone around the loop. Since this process can be delayed
by lost packets, Babel makes certain efforts to ensure that updates are
sent reliably after a router-id change ([Section
3.7.2](#triggered-updates){.xref}).[¶](#section-2.7-6){.pilcrow}

Additionally, after the routers have advertised the two routes, both
sources will be in their source tables, which will prevent them from
ever again participating in a routing loop involving routes from S and
S\' (up to the source GC time, which, available memory permitting, can
be set to arbitrarily large values).[¶](#section-2.7-7){.pilcrow}
:::

::: {#overlapping-prefixes}
::: {#section-2.8 .section}
### [2.8.](#section-2.8){.section-number .selfRef} [Overlapping Prefixes](#name-overlapping-prefixes){.section-name .selfRef} {#name-overlapping-prefixes}

In the above discussion, we have assumed that all prefixes are disjoint,
as is the case in flat (\"mesh\") routing. In practice, however,
prefixes may overlap: for example, the default route overlaps with all
of the routes present in the network.[¶](#section-2.8-1){.pilcrow}

After a route fails, it is not correct in general to switch to a route
that subsumes the failed route. Consider for example the following
configuration:[¶](#section-2.8-2){.pilcrow}

::: {#section-2.8-3 .artwork .art-text .alignLeft}
               1     1
    ::/0 -- A --- B --- C

[¶](#section-2.8-3){.pilcrow}
:::

Suppose that node C fails. If B forwards packets destined to C by
following the default route, a routing loop will form, and persist until
A learns of B\'s retraction of the direct route to C. B avoids this
pitfall by installing an \"unreachable\" route after a route is
retracted; this route is maintained until it can be guaranteed that the
former route has been retracted by all of B\'s neighbours ([Section
3.5.4](#hold-time){.xref}).[¶](#section-2.8-4){.pilcrow}
:::
:::
:::

::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Protocol Operation](#name-protocol-operation){.section-name .selfRef} {#name-protocol-operation}

Every Babel speaker is assigned a router-id, which is an arbitrary
string of 8 octets that is assumed unique across the routing domain. For
example, router-ids could be assigned randomly, or they could be derived
from a link-layer address. (The protocol encoding is slightly more
compact when router-ids are assigned in the same manner as the IPv6
layer assigns host IDs; see the definition of the \"R\" flag in [Section
4.6.9](#update){.xref}.)[¶](#section-3-1){.pilcrow}

::: {#transmission-reception}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Message Transmission and Reception](#name-message-transmission-and-re){.section-name .selfRef} {#name-message-transmission-and-re}

Babel protocol packets are sent in the body of a UDP datagram (as
described in [Section 4](#protocol-encoding){.xref}). Each Babel packet
consists of zero or more TLVs. Most TLVs may contain
sub-TLVs.[¶](#section-3.1-1){.pilcrow}

Babel\'s control traffic can be carried indifferently over IPv6 or over
IPv4, and prefixes of either address family can be announced over either
protocol. Thus, there are at least two natural deployment models: using
IPv6 exclusively for all control traffic, or running two distinct
protocol instances, one for each address family. The exclusive use of
IPv6 for all control traffic is [RECOMMENDED]{.bcp14}, since using both
protocols at the same time doubles the amount of traffic devoted to
neighbour discovery and link quality
estimation.[¶](#section-3.1-2){.pilcrow}

The source address of a Babel packet is always a unicast address,
link-local in the case of IPv6. Babel packets may be sent to a
well-known (link-local) multicast address or to a (link-local) unicast
address. In normal operation, a Babel speaker sends both multicast and
unicast packets to its neighbours.[¶](#section-3.1-3){.pilcrow}

With the exception of acknowledgments, all Babel TLVs can be sent to
either unicast or multicast addresses, and their semantics does not
depend on whether the destination is a unicast or a multicast address.
Hence, a Babel speaker does not need to determine the destination
address of a packet that it receives in order to interpret
it.[¶](#section-3.1-4){.pilcrow}

A moderate amount of jitter may be applied to packets sent by a Babel
speaker: outgoing TLVs are buffered and [SHOULD]{.bcp14} be sent with a
random delay. This is done for two purposes: it avoids synchronisation
of multiple Babel speakers across a network
\[[JITTER](#JITTER){.xref}\], and it allows for the aggregation of
multiple TLVs into a single packet.[¶](#section-3.1-5){.pilcrow}

The maximum amount of delay a TLV can be subjected to depends on the
TLV. When the protocol description specifies that a TLV is urgent (as in
[Section 3.7.2](#triggered-updates){.xref} and [Section
3.8.1](#handling-requests){.xref}), then the TLV [MUST]{.bcp14} be sent
within a short time known as the urgent timeout (see [Appendix
B](#parameters){.xref} for recommended values). When the TLV is governed
by a timeout explicitly included in a previous TLV, such as in the case
of Acknowledgments ([Section 4.6.4](#ack){.xref}), Updates ([Section
3.7](#sending-updates){.xref}), and IHUs ([Section
3.4.2](#bidirectional-reachability){.xref}), then the TLV [MUST]{.bcp14}
be sent early enough to meet the explicit deadline (with a small margin
to allow for propagation delays). In all other cases, the TLV
[SHOULD]{.bcp14} be sent out within one-half of the Multicast Hello
interval.[¶](#section-3.1-6){.pilcrow}

In order to avoid packet drops (either at the sender or at the
receiver), a delay [SHOULD]{.bcp14} be introduced between successive
packets sent out on the same interface, within the constraints of the
previous paragraph. Note, however, that such packet pacing might impair
the ability of some link layers (e.g., IEEE 802.11
\[[IEEE802.11](#IEEE802.11){.xref}\]) to perform packet
aggregation.[¶](#section-3.1-7){.pilcrow}
:::
:::

::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Data Structures](#name-data-structures){.section-name .selfRef} {#name-data-structures}

In this section, we describe the data structures that every Babel
speaker maintains. This description is conceptual: a Babel speaker may
use different data structures as long as the resulting protocol is the
same as the one described in this document. For example, rather than
maintaining a single table containing both selected and unselected
(fallback) routes, as described in [Section 3.2.6](#route-table){.xref},
an actual implementation would probably use two tables, one with
selected routes and one with fallback
routes.[¶](#section-3.2-1){.pilcrow}

::: {#sequence-number}
::: {#section-3.2.1 .section}
#### [3.2.1.](#section-3.2.1){.section-number .selfRef} [Sequence Number Arithmetic](#name-sequence-number-arithmetic){.section-name .selfRef} {#name-sequence-number-arithmetic}

Sequence numbers (seqnos) appear in a number of Babel data structures,
and they are interpreted as integers modulo 2^16^. For the purposes of
this document, arithmetic on sequence numbers is defined as
follows.[¶](#section-3.2.1-1){.pilcrow}

Given a seqno s and a non-negative integer n, the sum of s and n is
defined by the following:[¶](#section-3.2.1-2){.pilcrow}

s + n (modulo 2^16^) = (s + n) MOD 2^16^[¶](#section-3.2.1-3){.pilcrow}

or, equivalently,[¶](#section-3.2.1-4){.pilcrow}

s + n (modulo 2^16^) = (s + n) AND 65535[¶](#section-3.2.1-5){.pilcrow}

where MOD is the modulo operation yielding a non-negative integer, and
AND is the bitwise conjunction operation.[¶](#section-3.2.1-6){.pilcrow}

Given two sequence numbers s and s\', the relation s is less than s\'
(s \< s\') is defined by the following:[¶](#section-3.2.1-7){.pilcrow}

s \< s\' (modulo 2^16^) when 0 \< ((s\' - s) MOD 2^16^) \<
32768[¶](#section-3.2.1-8){.pilcrow}

or, equivalently,[¶](#section-3.2.1-9){.pilcrow}

s \< s\' (modulo 2^16^) when s /= s\' and ((s\' - s) AND 32768) =
0.[¶](#section-3.2.1-10){.pilcrow}
:::
:::

::: {#section-3.2.2 .section}
#### [3.2.2.](#section-3.2.2){.section-number .selfRef} [Node Sequence Number](#name-node-sequence-number){.section-name .selfRef} {#name-node-sequence-number}

A node\'s sequence number is a 16-bit integer that is included in route
updates sent for routes originated by this
node.[¶](#section-3.2.2-1){.pilcrow}

A node increments its sequence number (modulo 2^16^) whenever it
receives a request for a new sequence number ([Section
3.8.1.2](#handling-seqno-requests){.xref}). A node [SHOULD NOT]{.bcp14}
increment its sequence number (seqno) spontaneously, since increasing
seqnos makes it less likely that other nodes will have feasible
alternate routes when their selected routes
fail.[¶](#section-3.2.2-2){.pilcrow}
:::

::: {#section-3.2.3 .section}
#### [3.2.3.](#section-3.2.3){.section-number .selfRef} [The Interface Table](#name-the-interface-table){.section-name .selfRef} {#name-the-interface-table}

The interface table contains the list of interfaces on which the node
speaks the Babel protocol. Every interface table entry contains the
interface\'s outgoing Multicast Hello seqno, a 16-bit integer that is
sent with each Multicast Hello TLV on this interface and is incremented
(modulo 2^16^) whenever a Multicast Hello is sent. (Note that an
interface\'s Multicast Hello seqno is unrelated to the node\'s
seqno.)[¶](#section-3.2.3-1){.pilcrow}

There are two timers associated with each interface table entry. The
periodic multicast hello timer governs the sending of scheduled
Multicast Hello and IHU packets ([Section
3.4](#neighbour-acquisition){.xref}). The periodic Update timer governs
the sending of periodic route updates ([Section
3.7.1](#periodic-updates){.xref}). See [Appendix B](#parameters){.xref}
for suggested time constants.[¶](#section-3.2.3-2){.pilcrow}
:::

::: {#section-3.2.4 .section}
#### [3.2.4.](#section-3.2.4){.section-number .selfRef} [The Neighbour Table](#name-the-neighbour-table){.section-name .selfRef} {#name-the-neighbour-table}

The neighbour table contains the list of all neighbouring interfaces
from which a Babel packet has been recently received. The neighbour
table is indexed by pairs of the form (interface, address), and every
neighbour table entry contains the following
data:[¶](#section-3.2.4-1){.pilcrow}

-   [the local node\'s interface over which this neighbour is
    reachable;[¶](#section-3.2.4-2.1){.pilcrow}]{#section-3.2.4-2.1}
-   [the address of the neighbouring
    interface;[¶](#section-3.2.4-2.2){.pilcrow}]{#section-3.2.4-2.2}
-   [a history of recently received Multicast Hello packets from this
    neighbour; this can, for example, be a sequence of n bits, for some
    small value n, indicating which of the n hellos most recently sent
    by this neighbour have been received by the local
    node;[¶](#section-3.2.4-2.3){.pilcrow}]{#section-3.2.4-2.3}
-   [a history of recently received Unicast Hello packets from this
    neighbour;[¶](#section-3.2.4-2.4){.pilcrow}]{#section-3.2.4-2.4}
-   [the \"transmission cost\" value from the last IHU packet received
    from this neighbour, or FFFF hexadecimal (infinity) if the IHU hold
    timer for this neighbour has
    expired;[¶](#section-3.2.4-2.5){.pilcrow}]{#section-3.2.4-2.5}
-   [the expected incoming Multicast Hello sequence number for this
    neighbour, an integer modulo
    2^16^.[¶](#section-3.2.4-2.6){.pilcrow}]{#section-3.2.4-2.6}
-   [the expected incoming Unicast Hello sequence number for this
    neighbour, an integer modulo
    2^16^.[¶](#section-3.2.4-2.7){.pilcrow}]{#section-3.2.4-2.7}
-   [the outgoing Unicast Hello sequence number for this neighbour, an
    integer modulo 2^16^ that is sent with each Unicast Hello TLV to
    this neighbour and is incremented (modulo 2^16^) whenever a Unicast
    Hello is sent. (Note that the outgoing Unicast Hello seqno for a
    neighbour is distinct from the interface\'s outgoing Multicast Hello
    seqno.)[¶](#section-3.2.4-2.8){.pilcrow}]{#section-3.2.4-2.8}

There are three timers associated with each neighbour entry \-- the
multicast hello timer, which is set to the interval value carried by
scheduled Multicast Hello TLVs sent by this neighbour, the unicast hello
timer, which is set to the interval value carried by scheduled Unicast
Hello TLVs, and the IHU timer, which is set to a small multiple of the
interval carried in IHU TLVs (see \"IHU Hold time\" in [Appendix
B](#parameters){.xref} for suggested
values).[¶](#section-3.2.4-3){.pilcrow}

Note that the neighbour table is indexed by IP addresses, not by
router-ids: neighbourship is a relationship between interfaces, not
between nodes. Therefore, two nodes with multiple interfaces can
participate in multiple neighbourship relationships, a situation that
can notably arise when wireless nodes with multiple radios are
involved.[¶](#section-3.2.4-4){.pilcrow}
:::

::: {#section-3.2.5 .section}
#### [3.2.5.](#section-3.2.5){.section-number .selfRef} [The Source Table](#name-the-source-table){.section-name .selfRef} {#name-the-source-table}

The source table is used to record feasibility distances. It is indexed
by triples of the form (prefix, plen, router-id), and every source table
entry contains the following data:[¶](#section-3.2.5-1){.pilcrow}

-   [the prefix (prefix, plen), where plen is the prefix length in bits,
    that this entry applies
    to;[¶](#section-3.2.5-2.1){.pilcrow}]{#section-3.2.5-2.1}
-   [the router-id of a router originating this
    prefix;[¶](#section-3.2.5-2.2){.pilcrow}]{#section-3.2.5-2.2}
-   [a pair (seqno, metric), this source\'s feasibility
    distance.[¶](#section-3.2.5-2.3){.pilcrow}]{#section-3.2.5-2.3}

There is one timer associated with each entry in the source table \--
the source garbage-collection timer. It is initialised to a time on the
order of minutes and reset as specified in [Section
3.7.3](#maintaining-fd){.xref}.[¶](#section-3.2.5-3){.pilcrow}
:::

::: {#route-table}
::: {#section-3.2.6 .section}
#### [3.2.6.](#section-3.2.6){.section-number .selfRef} [The Route Table](#name-the-route-table){.section-name .selfRef} {#name-the-route-table}

The route table contains the routes known to this node. It is indexed by
triples of the form (prefix, plen, neighbour), and every route table
entry contains the following data:[¶](#section-3.2.6-1){.pilcrow}

-   [the source (prefix, plen, router-id) for which this route is
    advertised;[¶](#section-3.2.6-2.1){.pilcrow}]{#section-3.2.6-2.1}
-   [the neighbour (an entry in the neighbour table) that advertised
    this route;[¶](#section-3.2.6-2.2){.pilcrow}]{#section-3.2.6-2.2}
-   [the metric with which this route was advertised by the neighbour,
    or FFFF hexadecimal (infinity) for a recently retracted
    route;[¶](#section-3.2.6-2.3){.pilcrow}]{#section-3.2.6-2.3}
-   [the sequence number with which this route was
    advertised;[¶](#section-3.2.6-2.4){.pilcrow}]{#section-3.2.6-2.4}
-   [the next-hop address of this
    route;[¶](#section-3.2.6-2.5){.pilcrow}]{#section-3.2.6-2.5}
-   [a boolean flag indicating whether this route is selected, i.e.,
    whether it is currently being used for forwarding and is being
    advertised.[¶](#section-3.2.6-2.6){.pilcrow}]{#section-3.2.6-2.6}

There is one timer associated with each route table entry \-- the route
expiry timer. It is initialised and reset as specified in [Section
3.5.3](#route-acquisition){.xref}.[¶](#section-3.2.6-3){.pilcrow}

Note that there are two distinct (seqno, metric) pairs associated with
each route: the route\'s distance, which is stored in the route table,
and the feasibility distance, which is stored in the source table and
shared between all routes with the same
source.[¶](#section-3.2.6-4){.pilcrow}
:::
:::

::: {#section-3.2.7 .section}
#### [3.2.7.](#section-3.2.7){.section-number .selfRef} [The Table of Pending Seqno Requests](#name-the-table-of-pending-seqno-){.section-name .selfRef} {#name-the-table-of-pending-seqno-}

The table of pending seqno requests contains a list of seqno requests
that the local node has sent (either because they have been originated
locally, or because they were forwarded) and to which no reply has been
received yet. This table is indexed by triples of the form (prefix,
plen, router-id), and every entry in this table contains the following
data:[¶](#section-3.2.7-1){.pilcrow}

-   [the prefix, plen, router-id, and seqno being
    requested;[¶](#section-3.2.7-2.1){.pilcrow}]{#section-3.2.7-2.1}
-   [the neighbour, if any, on behalf of which we are forwarding this
    request;[¶](#section-3.2.7-2.2){.pilcrow}]{#section-3.2.7-2.2}
-   [a small integer indicating the number of times that this request
    will be resent if it remains
    unsatisfied.[¶](#section-3.2.7-2.3){.pilcrow}]{#section-3.2.7-2.3}

There is one timer associated with each pending seqno request; it
governs both the resending of requests and their
expiry.[¶](#section-3.2.7-3){.pilcrow}
:::
:::

::: {#acknowledgments}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Acknowledgments and Acknowledgment Requests](#name-acknowledgments-and-acknowl){.section-name .selfRef} {#name-acknowledgments-and-acknowl}

A Babel speaker may request that a neighbour receiving a given packet
reply with an explicit acknowledgment within a given time. While the use
of acknowledgment requests is optional, every Babel speaker
[MUST]{.bcp14} be able to reply to such a
request.[¶](#section-3.3-1){.pilcrow}

An acknowledgment [MUST]{.bcp14} be sent to a unicast destination. On
the other hand, acknowledgment requests may be sent to either unicast or
multicast destinations, in which case they request an acknowledgment
from all of the receiving nodes.[¶](#section-3.3-2){.pilcrow}

When to request acknowledgments is a matter of local policy; the
simplest strategy is to never request acknowledgments and to rely on
periodic updates to ensure that any reachable routes are eventually
propagated throughout the routing domain. In order to improve
convergence speed and to reduce the amount of control traffic,
acknowledgment requests [MAY]{.bcp14} be used in order to reliably send
urgent updates ([Section 3.7.2](#triggered-updates){.xref}) and
retractions ([Section 3.5.4](#hold-time){.xref}), especially when the
number of neighbours on a given interface is small. Since Babel is
designed to deal gracefully with packet loss on unreliable media,
sending all packets with acknowledgment requests is not necessary and
[NOT RECOMMENDED]{.bcp14}, as the acknowledgments cause additional
traffic and may force additional Address Resolution Protocol (ARP) or
Neighbour Discovery (ND) exchanges.[¶](#section-3.3-3){.pilcrow}
:::
:::

::: {#neighbour-acquisition}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [Neighbour Acquisition](#name-neighbour-acquisition){.section-name .selfRef} {#name-neighbour-acquisition}

Neighbour acquisition is the process by which a Babel node discovers the
set of neighbours heard over each of its interfaces and ascertains
bidirectional reachability. On unreliable media, neighbour acquisition
additionally provides some statistics that may be useful for link
quality computation.[¶](#section-3.4-1){.pilcrow}

Before it can exchange routing information with a neighbour, a Babel
node [MUST]{.bcp14} create an entry for that neighbour in the neighbour
table. When to do that is implementation-specific; suitable strategies
include creating an entry when any Babel packet is received, or creating
an entry when a Hello TLV is parsed. Similarly, in order to conserve
system resources, an implementation [SHOULD]{.bcp14} discard an entry
when it has been unused for long enough; suitable strategies include
dropping the neighbour after a timeout, and dropping a neighbour when
the associated Hello histories become empty (see [Appendix
A.2](#cost-computation-examples){.xref}).[¶](#section-3.4-2){.pilcrow}

::: {#reverse-reachability}
::: {#section-3.4.1 .section}
#### [3.4.1.](#section-3.4.1){.section-number .selfRef} [Reverse Reachability Detection](#name-reverse-reachability-detect){.section-name .selfRef} {#name-reverse-reachability-detect}

Every Babel node sends Hello TLVs to its neighbours, at regular or
irregular intervals, to indicate that it is alive. Each Hello TLV
carries an increasing (modulo 2^16^) sequence number and an upper bound
on the time interval until the next Hello of the same type (see below).
If the time interval is set to 0, then the Hello TLV does not establish
a new promise: the deadline carried by the previous Hello of the same
type still applies to the next Hello (if the most recent scheduled Hello
of the right kind was received at time t0 and carried interval i, then
the previous promise of sending another Hello before time t0 + i still
holds). We say that a Hello is \"scheduled\" if it carries a nonzero
interval, and \"unscheduled\" otherwise.[¶](#section-3.4.1-1){.pilcrow}

There are two kinds of Hellos: Multicast Hellos, which use a
per-interface Hello counter (the Multicast Hello seqno), and Unicast
Hellos, which use a per-neighbour counter (the Unicast Hello seqno). A
Multicast Hello with a given seqno [MUST]{.bcp14} be sent to all
neighbours on a given interface, either by sending it to a multicast
address or by sending it to one unicast address per neighbour (hence,
the term \"Multicast Hello\" is a slight misnomer). A Unicast Hello
carrying a given seqno should normally be sent to just one neighbour
(over unicast), since the sequence numbers of different neighbours are
not in general synchronised.[¶](#section-3.4.1-2){.pilcrow}

Multicast Hellos sent over multicast can be used for neighbour
discovery; hence, a node [SHOULD]{.bcp14} send periodic (scheduled)
Multicast Hellos unless neighbour discovery is performed by means
outside of the Babel protocol. A node [MAY]{.bcp14} send Unicast Hellos
or unscheduled Hellos of either kind for any reason, such as reducing
the amount of multicast traffic or improving reliability on link
technologies with poor support for link-layer
multicast.[¶](#section-3.4.1-3){.pilcrow}

A node [MAY]{.bcp14} send a scheduled Hello ahead of time. A node
[MAY]{.bcp14} change its scheduled Hello interval. The Hello interval
[MAY]{.bcp14} be decreased at any time; it [MAY]{.bcp14} be increased
immediately before sending a Hello TLV, but [SHOULD NOT]{.bcp14} be
increased at other times. (Equivalently, a node [SHOULD]{.bcp14} send a
scheduled Hello immediately after increasing its Hello
interval.)[¶](#section-3.4.1-4){.pilcrow}

How to deal with received Hello TLVs and what statistics to maintain are
considered local implementation matters; typically, a node will maintain
some sort of history of recently received Hellos. An example of a
suitable algorithm is described in [Appendix
A.1](#hello-history){.xref}.[¶](#section-3.4.1-5){.pilcrow}

After receiving a Hello, or determining that it has missed one, the node
recomputes the association\'s cost ([Section
3.4.3](#cost-computation){.xref}) and runs the route selection procedure
([Section 3.6](#route-selection){.xref}).[¶](#section-3.4.1-6){.pilcrow}
:::
:::

::: {#bidirectional-reachability}
::: {#section-3.4.2 .section}
#### [3.4.2.](#section-3.4.2){.section-number .selfRef} [Bidirectional Reachability Detection](#name-bidirectional-reachability-){.section-name .selfRef} {#name-bidirectional-reachability-}

In order to establish bidirectional reachability, every node sends
periodic IHU (\"I Heard You\") TLVs to each of its neighbours. Since
IHUs carry an explicit interval value, they [MAY]{.bcp14} be sent less
often than Hellos in order to reduce the amount of routing traffic in
dense networks; in particular, they [SHOULD]{.bcp14} be sent less often
than Hellos over links with little packet loss. While IHUs are
conceptually unicast, they [MAY]{.bcp14} be sent to a multicast address
in order to avoid an ARP or Neighbour Discovery exchange and to
aggregate multiple IHUs into a single
packet.[¶](#section-3.4.2-1){.pilcrow}

In addition to the periodic IHUs, a node [MAY]{.bcp14}, at any time,
send an unscheduled IHU packet. It [MAY]{.bcp14} also, at any time,
decrease its IHU interval, and it [MAY]{.bcp14} increase its IHU
interval immediately before sending an IHU, but [SHOULD NOT]{.bcp14}
increase it at any other time. (Equivalently, a node [SHOULD]{.bcp14}
send an extra IHU immediately after increasing its Hello
interval.)[¶](#section-3.4.2-2){.pilcrow}

Every IHU TLV contains two pieces of data: the link\'s rxcost (reception
cost) from the sender\'s perspective, used by the neighbour for
computing link costs ([Section 3.4.3](#cost-computation){.xref}), and
the interval between periodic IHU packets. A node receiving an IHU sets
the value of the txcost (transmission cost) maintained in the neighbour
table to the value contained in the IHU, and resets the IHU timer
associated to this neighbour to a small multiple of the interval value
received in the IHU (see \"IHU Hold time\" in [Appendix
B](#parameters){.xref} for suggested values). When a neighbour\'s IHU
timer expires, the neighbour\'s txcost is set to
infinity.[¶](#section-3.4.2-3){.pilcrow}

After updating a neighbour\'s txcost, the receiving node recomputes the
neighbour\'s cost ([Section 3.4.3](#cost-computation){.xref}) and runs
the route selection procedure ([Section
3.6](#route-selection){.xref}).[¶](#section-3.4.2-4){.pilcrow}
:::
:::

::: {#cost-computation}
::: {#section-3.4.3 .section}
#### [3.4.3.](#section-3.4.3){.section-number .selfRef} [Cost Computation](#name-cost-computation){.section-name .selfRef} {#name-cost-computation}

A neighbourship association\'s link cost is computed from the values
maintained in the neighbour table: the statistics kept in the neighbour
table about the reception of Hellos, and the txcost computed from
received IHU packets.[¶](#section-3.4.3-1){.pilcrow}

For every neighbour, a Babel node computes a value known as this
neighbour\'s rxcost. This value is usually derived from the Hello
history, which may be combined with other data, such as statistics
maintained by the link layer. The rxcost is sent to a neighbour in each
IHU.[¶](#section-3.4.3-2){.pilcrow}

Since nodes do not necessarily send periodic Unicast Hellos but do
usually send periodic Multicast Hellos ([Section
3.4.1](#reverse-reachability){.xref}), a node [SHOULD]{.bcp14} use an
algorithm that yields a finite rxcost when only Multicast Hellos are
received, unless interoperability with nodes that only send Multicast
Hellos is not required.[¶](#section-3.4.3-3){.pilcrow}

How the txcost and rxcost are combined in order to compute a link\'s
cost is a matter of local policy; as far as Babel\'s correctness is
concerned, only the following conditions [MUST]{.bcp14} be
satisfied:[¶](#section-3.4.3-4){.pilcrow}

-   [the cost is strictly
    positive;[¶](#section-3.4.3-5.1){.pilcrow}]{#section-3.4.3-5.1}
-   [if no Hello TLVs of either kind were received recently, then the
    cost is
    infinite;[¶](#section-3.4.3-5.2){.pilcrow}]{#section-3.4.3-5.2}
-   [if the txcost is infinite, then the cost is
    infinite.[¶](#section-3.4.3-5.3){.pilcrow}]{#section-3.4.3-5.3}

See [Appendix A.2](#cost-computation-examples){.xref} for
[RECOMMENDED]{.bcp14} strategies for computing a link\'s
cost.[¶](#section-3.4.3-6){.pilcrow}
:::
:::
:::
:::

::: {#route-maintenance}
::: {#section-3.5 .section}
### [3.5.](#section-3.5){.section-number .selfRef} [Routing Table Maintenance](#name-routing-table-maintenance){.section-name .selfRef} {#name-routing-table-maintenance}

Conceptually, a Babel update is a quintuple (prefix, plen, router-id,
seqno, metric), where (prefix, plen) is the prefix for which a route is
being advertised, router-id is the router-id of the router originating
this update, seqno is a nondecreasing (modulo 2^16^) integer that
carries the originating router seqno, and metric is the announced
metric.[¶](#section-3.5-1){.pilcrow}

Before being accepted, an update is checked against the feasibility
condition ([Section 3.5.1](#feasibility-condition){.xref}), which
ensures that the route does not create a routing loop. If the
feasibility condition is not satisfied, the update is either ignored or
prevents the route from being selected, as described in [Section
3.5.3](#route-acquisition){.xref}. If the feasibility condition is
satisfied, then the update cannot possibly cause a routing
loop.[¶](#section-3.5-2){.pilcrow}

::: {#feasibility-condition}
::: {#section-3.5.1 .section}
#### [3.5.1.](#section-3.5.1){.section-number .selfRef} [The Feasibility Condition](#name-the-feasibility-condition){.section-name .selfRef} {#name-the-feasibility-condition}

The feasibility condition is applied to all received updates. The
feasibility condition compares the metric in the received update with
the metrics of the updates previously sent by the receiving node;
updates that fail the feasibility condition, and therefore have metrics
large enough to cause a routing loop, are either ignored or prevent the
resulting route from being selected.[¶](#section-3.5.1-1){.pilcrow}

A feasibility distance is a pair (seqno, metric), where seqno is an
integer modulo 2^16^ and metric is a positive integer. Feasibility
distances are compared lexicographically, with the first component
inverted: we say that a distance (seqno, metric) is strictly better than
a distance (seqno\', metric\'), written[¶](#section-3.5.1-2){.pilcrow}

(seqno, metric) \< (seqno\', metric\')[¶](#section-3.5.1-3){.pilcrow}

when[¶](#section-3.5.1-4){.pilcrow}

seqno \> seqno\' or (seqno = seqno\' and metric \<
metric\')[¶](#section-3.5.1-5){.pilcrow}

where sequence numbers are compared modulo
2^16^.[¶](#section-3.5.1-6){.pilcrow}

Given a source (prefix, plen, router-id), a node\'s feasibility distance
for this source is the minimum, according to the ordering defined above,
of the distances of all the finite updates ever sent by this particular
node for the prefix (prefix, plen) and the given router-id. Feasibility
distances are maintained in the source table, the exact procedure is
given in [Section
3.7.3](#maintaining-fd){.xref}.[¶](#section-3.5.1-7){.pilcrow}

A received update is feasible when either it is a retraction (its metric
is FFFF hexadecimal), or the advertised distance is strictly better, in
the sense defined above, than the feasibility distance for the
corresponding source. More precisely, a route advertisement carrying the
quintuple (prefix, plen, router-id, seqno, metric) is feasible if one of
the following conditions holds:[¶](#section-3.5.1-8){.pilcrow}

-   [metric is infinite;
    or[¶](#section-3.5.1-9.1){.pilcrow}]{#section-3.5.1-9.1}

-   [no entry exists in the source table indexed by (prefix, plen,
    router-id); or[¶](#section-3.5.1-9.2){.pilcrow}]{#section-3.5.1-9.2}

-   ::: {#section-3.5.1-9.3}
    an entry (prefix, plen, router-id, seqno\', metric\') exists in the
    source table, and either[¶](#section-3.5.1-9.3.1){.pilcrow}

    -   [seqno\' \< seqno
        or[¶](#section-3.5.1-9.3.2.1){.pilcrow}]{#section-3.5.1-9.3.2.1}
    -   [seqno = seqno\' and metric \<
        metric\'.[¶](#section-3.5.1-9.3.2.2){.pilcrow}]{#section-3.5.1-9.3.2.2}
    :::

Note that the feasibility condition considers the metric advertised by
the neighbour, not the route\'s metric; hence, a fluctuation in a
neighbour\'s cost cannot render a selected route unfeasible. Note
further that retractions (updates with infinite metric) are always
feasible, since they cannot possibly cause a routing
loop.[¶](#section-3.5.1-10){.pilcrow}
:::
:::

::: {#metric-computation}
::: {#section-3.5.2 .section}
#### [3.5.2.](#section-3.5.2){.section-number .selfRef} [Metric Computation](#name-metric-computation){.section-name .selfRef} {#name-metric-computation}

A route\'s metric is computed from the metric advertised by the
neighbour and the neighbour\'s link cost. Just like cost computation,
metric computation is considered a local policy matter; as far as Babel
is concerned, the function M(c, m) used for computing a metric from a
locally computed link cost c and the metric m advertised by a neighbour
[MUST]{.bcp14} only satisfy the following
conditions:[¶](#section-3.5.2-1){.pilcrow}

-   [if c is infinite, then M(c, m) is
    infinite;[¶](#section-3.5.2-2.1){.pilcrow}]{#section-3.5.2-2.1}
-   [M is strictly monotonic: M(c, m) \>
    m.[¶](#section-3.5.2-2.2){.pilcrow}]{#section-3.5.2-2.2}

Additionally, the metric [SHOULD]{.bcp14} satisfy the following
condition:[¶](#section-3.5.2-3){.pilcrow}

-   [M is left-distributive: if m \<= m\', then M(c, m) \<= M(c,
    m\').[¶](#section-3.5.2-4.1){.pilcrow}]{#section-3.5.2-4.1}

While strict monotonicity is essential to the integrity of the network
(persistent routing loops may arise if it is not satisfied),
left-distributivity is not: if it is not satisfied, Babel will still
converge to a loop-free configuration, but might not reach a global
optimum (in fact, a global optimum may not even
exist).[¶](#section-3.5.2-5){.pilcrow}

The conditions above are easily satisfied by using the additive metric,
i.e., by defining M(c, m) = c + m. Since the additive metric is useful
with a large range of cost computation strategies, it is the
[RECOMMENDED]{.bcp14} default. See also [Appendix C](#filtering){.xref},
which describes a technique that makes it possible to tweak the values
of individual metrics without running the risk of creating routing
loops.[¶](#section-3.5.2-6){.pilcrow}
:::
:::

::: {#route-acquisition}
::: {#section-3.5.3 .section}
#### [3.5.3.](#section-3.5.3){.section-number .selfRef} [Route Acquisition](#name-route-acquisition){.section-name .selfRef} {#name-route-acquisition}

When a Babel node receives an update (prefix, plen, router-id, seqno,
metric) from a neighbour neigh, it checks whether it already has a route
table entry indexed by (prefix, plen,
neigh).[¶](#section-3.5.3-1){.pilcrow}

If no such entry exists:[¶](#section-3.5.3-2){.pilcrow}

-   [if the update is unfeasible, it [MAY]{.bcp14} be
    ignored;[¶](#section-3.5.3-3.1){.pilcrow}]{#section-3.5.3-3.1}
-   [if the metric is infinite (the update is a retraction of a route we
    do not know about), the update is
    ignored;[¶](#section-3.5.3-3.2){.pilcrow}]{#section-3.5.3-3.2}
-   [otherwise, a new entry is created in the route table, indexed by
    (prefix, plen, neigh), with source equal to (prefix, plen,
    router-id), seqno equal to seqno, and an advertised metric equal to
    the metric carried by the
    update.[¶](#section-3.5.3-3.3){.pilcrow}]{#section-3.5.3-3.3}

If such an entry exists:[¶](#section-3.5.3-4){.pilcrow}

-   [if the entry is currently selected, the update is unfeasible, and
    the router-id of the update is equal to the router-id of the entry,
    then the update [MAY]{.bcp14} be
    ignored;[¶](#section-3.5.3-5.1){.pilcrow}]{#section-3.5.3-5.1}
-   [otherwise, the entry\'s sequence number, advertised metric, metric,
    and router-id are updated, and if the advertised metric is not
    infinite, the route\'s expiry timer is reset to a small multiple of
    the interval value included in the update (see \"Route Expiry time\"
    in [Appendix B](#parameters){.xref} for suggested values). If the
    update is unfeasible, then the (now unfeasible) entry [MUST]{.bcp14}
    be immediately unselected. If the update caused the router-id of the
    entry to change, an update (possibly a retraction) [MUST]{.bcp14} be
    sent in a timely manner as described in [Section
    3.7.2](#triggered-updates){.xref}.[¶](#section-3.5.3-5.2){.pilcrow}]{#section-3.5.3-5.2}

Note that the route table may contain unfeasible routes, either because
they were created by an unfeasible update or due to a metric
fluctuation. Such routes are never selected, since they are not known to
be loop-free. Should all the feasible routes become unusable, however,
the unfeasible routes can be made feasible and therefore possible to
select by sending requests along them (see [Section
3.8.2](#sending-requests){.xref}).[¶](#section-3.5.3-6){.pilcrow}

When a route\'s expiry timer triggers, the behaviour depends on whether
the route\'s metric is finite. If the metric is finite, it is set to
infinity and the expiry timer is reset. If the metric is already
infinite, the route is flushed from the route
table.[¶](#section-3.5.3-7){.pilcrow}

After the route table is updated, the route selection procedure
([Section 3.6](#route-selection){.xref}) is
run.[¶](#section-3.5.3-8){.pilcrow}
:::
:::

::: {#hold-time}
::: {#section-3.5.4 .section}
#### [3.5.4.](#section-3.5.4){.section-number .selfRef} [Hold Time](#name-hold-time){.section-name .selfRef} {#name-hold-time}

When a prefix P is retracted (because all routes are unfeasible or have
an infinite metric, whether due to the expiry timer or for other
reasons), and a shorter prefix P\' that covers P is reachable, P\'
cannot in general be used for routing packets destined to P without
running the risk of creating a routing loop ([Section
2.8](#overlapping-prefixes){.xref}).[¶](#section-3.5.4-1){.pilcrow}

To avoid this issue, whenever a prefix P is retracted, a route table
entry with infinite metric is maintained as described in [Section
3.5.3](#route-acquisition){.xref}. As long as this entry is maintained,
packets destined to an address within P [MUST NOT]{.bcp14} be forwarded
by following a route for a shorter prefix. This entry is removed as soon
as a finite-metric update for prefix P is received and the resulting
route selected. If no such update is forthcoming, the infinite metric
entry [SHOULD]{.bcp14} be maintained at least until it is guaranteed
that no neighbour has selected the current node as next hop for prefix
P. This can be achieved by either:[¶](#section-3.5.4-2){.pilcrow}

-   [waiting until the route\'s expiry timer has expired ([Section
    3.5.3](#route-acquisition){.xref});
    or[¶](#section-3.5.4-3.1){.pilcrow}]{#section-3.5.4-3.1}
-   [sending a retraction with an acknowledgment request ([Section
    3.3](#acknowledgments){.xref}) to every reachable neighbour that has
    not explicitly retracted prefix P, and waiting for all
    acknowledgments.[¶](#section-3.5.4-3.2){.pilcrow}]{#section-3.5.4-3.2}

The former option is simpler and ensures that, at that point, any routes
for prefix P pointing at the current node have expired. However, since
the expiry time can be as high as a few minutes, doing that prevents
automatic aggregation by creating spurious black-holes for aggregated
routes. The latter option is [RECOMMENDED]{.bcp14} as it dramatically
reduces the time for which a prefix is unreachable in the presence of
aggregated routes.[¶](#section-3.5.4-4){.pilcrow}
:::
:::
:::
:::

::: {#route-selection}
::: {#section-3.6 .section}
### [3.6.](#section-3.6){.section-number .selfRef} [Route Selection](#name-route-selection){.section-name .selfRef} {#name-route-selection}

Route selection is the process by which a single route for a given
prefix is selected to be used for forwarding packets and to be
re-advertised to a node\'s neighbours.[¶](#section-3.6-1){.pilcrow}

Babel is designed to allow flexible route selection policies. As far as
the algorithm\'s correctness is concerned, the route selection policy
[MUST]{.bcp14} only satisfy the following
properties:[¶](#section-3.6-2){.pilcrow}

-   [a route with infinite metric (a retracted route) is never
    selected;[¶](#section-3.6-3.1){.pilcrow}]{#section-3.6-3.1}
-   [an unfeasible route is never
    selected.[¶](#section-3.6-3.2){.pilcrow}]{#section-3.6-3.2}

Babel nodes using different route selection strategies will interoperate
and will not create routing loops as long as these two properties
hold.[¶](#section-3.6-4){.pilcrow}

Route selection [MUST NOT]{.bcp14} take seqnos into account: a route
[MUST NOT]{.bcp14} be preferred just because it carries a higher (more
recent) seqno. Doing otherwise would cause route oscillation while a new
seqno propagates across the network, and might create persistent
black-holes if the metric being used is not left-distributive ([Section
3.5.2](#metric-computation){.xref}).[¶](#section-3.6-5){.pilcrow}

The obvious route selection strategy is to pick, for every destination,
the feasible route with minimal metric. When all metrics are stable,
this approach ensures convergence to a tree of shortest paths (assuming
that the metric is left-distributive, see [Section
3.5.2](#metric-computation){.xref}). There are two reasons, however, why
this strategy may lead to instability in the presence of continuously
varying metrics. First, if two parallel routes oscillate around a common
value, then the smallest metric strategy will keep switching between the
two. Second, the selection of a route increases congestion along it,
which might increase packet loss, which in turn could cause its metric
to increase; this kind of feedback loop is prone to causing persistent
oscillations.[¶](#section-3.6-6){.pilcrow}

In order to limit these kinds of instabilities, a route selection
strategy [SHOULD]{.bcp14} include some form of hysteresis, i.e., be
sensitive to a route\'s history: the strategy should only switch from
the currently selected route to a different route if the latter has been
consistently good for some period of time. A [RECOMMENDED]{.bcp14}
hysteresis algorithm is given in [Appendix
A.3](#route-selection-hysteresis){.xref}.[¶](#section-3.6-7){.pilcrow}

After the route selection procedure is run, triggered updates ([Section
3.7.2](#triggered-updates){.xref}) and requests ([Section
3.8.2](#sending-requests){.xref}) are sent.[¶](#section-3.6-8){.pilcrow}
:::
:::

::: {#sending-updates}
::: {#section-3.7 .section}
### [3.7.](#section-3.7){.section-number .selfRef} [Sending Updates](#name-sending-updates){.section-name .selfRef} {#name-sending-updates}

A Babel speaker advertises to its neighbours its set of selected routes.
Normally, this is done by sending one or more multicast packets
containing Update TLVs on all of its connected interfaces; however, on
link technologies where multicast is significantly more expensive than
unicast, a node [MAY]{.bcp14} choose to send multiple copies of updates
in unicast packets, especially when the number of neighbours is
small.[¶](#section-3.7-1){.pilcrow}

Additionally, in order to ensure that any black-holes are reliably
cleared in a timely manner, a Babel node may send retractions (updates
with an infinite metric) for any recently retracted
prefixes.[¶](#section-3.7-2){.pilcrow}

If an update is for a route injected into the Babel domain by the local
node (e.g., it carries the address of a local interface, the prefix of a
directly attached network, or a prefix redistributed from a different
routing protocol), the router-id is set to the local node\'s router-id,
the metric is set to some arbitrary finite value (typically 0), and the
seqno is set to the local router\'s sequence
number.[¶](#section-3.7-3){.pilcrow}

If an update is for a route learnt from another Babel speaker, the
router-id and sequence number are copied from the route table entry, and
the metric is computed as specified in [Section
3.5.2](#metric-computation){.xref}.[¶](#section-3.7-4){.pilcrow}

::: {#periodic-updates}
::: {#section-3.7.1 .section}
#### [3.7.1.](#section-3.7.1){.section-number .selfRef} [Periodic Updates](#name-periodic-updates){.section-name .selfRef} {#name-periodic-updates}

Every Babel speaker [MUST]{.bcp14} advertise each of its selected routes
on every interface, at least once every Update interval. Since Babel
doesn\'t suffer from routing loops (there is no \"counting to
infinity\") and relies heavily on triggered updates ([Section
3.7.2](#triggered-updates){.xref}), this full dump only needs to happen
infrequently (see [Appendix B](#parameters){.xref} for suggested
intervals).[¶](#section-3.7.1-1){.pilcrow}
:::
:::

::: {#triggered-updates}
::: {#section-3.7.2 .section}
#### [3.7.2.](#section-3.7.2){.section-number .selfRef} [Triggered Updates](#name-triggered-updates){.section-name .selfRef} {#name-triggered-updates}

In addition to periodic routing updates, a Babel speaker sends
unscheduled, or triggered, updates in order to inform its neighbours of
a significant change in the network
topology.[¶](#section-3.7.2-1){.pilcrow}

A change of router-id for the selected route to a given prefix may be
indicative of a routing loop in formation; hence, whenever it changes
the selected router-id for a given destination, a node [MUST]{.bcp14}
send an update as an urgent TLV (as defined in [Section
3.1](#transmission-reception){.xref}). Additionally, it [SHOULD]{.bcp14}
make a reasonable attempt at ensuring that all reachable neighbours
receive this update.[¶](#section-3.7.2-2){.pilcrow}

There are two strategies for ensuring that. If the number of neighbours
is small, then it is reasonable to send the update together with an
acknowledgment request; the update is resent until all neighbours have
acknowledged the packet, up to some number of times. If the number of
neighbours is large, however, requesting acknowledgments from all of
them might cause a non-negligible amount of network traffic; in that
case, it may be preferable to simply repeat the update some reasonable
number of times (say, 3 for wireless and 2 for wired links). The number
of copies [MUST NOT]{.bcp14} exceed 5, and the copies [SHOULD]{.bcp14}
be separated by a small delay, as described in [Section
3.1](#transmission-reception){.xref}.[¶](#section-3.7.2-3){.pilcrow}

A route retraction is somewhat less worrying: if the route retraction
doesn\'t reach all neighbours, a black-hole might be created, which,
unlike a routing loop, does not endanger the integrity of the network.
When a route is retracted, a node [SHOULD]{.bcp14} send a triggered
update and [SHOULD]{.bcp14} make a reasonable attempt at ensuring that
all neighbours receive this retraction.[¶](#section-3.7.2-4){.pilcrow}

Finally, a node [MAY]{.bcp14} send a triggered update when the metric
for a given prefix changes in a significant manner, due to a received
update, because a link\'s cost has changed or because a different next
hop has been selected. A node [SHOULD NOT]{.bcp14} send triggered
updates for other reasons, such as when there is a minor fluctuation in
a route\'s metric, when the selected next hop changes without inducing a
significant change to the route\'s metric, or to propagate a new
sequence number (except to satisfy a request, as specified in [Section
3.8](#requests){.xref}).[¶](#section-3.7.2-5){.pilcrow}
:::
:::

::: {#maintaining-fd}
::: {#section-3.7.3 .section}
#### [3.7.3.](#section-3.7.3){.section-number .selfRef} [Maintaining Feasibility Distances](#name-maintaining-feasibility-dis){.section-name .selfRef} {#name-maintaining-feasibility-dis}

Before sending an update (prefix, plen, router-id, seqno, metric) with
finite metric (i.e., not a route retraction), a Babel node updates the
feasibility distance maintained in the source table. This is done as
follows.[¶](#section-3.7.3-1){.pilcrow}

If no entry indexed by (prefix, plen, router-id) exists in the source
table, then one is created with value (prefix, plen, router-id, seqno,
metric).[¶](#section-3.7.3-2){.pilcrow}

If an entry (prefix, plen, router-id, seqno\', metric\') exists, then it
is updated as follows:[¶](#section-3.7.3-3){.pilcrow}

-   [if seqno > seqno\', then seqno\' := seqno, metric\' :=
    metric;[¶](#section-3.7.3-4.1){.pilcrow}]{#section-3.7.3-4.1}
-   [if seqno = seqno\' and metric\' > metric, then metric\' :=
    metric;[¶](#section-3.7.3-4.2){.pilcrow}]{#section-3.7.3-4.2}
-   [otherwise, nothing needs to be
    done.[¶](#section-3.7.3-4.3){.pilcrow}]{#section-3.7.3-4.3}

The garbage-collection timer for the entry is then reset. Note that the
feasibility distance is not updated and the garbage-collection timer is
not reset when a retraction (an update with infinite metric) is
sent.[¶](#section-3.7.3-5){.pilcrow}

When the garbage-collection timer expires, the entry is removed from the
source table.[¶](#section-3.7.3-6){.pilcrow}
:::
:::

::: {#section-3.7.4 .section}
#### [3.7.4.](#section-3.7.4){.section-number .selfRef} [Split Horizon](#name-split-horizon){.section-name .selfRef} {#name-split-horizon}

When running over a transitive, symmetric link technology, e.g., a
point-to-point link or a wired LAN technology such as Ethernet, a Babel
node [SHOULD]{.bcp14} use an optimisation known as split horizon. When
split horizon is used on a given interface, a routing update for prefix
P is not sent on the particular interface over which the selected route
towards prefix P was learnt.[¶](#section-3.7.4-1){.pilcrow}

Split horizon [SHOULD NOT]{.bcp14} be applied to an interface unless the
interface is known to be symmetric and transitive; in particular, split
horizon is not applicable to decentralised wireless link technologies
(e.g., IEEE 802.11 in ad hoc mode) when routing updates are sent over
multicast.[¶](#section-3.7.4-2){.pilcrow}
:::
:::
:::

::: {#requests}
::: {#section-3.8 .section}
### [3.8.](#section-3.8){.section-number .selfRef} [Explicit Requests](#name-explicit-requests){.section-name .selfRef} {#name-explicit-requests}

In normal operation, a node\'s route table is populated by the regular
and triggered updates sent by its neighbours. Under some circumstances,
however, a node sends explicit requests in order to cause a
resynchronisation with the source after a mobility event or to prevent a
route from spuriously expiring.[¶](#section-3.8-1){.pilcrow}

The Babel protocol provides two kinds of explicit requests: route
requests, which simply request an update for a given prefix, and seqno
requests, which request an update for a given prefix with a specific
sequence number. The former are never forwarded; the latter are
forwarded if they cannot be satisfied by the
receiver.[¶](#section-3.8-2){.pilcrow}

::: {#handling-requests}
::: {#section-3.8.1 .section}
#### [3.8.1.](#section-3.8.1){.section-number .selfRef} [Handling Requests](#name-handling-requests){.section-name .selfRef} {#name-handling-requests}

Upon receiving a request, a node either forwards the request or sends an
update in reply to the request, as described in the following sections.
If this causes an update to be sent, the update is either sent to a
multicast address on the interface on which the request was received, or
to the unicast address of the neighbour that sent the
request.[¶](#section-3.8.1-1){.pilcrow}

The exact behaviour is different for route requests and seqno
requests.[¶](#section-3.8.1-2){.pilcrow}

::: {#handling-route-requests}
::: {#section-3.8.1.1 .section}
##### [3.8.1.1.](#section-3.8.1.1){.section-number .selfRef} [Route Requests](#name-route-requests){.section-name .selfRef} {#name-route-requests}

When a node receives a route request for a given prefix, it checks its
route table for a selected route to this exact prefix. If such a route
exists, it [MUST]{.bcp14} send an update (over unicast or over
multicast); if such a route does not exist, it [MUST]{.bcp14} send a
retraction for that prefix.[¶](#section-3.8.1.1-1){.pilcrow}

When a node receives a wildcard route request, it [SHOULD]{.bcp14} send
a full route table dump. Full route dumps [SHOULD]{.bcp14} be
rate-limited, especially if they are sent over
multicast.[¶](#section-3.8.1.1-2){.pilcrow}
:::
:::

::: {#handling-seqno-requests}
::: {#section-3.8.1.2 .section}
##### [3.8.1.2.](#section-3.8.1.2){.section-number .selfRef} [Seqno Requests](#name-seqno-requests){.section-name .selfRef} {#name-seqno-requests}

When a node receives a seqno request for a given router-id and sequence
number, it checks whether its route table contains a selected entry for
that prefix. If a selected route for the given prefix exists and has
finite metric, and either the router-ids are different or the router-ids
are equal and the entry\'s sequence number is no smaller (modulo 2^16^)
than the requested sequence number, the node [MUST]{.bcp14} send an
update for the given prefix. If the router-ids match, but the requested
seqno is larger (modulo 2^16^) than the route entry\'s, the node
compares the router-id against its own router-id. If the router-id is
its own, then it increases its sequence number by 1 (modulo 2^16^) and
sends an update. A node [MUST NOT]{.bcp14} increase its sequence number
by more than 1 in reaction to a single seqno
request.[¶](#section-3.8.1.2-1){.pilcrow}

Otherwise, if the requested router-id is not its own, the received node
consults the Hop Count field of the request. If the hop count is 2 or
more, and the node is advertising the prefix to its neighbours, the node
selects a neighbour to forward the request to as
follows:[¶](#section-3.8.1.2-2){.pilcrow}

-   [if the node has one or more feasible routes towards the requested
    prefix with a next hop that is not the requesting node, then the
    node [MUST]{.bcp14} forward the request to the next hop of one such
    route;[¶](#section-3.8.1.2-3.1){.pilcrow}]{#section-3.8.1.2-3.1}
-   [otherwise, if the node has one or more (not feasible) routes to the
    requested prefix with a next hop that is not the requesting node,
    then the node [SHOULD]{.bcp14} forward the request to the next hop
    of one such
    route.[¶](#section-3.8.1.2-3.2){.pilcrow}]{#section-3.8.1.2-3.2}

In order to actually forward the request, the node decrements the hop
count and sends the request in a unicast packet destined to the selected
neighbour. The forwarded request [SHOULD]{.bcp14} be sent as an urgent
TLV (as defined in [Section
3.1](#transmission-reception){.xref}).[¶](#section-3.8.1.2-4){.pilcrow}

A node [SHOULD]{.bcp14} maintain a list of recently forwarded seqno
requests and forward the reply (an update with a seqno sufficiently
large to satisfy the request) as an urgent TLV (as defined in [Section
3.1](#transmission-reception){.xref}). A node [SHOULD]{.bcp14} compare
every incoming seqno request against its list of recently forwarded
seqno requests and avoid forwarding the request if it is redundant
(i.e., if the node has recently sent a request with the same prefix,
router-id, and a seqno that is not smaller modulo
2^16^).[¶](#section-3.8.1.2-5){.pilcrow}

Since the request-forwarding mechanism does not necessarily obey the
feasibility condition, it may get caught in routing loops; hence,
requests carry a hop count to limit the time during which they remain in
the network. However, since requests are only ever forwarded as unicast
packets, the initial hop count need not be kept particularly low, and
performing an expanding horizon search is not necessary. A single
request [MUST NOT]{.bcp14} be duplicated: it [MUST NOT]{.bcp14} be
forwarded to a multicast address, and it [MUST NOT]{.bcp14} be forwarded
to multiple neighbours. However, if a seqno request is resent by its
originator, the subsequent copies may be forwarded to a different
neighbour than the initial one.[¶](#section-3.8.1.2-6){.pilcrow}
:::
:::
:::
:::

::: {#sending-requests}
::: {#section-3.8.2 .section}
#### [3.8.2.](#section-3.8.2){.section-number .selfRef} [Sending Requests](#name-sending-requests){.section-name .selfRef} {#name-sending-requests}

A Babel node [MAY]{.bcp14} send a route or seqno request at any time to
a multicast or a unicast address; there is only one case when
originating requests is required ([Section
3.8.2.1](#avoiding-starvation){.xref}).[¶](#section-3.8.2-1){.pilcrow}

::: {#avoiding-starvation}
::: {#section-3.8.2.1 .section}
##### [3.8.2.1.](#section-3.8.2.1){.section-number .selfRef} [Avoiding Starvation](#name-avoiding-starvation){.section-name .selfRef} {#name-avoiding-starvation}

When a route is retracted or expires, a Babel node usually switches to
another feasible route for the same prefix. It may be the case, however,
that no such routes are available.[¶](#section-3.8.2.1-1){.pilcrow}

A node that has lost all feasible routes to a given destination but
still has unexpired unfeasible routes to that destination [MUST]{.bcp14}
send a seqno request; if it doesn\'t have any such routes, it
[MAY]{.bcp14} still send a seqno request. The router-id of the request
is set to the router-id of the route that it has just lost, and the
requested seqno is the value contained in the source table plus 1. The
request carries a hop count, which is used as a last-resort mechanism to
ensure that it eventually vanishes from the network; it [MAY]{.bcp14} be
set to any value that is larger than the diameter of the network (64 is
a suitable default value).[¶](#section-3.8.2.1-2){.pilcrow}

If the node has any (unfeasible) routes to the requested destination,
then it [MUST]{.bcp14} send the request to at least one of the next-hop
neighbours that advertised these routes, and [SHOULD]{.bcp14} send it to
all of them; in any case, it [MAY]{.bcp14} send the request to any other
neighbours, whether they advertise a route to the requested destination
or not. A simple implementation strategy is therefore to unconditionally
multicast the request over all
interfaces.[¶](#section-3.8.2.1-3){.pilcrow}

Similar requests will be sent by other nodes that are affected by the
route\'s loss. If the network is still connected, and assuming no packet
loss, then at least one of these requests will be forwarded to the
source, resulting in a route being advertised with a new sequence
number. (Due to duplicate suppression, only a small number of such
requests are expected to actually reach the
source.)[¶](#section-3.8.2.1-4){.pilcrow}

In order to compensate for packet loss, a node [SHOULD]{.bcp14} repeat
such a request a small number of times if no route becomes feasible
within a short time (see \"Request timeout\" in [Appendix
B](#parameters){.xref} for suggested values). In the presence of heavy
packet loss, however, all such requests might be lost; in that case, the
mechanism in the next section will eventually ensure that a new seqno is
received.[¶](#section-3.8.2.1-5){.pilcrow}
:::
:::

::: {#request-unfeasible}
::: {#section-3.8.2.2 .section}
##### [3.8.2.2.](#section-3.8.2.2){.section-number .selfRef} [Dealing with Unfeasible Updates](#name-dealing-with-unfeasible-upd){.section-name .selfRef} {#name-dealing-with-unfeasible-upd}

When a route\'s metric increases, a node might receive an unfeasible
update for a route that it has currently selected. As specified in
[Section 3.5.1](#feasibility-condition){.xref}, the receiving node will
either ignore the update or unselect the
route.[¶](#section-3.8.2.2-1){.pilcrow}

In order to keep routes from spuriously expiring because they have
become unfeasible, a node [SHOULD]{.bcp14} send a unicast seqno request
when it receives an unfeasible update for a route that is currently
selected. The requested sequence number is computed from the source
table as in [Section
3.8.2.1](#avoiding-starvation){.xref}.[¶](#section-3.8.2.2-2){.pilcrow}

Additionally, since metric computation does not necessarily coincide
with the delay in propagating updates, a node might receive an
unfeasible update from a currently unselected neighbour that is
preferable to the currently selected route (e.g., because it has a much
smaller metric); in that case, the node [SHOULD]{.bcp14} send a unicast
seqno request to the neighbour that advertised the preferable
update.[¶](#section-3.8.2.2-3){.pilcrow}
:::
:::

::: {#request-expiring}
::: {#section-3.8.2.3 .section}
##### [3.8.2.3.](#section-3.8.2.3){.section-number .selfRef} [Preventing Routes from Expiring](#name-preventing-routes-from-expi){.section-name .selfRef} {#name-preventing-routes-from-expi}

In normal operation, a route\'s expiry timer never triggers: since a
route\'s hold time is computed from an explicit interval included in
Update TLVs, a new update (possibly a retraction) should arrive in time
to prevent a route from expiring.[¶](#section-3.8.2.3-1){.pilcrow}

In the presence of packet loss, however, it may be the case that no
update is successfully received for an extended period of time, causing
a route to expire. In order to avoid such spurious expiry, shortly
before a selected route expires, a Babel node [SHOULD]{.bcp14} send a
unicast route request to the neighbour that advertised this route; since
nodes always send either updates or retractions in response to
non-wildcard route requests ([Section
3.8.1.1](#handling-route-requests){.xref}), this will usually result in
the route being either refreshed or
retracted.[¶](#section-3.8.2.3-2){.pilcrow}
:::
:::
:::
:::
:::
:::
:::

::: {#protocol-encoding}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Protocol Encoding](#name-protocol-encoding){.section-name .selfRef} {#name-protocol-encoding}

A Babel packet [MUST]{.bcp14} be sent as the body of a UDP datagram,
with network-layer hop count set to 1, destined to a well-known
multicast address or to a unicast address, over IPv4 or IPv6; in the
case of IPv6, these addresses are link-local. Both the source and
destination UDP port are set to a well-known port number. A Babel packet
[MUST]{.bcp14} be silently ignored unless its source address is either a
link-local IPv6 address or an IPv4 address belonging to the local
network, and its source port is the well-known Babel port. It
[MAY]{.bcp14} be silently ignored if its destination address is a global
IPv6 address.[¶](#section-4-1){.pilcrow}

In order to minimise the number of packets being sent while avoiding
lower-layer fragmentation, a Babel node [SHOULD]{.bcp14} maximise the
size of the packets it sends, up to the outgoing interface\'s MTU
adjusted for lower-layer headers (28 octets for UDP over IPv4, 48 octets
for UDP over IPv6). It [MUST NOT]{.bcp14} send packets larger than the
attached interface\'s MTU adjusted for lower-layer headers or 512
octets, whichever is larger, but not exceeding 2^16^ - 1 adjusted for
lower-layer headers. Every Babel speaker [MUST]{.bcp14} be able to
receive packets that are as large as any attached interface\'s MTU
adjusted for lower-layer headers or 512 octets, whichever is larger.
Babel packets [MUST NOT]{.bcp14} be sent in IPv6 jumbograms
\[[RFC2675](#RFC2675){.xref}\].[¶](#section-4-2){.pilcrow}

::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Data Types](#name-data-types){.section-name .selfRef} {#name-data-types}

::: {#section-4.1.1 .section}
#### [4.1.1.](#section-4.1.1){.section-number .selfRef} [Representation of Integers](#name-representation-of-integers){.section-name .selfRef} {#name-representation-of-integers}

All multi-octet fields that represent integers are encoded with the most
significant octet first (in Big-Endian format
\[[IEN137](#IEN137){.xref}\], also called network order). The base
protocol only carries unsigned values; if an extension needs to carry
signed values, it will need to specify their encoding (e.g., two\'s
complement).[¶](#section-4.1.1-1){.pilcrow}
:::

::: {#section-4.1.2 .section}
#### [4.1.2.](#section-4.1.2){.section-number .selfRef} [Interval](#name-interval){.section-name .selfRef} {#name-interval}

Relative times are carried as 16-bit values specifying a number of
centiseconds (hundredths of a second). This allows times up to roughly
11 minutes with a granularity of 10 ms, which should cover all
reasonable applications of Babel (see also [Appendix
B](#parameters){.xref}).[¶](#section-4.1.2-1){.pilcrow}
:::

::: {#router-id-def}
::: {#section-4.1.3 .section}
#### [4.1.3.](#section-4.1.3){.section-number .selfRef} [Router-Id](#name-router-id){.section-name .selfRef} {#name-router-id}

A router-id is an arbitrary 8-octet value. A router-id [MUST
NOT]{.bcp14} consist of either all binary zeroes (0000000000000000
hexadecimal) or all binary ones (FFFFFFFFFFFFFFFF
hexadecimal).[¶](#section-4.1.3-1){.pilcrow}
:::
:::

::: {#section-4.1.4 .section}
#### [4.1.4.](#section-4.1.4){.section-number .selfRef} [Address](#name-address){.section-name .selfRef} {#name-address}

Since the bulk of the protocol is taken by addresses, multiple ways of
encoding addresses are defined. Additionally, within Update TLVs a
common subnet prefix may be omitted when multiple addresses are sent in
a single packet \-- this is known as address compression ([Section
4.6.9](#update){.xref}).[¶](#section-4.1.4-1){.pilcrow}

Address encodings (AEs):[¶](#section-4.1.4-2){.pilcrow}

[]{.break}

AE 0:
:   Wildcard address. The value is 0 octets
    long.[¶](#section-4.1.4-3.2){.pilcrow}
:   

AE 1:
:   IPv4 address. Compression is allowed. 4 octets or
    less.[¶](#section-4.1.4-3.4){.pilcrow}
:   

AE 2:
:   IPv6 address. Compression is allowed. 16 octets or
    less.[¶](#section-4.1.4-3.6){.pilcrow}
:   

AE 3:
:   Link-local IPv6 address. Compression is not allowed. The value is 8
    octets long, a prefix of fe80::/64 is
    implied.[¶](#section-4.1.4-3.8){.pilcrow}
:   

The address family associated with an address encoding is either IPv4 or
IPv6: it is undefined for AE 0, IPv4 for AE 1, and IPv6 for AEs 2 and
3.[¶](#section-4.1.4-4){.pilcrow}
:::

::: {#section-4.1.5 .section}
#### [4.1.5.](#section-4.1.5){.section-number .selfRef} [Prefixes](#name-prefixes){.section-name .selfRef} {#name-prefixes}

A network prefix is encoded just like a network address, but it is
stored in the smallest number of octets that are enough to hold the
significant bits (up to the prefix
length).[¶](#section-4.1.5-1){.pilcrow}
:::
:::

::: {#packet-format}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Packet Format](#name-packet-format){.section-name .selfRef} {#name-packet-format}

A Babel packet consists of a 4-octet header, followed by a sequence of
TLVs (the packet body), optionally followed by a second sequence of TLVs
(the packet trailer). The format is designed to be extensible; see
[Appendix D](#extensions){.xref} for extensibility
considerations.[¶](#section-4.2-1){.pilcrow}

::: {#section-4.2-2 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Magic     |    Version    |        Body length            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          Packet Body...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
    |         Packet Trailer...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

[¶](#section-4.2-2){.pilcrow}
:::

Fields:[¶](#section-4.2-3){.pilcrow}

[]{.break}

Magic
:   The arbitrary but carefully chosen value 42 (decimal); packets with
    a first octet different from 42 [MUST]{.bcp14} be silently
    ignored.[¶](#section-4.2-4.2){.pilcrow}
:   

Version
:   This document specifies version 2 of the Babel protocol. Packets
    with a second octet different from 2 [MUST]{.bcp14} be silently
    ignored.[¶](#section-4.2-4.4){.pilcrow}
:   

Body length
:   The length in octets of the body following the packet header
    (excluding the Magic, Version, and Body length fields, and excluding
    the packet trailer).[¶](#section-4.2-4.6){.pilcrow}
:   

Packet Body
:   The packet body; a sequence of TLVs.[¶](#section-4.2-4.8){.pilcrow}
:   

Packet Trailer
:   The packet trailer; another sequence of
    TLVs.[¶](#section-4.2-4.10){.pilcrow}
:   

The packet body and trailer are both sequences of TLVs. The packet body
is the normal place to store TLVs; the packet trailer only contains
specialised TLVs that do not need to be protected by cryptographic
security mechanisms. When parsing the trailer, the receiver
[MUST]{.bcp14} ignore any TLV unless its definition explicitly states
that it is allowed to appear there. Among the TLVs defined in this
document, only Pad1 and PadN are allowed in the trailer; since these
TLVs are ignored in any case, an implementation [MAY]{.bcp14} silently
ignore the packet trailer without even parsing it, unless it implements
at least one protocol extension that defines TLVs that are allowed to
appear in the trailer.[¶](#section-4.2-5){.pilcrow}
:::
:::

::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [TLV Format](#name-tlv-format){.section-name .selfRef} {#name-tlv-format}

With the exception of Pad1, all TLVs have the following
structure:[¶](#section-4.3-1){.pilcrow}

::: {#section-4.3-2 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |    Length     |     Payload...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

[¶](#section-4.3-2){.pilcrow}
:::

Fields:[¶](#section-4.3-3){.pilcrow}

[]{.break}

Type
:   The type of the TLV.[¶](#section-4.3-4.2){.pilcrow}
:   

Length
:   The length of the body in octets, exclusive of the Type and Length
    fields.[¶](#section-4.3-4.4){.pilcrow}
:   

Payload
:   The TLV payload, which consists of a body and, for selected TLV
    types, an optional list of sub-TLVs.[¶](#section-4.3-4.6){.pilcrow}
:   

TLVs with an unknown type value [MUST]{.bcp14} be silently
ignored.[¶](#section-4.3-5){.pilcrow}
:::

::: {#sub-tlv-format}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Sub-TLV Format](#name-sub-tlv-format){.section-name .selfRef} {#name-sub-tlv-format}

Every TLV carries an explicit length in its header; however, most TLVs
are self-terminating, in the sense that it is possible to determine the
length of the body without reference to the explicit Length field. If a
TLV has a self-terminating format, then the space between the natural
size of the TLV and the size announced in the Length field may be used
to store a sequence of sub-TLVs.[¶](#section-4.4-1){.pilcrow}

Sub-TLVs have the same structure as TLVs. With the exception of Pad1,
all TLVs have the following structure:[¶](#section-4.4-2){.pilcrow}

::: {#section-4.4-3 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |    Length     |     Body...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

[¶](#section-4.4-3){.pilcrow}
:::

Fields:[¶](#section-4.4-4){.pilcrow}

[]{.break}

Type
:   The type of the sub-TLV.[¶](#section-4.4-5.2){.pilcrow}
:   

Length
:   The length of the body in octets, exclusive of the Type and Length
    fields.[¶](#section-4.4-5.4){.pilcrow}
:   

Body
:   The sub-TLV body, the interpretation of which depends on both the
    type of the sub-TLV and the type of the TLV within which it is
    embedded.[¶](#section-4.4-5.6){.pilcrow}
:   

The most significant bit of the sub-TLV type (the bit with value 80
hexadecimal), is called the mandatory bit; in other words, sub-TLV types
128 through 255 have the mandatory bit set. This bit indicates how to
handle unknown sub-TLVs. If the mandatory bit is not set, then an
unknown sub-TLV [MUST]{.bcp14} be silently ignored, and the rest of the
TLV is processed normally. If the mandatory bit is set, then the whole
enclosing TLV [MUST]{.bcp14} be silently ignored (except for updating
the parser state by a Router-Id, Next Hop, or Update TLV, as described
in the next section).[¶](#section-4.4-6){.pilcrow}
:::
:::

::: {#parser-state}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [Parser State and Encoding of Updates](#name-parser-state-and-encoding-o){.section-name .selfRef} {#name-parser-state-and-encoding-o}

In a large network, the bulk of Babel traffic consists of route updates;
hence, some care has been given to encoding them efficiently. The data
conceptually contained in an update ([Section
3.5](#route-maintenance){.xref}) is split into three
pieces:[¶](#section-4.5-1){.pilcrow}

-   [the prefix, seqno, and metric are contained in the Update TLV
    itself ([Section
    4.6.9](#update){.xref});[¶](#section-4.5-2.1){.pilcrow}]{#section-4.5-2.1}
-   [the router-id is taken from the Router-Id TLV that precedes the
    Update TLV and may be shared among multiple Update TLVs ([Section
    4.6.7](#router-id){.xref});[¶](#section-4.5-2.2){.pilcrow}]{#section-4.5-2.2}
-   [the next hop is taken either from the source address of the
    network-layer packet that contains the Babel packet or from an
    explicit Next Hop TLV ([Section
    4.6.8](#next-hop){.xref}).[¶](#section-4.5-2.3){.pilcrow}]{#section-4.5-2.3}

In addition to the above, an Update TLV can omit a prefix of the prefix
being announced, which is then extracted from the preceding Update TLV
in the same address family (IPv4 or IPv6). Finally, as a special
optimisation for the case when a router-id coincides with the
interface-id part of an IPv6 address, the Router-Id TLV itself may be
omitted, and the router-id is derived from the low-order bits of the
advertised prefix ([Section
4.6.9](#update){.xref}).[¶](#section-4.5-3){.pilcrow}

In order to implement these compression techniques, Babel uses a
stateful parser: a TLV may refer to data from a previous TLV. The parser
state consists of the following pieces of
data:[¶](#section-4.5-4){.pilcrow}

-   [for each address encoding that allows compression, the current
    default prefix: this is undefined at the start of the packet and is
    updated by each Update TLV with the Prefix flag set ([Section
    4.6.9](#update){.xref});[¶](#section-4.5-5.1){.pilcrow}]{#section-4.5-5.1}
-   [for each address family (IPv4 or IPv6), the current next hop: this
    is the source address of the enclosing packet for the matching
    address family at the start of a packet, and it is updated by each
    Next Hop TLV ([Section
    4.6.8](#next-hop){.xref});[¶](#section-4.5-5.2){.pilcrow}]{#section-4.5-5.2}
-   [the current router-id: this is undefined at the start of the
    packet, and it is updated by each Router-Id TLV ([Section
    4.6.7](#router-id){.xref}) and by each Update TLV with Router-Id
    flag set.[¶](#section-4.5-5.3){.pilcrow}]{#section-4.5-5.3}

Since the parser state must be identical across implementations, it is
updated before checking for mandatory sub-TLVs: parsing a TLV
[MUST]{.bcp14} update the parser state even if the TLV is otherwise
ignored due to an unknown mandatory sub-TLV or for any other
reason.[¶](#section-4.5-6){.pilcrow}

None of the TLVs that modify the parser state are allowed in the packet
trailer; hence, an implementation may choose to use a dedicated
stateless parser to parse the packet
trailer.[¶](#section-4.5-7){.pilcrow}
:::
:::

::: {#tlv-details}
::: {#section-4.6 .section}
### [4.6.](#section-4.6){.section-number .selfRef} [Details of Specific TLVs](#name-details-of-specific-tlvs){.section-name .selfRef} {#name-details-of-specific-tlvs}

::: {#section-4.6.1 .section}
#### [4.6.1.](#section-4.6.1){.section-number .selfRef} [Pad1](#name-pad1){.section-name .selfRef} {#name-pad1}

::: {#section-4.6.1-1 .artwork .art-text .alignLeft}
     0
     0 1 2 3 4 5 6 7
    +-+-+-+-+-+-+-+-+
    |   Type = 0    |
    +-+-+-+-+-+-+-+-+

[¶](#section-4.6.1-1){.pilcrow}
:::

Fields:[¶](#section-4.6.1-2){.pilcrow}

[]{.break}

Type
:   Set to 0 to indicate a Pad1 TLV.[¶](#section-4.6.1-3.2){.pilcrow}
:   

This TLV is silently ignored on reception. It is allowed in the packet
trailer.[¶](#section-4.6.1-4){.pilcrow}
:::

::: {#section-4.6.2 .section}
#### [4.6.2.](#section-4.6.2){.section-number .selfRef} [PadN](#name-padn){.section-name .selfRef} {#name-padn}

::: {#section-4.6.2-1 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Type = 1   |    Length     |      MBZ...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

[¶](#section-4.6.2-1){.pilcrow}
:::

Fields:[¶](#section-4.6.2-2){.pilcrow}

[]{.break}

Type
:   Set to 1 to indicate a PadN TLV.[¶](#section-4.6.2-3.2){.pilcrow}
:   

Length
:   The length of the body in octets, exclusive of the Type and Length
    fields.[¶](#section-4.6.2-3.4){.pilcrow}
:   

MBZ
:   Must be zero, set to 0 on
    transmission.[¶](#section-4.6.2-3.6){.pilcrow}
:   

This TLV is silently ignored on reception. It is allowed in the packet
trailer.[¶](#section-4.6.2-4){.pilcrow}
:::

::: {#section-4.6.3 .section}
#### [4.6.3.](#section-4.6.3){.section-number .selfRef} [Acknowledgment Request](#name-acknowledgment-request){.section-name .selfRef} {#name-acknowledgment-request}

::: {#section-4.6.3-1 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Type = 2   |    Length     |          Reserved             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |             Opaque            |          Interval             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-4.6.3-1){.pilcrow}
:::

This TLV requests that the receiver send an Acknowledgment TLV within
the number of centiseconds specified by the Interval
field.[¶](#section-4.6.3-2){.pilcrow}

Fields:[¶](#section-4.6.3-3){.pilcrow}

[]{.break}

Type
:   Set to 2 to indicate an Acknowledgment Request
    TLV.[¶](#section-4.6.3-4.2){.pilcrow}
:   

Length
:   The length of the body in octets, exclusive of the Type and Length
    fields.[¶](#section-4.6.3-4.4){.pilcrow}
:   

Reserved
:   Sent as 0 and [MUST]{.bcp14} be ignored on
    reception.[¶](#section-4.6.3-4.6){.pilcrow}
:   

Opaque
:   An arbitrary value that will be echoed in the receiver\'s
    Acknowledgment TLV.[¶](#section-4.6.3-4.8){.pilcrow}
:   

Interval
:   A time interval in centiseconds after which the sender will assume
    that this packet has been lost. This [MUST NOT]{.bcp14} be 0. The
    receiver [MUST]{.bcp14} send an Acknowledgment TLV before this time
    has elapsed (with a margin allowing for propagation
    time).[¶](#section-4.6.3-4.10){.pilcrow}
:   

This TLV is self-terminating and allows
sub-TLVs.[¶](#section-4.6.3-5){.pilcrow}
:::

::: {#ack}
::: {#section-4.6.4 .section}
#### [4.6.4.](#section-4.6.4){.section-number .selfRef} [Acknowledgment](#name-acknowledgment){.section-name .selfRef} {#name-acknowledgment}

::: {#section-4.6.4-1 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Type = 3   |    Length     |           Opaque              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-4.6.4-1){.pilcrow}
:::

This TLV is sent by a node upon receiving an Acknowledgment Request
TLV.[¶](#section-4.6.4-2){.pilcrow}

Fields:[¶](#section-4.6.4-3){.pilcrow}

[]{.break}

Type
:   Set to 3 to indicate an Acknowledgment
    TLV.[¶](#section-4.6.4-4.2){.pilcrow}
:   

Length
:   The length of the body in octets, exclusive of the Type and Length
    fields.[¶](#section-4.6.4-4.4){.pilcrow}
:   

Opaque
:   Set to the Opaque value of the Acknowledgment Request that prompted
    this Acknowledgment.[¶](#section-4.6.4-4.6){.pilcrow}
:   

Since Opaque values are not globally unique, this TLV [MUST]{.bcp14} be
sent to a unicast address.[¶](#section-4.6.4-5){.pilcrow}

This TLV is self-terminating and allows
sub-TLVs.[¶](#section-4.6.4-6){.pilcrow}
:::
:::

::: {#section-4.6.5 .section}
#### [4.6.5.](#section-4.6.5){.section-number .selfRef} [Hello](#name-hello){.section-name .selfRef} {#name-hello}

::: {#section-4.6.5-1 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Type = 4   |    Length     |            Flags              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |            Seqno              |          Interval             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-4.6.5-1){.pilcrow}
:::

This TLV is used for neighbour discovery and for determining a
neighbour\'s reception cost.[¶](#section-4.6.5-2){.pilcrow}

Fields:[¶](#section-4.6.5-3){.pilcrow}

[]{.break}

Type
:   Set to 4 to indicate a Hello TLV.[¶](#section-4.6.5-4.2){.pilcrow}
:   

Length
:   The length of the body in octets, exclusive of the Type and Length
    fields.[¶](#section-4.6.5-4.4){.pilcrow}
:   

Flags
:   The individual bits of this field specify special handling of this
    TLV (see below).[¶](#section-4.6.5-4.6){.pilcrow}
:   

Seqno
:   If the Unicast flag is set, this is the value of the sending node\'s
    outgoing Unicast Hello seqno for this neighbour. Otherwise, it is
    the sending node\'s outgoing Multicast Hello seqno for this
    interface.[¶](#section-4.6.5-4.8){.pilcrow}
:   

Interval
:   If nonzero, this is an upper bound, expressed in centiseconds, on
    the time after which the sending node will send a new scheduled
    Hello TLV with the same setting of the Unicast flag. If this is 0,
    then this Hello represents an unscheduled Hello and doesn\'t carry
    any new information about times at which Hellos are
    sent.[¶](#section-4.6.5-4.10){.pilcrow}
:   

The Flags field is interpreted as
follows:[¶](#section-4.6.5-5){.pilcrow}

::: {#section-4.6.5-6 .artwork .art-text .alignLeft}
     0                   1
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |U|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-4.6.5-6){.pilcrow}
:::

[]{.break}

U (Unicast) flag (8000 hexadecimal):
:   if set, then this Hello represents a Unicast Hello, otherwise it
    represents a Multicast Hello;[¶](#section-4.6.5-7.2){.pilcrow}
:   

X:
:   all other bits [MUST]{.bcp14} be sent as 0 and silently ignored on
    reception.[¶](#section-4.6.5-7.4){.pilcrow}
:   

Every time a Hello is sent, the corresponding seqno counter
[MUST]{.bcp14} be incremented. Since there is a single seqno counter for
all the Multicast Hellos sent by a given node over a given interface, if
the Unicast flag is not set, this TLV [MUST]{.bcp14} be sent to all
neighbours on this link, which can be achieved by sending to a multicast
destination or by sending multiple packets to the unicast addresses of
all reachable neighbours. Conversely, if the Unicast flag is set, this
TLV [MUST]{.bcp14} be sent to a single neighbour, which can achieved by
sending to a unicast destination. In order to avoid large
discontinuities in link quality, multiple Hello TLVs [SHOULD
NOT]{.bcp14} be sent in the same packet.[¶](#section-4.6.5-8){.pilcrow}

This TLV is self-terminating and allows
sub-TLVs.[¶](#section-4.6.5-9){.pilcrow}
:::

::: {#section-4.6.6 .section}
#### [4.6.6.](#section-4.6.6){.section-number .selfRef} [IHU](#name-ihu){.section-name .selfRef} {#name-ihu}

::: {#section-4.6.6-1 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Type = 5   |    Length     |       AE      |    Reserved   |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |            Rxcost             |          Interval             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |       Address...
    +-+-+-+-+-+-+-+-+-+-+-+-

[¶](#section-4.6.6-1){.pilcrow}
:::

An IHU (\"I Heard You\") TLV is used for confirming bidirectional
reachability and carrying a link\'s transmission
cost.[¶](#section-4.6.6-2){.pilcrow}

Fields:[¶](#section-4.6.6-3){.pilcrow}

[]{.break}

Type
:   Set to 5 to indicate an IHU TLV.[¶](#section-4.6.6-4.2){.pilcrow}
:   

Length
:   The length of the body in octets, exclusive of the Type and Length
    fields.[¶](#section-4.6.6-4.4){.pilcrow}
:   

AE
:   The encoding of the Address field. This should be 1 or 3 in most
    cases. As an optimisation, it [MAY]{.bcp14} be 0 if the TLV is sent
    to a unicast address, if the association is over a point-to-point
    link, or when bidirectional reachability is ascertained by means
    outside of the Babel protocol.[¶](#section-4.6.6-4.6){.pilcrow}
:   

Reserved
:   Sent as 0 and [MUST]{.bcp14} be ignored on
    reception.[¶](#section-4.6.6-4.8){.pilcrow}
:   

Rxcost
:   The rxcost according to the sending node of the interface whose
    address is specified in the Address field. The value FFFF
    hexadecimal (infinity) indicates that this interface is
    unreachable.[¶](#section-4.6.6-4.10){.pilcrow}
:   

Interval
:   An upper bound, expressed in centiseconds, on the time after which
    the sending node will send a new IHU; this [MUST NOT]{.bcp14} be 0.
    The receiving node will use this value in order to compute a hold
    time for this symmetric
    association.[¶](#section-4.6.6-4.12){.pilcrow}
:   

Address
:   The address of the destination node, in the format specified by the
    AE field. Address compression is not
    allowed.[¶](#section-4.6.6-4.14){.pilcrow}
:   

Conceptually, an IHU is destined to a single neighbour. However, IHU
TLVs contain an explicit destination address, and [MAY]{.bcp14} be sent
to a multicast address, as this allows aggregation of IHUs destined to
distinct neighbours into a single packet and avoids the need for an ARP
or Neighbour Discovery exchange when a neighbour is not being used for
data traffic.[¶](#section-4.6.6-5){.pilcrow}

IHU TLVs with an unknown value in the AE field [MUST]{.bcp14} be
silently ignored.[¶](#section-4.6.6-6){.pilcrow}

This TLV is self-terminating and allows
sub-TLVs.[¶](#section-4.6.6-7){.pilcrow}
:::

::: {#router-id}
::: {#section-4.6.7 .section}
#### [4.6.7.](#section-4.6.7){.section-number .selfRef} [Router-Id](#name-router-id-2){.section-name .selfRef} {#name-router-id-2}

::: {#section-4.6.7-1 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Type = 6   |    Length     |          Reserved             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                           Router-Id                           +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-4.6.7-1){.pilcrow}
:::

A Router-Id TLV establishes a router-id that is implied by subsequent
Update TLVs, as described in [Section 4.5](#parser-state){.xref}. This
TLV sets the router-id even if it is otherwise ignored due to an unknown
mandatory sub-TLV.[¶](#section-4.6.7-2){.pilcrow}

Fields:[¶](#section-4.6.7-3){.pilcrow}

[]{.break}

Type
:   Set to 6 to indicate a Router-Id
    TLV.[¶](#section-4.6.7-4.2){.pilcrow}
:   

Length
:   The length of the body in octets, exclusive of the Type and Length
    fields.[¶](#section-4.6.7-4.4){.pilcrow}
:   

Reserved
:   Sent as 0 and [MUST]{.bcp14} be ignored on
    reception.[¶](#section-4.6.7-4.6){.pilcrow}
:   

Router-Id
:   The router-id for routes advertised in subsequent Update TLVs. This
    [MUST NOT]{.bcp14} consist of all zeroes or all
    ones.[¶](#section-4.6.7-4.8){.pilcrow}
:   

This TLV is self-terminating and allows
sub-TLVs.[¶](#section-4.6.7-5){.pilcrow}
:::
:::

::: {#next-hop}
::: {#section-4.6.8 .section}
#### [4.6.8.](#section-4.6.8){.section-number .selfRef} [Next Hop](#name-next-hop){.section-name .selfRef} {#name-next-hop}

::: {#section-4.6.8-1 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Type = 7   |    Length     |      AE       |   Reserved    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |       Next hop...
    +-+-+-+-+-+-+-+-+-+-+-+-

[¶](#section-4.6.8-1){.pilcrow}
:::

A Next Hop TLV establishes a next-hop address for a given address family
(IPv4 or IPv6) that is implied in subsequent Update TLVs, as described
in [Section 4.5](#parser-state){.xref}. This TLV sets up the next hop
for subsequent Update TLVs even if it is otherwise ignored due to an
unknown mandatory sub-TLV.[¶](#section-4.6.8-2){.pilcrow}

Fields:[¶](#section-4.6.8-3){.pilcrow}

[]{.break}

Type
:   Set to 7 to indicate a Next Hop
    TLV.[¶](#section-4.6.8-4.2){.pilcrow}
:   

Length
:   The length of the body in octets, exclusive of the Type and Length
    fields.[¶](#section-4.6.8-4.4){.pilcrow}
:   

AE
:   The encoding of the Address field. This [SHOULD]{.bcp14} be 1 (IPv4)
    or 3 (link-local IPv6), and [MUST NOT]{.bcp14} be
    0.[¶](#section-4.6.8-4.6){.pilcrow}
:   

Reserved
:   Sent as 0 and [MUST]{.bcp14} be ignored on
    reception.[¶](#section-4.6.8-4.8){.pilcrow}
:   

Next hop
:   The next-hop address advertised by subsequent Update TLVs for this
    address family.[¶](#section-4.6.8-4.10){.pilcrow}
:   

When the address family matches the network-layer protocol over which
this packet is transported, a Next Hop TLV is not needed: in the absence
of a Next Hop TLV in a given address family, the next-hop address is
taken to be the source address of the
packet.[¶](#section-4.6.8-5){.pilcrow}

Next Hop TLVs with an unknown value for the AE field [MUST]{.bcp14} be
silently ignored.[¶](#section-4.6.8-6){.pilcrow}

This TLV is self-terminating, and allows
sub-TLVs.[¶](#section-4.6.8-7){.pilcrow}
:::
:::

::: {#update}
::: {#section-4.6.9 .section}
#### [4.6.9.](#section-4.6.9){.section-number .selfRef} [Update](#name-update){.section-name .selfRef} {#name-update}

::: {#section-4.6.9-1 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Type = 8   |    Length     |       AE      |    Flags      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Plen      |    Omitted    |            Interval           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |             Seqno             |            Metric             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |      Prefix...
    +-+-+-+-+-+-+-+-+-+-+-+-

[¶](#section-4.6.9-1){.pilcrow}
:::

An Update TLV advertises or retracts a route. As an optimisation, it can
optionally have the side effect of establishing a new implied router-id
and a new default prefix, as described in [Section
4.5](#parser-state){.xref}.[¶](#section-4.6.9-2){.pilcrow}

Fields:[¶](#section-4.6.9-3){.pilcrow}

[]{.break}

Type
:   Set to 8 to indicate an Update TLV.[¶](#section-4.6.9-4.2){.pilcrow}
:   

Length
:   The length of the body in octets, exclusive of the Type and Length
    fields.[¶](#section-4.6.9-4.4){.pilcrow}
:   

AE
:   The encoding of the Prefix field.[¶](#section-4.6.9-4.6){.pilcrow}
:   

Flags
:   The individual bits of this field specify special handling of this
    TLV (see below).[¶](#section-4.6.9-4.8){.pilcrow}
:   

Plen
:   The length in bits of the advertised prefix. If AE is 3 (link-local
    IPv6), the Omitted field [MUST]{.bcp14} be
    0.[¶](#section-4.6.9-4.10){.pilcrow}
:   

Omitted
:   The number of octets that have been omitted at the beginning of the
    advertised prefix and that should be taken from a preceding Update
    TLV in the same address family with the Prefix flag
    set.[¶](#section-4.6.9-4.12){.pilcrow}
:   

Interval
:   An upper bound, expressed in centiseconds, on the time after which
    the sending node will send a new update for this prefix. This [MUST
    NOT]{.bcp14} be 0. The receiving node will use this value to compute
    a hold time for the route table entry. The value FFFF hexadecimal
    (infinity) expresses that this announcement will not be repeated
    unless a request is received ([Section
    3.8.2.3](#request-expiring){.xref}).[¶](#section-4.6.9-4.14){.pilcrow}
:   

Seqno
:   The originator\'s sequence number for this
    update.[¶](#section-4.6.9-4.16){.pilcrow}
:   

Metric
:   The sender\'s metric for this route. The value FFFF hexadecimal
    (infinity) means that this is a route
    retraction.[¶](#section-4.6.9-4.18){.pilcrow}
:   

Prefix
:   The prefix being advertised. This field\'s size is
    (Plen/8 - Omitted) rounded
    upwards.[¶](#section-4.6.9-4.20){.pilcrow}
:   

The Flags field is interpreted as
follows:[¶](#section-4.6.9-5){.pilcrow}

::: {#section-4.6.9-6 .artwork .art-text .alignLeft}
     0 1 2 3 4 5 6 7
    +-+-+-+-+-+-+-+-+
    |P|R|X|X|X|X|X|X|
    +-+-+-+-+-+-+-+-+

[¶](#section-4.6.9-6){.pilcrow}
:::

[]{.break}

P (Prefix) flag (80 hexadecimal):
:   if set, then this Update TLV establishes a new default prefix for
    subsequent Update TLVs with a matching address encoding within the
    same packet, even if this TLV is otherwise ignored due to an unknown
    mandatory sub-TLV;[¶](#section-4.6.9-7.2){.pilcrow}
:   

R (Router-Id) flag (40 hexadecimal):

:   if set, then this TLV establishes a new default router-id for this
    TLV and subsequent Update TLVs in the same packet, even if this TLV
    is otherwise ignored due to an unknown mandatory sub-TLV. This
    router-id is computed from the first address of the advertised
    prefix as follows:[¶](#section-4.6.9-7.4.1){.pilcrow}

    -   [if the length of the address is 8 octets or more, then the new
        router-id is taken from the 8 last octets of the
        address;[¶](#section-4.6.9-7.4.2.1){.pilcrow}]{#section-4.6.9-7.4.2.1}
    -   [if the length of the address is smaller than 8 octets, then the
        new router-id consists of the required number of zero octets
        followed by the address, i.e., the address is stored on the
        right of the router-id. For example, for an IPv4 address, the
        router-id consists of 4 octets of zeroes followed by the IPv4
        address.[¶](#section-4.6.9-7.4.2.2){.pilcrow}]{#section-4.6.9-7.4.2.2}

:   

X:
:   all other bits [MUST]{.bcp14} be sent as 0 and silently ignored on
    reception.[¶](#section-4.6.9-7.6){.pilcrow}
:   

The prefix being advertised by an Update TLV is computed as
follows:[¶](#section-4.6.9-8){.pilcrow}

-   [the first Omitted octets of the prefix are taken from the previous
    Update TLV with the Prefix flag set and the same address encoding,
    even if it was ignored due to an unknown mandatory sub-TLV; if the
    Omitted field is not zero and there is no such TLV, then this Update
    [MUST]{.bcp14} be
    ignored;[¶](#section-4.6.9-9.1){.pilcrow}]{#section-4.6.9-9.1}
-   [the next (Plen/8 - Omitted) rounded upwards octets are taken from
    the Prefix
    field;[¶](#section-4.6.9-9.2){.pilcrow}]{#section-4.6.9-9.2}
-   [if Plen is not a multiple of 8, then any bits beyond Plen (i.e.,
    the low-order (8 - Plen MOD 8) bits of the last octet) are
    cleared;[¶](#section-4.6.9-9.3){.pilcrow}]{#section-4.6.9-9.3}
-   [the remaining octets are set to
    0.[¶](#section-4.6.9-9.4){.pilcrow}]{#section-4.6.9-9.4}

If the Metric field is finite, the router-id of the originating node for
this announcement is taken from the prefix advertised by this Update if
the Router-Id flag is set, computed as described above. Otherwise, it is
taken either from the preceding Router-Id TLV, or the preceding Update
TLV with the Router-Id flag set, whichever comes last, even if that TLV
is otherwise ignored due to an unknown mandatory sub-TLV; if there is no
suitable TLV, then this update is
ignored.[¶](#section-4.6.9-10){.pilcrow}

The next-hop address for this update is taken from the last preceding
Next Hop TLV with a matching address family (IPv4 or IPv6) in the same
packet even if it was otherwise ignored due to an unknown mandatory
sub-TLV; if no such TLV exists, it is taken from the network-layer
source address of this packet if it belongs to the same address family
as the prefix being announced; otherwise, this Update [MUST]{.bcp14} be
ignored.[¶](#section-4.6.9-11){.pilcrow}

If the metric field is FFFF hexadecimal, this TLV specifies a
retraction. In that case, the router-id, next hop, and seqno are not
used. AE [MAY]{.bcp14} then be 0, in which case this Update retracts all
of the routes previously advertised by the sending interface. If the
metric is finite, AE [MUST NOT]{.bcp14} be 0; Update TLVs with finite
metric and AE equal to 0 [MUST]{.bcp14} be ignored. If the metric is
infinite and AE is 0, Plen and Omitted [MUST]{.bcp14} both be 0; Update
TLVs that do not satisfy this requirement [MUST]{.bcp14} be
ignored.[¶](#section-4.6.9-12){.pilcrow}

Update TLVs with an unknown value in the AE field [MUST]{.bcp14} be
silently ignored.[¶](#section-4.6.9-13){.pilcrow}

This TLV is self-terminating and allows
sub-TLVs.[¶](#section-4.6.9-14){.pilcrow}
:::
:::

::: {#section-4.6.10 .section}
#### [4.6.10.](#section-4.6.10){.section-number .selfRef} [Route Request](#name-route-request){.section-name .selfRef} {#name-route-request}

::: {#section-4.6.10-1 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Type = 9   |    Length     |      AE       |     Plen      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |      Prefix...
    +-+-+-+-+-+-+-+-+-+-+-+-

[¶](#section-4.6.10-1){.pilcrow}
:::

A Route Request TLV prompts the receiver to send an update for a given
prefix, or a full route table dump.[¶](#section-4.6.10-2){.pilcrow}

Fields:[¶](#section-4.6.10-3){.pilcrow}

[]{.break}

Type
:   Set to 9 to indicate a Route Request
    TLV.[¶](#section-4.6.10-4.2){.pilcrow}
:   

Length
:   The length of the body in octets, exclusive of the Type and Length
    fields.[¶](#section-4.6.10-4.4){.pilcrow}
:   

AE
:   The encoding of the Prefix field. The value 0 specifies that this is
    a request for a full route table dump (a wildcard
    request).[¶](#section-4.6.10-4.6){.pilcrow}
:   

Plen
:   The length in bits of the requested
    prefix.[¶](#section-4.6.10-4.8){.pilcrow}
:   

Prefix
:   The prefix being requested. This field\'s size is Plen/8 rounded
    upwards.[¶](#section-4.6.10-4.10){.pilcrow}
:   

A Request TLV prompts the receiver to send an update message (possibly a
retraction) for the prefix specified by the AE, Plen, and Prefix fields,
or a full dump of its route table if AE is 0 (in which case Plen must be
0 and Prefix is of length 0). A Request TLV with AE set to 0 and Plen
not set to 0 [MUST]{.bcp14} be ignored.[¶](#section-4.6.10-5){.pilcrow}

This TLV is self-terminating and allows
sub-TLVs.[¶](#section-4.6.10-6){.pilcrow}
:::

::: {#section-4.6.11 .section}
#### [4.6.11.](#section-4.6.11){.section-number .selfRef} [Seqno Request](#name-seqno-request){.section-name .selfRef} {#name-seqno-request}

::: {#section-4.6.11-1 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Type = 10  |    Length     |      AE       |    Plen       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |             Seqno             |  Hop Count    |   Reserved    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                          Router-Id                            +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Prefix...
    +-+-+-+-+-+-+-+-+-+-+

[¶](#section-4.6.11-1){.pilcrow}
:::

A Seqno Request TLV prompts the receiver to send an Update for a given
prefix with a given sequence number, or to forward the request further
if it cannot be satisfied locally.[¶](#section-4.6.11-2){.pilcrow}

Fields:[¶](#section-4.6.11-3){.pilcrow}

[]{.break}

Type
:   Set to 10 to indicate a Seqno Request
    TLV.[¶](#section-4.6.11-4.2){.pilcrow}
:   

Length
:   The length of the body in octets, exclusive of the Type and Length
    fields.[¶](#section-4.6.11-4.4){.pilcrow}
:   

AE
:   The encoding of the Prefix field. This [MUST NOT]{.bcp14} be
    0.[¶](#section-4.6.11-4.6){.pilcrow}
:   

Plen
:   The length in bits of the requested
    prefix.[¶](#section-4.6.11-4.8){.pilcrow}
:   

Seqno
:   The sequence number that is being
    requested.[¶](#section-4.6.11-4.10){.pilcrow}
:   

Hop Count
:   The maximum number of times that this TLV may be forwarded, plus 1.
    This [MUST NOT]{.bcp14} be 0.[¶](#section-4.6.11-4.12){.pilcrow}
:   

Reserved
:   Sent as 0 and [MUST]{.bcp14} be ignored on
    reception.[¶](#section-4.6.11-4.14){.pilcrow}
:   

Router-Id
:   The Router-Id that is being requested. This [MUST NOT]{.bcp14}
    consist of all zeroes or all
    ones.[¶](#section-4.6.11-4.16){.pilcrow}
:   

Prefix
:   The prefix being requested. This field\'s size is Plen/8 rounded
    upwards.[¶](#section-4.6.11-4.18){.pilcrow}
:   

A Seqno Request TLV prompts the receiving node to send a finite-metric
Update for the prefix specified by the AE, Plen, and Prefix fields, with
either a router-id different from what is specified by the Router-Id
field, or a Seqno no less (modulo 2^16^) than what is specified by the
Seqno field. If this request cannot be satisfied locally, then it is
forwarded according to the rules set out in [Section
3.8.1.2](#handling-seqno-requests){.xref}.[¶](#section-4.6.11-5){.pilcrow}

While a Seqno Request [MAY]{.bcp14} be sent to a multicast address, it
[MUST NOT]{.bcp14} be forwarded to a multicast address and [MUST
NOT]{.bcp14} be forwarded to more than one neighbour. A request [MUST
NOT]{.bcp14} be forwarded if its Hop Count field is
1.[¶](#section-4.6.11-6){.pilcrow}

This TLV is self-terminating and allows
sub-TLVs.[¶](#section-4.6.11-7){.pilcrow}
:::
:::
:::

::: {#section-4.7 .section}
### [4.7.](#section-4.7){.section-number .selfRef} [Details of specific sub-TLVs](#name-details-of-specific-sub-tlv){.section-name .selfRef} {#name-details-of-specific-sub-tlv}

::: {#pad1}
::: {#section-4.7.1 .section}
#### [4.7.1.](#section-4.7.1){.section-number .selfRef} [Pad1](#name-pad1-2){.section-name .selfRef} {#name-pad1-2}

::: {#section-4.7.1-1 .artwork .art-text .alignLeft}
     0 1 2 3 4 5 6 7
    +-+-+-+-+-+-+-+-+
    |   Type = 0    |
    +-+-+-+-+-+-+-+-+

[¶](#section-4.7.1-1){.pilcrow}
:::

Fields:[¶](#section-4.7.1-2){.pilcrow}

[]{.break}

Type
:   Set to 0 to indicate a Pad1
    sub-TLV.[¶](#section-4.7.1-3.2){.pilcrow}
:   

This sub-TLV is silently ignored on reception. It is allowed within any
TLV that allows sub-TLVs.[¶](#section-4.7.1-4){.pilcrow}
:::
:::

::: {#section-4.7.2 .section}
#### [4.7.2.](#section-4.7.2){.section-number .selfRef} [PadN](#name-padn-2){.section-name .selfRef} {#name-padn-2}

::: {#section-4.7.2-1 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Type = 1   |    Length     |      MBZ...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

[¶](#section-4.7.2-1){.pilcrow}
:::

Fields:[¶](#section-4.7.2-2){.pilcrow}

[]{.break}

Type
:   Set to 1 to indicate a PadN
    sub-TLV.[¶](#section-4.7.2-3.2){.pilcrow}
:   

Length
:   The length of the body in octets, exclusive of the Type and Length
    fields.[¶](#section-4.7.2-3.4){.pilcrow}
:   

MBZ
:   Must be zero, set to 0 on
    transmission.[¶](#section-4.7.2-3.6){.pilcrow}
:   

This sub-TLV is silently ignored on reception. It is allowed within any
TLV that allows sub-TLVs.[¶](#section-4.7.2-4){.pilcrow}
:::
:::
:::
:::

::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

IANA has registered the UDP port number 6696, called \"babel\", for use
by the Babel protocol.[¶](#section-5-1){.pilcrow}

IANA has registered the IPv6 multicast group ff02::1:6 and the IPv4
multicast group 224.0.0.111 for use by the Babel
protocol.[¶](#section-5-2){.pilcrow}

IANA has created a registry called \"Babel TLV Types\". The allocation
policy for this registry is Specification Required
\[[RFC8126](#RFC8126){.xref}\] for Types 0-223 and Experimental Use for
Types 224-254. The values in this registry are as
follows:[¶](#section-5-3){.pilcrow}

  Type      Name                                       Reference
  --------- ------------------------------------------ --------------------------------
  0         Pad1                                       RFC 8966
  1         PadN                                       RFC 8966
  2         Acknowledgment Request                     RFC 8966
  3         Acknowledgment                             RFC 8966
  4         Hello                                      RFC 8966
  5         IHU                                        RFC 8966
  6         Router-Id                                  RFC 8966
  7         Next Hop                                   RFC 8966
  8         Update                                     RFC 8966
  9         Route Request                              RFC 8966
  10        Seqno Request                              RFC 8966
  11        TS/PC                                      \[[RFC7298](#RFC7298){.xref}\]
  12        HMAC                                       \[[RFC7298](#RFC7298){.xref}\]
  13        Reserved                                   
  14        Reserved                                   
  15        Reserved                                   
  224-254   Reserved for Experimental Use              RFC 8966
  255       Reserved for expansion of the type space   RFC 8966

  : [Table 1](#table-1){.selfRef}

IANA has created a registry called \"Babel Sub-TLV Types\". The
allocation policy for this registry is Specification Required for Types
0-111 and 128-239, and Experimental Use for Types 112-126 and 240-254.
The values in this registry are as follows:[¶](#section-5-5){.pilcrow}

  Type      Name                                       Reference
  --------- ------------------------------------------ -----------------------------------------------------------------------
  0         Pad1                                       RFC 8966
  1         PadN                                       RFC 8966
  2         Diversity                                  \[[BABEL-DIVERSITY](#I-D.chroboczek-babel-diversity-routing){.xref}\]
  3         Timestamp                                  \[[BABEL-RTT](#I-D.ietf-babel-rtt-extension){.xref}\]
  4-111     Unassigned                                 
  112-126   Reserved for Experimental Use              RFC 8966
  127       Reserved for expansion of the type space   RFC 8966
  128       Source Prefix                              \[[BABEL-SS](#I-D.ietf-babel-source-specific){.xref}\]
  129-239   Unassigned                                 
  240-254   Reserved for Experimental Use              RFC 8966
  255       Reserved for expansion of the type space   RFC 8966

  : [Table 2](#table-2){.selfRef}

IANA has created a registry called \"Babel Address Encodings\". The
allocation policy for this registry is Specification Required for
Address Encodings (AEs) 0-223, and Experimental Use for AEs 224-254. The
values in this registry are as follows:[¶](#section-5-7){.pilcrow}

  AE        Name                                     Reference
  --------- ---------------------------------------- -----------
  0         Wildcard address                         RFC 8966
  1         IPv4 address                             RFC 8966
  2         IPv6 address                             RFC 8966
  3         Link-local IPv6 address                  RFC 8966
  4-223     Unassigned                               
  224-254   Reserved for Experimental Use            RFC 8966
  255       Reserved for expansion of the AE space   RFC 8966

  : [Table 3](#table-3){.selfRef}

IANA has renamed the registry called \"Babel Flags Values\" to \"Babel
Update Flags Values\". The allocation policy for this registry is
Specification Required. The values in this registry are as
follows:[¶](#section-5-9){.pilcrow}

  Bit   Name                Reference
  ----- ------------------- -----------
  0     Default prefix      RFC 8966
  1     Default router-id   RFC 8966
  2-7   Unassigned          

  : [Table 4](#table-4){.selfRef}

IANA has created a new registry called \"Babel Hello Flags Values\". The
allocation policy for this registry is Specification Required. The
initial values in this registry are as
follows:[¶](#section-5-11){.pilcrow}

  Bit    Name         Reference
  ------ ------------ -----------
  0      Unicast      RFC 8966
  1-15   Unassigned   

  : [Table 5](#table-5){.selfRef}

IANA has replaced all references to RFCs 6126 and 7557 in all of the
registries mentioned above with references to this
document.[¶](#section-5-13){.pilcrow}
:::

::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

As defined in this document, Babel is a completely insecure protocol.
Without additional security mechanisms, Babel trusts any information it
receives in plaintext UDP datagrams and acts on it. An attacker that is
present on the local network can impact Babel operation in a variety of
ways; for example they can:[¶](#section-6-1){.pilcrow}

-   [spoof a Babel packet, and redirect traffic by announcing a route
    with a smaller metric, a larger sequence number, or a longer
    prefix;[¶](#section-6-2.1){.pilcrow}]{#section-6-2.1}
-   [spoof a malformed packet, which could cause an insufficiently
    robust implementation to crash or interfere with the rest of the
    network;[¶](#section-6-2.2){.pilcrow}]{#section-6-2.2}
-   [replay a previously captured Babel packet, which could cause
    traffic to be redirected, black-holed, or otherwise interfere with
    the network.[¶](#section-6-2.3){.pilcrow}]{#section-6-2.3}

When carried over IPv6, Babel packets are ignored unless they are sent
from a link-local IPv6 address; since routers don\'t forward link-local
IPv6 packets, this mitigates the attacks outlined above by restricting
them to on-link attackers. No such natural protection exists when Babel
packets are carried over IPv4, which is one of the reasons why it is
recommended to deploy Babel over IPv6 ([Section
3.1](#transmission-reception){.xref}).[¶](#section-6-3){.pilcrow}

It is usually difficult to ensure that packets arriving at a Babel node
are trusted, even in the case where the local link is believed to be
secure. For that reason, it is [RECOMMENDED]{.bcp14} that all Babel
traffic be protected by an application-layer cryptographic protocol.
There are currently two suitable mechanisms, which implement different
trade-offs between implementation simplicity and
security:[¶](#section-6-4){.pilcrow}

-   [Babel over DTLS \[[RFC8968](#RFC8968){.xref}\] runs the majority of
    Babel traffic over DTLS and leverages DTLS to authenticate nodes and
    provide confidentiality and integrity
    protection;[¶](#section-6-5.1){.pilcrow}]{#section-6-5.1}
-   [MAC authentication \[[RFC8967](#RFC8967){.xref}\] appends a message
    authentication code (MAC) to every Babel packet to prove that it
    originated at a node that knows a shared secret, and includes
    sufficient additional information to prove that the packet is fresh
    (not replayed).[¶](#section-6-5.2){.pilcrow}]{#section-6-5.2}

Both mechanisms enable nodes to ignore packets generated by attackers
without the proper credentials. They also ensure integrity of messages
and prevent message replay. While Babel-DTLS supports asymmetric keying
and ensures confidentiality, Babel-MAC has a much more limited scope
(see Sections
[1.1](https://www.rfc-editor.org/rfc/rfc8967#section-1.1){.relref},
[1.2](https://www.rfc-editor.org/rfc/rfc8967#section-1.2){.relref}, and
[7](https://www.rfc-editor.org/rfc/rfc8967#section-7){.relref} of
\[[RFC8967](#RFC8967){.xref}\]). Since Babel-MAC is simpler and more
lightweight, it is recommended in preference to Babel-DTLS in
deployments where its limitations are acceptable, i.e., when symmetric
keying is sufficient and where the routing information is not considered
confidential.[¶](#section-6-6){.pilcrow}

Every implementation of Babel [SHOULD]{.bcp14} implement
BABEL-MAC.[¶](#section-6-7){.pilcrow}

One should be aware that the information that a mobile Babel node
announces to the whole routing domain is sufficient to determine the
mobile node\'s physical location with reasonable precision, which might
cause privacy concerns even if the control traffic is protected from
unauthenticated attackers by a cryptographic mechanism such as
Babel-DTLS. This issue may be mitigated somewhat by using randomly
chosen router-ids and randomly chosen IP addresses, and changing them
often enough.[¶](#section-6-8){.pilcrow}
:::

::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC793\]
:   [Postel, J.]{.refAuthor}, [\"Transmission Control
    Protocol\"]{.refTitle}, [STD 7]{.seriesInfo}, [RFC
    793]{.seriesInfo}, [DOI 10.17487/RFC0793]{.seriesInfo}, September
    1981, \<<https://www.rfc-editor.org/info/rfc793>\>.
:   

\[RFC8126\]
:   [Cotton, M.]{.refAuthor}[, Leiba, B.]{.refAuthor}[, and T.
    Narten]{.refAuthor}, [\"Guidelines for Writing an IANA
    Considerations Section in RFCs\"]{.refTitle}, [BCP 26]{.seriesInfo},
    [RFC 8126]{.seriesInfo}, [DOI 10.17487/RFC8126]{.seriesInfo}, June
    2017, \<<https://www.rfc-editor.org/info/rfc8126>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8967\]
:   [Dô, C.]{.refAuthor}[, Kolodziejak, W.]{.refAuthor}[, and J.
    Chroboczek]{.refAuthor}, [\"MAC Authentication for the Babel Routing
    Protocol\"]{.refTitle}, [RFC 8967]{.seriesInfo}, [DOI
    10.17487/RFC8967]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8967>\>.
:   
:::

::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[BABEL-DIVERSITY\]
:   [Chroboczek, J.]{.refAuthor}, [\"Diversity Routing for the Babel
    Routing Protocol\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft,
    draft-chroboczek-babel-diversity-routing-01]{.seriesInfo}, 15
    February 2016,
    \<<https://tools.ietf.org/html/draft-chroboczek-babel-diversity-routing-01>\>.
:   

\[BABEL-RTT\]
:   [Jonglez, B.]{.refAuthor}[ and J. Chroboczek]{.refAuthor},
    [\"Delay-based Metric Extension for the Babel Routing
    Protocol\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-babel-rtt-extension-00]{.seriesInfo}, 26
    April 2019,
    \<<https://tools.ietf.org/html/draft-ietf-babel-rtt-extension-00>\>.
:   

\[BABEL-SS\]
:   [Boutier, M.]{.refAuthor}[ and J. Chroboczek]{.refAuthor},
    [\"Source-Specific Routing in Babel\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-babel-source-specific-07]{.seriesInfo}, 28 October 2020,
    \<<https://tools.ietf.org/html/draft-ietf-babel-source-specific-07>\>.
:   

\[DSDV\]
:   [Perkins, C.]{.refAuthor}[ and P. Bhagwat]{.refAuthor}, [\"Highly
    dynamic Destination-Sequenced Distance-Vector routing (DSDV) for
    mobile computers\"]{.refTitle}, [ACM SIGCOMM \'94: Proceedings of
    the conference on Communications architectures, protocols and
    applications]{.refContent}, [234-244]{.refContent}, [DOI
    10.1145/190314.190336]{.seriesInfo}, October 1994,
    \<<https://doi.org/10.1145/190314.190336>\>.
:   

\[DUAL\]
:   [Garcia Luna Aceves, J. J.]{.refAuthor}, [\"Loop-free routing using
    diffusing computations\"]{.refTitle}, [IEEE/ACM Transactions on
    Networking]{.refContent}, [1:1]{.refContent}, [DOI
    10.1109/90.222913]{.seriesInfo}, February 1993,
    \<<https://doi.org/10.1109/90.222913>\>.
:   

\[EIGRP\]
:   [Albrightson, B.]{.refAuthor}[, Garcia Luna Aceves, J.
    J.]{.refAuthor}[, and J. Boyle]{.refAuthor}, [\"EIGRP \-- a Fast
    Routing Protocol Based on Distance Vectors\"]{.refTitle}, [Proc.
    Networld/Interop 94]{.refContent}, 1994.
:   

\[ETX\]
:   [De Couto, D.]{.refAuthor}[, Aguayo, D.]{.refAuthor}[,
    Bicket, J.]{.refAuthor}[, and R. Morris]{.refAuthor}, [\"A
    high-throughput path metric for multi-hop wireless
    networks\"]{.refTitle}, [MobiCom \'03: Proceedings of the 9th annual
    international conference on Mobile computing and
    networking]{.refContent}, [134-146]{.refContent}, [DOI
    10.1145/938985.939000]{.seriesInfo}, September 2003,
    \<<https://doi.org/10.1145/938985.939000>\>.
:   

\[IEEE802.11\]
:   [IEEE]{.refAuthor}, [\"IEEE Standard for Information
    technology\--Telecommunications and information exchange between
    systems Local and metropolitan area networks\--Specific requirements
    Part 11: Wireless LAN Medium Access Control (MAC) and Physical Layer
    (PHY) Specifications\"]{.refTitle}, [IEEE 802.11-2012]{.seriesInfo},
    [DOI 10.1109/ieeestd.2012.6178212]{.seriesInfo}, April 2012,
    \<<https://doi.org/10.1109/ieeestd.2012.6178212>\>.
:   

\[IEN137\]
:   [Cohen, D.]{.refAuthor}, [\"On Holy Wars and a Plea for
    Peace\"]{.refTitle}, [IEN 137]{.seriesInfo}, 1 April 1980.
:   

\[IS-IS\]
:   [International Organization for Standardization]{.refAuthor},
    [\"Information technology \-- Telecommunications and information
    exchange between systems \-- Intermediate System to Intermediate
    System intra-domain routeing information exchange protocol for use
    in conjunction with the protocol for providing the
    connectionless-mode network service (ISO 8473)\"]{.refTitle},
    [ISO/IEC 10589:2002]{.refContent}, 2002.
:   

\[JITTER\]
:   [Floyd, S.]{.refAuthor}[ and V. Jacobson]{.refAuthor}, [\"The
    Synchronization of Periodic Routing Messages\"]{.refTitle},
    [IEEE/ACM Transactions on Networking]{.refContent}, [2, 2,
    122-136]{.refContent}, [DOI 10.1109/90.298431]{.seriesInfo}, April
    1994, \<<https://doi.org/10.1109/90.298431>\>.
:   

\[OSPF\]
:   [Moy, J.]{.refAuthor}, [\"OSPF Version 2\"]{.refTitle}, [STD
    54]{.seriesInfo}, [RFC 2328]{.seriesInfo}, [DOI
    10.17487/RFC2328]{.seriesInfo}, April 1998,
    \<<https://www.rfc-editor.org/info/rfc2328>\>.
:   

\[PACKETBB\]
:   [Clausen, T.]{.refAuthor}[, Dearlove, C.]{.refAuthor}[,
    Dean, J.]{.refAuthor}[, and C. Adjih]{.refAuthor}, [\"Generalized
    Mobile Ad Hoc Network (MANET) Packet/Message Format\"]{.refTitle},
    [RFC 5444]{.seriesInfo}, [DOI 10.17487/RFC5444]{.seriesInfo},
    February 2009, \<<https://www.rfc-editor.org/info/rfc5444>\>.
:   

\[RFC2675\]
:   [Borman, D.]{.refAuthor}[, Deering, S.]{.refAuthor}[, and R.
    Hinden]{.refAuthor}, [\"IPv6 Jumbograms\"]{.refTitle}, [RFC
    2675]{.seriesInfo}, [DOI 10.17487/RFC2675]{.seriesInfo}, August
    1999, \<<https://www.rfc-editor.org/info/rfc2675>\>.
:   

\[RFC3561\]
:   [Perkins, C.]{.refAuthor}[, Belding-Royer, E.]{.refAuthor}[, and S.
    Das]{.refAuthor}, [\"Ad hoc On-Demand Distance Vector (AODV)
    Routing\"]{.refTitle}, [RFC 3561]{.seriesInfo}, [DOI
    10.17487/RFC3561]{.seriesInfo}, July 2003,
    \<<https://www.rfc-editor.org/info/rfc3561>\>.
:   

\[RFC6126\]
:   [Chroboczek, J.]{.refAuthor}, [\"The Babel Routing
    Protocol\"]{.refTitle}, [RFC 6126]{.seriesInfo}, [DOI
    10.17487/RFC6126]{.seriesInfo}, April 2011,
    \<<https://www.rfc-editor.org/info/rfc6126>\>.
:   

\[RFC7298\]
:   [Ovsienko, D.]{.refAuthor}, [\"Babel Hashed Message Authentication
    Code (HMAC) Cryptographic Authentication\"]{.refTitle}, [RFC
    7298]{.seriesInfo}, [DOI 10.17487/RFC7298]{.seriesInfo}, July 2014,
    \<<https://www.rfc-editor.org/info/rfc7298>\>.
:   

\[RFC7557\]
:   [Chroboczek, J.]{.refAuthor}, [\"Extension Mechanism for the Babel
    Routing Protocol\"]{.refTitle}, [RFC 7557]{.seriesInfo}, [DOI
    10.17487/RFC7557]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7557>\>.
:   

\[RFC8968\]
:   [Décimo, A.]{.refAuthor}[, Schinazi, D.]{.refAuthor}[, and J.
    Chroboczek]{.refAuthor}, [\"Babel Routing Protocol over Datagram
    Transport Layer Security\"]{.refTitle}, [RFC 8968]{.seriesInfo},
    [DOI 10.17487/RFC8968]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8968>\>.
:   

\[RIP\]
:   [Malkin, G.]{.refAuthor}, [\"RIP Version 2\"]{.refTitle}, [STD
    56]{.seriesInfo}, [RFC 2453]{.seriesInfo}, [DOI
    10.17487/RFC2453]{.seriesInfo}, November 1998,
    \<<https://www.rfc-editor.org/info/rfc2453>\>.
:   
:::
:::

::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Cost and Metric Computation](#name-cost-and-metric-computation){.section-name .selfRef} {#name-cost-and-metric-computation}

The strategy for computing link costs and route metrics is a local
matter; Babel itself only requires that it comply with the conditions
given in [Section 3.4.3](#cost-computation){.xref} and [Section
3.5.2](#metric-computation){.xref}. Different nodes may use different
strategies in a single network and may use different strategies on
different interface types. This section describes a set of strategies
that have been found to work well in actual
networks.[¶](#section-appendix.a-1){.pilcrow}

In summary, a node maintains per-neighbour statistics about the last 16
received Hello TLVs of each kind ([Appendix
A.1](#hello-history){.xref}), it computes costs by using the 2-out-of-3
strategy ([Appendix A.2.1](#k-j){.xref}) on wired links and Expected
Transmission Cost (ETX) ([Appendix A.2.2](#etx){.xref}) on wireless
links. It uses an additive algebra for metric computation ([Section
3.5.2](#metric-computation){.xref}).[¶](#section-appendix.a-2){.pilcrow}

::: {#hello-history}
::: {#section-a.1 .section}
## [A.1.](#section-a.1){.section-number .selfRef} [Maintaining Hello History](#name-maintaining-hello-history){.section-name .selfRef} {#name-maintaining-hello-history}

For each neighbour, a node maintains two sets of Hello history, one for
each kind of Hello, and an expected sequence number, one for Multicast
and one for Unicast Hellos. Each Hello history is a vector of 16 bits,
where a 1 value represents a received Hello, and a 0 value a missed
Hello. For each kind of Hello, the expected sequence number, written ne,
is the sequence number that is expected to be carried by the next
received Hello from this neighbour.[¶](#section-a.1-1){.pilcrow}

Whenever it receives a Hello packet of a given kind from a neighbour, a
node compares the received sequence number nr for that kind of Hello
with its expected sequence number ne. Depending on the outcome of this
comparison, one of the following actions is
taken:[¶](#section-a.1-2){.pilcrow}

-   [if the two differ by more than 16 (modulo 2^16^), then the sending
    node has probably rebooted and lost its sequence number; the whole
    associated neighbour table entry is flushed and a new one is
    created;[¶](#section-a.1-3.1){.pilcrow}]{#section-a.1-3.1}
-   [otherwise, if the received nr is smaller (modulo 2^16^) than the
    expected sequence number ne, then the sending node has increased its
    Hello interval without our noticing; the receiving node removes the
    last (ne - nr) entries from this neighbour\'s Hello history (we
    \"undo history\");[¶](#section-a.1-3.2){.pilcrow}]{#section-a.1-3.2}
-   [otherwise, if nr is larger (modulo 2^16^) than ne, then the sending
    node has decreased its Hello interval, and some Hellos were lost;
    the receiving node adds (nr - ne) 0 bits to the Hello history (we
    \"fast-forward\").[¶](#section-a.1-3.3){.pilcrow}]{#section-a.1-3.3}

The receiving node then appends a 1 bit to the Hello history and sets ne
to (nr + 1). If the Interval field of the received Hello is not zero, it
resets the neighbour\'s hello timer to 1.5 times the advertised Interval
(the extra margin allows for delay due to
jitter).[¶](#section-a.1-4){.pilcrow}

Whenever either hello timer associated with a neighbour expires, the
local node adds a 0 bit to the corresponding Hello history, and
increments the expected Hello number. If both Hello histories are empty
(they contain 0 bits only), the neighbour entry is flushed; otherwise,
the relevant hello timer is reset to the value advertised in the last
Hello of that kind received from this neighbour (no extra margin is
necessary in this case, since jitter was already taken into account when
computing the timeout that has just
expired).[¶](#section-a.1-5){.pilcrow}
:::
:::

::: {#cost-computation-examples}
::: {#section-a.2 .section}
## [A.2.](#section-a.2){.section-number .selfRef} [Cost Computation](#name-cost-computation-2){.section-name .selfRef} {#name-cost-computation-2}

This section describes two algorithms suitable for computing costs
([Section 3.4.3](#cost-computation){.xref}) based on Hello history.
[Appendix A.2.1](#k-j){.xref} applies to wired links and [Appendix
A.2.2](#etx){.xref} to wireless links. [RECOMMENDED]{.bcp14} default
values of the parameters that appear in these algorithms are given in
[Appendix B](#parameters){.xref}.[¶](#section-a.2-1){.pilcrow}

::: {#k-j}
::: {#section-a.2.1 .section}
### [A.2.1.](#section-a.2.1){.section-number .selfRef} [k-out-of-j](#name-k-out-of-j){.section-name .selfRef} {#name-k-out-of-j}

K-out-of-j link sensing is suitable for wired links that are either up,
in which case they only occasionally drop a packet, or down, in which
case they drop all packets.[¶](#section-a.2.1-1){.pilcrow}

The k-out-of-j strategy is parameterised by two small integers k and j,
such that 0 \< k \<= j, and the nominal link cost, a constant C \>= 1. A
node keeps a history of the last j hellos; if k or more of those have
been correctly received, the link is assumed to be up, and the rxcost is
set to C; otherwise, the link is assumed to be down, and the rxcost is
set to infinity.[¶](#section-a.2.1-2){.pilcrow}

Since Babel supports two kinds of Hellos, a Babel node performs
k-out-of-j twice for each neighbour, once on the Unicast Hello history
and once on the Multicast Hello history. If either of the instances of
k-out-of-j indicates that the link is up, then the link is assumed to be
up, and the rxcost is set to C; if both instances indicate that the link
is down, then the link is assumed to be down, and the rxcost is set to
infinity. In other words, the resulting rxcost is the minimum of the
rxcosts yielded by the two instances of k-out-of-j link
sensing.[¶](#section-a.2.1-3){.pilcrow}

The cost of a link performing k-out-of-j link sensing is defined as
follows:[¶](#section-a.2.1-4){.pilcrow}

-   [cost = FFFF hexadecimal if rxcost = FFFF
    hexadecimal;[¶](#section-a.2.1-5.1){.pilcrow}]{#section-a.2.1-5.1}
-   [cost = txcost
    otherwise.[¶](#section-a.2.1-5.2){.pilcrow}]{#section-a.2.1-5.2}
:::
:::

::: {#etx}
::: {#section-a.2.2 .section}
### [A.2.2.](#section-a.2.2){.section-number .selfRef} [ETX](#name-etx){.section-name .selfRef} {#name-etx}

Unlike wired links which are bimodal (either up or down), wireless links
exhibit continuous variation of the link quality. Naive application of
hop-count routing in networks that use wireless links for transit tends
to select long, lossy links in preference to shorter, lossless links,
which can dramatically reduce throughput. For that reason, a routing
protocol designed to support wireless links must perform some form of
link quality estimation.[¶](#section-a.2.2-1){.pilcrow}

The Expected Transmission Cost algorithm, or ETX \[[ETX](#ETX){.xref}\],
is a simple link quality estimation algorithm that is designed to work
well with the IEEE 802.11 MAC \[[IEEE802.11](#IEEE802.11){.xref}\]. By
default, the IEEE 802.11 MAC performs Automatic Repeat Query (ARQ) and
rate adaptation on unicast frames, but not on multicast frames, which
are sent at a fixed rate with no ARQ; therefore, measuring the loss rate
of multicast frames yields a useful estimate of a link\'s
quality.[¶](#section-a.2.2-2){.pilcrow}

A node performing ETX link quality estimation uses a neighbour\'s
Multicast Hello history to compute an estimate, written beta, of the
probability that a Hello TLV is successfully received. Beta can be
computed as the fraction of 1 bits within a small number (say, 6) of the
most recent entries in the Multicast Hello history, or it can be an
exponential average, or some combination of both approaches. Let rxcost
be 256/beta.[¶](#section-a.2.2-3){.pilcrow}

Let alpha be MIN(1, 256/txcost), an estimate of the probability of
successfully sending a Hello TLV. The cost is then computed
by[¶](#section-a.2.2-4){.pilcrow}

cost = 256/(alpha \* beta)[¶](#section-a.2.2-5){.pilcrow}

or, equivalently,[¶](#section-a.2.2-6){.pilcrow}

cost = (MAX(txcost, 256) \* rxcost) /
256.[¶](#section-a.2.2-7){.pilcrow}

Since the IEEE 802.11 MAC performs ARQ on unicast frames, unicast frames
do not provide a useful measure of link quality, and therefore ETX
ignores the Unicast Hello history. Thus, a node performing ETX link
quality estimation will not route through neighbouring nodes unless they
send periodic Multicast Hellos (possibly in addition to Unicast
Hellos).[¶](#section-a.2.2-8){.pilcrow}
:::
:::
:::
:::

::: {#route-selection-hysteresis}
::: {#section-a.3 .section}
## [A.3.](#section-a.3){.section-number .selfRef} [Route Selection and Hysteresis](#name-route-selection-and-hystere){.section-name .selfRef} {#name-route-selection-and-hystere}

Route selection ([Section 3.6](#route-selection){.xref}) is the process
by which a node selects a single route among the routes that it has
available towards a given destination. With Babel, any route selection
procedure that only ever chooses feasible routes with a finite metric
will yield a set of loop-free routes; however, in the presence of
continuously variable metrics such as ETX ([Appendix
A.2.2](#etx){.xref}), a naive route selection procedure might lead to
persistent oscillations. Such oscillations can be limited or avoided
altogether by implementing hysteresis within the route selection
algorithm, i.e., by making the route selection algorithm sensitive to a
route\'s history. Any reasonable hysteresis algorithm should yield good
results; the following algorithm is simple to implement and has been
successfully deployed in a variety of
environments.[¶](#section-a.3-1){.pilcrow}

For every route R, in addition to the route\'s metric m(R), maintain a
smoothed version of m(R) written ms(R) (we RECOMMEND computing ms(R) as
an exponentially smoothed average (see [Section
3.7](https://www.rfc-editor.org/rfc/rfc793#section-3.7){.relref} of
\[[RFC793](#RFC0793){.xref}\]) of m(R) with a time constant equal to the
Hello interval multiplied by a small number such as 3). If no route to a
given destination is selected, then select the route with the smallest
metric, ignoring the smoothed metric. If a route R is selected, then
switch to a route R\' only when both m(R\') \< m(R) and
ms(R\') \< ms(R).[¶](#section-a.3-2){.pilcrow}

Intuitively, the smoothed metric is a long-term estimate of the quality
of a route. The algorithm above works by only switching routes when both
the instantaneous and the long-term estimates of the route\'s quality
indicate that switching is profitable.[¶](#section-a.3-3){.pilcrow}
:::
:::
:::

::: {#parameters}
::: {#section-appendix.b .section}
## [Appendix B.](#section-appendix.b){.section-number .selfRef} [Protocol Parameters](#name-protocol-parameters){.section-name .selfRef} {#name-protocol-parameters}

The choice of time constants is a trade-off between fast detection of
mobility events and protocol overhead. Two instances of Babel running
with different time constants will interoperate, although the resulting
worst-case convergence time will be dictated by the slower of the
two.[¶](#section-appendix.b-1){.pilcrow}

The Hello interval is the most important time constant: an outage or a
mobility event is detected within 1.5 to 3.5 Hello intervals. Due to
Babel\'s use of a redundant route table, and due to its reliance on
triggered updates and explicit requests, the Update interval has little
influence on the time needed to reconverge after an outage: in practice,
it only has a significant effect on the time needed to acquire new
routes after a mobility event. While the protocol allows intervals as
low as 10 ms, such low values would cause significant amounts of
protocol traffic for little practical
benefit.[¶](#section-appendix.b-2){.pilcrow}

The following values have been found to work well in a variety of
environments and are therefore [RECOMMENDED]{.bcp14} default
values:[¶](#section-appendix.b-3){.pilcrow}

[]{.break}

Multicast Hello interval:
:   4 seconds.[¶](#section-appendix.b-4.2){.pilcrow}
:   

Unicast Hello interval:
:   infinite (no Unicast Hellos are
    sent).[¶](#section-appendix.b-4.4){.pilcrow}
:   

Link cost:
:   estimated using ETX on wireless links; 2-out-of-3 with C=96 on wired
    links.[¶](#section-appendix.b-4.6){.pilcrow}
:   

IHU interval:
:   the advertised IHU interval is always 3 times the Multicast Hello
    interval. IHUs are actually sent with each Hello on lossy links (as
    determined from the Hello history), but only with every third
    Multicast Hello on lossless
    links.[¶](#section-appendix.b-4.8){.pilcrow}
:   

Update interval:
:   4 times the Multicast Hello
    interval.[¶](#section-appendix.b-4.10){.pilcrow}
:   

IHU Hold time:
:   3.5 times the advertised IHU
    interval.[¶](#section-appendix.b-4.12){.pilcrow}
:   

Route Expiry time:
:   3.5 times the advertised update
    interval.[¶](#section-appendix.b-4.14){.pilcrow}
:   

Request timeout:
:   initially 2 seconds, doubled every time a request is resent, up to a
    maximum of three times.[¶](#section-appendix.b-4.16){.pilcrow}
:   

Urgent timeout:
:   0.2 seconds.[¶](#section-appendix.b-4.18){.pilcrow}
:   

Source GC time:
:   3 minutes.[¶](#section-appendix.b-4.20){.pilcrow}
:   
:::
:::

::: {#filtering}
::: {#section-appendix.c .section}
## [Appendix C.](#section-appendix.c){.section-number .selfRef} [Route Filtering](#name-route-filtering){.section-name .selfRef} {#name-route-filtering}

Route filtering is a procedure where an instance of a routing protocol
either discards some of the routes announced by its neighbours or learns
them with a metric that is higher than what would be expected. Like all
distance-vector protocols, Babel has the ability to apply arbitrary
filtering to the routes it learns, and implementations of Babel that
apply different sets of filtering rules will interoperate without
causing routing loops. The protocol\'s ability to perform route
filtering is a consequence of the latitude given in [Section
3.5.2](#metric-computation){.xref}: Babel can use any metric that is
strictly monotonic, including one that assigns an infinite metric to a
selected subset of routes. (See also [Section
3.8.1](#handling-requests){.xref}, where requests for nonexistent routes
are treated in the same way as requests for routes with infinite
metric.)[¶](#section-appendix.c-1){.pilcrow}

It is not in general correct to learn a route with a metric smaller than
the one it was announced with, or to replace a route\'s destination
prefix with a more specific (longer) one. Doing either of these may
cause persistent routing loops.[¶](#section-appendix.c-2){.pilcrow}

Route filtering is a useful tool, since it allows fine-grained tuning of
the routing decisions made by the routing protocol. Accordingly, some
implementations of Babel implement a rich configuration language that
allows applying filtering to sets of routes defined, for example, by
incoming interface and destination
prefix.[¶](#section-appendix.c-3){.pilcrow}

In order to limit the consequences of misconfiguration, Babel
implementations provide a reasonable set of default filtering rules even
when they don\'t allow configuration of filtering by the user. At a
minimum, they discard routes with a destination prefix in fe80::/64,
ff00::/8, 127.0.0.1/32, 0.0.0.0/32, and
224.0.0.0/8.[¶](#section-appendix.c-4){.pilcrow}
:::
:::

::: {#extensions}
::: {#section-appendix.d .section}
## [Appendix D.](#section-appendix.d){.section-number .selfRef} [Considerations for Protocol Extensions](#name-considerations-for-protocol){.section-name .selfRef} {#name-considerations-for-protocol}

Babel is an extensible protocol, and this document defines a number of
mechanisms that can be used to extend the protocol in a backwards
compatible manner:[¶](#section-appendix.d-1){.pilcrow}

-   [increasing the version number in the packet
    header;[¶](#section-appendix.d-2.1){.pilcrow}]{#section-appendix.d-2.1}
-   [defining new
    TLVs;[¶](#section-appendix.d-2.2){.pilcrow}]{#section-appendix.d-2.2}
-   [defining new sub-TLVs (with or without the mandatory bit
    set);[¶](#section-appendix.d-2.3){.pilcrow}]{#section-appendix.d-2.3}
-   [defining new
    AEs;[¶](#section-appendix.d-2.4){.pilcrow}]{#section-appendix.d-2.4}
-   [using the packet
    trailer.[¶](#section-appendix.d-2.5){.pilcrow}]{#section-appendix.d-2.5}

This appendix is intended to guide designers of protocol extensions in
choosing a particular encoding.[¶](#section-appendix.d-3){.pilcrow}

The version number in the Babel header should only be increased if the
new version is not backwards compatible with the original
protocol.[¶](#section-appendix.d-4){.pilcrow}

In many cases, an extension could be implemented either by defining a
new TLV or by adding a new sub-TLV to an existing TLV. For example, an
extension whose purpose is to attach additional data to route updates
can be implemented either by creating a new \"enriched\" Update TLV, by
adding a nonmandatory sub-TLV to the Update TLV, or by adding a
mandatory sub-TLV.[¶](#section-appendix.d-5){.pilcrow}

The various encodings are treated differently by implementations that do
not understand the extension. In the case of a new TLV or of a sub-TLV
with the mandatory bit set, the whole TLV is ignored by implementations
that do not implement the extension, while in the case of a nonmandatory
sub-TLV, the TLV is parsed and acted upon, and only the unknown sub-TLV
is silently ignored. Therefore, a nonmandatory sub-TLV should be used by
extensions that extend the Update in a compatible manner (the extension
data may be silently ignored), while a mandatory sub-TLV or a new TLV
must be used by extensions that make incompatible extensions to the
meaning of the TLV (the whole TLV must be thrown away if the extension
data is not understood).[¶](#section-appendix.d-6){.pilcrow}

Experience shows that the need for additional data tends to crop up in
the most unexpected places. Hence, it is recommended that extensions
that define new TLVs should make them self-terminating and allow
attaching sub-TLVs to them.[¶](#section-appendix.d-7){.pilcrow}

Adding a new AE is essentially equivalent to adding a new TLV: Update
TLVs with an unknown AE are ignored, just like unknown TLVs. However,
adding a new AE is more involved than adding a new TLV, since it creates
a new set of compression state. Additionally, since the Next Hop TLV
creates state specific to a given address family, as opposed to a given
AE, a new AE for a previously defined address family must not be used in
the Next Hop TLV if backwards compatibility is required. A similar issue
arises with Update TLVs with unknown AEs establishing a new router-id
(due to the Router-Id flag being set). Therefore, defining new AEs must
be done with care if compatibility with unextended implementations is
required.[¶](#section-appendix.d-8){.pilcrow}

The packet trailer is intended to carry cryptographic signatures that
only cover the packet body; storing the cryptographic signatures in the
packet trailer avoids clearing the signature before computing a hash of
the packet body, and makes it possible to check a cryptographic
signature before running the full, stateful TLV parser. Hence, only TLVs
that don\'t need to be protected by cryptographic security protocols
should be allowed in the packet trailer. Any such TLVs should be easy to
parse and, in particular, should not require stateful
parsing.[¶](#section-appendix.d-9){.pilcrow}
:::
:::

::: {#section-appendix.e .section}
## [Appendix E.](#section-appendix.e){.section-number .selfRef} [Stub Implementations](#name-stub-implementations){.section-name .selfRef} {#name-stub-implementations}

Babel is a fairly economic protocol. Updates take between 12 and 40
octets per destination, depending on the address family and how
successful compression is; in a dual-stack flat network, an average of
less than 24 octets per update is typical. The route table occupies
about 35 octets per IPv6 entry. To put these values into perspective, a
single full-size Ethernet frame can carry some 65 route updates, and a
megabyte of memory can contain a 20,000-entry route table and the
associated source table.[¶](#section-appendix.e-1){.pilcrow}

Babel is also a reasonably simple protocol. One complete implementation
consists of less than 12,000 lines of C code, and it compiles to less
than 120 KB of text on a 32-bit CISC architecture; about half of this
figure is due to protocol extensions and user-interface
code.[¶](#section-appendix.e-2){.pilcrow}

Nonetheless, in some very constrained environments, such as PDAs,
microwave ovens, or abacuses, it may be desirable to have subset
implementations of the protocol.[¶](#section-appendix.e-3){.pilcrow}

There are many different definitions of a stub router, but for the needs
of this section, a stub implementation of Babel is one that announces
one or more directly attached prefixes into a Babel network but doesn\'t
re-announce any routes that it has learnt from its neighbours, and
always prefers the direct route to a directly attached prefix to a route
learnt over the Babel protocol, even when the prefixes are the same. It
may either maintain a full routing table or simply select a default
gateway through any one of its neighbours that announces a default
route. Since a stub implementation never forwards packets except from or
to a directly attached link, it cannot possibly participate in a routing
loop, and hence it need not evaluate the feasibility condition or
maintain a source table.[¶](#section-appendix.e-4){.pilcrow}

No matter how primitive, a stub implementation must parse sub-TLVs
attached to any TLVs that it understands and check the mandatory bit. It
must answer acknowledgment requests and must participate in the
Hello/IHU protocol. It must also be able to reply to seqno requests for
routes that it announces, and it should be able to reply to route
requests.[¶](#section-appendix.e-5){.pilcrow}

Experience shows that an IPv6-only stub implementation of Babel can be
written in less than 1,000 lines of C code and compile to 13 KB of text
on 32-bit CISC architecture.[¶](#section-appendix.e-6){.pilcrow}
:::

::: {#section-appendix.f .section}
## [Appendix F.](#section-appendix.f){.section-number .selfRef} [Compatibility with Previous Versions](#name-compatibility-with-previous){.section-name .selfRef} {#name-compatibility-with-previous}

The protocol defined in this document is a successor to the protocol
defined in \[[RFC6126](#RFC6126){.xref}\] and
\[[RFC7557](#RFC7557){.xref}\]. While the two protocols are not entirely
compatible, the new protocol has been designed so that it can be
deployed in existing RFC 6126 networks without requiring a flag
day.[¶](#section-appendix.f-1){.pilcrow}

There are three optional features that make this protocol incompatible
with its predecessor. First of all, RFC 6126 did not define Unicast
Hellos ([Section 3.4.1](#reverse-reachability){.xref}), and an
implementation of RFC 6126 will misinterpret a Unicast Hello for a
Multicast one; since the sequence number space of Unicast Hellos is
distinct from the sequence number space of Multicast Hellos, sending a
Unicast Hello to an implementation of RFC 6126 will confuse its link
quality estimator. Second, RFC 6126 did not define unscheduled Hellos,
and an implementation of RFC 6126 will mis-parse Hellos with an interval
equal to 0. Finally, RFC 7557 did not define mandatory sub-TLVs
([Section 4.4](#sub-tlv-format){.xref}), and thus an implementation of
RFCs 6126 and 7557 will not correctly ignore a TLV that carries an
unknown mandatory sub-TLV; depending on the sub-TLV, this might cause
routing pathologies.[¶](#section-appendix.f-2){.pilcrow}

An implementation of this specification that never sends Unicast or
unscheduled Hellos and doesn\'t implement any extensions that use
mandatory sub-TLVs is safe to deploy in a network in which some nodes
implement the protocol described in RFCs 6126 and
7557.[¶](#section-appendix.f-3){.pilcrow}

Two changes need to be made to an implementation of RFCs 6126 and 7557
so that it can safely interoperate in all cases with implementations of
this protocol. First, it needs to be modified either to ignore or to
process Unicast and unscheduled Hellos. Second, it needs to be modified
to parse sub-TLVs of all the TLVs that it understands and that allow
sub-TLVs, and to ignore the TLV if an unknown mandatory sub-TLV is
found. It is not necessary to parse unknown TLVs, as these are ignored
in any case.[¶](#section-appendix.f-4){.pilcrow}

There are other changes, but these are not of a nature to prevent
interoperability:[¶](#section-appendix.f-5){.pilcrow}

-   [the conditions on route acquisition ([Section
    3.5.3](#route-acquisition){.xref}) have been
    relaxed;[¶](#section-appendix.f-6.1){.pilcrow}]{#section-appendix.f-6.1}
-   [route selection should no longer use the route\'s sequence number
    ([Section
    3.6](#route-selection){.xref});[¶](#section-appendix.f-6.2){.pilcrow}]{#section-appendix.f-6.2}
-   [the format of the packet trailer has been defined ([Section
    4.2](#packet-format){.xref});[¶](#section-appendix.f-6.3){.pilcrow}]{#section-appendix.f-6.3}
-   [router-ids with a value of all-zeros or all-ones have been
    forbidden ([Section
    4.1.3](#router-id-def){.xref});[¶](#section-appendix.f-6.4){.pilcrow}]{#section-appendix.f-6.4}
-   [the compression state is now specific to an address family rather
    than an address encoding ([Section
    4.5](#parser-state){.xref});[¶](#section-appendix.f-6.5){.pilcrow}]{#section-appendix.f-6.5}
-   [packet pacing is now recommended ([Section
    3.1](#transmission-reception){.xref}).[¶](#section-appendix.f-6.6){.pilcrow}]{#section-appendix.f-6.6}
:::

::: {#section-appendix.g .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

A number of people have contributed text and ideas to this
specification. The authors are particularly indebted to [Matthieu
Boutier]{.contact-name}, [Gwendoline Chouasne]{.contact-name}, [Margaret
Cullen]{.contact-name}, [Donald Eastlake]{.contact-name}, [Toke
Høiland-Jørgensen]{.contact-name}, [Benjamin Kaduk]{.contact-name},
[Joao Sobrinho]{.contact-name}, and [Martin Vigoureux]{.contact-name}.
The previous version of this specification
\[[RFC6126](#RFC6126){.xref}\] greatly benefited from the input of [Joel
Halpern]{.contact-name}. The address compression technique was inspired
by \[[PACKETBB](#RFC5444){.xref}\].[¶](#section-appendix.g-1){.pilcrow}
:::

::: {#authors-addresses}
::: {#section-appendix.h .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Juliusz Chroboczek]{.fn .nameRole}
:::

::: {.left dir="auto"}
[IRIF, University of Paris-Diderot]{.org}
:::

::: {.left dir="auto"}
[Case 7014]{.street-address}
:::

::: {.left dir="auto"}
[75205]{.postal-code} [Paris CEDEX 13]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <jch@irif.fr>
:::

::: {.left dir="auto"}
[David Schinazi]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google LLC]{.org}
:::

::: {.left dir="auto"}
[1600 Amphitheatre Parkway]{.street-address}
:::

::: {.left dir="auto"}
[Mountain View]{.locality}, [California]{.region} [94043]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <dschinazi.ietf@gmail.com>
:::
:::
:::
