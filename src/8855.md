  RFC 8855            BFCP              January 2021
  ------------------- ----------------- --------------
  Camarillo, et al.   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8855](https://www.rfc-editor.org/rfc/rfc8855){.eref}

Obsoletes:
:   [4582](https://www.rfc-editor.org/rfc/rfc4582){.eref}

Category:
:   Standards Track

Published:
:   January 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    G. Camarillo
    :::

    ::: org
    Ericsson
    :::
    :::

    ::: author
    ::: author-name
    K. Drage
    :::
    :::

    ::: author
    ::: author-name
    T. Kristensen
    :::

    ::: org
    Jotron
    :::
    :::

    ::: author
    ::: author-name
    J. Ott
    :::

    ::: org
    Technical University Munich
    :::
    :::

    ::: author
    ::: author-name
    C. Eckel
    :::

    ::: org
    Cisco
    :::
    :::
:::

# RFC 8855 {#rfcnum}

# The Binary Floor Control Protocol (BFCP) {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

Floor control is a means to manage joint or exclusive access to shared
resources in a (multiparty) conferencing environment. Thereby, floor
control complements other functions \-- such as conference and media
session setup, conference policy manipulation, and media control \--
that are realized by other protocols.[¶](#section-abstract-1){.pilcrow}

This document specifies the Binary Floor Control Protocol (BFCP). BFCP
is used between floor participants and floor control servers, and
between floor chairs (i.e., moderators) and floor control
servers.[¶](#section-abstract-2){.pilcrow}

This document obsoletes RFC 4582.[¶](#section-abstract-3){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8855>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Scope](#name-scope){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Floor
        Creation](#name-floor-creation){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Obtaining Information to Contact a
        Floor Control
        Server](#name-obtaining-information-to-co){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Obtaining Floor-Resource
        Associations](#name-obtaining-floor-resource-as){.xref}[¶](#section-toc.1-1.3.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [Privileges of Floor
        Control](#name-privileges-of-floor-control){.xref}[¶](#section-toc.1-1.3.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Overview of
    Operation](#name-overview-of-operation){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Floor Participant to Floor Control
        Server
        Interface](#name-floor-participant-to-floor-){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Floor Chair to Floor Control
        Server
        Interface](#name-floor-chair-to-floor-contro){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Packet
    Format](#name-packet-format){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [COMMON-HEADER
        Format](#name-common-header-format){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Attribute
        Format](#name-attribute-format){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.5.2.2.2.1}
            [5.2.1](#section-5.2.1){.xref}.  [BENEFICIARY-ID](#name-beneficiary-id){.xref}[¶](#section-toc.1-1.5.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.2}
            [5.2.2](#section-5.2.2){.xref}.  [FLOOR-ID](#name-floor-id){.xref}[¶](#section-toc.1-1.5.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.3}
            [5.2.3](#section-5.2.3){.xref}.  [FLOOR-REQUEST-ID](#name-floor-request-id){.xref}[¶](#section-toc.1-1.5.2.2.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.4}
            [5.2.4](#section-5.2.4){.xref}.  [PRIORITY](#name-priority){.xref}[¶](#section-toc.1-1.5.2.2.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.5}
            [5.2.5](#section-5.2.5){.xref}.  [REQUEST-STATUS](#name-request-status){.xref}[¶](#section-toc.1-1.5.2.2.2.5.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.6}
            [5.2.6](#section-5.2.6){.xref}.  [ERROR-CODE](#name-error-code){.xref}[¶](#section-toc.1-1.5.2.2.2.6.1){.pilcrow}

            -   ::: {#section-toc.1-1.5.2.2.2.6.2.1}
                [5.2.6.1](#section-5.2.6.1){.xref}.  [Error Specific
                Details for Error Code
                4](#name-error-specific-details-for-){.xref}[¶](#section-toc.1-1.5.2.2.2.6.2.1.1){.pilcrow}
                :::
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.7}
            [5.2.7](#section-5.2.7){.xref}.  [ERROR-INFO](#name-error-info){.xref}[¶](#section-toc.1-1.5.2.2.2.7.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.8}
            [5.2.8](#section-5.2.8){.xref}.  [PARTICIPANT-PROVIDED-INFO](#name-participant-provided-info){.xref}[¶](#section-toc.1-1.5.2.2.2.8.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.9}
            [5.2.9](#section-5.2.9){.xref}.  [STATUS-INFO](#name-status-info){.xref}[¶](#section-toc.1-1.5.2.2.2.9.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.10}
            [5.2.10](#section-5.2.10){.xref}. [SUPPORTED-ATTRIBUTES](#name-supported-attributes){.xref}[¶](#section-toc.1-1.5.2.2.2.10.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.11}
            [5.2.11](#section-5.2.11){.xref}. [SUPPORTED-PRIMITIVES](#name-supported-primitives){.xref}[¶](#section-toc.1-1.5.2.2.2.11.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.12}
            [5.2.12](#section-5.2.12){.xref}. [USER-DISPLAY-NAME](#name-user-display-name){.xref}[¶](#section-toc.1-1.5.2.2.2.12.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.13}
            [5.2.13](#section-5.2.13){.xref}. [USER-URI](#name-user-uri){.xref}[¶](#section-toc.1-1.5.2.2.2.13.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.14}
            [5.2.14](#section-5.2.14){.xref}. [BENEFICIARY-INFORMATION](#name-beneficiary-information){.xref}[¶](#section-toc.1-1.5.2.2.2.14.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.15}
            [5.2.15](#section-5.2.15){.xref}. [FLOOR-REQUEST-INFORMATION](#name-floor-request-information){.xref}[¶](#section-toc.1-1.5.2.2.2.15.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.16}
            [5.2.16](#section-5.2.16){.xref}. [REQUESTED-BY-INFORMATION](#name-requested-by-information){.xref}[¶](#section-toc.1-1.5.2.2.2.16.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.17}
            [5.2.17](#section-5.2.17){.xref}. [FLOOR-REQUEST-STATUS](#name-floor-request-status){.xref}[¶](#section-toc.1-1.5.2.2.2.17.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.18}
            [5.2.18](#section-5.2.18){.xref}. [OVERALL-REQUEST-STATUS](#name-overall-request-status){.xref}[¶](#section-toc.1-1.5.2.2.2.18.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Message
        Format](#name-message-format){.xref}[¶](#section-toc.1-1.5.2.3.1){.pilcrow}

        -   ::: {#section-toc.1-1.5.2.3.2.1}
            [5.3.1](#section-5.3.1){.xref}.  [FloorRequest](#name-floorrequest){.xref}[¶](#section-toc.1-1.5.2.3.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.2}
            [5.3.2](#section-5.3.2){.xref}.  [FloorRelease](#name-floorrelease){.xref}[¶](#section-toc.1-1.5.2.3.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.3}
            [5.3.3](#section-5.3.3){.xref}.  [FloorRequestQuery](#name-floorrequestquery){.xref}[¶](#section-toc.1-1.5.2.3.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.4}
            [5.3.4](#section-5.3.4){.xref}.  [FloorRequestStatus](#name-floorrequeststatus){.xref}[¶](#section-toc.1-1.5.2.3.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.5}
            [5.3.5](#section-5.3.5){.xref}.  [UserQuery](#name-userquery){.xref}[¶](#section-toc.1-1.5.2.3.2.5.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.6}
            [5.3.6](#section-5.3.6){.xref}.  [UserStatus](#name-userstatus){.xref}[¶](#section-toc.1-1.5.2.3.2.6.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.7}
            [5.3.7](#section-5.3.7){.xref}.  [FloorQuery](#name-floorquery){.xref}[¶](#section-toc.1-1.5.2.3.2.7.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.8}
            [5.3.8](#section-5.3.8){.xref}.  [FloorStatus](#name-floorstatus){.xref}[¶](#section-toc.1-1.5.2.3.2.8.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.9}
            [5.3.9](#section-5.3.9){.xref}.  [ChairAction](#name-chairaction){.xref}[¶](#section-toc.1-1.5.2.3.2.9.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.10}
            [5.3.10](#section-5.3.10){.xref}. [ChairActionAck](#name-chairactionack){.xref}[¶](#section-toc.1-1.5.2.3.2.10.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.11}
            [5.3.11](#section-5.3.11){.xref}. [Hello](#name-hello){.xref}[¶](#section-toc.1-1.5.2.3.2.11.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.12}
            [5.3.12](#section-5.3.12){.xref}. [HelloAck](#name-helloack){.xref}[¶](#section-toc.1-1.5.2.3.2.12.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.13}
            [5.3.13](#section-5.3.13){.xref}. [Error](#name-error){.xref}[¶](#section-toc.1-1.5.2.3.2.13.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.14}
            [5.3.14](#section-5.3.14){.xref}. [FloorRequestStatusAck](#name-floorrequeststatusack){.xref}[¶](#section-toc.1-1.5.2.3.2.14.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.15}
            [5.3.15](#section-5.3.15){.xref}. [FloorStatusAck](#name-floorstatusack){.xref}[¶](#section-toc.1-1.5.2.3.2.15.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.16}
            [5.3.16](#section-5.3.16){.xref}. [Goodbye](#name-goodbye){.xref}[¶](#section-toc.1-1.5.2.3.2.16.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.17}
            [5.3.17](#section-5.3.17){.xref}. [GoodbyeAck](#name-goodbyeack){.xref}[¶](#section-toc.1-1.5.2.3.2.17.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Transport](#name-transport){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Reliable
        Transport](#name-reliable-transport){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Unreliable
        Transport](#name-unreliable-transport){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.6.2.2.2.1}
            [6.2.1](#section-6.2.1){.xref}.  [Congestion
            Control](#name-congestion-control){.xref}[¶](#section-toc.1-1.6.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.6.2.2.2.2}
            [6.2.2](#section-6.2.2){.xref}.  [ICMP Error
            Handling](#name-icmp-error-handling){.xref}[¶](#section-toc.1-1.6.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.6.2.2.2.3}
            [6.2.3](#section-6.2.3){.xref}.  [Fragmentation
            Handling](#name-fragmentation-handling){.xref}[¶](#section-toc.1-1.6.2.2.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.6.2.2.2.4}
            [6.2.4](#section-6.2.4){.xref}.  [NAT
            Traversal](#name-nat-traversal){.xref}[¶](#section-toc.1-1.6.2.2.2.4.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Lower-Layer
    Security](#name-lower-layer-security){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Protocol
    Transactions](#name-protocol-transactions){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Client
        Behavior](#name-client-behavior){.xref}[¶](#section-toc.1-1.8.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Server
        Behavior](#name-server-behavior){.xref}[¶](#section-toc.1-1.8.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [8.3](#section-8.3){.xref}.  [Timers](#name-timers){.xref}[¶](#section-toc.1-1.8.2.3.1){.pilcrow}

        -   ::: {#section-toc.1-1.8.2.3.2.1}
            [8.3.1](#section-8.3.1){.xref}.  [Request Retransmission
            Timer,
            T1](#name-request-retransmission-time){.xref}[¶](#section-toc.1-1.8.2.3.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.3.2.2}
            [8.3.2](#section-8.3.2){.xref}.  [Response Retransmission
            Timer,
            T2](#name-response-retransmission-tim){.xref}[¶](#section-toc.1-1.8.2.3.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.3.2.3}
            [8.3.3](#section-8.3.3){.xref}.  [Timer
            Values](#name-timer-values){.xref}[¶](#section-toc.1-1.8.2.3.2.3.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Authentication and
    Authorization](#name-authentication-and-authoriz){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [TLS/DTLS Based Mutual
        Authentication](#name-tls-dtls-based-mutual-authe){.xref}[¶](#section-toc.1-1.9.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Floor Participant
    Operations](#name-floor-participant-operation){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}

    -   ::: {#section-toc.1-1.10.2.1}
        [10.1](#section-10.1){.xref}.  [Requesting a
        Floor](#name-requesting-a-floor){.xref}[¶](#section-toc.1-1.10.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.10.2.1.2.1}
            [10.1.1](#section-10.1.1){.xref}.  [Sending a FloorRequest
            Message](#name-sending-a-floorrequest-mess){.xref}[¶](#section-toc.1-1.10.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.10.2.1.2.2}
            [10.1.2](#section-10.1.2){.xref}.  [Receiving a
            Response](#name-receiving-a-response){.xref}[¶](#section-toc.1-1.10.2.1.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.10.2.1.2.3}
            [10.1.3](#section-10.1.3){.xref}.  [Reception of a
            Subsequent FloorRequestStatus
            Message](#name-reception-of-a-subsequent-f){.xref}[¶](#section-toc.1-1.10.2.1.2.3.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [10.2](#section-10.2){.xref}.  [Cancelling a Floor Request and
        Releasing a
        Floor](#name-cancelling-a-floor-request-){.xref}[¶](#section-toc.1-1.10.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.10.2.2.2.1}
            [10.2.1](#section-10.2.1){.xref}.  [Sending a FloorRelease
            Message](#name-sending-a-floorrelease-mess){.xref}[¶](#section-toc.1-1.10.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.10.2.2.2.2}
            [10.2.2](#section-10.2.2){.xref}.  [Receiving a
            Response](#name-receiving-a-response-2){.xref}[¶](#section-toc.1-1.10.2.2.2.2.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [Chair
    Operations](#name-chair-operations){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}

    -   ::: {#section-toc.1-1.11.2.1}
        [11.1](#section-11.1){.xref}.  [Sending a ChairAction
        Message](#name-sending-a-chairaction-messa){.xref}[¶](#section-toc.1-1.11.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [11.2](#section-11.2){.xref}.  [Receiving a
        Response](#name-receiving-a-response-3){.xref}[¶](#section-toc.1-1.11.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [General Client
    Operations](#name-general-client-operations){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}

    -   ::: {#section-toc.1-1.12.2.1}
        [12.1](#section-12.1){.xref}.  [Requesting Information about
        Floors](#name-requesting-information-abou){.xref}[¶](#section-toc.1-1.12.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.12.2.1.2.1}
            [12.1.1](#section-12.1.1){.xref}.  [Sending a FloorQuery
            Message](#name-sending-a-floorquery-messag){.xref}[¶](#section-toc.1-1.12.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.12.2.1.2.2}
            [12.1.2](#section-12.1.2){.xref}.  [Receiving a
            Response](#name-receiving-a-response-4){.xref}[¶](#section-toc.1-1.12.2.1.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.12.2.1.2.3}
            [12.1.3](#section-12.1.3){.xref}.  [Reception of a
            Subsequent FloorStatus
            Message](#name-reception-of-a-subsequent-fl){.xref}[¶](#section-toc.1-1.12.2.1.2.3.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [12.2](#section-12.2){.xref}.  [Requesting Information about
        Floor
        Requests](#name-requesting-information-about){.xref}[¶](#section-toc.1-1.12.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.12.2.2.2.1}
            [12.2.1](#section-12.2.1){.xref}.  [Sending a
            FloorRequestQuery
            Message](#name-sending-a-floorrequestquery){.xref}[¶](#section-toc.1-1.12.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.12.2.2.2.2}
            [12.2.2](#section-12.2.2){.xref}.  [Receiving a
            Response](#name-receiving-a-response-5){.xref}[¶](#section-toc.1-1.12.2.2.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.12.2.3}
        [12.3](#section-12.3){.xref}.  [Requesting Information about a
        User](#name-requesting-information-about-){.xref}[¶](#section-toc.1-1.12.2.3.1){.pilcrow}

        -   ::: {#section-toc.1-1.12.2.3.2.1}
            [12.3.1](#section-12.3.1){.xref}.  [Sending a UserQuery
            Message](#name-sending-a-userquery-message){.xref}[¶](#section-toc.1-1.12.2.3.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.12.2.3.2.2}
            [12.3.2](#section-12.3.2){.xref}.  [Receiving a
            Response](#name-receiving-a-response-6){.xref}[¶](#section-toc.1-1.12.2.3.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.12.2.4}
        [12.4](#section-12.4){.xref}.  [Obtaining the Capabilities of a
        Floor Control
        Server](#name-obtaining-the-capabilities-){.xref}[¶](#section-toc.1-1.12.2.4.1){.pilcrow}

        -   ::: {#section-toc.1-1.12.2.4.2.1}
            [12.4.1](#section-12.4.1){.xref}.  [Sending a Hello
            Message](#name-sending-a-hello-message){.xref}[¶](#section-toc.1-1.12.2.4.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.12.2.4.2.2}
            [12.4.2](#section-12.4.2){.xref}.  [Receiving
            Responses](#name-receiving-responses){.xref}[¶](#section-toc.1-1.12.2.4.2.2.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [13](#section-13){.xref}. [Floor Control Server
    Operations](#name-floor-control-server-operat){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}

    -   ::: {#section-toc.1-1.13.2.1}
        [13.1](#section-13.1){.xref}.  [Reception of a FloorRequest
        Message](#name-reception-of-a-floorrequest){.xref}[¶](#section-toc.1-1.13.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.13.2.1.2.1}
            [13.1.1](#section-13.1.1){.xref}.  [Generating the First
            FloorRequestStatus
            Message](#name-generating-the-first-floorr){.xref}[¶](#section-toc.1-1.13.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.13.2.1.2.2}
            [13.1.2](#section-13.1.2){.xref}.  [Generation of Subsequent
            FloorRequestStatus
            Messages](#name-generation-of-subsequent-fl){.xref}[¶](#section-toc.1-1.13.2.1.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.13.2.2}
        [13.2](#section-13.2){.xref}.  [Reception of a FloorRequestQuery
        Message](#name-reception-of-a-floorrequestq){.xref}[¶](#section-toc.1-1.13.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.13.2.3}
        [13.3](#section-13.3){.xref}.  [Reception of a UserQuery
        Message](#name-reception-of-a-userquery-me){.xref}[¶](#section-toc.1-1.13.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.13.2.4}
        [13.4](#section-13.4){.xref}.  [Reception of a FloorRelease
        Message](#name-reception-of-a-floorrelease){.xref}[¶](#section-toc.1-1.13.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.13.2.5}
        [13.5](#section-13.5){.xref}.  [Reception of a FloorQuery
        Message](#name-reception-of-a-floorquery-m){.xref}[¶](#section-toc.1-1.13.2.5.1){.pilcrow}

        -   ::: {#section-toc.1-1.13.2.5.2.1}
            [13.5.1](#section-13.5.1){.xref}.  [Generation of the First
            FloorStatus
            Message](#name-generation-of-the-first-flo){.xref}[¶](#section-toc.1-1.13.2.5.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.13.2.5.2.2}
            [13.5.2](#section-13.5.2){.xref}.  [Generation of Subsequent
            FloorStatus
            Messages](#name-generation-of-subsequent-flo){.xref}[¶](#section-toc.1-1.13.2.5.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.13.2.6}
        [13.6](#section-13.6){.xref}.  [Reception of a ChairAction
        Message](#name-reception-of-a-chairaction-){.xref}[¶](#section-toc.1-1.13.2.6.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.13.2.7}
        [13.7](#section-13.7){.xref}.  [Reception of a Hello
        Message](#name-reception-of-a-hello-messag){.xref}[¶](#section-toc.1-1.13.2.7.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.13.2.8}
        [13.8](#section-13.8){.xref}.  [Error Message
        Generation](#name-error-message-generation){.xref}[¶](#section-toc.1-1.13.2.8.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.14}
    [14](#section-14){.xref}. [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.15}
    [15](#section-15){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.15.1){.pilcrow}

    -   ::: {#section-toc.1-1.15.2.1}
        [15.1](#section-15.1){.xref}.  [Attributes
        Subregistry](#name-attributes-subregistry){.xref}[¶](#section-toc.1-1.15.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.15.2.2}
        [15.2](#section-15.2){.xref}.  [Primitives
        Subregistry](#name-primitives-subregistry){.xref}[¶](#section-toc.1-1.15.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.15.2.3}
        [15.3](#section-15.3){.xref}.  [Request Statuses
        Subregistry](#name-request-statuses-subregistr){.xref}[¶](#section-toc.1-1.15.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.15.2.4}
        [15.4](#section-15.4){.xref}.  [Error Codes
        Subregistry](#name-error-codes-subregistry){.xref}[¶](#section-toc.1-1.15.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.16}
    [16](#section-16){.xref}. [Changes from RFC
    4582](#name-changes-from-rfc-4582){.xref}[¶](#section-toc.1-1.16.1){.pilcrow}

    -   ::: {#section-toc.1-1.16.2.1}
        [16.1](#section-16.1){.xref}.  [Extensions for an Unreliable
        Transport](#name-extensions-for-an-unreliabl){.xref}[¶](#section-toc.1-1.16.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.16.2.2}
        [16.2](#section-16.2){.xref}.  [Other
        Changes](#name-other-changes){.xref}[¶](#section-toc.1-1.16.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.17}
    [17](#section-17){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.17.1){.pilcrow}

    -   ::: {#section-toc.1-1.17.2.1}
        [17.1](#section-17.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.17.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.17.2.2}
        [17.2](#section-17.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.17.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.18}
    [Appendix A](#section-appendix.a){.xref}.  [Example Call Flows for
    BFCP over an Unreliable
    Transport](#name-example-call-flows-for-bfcp){.xref}[¶](#section-toc.1-1.18.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.19}
    [Appendix B](#section-appendix.b){.xref}.  [Motivation for
    Supporting an Unreliable
    Transport](#name-motivation-for-supporting-a){.xref}[¶](#section-toc.1-1.19.1){.pilcrow}

    -   ::: {#section-toc.1-1.19.2.1}
        [B.1](#section-b.1){.xref}.  [Motivation](#name-motivation){.xref}[¶](#section-toc.1-1.19.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.19.2.1.2.1}
            [B.1.1](#section-b.1.1){.xref}.  [Alternatives
            Considered](#name-alternatives-considered){.xref}[¶](#section-toc.1-1.19.2.1.2.1.1){.pilcrow}

            -   ::: {#section-toc.1-1.19.2.1.2.1.2.1}
                [B.1.1.1](#section-b.1.1.1){.xref}.  [ICE
                TCP](#name-ice-tcp){.xref}[¶](#section-toc.1-1.19.2.1.2.1.2.1.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.19.2.1.2.1.2.2}
                [B.1.1.2](#section-b.1.1.2){.xref}.  [Teredo](#name-teredo){.xref}[¶](#section-toc.1-1.19.2.1.2.1.2.2.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.19.2.1.2.1.2.3}
                [B.1.1.3](#section-b.1.1.3){.xref}.  [GUT](#name-gut){.xref}[¶](#section-toc.1-1.19.2.1.2.1.2.3.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.19.2.1.2.1.2.4}
                [B.1.1.4](#section-b.1.1.4){.xref}.  [UPnP
                IGD](#name-upnp-igd){.xref}[¶](#section-toc.1-1.19.2.1.2.1.2.4.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.19.2.1.2.1.2.5}
                [B.1.1.5](#section-b.1.1.5){.xref}.  [NAT
                PMP](#name-nat-pmp){.xref}[¶](#section-toc.1-1.19.2.1.2.1.2.5.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.19.2.1.2.1.2.6}
                [B.1.1.6](#section-b.1.1.6){.xref}.  [SCTP](#name-sctp){.xref}[¶](#section-toc.1-1.19.2.1.2.1.2.6.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.19.2.1.2.1.2.7}
                [B.1.1.7](#section-b.1.1.7){.xref}.  [BFCP over UDP
                Transport](#name-bfcp-over-udp-transport){.xref}[¶](#section-toc.1-1.19.2.1.2.1.2.7.1){.pilcrow}
                :::
            :::
        :::
    :::

-   ::: {#section-toc.1-1.20}
    [](#section-appendix.c){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.20.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.21}
    [](#section-appendix.d){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.21.1){.pilcrow}
    :::
:::
:::

::: {#sec_intro}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Within a conference, some applications need to manage the access to a
set of shared resources, such as the right to send media to a particular
media session. Floor control enables such applications to provide users
with coordinated (shared or exclusive) access to these
resources.[¶](#section-1-1){.pilcrow}

The Requirements for Floor Control Protocol \[[18](#RFC4376){.xref}\]
list a set of requirements that need to be met by floor control
protocols. The Binary Floor Control Protocol (BFCP), which is specified
in this document, meets these requirements.[¶](#section-1-2){.pilcrow}

In addition, BFCP has been designed so that it can be used in
low-bandwidth environments. The binary encoding used by BFCP achieves a
small message size (when message signatures are not used) that keeps the
time it takes to transmit delay-sensitive BFCP messages to a minimum.
Delay-sensitive BFCP messages include FloorRequest, FloorRelease,
FloorRequestStatus, and ChairAction. It is expected that future
extensions to these messages will not increase the size of these
messages in a significant way.[¶](#section-1-3){.pilcrow}

The remainder of this document is organized as follows: [Section
2](#sec_terminology){.xref} defines the terminology used throughout this
document, [Section 3](#sec_scope){.xref} discusses the scope of BFCP
(i.e., which tasks fall within the scope of BFCP and which ones are
performed using different mechanisms), [Section 4](#sec_overview){.xref}
provides a non-normative overview of BFCP operation. The subsequent
sections provide the normative specification of BFCP. [Section
16](#sec_changes){.xref} summarizes changes from [RFC
4582](#RFC4582){.xref}
\[[3](#RFC4582){.xref}\].[¶](#section-1-4){.pilcrow}
:::
:::

::: {#sec_terminology}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[1](#RFC2119){.xref}\]
\[[10](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}

[]{.break}

Media Participant:
:   An entity that has access to the media resources of a conference
    (e.g., it can receive a media stream). In floor-controlled
    conferences, a given media participant is typically co-located with
    a floor participant, but it does not need to be. Third-party floor
    requests consist of having a floor participant request a floor for a
    media participant when they are not co-located. The protocol between
    a floor participant and a media participant (that are not
    co-located) is outside the scope of this
    document.[¶](#section-2-2.2){.pilcrow}
:   

Client:
:   A floor participant or a floor chair that communicates with a floor
    control server using BFCP.[¶](#section-2-2.4){.pilcrow}
:   

Floor:
:   A temporary permission to access or manipulate a specific shared
    resource or set of resources.[¶](#section-2-2.6){.pilcrow}
:   

Floor Chair:
:   A logical entity that manages one floor (grants, denies, or revokes
    a floor). An entity that assumes the logical role of a floor chair
    for a given transaction may assume a different role (e.g., floor
    participant) for a different transaction. The roles of floor chair
    and floor participant are defined on a transaction-by-transaction
    basis. BFCP transactions are defined in [Section
    8](#sec_transactions){.xref}.[¶](#section-2-2.8){.pilcrow}
:   

Floor Control:
:   A mechanism that enables applications or users to gain safe and
    mutually exclusive or non-exclusive input access to the shared
    object or resource.[¶](#section-2-2.10){.pilcrow}
:   

Floor Control Server:
:   A logical entity that maintains the state of the floor(s), including
    which floors exists, who the floor chairs are, who holds a floor,
    etc. Requests to manipulate a floor are directed at the floor
    control server. The floor control server of a conference may perform
    other logical roles (e.g., floor participant) in another
    conference.[¶](#section-2-2.12){.pilcrow}
:   

Floor Participant:
:   A logical entity that requests floors, and possibly information
    about them, from a floor control server. An entity that assumes the
    logical role of a floor participant for a given transaction may
    assume a different role (e.g., a floor chair) for a different
    transaction. The roles of floor participant and floor chair are
    defined on a transaction-by-transaction basis. BFCP transactions are
    defined in [Section 8](#sec_transactions){.xref}. In
    floor-controlled conferences, a given floor participant is typically
    co-located with a media participant, but it does not need to be.
    Third-party floor requests consist of having a floor participant
    request a floor for a media participant when they are not
    co-located.[¶](#section-2-2.14){.pilcrow}
:   

Participant:
:   An entity that acts as a floor participant, as a media participant,
    or as both.[¶](#section-2-2.16){.pilcrow}
:   

BFCP Connection:
:   A transport association between BFCP entities, used to exchange BFCP
    messages.[¶](#section-2-2.18){.pilcrow}
:   

Transaction Failure Window:
:   When communicating over an unreliable transport, this is some period
    of time less than or equal to T1\*2^4^ (see [Section
    8.3](#timers){.xref}). For reliable transports, this period of time
    is unbounded.[¶](#section-2-2.20){.pilcrow}
:   
:::
:::

::: {#sec_scope}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Scope](#name-scope){.section-name .selfRef} {#name-scope}

As stated earlier, BFCP is a protocol to coordinate access to shared
resources in a conference following the requirements defined in
\[[18](#RFC4376){.xref}\]. Floor control complements other functions
defined in the Centralized Conferencing (XCON) Framework
\[[19](#RFC5239){.xref}\]. The floor control protocol BFCP defined in
this document only specifies a means to arbitrate access to floors. The
rules and constraints for floor arbitration and the results of floor
assignments are outside the scope of this document and are defined by
other protocols \[[19](#RFC5239){.xref}\].[¶](#section-3-1){.pilcrow}

[Figure 1](#fig_arch){.xref} shows the tasks that BFCP can
perform.[¶](#section-3-2){.pilcrow}

[]{#name-functionality-provided-by-b}

::: {#fig_arch}
::: {#section-3-3.1 .artwork .art-text .alignLeft}
                               +---------+
                               |  Floor  |
                               |  Chair  |
                               |         |
                               +---------+
                                  ^   |
                                  |   |
                     Notification |   | Decision
                                  |   |
                                  |   |
                       Floor      |   v
    +-------------+   Request  +---------+              +-------------+
    |    Floor    |----------->|  Floor  | Notification |    Floor    |
    | Participant |            | Control |------------->| Participant |
    |             |<-----------|  Server |              |             |
    +-------------+ Granted or +---------+              +-------------+
                      Denied
:::

[Figure 1](#figure-1){.selfRef}: [Functionality provided by
BFCP](#name-functionality-provided-by-b){.selfRef}
:::

BFCP provides a means:[¶](#section-3-4){.pilcrow}

-   [for floor participants to send floor requests to floor control
    servers.[¶](#section-3-5.1){.pilcrow}]{#section-3-5.1}
-   [for floor control servers to grant or deny requests to access a
    given resource from floor
    participants.[¶](#section-3-5.2){.pilcrow}]{#section-3-5.2}
-   [for floor chairs to send floor control servers decisions regarding
    floor requests.[¶](#section-3-5.3){.pilcrow}]{#section-3-5.3}
-   [for floor control servers to keep floor participants and floor
    chairs informed about the status of a given floor or a given floor
    request.[¶](#section-3-5.4){.pilcrow}]{#section-3-5.4}

Even though tasks that do not belong to the previous list are outside
the scope of BFCP, some of these out-of-scope tasks relate to floor
control and are essential for creating floors and establishing BFCP
connections between different entities. In the following subsections, we
discuss some of these tasks and mechanisms to perform
them.[¶](#section-3-6){.pilcrow}

::: {#sec_scope_creation}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Floor Creation](#name-floor-creation){.section-name .selfRef} {#name-floor-creation}

The association of a given floor with a resource or a set of resources
(e.g., media streams) is out of the scope of BFCP as described in
\[[19](#RFC5239){.xref}\]. Floor creation and termination are also
outside the scope of BFCP; these aspects are handled using the
conference control protocol for manipulating the conference object.
Consequently, the floor control server needs to stay up to date on
changes to the conference object (e.g., when a new floor is
created).[¶](#section-3.1-1){.pilcrow}

Conference control clients using Centralized Conferencing Manipulation
Protocol (CCMP) \[[23](#RFC6503){.xref}\] can specify such floor-related
settings in the \<floor-information> element \[[22](#RFC6501){.xref}\]
of the to-be created conference object provided in the body of a CCMP
confRequest/create message issued to the conference control
server.[¶](#section-3.1-2){.pilcrow}
:::
:::

::: {#sec_scope_info}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Obtaining Information to Contact a Floor Control Server](#name-obtaining-information-to-co){.section-name .selfRef} {#name-obtaining-information-to-co}

A client needs a set of data in order to establish a BFCP connection to
a floor control server. These data include the transport address of the
server, the conference identifier, and a user
identifier.[¶](#section-3.2-1){.pilcrow}

Clients can obtain this information in different ways. One is to use a
Session Description Protocol (SDP) offer/answer
\[[17](#RFC3264){.xref}\] exchange, which is described in
\[[12](#RFC8856){.xref}\]. How to establish a connection to a BFCP floor
control server is outside the context of an offer/answer exchange when
using a reliable transport is described in \[[4](#RFC5018){.xref}\].
Other mechanisms are described in the XCON Framework
\[[19](#RFC5239){.xref}\] (and other related documents). For unreliable
transports, the use of an SDP offer/answer exchange is the only
specified mechanism.[¶](#section-3.2-2){.pilcrow}
:::
:::

::: {#sec_scope_associations}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Obtaining Floor-Resource Associations](#name-obtaining-floor-resource-as){.section-name .selfRef} {#name-obtaining-floor-resource-as}

Floors are associated with resources. For example, a floor that controls
who talks at a given time has a particular audio session as its
associated resource. Associations between floors and resources are part
of the conference object.[¶](#section-3.3-1){.pilcrow}

Floor participants and floor chairs need to know which resources are
associated with which floors. They can obtain this information by using
different mechanisms, such as an SDP offer/answer
\[[17](#RFC3264){.xref}\] exchange. How to use an SDP offer/answer
exchange to obtain these associations is described in
\[[12](#RFC8856){.xref}\].[¶](#section-3.3-2){.pilcrow}

Note that floor participants perform SDP offer/answer exchanges with the
conference focus of the conference. So, the conference focus needs to
obtain information about associations between floors and resources in
order to be able to provide this information to a floor participant in
an SDP offer/answer exchange.[¶](#section-3.3-3.1){.pilcrow}

Other mechanisms for obtaining this information, including discussion of
how the information is made available to a (SIP) focus, are described in
the XCON Framework \[[19](#RFC5239){.xref}\] (and other related
documents). According to the conferencing system policies, conference
control clients using CCMP \[[23](#RFC6503){.xref}\] can modify the
floor settings of a conference by issuing CCMP confRequest/update
messages providing the specific updates to the \<floor-information>
element of the target conference object. More information about CCMP and
BFCP interaction can be found in
\[[24](#RFC6504){.xref}\].[¶](#section-3.3-4){.pilcrow}
:::
:::

::: {#sec_scope_policy}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [Privileges of Floor Control](#name-privileges-of-floor-control){.section-name .selfRef} {#name-privileges-of-floor-control}

A participant whose floor request is granted has the right to use the
resource or resources associated with the floor that was requested. For
example, the participant may have the right to send media over a
particular audio stream.[¶](#section-3.4-1){.pilcrow}

Nevertheless, holding a floor does not imply that others will not be
able to use its associated resources at the same time, even if they do
not have the right to do so. Determination of which media participants
can actually use the resources in the conference is discussed in the
XCON Framework \[[19](#RFC5239){.xref}\].[¶](#section-3.4-2){.pilcrow}
:::
:::
:::
:::

::: {#sec_overview}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Overview of Operation](#name-overview-of-operation){.section-name .selfRef} {#name-overview-of-operation}

This section provides a non-normative description of BFCP operations.
[Section 4.1](#sec_overview_user){.xref} describes the interface between
floor participants and floor control servers, and [Section
4.2](#sec_overview_chair){.xref} describes the interface between floor
chairs and floor control servers.[¶](#section-4-1){.pilcrow}

BFCP messages, which use a TLV (Type-Length-Value) binary encoding,
consist of a COMMON-HEADER followed by a set of attributes. The
COMMON-HEADER contains, among other information, a 32-bit conference
identifier. Floor participants, media participants, and floor chairs are
identified by 16-bit user identifiers.[¶](#section-4-2){.pilcrow}

BFCP supports nested attributes (i.e., attributes that contain
attributes). These are referred to as grouped
attributes.[¶](#section-4-3){.pilcrow}

There are two types of transactions in BFCP: client-initiated
transactions and server-initiated transactions. [Section
8](#sec_transactions){.xref} describes both types of transactions in
detail.[¶](#section-4-4){.pilcrow}

::: {#sec_overview_user}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Floor Participant to Floor Control Server Interface](#name-floor-participant-to-floor-){.section-name .selfRef} {#name-floor-participant-to-floor-}

Floor participants request a floor by sending a FloorRequest message to
the floor control server. BFCP supports third-party floor requests. That
is, the floor participant sending the floor request need not be
co-located with the media participant that will get the floor once the
floor request is granted. FloorRequest messages carry the identity of
the requester in the User ID field of the COMMON-HEADER, and the
identity of the beneficiary of the floor (in third-party floor requests)
in a BENEFICIARY-ID attribute.[¶](#section-4.1-1){.pilcrow}

Third-party floor requests can be sent, for example, by floor
participants that have a BFCP connection to the floor control server but
that are not media participants (i.e., they do not handle any
media).[¶](#section-4.1-2.1){.pilcrow}

FloorRequest messages identify the floor or floors being requested by
carrying their 16-bit floor identifiers in FLOOR-ID attributes. If a
FloorRequest message carries more than one floor identifier, the floor
control server treats all the floor requests as an atomic package. That
is, the floor control server either grants or denies all the floors in
the FloorRequest message.[¶](#section-4.1-3){.pilcrow}

Floor control servers respond to FloorRequest messages with
FloorRequestStatus messages, which provide information about the status
of the floor request. The first FloorRequestStatus message is the
response to the FloorRequest message from the client, and therefore has
the same Transaction ID as the
FloorRequest.[¶](#section-4.1-4){.pilcrow}

Additionally, the first FloorRequestStatus message carries the Floor
Request ID in a FLOOR-REQUEST-INFORMATION attribute. Subsequent
FloorRequestStatus messages related to the same floor request will carry
the same Floor Request ID. This way, the floor participant can associate
them with the appropriate floor request.[¶](#section-4.1-5){.pilcrow}

Messages from the floor participant related to a particular floor
request also use the same Floor Request ID as the first
FloorRequestStatus message from the floor control
server.[¶](#section-4.1-6){.pilcrow}

[Figure 2](#fig_flow1){.xref} and [Figure 3](#fig_flow2){.xref} show
examples of call flows where BFCP is used over a reliable transport.
[Appendix A](#app_unrelcallflow){.xref} shows the same call flow
examples using an unreliable transport.[¶](#section-4.1-7){.pilcrow}

[Figure 2](#fig_flow1){.xref} shows how a floor participant requests a
floor, obtains it, and, at a later time, releases it. This figure
illustrates the use, among other things, of the Transaction ID and the
FLOOR-REQUEST-ID attribute.[¶](#section-4.1-8){.pilcrow}

[]{#name-requesting-and-releasing-a-}

::: {#fig_flow1}
::: {#section-4.1-9.1 .artwork .art-text .alignLeft}
       Floor Participant                                 Floor Control
                                                            Server
               |(1) FloorRequest                               |
               |Transaction ID: 123                            |
               |User ID: 234                                   |
               |FLOOR-ID: 543                                  |
               |---------------------------------------------->|
               |                                               |
               |(2) FloorRequestStatus                         |
               |Transaction ID: 123                            |
               |User ID: 234                                   |
               |FLOOR-REQUEST-INFORMATION                      |
               |      Floor Request ID: 789                    |
               |      OVERALL-REQUEST-STATUS                   |
               |              Request Status: Pending          |
               |      FLOOR-REQUEST-STATUS                     |
               |            Floor ID: 543                      |
               |<----------------------------------------------|
               |                                               |
               |(3) FloorRequestStatus                         |
               |Transaction ID: 0                              |
               |User ID: 234                                   |
               |FLOOR-REQUEST-INFORMATION                      |
               |      Floor Request ID: 789                    |
               |      OVERALL-REQUEST-STATUS                   |
               |              Request Status: Accepted         |
               |              Queue Position: 1st              |
               |      FLOOR-REQUEST-STATUS                     |
               |            Floor ID: 543                      |
               |<----------------------------------------------|
               |                                               |
               |(4) FloorRequestStatus                         |
               |Transaction ID: 0                              |
               |User ID: 234                                   |
               |FLOOR-REQUEST-INFORMATION                      |
               |      Floor Request ID: 789                    |
               |      OVERALL-REQUEST-STATUS                   |
               |              Request Status: Granted          |
               |      FLOOR-REQUEST-STATUS                     |
               |            Floor ID: 543                      |
               |<----------------------------------------------|
               |                                               |
               |(5) FloorRelease                               |
               |Transaction ID: 154                            |
               |User ID: 234                                   |
               |FLOOR-REQUEST-ID: 789                          |
               |---------------------------------------------->|
               |                                               |
               |(6) FloorRequestStatus                         |
               |Transaction ID: 154                            |
               |User ID: 234                                   |
               |FLOOR-REQUEST-INFORMATION                      |
               |      Floor Request ID: 789                    |
               |      OVERALL-REQUEST-STATUS                   |
               |              Request Status: Released         |
               |      FLOOR-REQUEST-STATUS                     |
               |            Floor ID: 543                      |
               |<----------------------------------------------|
:::

[Figure 2](#figure-2){.selfRef}: [Requesting and releasing a
floor](#name-requesting-and-releasing-a-){.selfRef}
:::

[Figure 3](#fig_flow2){.xref} shows how a floor participant requests to
be informed on the status of a floor. The first FloorStatus message from
the floor control server is the response to the FloorQuery message and,
as such, has the same Transaction ID as the FloorQuery
message.[¶](#section-4.1-10){.pilcrow}

Subsequent FloorStatus messages consist of server-initiated
transactions, and therefore their Transaction ID is 0 given this example
uses a reliable transport. FloorStatus message (2) indicates that there
are currently two floor requests for the floor whose Floor ID is 543.
FloorStatus message (3) indicates that the floor requests with Floor
Request ID 764 has been granted, and the floor request with Floor
Request ID 635 is the first in the queue. FloorStatus message (4)
indicates that the floor request with Floor Request ID 635 has been
granted.[¶](#section-4.1-11){.pilcrow}

[]{#name-obtaining-status-informatio}

::: {#fig_flow2}
::: {#section-4.1-12.1 .artwork .art-text .alignLeft}
       Floor Participant                                 Floor Control
                                                            Server
               |(1) FloorQuery                                 |
               |Transaction ID: 257                            |
               |User ID: 234                                   |
               |FLOOR-ID: 543                                  |
               |---------------------------------------------->|
               |                                               |
               |(2) FloorStatus                                |
               |Transaction ID: 257                            |
               |User ID: 234                                   |
               |FLOOR-ID:543                                   |
               |FLOOR-REQUEST-INFORMATION                      |
               |      Floor Request ID: 764                    |
               |      OVERALL-REQUEST-STATUS                   |
               |              Request Status: Accepted         |
               |              Queue Position: 1st              |
               |      FLOOR-REQUEST-STATUS                     |
               |            Floor ID: 543                      |
               |      BENEFICIARY-INFORMATION                  |
               |                  Beneficiary ID: 124          |
               |FLOOR-REQUEST-INFORMATION                      |
               |      Floor Request ID: 635                    |
               |      OVERALL-REQUEST-STATUS                   |
               |              Request Status: Accepted         |
               |              Queue Position: 2nd              |
               |      FLOOR-REQUEST-STATUS                     |
               |            Floor ID: 543                      |
               |      BENEFICIARY-INFORMATION                  |
               |                  Beneficiary ID: 154          |
               |<----------------------------------------------|
               |                                               |
               |(3) FloorStatus                                |
               |Transaction ID: 0                              |
               |User ID: 234                                   |
               |FLOOR-ID:543                                   |
               |FLOOR-REQUEST-INFORMATION                      |
               |      Floor Request ID: 764                    |
               |      OVERALL-REQUEST-STATUS                   |
               |              Request Status: Granted          |
               |      FLOOR-REQUEST-STATUS                     |
               |            Floor ID: 543                      |
               |      BENEFICIARY-INFORMATION                  |
               |                  Beneficiary ID: 124          |
               |FLOOR-REQUEST-INFORMATION                      |
               |      Floor Request ID: 635                    |
               |      OVERALL-REQUEST-STATUS                   |
               |              Request Status: Accepted         |
               |              Queue Position: 1st              |
               |      FLOOR-REQUEST-STATUS                     |
               |            Floor ID: 543                      |
               |      BENEFICIARY-INFORMATION                  |
               |                  Beneficiary ID: 154          |
               |<----------------------------------------------|
               |                                               |
               |(4) FloorStatus                                |
               |Transaction ID: 0                              |
               |User ID: 234                                   |
               |FLOOR-ID:543                                   |
               |FLOOR-REQUEST-INFORMATION                      |
               |      Floor Request ID: 635                    |
               |      OVERALL-REQUEST-STATUS                   |
               |              Request Status: Granted          |
               |      FLOOR-REQUEST-STATUS                     |
               |            Floor ID: 543                      |
               |      BENEFICIARY-INFORMATION                  |
               |                  Beneficiary ID: 154          |
               |<----------------------------------------------|
:::

[Figure 3](#figure-3){.selfRef}: [Obtaining status information about a
floor](#name-obtaining-status-informatio){.selfRef}
:::

FloorStatus messages contain information about the floor requests they
carry. For example, FloorStatus message (4) indicates that the floor
request with Floor Request ID 635 has as the beneficiary (i.e., the
participant that holds the floor when a particular floor request is
granted) the participant whose User ID is 154. The floor request applies
only to the floor whose Floor ID is 543. That is, this is not a
multi-floor floor request.[¶](#section-4.1-13){.pilcrow}

A multi-floor floor request applies to more than one floor (e.g., a
participant wants to be able to speak and write on the whiteboard at the
same time). The floor control server treats a multi-floor floor request
as an atomic package. That is, the floor control server either grants
the request for all floors or denies the request for all
floors.[¶](#section-4.1-14.1){.pilcrow}
:::
:::

::: {#sec_overview_chair}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Floor Chair to Floor Control Server Interface](#name-floor-chair-to-floor-contro){.section-name .selfRef} {#name-floor-chair-to-floor-contro}

[Figure 4](#fig_flow3){.xref} shows a floor chair instructing a floor
control server to grant a floor.[¶](#section-4.2-1){.pilcrow}

Note, however, that although the floor control server needs to take into
consideration the instructions received in ChairAction messages (e.g.,
granting a floor), it does not necessarily need to perform them exactly
as requested by the floor chair. The operation that the floor control
server performs depends on the ChairAction message and on the internal
state of the floor control server.[¶](#section-4.2-2.1){.pilcrow}

For example, a floor chair may send a ChairAction message granting a
floor that was requested as part of an atomic floor request operation
that involved several floors. Even if the chair responsible for one of
the floors instructs the floor control server to grant the floor, the
floor control server will not grant it until the chairs responsible for
the other floors agree to grant them as well. In another example, a
floor chair may instruct the floor control server to grant a floor to a
participant. The floor control server needs to revoke the floor from its
current holder before granting it to the new
participant.[¶](#section-4.2-3){.pilcrow}

So, the floor control server is ultimately responsible for keeping a
coherent floor state using instructions from floor chairs as input to
this state.[¶](#section-4.2-4){.pilcrow}

[]{#name-chair-instructing-the-floor}

::: {#fig_flow3}
::: {#section-4.2-5.1 .artwork .art-text .alignLeft}
       Floor Chair                                    Floor Control
                                                         Server
            |(1) ChairAction                                |
            |Transaction ID: 769                            |
            |User ID: 357                                   |
            |FLOOR-REQUEST-INFORMATION                      |
            |      Floor Request ID: 635                    |
            |      FLOOR-REQUEST-STATUS                     |
            |            Floor ID: 543                      |
            |            Request Status: Granted            |
            |---------------------------------------------->|
            |                                               |
            |(2) ChairActionAck                             |
            |Transaction ID: 769                            |
            |User ID: 357                                   |
            |<----------------------------------------------|
:::

[Figure 4](#figure-4){.selfRef}: [Chair instructing the floor control
server](#name-chair-instructing-the-floor){.selfRef}
:::
:::
:::
:::
:::

::: {#sec_format}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Packet Format](#name-packet-format){.section-name .selfRef} {#name-packet-format}

BFCP packets consist of a 12-octet COMMON-HEADER followed by attributes.
All the protocol values [MUST]{.bcp14} be sent in network byte
order.[¶](#section-5-1){.pilcrow}

::: {#sec_format_common}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [COMMON-HEADER Format](#name-common-header-format){.section-name .selfRef} {#name-common-header-format}

The following is the format of the
COMMON-HEADER.[¶](#section-5.1-1){.pilcrow}

[]{#name-common-header-format-2}

::: {#fig_common}
::: {#section-5.1-2.1 .artwork .art-text .alignLeft}
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       | Ver |R|F| Res |  Primitive    |        Payload Length         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         Conference ID                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |         Transaction ID        |            User ID            |
    +> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  | Fragment Offset (if F is set) | Fragment Length (if F is set) |
    +> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |
    +---- These fragment fields are never present
          when using reliable transports
:::

[Figure 5](#figure-5){.selfRef}: [COMMON-HEADER
format](#name-common-header-format-2){.selfRef}
:::

[]{.break}

Ver:
:   This 3-bit field defines the version of BFCP to which this message
    adheres. This specification defines two versions: 1 and 2. The
    version field [MUST]{.bcp14} be set to 1 when using BFCP over a
    reliable transport. The version field [MUST]{.bcp14} be set to 2
    when using BFCP over an unreliable transport. If a floor control
    server receives a message with an unsupported version field value or
    a message with a version number that is not permitted with the
    transport over which it was received, the server [MUST]{.bcp14}
    indicate it does not support the protocol version by sending an
    Error message with parameter value 12 (Unsupported Version). Note
    that BFCP entities supporting only the \[[3](#RFC4582){.xref}\]
    subset will not support this parameter
    value.[¶](#section-5.1-3.2){.pilcrow}
:   

R:
:   The Transaction Responder (R) flag bit has relevance only for use of
    BFCP over an unreliable transport. When cleared, it indicates that
    this message is a request initiating a new transaction, and the
    Transaction ID that follows has been generated for this transaction.
    When set, it indicates that this message is a response to a previous
    request, and the Transaction ID that follows is the one associated
    with that request. When BFCP is used over a reliable transport, the
    flag has no significance and [MUST]{.bcp14} be cleared by the sender
    and [MUST]{.bcp14} be ignored by the
    receiver.[¶](#section-5.1-3.4){.pilcrow}
:   

F:
:   The Fragmentation (F) flag bit has relevance only for use of BFCP
    over an unreliable transport. When cleared, the message is not
    fragmented. When set, it indicates that the message is a fragment of
    a large, fragmented BFCP message. (The optional fields Fragment
    Offset and Fragment Length described below are present only if the F
    flag is set). When BFCP is used over a reliable transport, the flag
    has no significance and [MUST]{.bcp14} be cleared by the sender, and
    the flag [MUST]{.bcp14} be ignored by the receiver. In the latter
    case, the receiver should also ignore the Fragment Offset and
    Fragment Length fields when processing the
    COMMON-HEADER.[¶](#section-5.1-3.6){.pilcrow}
:   

Res:
:   The 3 bits in the reserved field [MUST]{.bcp14} be set to zero by
    the sender of the message and [MUST]{.bcp14} be ignored by the
    receiver.[¶](#section-5.1-3.8){.pilcrow}
:   

Primitive:
:   This 8-bit field identifies the main purpose of the message. The
    following primitive values are
    defined:[¶](#section-5.1-3.10){.pilcrow}
:   

[]{#name-bfcp-primitives}

::: {#tab_primitives}
+-----------------------+-----------------------+-----------------------+
| Value                 | Primitive             | Direction             |
+=======================+=======================+=======================+
| 1                     | FloorRequest          | P -\> S               |
+-----------------------+-----------------------+-----------------------+
| 2                     | FloorRelease          | P -\> S               |
+-----------------------+-----------------------+-----------------------+
| 3                     | FloorRequestQuery     | P -\> S ; Ch -\> S    |
+-----------------------+-----------------------+-----------------------+
| 4                     | FloorRequestStatus    | P \<- S ; Ch \<- S    |
+-----------------------+-----------------------+-----------------------+
| 5                     | UserQuery             | P -\> S ; Ch -\> S    |
+-----------------------+-----------------------+-----------------------+
| 6                     | UserStatus            | P \<- S ; Ch \<- S    |
+-----------------------+-----------------------+-----------------------+
| 7                     | FloorQuery            | P -\> S ; Ch -\> S    |
+-----------------------+-----------------------+-----------------------+
| 8                     | FloorStatus           | P \<- S ; Ch \<- S    |
+-----------------------+-----------------------+-----------------------+
| 9                     | ChairAction           | Ch -\> S              |
+-----------------------+-----------------------+-----------------------+
| 10                    | ChairActionAck        | Ch \<- S              |
+-----------------------+-----------------------+-----------------------+
| 11                    | Hello                 | P -\> S ; Ch -\> S    |
+-----------------------+-----------------------+-----------------------+
| 12                    | HelloAck              | P \<- S ; Ch \<- S    |
+-----------------------+-----------------------+-----------------------+
| 13                    | Error                 | P \<- S ; Ch \<- S    |
+-----------------------+-----------------------+-----------------------+
| 14                    | FloorRequestStatusAck | P -\> S ; Ch -\> S    |
+-----------------------+-----------------------+-----------------------+
| 15                    | FloorStatusAck        | P -\> S ; Ch -\> S    |
+-----------------------+-----------------------+-----------------------+
| 16                    | Goodbye               | P -\> S ; Ch -\> S ;  |
|                       |                       | P \<- S ; Ch \<- S    |
+-----------------------+-----------------------+-----------------------+
| 17                    | GoodbyeAck            | P -\> S ; Ch -\> S ;  |
|                       |                       | P \<- S ; Ch \<- S    |
+-----------------------+-----------------------+-----------------------+
| S: Floor Control      |                       |                       |
| Server\               |                       |                       |
| P: Floor Participant\ |                       |                       |
| Ch: Floor             |                       |                       |
| Chair[¶](#section-5.1 |                       |                       |
| -4.3.1.1.1){.pilcrow} |                       |                       |
+-----------------------+-----------------------+-----------------------+

: [Table 1](#table-1){.selfRef}: [BFCP
primitives](#name-bfcp-primitives){.selfRef}
:::

[]{.break}

Payload Length:
:   This 16-bit field contains the length of the message in 4-octet
    units, excluding the COMMON-HEADER. If a floor control server
    receives a message with an incorrect Payload Length field value, the
    receiving server [MUST]{.bcp14} send an Error message with parameter
    value 13 (Incorrect Message Length) to indicate this and then
    discard the message. Other entities that receive a message with an
    incorrect length [MUST]{.bcp14} discard the
    message.[¶](#section-5.1-6.2){.pilcrow}
:   

Note: BFCP is designed to achieve small message size, as explained in
[Section 1](#sec_intro){.xref}, and BFCP entities are [REQUIRED]{.bcp14}
to keep the BFCP message size smaller than the size limited by the
16-bit Payload Length field. To convey information not strictly related
to floor control, other protocols should be used, such as the XCON
Framework (cf. [Section
3](#sec_scope){.xref}).[¶](#section-5.1-7.1){.pilcrow}

[]{.break}

Conference ID:
:   This 32-bit unsigned integer field identifies the conference to
    which the message belongs. It is [RECOMMENDED]{.bcp14} that the
    conference identifier be randomly chosen. (Note that the use of
    predictable conference identifiers in conjunction with a nonsecure
    transport protocol makes BFCP susceptible to off-path data injection
    attacks, where an attacker can forge a request or response
    message.)[¶](#section-5.1-8.2){.pilcrow}
:   

Transaction ID:
:   This field contains a 16-bit value that allows users to match a
    given message with its response (see [Section
    8](#sec_transactions){.xref}).[¶](#section-5.1-8.4){.pilcrow}
:   

User ID:
:   This field contains a 16-bit unsigned integer that uniquely
    identifies a participant within a
    conference.[¶](#section-5.1-8.6){.pilcrow}
:   

The identity used by a participant in BFCP, which is carried in the User
ID field, is generally mapped to the identity used by the same
participant in the session establishment protocol (e.g., in SIP). The
way this mapping is performed is outside the scope of this
specification.[¶](#section-5.1-9.1){.pilcrow}

[]{.break}

Fragment Offset:
:   This optional field is present only if the F flag is set and
    contains a 16-bit value that specifies the number of 4-octet units
    contained in previous fragments, excluding the
    COMMON-HEADER.[¶](#section-5.1-10.2){.pilcrow}
:   

Fragment Length:
:   This optional field is present only if the F flag is set and
    contains a 16-bit value that specifies the number of 4-octet units
    contained in this fragment, excluding the COMMON-HEADER. BFCP
    entities that receive message fragments that, individually or
    collectively, exceed the Payload Length value [MUST]{.bcp14} discard
    the message. Additionally, if the receiver is a floor control
    server, it [MUST]{.bcp14} also send an Error message with parameter
    value 13 (Incorrect Message Length)[¶](#section-5.1-10.4){.pilcrow}
:   
:::
:::

::: {#sec_format_attributes}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Attribute Format](#name-attribute-format){.section-name .selfRef} {#name-attribute-format}

BFCP attributes are encoded in TLV (Type-Length-Value) format.
Attributes are 32-bit aligned.[¶](#section-5.2-1){.pilcrow}

[]{#name-attribute-format-2}

::: {#sec_format_tlv}
::: {#section-5.2-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Type     |M|    Length     |                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
      |                                                               |
      /                       Attribute Contents                      /
      /                                                               /
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 6](#figure-6){.selfRef}: [Attribute
format](#name-attribute-format-2){.selfRef}
:::

[]{.break}

Type:

:   This 7-bit field contains the type of the attribute. Each attribute,
    identified by its type, has a particular format. The attribute
    formats defined are:[¶](#section-5.2-3.2.1){.pilcrow}

    []{.break}

    Unsigned16:
    :   The contents of the attribute consist of a 16-bit unsigned
        integer.[¶](#section-5.2-3.2.2.2){.pilcrow}
    :   

    OctetString16:
    :   The contents of the attribute consist of 16 bits of arbitrary
        data.[¶](#section-5.2-3.2.2.4){.pilcrow}
    :   

    OctetString:
    :   The contents of the attribute consist of arbitrary data of
        variable length.[¶](#section-5.2-3.2.2.6){.pilcrow}
    :   

    Grouped:
    :   The contents of the attribute consist of a sequence of
        attributes.[¶](#section-5.2-3.2.2.8){.pilcrow}
    :   

:   

Note that extension attributes defined in the future may define new
attribute formats.[¶](#section-5.2-4.1){.pilcrow}

The following attribute types are defined:[¶](#section-5.2-5){.pilcrow}

[]{#name-bfcp-attributes}

::: {#tab_attributes}
  Type   Attribute                   Format
  ------ --------------------------- ---------------
  1      BENEFICIARY-ID              Unsigned16
  2      FLOOR-ID                    Unsigned16
  3      FLOOR-REQUEST-ID            Unsigned16
  4      PRIORITY                    OctetString16
  5      REQUEST-STATUS              OctetString16
  6      ERROR-CODE                  OctetString
  7      ERROR-INFO                  OctetString
  8      PARTICIPANT-PROVIDED-INFO   OctetString
  9      STATUS-INFO                 OctetString
  10     SUPPORTED-ATTRIBUTES        OctetString
  11     SUPPORTED-PRIMITIVES        OctetString
  12     USER-DISPLAY-NAME           OctetString
  13     USER-URI                    OctetString
  14     BENEFICIARY-INFORMATION     Grouped
  15     FLOOR-REQUEST-INFORMATION   Grouped
  16     REQUESTED-BY-INFORMATION    Grouped
  17     FLOOR-REQUEST-STATUS        Grouped
  18     OVERALL-REQUEST-STATUS      Grouped

  : [Table 2](#table-2){.selfRef}: [BFCP
  attributes](#name-bfcp-attributes){.selfRef}
:::

[]{.break}

M:
:   The \'M\' bit, known as the Mandatory bit, indicates whether support
    of the attribute is [REQUIRED]{.bcp14}. If a floor control server
    receives an unrecognized attribute with the \'M\' bit set, the
    server [MUST]{.bcp14} send an Error message with parameter value 4
    (Unknown Mandatory Attribute) to indicate this. The \'M\' bit is
    significant for extension attributes defined in other documents
    only. All attributes specified in this document [MUST]{.bcp14} be
    understood by the receiver so that the setting of the \'M\' bit is
    irrelevant for these. Unrecognized attributes, such as those that
    might be specified in future extensions, that do not have the \'M\'
    bit set are ignored, but the message is
    processed.[¶](#section-5.2-7.2){.pilcrow}
:   

Length:
:   This 8-bit field contains the length of the attribute in octets,
    excluding any padding defined for specific attributes. The length of
    attributes that are not grouped includes the Type, \'M\' bit, and
    Length fields. The Length in grouped attributes is the length of the
    grouped attribute itself (including Type, \'M\' bit, and Length
    fields) plus the total length (including padding) of all the
    included attributes.[¶](#section-5.2-7.4){.pilcrow}
:   

Attribute Contents:
:   The contents of the different attributes are defined in the
    following sections.[¶](#section-5.2-7.6){.pilcrow}
:   

::: {#sec_format_attributes_beneficiaryid}
::: {#section-5.2.1 .section}
#### [5.2.1.](#section-5.2.1){.section-number .selfRef} [BENEFICIARY-ID](#name-beneficiary-id){.section-name .selfRef} {#name-beneficiary-id}

The following is the format of the BENEFICIARY-ID
attribute.[¶](#section-5.2.1-1){.pilcrow}

[]{#name-beneficiary-id-format}

::: {#sec_format_beneficiary-id}
::: {#section-5.2.1-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 0 0 0 1|M|0 0 0 0 0 1 0 0|        Beneficiary ID         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 7](#figure-7){.selfRef}: [BENEFICIARY-ID
format](#name-beneficiary-id-format){.selfRef}
:::

[]{.break}

Beneficiary ID:
:   This field contains a 16-bit value that uniquely identifies a user
    within a conference.[¶](#section-5.2.1-3.2){.pilcrow}
:   

Note that although the formats of the Beneficiary ID and of the User ID
field in the COMMON-HEADER are similar, their semantics are different.
The Beneficiary ID is used in third-party floor requests and to request
information about a particular
participant.[¶](#section-5.2.1-4.1){.pilcrow}
:::
:::

::: {#sec_format_attributes_floorid}
::: {#section-5.2.2 .section}
#### [5.2.2.](#section-5.2.2){.section-number .selfRef} [FLOOR-ID](#name-floor-id){.section-name .selfRef} {#name-floor-id}

The following is the format of the FLOOR-ID
attribute.[¶](#section-5.2.2-1){.pilcrow}

[]{#name-floor-id-format}

::: {#sec_format_floor-id}
::: {#section-5.2.2-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 0 0 1 0|M|0 0 0 0 0 1 0 0|           Floor ID            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 8](#figure-8){.selfRef}: [FLOOR-ID
format](#name-floor-id-format){.selfRef}
:::

[]{.break}

Floor ID:
:   This field contains a 16-bit value that uniquely identifies a floor
    within a conference.[¶](#section-5.2.2-3.2){.pilcrow}
:   
:::
:::

::: {#sec_format_attributes_floorrequestid}
::: {#section-5.2.3 .section}
#### [5.2.3.](#section-5.2.3){.section-number .selfRef} [FLOOR-REQUEST-ID](#name-floor-request-id){.section-name .selfRef} {#name-floor-request-id}

The following is the format of the FLOOR-REQUEST-ID
attribute.[¶](#section-5.2.3-1){.pilcrow}

[]{#name-floor-request-id-format}

::: {#sec_format_floor-request-id}
::: {#section-5.2.3-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 0 0 1 1|M|0 0 0 0 0 1 0 0|       Floor Request ID        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 9](#figure-9){.selfRef}: [FLOOR-REQUEST-ID
format](#name-floor-request-id-format){.selfRef}
:::

[]{.break}

Floor Request ID:
:   This field contains a 16-bit value that identifies a floor request
    at the floor control server.[¶](#section-5.2.3-3.2){.pilcrow}
:   
:::
:::

::: {#sec_format_attributes_priority}
::: {#section-5.2.4 .section}
#### [5.2.4.](#section-5.2.4){.section-number .selfRef} [PRIORITY](#name-priority){.section-name .selfRef} {#name-priority}

The following is the format of the PRIORITY
attribute.[¶](#section-5.2.4-1){.pilcrow}

[]{#name-priority-format}

::: {#sec_format_priority}
::: {#section-5.2.4-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 0 1 0 0|M|0 0 0 0 0 1 0 0|Prio |         Reserved        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 10](#figure-10){.selfRef}: [PRIORITY
format](#name-priority-format){.selfRef}
:::

[]{.break}

Prio:
:   This field contains a 3-bit Priority value, as shown in [Table
    3](#tab_priority){.xref}. Senders [SHOULD NOT]{.bcp14} use values
    higher than 4 in this field. Receivers [MUST]{.bcp14} treat values
    higher than 4 as if the value received were 4 (Highest). The default
    Priority value when the PRIORITY attribute is missing is 2
    (Normal).[¶](#section-5.2.4-3.2){.pilcrow}
:   

[]{#name-priority-values}

::: {#tab_priority}
  Value   Priority
  ------- ----------
  0       Lowest
  1       Low
  2       Normal
  3       High
  4       Highest

  : [Table 3](#table-3){.selfRef}: [Priority
  values](#name-priority-values){.selfRef}
:::

[]{.break}

Reserved:
:   The 13 bits in the reserved field [MUST]{.bcp14} be set to zero by
    the sender of the message and [MUST]{.bcp14} be ignored by the
    receiver.[¶](#section-5.2.4-5.2){.pilcrow}
:   
:::
:::

::: {#sec_format_attributes_req-status}
::: {#section-5.2.5 .section}
#### [5.2.5.](#section-5.2.5){.section-number .selfRef} [REQUEST-STATUS](#name-request-status){.section-name .selfRef} {#name-request-status}

The following is the format of the REQUEST-STATUS
attribute.[¶](#section-5.2.5-1){.pilcrow}

[]{#name-request-status-format}

::: {#sec_format_request-status}
::: {#section-5.2.5-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 0 1 0 1|M|0 0 0 0 0 1 0 0|Request Status |Queue Position |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 11](#figure-11){.selfRef}: [REQUEST-STATUS
format](#name-request-status-format){.selfRef}
:::

[]{.break}

Request Status:
:   This 8-bit field contains the status of the request, as described in
    the following table.[¶](#section-5.2.5-3.2){.pilcrow}
:   

[]{#name-request-status-values}

::: {#tab_requeststatusvalues}
  Value   Status
  ------- -----------
  1       Pending
  2       Accepted
  3       Granted
  4       Denied
  5       Cancelled
  6       Released
  7       Revoked

  : [Table 4](#table-4){.selfRef}: [Request Status
  values](#name-request-status-values){.selfRef}
:::

[]{.break}

Queue Position:
:   This 8-bit field contains, when applicable, the position of the
    floor request in the floor request queue at the server. If the
    Request Status value is different from Accepted, if the floor
    control server does not implement a floor request queue, or if the
    floor control server does not want to provide the client with this
    information, all the bits of this field [SHOULD]{.bcp14} be set to
    zero.[¶](#section-5.2.5-5.2){.pilcrow}
:   

A floor request is in Pending state if the floor control server needs to
contact a floor chair in order to accept the floor request, but has not
done it yet. Once the floor control chair accepts the floor request, the
floor request is moved to the Accepted
state.[¶](#section-5.2.5-6){.pilcrow}
:::
:::

::: {#sec_format_attributes_error-code}
::: {#section-5.2.6 .section}
#### [5.2.6.](#section-5.2.6){.section-number .selfRef} [ERROR-CODE](#name-error-code){.section-name .selfRef} {#name-error-code}

The following is the format of the ERROR-CODE
attribute.[¶](#section-5.2.6-1){.pilcrow}

[]{#name-error-code-format}

::: {#sec_format_error}
::: {#section-5.2.6-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 0 1 1 0|M|    Length     |  Error Code   |               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
      |                                                               |
      |                     Error Specific Details                    |
      /                                                               /
      /                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               |            Padding            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 12](#figure-12){.selfRef}: [ERROR-CODE
format](#name-error-code-format){.selfRef}
:::

[]{.break}

Error Code:
:   This 8-bit field contains an error code from the following table. If
    an error code is not recognized by the receiver, then the receiver
    [MUST]{.bcp14} assume that an error exists, and therefore that the
    original message that triggered the Error message to be sent is
    processed, but the nature of the error is
    unclear.[¶](#section-5.2.6-3.2){.pilcrow}
:   

[]{#name-error-code-meaning}

::: {#tab_errorcode}
  Value   Meaning
  ------- --------------------------------------------------------------------------------------
  1       Conference Does Not Exist
  2       User Does Not Exist
  3       Unknown Primitive
  4       Unknown Mandatory Attribute
  5       Unauthorized Operation
  6       Invalid Floor ID
  7       Floor Request ID Does Not Exist
  8       You have Already Reached the Maximum Number of Ongoing Floor Requests for This Floor
  9       Use TLS
  10      Unable to Parse Message
  11      Use DTLS
  12      Unsupported Version
  13      Incorrect Message Length
  14      Generic Error

  : [Table 5](#table-5){.selfRef}: [Error Code
  meaning](#name-error-code-meaning){.selfRef}
:::

Note: The Generic Error error code is intended to be used when an error
occurs and the other specific error codes do not
apply.[¶](#section-5.2.6-5.1){.pilcrow}

[]{.break}

Error Specific Details:
:   Present only for certain error codes. In this document, this field
    is present only for Error Code 4 (Unknown Mandatory Attribute). See
    [Section
    5.2.6.1](#sec_format_attributes_error-code_specific-4){.xref} for
    its definition.[¶](#section-5.2.6-6.2){.pilcrow}
:   

Padding:

:   One, two, or three octets of padding added so that the contents of
    the ERROR-CODE attribute is 32-bit aligned. If the attribute is
    already 32-bit aligned, no padding is
    needed.[¶](#section-5.2.6-6.4.1){.pilcrow}

    The Padding bits [MUST]{.bcp14} be set to zero by the sender and
    [MUST]{.bcp14} be ignored by the
    receiver.[¶](#section-5.2.6-6.4.2){.pilcrow}

:   

::: {#sec_format_attributes_error-code_specific-4}
::: {#section-5.2.6.1 .section}
##### [5.2.6.1.](#section-5.2.6.1){.section-number .selfRef} [Error Specific Details for Error Code 4](#name-error-specific-details-for-){.section-name .selfRef} {#name-error-specific-details-for-}

The following is the format of the Error Specific Details field for
Error Code 4.[¶](#section-5.2.6.1-1){.pilcrow}

[]{#name-unknown-attributes-format}

::: {#sec_format_unknown-tlvs}
::: {#section-5.2.6.1-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | Unknown Type|R| Unknown Type|R| Unknown Type|R| Unknown Type|R|
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      /                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               | Unknown Type|R| Unknown Type|R|
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | Unknown Type|R| Unknown Type|R|
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 13](#figure-13){.selfRef}: [Unknown attributes
format](#name-unknown-attributes-format){.selfRef}
:::

[]{.break}

Unknown Type:
:   These 7-bit fields contain the Types of the attributes (which were
    present in the message that triggered the Error message) that were
    unknown to the receiver.[¶](#section-5.2.6.1-3.2){.pilcrow}
:   

Reserved (R):
:   This bit is reserved. It [MUST]{.bcp14} be set to zero by the sender
    of the message and [MUST]{.bcp14} be ignored by the
    receiver.[¶](#section-5.2.6.1-3.4){.pilcrow}
:   
:::
:::
:::
:::

::: {#sec_format_attributes_error-info}
::: {#section-5.2.7 .section}
#### [5.2.7.](#section-5.2.7){.section-number .selfRef} [ERROR-INFO](#name-error-info){.section-name .selfRef} {#name-error-info}

The following is the format of the ERROR-INFO
attribute.[¶](#section-5.2.7-1){.pilcrow}

[]{#name-error-info-format}

::: {#sec_format_error-info}
::: {#section-5.2.7-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 0 1 1 1|M|    Length     |                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
      |                                                               |
      /                             Text                              /
      /                                               +-+-+-+-+-+-+-+-+
      |                                               |    Padding    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 14](#figure-14){.selfRef}: [ERROR-INFO
format](#name-error-info-format){.selfRef}
:::

[]{.break}

Text:

:   This field contains UTF-8 encoded text
    \[[9](#RFC3629){.xref}\].[¶](#section-5.2.7-3.2.1){.pilcrow}

    In some situations, the contents of the Text field may be generated
    by an automaton. If this automaton has information about the
    preferred language of the receiver of a particular ERROR-INFO
    attribute, it [MAY]{.bcp14} use this language to generate the Text
    field.[¶](#section-5.2.7-3.2.2){.pilcrow}

:   

Padding:
:   One, two, or three octets of padding added so that the contents of
    the ERROR-INFO attribute is 32-bit aligned. The Padding bits
    [MUST]{.bcp14} be set to zero by the sender and [MUST]{.bcp14} be
    ignored by the receiver. If the attribute is already 32-bit aligned,
    no padding is needed.[¶](#section-5.2.7-3.4){.pilcrow}
:   
:::
:::

::: {#sec_format_attributes_human-read-info}
::: {#section-5.2.8 .section}
#### [5.2.8.](#section-5.2.8){.section-number .selfRef} [PARTICIPANT-PROVIDED-INFO](#name-participant-provided-info){.section-name .selfRef} {#name-participant-provided-info}

The following is the format of the PARTICIPANT-PROVIDED-INFO
attribute.[¶](#section-5.2.8-1){.pilcrow}

[]{#name-participant-provided-info-f}

::: {#sec_format_human}
::: {#section-5.2.8-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 1 0 0 0|M|    Length     |                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
      |                                                               |
      /                             Text                              /
      /                                               +-+-+-+-+-+-+-+-+
      |                                               |    Padding    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 15](#figure-15){.selfRef}: [PARTICIPANT-PROVIDED-INFO
format](#name-participant-provided-info-f){.selfRef}
:::

[]{.break}

Text:
:   This field contains UTF-8 encoded text
    \[[9](#RFC3629){.xref}\].[¶](#section-5.2.8-3.2){.pilcrow}
:   

Padding:
:   One, two, or three octets of padding added so that the contents of
    the PARTICIPANT-PROVIDED-INFO attribute is 32-bit aligned. The
    Padding bits [MUST]{.bcp14} be set to zero by the sender and
    [MUST]{.bcp14} be ignored by the receiver. If the attribute is
    already 32-bit aligned, no padding is
    needed.[¶](#section-5.2.8-3.4){.pilcrow}
:   
:::
:::

::: {#sec_format_attributes_status-info}
::: {#section-5.2.9 .section}
#### [5.2.9.](#section-5.2.9){.section-number .selfRef} [STATUS-INFO](#name-status-info){.section-name .selfRef} {#name-status-info}

The following is the format of the STATUS-INFO
attribute.[¶](#section-5.2.9-1){.pilcrow}

[]{#name-status-info-format}

::: {#sec_format_status}
::: {#section-5.2.9-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 1 0 0 1|M|    Length     |                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
      |                                                               |
      /                             Text                              /
      /                                               +-+-+-+-+-+-+-+-+
      |                                               |    Padding    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 16](#figure-16){.selfRef}: [STATUS-INFO
format](#name-status-info-format){.selfRef}
:::

[]{.break}

Text:

:   This field contains UTF-8 encoded text
    \[[9](#RFC3629){.xref}\].[¶](#section-5.2.9-3.2.1){.pilcrow}

    In some situations, the contents of the Text field may be generated
    by an automaton. If this automaton has information about the
    preferred language of the receiver of a particular STATUS-INFO
    attribute, it [MAY]{.bcp14} use this language to generate the Text
    field.[¶](#section-5.2.9-3.2.2){.pilcrow}

:   

Padding:
:   One, two, or three octets of padding added so that the contents of
    the STATUS-INFO attribute is 32-bit aligned. The Padding bits
    [MUST]{.bcp14} be set to zero by the sender and [MUST]{.bcp14} be
    ignored by the receiver. If the attribute is already 32-bit aligned,
    no padding is needed.[¶](#section-5.2.9-3.4){.pilcrow}
:   
:::
:::

::: {#sec_format_attributes_supported-tlvs}
::: {#section-5.2.10 .section}
#### [5.2.10.](#section-5.2.10){.section-number .selfRef} [SUPPORTED-ATTRIBUTES](#name-supported-attributes){.section-name .selfRef} {#name-supported-attributes}

The following is the format of the SUPPORTED-ATTRIBUTES
attribute.[¶](#section-5.2.10-1){.pilcrow}

[]{#name-supported-attributes-format}

::: {#fig_format_supported-tlvs}
::: {#section-5.2.10-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 1 0 1 0|M|    Length     | Supp. Attr. |R| Supp. Attr. |R|
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | Supp. Attr. |R| Supp. Attr. |R| Supp. Attr. |R| Supp. Attr. |R|
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      /                                                               /
      /                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               |            Padding            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 17](#figure-17){.selfRef}: [SUPPORTED-ATTRIBUTES
format](#name-supported-attributes-format){.selfRef}
:::

[]{.break}

Supp. Attr.:
:   These fields contain the BFCP attribute types that are supported by
    the floor control server. See [Table 2](#tab_attributes){.xref} for
    the list of BFCP attributes.[¶](#section-5.2.10-3.2){.pilcrow}
:   

Reserved (R):
:   This bit [MUST]{.bcp14} be set to zero upon transmission and
    [MUST]{.bcp14} be ignored upon
    reception.[¶](#section-5.2.10-3.4){.pilcrow}
:   

Padding:

:   One, two, or three octets of padding added so that the contents of
    the SUPPORTED-ATTRIBUTES attribute is 32-bit aligned. If the
    attribute is already 32-bit aligned, no padding is
    needed.[¶](#section-5.2.10-3.6.1){.pilcrow}

    The Padding bits [MUST]{.bcp14} be set to zero by the sender and
    [MUST]{.bcp14} be ignored by the
    receiver.[¶](#section-5.2.10-3.6.2){.pilcrow}

:   
:::
:::

::: {#sec_format_attributes_supported-reqs}
::: {#section-5.2.11 .section}
#### [5.2.11.](#section-5.2.11){.section-number .selfRef} [SUPPORTED-PRIMITIVES](#name-supported-primitives){.section-name .selfRef} {#name-supported-primitives}

The following is the format of the SUPPORTED-PRIMITIVES
attribute.[¶](#section-5.2.11-1){.pilcrow}

[]{#name-supported-primitives-format}

::: {#fig_format_supported-reqs}
::: {#section-5.2.11-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 1 0 1 1|M|    Length     |   Primitive   |   Primitive   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Primitive   |   Primitive   |   Primitive   |   Primitive   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      /                                                               /
      /                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               |            Padding            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 18](#figure-18){.selfRef}: [SUPPORTED-PRIMITIVES
format](#name-supported-primitives-format){.selfRef}
:::

[]{.break}

Primitive:
:   These fields contain the types of the BFCP messages that are
    supported by the floor control server. See [Table
    1](#tab_primitives){.xref} for the list of BFCP
    primitives.[¶](#section-5.2.11-3.2){.pilcrow}
:   

Padding:

:   One, two, or three octets of padding added so that the contents of
    the SUPPORTED-PRIMITIVES attribute is 32-bit aligned. If the
    attribute is already 32-bit aligned, no padding is
    needed.[¶](#section-5.2.11-3.4.1){.pilcrow}

    The Padding bits [MUST]{.bcp14} be set to zero by the sender and
    [MUST]{.bcp14} be ignored by the
    receiver.[¶](#section-5.2.11-3.4.2){.pilcrow}

:   
:::
:::

::: {#sec_format_attributes_user-display-name}
::: {#section-5.2.12 .section}
#### [5.2.12.](#section-5.2.12){.section-number .selfRef} [USER-DISPLAY-NAME](#name-user-display-name){.section-name .selfRef} {#name-user-display-name}

The following is the format of the USER-DISPLAY-NAME
attribute.[¶](#section-5.2.12-1){.pilcrow}

[]{#name-user-display-name-format}

::: {#sec_format_user-display}
::: {#section-5.2.12-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 1 1 0 0|M|    Length     |                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
      |                                                               |
      /                             Text                              /
      /                                               +-+-+-+-+-+-+-+-+
      |                                               |    Padding    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 19](#figure-19){.selfRef}: [USER-DISPLAY-NAME
format](#name-user-display-name-format){.selfRef}
:::

[]{.break}

Text:
:   This field contains the UTF-8 encoded name of the
    user.[¶](#section-5.2.12-3.2){.pilcrow}
:   

Padding:
:   One, two, or three octets of padding added so that the contents of
    the USER-DISPLAY-NAME attribute is 32-bit aligned. The Padding bits
    [MUST]{.bcp14} be set to zero by the sender and [MUST]{.bcp14} be
    ignored by the receiver. If the attribute is already 32-bit aligned,
    no padding is needed.[¶](#section-5.2.12-3.4){.pilcrow}
:   
:::
:::

::: {#sec_format_attributes_user-uri}
::: {#section-5.2.13 .section}
#### [5.2.13.](#section-5.2.13){.section-number .selfRef} [USER-URI](#name-user-uri){.section-name .selfRef} {#name-user-uri}

The following is the format of the USER-URI
attribute.[¶](#section-5.2.13-1){.pilcrow}

[]{#name-user-uri-format}

::: {#sec_format_user-uri}
::: {#section-5.2.13-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 1 1 0 1|M|    Length     |                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
      |                                                               |
      /                             Text                              /
      /                                               +-+-+-+-+-+-+-+-+
      |                                               |    Padding    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 20](#figure-20){.selfRef}: [USER-URI
format](#name-user-uri-format){.selfRef}
:::

[]{.break}

Text:
:   This field contains the UTF-8 encoded user\'s contact URI, that is,
    the URI used by the user to set up the resources (e.g., media
    streams) that are controlled by BFCP. For example, in the context of
    a conference set up by SIP, the USER-URI attribute would carry the
    SIP URI of the user.[¶](#section-5.2.13-3.2){.pilcrow}
:   

Messages containing a user\'s URI in a USER-URI attribute also contain
the user\'s User ID. This way, a client receiving such a message can
correlate the user\'s URI (e.g., the SIP URI the user used to join a
conference) with the user\'s User ID.[¶](#section-5.2.13-4.1){.pilcrow}

[]{.break}

Padding:
:   One, two, or three octets of padding added so that the contents of
    the USER-URI attribute is 32-bit aligned. The Padding bits
    [MUST]{.bcp14} be set to zero by the sender and [MUST]{.bcp14} be
    ignored by the receiver. If the attribute is already 32-bit aligned,
    no padding is needed.[¶](#section-5.2.13-5.2){.pilcrow}
:   
:::
:::

::: {#sec_format_attributes_ben-info}
::: {#section-5.2.14 .section}
#### [5.2.14.](#section-5.2.14){.section-number .selfRef} [BENEFICIARY-INFORMATION](#name-beneficiary-information){.section-name .selfRef} {#name-beneficiary-information}

The BENEFICIARY-INFORMATION attribute is a grouped attribute that
consists of a header, which is referred to as
BENEFICIARY-INFORMATION-HEADER, followed by a sequence of attributes.
The following is the format of the
BENEFICIARY-INFORMATION-HEADER:[¶](#section-5.2.14-1){.pilcrow}

[]{#name-beneficiary-information-hea}

::: {#fig_format_ben-information-header}
::: {#section-5.2.14-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 1 1 1 0|M|    Length     |        Beneficiary ID         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 21](#figure-21){.selfRef}: [BENEFICIARY-INFORMATION-HEADER
format](#name-beneficiary-information-hea){.selfRef}
:::

[]{.break}

Beneficiary ID:
:   This field contains a 16-bit value that uniquely identifies a user
    within a conference.[¶](#section-5.2.14-3.2){.pilcrow}
:   

The following is the ABNF (Augmented Backus-Naur Form)
\[[5](#RFC5234){.xref}\] of the BENEFICIARY-INFORMATION grouped
attribute. (EXTENSION-ATTRIBUTE refers to extension attributes that may
be defined in the future.)[¶](#section-5.2.14-4){.pilcrow}

[]{#name-beneficiary-information-for}

::: {#fig_ben-information}
::: {#section-5.2.14-5.1}
``` {.sourcecode .lang-abnf}
BENEFICIARY-INFORMATION =  BENEFICIARY-INFORMATION-HEADER
                           [USER-DISPLAY-NAME]
                           [USER-URI]
                          *EXTENSION-ATTRIBUTE
```
:::

[Figure 22](#figure-22){.selfRef}: [BENEFICIARY-INFORMATION
format](#name-beneficiary-information-for){.selfRef}
:::
:::
:::

::: {#sec_format_attributes_floor-req-info}
::: {#section-5.2.15 .section}
#### [5.2.15.](#section-5.2.15){.section-number .selfRef} [FLOOR-REQUEST-INFORMATION](#name-floor-request-information){.section-name .selfRef} {#name-floor-request-information}

The FLOOR-REQUEST-INFORMATION attribute is a grouped attribute that
consists of a header, which is referred to as
FLOOR-REQUEST-INFORMATION-HEADER, followed by a sequence of attributes.
The following is the format of the
FLOOR-REQUEST-INFORMATION-HEADER:[¶](#section-5.2.15-1){.pilcrow}

[]{#name-floor-request-information-h}

::: {#fig_format_request-information-header}
::: {#section-5.2.15-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 1 1 1 1|M|    Length     |       Floor Request ID        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 23](#figure-23){.selfRef}: [FLOOR-REQUEST-INFORMATION-HEADER
format](#name-floor-request-information-h){.selfRef}
:::

[]{.break}

Floor Request ID:
:   This field contains a 16-bit value that identifies a floor request
    at the floor control server.[¶](#section-5.2.15-3.2){.pilcrow}
:   

The following is the ABNF of the FLOOR-REQUEST-INFORMATION grouped
attribute. (EXTENSION-ATTRIBUTE refers to extension attributes that may
be defined in the future.)[¶](#section-5.2.15-4){.pilcrow}

[]{#name-floor-request-information-f}

::: {#fig_floor-request-information}
::: {#section-5.2.15-5.1}
``` {.sourcecode .lang-abnf}
FLOOR-REQUEST-INFORMATION =   FLOOR-REQUEST-INFORMATION-HEADER
                              [OVERALL-REQUEST-STATUS]
                            1*FLOOR-REQUEST-STATUS
                              [BENEFICIARY-INFORMATION]
                              [REQUESTED-BY-INFORMATION]
                              [PRIORITY]
                              [PARTICIPANT-PROVIDED-INFO]
                             *EXTENSION-ATTRIBUTE
```
:::

[Figure 24](#figure-24){.selfRef}: [FLOOR-REQUEST-INFORMATION
format](#name-floor-request-information-f){.selfRef}
:::
:::
:::

::: {#sec_format_attributes_req-by-info}
::: {#section-5.2.16 .section}
#### [5.2.16.](#section-5.2.16){.section-number .selfRef} [REQUESTED-BY-INFORMATION](#name-requested-by-information){.section-name .selfRef} {#name-requested-by-information}

The REQUESTED-BY-INFORMATION attribute is a grouped attribute that
consists of a header, which is referred to as
REQUESTED-BY-INFORMATION-HEADER, followed by a sequence of attributes.
The following is the format of the
REQUESTED-BY-INFORMATION-HEADER:[¶](#section-5.2.16-1){.pilcrow}

[]{#name-requested-by-information-he}

::: {#fig_format_req-by-information-header}
::: {#section-5.2.16-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 1 0 0 0 0|M|    Length     |       Requested-by ID         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 25](#figure-25){.selfRef}: [REQUESTED-BY-INFORMATION-HEADER
format](#name-requested-by-information-he){.selfRef}
:::

[]{.break}

Requested-by ID:
:   This field contains a 16-bit value that uniquely identifies a user
    within a conference.[¶](#section-5.2.16-3.2){.pilcrow}
:   

The following is the ABNF of the REQUESTED-BY-INFORMATION grouped
attribute. (EXTENSION-ATTRIBUTE refers to extension attributes that may
be defined in the future.)[¶](#section-5.2.16-4){.pilcrow}

[]{#name-requested-by-information-fo}

::: {#fig_reqby-information}
::: {#section-5.2.16-5.1}
``` {.sourcecode .lang-abnf}
REQUESTED-BY-INFORMATION =  REQUESTED-BY-INFORMATION-HEADER
                            [USER-DISPLAY-NAME]
                            [USER-URI]
                           *EXTENSION-ATTRIBUTE
```
:::

[Figure 26](#figure-26){.selfRef}: [REQUESTED-BY-INFORMATION
format](#name-requested-by-information-fo){.selfRef}
:::
:::
:::

::: {#sec_format_attributes_floor-req-status}
::: {#section-5.2.17 .section}
#### [5.2.17.](#section-5.2.17){.section-number .selfRef} [FLOOR-REQUEST-STATUS](#name-floor-request-status){.section-name .selfRef} {#name-floor-request-status}

The FLOOR-REQUEST-STATUS attribute is a grouped attribute that consists
of a header, which is referred to as FLOOR-REQUEST-STATUS-HEADER,
followed by a sequence of attributes. The following is the format of the
FLOOR-REQUEST-STATUS-HEADER:[¶](#section-5.2.17-1){.pilcrow}

[]{#name-floor-request-status-header}

::: {#fig_format_floor-req-status-header}
::: {#section-5.2.17-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 1 0 0 0 1|M|    Length     |           Floor ID            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 27](#figure-27){.selfRef}: [FLOOR-REQUEST-STATUS-HEADER
format](#name-floor-request-status-header){.selfRef}
:::

[]{.break}

Floor ID:
:   this field contains a 16-bit value that uniquely identifies a floor
    within a conference.[¶](#section-5.2.17-3.2){.pilcrow}
:   

The following is the ABNF of the FLOOR-REQUEST-STATUS grouped attribute.
(EXTENSION-ATTRIBUTE refers to extension attributes that may be defined
in the future.)[¶](#section-5.2.17-4){.pilcrow}

[]{#name-floor-request-status-format}

::: {#fig_floor-req-status}
::: {#section-5.2.17-5.1}
``` {.sourcecode .lang-abnf}
FLOOR-REQUEST-STATUS =  FLOOR-REQUEST-STATUS-HEADER
                        [REQUEST-STATUS]
                        [STATUS-INFO]
                       *EXTENSION-ATTRIBUTE
```
:::

[Figure 28](#figure-28){.selfRef}: [FLOOR-REQUEST-STATUS
format](#name-floor-request-status-format){.selfRef}
:::
:::
:::

::: {#sec_format_attributes_overall-req-status}
::: {#section-5.2.18 .section}
#### [5.2.18.](#section-5.2.18){.section-number .selfRef} [OVERALL-REQUEST-STATUS](#name-overall-request-status){.section-name .selfRef} {#name-overall-request-status}

The OVERALL-REQUEST-STATUS attribute is a grouped attribute that
consists of a header, which is referred to as
OVERALL-REQUEST-STATUS-HEADER, followed by a sequence of attributes. The
following is the format of the
OVERALL-REQUEST-STATUS-HEADER:[¶](#section-5.2.18-1){.pilcrow}

[]{#name-overall-request-status-head}

::: {#fig_format_overall-req-status-header}
::: {#section-5.2.18-2.1 .artwork .art-text .alignLeft}
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 1 0 0 1 0|M|    Length     |       Floor Request ID        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 29](#figure-29){.selfRef}: [OVERALL-REQUEST-STATUS-HEADER
format](#name-overall-request-status-head){.selfRef}
:::

[]{.break}

Floor Request ID:
:   This field contains a 16-bit value that identifies a floor request
    at the floor control server.[¶](#section-5.2.18-3.2){.pilcrow}
:   

The following is the ABNF of the OVERALL-REQUEST-STATUS grouped
attribute. (EXTENSION-ATTRIBUTE refers to extension attributes that may
be defined in the future.)[¶](#section-5.2.18-4){.pilcrow}

[]{#name-overall-request-status-form}

::: {#fig_overall-req-status}
::: {#section-5.2.18-5.1}
``` {.sourcecode .lang-abnf}
OVERALL-REQUEST-STATUS =  OVERALL-REQUEST-STATUS-HEADER
                          [REQUEST-STATUS]
                          [STATUS-INFO]
                         *EXTENSION-ATTRIBUTE
```
:::

[Figure 30](#figure-30){.selfRef}: [OVERALL-REQUEST-STATUS
format](#name-overall-request-status-form){.selfRef}
:::
:::
:::
:::
:::

::: {#sec_msg_format}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Message Format](#name-message-format){.section-name .selfRef} {#name-message-format}

This section contains the normative ABNF (Augmented Backus-Naur Form)
\[[5](#RFC5234){.xref}\] of the BFCP messages. Extension attributes that
may be defined in the future are referred to as EXTENSION-ATTRIBUTE in
the ABNF.[¶](#section-5.3-1){.pilcrow}

::: {#sec_msg_format_FloorRequest}
::: {#section-5.3.1 .section}
#### [5.3.1.](#section-5.3.1){.section-number .selfRef} [FloorRequest](#name-floorrequest){.section-name .selfRef} {#name-floorrequest}

Floor participants request a floor by sending a FloorRequest message to
the floor control server. The following is the format of the
FloorRequest message:[¶](#section-5.3.1-1){.pilcrow}

[]{#name-floorrequest-format}

::: {#fig_floorequest}
::: {#section-5.3.1-2.1}
``` {.sourcecode .lang-abnf}
FloorRequest =   COMMON-HEADER
               1*FLOOR-ID
                 [BENEFICIARY-ID]
                 [PARTICIPANT-PROVIDED-INFO]
                 [PRIORITY]
                *EXTENSION-ATTRIBUTE
```
:::

[Figure 31](#figure-31){.selfRef}: [FloorRequest
format](#name-floorrequest-format){.selfRef}
:::
:::
:::

::: {#sec_msg_format_FloorRelease}
::: {#section-5.3.2 .section}
#### [5.3.2.](#section-5.3.2){.section-number .selfRef} [FloorRelease](#name-floorrelease){.section-name .selfRef} {#name-floorrelease}

Floor participants release a floor by sending a FloorRelease message to
the floor control server. Floor participants also use the FloorRelease
message to cancel pending floor requests. The following is the format of
the FloorRelease message:[¶](#section-5.3.2-1){.pilcrow}

[]{#name-floorrelease-format}

::: {#fig_floorelease}
::: {#section-5.3.2-2.1}
``` {.sourcecode .lang-abnf}
FloorRelease =  COMMON-HEADER
                FLOOR-REQUEST-ID
               *EXTENSION-ATTRIBUTE
```
:::

[Figure 32](#figure-32){.selfRef}: [FloorRelease
format](#name-floorrelease-format){.selfRef}
:::
:::
:::

::: {#sec_msg_format_FloorRequestQuery}
::: {#section-5.3.3 .section}
#### [5.3.3.](#section-5.3.3){.section-number .selfRef} [FloorRequestQuery](#name-floorrequestquery){.section-name .selfRef} {#name-floorrequestquery}

Floor participants and floor chairs request information about a floor
request by sending a FloorRequestQuery message to the floor control
server. The following is the format of the FloorRequestQuery
message:[¶](#section-5.3.3-1){.pilcrow}

[]{#name-floorrequestquery-format}

::: {#fig_floorrequestinfo}
::: {#section-5.3.3-2.1}
``` {.sourcecode .lang-abnf}
FloorRequestQuery =  COMMON-HEADER
                     FLOOR-REQUEST-ID
                    *EXTENSION-ATTRIBUTE
```
:::

[Figure 33](#figure-33){.selfRef}: [FloorRequestQuery
format](#name-floorrequestquery-format){.selfRef}
:::
:::
:::

::: {#sec_msg_format_FloorRequestStatus}
::: {#section-5.3.4 .section}
#### [5.3.4.](#section-5.3.4){.section-number .selfRef} [FloorRequestStatus](#name-floorrequeststatus){.section-name .selfRef} {#name-floorrequeststatus}

The floor control server informs floor participants and floor chairs
about the status of their floor requests by sending them
FloorRequestStatus messages. The following is the format of the
FloorRequestStatus message:[¶](#section-5.3.4-1){.pilcrow}

[]{#name-floorrequeststatus-format}

::: {#fig_floorrequeststatus}
::: {#section-5.3.4-2.1}
``` {.sourcecode .lang-abnf}
FloorRequestStatus =  COMMON-HEADER
                      FLOOR-REQUEST-INFORMATION
                     *EXTENSION-ATTRIBUTE
```
:::

[Figure 34](#figure-34){.selfRef}: [FloorRequestStatus
format](#name-floorrequeststatus-format){.selfRef}
:::
:::
:::

::: {#sec_msg_format_UserQuery}
::: {#section-5.3.5 .section}
#### [5.3.5.](#section-5.3.5){.section-number .selfRef} [UserQuery](#name-userquery){.section-name .selfRef} {#name-userquery}

Floor participants and floor chairs request information about a
participant and the floor requests related to this participant by
sending a UserQuery message to the floor control server. The following
is the format of the UserQuery message:[¶](#section-5.3.5-1){.pilcrow}

[]{#name-userquery-format}

::: {#fig_userinfowanted}
::: {#section-5.3.5-2.1}
``` {.sourcecode .lang-abnf}
UserQuery =  COMMON-HEADER
             [BENEFICIARY-ID]
            *EXTENSION-ATTRIBUTE
```
:::

[Figure 35](#figure-35){.selfRef}: [UserQuery
format](#name-userquery-format){.selfRef}
:::
:::
:::

::: {#sec_msg_format_UserStatus}
::: {#section-5.3.6 .section}
#### [5.3.6.](#section-5.3.6){.section-number .selfRef} [UserStatus](#name-userstatus){.section-name .selfRef} {#name-userstatus}

The floor control server provides information about participants and
their related floor requests to floor participants and floor chairs by
sending them UserStatus messages. The following is the format of the
UserStatus message:[¶](#section-5.3.6-1){.pilcrow}

[]{#name-userstatus-format}

::: {#fig_userstatus}
::: {#section-5.3.6-2.1}
``` {.sourcecode .lang-abnf}
UserStatus =  COMMON-HEADER
              [BENEFICIARY-INFORMATION]
             *FLOOR-REQUEST-INFORMATION
             *EXTENSION-ATTRIBUTE
```
:::

[Figure 36](#figure-36){.selfRef}: [UserStatus
format](#name-userstatus-format){.selfRef}
:::
:::
:::

::: {#sec_msg_format_FloorQuery}
::: {#section-5.3.7 .section}
#### [5.3.7.](#section-5.3.7){.section-number .selfRef} [FloorQuery](#name-floorquery){.section-name .selfRef} {#name-floorquery}

Floor participants and floor chairs request information about a floor or
floors by sending a FloorQuery message to the floor control server. The
following is the format of the FloorQuery
message:[¶](#section-5.3.7-1){.pilcrow}

[]{#name-floorquery-format}

::: {#fig_floorinfo}
::: {#section-5.3.7-2.1}
``` {.sourcecode .lang-abnf}
FloorQuery =  COMMON-HEADER
             *FLOOR-ID
             *EXTENSION-ATTRIBUTE
```
:::

[Figure 37](#figure-37){.selfRef}: [FloorQuery
format](#name-floorquery-format){.selfRef}
:::
:::
:::

::: {#sec_msg_format_FloorStatus}
::: {#section-5.3.8 .section}
#### [5.3.8.](#section-5.3.8){.section-number .selfRef} [FloorStatus](#name-floorstatus){.section-name .selfRef} {#name-floorstatus}

The floor control server informs floor participants and floor chairs
about the status (e.g., the current holder) of a floor by sending them
FloorStatus messages. The following is the format of the FloorStatus
message:[¶](#section-5.3.8-1){.pilcrow}

[]{#name-floorstatus-format}

::: {#fig_floorstatus}
::: {#section-5.3.8-2.1}
``` {.sourcecode .lang-abnf}
FloorStatus =  COMMON-HEADER
              *FLOOR-ID
              *FLOOR-REQUEST-INFORMATION
              *EXTENSION-ATTRIBUTE
```
:::

[Figure 38](#figure-38){.selfRef}: [FloorStatus
format](#name-floorstatus-format){.selfRef}
:::
:::
:::

::: {#sec_msg_format_ChairAction}
::: {#section-5.3.9 .section}
#### [5.3.9.](#section-5.3.9){.section-number .selfRef} [ChairAction](#name-chairaction){.section-name .selfRef} {#name-chairaction}

Floor chairs send instructions to floor control servers by sending them
ChairAction messages. The following is the format of the ChairAction
message:[¶](#section-5.3.9-1){.pilcrow}

[]{#name-chairaction-format}

::: {#fig_chairaction}
::: {#section-5.3.9-2.1}
``` {.sourcecode .lang-abnf}
ChairAction =  COMMON-HEADER
               FLOOR-REQUEST-INFORMATION
              *EXTENSION-ATTRIBUTE
```
:::

[Figure 39](#figure-39){.selfRef}: [ChairAction
format](#name-chairaction-format){.selfRef}
:::
:::
:::

::: {#sec_msg_format_ChairActionAck}
::: {#section-5.3.10 .section}
#### [5.3.10.](#section-5.3.10){.section-number .selfRef} [ChairActionAck](#name-chairactionack){.section-name .selfRef} {#name-chairactionack}

Floor control servers confirm that they have accepted a ChairAction
message by sending a ChairActionAck message. The following is the format
of the ChairActionAck message:[¶](#section-5.3.10-1){.pilcrow}

[]{#name-chairactionack-format}

::: {#fig_chairactionack}
::: {#section-5.3.10-2.1}
``` {.sourcecode .lang-abnf}
ChairActionAck =  COMMON-HEADER
                 *EXTENSION-ATTRIBUTE
```
:::

[Figure 40](#figure-40){.selfRef}: [ChairActionAck
format](#name-chairactionack-format){.selfRef}
:::
:::
:::

::: {#sec_msg_format_Hello}
::: {#section-5.3.11 .section}
#### [5.3.11.](#section-5.3.11){.section-number .selfRef} [Hello](#name-hello){.section-name .selfRef} {#name-hello}

Floor participants and floor chairs [MAY]{.bcp14} check the liveness of
floor control servers by sending a Hello message. Additionally, clients
communicating with a floor control server over an unreliable transport
use the Hello message to initiate communication with the server. The
following is the format of the Hello
message:[¶](#section-5.3.11-1){.pilcrow}

[]{#name-hello-format}

::: {#fig_hello}
::: {#section-5.3.11-2.1}
``` {.sourcecode .lang-abnf}
Hello =  COMMON-HEADER
        *EXTENSION-ATTRIBUTE
```
:::

[Figure 41](#figure-41){.selfRef}: [Hello
format](#name-hello-format){.selfRef}
:::
:::
:::

::: {#sec_msg_format_HelloAck}
::: {#section-5.3.12 .section}
#### [5.3.12.](#section-5.3.12){.section-number .selfRef} [HelloAck](#name-helloack){.section-name .selfRef} {#name-helloack}

Floor control servers confirm that they are alive on reception of a
Hello message by sending a HelloAck message. The following is the format
of the HelloAck message:[¶](#section-5.3.12-1){.pilcrow}

[]{#name-helloack-format}

::: {#fig_helloack}
::: {#section-5.3.12-2.1}
``` {.sourcecode .lang-abnf}
HelloAck =  COMMON-HEADER
            SUPPORTED-PRIMITIVES
            SUPPORTED-ATTRIBUTES
           *EXTENSION-ATTRIBUTE
```
:::

[Figure 42](#figure-42){.selfRef}: [HelloAck
format](#name-helloack-format){.selfRef}
:::
:::
:::

::: {#sec_msg_format_Error}
::: {#section-5.3.13 .section}
#### [5.3.13.](#section-5.3.13){.section-number .selfRef} [Error](#name-error){.section-name .selfRef} {#name-error}

Floor control servers inform floor participants and floor chairs about
errors processing requests by sending them Error messages. The following
is the format of the Error message:[¶](#section-5.3.13-1){.pilcrow}

[]{#name-error-format}

::: {#fig_error}
::: {#section-5.3.13-2.1}
``` {.sourcecode .lang-abnf}
Error =  COMMON-HEADER
         ERROR-CODE
         [ERROR-INFO]
        *EXTENSION-ATTRIBUTE
```
:::

[Figure 43](#figure-43){.selfRef}: [Error
format](#name-error-format){.selfRef}
:::
:::
:::

::: {#section-5.3.14 .section}
#### [5.3.14.](#section-5.3.14){.section-number .selfRef} [FloorRequestStatusAck](#name-floorrequeststatusack){.section-name .selfRef} {#name-floorrequeststatusack}

When communicating over an unreliable transport, floor participants and
chairs acknowledge the receipt of a subsequent FloorRequestStatus
message from the floor control server (cf. [Section
13.1.2](#sec_server_request_subsequent){.xref}) by sending a
FloorRequestStatusAck message. The following is the format of the
FloorRequestStatusAck message:[¶](#section-5.3.14-1){.pilcrow}

[]{#name-floorrequeststatusack-forma}

::: {#FloorRequestStatusAck}
::: {#section-5.3.14-2.1}
``` {.sourcecode .lang-abnf}
FloorRequestStatusAck =  (COMMON-HEADER)
                        *EXTENSION-ATTRIBUTE
```
:::

[Figure 44](#figure-44){.selfRef}: [FloorRequestStatusAck
format](#name-floorrequeststatusack-forma){.selfRef}
:::
:::

::: {#section-5.3.15 .section}
#### [5.3.15.](#section-5.3.15){.section-number .selfRef} [FloorStatusAck](#name-floorstatusack){.section-name .selfRef} {#name-floorstatusack}

When communicating over an unreliable transport, floor participants and
chairs acknowledge the receipt of a subsequent FloorStatus message from
the floor control server (cf. [Section
13.5.2](#sec_server_floorinfo_subsequent){.xref}) by sending a
FloorStatusAck message. The following is the format of the
FloorStatusAck message:[¶](#section-5.3.15-1){.pilcrow}

[]{#name-floorstatusack-format}

::: {#FloorStatusAck}
::: {#section-5.3.15-2.1}
``` {.sourcecode .lang-abnf}
FloorStatusAck =  (COMMON-HEADER)
                 *EXTENSION-ATTRIBUTE
```
:::

[Figure 45](#figure-45){.selfRef}: [FloorStatusAck
format](#name-floorstatusack-format){.selfRef}
:::
:::

::: {#section-5.3.16 .section}
#### [5.3.16.](#section-5.3.16){.section-number .selfRef} [Goodbye](#name-goodbye){.section-name .selfRef} {#name-goodbye}

BFCP entities communicating over an unreliable transport that wish to
dissociate themselves from their remote participant do so through the
transmission of a Goodbye. The following is the format of the Goodbye
message:[¶](#section-5.3.16-1){.pilcrow}

[]{#name-goodbye-format}

::: {#Goodbye}
::: {#section-5.3.16-2.1}
``` {.sourcecode .lang-abnf}
Goodbye =  (COMMON-HEADER)
          *EXTENSION-ATTRIBUTE
```
:::

[Figure 46](#figure-46){.selfRef}: [Goodbye
format](#name-goodbye-format){.selfRef}
:::
:::

::: {#section-5.3.17 .section}
#### [5.3.17.](#section-5.3.17){.section-number .selfRef} [GoodbyeAck](#name-goodbyeack){.section-name .selfRef} {#name-goodbyeack}

BFCP entities communicating over an unreliable transport acknowledge the
receipt of a Goodbye message from a peer. The following is the format of
the GoodbyeAck message:[¶](#section-5.3.17-1){.pilcrow}

[]{#name-goodbyeack-format}

::: {#GoodbyeAck}
::: {#section-5.3.17-2.1}
``` {.sourcecode .lang-abnf}
GoodbyeAck =  (COMMON-HEADER)
             *EXTENSION-ATTRIBUTE
```
:::

[Figure 47](#figure-47){.selfRef}: [GoodbyeAck
format](#name-goodbyeack-format){.selfRef}
:::
:::
:::
:::
:::
:::

::: {#sec_transport}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Transport](#name-transport){.section-name .selfRef} {#name-transport}

The transport over which BFCP entities exchange messages depends on the
information the clients obtain for contacting the floor control server,
as described in [Section 3.2](#sec_scope_info){.xref}. Two transports
are supported: TCP, which is appropriate where connectivity is not
impeded by network elements such as NAT devices or media relays; and UDP
for those deployments where TCP may not be applicable or
appropriate.[¶](#section-6-1){.pilcrow}

Note: In practice, products are configured to try one transport first
and then use the other transport as a fallback. Whether TCP or UDP is
chosen as underlying transport depends on the type of product and the
deployment environment. See [Appendix B](#app_motivation){.xref} for
additional considerations.[¶](#section-6-2.1){.pilcrow}

::: {#tcp_transport}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Reliable Transport](#name-reliable-transport){.section-name .selfRef} {#name-reliable-transport}

BFCP entities may elect to exchange BFCP messages using TCP connections.
TCP provides an in-order reliable delivery of a stream of bytes.
Consequently, message framing needs to be implemented in the application
layer. BFCP implements application-layer framing using TLV-encoded
attributes.[¶](#section-6.1-1){.pilcrow}

A client [MUST NOT]{.bcp14} use more than one TCP connection to
communicate with a given floor control server within a conference.
Nevertheless, if the same physical box handles different clients (e.g.,
a floor chair and a floor participant), which are identified by
different User IDs, a separate connection per client is
allowed.[¶](#section-6.1-2){.pilcrow}

If a BFCP entity (a client or a floor control server) receives data that
cannot be parsed, the entity [MUST]{.bcp14} close the TCP connection,
and the connection [SHOULD]{.bcp14} be reestablished. Similarly, if a
TCP connection cannot deliver a BFCP message and times out or receives
an ICMP port unreachable message mid-connection, the TCP connection
[SHOULD]{.bcp14} be reestablished.[¶](#section-6.1-3){.pilcrow}

The way connection reestablishment is handled depends on how the client
obtains information to contact the floor control server. Once the TCP
connection is reestablished, the client [MAY]{.bcp14} resend those
messages for which it did not get a response from the floor control
server.[¶](#section-6.1-4){.pilcrow}

If a floor control server detects that the TCP connection towards one of
the floor participants is lost, it is up to the local policy of the
floor control server what to do with the pending floor requests of the
floor participant. In any case, it is [RECOMMENDED]{.bcp14} that the
floor control server keep the floor requests (i.e., that it does not
cancel them) while the TCP connection is
reestablished.[¶](#section-6.1-5){.pilcrow}

If a client wishes to end its BFCP connection with a floor control
server, the client closes (i.e., a graceful close) the TCP connection
towards the floor control server. If a floor control server wishes to
end its BFCP connection with a client (e.g., the focus of the conference
informs the floor control server that the client has been kicked out of
the conference), the floor control server closes (i.e., a graceful
close) the TCP connection towards the
client.[¶](#section-6.1-6){.pilcrow}

In cases where a BFCP entity reestablishes a connection due to protocol
errors as described above, the entity [SHOULD NOT]{.bcp14} repeatedly
reestablish the connection. Rather, if the same protocol errors persist,
the entity [MUST]{.bcp14} cease attempts and [SHOULD]{.bcp14} report the
error to the human user and/or log the event. This does not preclude the
entity from reestablishing a connection when facing a different set of
errors. That said, entities [MUST]{.bcp14} avoid overloading the server
with reestablishment requests. A connection [MUST NOT]{.bcp14} be
reestablished too frequently. The frequency is a matter of
implementation, but [SHOULD NOT]{.bcp14} be attempted more than once in
a 30 second period of time.[¶](#section-6.1-7){.pilcrow}
:::
:::

::: {#udp_transport}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Unreliable Transport](#name-unreliable-transport){.section-name .selfRef} {#name-unreliable-transport}

BFCP entities may elect to exchange BFCP messages using UDP datagrams.
UDP is an unreliable transport where neither delivery nor ordering is
assured. Each BFCP UDP datagram [MUST]{.bcp14} contain exactly one BFCP
message or message fragment. To keep large BFCP messages from being
fragmented at the IP layer, the fragmentation of BFCP messages that
exceed the path MTU size is performed at the BFCP level. Considerations
related to fragmentation are covered in [Section
6.2.3](#fragmentation_handling){.xref}. The message format for BFCP
messages is the same regardless of whether the messages are sent in UDP
datagrams or over a TCP stream.[¶](#section-6.2-1){.pilcrow}

Clients [MUST]{.bcp14} announce their presence to the floor control
server by sending a Hello message. The floor control server responds to
the Hello message with a HelloAck message. The client considers the
floor control server as present and available only upon receiving the
HelloAck message. The behavior when timers fire, including the
determination that a connection is broken, is described in [Section
8.3](#timers){.xref}.[¶](#section-6.2-2){.pilcrow}

As described in [Section 8](#sec_transactions){.xref}, each request sent
by a floor participant or chair forms a client transaction that expects
an acknowledgement message from the floor control server within a
transaction failure window. Concordantly, messages sent by the floor
control server that initiate new transactions (e.g., FloorStatus
announcements as part of a FloorQuery subscription) require
acknowledgement messages from the floor participant and chair entities
to which they were sent.[¶](#section-6.2-3){.pilcrow}

If a floor control server receives data that cannot be parsed, the
receiving server [MUST]{.bcp14} send an Error message with parameter
value 10 (Unable to Parse Message) indicating receipt of a malformed
message, given that it is possible to parse the received message to such
an extent that an Error message may be
built.[¶](#section-6.2-4){.pilcrow}

Entities [MUST]{.bcp14} have at most one outstanding request transaction
per peer at any one time. Implicit subscriptions occur for a
client-initiated request transaction whose acknowledgement is implied by
the first server-initiated response for that transaction, followed by
zero of more subsequent server-initiated messages corresponding to the
same transaction. An example is a FloorRequest message for which there
are potentially multiple responses from the floor control server as it
processes intermediate states until a terminal state (e.g., Granted or
Denied) is attained. The subsequent changes in state for the request are
new transactions whose Transaction ID is determined by the floor control
server and whose receipt by the client participant is acknowledged with
a FloorRequestStatusAck message.[¶](#section-6.2-5){.pilcrow}

By restricting entities to having at most one pending transaction open
in a BFCP connection, both the out-of-order receipt of messages as well
as the possibility for congestion are mitigated. Additional details
regarding congestion control are provided in [Section
6.2.1](#congestion){.xref}. If a participant receives a server-initiated
request (e.g., a FloorStatus from the floor control server) while
waiting for a response to a client-initiated transaction (e.g., the
participant sent a FloorRequest and is waiting for a FloorRequestStatus
response), then the participant [MUST]{.bcp14} treat the
server-initiated request as superseding any response to its
client-initiated transaction. As the floor control server cannot send a
second update to the implicit floor status subscription until the first
is acknowledged, ordinality is maintained.[¶](#section-6.2-6){.pilcrow}

If a client wishes to end its BFCP connection with a floor control
server, it is [REQUIRED]{.bcp14} that the client send a Goodbye message
to dissociate itself from any allocated resources. If a floor control
server wishes to end its BFCP connection with a client (e.g., the focus
of the conference informs the floor control server that the client has
been kicked out from the conference), it is [REQUIRED]{.bcp14} that the
floor control server send a Goodbye message towards the
client.[¶](#section-6.2-7){.pilcrow}

::: {#congestion}
::: {#section-6.2.1 .section}
#### [6.2.1.](#section-6.2.1){.section-number .selfRef} [Congestion Control](#name-congestion-control){.section-name .selfRef} {#name-congestion-control}

BFCP may be characterized as generating \"low data-volume\" traffic, per
the classification in \[[15](#RFC8085){.xref}\]. Nevertheless, it is
necessary to ensure that suitable and necessary congestion control
mechanisms are used for BFCP over UDP. As described in [Section
6.2](#udp_transport){.xref}, within the same BFCP connection, every
entity \-- client or server \-- is only allowed to send one request at a
time, and await the acknowledging response. This way, at most one
datagram is sent per RTT given the message is not lost during
transmission. If the message is lost, the request retransmission timer
T1 specified in [Section 8.3.1](#timers_retrans){.xref} will fire, and
the message is retransmitted up to three times, in addition to the
original transmission of the message. The default initial interval
[MUST]{.bcp14} be set to 500 ms, but is adjusted dynamically as
described in [Section 8.3.1](#timers_retrans){.xref}. The interval
[MUST]{.bcp14} be doubled after each retransmission attempt. This is
similar to the specification of the timer A and its initial value T1 in
SIP as described in [Section
17.1.1.2](https://www.rfc-editor.org/rfc/rfc3261#section-17.1.1.2){.relref}
of \[[20](#RFC3261){.xref}\], except that the value of T1 in this
protocol is not fixed from one transaction to
another.[¶](#section-6.2.1-1){.pilcrow}
:::
:::

::: {#icmp}
::: {#section-6.2.2 .section}
#### [6.2.2.](#section-6.2.2){.section-number .selfRef} [ICMP Error Handling](#name-icmp-error-handling){.section-name .selfRef} {#name-icmp-error-handling}

ICMP is not usable when BFCP is running over an unreliable transport due
to risks associated with off-path attacks. Any ICMP messages associated
with BFCP running over an unreliable transport [MUST]{.bcp14} be
ignored.[¶](#section-6.2.2-1){.pilcrow}
:::
:::

::: {#fragmentation_handling}
::: {#section-6.2.3 .section}
#### [6.2.3.](#section-6.2.3){.section-number .selfRef} [Fragmentation Handling](#name-fragmentation-handling){.section-name .selfRef} {#name-fragmentation-handling}

When using UDP, a single BFCP message could be fragmented at the IP
layer if its overall size exceeds the path MTU of the network. To avoid
this happening at the IP layer, a fragmentation scheme for BFCP is
defined below.[¶](#section-6.2.3-1){.pilcrow}

BFCP is designed for achieving small message size, due to the binary
encoding as described in [Section 1](#sec_intro){.xref}. The
fragmentation scheme is therefore deliberately kept simple and
straightforward, since the probability of fragmentation of BFCP messages
is small. By design, the fragmentation scheme does not acknowledge
individual BFCP message fragments. The whole BFCP message is
acknowledged if received completely.[¶](#section-6.2.3-2){.pilcrow}

BFCP entities [SHOULD]{.bcp14} consider the path MTU size available
between the sender and the receiver and [MAY]{.bcp14} run MTU discovery,
such as described in \[[25](#RFC1191){.xref}\],
\[[26](#RFC8201){.xref}\], and \[[27](#RFC4821){.xref}\], for this
purpose.[¶](#section-6.2.3-3){.pilcrow}

When transmitting a BFCP message with a size greater than the path MTU,
the sender [MUST]{.bcp14} fragment the message into a series of N
contiguous data ranges. The size of each of these N messages
[MUST]{.bcp14} be smaller than the path MTU to help prevent
fragmentation overlap attacks. The value for N is defined as
ceil((message size \-- COMMON-HEADER size) / (path MTU size \--
COMMON-HEADER size)), where ceil is the integer ceiling function, and
the COMMON-HEADER size includes the Fragment Offset and Fragment Length
fields. The sender then creates N BFCP fragment messages (one for each
data range) with the same Transaction ID. The size of each of these N
messages, with the COMMON-HEADER included, [MUST]{.bcp14} be smaller
than the path MTU. The F flag in the COMMON-HEADER in all the fragments
is set to indicate fragmentation of the BFCP
message.[¶](#section-6.2.3-4){.pilcrow}

For each of these fragments, the Fragment Offset and Fragment Length
fields are included in the COMMON-HEADER. The Fragment Offset field
denotes the number of 4-octet units contained in the previous fragments,
excluding the COMMON-HEADER. The Fragment Length contains the length of
the fragment itself, also excluding the COMMON-HEADER. Note that the
Payload Length field contains the length of the entire, unfragmented
message.[¶](#section-6.2.3-5){.pilcrow}

When a BFCP implementation receives a BFCP message fragment, it
[MUST]{.bcp14} buffer the fragment until either it has received the
entire BFCP message, or until the Response Retransmission Timer expires.
The state machine should handle the BFCP message only after all the
fragments of the message have been
received.[¶](#section-6.2.3-6){.pilcrow}

If a fragment of a BFCP message is lost, the sender will not receive an
acknowledgement for the message. Therefore the sender will retransmit
the message with same transaction ID as specified in [Section
8.3](#timers){.xref}. If the acknowledgement message sent by the
receiver is lost, then the entire message will be resent by the sender.
The receiver [MUST]{.bcp14} then retransmit the acknowledgement. The
receiver [MAY]{.bcp14} discard an incomplete buffer utilizing the
Response Retransmission Timer, starting the timer after the receipt of
the first fragment.[¶](#section-6.2.3-7){.pilcrow}

A Denial of Service (DoS) attack utilizing the fragmentation scheme
described above is mitigated by the fact that the Response
Retransmission Timer is started after receipt of the first BFCP message
fragment. In addition, the Payload Length field can be compared with the
Fragment Offset and Fragment Length fields to verify the message
fragments as they arrive. To make DoS attacks with spoofed IP addresses
difficult, BFCP entities [SHOULD]{.bcp14} use the cookie exchange
mechanism in DTLS
\[[8](#RFC6347){.xref}\].[¶](#section-6.2.3-8.1){.pilcrow}

When deciding the size of the message fragment based on path MTU, the
BFCP fragmentation handling should take into account how the DTLS record
framing expands the datagram size as described in [Section
4.1.1.1](https://www.rfc-editor.org/rfc/rfc6347#section-4.1.1.1){.relref}
of \[[8](#RFC6347){.xref}\].[¶](#section-6.2.3-9){.pilcrow}
:::
:::

::: {#nat_traversal}
::: {#section-6.2.4 .section}
#### [6.2.4.](#section-6.2.4){.section-number .selfRef} [NAT Traversal](#name-nat-traversal){.section-name .selfRef} {#name-nat-traversal}

One of the key benefits of using UDP for BFCP communication is the
ability to leverage the existing NAT traversal infrastructure and
strategies deployed to facilitate transport of the media associated with
the video conferencing sessions. Depending on the given deployment, this
infrastructure typically includes some subset of Interactive
Connectivity Establishment (ICE)
\[[16](#RFC8445){.xref}\].[¶](#section-6.2.4-1){.pilcrow}

In order to facilitate the initial establishment of NAT bindings, and to
maintain those bindings once established, BFCP entities using an
unreliable transport are [RECOMMENDED]{.bcp14} to use STUN
\[[14](#RFC5389){.xref}\] Binding Indication for keepalives, as
described for ICE \[[16](#RFC8445){.xref}\]. [Section
6.7](https://www.rfc-editor.org/rfc/rfc5763#section-6.7){.relref} of
\[[28](#RFC5763){.xref}\] provides useful recommendations for middlebox
interaction when DTLS is used.[¶](#section-6.2.4-2){.pilcrow}

Note: Since the version number is set to 2 when BFCP is used over an
unreliable transport, cf. the Ver field in [Section
5.1](#sec_format_common){.xref}, it is straightforward to distinguish
between STUN and BFCP packets even without checking the STUN magic
cookie \[[14](#RFC5389){.xref}\].[¶](#section-6.2.4-3.1){.pilcrow}

In order to facilitate traversal of BFCP packets through NATs, BFCP
entities using an unreliable transport are [RECOMMENDED]{.bcp14} to use
symmetric ports for sending and receiving BFCP packets, as recommended
for RTP/RTP Control Protocol (RTCP)
\[[13](#RFC4961){.xref}\].[¶](#section-6.2.4-4){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#sec_lower-security}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Lower-Layer Security](#name-lower-layer-security){.section-name .selfRef} {#name-lower-layer-security}

BFCP relies on lower-layer security mechanisms to provide replay and
integrity protection and confidentiality. BFCP floor control servers and
clients (which include both floor participants and floor chairs)
[MUST]{.bcp14} support TLS for transport over TCP
\[[11](#RFC8446){.xref}\] and [MUST]{.bcp14} support DTLS
\[[8](#RFC6347){.xref}\] for transport over UDP. Any BFCP entity
[MAY]{.bcp14} support other security
mechanisms.[¶](#section-7-1){.pilcrow}

BFCP entities [MUST]{.bcp14} support, at a minimum, the
TLS_RSA_WITH_AES_128_CBC_SHA cipher suite \[[7](#RFC5246){.xref}\] for
backwards compatibility with existing implementations of RFC 4582. In
accordance with the recommendations and guidelines in
\[[30](#RFC7525){.xref}\], BFCP entities [SHOULD]{.bcp14} support the
following cipher suites:[¶](#section-7-2){.pilcrow}

-   [TLS_DHE_RSA_WITH_AES_128_GCM_SHA256[¶](#section-7-3.1){.pilcrow}]{#section-7-3.1}
-   [TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256[¶](#section-7-3.2){.pilcrow}]{#section-7-3.2}
-   [TLS_DHE_RSA_WITH_AES_256_GCM_SHA384[¶](#section-7-3.3){.pilcrow}]{#section-7-3.3}
-   [TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384[¶](#section-7-3.4){.pilcrow}]{#section-7-3.4}
:::
:::

::: {#sec_transactions}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Protocol Transactions](#name-protocol-transactions){.section-name .selfRef} {#name-protocol-transactions}

In BFCP, there are two types of transactions: client-initiated
transactions and server-initiated
transactions.[¶](#section-8-1){.pilcrow}

Client-initiated transactions consist of a request from a client to a
floor control server and a response from the floor control server to the
client.[¶](#section-8-2){.pilcrow}

Server-initiated transactions have different requirements and behavior
depending on underlying transport:[¶](#section-8-3){.pilcrow}

-   [When using a reliable transport, server-initiated transactions
    consist of a single message from a floor control server to a client
    (notifications). They do not trigger any
    response.[¶](#section-8-4.1){.pilcrow}]{#section-8-4.1}
-   [When using an unreliable transport, server-initiated transactions
    consist of a request from a floor control server to a client and a
    response from the client to the floor control
    server.[¶](#section-8-4.2){.pilcrow}]{#section-8-4.2}

When using BFCP over an unreliable transport, retransmission timer T1
(see [Section 8.3](#timers){.xref}) [MUST]{.bcp14} be used for all
requests until the transaction is completed. Note that while T1 varies
over time, it remains constant for the duration of a given transaction
and is only updated at the completion of a
transaction.[¶](#section-8-5){.pilcrow}

::: {#sec_transactions_client}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Client Behavior](#name-client-behavior){.section-name .selfRef} {#name-client-behavior}

A client starting a client-initiated transaction [MUST]{.bcp14} set the
Conference ID in the COMMON-HEADER of the message to the Conference ID
for the conference that the client obtained
previously.[¶](#section-8.1-1){.pilcrow}

The client [MUST]{.bcp14} set the Transaction ID value in the
COMMON-HEADER to a number that is different from 0 and that [MUST
NOT]{.bcp14} be reused in another message from the client until a
response from the server is received for the transaction. The client
uses the Transaction ID value to match this message with the response
from the floor control server. When using BFCP over an unreliable
transport, it is important to choose a Transaction ID value that lets
the receiver distinguish the reception of the next message in a sequence
of BFCP messages from a retransmission of a previous message. Therefore,
BFCP entities using an unreliable transport [MUST]{.bcp14} use
monotonically increasing Transaction ID values (except for
wrap-around).[¶](#section-8.1-2){.pilcrow}

A client receiving a server-initiated transaction over an unreliable
transport [MUST]{.bcp14} copy the Transaction ID from the request
received from the server into the response.[¶](#section-8.1-3){.pilcrow}
:::
:::

::: {#sec_transactions_server}
::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Server Behavior](#name-server-behavior){.section-name .selfRef} {#name-server-behavior}

A floor control server sending a response within a client-initiated
transaction [MUST]{.bcp14} copy the Conference ID, the Transaction ID,
and the User ID from the request received from the client into the
response.[¶](#section-8.2-1){.pilcrow}

Server-initiated transactions [MUST]{.bcp14} contain a Transaction ID
equal to zero when BFCP is used over a reliable transport. Over an
unreliable transport, the Transaction ID shall have the same properties
as for client-initiated transactions. The server uses the Transaction ID
value to match this message with the response from the floor participant
or floor chair.[¶](#section-8.2-2){.pilcrow}
:::
:::

::: {#timers}
::: {#section-8.3 .section}
### [8.3.](#section-8.3){.section-number .selfRef} [Timers](#name-timers){.section-name .selfRef} {#name-timers}

When BFCP entities are communicating over an unreliable transport, two
retransmission timers are employed to help mitigate the loss of
datagrams. Retransmission and response caching are not required when
BFCP entities communicate over a reliable
transport.[¶](#section-8.3-1){.pilcrow}

::: {#timers_retrans}
::: {#section-8.3.1 .section}
#### [8.3.1.](#section-8.3.1){.section-number .selfRef} [Request Retransmission Timer, T1](#name-request-retransmission-time){.section-name .selfRef} {#name-request-retransmission-time}

T1 is a timer that schedules retransmission of a request until an
appropriate response is received or until the maximum number of
retransmissions has occurred. The timer is computed using the smoothed
round-trip time algorithm defined in \[[2](#RFC6298){.xref}\] with an
initial retransmission timeout (RTO) value of 500 ms and clock
granularity (G) of 100 ms. In contrast to step 2.4 of [Section
2](https://www.rfc-editor.org/rfc/rfc6298#section-2){.relref} of
\[[2](#RFC6298){.xref}\], if the computed value of RTO is less than 500
ms, then RTO shall be set to 500 ms. Timer T1 [MUST]{.bcp14} be adjusted
with the reception of a response to each request transmitted in order to
compute an accurate RTO value, which is the effective T1 value. The RTT
value R is the time in milliseconds from the time when a request is
transmitted to the time the initial response to that request is
received. Responses to retransmitted packets [MUST NOT]{.bcp14} be used
to recompute the RTO value, as one cannot determine if a response is to
an initial or retransmitted request. If T1 always expires on the initial
transmission of a new request, this would suggest the recommended
initial T1 (and RTO) value is too low and [SHOULD]{.bcp14} be increased
by doubling the initial values of T1 (and RTO) until T1 does not expire
when sending a new request.[¶](#section-8.3.1-1){.pilcrow}

When retransmitting a request, timer T1 is doubled with each
retransmission, failing after three unacknowledged retransmission
attempts.[¶](#section-8.3.1-2){.pilcrow}

If a valid response is not received for a client- or server-initiated
transaction, the implementation [MUST]{.bcp14} consider the BFCP
connection as broken. Implementations [SHOULD]{.bcp14} follow the
reestablishment procedure described in [Section
6](#sec_transport){.xref}.[¶](#section-8.3.1-3){.pilcrow}
:::
:::

::: {#timers_cache}
::: {#section-8.3.2 .section}
#### [8.3.2.](#section-8.3.2){.section-number .selfRef} [Response Retransmission Timer, T2](#name-response-retransmission-tim){.section-name .selfRef} {#name-response-retransmission-tim}

T2 is a timer that, when fired, signals that the BFCP entity can release
knowledge of the transaction against which it is running. It is started
upon the first transmission of the response to a request and is the only
mechanism by which that response is released by the BFCP entity. Any
subsequent retransmissions of the same request can be responded to by
replaying the cached response, while that value is retained until the
timer has fired. Refer to [Section
6.2.3](#fragmentation_handling){.xref} for this timer\'s role in the
fragmentation handling scheme.[¶](#section-8.3.2-1){.pilcrow}
:::
:::

::: {#timers_values}
::: {#section-8.3.3 .section}
#### [8.3.3.](#section-8.3.3){.section-number .selfRef} [Timer Values](#name-timer-values){.section-name .selfRef} {#name-timer-values}

The table below defines the different timers required when BFCP entities
communicate over an unreliable transport.[¶](#section-8.3.3-1){.pilcrow}

[]{#name-timers-2}

::: {#timertable}
  Timer   Description                            Value/s
  ------- -------------------------------------- ------------------
  T1      Initial request retransmission timer   0.5 s (initial)
  T2      Response retransmission timer          (T1\*2^4^)\*1.25

  : [Table 6](#table-6){.selfRef}: [Timers](#name-timers-2){.selfRef}
:::

The initial value for T1 is 500 ms, which is an estimate of the RTT for
completing the transaction. Computation of this value follows the
procedures described in [Section 8.3.1](#timers_retrans){.xref}, which
includes exponential backoffs on
retransmissions.[¶](#section-8.3.3-3){.pilcrow}

T2 [MUST]{.bcp14} be set such that it encompasses all legal
retransmissions per T1 plus a factor to accommodate network latency
between BFCP entities, processing delays,
etc.[¶](#section-8.3.3-4){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#sec_auth}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Authentication and Authorization](#name-authentication-and-authoriz){.section-name .selfRef} {#name-authentication-and-authoriz}

BFCP clients [SHOULD]{.bcp14} authenticate the floor control server
before sending any BFCP message to it or accepting any BFCP message from
it. Similarly, floor control servers [SHOULD]{.bcp14} authenticate a
client before accepting any BFCP message from it or sending any BFCP
message to it.[¶](#section-9-1){.pilcrow}

If the signaling or control protocol traffic used to set up the
conference is authenticated and confidentiality and integrity protected,
and the extensions in this document are supported, the BFCP clients
[MUST]{.bcp14} authenticate the floor control server, and the floor
control servers [MUST]{.bcp14} authenticate the client before
communicating as described above. Note that BFCP entities supporting
only the \[[3](#RFC4582){.xref}\] subset may not comply with this
mandatory authentication requirement.[¶](#section-9-2){.pilcrow}

BFCP supports TLS/DTLS mutual authentication between clients and floor
control servers, as specified in [Section 9.1](#sec_auth_tls){.xref}.
This is the [RECOMMENDED]{.bcp14} authentication mechanism in
BFCP.[¶](#section-9-3){.pilcrow}

Note that future extensions may define additional authentication
mechanisms.[¶](#section-9-4){.pilcrow}

In addition to authenticating BFCP messages, floor control servers need
to authorize them. On receiving an authenticated BFCP message, the floor
control server checks whether the client sending the message is
authorized. If the client is not authorized to perform the operation
being requested, the floor control server generates an Error message, as
described in [Section 13.8](#sec_server_error){.xref}, with an error
code with a value of 5 (Unauthorized Operation). Messages from a client
that cannot be authorized [MUST NOT]{.bcp14} be processed
further.[¶](#section-9-5){.pilcrow}

::: {#sec_auth_tls}
::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [TLS/DTLS Based Mutual Authentication](#name-tls-dtls-based-mutual-authe){.section-name .selfRef} {#name-tls-dtls-based-mutual-authe}

BFCP supports TLS/DTLS based mutual authentication between clients and
floor control servers. If TLS/DTLS is used, an initial
integrity-protected channel is [REQUIRED]{.bcp14} between the client and
the floor control server that can be used to exchange their certificates
(which [MAY]{.bcp14} be self-signed certificates) or, more commonly, the
fingerprints of these certificates. These certificates are used at
TLS/DTLS establishment time.[¶](#section-9.1-1){.pilcrow}

The implementation of such an integrity-protected channel using SIP and
the SDP offer/answer model is described in
\[[12](#RFC8856){.xref}\].[¶](#section-9.1-2.1){.pilcrow}

BFCP messages received over an authenticated TLS/DTLS connection are
considered authenticated. A floor control server that receives a BFCP
message over TCP/UDP (no TLS/DTLS) [MAY]{.bcp14} request the use of
TLS/DTLS by generating an Error message, as described in [Section
13.8](#sec_server_error){.xref}, with an error code with a value of 9
(Use TLS) or a value of 11 (Use DTLS) respectively. Clients configured
to require the use of TLS/DTLS [MUST]{.bcp14} ignore unauthenticated
messages.[¶](#section-9.1-3){.pilcrow}

Note that future extensions may define additional authentication
mechanisms that may not require an initial integrity-protected channel
(e.g., authentication based on certificates signed by a certificate
authority).[¶](#section-9.1-4){.pilcrow}

As described in [Section 9](#sec_auth){.xref}, floor control servers
need to perform authorization before processing any message. In
particular, the floor control server [MUST]{.bcp14} check that messages
arriving over a given authenticated TLS/DTLS connection use an
authorized User ID (i.e., a User ID that the user that established the
authenticated TLS/DTLS connection is allowed to
use).[¶](#section-9.1-5){.pilcrow}
:::
:::
:::
:::

::: {#sec_participant}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Floor Participant Operations](#name-floor-participant-operation){.section-name .selfRef} {#name-floor-participant-operation}

This section specifies how floor participants can perform different
operations, such as requesting a floor, using the protocol elements
described in earlier sections. [Section 11](#sec_chair){.xref} specifies
operations that are specific to floor chairs, such as instructing the
floor control server to grant or revoke a floor, and [Section
12](#sec_client){.xref} specifies operations that can be performed by
any client (i.e., both floor participants and floor
chairs).[¶](#section-10-1){.pilcrow}

::: {#sec_participant_request}
::: {#section-10.1 .section}
### [10.1.](#section-10.1){.section-number .selfRef} [Requesting a Floor](#name-requesting-a-floor){.section-name .selfRef} {#name-requesting-a-floor}

A floor participant that wishes to request one or more floors does so by
sending a FloorRequest message to the floor control
server.[¶](#section-10.1-1){.pilcrow}

::: {#sec_participant_request_send}
::: {#section-10.1.1 .section}
#### [10.1.1.](#section-10.1.1){.section-number .selfRef} [Sending a FloorRequest Message](#name-sending-a-floorrequest-mess){.section-name .selfRef} {#name-sending-a-floorrequest-mess}

The ABNF in [Section 5.3.1](#sec_msg_format_FloorRequest){.xref}
describes the attributes that a FloorRequest message can contain. In
addition, the ABNF specifies normatively which of these attributes are
mandatory, and which ones are optional.[¶](#section-10.1.1-1){.pilcrow}

The floor participant sets the Conference ID and the Transaction ID in
the COMMON-HEADER following the rules given in [Section
8.1](#sec_transactions_client){.xref}.[¶](#section-10.1.1-2){.pilcrow}

The floor participant sets the User ID in the COMMON-HEADER to the floor
participant\'s identifier. If the sender of the FloorRequest message
(identified by the User ID) is not the participant that would eventually
get the floor (i.e., a third-party floor request), the sender
[SHOULD]{.bcp14} add a BENEFICIARY-ID attribute to the message
identifying the beneficiary of the
floor.[¶](#section-10.1.1-3){.pilcrow}

Note that the namespace for both the User ID and the Beneficiary ID is
the same. That is, a given participant is identified by a single 16-bit
value that can be used in the User ID in the COMMON-HEADER and in
several attributes: BENEFICIARY-ID, BENEFICIARY-INFORMATION, and
REQUESTED-BY-INFORMATION.[¶](#section-10.1.1-4.1){.pilcrow}

The floor participant [MUST]{.bcp14} insert at least one FLOOR-ID
attribute in the FloorRequest message. If the client inserts more than
one FLOOR-ID attribute, the floor control server will treat all the
floor requests as an atomic package. That is, the floor control server
will either grant or deny all the floors in the FloorRequest
message.[¶](#section-10.1.1-5){.pilcrow}

The floor participant may use a PARTICIPANT-PROVIDED-INFO attribute to
state the reason why the floor or floors are being requested. The Text
field in the PARTICIPANT-PROVIDED-INFO attribute is intended for human
consumption.[¶](#section-10.1.1-6){.pilcrow}

The floor participant may request that the server handle the floor
request with a certain priority using a PRIORITY
attribute.[¶](#section-10.1.1-7){.pilcrow}
:::
:::

::: {#sec_client_request_response}
::: {#section-10.1.2 .section}
#### [10.1.2.](#section-10.1.2){.section-number .selfRef} [Receiving a Response](#name-receiving-a-response){.section-name .selfRef} {#name-receiving-a-response}

A message from the floor control server is considered a response to the
FloorRequest message if the message from the floor control server has
the same Conference ID, Transaction ID, and User ID as the FloorRequest
message, as described in [Section 8.1](#sec_transactions_client){.xref}.
On receiving such a response, the floor participant follows the rules in
[Section 9](#sec_auth){.xref} that relate to floor control server
authentication.[¶](#section-10.1.2-1){.pilcrow}

The successful processing of a FloorRequest message at the floor control
server involves generating one or several FloorRequestStatus messages.
The floor participant obtains a Floor Request ID in the Floor Request ID
field of a FLOOR-REQUEST-INFORMATION attribute in the first
FloorRequestStatus message from the floor control server. Subsequent
FloorRequestStatus messages from the floor control server regarding the
same floor request will carry the same Floor Request ID in a
FLOOR-REQUEST-INFORMATION attribute as the initial FloorRequestStatus
message. This way, the floor participant can associate subsequent
incoming FloorRequestStatus messages with the ongoing floor
request.[¶](#section-10.1.2-2){.pilcrow}

The floor participant obtains information about the status of the floor
request in the FLOOR-REQUEST-INFORMATION attribute of each of the
FloorRequestStatus messages received from the floor control server. This
attribute is a grouped attribute, and as such it includes a number of
attributes that provide information about the floor
request.[¶](#section-10.1.2-3){.pilcrow}

The OVERALL-REQUEST-STATUS attribute provides information about the
overall status of the floor request. If the Request Status value is
Granted, all the floors that were requested in the FloorRequest message
have been granted. If the Request Status value is Denied, all the floors
that were requested in the FloorRequest message have been denied. A
floor request is considered to be ongoing while it is in the Pending,
Accepted, or Granted states. If the floor request value is unknown, then
the response is still processed. However, no meaningful value can be
reported to the user.[¶](#section-10.1.2-4){.pilcrow}

The STATUS-INFO attribute, if present, provides extra information that
the floor participant can display to the
user.[¶](#section-10.1.2-5){.pilcrow}

The FLOOR-REQUEST-STATUS attributes provide information about the status
of the floor request as it relates to a particular floor. The
STATUS-INFO attribute, if present, provides extra information that the
floor participant can display to the
user.[¶](#section-10.1.2-6){.pilcrow}

The BENEFICIARY-INFORMATION attribute identifies the beneficiary of the
floor request in third-party floor requests. The
REQUESTED-BY-INFORMATION attribute need not be present in
FloorRequestStatus messages received by the floor participant that
requested the floor, as this floor participant is already identified by
the User ID in the COMMON-HEADER.[¶](#section-10.1.2-7){.pilcrow}

The PRIORITY attribute, when present, contains the priority that was
requested by the generator of the FloorRequest
message.[¶](#section-10.1.2-8){.pilcrow}

If the response is an Error message, the floor control server could not
process the FloorRequest message for some reason, which is described in
the Error message.[¶](#section-10.1.2-9){.pilcrow}
:::
:::

::: {#sec_recept_frsm}
::: {#section-10.1.3 .section}
#### [10.1.3.](#section-10.1.3){.section-number .selfRef} [Reception of a Subsequent FloorRequestStatus Message](#name-reception-of-a-subsequent-f){.section-name .selfRef} {#name-reception-of-a-subsequent-f}

When communicating over an unreliable transport and upon receiving a
FloorRequestStatus message from a floor control server, the participant
[MUST]{.bcp14} respond with a FloorRequestStatusAck message within the
transaction failure window to complete the
transaction.[¶](#section-10.1.3-1){.pilcrow}
:::
:::
:::
:::

::: {#sec_participant_cancel}
::: {#section-10.2 .section}
### [10.2.](#section-10.2){.section-number .selfRef} [Cancelling a Floor Request and Releasing a Floor](#name-cancelling-a-floor-request-){.section-name .selfRef} {#name-cancelling-a-floor-request-}

A floor participant that wishes to cancel an ongoing floor request does
so by sending a FloorRelease message to the floor control server. The
FloorRelease message is also used by floor participants that hold a
floor and would like to release it.[¶](#section-10.2-1){.pilcrow}

::: {#sec_participant_cancel_send}
::: {#section-10.2.1 .section}
#### [10.2.1.](#section-10.2.1){.section-number .selfRef} [Sending a FloorRelease Message](#name-sending-a-floorrelease-mess){.section-name .selfRef} {#name-sending-a-floorrelease-mess}

The ABNF in [Section 5.3.2](#sec_msg_format_FloorRelease){.xref}
describes the attributes that a FloorRelease message can contain. In
addition, the ABNF specifies normatively which of these attributes are
mandatory, and which ones are optional.[¶](#section-10.2.1-1){.pilcrow}

The floor participant sets the Conference ID and the Transaction ID in
the COMMON-HEADER following the rules given in [Section
8.1](#sec_transactions_client){.xref}. The floor participant sets the
User ID in the COMMON-HEADER to the floor participant\'s
identifier.[¶](#section-10.2.1-2){.pilcrow}

Note that the FloorRelease message is used to release a floor or floors
that were granted and to cancel ongoing floor requests (from the
protocol perspective, both are ongoing floor requests). Using the same
message in both situations helps resolve the race condition that occurs
when the FloorRelease message and the FloorGrant message cross each
other on the wire.[¶](#section-10.2.1-3.1){.pilcrow}

The floor participant uses the FLOOR-REQUEST-ID that was received in the
response to the FloorRequest message that the FloorRelease message is
cancelling.[¶](#section-10.2.1-4){.pilcrow}

Note that if the floor participant requested several floors as an atomic
operation (i.e., in a single FloorRequest message), all the floors are
released as an atomic operation as well (i.e., all are released at the
same time).[¶](#section-10.2.1-5.1){.pilcrow}
:::
:::

::: {#sec_participant_cancel_response}
::: {#section-10.2.2 .section}
#### [10.2.2.](#section-10.2.2){.section-number .selfRef} [Receiving a Response](#name-receiving-a-response-2){.section-name .selfRef} {#name-receiving-a-response-2}

A message from the floor control server is considered a response to the
FloorRelease message if the message from the floor control server has
the same Conference ID, Transaction ID, and User ID as the FloorRelease
message, as described in [Section 8.1](#sec_transactions_client){.xref}.
On receiving such a response, the floor participant follows the rules in
[Section 9](#sec_auth){.xref} that relate to floor control server
authentication.[¶](#section-10.2.2-1){.pilcrow}

If the response is a FloorRequestStatus message, the Request Status
value in the OVERALL-REQUEST-STATUS attribute (within the
FLOOR-REQUEST-INFORMATION grouped attribute) will be Cancelled or
Released.[¶](#section-10.2.2-2){.pilcrow}

If the response is an Error message, the floor control server could not
process the FloorRequest message for some reason, which is described in
the Error message.[¶](#section-10.2.2-3){.pilcrow}

It is possible that the FloorRelease message crosses on the wire with a
FloorRequestStatus message from the server with a Request Status
different from Cancelled or Released. In any case, such a
FloorRequestStatus message will not be a response to the FloorRelease
message, as its Transaction ID will not match that of the
FloorRelease.[¶](#section-10.2.2-4){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#sec_chair}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [Chair Operations](#name-chair-operations){.section-name .selfRef} {#name-chair-operations}

This section specifies how floor chairs can instruct the floor control
server to grant or revoke a floor using the protocol elements described
in earlier sections.[¶](#section-11-1){.pilcrow}

Floor chairs that wish to send instructions to a floor control server do
so by sending a ChairAction message.[¶](#section-11-2){.pilcrow}

::: {#sec_chair_send}
::: {#section-11.1 .section}
### [11.1.](#section-11.1){.section-number .selfRef} [Sending a ChairAction Message](#name-sending-a-chairaction-messa){.section-name .selfRef} {#name-sending-a-chairaction-messa}

The ABNF in [Section 5.3.9](#sec_msg_format_ChairAction){.xref}
describes the attributes that a ChairAction message can contain. In
addition, the ABNF specifies normatively which of these attributes are
mandatory, and which ones are optional.[¶](#section-11.1-1){.pilcrow}

The floor chair sets the Conference ID and the Transaction ID in the
COMMON-HEADER following the rules given in [Section
8.1](#sec_transactions_client){.xref}. The floor chair sets the User ID
in the COMMON-HEADER to the floor chair\'s
identifier.[¶](#section-11.1-2){.pilcrow}

The ChairAction message contains instructions that apply to one or more
floors within a particular floor request. The floor or floors are
identified by the FLOOR-REQUEST-STATUS attributes and the floor request
is identified by the FLOOR-REQUEST-INFORMATION-HEADER, which are carried
in the ChairAction message.[¶](#section-11.1-3){.pilcrow}

For example, if a floor request consists of two floors that depend on
different floor chairs, each floor chair will grant its floor within the
floor request. Once both chairs have granted their floor, the floor
control server will grant the floor request as a whole. On the other
hand, if one of the floor chairs denies its floor, the floor control
server will deny the floor request as a whole, regardless of the other
floor chair\'s decision.[¶](#section-11.1-4){.pilcrow}

The floor chair provides the new status of the floor request as it
relates to a particular floor using a FLOOR-REQUEST-STATUS attribute. If
the new status of the floor request is Accepted, the floor chair
[MAY]{.bcp14} use the Queue Position field to provide a queue position
for the floor request. If the floor chair does not wish to provide a
queue position, all the bits of the Queue Position field [MUST]{.bcp14}
be set to zero. The floor chair [MUST]{.bcp14} use the Status Revoked to
revoke a floor that was granted (i.e., Granted status) and
[MUST]{.bcp14} use the Status Denied to reject floor requests in any
other status (e.g., Pending and Accepted).[¶](#section-11.1-5){.pilcrow}

The floor chair [MAY]{.bcp14} add an OVERALL-REQUEST-STATUS attribute to
the ChairAction message to provide a new overall status for the floor
request. If the new overall status of the floor request is Accepted, the
floor chair can use the Queue Position field to provide a queue position
for the floor request.[¶](#section-11.1-6){.pilcrow}

Note that a particular floor control server can implement a different
queue for each floor containing all the floor requests that relate to
that particular floor, a general queue for all floor requests, or both.
Also note that a floor request can involve several floors and that a
ChairAction message can only deal with a subset of these floors (e.g.,
if a single floor chair is not authorized to manage all the floors). In
this case, the floor control server will combine the instructions
received from the different floor chairs in FLOOR-REQUEST-STATUS
attributes to come up with the overall status of the floor
request.[¶](#section-11.1-7.1){.pilcrow}

Note that, while the action of a floor chair may communicate information
in the OVERALL-REQUEST-STATUS attribute, the floor control server may
override, modify, or ignore this field\'s
content.[¶](#section-11.1-7.2){.pilcrow}

The floor chair [MAY]{.bcp14} include STATUS-INFO attributes to state
the reason why the floor or floors are being accepted, granted, or
revoked. The Text in the STATUS-INFO attribute is intended for human
consumption.[¶](#section-11.1-8){.pilcrow}
:::
:::

::: {#sec_chair_instruct_response}
::: {#section-11.2 .section}
### [11.2.](#section-11.2){.section-number .selfRef} [Receiving a Response](#name-receiving-a-response-3){.section-name .selfRef} {#name-receiving-a-response-3}

A message from the floor control server is considered a response to the
ChairAction message if the message from the server has the same
Conference ID, Transaction ID, and User ID as the ChairAction message,
as described in [Section 8.1](#sec_transactions_client){.xref}. On
receiving such a response, the floor chair follows the rules in [Section
9](#sec_auth){.xref} that relate to floor control server
authentication.[¶](#section-11.2-1){.pilcrow}

A ChairActionAck message from the floor control server confirms that the
floor control server has accepted the ChairAction message. An Error
message indicates that the floor control server could not process the
ChairAction message for some reason, which is described in the Error
message.[¶](#section-11.2-2){.pilcrow}
:::
:::
:::
:::

::: {#sec_client}
::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [General Client Operations](#name-general-client-operations){.section-name .selfRef} {#name-general-client-operations}

This section specifies operations that can be performed by any client.
That is, they are not specific to floor participants or floor chairs.
They can be performed by both.[¶](#section-12-1){.pilcrow}

::: {#sec_client_floorinfo}
::: {#section-12.1 .section}
### [12.1.](#section-12.1){.section-number .selfRef} [Requesting Information about Floors](#name-requesting-information-abou){.section-name .selfRef} {#name-requesting-information-abou}

A client can obtain information about the status of a floor or floors in
different ways, which include using BFCP and using out-of-band
mechanisms. Clients using BFCP to obtain such information use the
procedures described in this section.[¶](#section-12.1-1){.pilcrow}

Clients request information about the status of one or several floors by
sending a FloorQuery message to the floor control
server.[¶](#section-12.1-2){.pilcrow}

::: {#sec_client_floorinfo_send}
::: {#section-12.1.1 .section}
#### [12.1.1.](#section-12.1.1){.section-number .selfRef} [Sending a FloorQuery Message](#name-sending-a-floorquery-messag){.section-name .selfRef} {#name-sending-a-floorquery-messag}

The ABNF in [Section 5.3.7](#sec_msg_format_FloorQuery){.xref} describes
the attributes that a FloorQuery message can contain. In addition, the
ABNF specifies normatively which of these attributes are mandatory, and
which ones are optional.[¶](#section-12.1.1-1){.pilcrow}

The client sets the Conference ID and the Transaction ID in the
COMMON-HEADER following the rules given in [Section
8.1](#sec_transactions_client){.xref}. The client sets the User ID in
the COMMON-HEADER to the client\'s
identifier.[¶](#section-12.1.1-2){.pilcrow}

The client inserts in the message all the Floor IDs it wants to receive
information about. The floor control server will send periodic
information about all of these floors. If the client does not want to
receive information about a particular floor any longer, it sends a new
FloorQuery message removing the FLOOR-ID of this floor. If the client
does not want to receive information about any floor any longer, it
sends a FloorQuery message with no FLOOR-ID
attribute.[¶](#section-12.1.1-3){.pilcrow}
:::
:::

::: {#sec_client_floorinfo_response}
::: {#section-12.1.2 .section}
#### [12.1.2.](#section-12.1.2){.section-number .selfRef} [Receiving a Response](#name-receiving-a-response-4){.section-name .selfRef} {#name-receiving-a-response-4}

A message from the floor control server is considered a response to the
FloorQuery message if the message from the floor control server has the
same Conference ID, Transaction ID, and User ID as the FloorQuery
message, as described in [Section 8.1](#sec_transactions_client){.xref}.
On receiving such a response, the client follows the rules in [Section
9](#sec_auth){.xref} that relate to floor control server
authentication.[¶](#section-12.1.2-1){.pilcrow}

On reception of the FloorQuery message, the floor control server
[MUST]{.bcp14} respond with a FloorStatus message or with an Error
message. If the response is a FloorStatus message, it will contain
information about one of the floors the client requested information
about. If the client did not include any FLOOR-ID attribute in its
FloorQuery message (i.e., the client does not want to receive
information about any floor any longer), the FloorStatus message from
the floor control server will not include any FLOOR-ID attribute
either.[¶](#section-12.1.2-2){.pilcrow}

FloorStatus messages that carry information about a floor contain a
FLOOR-ID attribute that identifies the floor. After this attribute,
FloorStatus messages contain information about existing (one or more)
floor requests that relate to that floor. The information about each
particular floor request is encoded in a FLOOR-REQUEST-INFORMATION
attribute. This grouped attribute carries a Floor Request ID that
identifies the floor request, followed by a set of attributes that
provide information about the floor
request.[¶](#section-12.1.2-3){.pilcrow}

After the first FloorStatus, the floor control server will continue
sending FloorStatus messages, periodically informing the client about
changes on the floors the client requested information
about.[¶](#section-12.1.2-4){.pilcrow}
:::
:::

::: {#sec_recept_fsm}
::: {#section-12.1.3 .section}
#### [12.1.3.](#section-12.1.3){.section-number .selfRef} [Reception of a Subsequent FloorStatus Message](#name-reception-of-a-subsequent-fl){.section-name .selfRef} {#name-reception-of-a-subsequent-fl}

When communicating over an unreliable transport and upon receiving a
FloorStatus message from a floor control server, the participant
[MUST]{.bcp14} respond with a FloorStatusAck message within the
transaction failure window to complete the
transaction.[¶](#section-12.1.3-1){.pilcrow}
:::
:::
:::
:::

::: {#sec_client_info}
::: {#section-12.2 .section}
### [12.2.](#section-12.2){.section-number .selfRef} [Requesting Information about Floor Requests](#name-requesting-information-about){.section-name .selfRef} {#name-requesting-information-about}

A client can obtain information about the status of one or several floor
requests in different ways, which include using BFCP and using
out-of-band mechanisms. Clients using BFCP to obtain such information
use the procedures described in this
section.[¶](#section-12.2-1){.pilcrow}

Clients request information about the current status of a floor request
by sending a FloorRequestQuery message to the floor control
server.[¶](#section-12.2-2){.pilcrow}

Requesting information about a particular floor request is useful in a
number of situations. For example, on reception of a FloorRequest
message, a floor control server may choose to return FloorRequestStatus
messages only when the floor request changes its state (e.g., from
Accepted to Granted), but not when the floor request advances in its
queue. In this situation, if the user requests it, the floor participant
can use a FloorRequestQuery message to poll the floor control server for
the status of the floor request.[¶](#section-12.2-3){.pilcrow}

::: {#sec_client_info_send}
::: {#section-12.2.1 .section}
#### [12.2.1.](#section-12.2.1){.section-number .selfRef} [Sending a FloorRequestQuery Message](#name-sending-a-floorrequestquery){.section-name .selfRef} {#name-sending-a-floorrequestquery}

The ABNF in [Section 5.3.3](#sec_msg_format_FloorRequestQuery){.xref}
describes the attributes that a FloorRequestQuery message can contain.
In addition, the ABNF specifies normatively which of these attributes
are mandatory, and which ones are
optional.[¶](#section-12.2.1-1){.pilcrow}

The client sets the Conference ID and the Transaction ID in the
COMMON-HEADER following the rules given in [Section
8.1](#sec_transactions_client){.xref}. The client sets the User ID in
the COMMON-HEADER to the client\'s
identifier.[¶](#section-12.2.1-2){.pilcrow}

The client [MUST]{.bcp14} insert a FLOOR-REQUEST-ID attribute that
identifies the floor request at the floor control
server.[¶](#section-12.2.1-3){.pilcrow}
:::
:::

::: {#sec_client_info_response}
::: {#section-12.2.2 .section}
#### [12.2.2.](#section-12.2.2){.section-number .selfRef} [Receiving a Response](#name-receiving-a-response-5){.section-name .selfRef} {#name-receiving-a-response-5}

A message from the floor control server is considered a response to the
FloorRequestQuery message if the message from the floor control server
has the same Conference ID, Transaction ID, and User ID as the
FloorRequestQuery message, as described in [Section
8.1](#sec_transactions_client){.xref}. On receiving such a response, the
client follows the rules in [Section 9](#sec_auth){.xref} that relate to
floor control server authentication.[¶](#section-12.2.2-1){.pilcrow}

If the response is a FloorRequestStatus message, the client obtains
information about the status of the FloorRequest the client requested
information about in a FLOOR-REQUEST-INFORMATION
attribute.[¶](#section-12.2.2-2){.pilcrow}

If the response is an Error message, the floor control server could not
process the FloorRequestQuery message for some reason, which is
described in the Error message.[¶](#section-12.2.2-3){.pilcrow}
:::
:::
:::
:::

::: {#sec_client_user}
::: {#section-12.3 .section}
### [12.3.](#section-12.3){.section-number .selfRef} [Requesting Information about a User](#name-requesting-information-about-){.section-name .selfRef} {#name-requesting-information-about-}

A client can obtain information about a participant and the floor
requests related to this participant in different ways, which include
using BFCP and using out-of-band mechanisms. Clients using BFCP to
obtain such information use the procedures described in this
section.[¶](#section-12.3-1){.pilcrow}

Clients request information about a participant and the floor requests
related to this participant by sending a UserQuery message to the floor
control server.[¶](#section-12.3-2){.pilcrow}

This functionality may be useful for floor chairs or floor participants
interested in the display name and the URI of a particular floor
participant. In addition, a floor participant may find it useful to
request information about itself. For example, a floor participant,
after experiencing connectivity problems (e.g., its TCP connection with
the floor control server was down for a while and eventually was
re-established), may need to request information about all the floor
requests associated to itself that still
exist.[¶](#section-12.3-3){.pilcrow}

::: {#sec_client_user_send}
::: {#section-12.3.1 .section}
#### [12.3.1.](#section-12.3.1){.section-number .selfRef} [Sending a UserQuery Message](#name-sending-a-userquery-message){.section-name .selfRef} {#name-sending-a-userquery-message}

The ABNF in [Section 5.3.5](#sec_msg_format_UserQuery){.xref} describes
the attributes that a UserQuery message can contain. In addition, the
ABNF specifies normatively which of these attributes are mandatory, and
which ones are optional.[¶](#section-12.3.1-1){.pilcrow}

The client sets the Conference ID and the Transaction ID in the
COMMON-HEADER following the rules given in [Section
8.1](#sec_transactions_client){.xref}. The client sets the User ID in
the COMMON-HEADER to the client\'s
identifier.[¶](#section-12.3.1-2){.pilcrow}

If the floor participant the client is requesting information about is
not the client issuing the UserQuery message (which is identified by the
User ID in the COMMON-HEADER of the message), the client [MUST]{.bcp14}
insert a BENEFICIARY-ID attribute.[¶](#section-12.3.1-3){.pilcrow}
:::
:::

::: {#sec_client_user_response}
::: {#section-12.3.2 .section}
#### [12.3.2.](#section-12.3.2){.section-number .selfRef} [Receiving a Response](#name-receiving-a-response-6){.section-name .selfRef} {#name-receiving-a-response-6}

A message from the floor control server is considered a response to the
UserQuery message if the message from the floor control server has the
same Conference ID, Transaction ID, and User ID as the UserQuery
message, as described in [Section 8.1](#sec_transactions_client){.xref}.
On receiving such a response, the client follows the rules in [Section
9](#sec_auth){.xref} that relate to floor control server
authentication.[¶](#section-12.3.2-1){.pilcrow}

If the response is a UserStatus message, the client obtains information
about the floor participant in a BENEFICIARY-INFORMATION grouped
attribute and about the status of the floor requests associated with the
floor participant in FLOOR-REQUEST-INFORMATION
attributes.[¶](#section-12.3.2-2){.pilcrow}

If the response is an Error message, the floor control server could not
process the UserQuery message for some reason, which is described in the
Error message.[¶](#section-12.3.2-3){.pilcrow}
:::
:::
:::
:::

::: {#sec_client_hello}
::: {#section-12.4 .section}
### [12.4.](#section-12.4){.section-number .selfRef} [Obtaining the Capabilities of a Floor Control Server](#name-obtaining-the-capabilities-){.section-name .selfRef} {#name-obtaining-the-capabilities-}

A client that wishes to obtain the capabilities of a floor control
server does so by sending a Hello message to the floor control
server.[¶](#section-12.4-1){.pilcrow}

::: {#sec_client_hello_send}
::: {#section-12.4.1 .section}
#### [12.4.1.](#section-12.4.1){.section-number .selfRef} [Sending a Hello Message](#name-sending-a-hello-message){.section-name .selfRef} {#name-sending-a-hello-message}

The ABNF in [Section 5.3.11](#sec_msg_format_Hello){.xref} describes the
attributes that a Hello message can contain. In addition, the ABNF
specifies normatively which of these attributes are mandatory, and which
ones are optional.[¶](#section-12.4.1-1){.pilcrow}

The client sets the Conference ID and the Transaction ID in the
COMMON-HEADER following the rules given in [Section
8.1](#sec_transactions_client){.xref}. The client sets the User ID in
the COMMON-HEADER to the client\'s
identifier.[¶](#section-12.4.1-2){.pilcrow}
:::
:::

::: {#sec_client_hello_responses}
::: {#section-12.4.2 .section}
#### [12.4.2.](#section-12.4.2){.section-number .selfRef} [Receiving Responses](#name-receiving-responses){.section-name .selfRef} {#name-receiving-responses}

A message from the floor control server is considered a response to the
Hello message by the client if the message from the floor control server
has the same Conference ID, Transaction ID, and User ID as the Hello
message, as described in [Section 8.1](#sec_transactions_client){.xref}.
On receiving such a response, the client follows the rules in [Section
9](#sec_auth){.xref} that relate to floor control server
authentication.[¶](#section-12.4.2-1){.pilcrow}

If the response is a HelloAck message, the floor control server could
process the Hello message successfully. The SUPPORTED-PRIMITIVES and
SUPPORTED-ATTRIBUTES attributes indicate which primitives and
attributes, respectively, are supported by the
server.[¶](#section-12.4.2-2){.pilcrow}

If the response is an Error message, the floor control server could not
process the Hello message for some reason, which is described in the
Error message.[¶](#section-12.4.2-3){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#sec_server}
::: {#section-13 .section}
## [13.](#section-13){.section-number .selfRef} [Floor Control Server Operations](#name-floor-control-server-operat){.section-name .selfRef} {#name-floor-control-server-operat}

This section specifies how floor control servers can perform different
operations, such as granting a floor, using the protocol elements
described in earlier sections.[¶](#section-13-1){.pilcrow}

On reception of a message from a client, the floor control server
[MUST]{.bcp14} check whether the value of the primitive is supported. If
it is not, the floor control server [MUST]{.bcp14} send an Error
message, as described in [Section 13.8](#sec_server_error){.xref}, with
Error Code 3 (Unknown Primitive).[¶](#section-13-2){.pilcrow}

On reception of a message from a client, the floor control server
[MUST]{.bcp14} check whether the value of the Conference ID matched an
existing conference. If it does not, the floor control server
[MUST]{.bcp14} send an Error message, as described in [Section
13.8](#sec_server_error){.xref}, with Error Code 1 (Conference Does Not
Exist).[¶](#section-13-3){.pilcrow}

On reception of a message from a client, the floor control server
follows the rules in [Section 9](#sec_auth){.xref} that relate to the
authentication of the message.[¶](#section-13-4){.pilcrow}

On reception of a message from a client, the floor control server
[MUST]{.bcp14} check whether it understands all the mandatory (\'M\' bit
set) attributes in the message. If the floor control server does not
understand all of them, the floor control server [MUST]{.bcp14} send an
Error message, as described in [Section 13.8](#sec_server_error){.xref},
with Error Code 4 (Unknown Mandatory Attribute). The Error message
[SHOULD]{.bcp14} list the attributes that were not
understood.[¶](#section-13-5){.pilcrow}

::: {#sec_server_request}
::: {#section-13.1 .section}
### [13.1.](#section-13.1){.section-number .selfRef} [Reception of a FloorRequest Message](#name-reception-of-a-floorrequest){.section-name .selfRef} {#name-reception-of-a-floorrequest}

On reception of a FloorRequest message, the floor control server follows
the rules in [Section 9](#sec_auth){.xref} that relate to client
authentication and authorization. If while processing the FloorRequest
message, the floor control server encounters an error, it [MUST]{.bcp14}
generate an Error response following the procedures described in
[Section 13.8](#sec_server_error){.xref}.[¶](#section-13.1-1){.pilcrow}

BFCP allows floor participants to have several ongoing floor requests
for the same floor (e.g., the same floor participant can occupy more
than one position in a queue at the same time). A floor control server
that only supports a certain number of ongoing floor requests per floor
participant (e.g., one) can use Error Code 8 (You have Already Reached
the Maximum Number of Ongoing Floor Requests for This Floor) to inform
the floor participant.[¶](#section-13.1-2.1){.pilcrow}

When communicating over an unreliable transport and upon receiving a
FloorRequest from a participant, the floor control server [MUST]{.bcp14}
respond with a FloorRequestStatus message within the transaction failure
window to complete the transaction.[¶](#section-13.1-3){.pilcrow}

::: {#sec_server_request_first}
::: {#section-13.1.1 .section}
#### [13.1.1.](#section-13.1.1){.section-number .selfRef} [Generating the First FloorRequestStatus Message](#name-generating-the-first-floorr){.section-name .selfRef} {#name-generating-the-first-floorr}

The successful processing of a FloorRequest message by a floor control
server involves generating one or several FloorRequestStatus messages,
the first of which [SHOULD]{.bcp14} be generated as soon as possible. If
the floor control server cannot accept, grant, or deny the floor request
right away (e.g., a decision from a chair is needed), it
[SHOULD]{.bcp14} use a Request Status value of Pending in the
OVERALL-REQUEST-STATUS attribute (within the FLOOR-REQUEST-INFORMATION
grouped attribute) of the first FloorRequestStatus message it
generates.[¶](#section-13.1.1-1){.pilcrow}

The policy that a floor control server follows to grant or deny floors
is outside the scope of this document. A given floor control server may
perform these decisions automatically while another may contact a human
acting as a chair every time a decision needs to be
made.[¶](#section-13.1.1-2.1){.pilcrow}

The floor control server [MUST]{.bcp14} copy the Conference ID, the
Transaction ID, and the User ID from the FloorRequest into the
FloorRequestStatus, as described in [Section
8.2](#sec_transactions_server){.xref}. Additionally, the floor control
server [MUST]{.bcp14} add a FLOOR-REQUEST-INFORMATION grouped attribute
to the FloorRequestStatus. The attributes contained in this grouped
attribute carry information about the floor
request.[¶](#section-13.1.1-3){.pilcrow}

The floor control server [MUST]{.bcp14} assign an identifier that is
unique within the conference to this floor request, and [MUST]{.bcp14}
insert it in the Floor Request ID field of the FLOOR-REQUEST-INFORMATION
attribute. This identifier will be used by the floor participant (or by
a chair or chairs) to refer to this specific floor request in the
future.[¶](#section-13.1.1-4){.pilcrow}

The floor control server [MUST]{.bcp14} copy the Floor IDs in the
FLOOR-ID attributes of the FloorRequest into the FLOOR-REQUEST-STATUS
attributes in the FLOOR-REQUEST-INFORMATION grouped attribute. These
Floor IDs identify the floors being requested (i.e., the floors
associated with this particular floor
request).[¶](#section-13.1.1-5){.pilcrow}

The floor control server [SHOULD]{.bcp14} copy (if present) the contents
of the BENEFICIARY-ID attribute from the FloorRequest into a
BENEFICIARY-INFORMATION attribute inside the FLOOR-REQUEST-INFORMATION
grouped attribute. Additionally, the floor control server [MAY]{.bcp14}
provide the display name and the URI of the beneficiary in this
BENEFICIARY-INFORMATION attribute.[¶](#section-13.1.1-6){.pilcrow}

The floor control server [MAY]{.bcp14} provide information about the
requester of the floor in a REQUESTED-BY-INFORMATION attribute inside
the FLOOR-REQUEST-INFORMATION grouped
attribute.[¶](#section-13.1.1-7){.pilcrow}

The floor control server [MAY]{.bcp14} copy (if present) the PRIORITY
attribute from the FloorRequest into the FLOOR-REQUEST-INFORMATION
grouped attribute.[¶](#section-13.1.1-8){.pilcrow}

Note that this attribute carries the priority requested by the
participant. The priority that the floor control server assigns to the
floor request depends on the priority requested by the participant and
the rights the participant has according to the policy of the
conference. For example, a participant that is only allowed to use the
Normal priority may request Highest priority for a floor request. In
that case, the floor control server would ignore the priority requested
by the participant.[¶](#section-13.1.1-9.1){.pilcrow}

The floor control server [MAY]{.bcp14} copy (if present) the
PARTICIPANT-PROVIDED-INFO attribute from the FloorRequest into the
FLOOR-REQUEST-INFORMATION grouped
attribute.[¶](#section-13.1.1-10){.pilcrow}
:::
:::

::: {#sec_server_request_subsequent}
::: {#section-13.1.2 .section}
#### [13.1.2.](#section-13.1.2){.section-number .selfRef} [Generation of Subsequent FloorRequestStatus Messages](#name-generation-of-subsequent-fl){.section-name .selfRef} {#name-generation-of-subsequent-fl}

A floor request is considered to be ongoing as long as it is not in the
Cancelled, Released, or Revoked states. If the OVERALL-REQUEST-STATUS
attribute (inside the FLOOR-REQUEST-INFORMATION grouped attribute) of
the first FloorRequestStatus message generated by the floor control
server did not indicate any of these states, the floor control server
will need to send subsequent FloorRequestStatus
messages.[¶](#section-13.1.2-1){.pilcrow}

When the status of the floor request changes, the floor control server
[SHOULD]{.bcp14} send new FloorRequestStatus messages with the
appropriate Request Status. The floor control server [MUST]{.bcp14} add
a FLOOR-REQUEST-INFORMATION attribute with a Floor Request ID equal to
the one sent in the first FloorRequestStatus message to any new
FloorRequestStatus related to the same floor request. (The Floor Request
ID identifies the floor request to which the FloorRequestStatus
applies.)[¶](#section-13.1.2-2){.pilcrow}

When using BFCP over a reliable transport, the floor control server
[MUST]{.bcp14} set the Transaction ID of subsequent FloorRequestStatus
messages to zero. When using BFCP over an unreliable transport, the
Transaction ID [MUST]{.bcp14} be non-zero and unique in the context of
outstanding transactions over an unreliable transport as described in
[Section 8](#sec_transactions){.xref}.[¶](#section-13.1.2-3){.pilcrow}

The rate at which the floor control server sends FloorRequestStatus
messages is a matter of local policy. A floor control server may choose
to send a new FloorRequestStatus message every time the floor request
moves in the floor request queue, while another may choose only to send
a new FloorRequestStatus message when the floor request is Granted or
Denied.[¶](#section-13.1.2-4.1){.pilcrow}

The floor control server may add a STATUS-INFO attribute to any of the
FloorRequestStatus messages it generates to provide extra information
about its decisions regarding the floor request (e.g., why it was
denied).[¶](#section-13.1.2-5){.pilcrow}

Floor participants and floor chairs may request to be informed about the
status of a floor following the procedures in [Section
12.1](#sec_client_floorinfo){.xref}. If the processing of a floor
request changes the status of a floor (e.g., the floor request is
granted and consequently the floor has a new holder), the floor control
server needs to follow the procedures in [Section
13.5](#sec_server_floorinfo){.xref} to inform the clients that have
requested that information.[¶](#section-13.1.2-6.1){.pilcrow}

The COMMON-HEADER and the rest of the attributes are the same as in the
first FloorRequestStatus message.[¶](#section-13.1.2-7){.pilcrow}

The floor control server can discard the state information about a
particular floor request when this reaches a status of Cancelled,
Released, or Revoked.[¶](#section-13.1.2-8){.pilcrow}

When communicating over an unreliable transport and a
FloorRequestStatusAck message is not received within the transaction
failure window, the floor control server [MUST]{.bcp14} retransmit the
FloorRequestStatus message according to [Section
6.2](#udp_transport){.xref}.[¶](#section-13.1.2-9){.pilcrow}
:::
:::
:::
:::

::: {#sec_server_requestinfo}
::: {#section-13.2 .section}
### [13.2.](#section-13.2){.section-number .selfRef} [Reception of a FloorRequestQuery Message](#name-reception-of-a-floorrequestq){.section-name .selfRef} {#name-reception-of-a-floorrequestq}

On reception of a FloorRequestQuery message, the floor control server
follows the rules in [Section 9](#sec_auth){.xref} that relate to client
authentication and authorization. If while processing the
FloorRequestQuery message, the floor control server encounters an error,
it [MUST]{.bcp14} generate an Error response following the procedures
described in [Section
13.8](#sec_server_error){.xref}.[¶](#section-13.2-1){.pilcrow}

The successful processing of a FloorRequestQuery message by a floor
control server involves generating a FloorRequestStatus message, which
[SHOULD]{.bcp14} be generated as soon as
possible.[¶](#section-13.2-2){.pilcrow}

When communicating over an unreliable transport and upon receiving a
FloorRequestQuery from a participant, the floor control server
[MUST]{.bcp14} respond with a FloorRequestStatus message within the
transaction failure window to complete the
transaction.[¶](#section-13.2-3){.pilcrow}

The floor control server [MUST]{.bcp14} copy the Conference ID, the
Transaction ID, and the User ID from the FloorRequestQuery message into
the FloorRequestStatus message, as described in [Section
8.2](#sec_transactions_server){.xref}. Additionally, the floor control
server [MUST]{.bcp14} include information about the floor request in the
FLOOR-REQUEST-INFORMATION grouped attribute to the
FloorRequestStatus.[¶](#section-13.2-4){.pilcrow}

The floor control server [MUST]{.bcp14} copy the contents of the
FLOOR-REQUEST-ID attribute from the FloorRequestQuery message into the
Floor Request ID field of the FLOOR-REQUEST-INFORMATION
attribute.[¶](#section-13.2-5){.pilcrow}

The floor control server [MUST]{.bcp14} add FLOOR-REQUEST-STATUS
attributes to the FLOOR-REQUEST-INFORMATION grouped attribute
identifying the floors being requested (i.e., the floors associated with
the floor request identified by the FLOOR-REQUEST-ID
attribute).[¶](#section-13.2-6){.pilcrow}

The floor control server [SHOULD]{.bcp14} add a BENEFICIARY-ID attribute
to the FLOOR-REQUEST-INFORMATION grouped attribute identifying the
beneficiary of the floor request. Additionally, the floor control server
[MAY]{.bcp14} provide the display name and the URI of the beneficiary in
this BENEFICIARY-INFORMATION attribute.[¶](#section-13.2-7){.pilcrow}

The floor control server [MAY]{.bcp14} provide information about the
requester of the floor in a REQUESTED-BY-INFORMATION attribute inside
the FLOOR-REQUEST-INFORMATION grouped
attribute.[¶](#section-13.2-8){.pilcrow}

The floor control server [MAY]{.bcp14} provide the reason why the floor
participant requested the floor in a
PARTICIPANT-PROVIDED-INFO.[¶](#section-13.2-9){.pilcrow}

The floor control server [MAY]{.bcp14} also add to the
FLOOR-REQUEST-INFORMATION grouped attribute a PRIORITY attribute with
the Priority value requested for the floor request and a STATUS-INFO
attribute with extra information about the floor
request.[¶](#section-13.2-10){.pilcrow}

The floor control server [MUST]{.bcp14} add an OVERALL-REQUEST-STATUS
attribute to the FLOOR-REQUEST-INFORMATION grouped attribute with the
current status of the floor request. The floor control server
[MAY]{.bcp14} provide information about the status of the floor request
as it relates to each of the floors being requested in the
FLOOR-REQUEST-STATUS attributes.[¶](#section-13.2-11){.pilcrow}
:::
:::

::: {#sec_server_userinfo}
::: {#section-13.3 .section}
### [13.3.](#section-13.3){.section-number .selfRef} [Reception of a UserQuery Message](#name-reception-of-a-userquery-me){.section-name .selfRef} {#name-reception-of-a-userquery-me}

On reception of a UserQuery message, the floor control server follows
the rules in [Section 9](#sec_auth){.xref} that relate to client
authentication and authorization. If while processing the UserQuery
message, the floor control server encounters an error, it [MUST]{.bcp14}
generate an Error response following the procedures described in
[Section 13.8](#sec_server_error){.xref}.[¶](#section-13.3-1){.pilcrow}

The successful processing of a UserQuery message by a floor control
server involves generating a UserStatus message, which [SHOULD]{.bcp14}
be generated as soon as possible.[¶](#section-13.3-2){.pilcrow}

When communicating over an unreliable transport and upon receiving a
UserQuery from a participant, the floor control server [MUST]{.bcp14}
respond with a UserStatus message within the transaction failure window
to complete the transaction.[¶](#section-13.3-3){.pilcrow}

The floor control server [MUST]{.bcp14} copy the Conference ID, the
Transaction ID, and the User ID from the UserQuery message into the
UserStatus message, as described in [Section
8.2](#sec_transactions_server){.xref}.[¶](#section-13.3-4){.pilcrow}

The sender of the UserQuery message is requesting information about all
the floor requests associated with a given participant (i.e., the floor
requests where the participant is either the beneficiary or the
requester). This participant is identified by a BENEFICIARY-ID attribute
or, in the absence of a BENEFICIARY-ID attribute, by a the User ID in
the COMMON-HEADER of the UserQuery
message.[¶](#section-13.3-5){.pilcrow}

The floor control server [MUST]{.bcp14} copy, if present, the contents
of the BENEFICIARY-ID attribute from the UserQuery message into a
BENEFICIARY-INFORMATION attribute in the UserStatus message.
Additionally, the floor control server [MAY]{.bcp14} provide the display
name and the URI of the participant about which the UserStatus message
provides information in this BENEFICIARY-INFORMATION
attribute.[¶](#section-13.3-6){.pilcrow}

The floor control server [SHOULD]{.bcp14} add to the UserStatus message
a FLOOR-REQUEST-INFORMATION grouped attribute for each floor request
related to the participant about which the message provides information
(i.e., the floor requests where the participant is either the
beneficiary or the requester). For each FLOOR-REQUEST-INFORMATION
attribute, the floor control server follows the following
steps.[¶](#section-13.3-7){.pilcrow}

The floor control server [MUST]{.bcp14} identify the floor request the
FLOOR-REQUEST-INFORMATION attribute applies to by filling the Floor
Request ID field of the FLOOR-REQUEST-INFORMATION
attribute.[¶](#section-13.3-8){.pilcrow}

The floor control server [MUST]{.bcp14} add FLOOR-REQUEST-STATUS
attributes to the FLOOR-REQUEST-INFORMATION grouped attribute
identifying the floors being requested (i.e., the floors associated with
the floor request identified by the FLOOR-REQUEST-ID
attribute).[¶](#section-13.3-9){.pilcrow}

The floor control server [SHOULD]{.bcp14} add a BENEFICIARY-ID attribute
to the FLOOR-REQUEST-INFORMATION grouped attribute identifying the
beneficiary of the floor request. Additionally, the floor control server
[MAY]{.bcp14} provide the display name and the URI of the beneficiary in
this BENEFICIARY-INFORMATION attribute.[¶](#section-13.3-10){.pilcrow}

The floor control server [MAY]{.bcp14} provide information about the
requester of the floor in a REQUESTED-BY-INFORMATION attribute inside
the FLOOR-REQUEST-INFORMATION grouped
attribute.[¶](#section-13.3-11){.pilcrow}

The floor control server [MAY]{.bcp14} provide the reason why the floor
participant requested the floor in a
PARTICIPANT-PROVIDED-INFO.[¶](#section-13.3-12){.pilcrow}

The floor control server [MAY]{.bcp14} also add to the
FLOOR-REQUEST-INFORMATION grouped attribute a PRIORITY attribute with
the Priority value requested for the floor
request.[¶](#section-13.3-13){.pilcrow}

The floor control server [MUST]{.bcp14} include the current status of
the floor request in an OVERALL-REQUEST-STATUS attribute to the
FLOOR-REQUEST-INFORMATION grouped attribute. The floor control server
[MAY]{.bcp14} add a STATUS-INFO attribute with extra information about
the floor request.[¶](#section-13.3-14){.pilcrow}

The floor control server [MAY]{.bcp14} provide information about the
status of the floor request as it relates to each of the floors being
requested in the FLOOR-REQUEST-STATUS
attributes.[¶](#section-13.3-15){.pilcrow}
:::
:::

::: {#sec_server_release}
::: {#section-13.4 .section}
### [13.4.](#section-13.4){.section-number .selfRef} [Reception of a FloorRelease Message](#name-reception-of-a-floorrelease){.section-name .selfRef} {#name-reception-of-a-floorrelease}

On reception of a FloorRelease message, the floor control server follows
the rules in [Section 9](#sec_auth){.xref} that relate to client
authentication and authorization. If while processing the FloorRelease
message, the floor control server encounters an error, it [MUST]{.bcp14}
generate an Error response following the procedures described in
[Section 13.8](#sec_server_error){.xref}.[¶](#section-13.4-1){.pilcrow}

The successful processing of a FloorRelease message by a floor control
server involves generating a FloorRequestStatus message, which
[SHOULD]{.bcp14} be generated as soon as
possible.[¶](#section-13.4-2){.pilcrow}

When communicating over an unreliable transport and upon receiving a
FloorRelease from a participant, the floor control server [MUST]{.bcp14}
respond with a FloorRequestStatus message within the transaction failure
window to complete the transaction.[¶](#section-13.4-3){.pilcrow}

The floor control server [MUST]{.bcp14} copy the Conference ID, the
Transaction ID, and the User ID from the FloorRelease message into the
FloorRequestStatus message, as described in [Section
8.2](#sec_transactions_server){.xref}.[¶](#section-13.4-4){.pilcrow}

The floor control server [MUST]{.bcp14} add a FLOOR-REQUEST-INFORMATION
grouped attribute to the FloorRequestStatus. The attributes contained in
this grouped attribute carry information about the floor
request.[¶](#section-13.4-5){.pilcrow}

The FloorRelease message identifies the floor request it applies to
using a FLOOR-REQUEST-ID. The floor control server [MUST]{.bcp14} copy
the contents of the FLOOR-REQUEST-ID attribute from the FloorRelease
message into the Floor Request ID field of the FLOOR-REQUEST-INFORMATION
attribute.[¶](#section-13.4-6){.pilcrow}

The floor control server [MUST]{.bcp14} identify the floors being
released (i.e., the floors associated with the floor request identified
by the FLOOR-REQUEST-ID attribute) in FLOOR-REQUEST-STATUS attributes to
the FLOOR-REQUEST-INFORMATION grouped
attribute.[¶](#section-13.4-7){.pilcrow}

The floor control server [MUST]{.bcp14} add an OVERALL-REQUEST-STATUS
attribute to the FLOOR-REQUEST-INFORMATION grouped attribute. The
Request Status value [SHOULD]{.bcp14} be Released, if the floor (or
floors) had been previously granted, or Cancelled, if the floor (or
floors) had not been previously granted. The floor control server
[MAY]{.bcp14} add a STATUS-INFO attribute with extra information about
the floor request.[¶](#section-13.4-8){.pilcrow}
:::
:::

::: {#sec_server_floorinfo}
::: {#section-13.5 .section}
### [13.5.](#section-13.5){.section-number .selfRef} [Reception of a FloorQuery Message](#name-reception-of-a-floorquery-m){.section-name .selfRef} {#name-reception-of-a-floorquery-m}

On reception of a FloorQuery message, the floor control server follows
the rules in [Section 9](#sec_auth){.xref} that relate to client
authentication. If while processing the FloorQuery message, the floor
control server encounters an error, it [MUST]{.bcp14} generate an Error
response following the procedures described in [Section
13.8](#sec_server_error){.xref}.[¶](#section-13.5-1){.pilcrow}

When communicating over an unreliable transport and upon receiving a
FloorQuery from a participant, the floor control server [MUST]{.bcp14}
respond with a FloorStatus message within the transaction failure window
to complete the transaction.[¶](#section-13.5-2){.pilcrow}

A floor control server receiving a FloorQuery message from a client
[SHOULD]{.bcp14} keep this client informed about the status of the
floors identified by FLOOR-ID attributes in the FloorQuery message.
Floor control servers keep clients informed by using FloorStatus
messages.[¶](#section-13.5-3){.pilcrow}

An individual FloorStatus message carries information about a single
floor. So, when a FloorQuery message requests information about more
than one floor, the floor control server needs to send separate
FloorStatus messages for different floors.[¶](#section-13.5-4){.pilcrow}

The information FloorQuery messages carry may depend on the user
requesting the information. For example, a chair may be able to receive
information about pending requests, while a regular user may not be
authorized to do so.[¶](#section-13.5-5){.pilcrow}

::: {#sec_server_floorinfo_first}
::: {#section-13.5.1 .section}
#### [13.5.1.](#section-13.5.1){.section-number .selfRef} [Generation of the First FloorStatus Message](#name-generation-of-the-first-flo){.section-name .selfRef} {#name-generation-of-the-first-flo}

The successful processing of a FloorQuery message by a floor control
server involves generating one or several FloorStatus messages, the
first of which [SHOULD]{.bcp14} be generated as soon as
possible.[¶](#section-13.5.1-1){.pilcrow}

The floor control server [MUST]{.bcp14} copy the Conference ID, the
Transaction ID, and the User ID from the FloorQuery message into the
FloorStatus message, as described in [Section
8.2](#sec_transactions_server){.xref}.[¶](#section-13.5.1-2){.pilcrow}

If the FloorQuery message did not contain any FLOOR-ID attribute, the
floor control server sends the FloorStatus message without adding any
additional attribute and does not send any subsequent FloorStatus
message to the floor participant.[¶](#section-13.5.1-3){.pilcrow}

If the FloorQuery message contained one or more FLOOR-ID attributes, the
floor control server chooses one from among them and adds this FLOOR-ID
attribute to the FloorStatus message. The floor control server
[SHOULD]{.bcp14} add a FLOOR-REQUEST-INFORMATION grouped attribute for
each floor request associated to the floor. Each
FLOOR-REQUEST-INFORMATION grouped attribute contains a number of
attributes that provide information about the floor request. For each
FLOOR-REQUEST-INFORMATION attribute, the floor control server follows
the following steps.[¶](#section-13.5.1-4){.pilcrow}

The floor control server [MUST]{.bcp14} identify the floor request the
FLOOR-REQUEST-INFORMATION attribute applies to by filling the Floor
Request ID field of the FLOOR-REQUEST-INFORMATION
attribute.[¶](#section-13.5.1-5){.pilcrow}

The floor control server [MUST]{.bcp14} add FLOOR-REQUEST-STATUS
attributes to the FLOOR-REQUEST-INFORMATION grouped attribute
identifying the floors being requested (i.e., the floors associated with
the floor request identified by the FLOOR-REQUEST-ID
attribute).[¶](#section-13.5.1-6){.pilcrow}

The floor control server [SHOULD]{.bcp14} add a BENEFICIARY-ID attribute
to the FLOOR-REQUEST-INFORMATION grouped attribute identifying the
beneficiary of the floor request. Additionally, the floor control server
[MAY]{.bcp14} provide the display name and the URI of the beneficiary in
this BENEFICIARY-INFORMATION attribute.[¶](#section-13.5.1-7){.pilcrow}

The floor control server [MAY]{.bcp14} provide information about the
requester of the floor in a REQUESTED-BY-INFORMATION attribute inside
the FLOOR-REQUEST-INFORMATION grouped
attribute.[¶](#section-13.5.1-8){.pilcrow}

The floor control server [MAY]{.bcp14} provide the reason why the floor
participant requested the floor in a
PARTICIPANT-PROVIDED-INFO.[¶](#section-13.5.1-9){.pilcrow}

The floor control server [MAY]{.bcp14} also add to the
FLOOR-REQUEST-INFORMATION grouped attribute a PRIORITY attribute with
the Priority value requested for the floor
request.[¶](#section-13.5.1-10){.pilcrow}

The floor control server [MUST]{.bcp14} add an OVERALL-REQUEST-STATUS
attribute to the FLOOR-REQUEST-INFORMATION grouped attribute with the
current status of the floor request. The floor control server
[MAY]{.bcp14} add a STATUS-INFO attribute with extra information about
the floor request.[¶](#section-13.5.1-11){.pilcrow}

The floor control server [MAY]{.bcp14} provide information about the
status of the floor request as it relates to each of the floors being
requested in the FLOOR-REQUEST-STATUS
attributes.[¶](#section-13.5.1-12){.pilcrow}
:::
:::

::: {#sec_server_floorinfo_subsequent}
::: {#section-13.5.2 .section}
#### [13.5.2.](#section-13.5.2){.section-number .selfRef} [Generation of Subsequent FloorStatus Messages](#name-generation-of-subsequent-flo){.section-name .selfRef} {#name-generation-of-subsequent-flo}

If the FloorQuery message carried more than one FLOOR-ID attribute, the
floor control server [SHOULD]{.bcp14} generate a FloorStatus message for
each of them (except for the FLOOR-ID attribute chosen for the first
FloorStatus message) as soon as possible. These FloorStatus messages are
generated following the same rules as those for the first FloorStatus
message (see [Section 13.5.1](#sec_server_floorinfo_first){.xref}), but
their Transaction ID is 0 when using a reliable transport and non-zero
and unique in the context of outstanding transactions when using an
unreliable transport (cf. [Section
8](#sec_transactions){.xref}).[¶](#section-13.5.2-1){.pilcrow}

After generating these messages, the floor control server sends
FloorStatus messages, periodically keeping the client informed about all
the floors for which the client requested information. The Transaction
ID of these messages [MUST]{.bcp14} be 0 when using a reliable transport
and non-zero and unique in the context of outstanding transactions when
using an unreliable transport (cf. [Section
8](#sec_transactions){.xref}).[¶](#section-13.5.2-2){.pilcrow}

The rate at which the floor control server sends FloorStatus messages is
a matter of local policy. A floor control server may choose to send a
new FloorStatus message every time a new floor request arrives, while
another may choose to only send a new FloorStatus message when a new
floor request is Granted.[¶](#section-13.5.2-3.1){.pilcrow}

When communicating over an unreliable transport and a FloorStatusAck
message is not received within the transaction failure window, the floor
control server [MUST]{.bcp14} retransmit the FloorStatus message
according to [Section
6.2](#udp_transport){.xref}.[¶](#section-13.5.2-4){.pilcrow}
:::
:::
:::
:::

::: {#sec_server_chairaction}
::: {#section-13.6 .section}
### [13.6.](#section-13.6){.section-number .selfRef} [Reception of a ChairAction Message](#name-reception-of-a-chairaction-){.section-name .selfRef} {#name-reception-of-a-chairaction-}

On reception of a ChairAction message, the floor control server follows
the rules in [Section 9](#sec_auth){.xref} that relate to client
authentication and authorization. If while processing the ChairAction
message, the floor control server encounters an error, it [MUST]{.bcp14}
generate an Error response following the procedures described in
[Section 13.8](#sec_server_error){.xref}.[¶](#section-13.6-1){.pilcrow}

The successful processing of a ChairAction message by a floor control
server involves generating a ChairActionAck message, which
[SHOULD]{.bcp14} be generated as soon as
possible.[¶](#section-13.6-2){.pilcrow}

When communicating over an unreliable transport and upon receiving a
ChairAction from a chair, the floor control server [MUST]{.bcp14}
respond with a ChairActionAck message within the transaction failure
window to complete the transaction.[¶](#section-13.6-3){.pilcrow}

The floor control server [MUST]{.bcp14} copy the Conference ID, the
Transaction ID, and the User ID from the ChairAction message into the
ChairActionAck message, as described in [Section
8.2](#sec_transactions_server){.xref}.[¶](#section-13.6-4){.pilcrow}

The floor control server needs to take into consideration the operation
requested in the ChairAction message (e.g., granting a floor) but does
not necessarily need to perform it as requested by the floor chair. The
operation that the floor control server performs depends on the
ChairAction message and on the internal state of the floor control
server.[¶](#section-13.6-5){.pilcrow}

For example, a floor chair may send a ChairAction message granting a
floor that was requested as part of an atomic floor request operation
that involved several floors. Even if the chair responsible for one of
the floors instructs the floor control server to grant the floor, the
floor control server will not grant it until the chairs responsible for
the other floors agree to grant them as
well.[¶](#section-13.6-6){.pilcrow}

So, the floor control server is ultimately responsible for keeping a
coherent floor state using instructions from floor chairs as input to
this state.[¶](#section-13.6-7){.pilcrow}

If the new Status in the ChairAction message is Accepted and all the
bits of the Queue Position field are zero, the floor chair is requesting
that the floor control server assign a queue position (e.g., the last in
the queue) to the floor request based on the local policy of the floor
control server. (Of course, such a request only applies if the floor
control server implements a queue.)[¶](#section-13.6-8){.pilcrow}
:::
:::

::: {#sec_server_helloack}
::: {#section-13.7 .section}
### [13.7.](#section-13.7){.section-number .selfRef} [Reception of a Hello Message](#name-reception-of-a-hello-messag){.section-name .selfRef} {#name-reception-of-a-hello-messag}

On reception of a Hello message, the floor control server follows the
rules in [Section 9](#sec_auth){.xref} that relate to client
authentication. If while processing the Hello message, the floor control
server encounters an error, it [MUST]{.bcp14} generate an Error response
following the procedures described in [Section
13.8](#sec_server_error){.xref}.[¶](#section-13.7-1){.pilcrow}

If the version of BFCP specified in the version field of the
COMMON-HEADER is supported by the floor control server, it
[MUST]{.bcp14} respond with the same version number in the HelloAck;
this defines the version for all subsequent BFCP messages within this
BFCP Connection.[¶](#section-13.7-2){.pilcrow}

When communicating over an unreliable transport and upon receiving a
Hello from a participant, the floor control server [MUST]{.bcp14}
respond with a HelloAck message within the transaction failure window to
complete the transaction.[¶](#section-13.7-3){.pilcrow}

The successful processing of a Hello message by a floor control server
involves generating a HelloAck message, which [SHOULD]{.bcp14} be
generated as soon as possible. The floor control server [MUST]{.bcp14}
copy the Conference ID, the Transaction ID, and the User ID from the
Hello into the HelloAck, as described in [Section
8.2](#sec_transactions_server){.xref}.[¶](#section-13.7-4){.pilcrow}

The floor control server [MUST]{.bcp14} add a SUPPORTED-PRIMITIVES
attribute to the HelloAck message listing all the primitives (i.e., BFCP
messages) supported by the floor control
server.[¶](#section-13.7-5){.pilcrow}

The floor control server [MUST]{.bcp14} add a SUPPORTED-ATTRIBUTES
attribute to the HelloAck message listing all the attributes supported
by the floor control server.[¶](#section-13.7-6){.pilcrow}
:::
:::

::: {#sec_server_error}
::: {#section-13.8 .section}
### [13.8.](#section-13.8){.section-number .selfRef} [Error Message Generation](#name-error-message-generation){.section-name .selfRef} {#name-error-message-generation}

Error messages are always sent in response to a previous message from
the client as part of a client-initiated transaction. The ABNF in
[Section 5.3.13](#sec_msg_format_Error){.xref} describes the attributes
that an Error message can contain. In addition, the ABNF specifies
normatively which of these attributes are mandatory and which ones are
optional.[¶](#section-13.8-1){.pilcrow}

The floor control server [MUST]{.bcp14} copy the Conference ID, the
Transaction ID, and the User ID from the message from the client into
the Error message, as described in [Section
8.2](#sec_transactions_server){.xref}.[¶](#section-13.8-2){.pilcrow}

The floor control server [MUST]{.bcp14} add an ERROR-CODE attribute to
the Error message. The ERROR-CODE attribute contains an error code from
[Table 5](#tab_errorcode){.xref}. Additionally, the floor control server
may add an ERROR-INFO attribute with extra information about the
error.[¶](#section-13.8-3){.pilcrow}
:::
:::
:::
:::

::: {#sec_security}
::: {#section-14 .section}
## [14.](#section-14){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

BFCP uses TLS/DTLS to provide mutual authentication between clients and
servers. TLS/DTLS also provides replay and integrity protection and
confidentiality. It is [RECOMMENDED]{.bcp14} that TLS/DTLS with an
encryption algorithm according to [Section
7](#sec_lower-security){.xref} always be used. In cases where
signaling/control traffic is properly protected, as described in
[Section 9](#sec_auth){.xref}, it is [REQUIRED]{.bcp14} to use a
mandated encryption algorithm. BFCP entities [MAY]{.bcp14} use other
security mechanisms to interwork with legacy implementation that do not
use TLS/DTLS as long as these mechanisms provide similar security
properties. An example of other mechanisms to effectively secure a
nonsecure BFCP connection is IPsec
\[[21](#RFC4301){.xref}\].[¶](#section-14-1){.pilcrow}

The remainder of this section analyzes some of the threats against BFCP
and how they are addressed.[¶](#section-14-2){.pilcrow}

An attacker may attempt to impersonate a client (a floor participant or
a floor chair) in order to generate forged floor requests or to grant or
deny existing floor requests. Client impersonation is avoided by having
servers only accept BFCP messages over authenticated TLS/DTLS
connections. The floor control server assumes that attackers cannot
hijack the TLS/DTLS connection and, therefore, that messages over the
TLS/DTLS connection come from the client that was initially
authenticated.[¶](#section-14-3){.pilcrow}

An attacker may attempt to impersonate a floor control server. A
successful attacker would be able to make clients think that they hold a
particular floor so that they would try to access a resource (e.g.,
sending media) without having legitimate rights to access it. Floor
control server impersonation is avoided by having servers only accept
BFCP messages over authenticated TLS/DTLS connections, as well as
ensuring clients only send and accept messages over authenticated
TLS/DTLS connections.[¶](#section-14-4){.pilcrow}

Attackers may attempt to modify messages exchanged by a client and a
floor control server. The integrity protection provided by TLS/DTLS
connections prevents this attack.[¶](#section-14-5){.pilcrow}

An attacker may attempt to fetch a valid message sent by a client to a
floor control server and replay it over a connection between the
attacker and the floor control server. This attack is prevented by
having floor control servers check that messages arriving over a given
authenticated TLS/DTLS connection use an authorized user ID (i.e., a
user ID that the user that established the authenticated TLS/DTLS
connection is allowed to use).[¶](#section-14-6){.pilcrow}

Attackers may attempt to pick messages from the network to get access to
confidential information between the floor control server and a client
(e.g., why a floor request was denied). TLS/DTLS confidentiality
prevents this attack. Therefore, it is [REQUIRED]{.bcp14} that TLS/DTLS
be used with an encryption algorithm according to [Section
7](#sec_lower-security){.xref}.[¶](#section-14-7){.pilcrow}
:::
:::

::: {#sec_iana}
::: {#section-15 .section}
## [15.](#section-15){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

The IANA has created a registry for BFCP parameters called \"The Binary
Floor Control Protocol (BFCP) Parameters\". This registry has a number
of subregistries, which are described in the following
sections.[¶](#section-15-1){.pilcrow}

::: {#section-15.1 .section}
### [15.1.](#section-15.1){.section-number .selfRef} [Attributes Subregistry](#name-attributes-subregistry){.section-name .selfRef} {#name-attributes-subregistry}

This section establishes the \"Attributes\" subregistry under the BFCP
Parameters registry. As per the terminology in RFC 8126
\[[6](#RFC8126){.xref}\], the registration policy for BFCP attributes is
\"Specification Required\". For the purposes of this subregistry, the
BFCP attributes for which IANA registration is requested [MUST]{.bcp14}
be defined by a Standards Track RFC. Such an RFC [MUST]{.bcp14} specify
the attribute\'s type, name, format, and
semantics.[¶](#section-15.1-1){.pilcrow}

For each BFCP attribute, the IANA registers its type, its name, and the
reference to the RFC where the attribute is defined. The following table
contains the initial values of this
subregistry.[¶](#section-15.1-2){.pilcrow}

[]{#name-initial-values-of-the-bfcp-}

::: {#tab_iana-attributes}
  Type   Attribute                   Reference
  ------ --------------------------- -----------
  1      BENEFICIARY-ID              RFC 8855
  2      FLOOR-ID                    RFC 8855
  3      FLOOR-REQUEST-ID            RFC 8855
  4      PRIORITY                    RFC 8855
  5      REQUEST-STATUS              RFC 8855
  6      ERROR-CODE                  RFC 8855
  7      ERROR-INFO                  RFC 8855
  8      PARTICIPANT-PROVIDED-INFO   RFC 8855
  9      STATUS-INFO                 RFC 8855
  10     SUPPORTED-ATTRIBUTES        RFC 8855
  11     SUPPORTED-PRIMITIVES        RFC 8855
  12     USER-DISPLAY-NAME           RFC 8855
  13     USER-URI                    RFC 8855
  14     BENEFICIARY-INFORMATION     RFC 8855
  15     FLOOR-REQUEST-INFORMATION   RFC 8855
  16     REQUESTED-BY-INFORMATION    RFC 8855
  17     FLOOR-REQUEST-STATUS        RFC 8855
  18     OVERALL-REQUEST-STATUS      RFC 8855

  : [Table 7](#table-7){.selfRef}: [Initial values of the BFCP
  Attributes subregistry](#name-initial-values-of-the-bfcp-){.selfRef}
:::
:::

::: {#sec_iana_primitive}
::: {#section-15.2 .section}
### [15.2.](#section-15.2){.section-number .selfRef} [Primitives Subregistry](#name-primitives-subregistry){.section-name .selfRef} {#name-primitives-subregistry}

This section establishes the \"Primitives\" subregistry under the BFCP
Parameters registry. As per the terminology in RFC 8126
\[[6](#RFC8126){.xref}\], the registration policy for BFCP primitives is
\"Specification Required\". For the purposes of this subregistry, the
BFCP primitives for which IANA registration is requested [MUST]{.bcp14}
be defined by a Standards Track RFC. Such an RFC [MUST]{.bcp14} specify
the primitive\'s value, name, format, and
semantics.[¶](#section-15.2-1){.pilcrow}

For each BFCP primitive, the IANA registers its value, its name, and the
reference to the RFC where the primitive is defined. The following table
contains the initial values of this
subregistry.[¶](#section-15.2-2){.pilcrow}

[]{#name-initial-values-of-the-bfcp-p}

::: {#tab_iana-primitives}
  Value   Primitive               Reference
  ------- ----------------------- -----------
  1       FloorRequest            RFC 8855
  2       FloorRelease            RFC 8855
  3       FloorRequestQuery       RFC 8855
  4       FloorRequestStatus      RFC 8855
  5       UserQuery               RFC 8855
  6       UserStatus              RFC 8855
  7       FloorQuery              RFC 8855
  8       FloorStatus             RFC 8855
  9       ChairAction             RFC 8855
  10      ChairActionAck          RFC 8855
  11      Hello                   RFC 8855
  12      HelloAck                RFC 8855
  13      Error                   RFC 8855
  14      FloorRequestStatusAck   RFC 8855
  15      FloorStatusAck          RFC 8855
  16      Goodbye                 RFC 8855
  17      GoodbyeAck              RFC 8855

  : [Table 8](#table-8){.selfRef}: [Initial values of the BFCP
  Primitives subregistry](#name-initial-values-of-the-bfcp-p){.selfRef}
:::
:::
:::

::: {#section-15.3 .section}
### [15.3.](#section-15.3){.section-number .selfRef} [Request Statuses Subregistry](#name-request-statuses-subregistr){.section-name .selfRef} {#name-request-statuses-subregistr}

This section establishes the \"Request Statuses\" subregistry under the
BFCP Parameters registry. As per the terminology in RFC 8126
\[[6](#RFC8126){.xref}\], the registration policy for BFCP request
statuses is \"Specification Required\". For the purposes of this
subregistry, the BFCP request statuses for which IANA registration is
requested [MUST]{.bcp14} be defined by a Standards Track RFC. Such an
RFC [MUST]{.bcp14} specify the value and the semantics of the request
status.[¶](#section-15.3-1){.pilcrow}

For each BFCP request status, the IANA registers its value, its meaning,
and the reference to the RFC where the request status is defined. The
following table contains the initial values of this
subregistry.[¶](#section-15.3-2){.pilcrow}

[]{#name-initial-values-of-the-reque}

::: {#tab_iana-requeststatusvalues}
  Value   Status      Reference
  ------- ----------- -----------
  1       Pending     RFC 8855
  2       Accepted    RFC 8855
  3       Granted     RFC 8855
  4       Denied      RFC 8855
  5       Cancelled   RFC 8855
  6       Released    RFC 8855
  7       Revoked     RFC 8855

  : [Table 9](#table-9){.selfRef}: [Initial values of the Request
  Statuses subregistry](#name-initial-values-of-the-reque){.selfRef}
:::
:::

::: {#sec_iana_errorcode}
::: {#section-15.4 .section}
### [15.4.](#section-15.4){.section-number .selfRef} [Error Codes Subregistry](#name-error-codes-subregistry){.section-name .selfRef} {#name-error-codes-subregistry}

This section establishes the \"Error Codes\" subregistry under the BFCP
Parameters registry. As per the terminology in RFC 8126
\[[6](#RFC8126){.xref}\], the registration policy for BFCP error codes
is \"Specification Required\". For the purposes of this subregistry, the
BFCP error codes for which IANA registration is requested [MUST]{.bcp14}
be defined by a Standards Track RFC. Such an RFC [MUST]{.bcp14} specify
the value and the semantics of the error code, and any Error Specific
Details that apply to it.[¶](#section-15.4-1){.pilcrow}

For each BFCP primitive, the IANA registers its value, its meaning, and
the reference to the RFC where the primitive is defined. The following
table contains the initial values of this
subregistry.[¶](#section-15.4-2){.pilcrow}

[]{#name-initial-values-of-the-error}

::: {#tab_iana-errorcode}
  Value   Meaning                                                                                Reference
  ------- -------------------------------------------------------------------------------------- -----------
  1       Conference Does Not Exist                                                              RFC 8855
  2       User Does Not Exist                                                                    RFC 8855
  3       Unknown Primitive                                                                      RFC 8855
  4       Unknown Mandatory Attribute                                                            RFC 8855
  5       Unauthorized Operation                                                                 RFC 8855
  6       Invalid Floor ID                                                                       RFC 8855
  7       Floor Request ID Does Not Exist                                                        RFC 8855
  8       You have Already Reached the Maximum Number of Ongoing Floor Requests for This Floor   RFC 8855
  9       Use TLS                                                                                RFC 8855
  10      Unable to Parse Message                                                                RFC 8855
  11      Use DTLS                                                                               RFC 8855
  12      Unsupported Version                                                                    RFC 8855
  13      Incorrect Message Length                                                               RFC 8855
  14      Generic Error                                                                          RFC 8855

  : [Table 10](#table-10){.selfRef}: [Initial values of the Error Codes
  subregistry](#name-initial-values-of-the-error){.selfRef}
:::
:::
:::
:::
:::

::: {#sec_changes}
::: {#section-16 .section}
## [16.](#section-16){.section-number .selfRef} [Changes from RFC 4582](#name-changes-from-rfc-4582){.section-name .selfRef} {#name-changes-from-rfc-4582}

The following is the list of technical changes and other non-trivial
fixes from \[[3](#RFC4582){.xref}\].[¶](#section-16-1){.pilcrow}

::: {#section-16.1 .section}
### [16.1.](#section-16.1){.section-number .selfRef} [Extensions for an Unreliable Transport](#name-extensions-for-an-unreliabl){.section-name .selfRef} {#name-extensions-for-an-unreliabl}

The main purpose of this work was to revise the specification to support
BFCP over an unreliable transport, resulting in the following
changes:[¶](#section-16.1-1){.pilcrow}

1.  ::: {#section-16.1-2.1}
    Overview of Operation ([Section
    4](#sec_overview){.xref}):[¶](#section-16.1-2.1.1){.pilcrow}

    Changed the description of client-initiated and server-initiated
    transactions, referring to [Section
    8](#sec_transactions){.xref}.[¶](#section-16.1-2.1.2){.pilcrow}
    :::

2.  ::: {#section-16.1-2.2}
    COMMON-HEADER Format ([Section
    5.1](#sec_format_common){.xref}):[¶](#section-16.1-2.2.1){.pilcrow}

    Ver(sion) field, where the value 2 is used for the extensions for an
    unreliable transport. Added new R and F flag bits for an unreliable
    transport. Res(erved) field is now 3 bit. New optional Fragment
    Offset and Fragment Length fields.[¶](#section-16.1-2.2.2){.pilcrow}
    :::

3.  ::: {#section-16.1-2.3}
    New primitives ([Section
    5.1](#sec_format_common){.xref}):[¶](#section-16.1-2.3.1){.pilcrow}

    Added four new primitives: FloorRequestStatusAck, FloorStatusAck,
    Goodbye, and GoodbyeAck.[¶](#section-16.1-2.3.2){.pilcrow}
    :::

4.  ::: {#section-16.1-2.4}
    New error codes ([Section
    5.2.6](#sec_format_attributes_error-code){.xref}):[¶](#section-16.1-2.4.1){.pilcrow}

    Added three new error codes: \"Unable to Parse Message\", \"Use
    DTLS\" and \"Unsupported Version\". Note that two additional error
    codes were added, see [Section
    16.2](#sec_changes_other){.xref}.[¶](#section-16.1-2.4.2){.pilcrow}
    :::

5.  ::: {#section-16.1-2.5}
    ABNF for new primitives ([Section
    5.3](#sec_msg_format){.xref}):[¶](#section-16.1-2.5.1){.pilcrow}

    Added new subsections with normative ABNF for the new
    primitives.[¶](#section-16.1-2.5.2){.pilcrow}
    :::

6.  ::: {#section-16.1-2.6}
    Transport split in two ([Section
    6](#sec_transport){.xref}):[¶](#section-16.1-2.6.1){.pilcrow}

    [Section 6](#sec_transport){.xref} specifying the transport was
    split in two subsections; [Section 6.1](#tcp_transport){.xref} for a
    reliable transport and [Section 6.2](#udp_transport){.xref} for an
    unreliable transport. The specification for an unreliable transport,
    among other issues, deals with reliability, congestion control,
    fragmentation and ICMP.[¶](#section-16.1-2.6.2){.pilcrow}
    :::

7.  ::: {#section-16.1-2.7}
    Mandated DTLS ([Section 7](#sec_lower-security){.xref} and [Section
    9](#sec_auth){.xref}):[¶](#section-16.1-2.7.1){.pilcrow}

    Mandated DTLS support when transport over UDP is
    used.[¶](#section-16.1-2.7.2){.pilcrow}
    :::

8.  ::: {#section-16.1-2.8}
    Transaction changes ([Section
    8](#sec_transactions){.xref}):[¶](#section-16.1-2.8.1){.pilcrow}

    Server-initiated transactions over an unreliable transport have
    non-zero and unique Transaction IDs. Over an unreliable transport,
    the retransmit timers T1 and T2 described in [Section
    8.3](#timers){.xref} apply.[¶](#section-16.1-2.8.2){.pilcrow}
    :::

9.  ::: {#section-16.1-2.9}
    Timely response required ([Section 8.3](#timers){.xref}, [Section
    10.1.2](#sec_client_request_response){.xref}, [Section
    10.2.2](#sec_participant_cancel_response){.xref}, [Section
    11.2](#sec_chair_instruct_response){.xref}, [Section
    12.1.2](#sec_client_floorinfo_response){.xref}, [Section
    12.2.2](#sec_client_info_response){.xref}, [Section
    12.3.2](#sec_client_user_response){.xref}, [Section
    12.4.2](#sec_client_hello_responses){.xref}, [Section
    10.1.3](#sec_recept_frsm){.xref} and [Section
    12.1.3](#sec_recept_fsm){.xref}):[¶](#section-16.1-2.9.1){.pilcrow}

    Described that a given response must be sent within the transaction
    failure window to complete the
    transaction.[¶](#section-16.1-2.9.2){.pilcrow}
    :::

10. ::: {#section-16.1-2.10}
    Updated IANA Considerations ([Section
    15](#sec_iana){.xref}):[¶](#section-16.1-2.10.1){.pilcrow}

    Added the new primitives and error codes to [Section
    15.2](#sec_iana_primitive){.xref} and [Section
    15.4](#sec_iana_errorcode){.xref}
    respectively.[¶](#section-16.1-2.10.2){.pilcrow}
    :::

11. ::: {#section-16.1-2.11}
    Examples over an unreliable transport ([Appendix
    A](#app_unrelcallflow){.xref}):[¶](#section-16.1-2.11.1){.pilcrow}

    Added sample interactions over an unreliable transport for the
    scenarios in [Figure 2](#fig_flow1){.xref} and [Figure
    3](#fig_flow2){.xref}[¶](#section-16.1-2.11.2){.pilcrow}
    :::

12. ::: {#section-16.1-2.12}
    Motivation for an unreliable transport ([Appendix
    B](#app_motivation){.xref}):[¶](#section-16.1-2.12.1){.pilcrow}

    Added introduction to and motivation for extending BFCP to support
    an unreliable transport.[¶](#section-16.1-2.12.2){.pilcrow}
    :::
:::

::: {#sec_changes_other}
::: {#section-16.2 .section}
### [16.2.](#section-16.2){.section-number .selfRef} [Other Changes](#name-other-changes){.section-name .selfRef} {#name-other-changes}

Clarifications and bug fixes:[¶](#section-16.2-1){.pilcrow}

1.  ::: {#section-16.2-2.1}
    ABNF fixes ([Figure 22](#fig_ben-information){.xref}, [Figure
    24](#fig_floor-request-information){.xref}, [Figure
    26](#fig_reqby-information){.xref}, [Figure
    28](#fig_floor-req-status){.xref}, [Figure
    30](#fig_overall-req-status){.xref}, and the ABNF figures in
    [Section
    5.3](#sec_msg_format){.xref}):[¶](#section-16.2-2.1.1){.pilcrow}

    Although formally correct in \[[3](#RFC4582){.xref}\], the notation
    has changed in a number of figures to an equivalent form for
    clarity, e.g., `s/*1(FLOOR-ID)/[FLOOR-ID]/` in [Figure
    38](#fig_floorstatus){.xref} and `s/*[XXX]/*(XXX)/` in the other
    figures.[¶](#section-16.2-2.1.2){.pilcrow}
    :::

2.  ::: {#section-16.2-2.2}
    Typo ([Section
    12.4.2](#sec_client_hello_responses){.xref}):[¶](#section-16.2-2.2.1){.pilcrow}

    Changed from SUPPORTED-PRIMITVIES to SUPPORTED-PRIMITIVES in the
    second paragraph.[¶](#section-16.2-2.2.2){.pilcrow}
    :::

3.  ::: {#section-16.2-2.3}
    Corrected attribute type ([Section
    13.1.1](#sec_server_request_first){.xref}):[¶](#section-16.2-2.3.1){.pilcrow}

    Changed from PARTICIPANT-PROVIDED-INFO to PRIORITY attribute in the
    eighth paragraph, since the note below describes priority and that
    the last paragraph deals with
    PARTICIPANT-PROVIDED-INFO.[¶](#section-16.2-2.3.2){.pilcrow}
    :::

4.  ::: {#section-16.2-2.4}
    New error codes ([Section
    5.2.6](#sec_format_attributes_error-code){.xref}):[¶](#section-16.2-2.4.1){.pilcrow}

    Added two additional error codes: \"Incorrect Message Length\" and
    \"Generic Error\".[¶](#section-16.2-2.4.2){.pilcrow}
    :::

5.  ::: {#section-16.2-2.5}
    New cipher suites ([Section
    7](#sec_lower-security){.xref})[¶](#section-16.2-2.5.1){.pilcrow}

    Additional cipher suites are now specified which should be
    supported.[¶](#section-16.2-2.5.2){.pilcrow}
    :::

6.  ::: {#section-16.2-2.6}
    Assorted clarifications (Across the
    document):[¶](#section-16.2-2.6.1){.pilcrow}

    Language clarifications as a result of reviews. Also, the normative
    language was tightened where appropriate, i.e. changed from
    [SHOULD]{.bcp14} strength to [MUST]{.bcp14} in a number of
    places.[¶](#section-16.2-2.6.2){.pilcrow}
    :::
:::
:::
:::
:::

::: {#section-17 .section}
## [17.](#section-17){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-17.1 .section}
### [17.1.](#section-17.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[1\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[2\]
:   [Paxson, V.]{.refAuthor}[, Allman, M.]{.refAuthor}[,
    Chu, J.]{.refAuthor}[, and M. Sargent]{.refAuthor}, [\"Computing
    TCP\'s Retransmission Timer\"]{.refTitle}, [RFC 6298]{.seriesInfo},
    [DOI 10.17487/RFC6298]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6298>\>.
:   

\[3\]
:   [Camarillo, G.]{.refAuthor}[, Ott, J.]{.refAuthor}[, and K.
    Drage]{.refAuthor}, [\"The Binary Floor Control Protocol
    (BFCP)\"]{.refTitle}, [RFC 4582]{.seriesInfo}, [DOI
    10.17487/RFC4582]{.seriesInfo}, November 2006,
    \<<https://www.rfc-editor.org/info/rfc4582>\>.
:   

\[4\]
:   [Camarillo, G.]{.refAuthor}, [\"Connection Establishment in the
    Binary Floor Control Protocol (BFCP)\"]{.refTitle}, [RFC
    5018]{.seriesInfo}, [DOI 10.17487/RFC5018]{.seriesInfo}, September
    2007, \<<https://www.rfc-editor.org/info/rfc5018>\>.
:   

\[5\]
:   [Crocker, D., Ed.]{.refAuthor}[ and P. Overell]{.refAuthor},
    [\"Augmented BNF for Syntax Specifications: ABNF\"]{.refTitle}, [STD
    68]{.seriesInfo}, [RFC 5234]{.seriesInfo}, [DOI
    10.17487/RFC5234]{.seriesInfo}, January 2008,
    \<<https://www.rfc-editor.org/info/rfc5234>\>.
:   

\[6\]
:   [Cotton, M.]{.refAuthor}[, Leiba, B.]{.refAuthor}[, and T.
    Narten]{.refAuthor}, [\"Guidelines for Writing an IANA
    Considerations Section in RFCs\"]{.refTitle}, [BCP 26]{.seriesInfo},
    [RFC 8126]{.seriesInfo}, [DOI 10.17487/RFC8126]{.seriesInfo}, June
    2017, \<<https://www.rfc-editor.org/info/rfc8126>\>.
:   

\[7\]
:   [Dierks, T.]{.refAuthor}[ and E. Rescorla]{.refAuthor}, [\"The
    Transport Layer Security (TLS) Protocol Version 1.2\"]{.refTitle},
    [RFC 5246]{.seriesInfo}, [DOI 10.17487/RFC5246]{.seriesInfo}, August
    2008, \<<https://www.rfc-editor.org/info/rfc5246>\>.
:   

\[8\]
:   [Rescorla, E.]{.refAuthor}[ and N. Modadugu]{.refAuthor},
    [\"Datagram Transport Layer Security Version 1.2\"]{.refTitle}, [RFC
    6347]{.seriesInfo}, [DOI 10.17487/RFC6347]{.seriesInfo}, January
    2012, \<<https://www.rfc-editor.org/info/rfc6347>\>.
:   

\[9\]
:   [Yergeau, F.]{.refAuthor}, [\"UTF-8, a transformation format of ISO
    10646\"]{.refTitle}, [STD 63]{.seriesInfo}, [RFC 3629]{.seriesInfo},
    [DOI 10.17487/RFC3629]{.seriesInfo}, November 2003,
    \<<https://www.rfc-editor.org/info/rfc3629>\>.
:   

\[10\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[11\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   

\[12\]
:   [Camarillo, G.]{.refAuthor}[, Kristensen, T.]{.refAuthor}[, and C.
    Holmberg]{.refAuthor}, [\"Session Description Protocol (SDP) Format
    for Binary Floor Control Protocol (BFCP) Streams\"]{.refTitle}, [RFC
    8856]{.seriesInfo}, [DOI 10.17487/RFC8856]{.seriesInfo}, January
    2021, \<<https://www.rfc-editor.org/info/rfc8856>\>.
:   

\[13\]
:   [Wing, D.]{.refAuthor}, [\"Symmetric RTP / RTP Control Protocol
    (RTCP)\"]{.refTitle}, [BCP 131]{.seriesInfo}, [RFC
    4961]{.seriesInfo}, [DOI 10.17487/RFC4961]{.seriesInfo}, July 2007,
    \<<https://www.rfc-editor.org/info/rfc4961>\>.
:   

\[14\]
:   [Rosenberg, J.]{.refAuthor}[, Mahy, R.]{.refAuthor}[,
    Matthews, P.]{.refAuthor}[, and D. Wing]{.refAuthor}, [\"Session
    Traversal Utilities for NAT (STUN)\"]{.refTitle}, [RFC
    5389]{.seriesInfo}, [DOI 10.17487/RFC5389]{.seriesInfo}, October
    2008, \<<https://www.rfc-editor.org/info/rfc5389>\>.
:   

\[15\]
:   [Eggert, L.]{.refAuthor}[, Fairhurst, G.]{.refAuthor}[, and G.
    Shepherd]{.refAuthor}, [\"UDP Usage Guidelines\"]{.refTitle}, [BCP
    145]{.seriesInfo}, [RFC 8085]{.seriesInfo}, [DOI
    10.17487/RFC8085]{.seriesInfo}, March 2017,
    \<<https://www.rfc-editor.org/info/rfc8085>\>.
:   

\[16\]
:   [Keranen, A.]{.refAuthor}[, Holmberg, C.]{.refAuthor}[, and J.
    Rosenberg]{.refAuthor}, [\"Interactive Connectivity Establishment
    (ICE): A Protocol for Network Address Translator (NAT)
    Traversal\"]{.refTitle}, [RFC 8445]{.seriesInfo}, [DOI
    10.17487/RFC8445]{.seriesInfo}, July 2018,
    \<<https://www.rfc-editor.org/info/rfc8445>\>.
:   
:::

::: {#section-17.2 .section}
### [17.2.](#section-17.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[17\]
:   [Rosenberg, J.]{.refAuthor}[ and H. Schulzrinne]{.refAuthor}, [\"An
    Offer/Answer Model with Session Description Protocol
    (SDP)\"]{.refTitle}, [RFC 3264]{.seriesInfo}, [DOI
    10.17487/RFC3264]{.seriesInfo}, June 2002,
    \<<https://www.rfc-editor.org/info/rfc3264>\>.
:   

\[18\]
:   [Koskelainen, P.]{.refAuthor}[, Ott, J.]{.refAuthor}[,
    Schulzrinne, H.]{.refAuthor}[, and X. Wu]{.refAuthor},
    [\"Requirements for Floor Control Protocols\"]{.refTitle}, [RFC
    4376]{.seriesInfo}, [DOI 10.17487/RFC4376]{.seriesInfo}, February
    2006, \<<https://www.rfc-editor.org/info/rfc4376>\>.
:   

\[19\]
:   [Barnes, M.]{.refAuthor}[, Boulton, C.]{.refAuthor}[, and O.
    Levin]{.refAuthor}, [\"A Framework for Centralized
    Conferencing\"]{.refTitle}, [RFC 5239]{.seriesInfo}, [DOI
    10.17487/RFC5239]{.seriesInfo}, June 2008,
    \<<https://www.rfc-editor.org/info/rfc5239>\>.
:   

\[20\]
:   [Rosenberg, J.]{.refAuthor}[, Schulzrinne, H.]{.refAuthor}[,
    Camarillo, G.]{.refAuthor}[, Johnston, A.]{.refAuthor}[,
    Peterson, J.]{.refAuthor}[, Sparks, R.]{.refAuthor}[,
    Handley, M.]{.refAuthor}[, and E. Schooler]{.refAuthor}, [\"SIP:
    Session Initiation Protocol\"]{.refTitle}, [RFC 3261]{.seriesInfo},
    [DOI 10.17487/RFC3261]{.seriesInfo}, June 2002,
    \<<https://www.rfc-editor.org/info/rfc3261>\>.
:   

\[21\]
:   [Kent, S.]{.refAuthor}[ and K. Seo]{.refAuthor}, [\"Security
    Architecture for the Internet Protocol\"]{.refTitle}, [RFC
    4301]{.seriesInfo}, [DOI 10.17487/RFC4301]{.seriesInfo}, December
    2005, \<<https://www.rfc-editor.org/info/rfc4301>\>.
:   

\[22\]
:   [Novo, O.]{.refAuthor}[, Camarillo, G.]{.refAuthor}[,
    Morgan, D.]{.refAuthor}[, and J. Urpalainen]{.refAuthor},
    [\"Conference Information Data Model for Centralized Conferencing
    (XCON)\"]{.refTitle}, [RFC 6501]{.seriesInfo}, [DOI
    10.17487/RFC6501]{.seriesInfo}, March 2012,
    \<<https://www.rfc-editor.org/info/rfc6501>\>.
:   

\[23\]
:   [Barnes, M.]{.refAuthor}[, Boulton, C.]{.refAuthor}[,
    Romano, S.]{.refAuthor}[, and H. Schulzrinne]{.refAuthor},
    [\"Centralized Conferencing Manipulation Protocol\"]{.refTitle},
    [RFC 6503]{.seriesInfo}, [DOI 10.17487/RFC6503]{.seriesInfo}, March
    2012, \<<https://www.rfc-editor.org/info/rfc6503>\>.
:   

\[24\]
:   [Barnes, M.]{.refAuthor}[, Miniero, L.]{.refAuthor}[,
    Presta, R.]{.refAuthor}[, and S P. Romano]{.refAuthor},
    [\"Centralized Conferencing Manipulation Protocol (CCMP) Call Flow
    Examples\"]{.refTitle}, [RFC 6504]{.seriesInfo}, [DOI
    10.17487/RFC6504]{.seriesInfo}, March 2012,
    \<<https://www.rfc-editor.org/info/rfc6504>\>.
:   

\[25\]
:   [Mogul, J.]{.refAuthor}[ and S. Deering]{.refAuthor}, [\"Path MTU
    discovery\"]{.refTitle}, [RFC 1191]{.seriesInfo}, [DOI
    10.17487/RFC1191]{.seriesInfo}, November 1990,
    \<<https://www.rfc-editor.org/info/rfc1191>\>.
:   

\[26\]
:   [McCann, J.]{.refAuthor}[, Deering, S.]{.refAuthor}[,
    Mogul, J.]{.refAuthor}[, and R. Hinden, Ed.]{.refAuthor}, [\"Path
    MTU Discovery for IP version 6\"]{.refTitle}, [STD 87]{.seriesInfo},
    [RFC 8201]{.seriesInfo}, [DOI 10.17487/RFC8201]{.seriesInfo}, July
    2017, \<<https://www.rfc-editor.org/info/rfc8201>\>.
:   

\[27\]
:   [Mathis, M.]{.refAuthor}[ and J. Heffner]{.refAuthor},
    [\"Packetization Layer Path MTU Discovery\"]{.refTitle}, [RFC
    4821]{.seriesInfo}, [DOI 10.17487/RFC4821]{.seriesInfo}, March 2007,
    \<<https://www.rfc-editor.org/info/rfc4821>\>.
:   

\[28\]
:   [Fischl, J.]{.refAuthor}[, Tschofenig, H.]{.refAuthor}[, and E.
    Rescorla]{.refAuthor}, [\"Framework for Establishing a Secure
    Real-time Transport Protocol (SRTP) Security Context Using Datagram
    Transport Layer Security (DTLS)\"]{.refTitle}, [RFC
    5763]{.seriesInfo}, [DOI 10.17487/RFC5763]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5763>\>.
:   

\[29\]
:   [Tuexen, M.]{.refAuthor}[ and R. Stewart]{.refAuthor}, [\"UDP
    Encapsulation of Stream Control Transmission Protocol (SCTP) Packets
    for End-Host to End-Host Communication\"]{.refTitle}, [RFC
    6951]{.seriesInfo}, [DOI 10.17487/RFC6951]{.seriesInfo}, May 2013,
    \<<https://www.rfc-editor.org/info/rfc6951>\>.
:   

\[30\]
:   [Sheffer, Y.]{.refAuthor}[, Holz, R.]{.refAuthor}[, and P.
    Saint-Andre]{.refAuthor}, [\"Recommendations for Secure Use of
    Transport Layer Security (TLS) and Datagram Transport Layer Security
    (DTLS)\"]{.refTitle}, [BCP 195]{.seriesInfo}, [RFC
    7525]{.seriesInfo}, [DOI 10.17487/RFC7525]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7525>\>.
:   

\[31\]
:   [Huitema, C.]{.refAuthor}, [\"Teredo: Tunneling IPv6 over UDP
    through Network Address Translations (NATs)\"]{.refTitle}, [RFC
    4380]{.seriesInfo}, [DOI 10.17487/RFC4380]{.seriesInfo}, February
    2006, \<<https://www.rfc-editor.org/info/rfc4380>\>.
:   

\[32\]
:   [Thaler, D.]{.refAuthor}, [\"Teredo Extensions\"]{.refTitle}, [RFC
    6081]{.seriesInfo}, [DOI 10.17487/RFC6081]{.seriesInfo}, January
    2011, \<<https://www.rfc-editor.org/info/rfc6081>\>.
:   

\[33\]
:   [Stewart, R., Ed.]{.refAuthor}, [\"Stream Control Transmission
    Protocol\"]{.refTitle}, [RFC 4960]{.seriesInfo}, [DOI
    10.17487/RFC4960]{.seriesInfo}, September 2007,
    \<<https://www.rfc-editor.org/info/rfc4960>\>.
:   

\[34\]
:   [Rosenberg, J.]{.refAuthor}[, Keranen, A.]{.refAuthor}[,
    Lowekamp, B. B.]{.refAuthor}[, and A. B. Roach]{.refAuthor}, [\"TCP
    Candidates with Interactive Connectivity Establishment
    (ICE)\"]{.refTitle}, [RFC 6544]{.seriesInfo}, [DOI
    10.17487/RFC6544]{.seriesInfo}, March 2012,
    \<<https://www.rfc-editor.org/info/rfc6544>\>.
:   

\[35\]
:   [Manner, J.]{.refAuthor}[, Varis, N.]{.refAuthor}[, and B.
    Briscoe]{.refAuthor}, [\"Generic UDP Tunnelling (GUT)\"]{.refTitle},
    [Work in Progress]{.refContent}, [Internet-Draft,
    draft-manner-tsvwg-gut-02]{.seriesInfo}, 12 July 2010,
    \<<https://tools.ietf.org/html/draft-manner-tsvwg-gut-02>\>.
:   

\[36\]
:   [Stucker, B.]{.refAuthor}[, Tschofenig, H.]{.refAuthor}[, and G.
    Salgueiro]{.refAuthor}, [\"Analysis of Middlebox Interactions for
    Signaling Protocol Communication along the Media Path\"]{.refTitle},
    [Work in Progress]{.refContent}, [Internet-Draft,
    draft-ietf-mmusic-media-path-middleboxes-07]{.seriesInfo}, 30 May
    2013,
    \<<https://tools.ietf.org/html/draft-ietf-mmusic-media-path-middleboxes-07>\>.
:   

\[37\]
:   [Guha, S.]{.refAuthor}[ and P. Francis]{.refAuthor},
    [\"Characterization and Measurement of TCP Traversal through NATs
    and Firewalls\"]{.refTitle}, 2005,
    \<<https://www.usenix.org/legacy/event/imc05/tech/full_papers/guha/guha.pdf>\>.
:   

\[38\]
:   [Ford, B.]{.refAuthor}[, Srisuresh, P.]{.refAuthor}[, and D.
    Kegel]{.refAuthor}, [\"Peer-to-Peer Communication Across Network
    Address Translators\"]{.refTitle}, April 2005,
    \<<https://www.usenix.org/legacy/events/usenix05/tech/general/full_papers/ford/ford.pdf>\>.
:   
:::
:::

::: {#app_unrelcallflow}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Example Call Flows for BFCP over an Unreliable Transport](#name-example-call-flows-for-bfcp){.section-name .selfRef} {#name-example-call-flows-for-bfcp}

With reference to [Section 4.1](#sec_overview_user){.xref}, the
following figures show representative call flows for requesting and
releasing a floor, and obtaining status information about a floor when
BFCP is deployed over an unreliable transport. The figures here show a
lossless interaction.[¶](#section-appendix.a-1){.pilcrow}

[]{#name-requesting-and-releasing-a-f}

::: {#ReqRelUnrelExample}
::: {#section-appendix.a-2.1 .artwork .art-text .alignLeft}
          Floor Participant                                 Floor Control
                                                               Server
                  |(1) FloorRequest                               |
                  |Transaction Responder: 0                       |
                  |Transaction ID: 123                            |
                  |User ID: 234                                   |
                  |FLOOR-ID: 543                                  |
                  |---------------------------------------------->|
                  |                                               |
                  |(2) FloorRequestStatus                         |
                  |Transaction Responder: 1                       |
                  |Transaction ID: 123                            |
                  |User ID: 234                                   |
                  |FLOOR-REQUEST-INFORMATION                      |
                  |      Floor Request ID: 789                    |
                  |      OVERALL-REQUEST-STATUS                   |
                  |              Request Status: Pending          |
                  |      FLOOR-REQUEST-STATUS                     |
                  |            Floor ID: 543                      |
                  |<----------------------------------------------|
                  |                                               |
                  |(3) FloorRequestStatus                         |
                  |Transaction Responder: 0                       |
                  |Transaction ID: 124                            |
                  |User ID: 234                                   |
                  |FLOOR-REQUEST-INFORMATION                      |
                  |      Floor Request ID: 789                    |
                  |      OVERALL-REQUEST-STATUS                   |
                  |              Request Status: Accepted         |
                  |              Queue Position: 1st              |
                  |      FLOOR-REQUEST-STATUS                     |
                  |            Floor ID: 543                      |
                  |<----------------------------------------------|
                  |                                               |
                  |(4) FloorRequestStatusAck                      |
                  |Transaction Responder: 1                       |
                  |Transaction ID: 124                            |
                  |User ID: 234                                   |
                  |---------------------------------------------->|
                  |                                               |
                  |(5) FloorRequestStatus                         |
                  |Transaction Responder: 0                       |
                  |Transaction ID: 125                            |
                  |User ID: 234                                   |
                  |FLOOR-REQUEST-INFORMATION                      |
                  |      Floor Request ID: 789                    |
                  |      OVERALL-REQUEST-STATUS                   |
                  |              Request Status: Granted          |
                  |      FLOOR-REQUEST-STATUS                     |
                  |            Floor ID: 543                      |
                  |<----------------------------------------------|
                  |                                               |
                  |(6) FloorRequestStatusAck                      |
                  |Transaction Responder: 1                       |
                  |Transaction ID: 125                            |
                  |User ID: 234                                   |
                  |---------------------------------------------->|
                  |                                               |
                  |(7) FloorRelease                               |
                  |Transaction Responder: 0                       |
                  |Transaction ID: 126                            |
                  |User ID: 234                                   |
                  |FLOOR-REQUEST-ID: 789                          |
                  |---------------------------------------------->|
                  |                                               |
                  |(8) FloorRequestStatus                         |
                  |Transaction Responder: 1                       |
                  |Transaction ID: 126                            |
                  |User ID: 234                                   |
                  |FLOOR-REQUEST-INFORMATION                      |
                  |      Floor Request ID: 789                    |
                  |      OVERALL-REQUEST-STATUS                   |
                  |              Request Status: Released         |
                  |      FLOOR-REQUEST-STATUS                     |
                  |            Floor ID: 543                      |
                  |<----------------------------------------------|
:::

[Figure 48](#figure-48){.selfRef}: [Requesting and releasing a
floor](#name-requesting-and-releasing-a-f){.selfRef}
:::

Note that in [Figure 48](#ReqRelUnrelExample){.xref}, the
FloorRequestStatus message from the floor control server to the floor
participant is a transaction-closing message as a response to the
client-initiated transaction with Transaction ID 126. As such, it is not
followed by a FloorRequestStatusAck message from the floor participant
to the floor control server.[¶](#section-appendix.a-3){.pilcrow}

[]{#name-obtaining-status-information}

::: {#StatusUnrelExample}
::: {#section-appendix.a-4.1 .artwork .art-text .alignLeft}
          Floor Participant                                 Floor Control
                                                               Server
                  |(1) FloorQuery                                 |
                  |Transaction Responder: 0                       |
                  |Transaction ID: 257                            |
                  |User ID: 234                                   |
                  |FLOOR-ID: 543                                  |
                  |---------------------------------------------->|
                  |                                               |
                  |(2) FloorStatus                                |
                  |Transaction Responder: 1                       |
                  |Transaction ID: 257                            |
                  |User ID: 234                                   |
                  |FLOOR-ID:543                                   |
                  |FLOOR-REQUEST-INFORMATION                      |
                  |      Floor Request ID: 764                    |
                  |      OVERALL-REQUEST-STATUS                   |
                  |              Request Status: Accepted         |
                  |              Queue Position: 1st              |
                  |      FLOOR-REQUEST-STATUS                     |
                  |            Floor ID: 543                      |
                  |      BENEFICIARY-INFORMATION                  |
                  |                  Beneficiary ID: 124          |
                  |FLOOR-REQUEST-INFORMATION                      |
                  |      Floor Request ID: 635                    |
                  |      OVERALL-REQUEST-STATUS                   |
                  |              Request Status: Accepted         |
                  |              Queue Position: 2nd              |
                  |      FLOOR-REQUEST-STATUS                     |
                  |            Floor ID: 543                      |
                  |      BENEFICIARY-INFORMATION                  |
                  |                  Beneficiary ID: 154          |
                  |<----------------------------------------------|
                  |                                               |
                  |(3) FloorStatus                                |
                  |Transaction Responder: 0                       |
                  |Transaction ID: 258                            |
                  |User ID: 234                                   |
                  |FLOOR-ID:543                                   |
                  |FLOOR-REQUEST-INFORMATION                      |
                  |      Floor Request ID: 764                    |
                  |      OVERALL-REQUEST-STATUS                   |
                  |              Request Status: Granted          |
                  |      FLOOR-REQUEST-STATUS                     |
                  |            Floor ID: 543                      |
                  |      BENEFICIARY-INFORMATION                  |
                  |                  Beneficiary ID: 124          |
                  |FLOOR-REQUEST-INFORMATION                      |
                  |      Floor Request ID: 635                    |
                  |      OVERALL-REQUEST-STATUS                   |
                  |              Request Status: Accepted         |
                  |              Queue Position: 1st              |
                  |      FLOOR-REQUEST-STATUS                     |
                  |            Floor ID: 543                      |
                  |      BENEFICIARY-INFORMATION                  |
                  |                  Beneficiary ID: 154          |
                  |<----------------------------------------------|
                  |                                               |
                  |(4) FloorStatusAck                             |
                  |Transaction Responder: 1                       |
                  |Transaction ID: 258                            |
                  |User ID: 234                                   |
                  |---------------------------------------------->|
                  |                                               |
                  |(5) FloorStatus                                |
                  |Transaction Responder: 0                       |
                  |Transaction ID: 259                            |
                  |User ID: 234                                   |
                  |FLOOR-ID:543                                   |
                  |FLOOR-REQUEST-INFORMATION                      |
                  |      Floor Request ID: 635                    |
                  |      OVERALL-REQUEST-STATUS                   |
                  |              Request Status: Granted          |
                  |      FLOOR-REQUEST-STATUS                     |
                  |            Floor ID: 543                      |
                  |      BENEFICIARY-INFORMATION                  |
                  |                  Beneficiary ID: 154          |
                  |<----------------------------------------------|
                  |                                               |
                  |(6) FloorStatusAck                             |
                  |Transaction Responder: 1                       |
                  |Transaction ID: 259                            |
                  |User ID: 234                                   |
                  |---------------------------------------------->|
:::

[Figure 49](#figure-49){.selfRef}: [Obtaining status information about a
floor](#name-obtaining-status-information){.selfRef}
:::
:::
:::

::: {#app_motivation}
::: {#section-appendix.b .section}
## [Appendix B.](#section-appendix.b){.section-number .selfRef} [Motivation for Supporting an Unreliable Transport](#name-motivation-for-supporting-a){.section-name .selfRef} {#name-motivation-for-supporting-a}

This appendix is provided as an aid to understand the background and
rationale for adding support for unreliable
transport.[¶](#section-appendix.b-1){.pilcrow}

::: {#motivation}
::: {#section-b.1 .section}
## [B.1.](#section-b.1){.section-number .selfRef} [Motivation](#name-motivation){.section-name .selfRef} {#name-motivation}

In existing video conferencing deployments, BFCP is used to manage the
floor for the content sharing associated with the conference. For
peer-to-peer scenarios, including business-to-business conferences and
point-to-point conferences in general, it is frequently the case that
one or both endpoints exist behind a NAT. BFCP roles are negotiated in
the offer/answer exchange as specified in \[[12](#RFC8856){.xref}\],
resulting in one endpoint being responsible for opening the TCP
connection used for the BFCP communication.[¶](#section-b.1-1){.pilcrow}

[]{#name-use-case}

::: {#use_case}
::: {#section-b.1-2.1 .artwork .art-text .alignCenter}
                 +---------+
                 | Network |
                 +---------+
          +-----+ /       \ +-----+
          | NAT |/         \| NAT |
          +-----+           +-----+
    +----+ /                     \ +----+
    |BFCP|/                       \|BFCP|
    | UA |                         | UA |
    +----+                         +----+
:::

[Figure 50](#figure-50){.selfRef}: [Use case](#name-use-case){.selfRef}
:::

The communication session between the video conferencing endpoints
typically consists of a number of RTP over UDP media streams for audio
and video and a BFCP connection for floor control. Existing deployments
are most common in, but not limited to, enterprise networks. In existing
deployments, NAT traversal for the RTP streams works using ICE and/or
other methods, including those described in
\[[36](#I-D.ietf-mmusic-media-path-middleboxes){.xref}\].[¶](#section-b.1-3){.pilcrow}

When enhancing an existing SIP-based video conferencing deployment with
support for content sharing, the BFCP connection often poses a problem.
The reasons for this fall into two general classes. First, there may be
a strong preference for UDP-based signaling in general. On high-capacity
endpoints (e.g., Public Switched Telephone Network (PSTN) gateways or
SIP/H.323 inter-working gateways), TCP can suffer from head-of-line
blocking, and it uses many kernel buffers. Network operators view UDP as
a way to avoid both of these. Second, the establishment and traversal of
the TCP connection involving ephemeral ports, as is typically the case
with BFCP over TCP, can be problematic, as described in [Appendix
A](https://www.rfc-editor.org/rfc/rfc6544#appendix-A){.relref} of
\[[34](#RFC6544){.xref}\]. A broad study of NAT behavior and
peer-to-peer TCP establishment for a comprehensive set of TCP NAT
traversal techniques over a wide range of commercial NAT products
concluded that it was not possible to establish a TCP connection in 11%
of the cases \[[37](#IMC05){.xref}\]. The results are worse when
focusing on enterprise NATs. A study of hole-punching as a NAT traversal
technique across a wide variety of deployed NATs reported consistently
higher success rates when using UDP than when using TCP
\[[38](#P2PNAT){.xref}\].[¶](#section-b.1-4){.pilcrow}

It is worth noting that BFCP over UDP is already being used in real
deployments, underlining the necessity to specify a common way to
exchange BFCP messages where TCP is not appropriate, to avoid a
situation where multiple different and non-interoperable implementations
would coexist in the market. The purpose of this document is to extend
the standard specification to support unreliable transport in order to
facilitate complete interoperability between
implementations.[¶](#section-b.1-5){.pilcrow}

::: {#alternatives}
::: {#section-b.1.1 .section}
### [B.1.1.](#section-b.1.1){.section-number .selfRef} [Alternatives Considered](#name-alternatives-considered){.section-name .selfRef} {#name-alternatives-considered}

In selecting the approach of defining UDP as an alternate transport for
BFCP, several alternatives were considered and explored to some degree.
Each of these is discussed briefly in the following subsections. In
summary, while the alternatives that were not chosen work in a number of
scenarios, they are not sufficient, in and of themselves, to address the
use case targeted by this document. The last alternative, presented in
[Appendix B.1.1.7](#thisextension){.xref}, was selected and is specified
in this document.[¶](#section-b.1.1-1){.pilcrow}

It is also worth noting that the IETF Transport Area was asked for a way
to tunnel TCP over UDP, but at that point there was no consensus on how
to achieve that.[¶](#section-b.1.1-2){.pilcrow}

::: {#ice_tcp}
::: {#section-b.1.1.1 .section}
#### [B.1.1.1.](#section-b.1.1.1){.section-number .selfRef} [ICE TCP](#name-ice-tcp){.section-name .selfRef} {#name-ice-tcp}

ICE TCP \[[34](#RFC6544){.xref}\] extends ICE to TCP-based media,
including the ability to offer a mix of TCP- and UDP-based candidates
for a single stream. ICE TCP has, in general, a lower success
probability for enabling TCP connectivity without a relay if both of the
hosts are behind a NAT (see [Appendix
A](https://www.rfc-editor.org/rfc/rfc6544#appendix-A){.relref} of
\[[34](#RFC6544){.xref}\]) than enabling UDP connectivity in the same
scenarios. The happens because many of the currently deployed NATs in
video conferencing networks do not support the flow of TCP handshake
packets seen in the case of TCP simultaneous-open, either because they
do not allow incoming TCP SYN packets from an address to which a SYN
packet has been sent recently, or because they do not properly process
the subsequent SYNACK. Implementing various techniques advocated for
candidate collection in \[[34](#RFC6544){.xref}\] should increase the
success probability, but many of these techniques require support from
some network elements (e.g., from the NATs). Such support is not common
in enterprise NATs.[¶](#section-b.1.1.1-1){.pilcrow}
:::
:::

::: {#teredo}
::: {#section-b.1.1.2 .section}
#### [B.1.1.2.](#section-b.1.1.2){.section-number .selfRef} [Teredo](#name-teredo){.section-name .selfRef} {#name-teredo}

Teredo \[[31](#RFC4380){.xref}\] enables nodes located behind one or
more IPv4 NATs to obtain IPv6 connectivity by tunneling packets over
UDP. Teredo extensions \[[32](#RFC6081){.xref}\] provide additional
capabilities to Teredo, including support for more types of NATs and
support for more efficient
communication.[¶](#section-b.1.1.2-1){.pilcrow}

As defined, Teredo could be used to make BFCP work for the video
conferencing use cases addressed in this document. However, running the
service requires the help of \"Teredo servers\" and \"Teredo relays\"
\[[31](#RFC4380){.xref}\]. These servers and relays generally do not
exist in current video conferencing deployments. It also requires IPv6
awareness on the endpoints. It should also be noted that ICMP6, as used
with Teredo to complete an initial protocol exchange and confirm that
the appropriate NAT bindings have been set up, is not a conventional
feature of IPv4 or even IPv6, and some currently deployed IPv6 firewalls
discard ICMP messages. As these networks continue to evolve and tackle
the transaction to IPv6, Teredo servers and relays may be deployed,
making Teredo available as a suitable alternative to BFCP over
UDP.[¶](#section-b.1.1.2-2){.pilcrow}
:::
:::

::: {#gut}
::: {#section-b.1.1.3 .section}
#### [B.1.1.3.](#section-b.1.1.3){.section-number .selfRef} [GUT](#name-gut){.section-name .selfRef} {#name-gut}

GUT \[[35](#I-D.manner-tsvwg-gut){.xref}\] attempts to facilitate
tunneling over UDP by encapsulating the native transport protocol and
its payload (in general the whole IP payload) within a UDP packet
destined to the well-known port GUT_P. Unfortunately, it requires
user-space TCP, for which there is not a readily available
implementation, and creating one is a large project in itself. This
document has expired, and its future is still unclear as it has not yet
been adopted by a working group.[¶](#section-b.1.1.3-1){.pilcrow}
:::
:::

::: {#upnp_igd}
::: {#section-b.1.1.4 .section}
#### [B.1.1.4.](#section-b.1.1.4){.section-number .selfRef} [UPnP IGD](#name-upnp-igd){.section-name .selfRef} {#name-upnp-igd}

Universal Plug and Play Internet Gateway Devices (UPnP IGD) sit on the
edge of the network, providing connectivity to the Internet for
computers internal to the LAN, but do not allow Internet devices to
connect to computers on the internal LAN. IGDs enable a computer on an
internal LAN to create port mappings on their NAT, through which hosts
on the Internet can send data that will be forwarded to the computer on
the internal LAN. IGDs may be self-contained hardware devices or may be
software components provided within an operating
system.[¶](#section-b.1.1.4-1){.pilcrow}

In considering UPnP IGD, several issues exist. Not all NATs support
UPnP, and many that do support it are configured with it turned off by
default. NATs are often multilayered, and UPnP does not work well with
such NATs. For example, a typical DSL modem acts as a NAT, and the user
plugs in a wireless access point behind that, which adds another layer
of NAT. The client can discover the first layer of NAT using multicast,
but it is harder to figure out how to discover and control NATs in the
next layer up.[¶](#section-b.1.1.4-2){.pilcrow}
:::
:::

::: {#nat_pmp}
::: {#section-b.1.1.5 .section}
#### [B.1.1.5.](#section-b.1.1.5){.section-number .selfRef} [NAT PMP](#name-nat-pmp){.section-name .selfRef} {#name-nat-pmp}

The NAT Port Mapping Protocol (NAT PMP) allows a computer in a private
network (behind a NAT router) to automatically configure the router to
allow parties outside the private network to contact it. NAT PMP runs
over UDP. It essentially automates the process of port forwarding.
Included in the protocol is a method for retrieving the public IP
address of a NAT gateway, thus allowing a client to make this public IP
address and port number known to peers that may wish to communicate with
it.[¶](#section-b.1.1.5-1){.pilcrow}

Many NATs do not support PMP. In those that do support it, it has
similar issues with negotiation of multilayer NATs as UPnP. Video
conferencing is used extensively in enterprise networks, and NAT PMP is
not generally available in enterprise-class
routers.[¶](#section-b.1.1.5-2){.pilcrow}
:::
:::

::: {#sctp_udp}
::: {#section-b.1.1.6 .section}
#### [B.1.1.6.](#section-b.1.1.6){.section-number .selfRef} [SCTP](#name-sctp){.section-name .selfRef} {#name-sctp}

It would be quite straightforward to specify a BFCP binding for Stream
Control Transmission Protocol (SCTP) \[[33](#RFC4960){.xref}\], and then
tunnel SCTP over UDP in the use case described in [Appendix
B.1](#motivation){.xref}. SCTP is gaining some momentum currently. There
was ongoing discussion in the RTCWeb Working Group regarding this
approach, which resulted in \[[29](#RFC6951){.xref}\]. However, this
approach to tunneling over UDP was not mature enough when considered and
was not even fully specified.[¶](#section-b.1.1.6-1){.pilcrow}
:::
:::

::: {#thisextension}
::: {#section-b.1.1.7 .section}
#### [B.1.1.7.](#section-b.1.1.7){.section-number .selfRef} [BFCP over UDP Transport](#name-bfcp-over-udp-transport){.section-name .selfRef} {#name-bfcp-over-udp-transport}

To overcome the problems with establishing TCP flows between BFCP
entities, an alternative is to define UDP as an alternate transport for
BFCP, leveraging the same mechanisms in place for the RTP over UDP media
streams for the BFCP communication. When using UDP as the transport,
following the guidelines provided in \[[15](#RFC8085){.xref}\] is
recommended.[¶](#section-b.1.1.7-1){.pilcrow}

Minor changes to the transaction model have been introduced in that all
requests now have an appropriate response to complete the transaction.
The requests are sent with a retransmission timer associated with the
response to achieve reliability. This alternative does not change the
semantics of BFCP. It permits UDP as an alternate
transport.[¶](#section-b.1.1.7-2){.pilcrow}

Existing implementations, in the spirit of the approach detailed in
earlier draft versions of this document, have demonstrated that this
approach is feasible. Initial compatibility among implementations has
been achieved at previous interoperability events. The authors view this
extension as a pragmatic solution to an existing deployment challenge.
This is the chosen approach, and the extensions are specified in this
document.[¶](#section-b.1.1.7-3){.pilcrow}
:::
:::
:::
:::
:::
:::
:::
:::

::: {#sec_acks}
::: {#section-appendix.c .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

The XCON Working Group chairs, [Adam Roach]{.contact-name} and [Alan
Johnston]{.contact-name}, provided useful ideas for RFC 4582
\[[3](#RFC4582){.xref}\]. Additionally, [Xiaotao Wu]{.contact-name},
[Paul Kyzivat]{.contact-name}, [Jonathan Rosenberg]{.contact-name},
[Miguel A. Garcia-Martin]{.contact-name}, [Mary Barnes]{.contact-name},
[Ben Campbell]{.contact-name}, [Dave Morgan]{.contact-name}, and [Oscar
Novo]{.contact-name} provided useful comments during the work with RFC
4582. The authors also acknowledge contributions to the revision of BFCP
for use over an unreliable transport from [Geir Arne
Sandbakken]{.contact-name} who had the initial idea, [Alfred
E. Heggestad]{.contact-name}, [Trond G. Andersen]{.contact-name},
[Gonzalo Camarillo]{.contact-name}, [Roni Even]{.contact-name}, [Lorenzo
Miniero]{.contact-name}, [Jörg Ott]{.contact-name}, [Eoin
McLeod]{.contact-name}, [Mark K. Thompson]{.contact-name}, [Hadriel
Kaplan]{.contact-name}, [Dan Wing]{.contact-name}, [Cullen
Jennings]{.contact-name}, [David Benham]{.contact-name}, [Nivedita
Melinkeri]{.contact-name}, [Woo Johnman]{.contact-name}, [Vijaya
Mandava]{.contact-name}, and [Alan Ford]{.contact-name}. In the final
phase, [Ernst Horvath]{.contact-name} did a thorough review, revealing
issues that needed clarification and changes. Useful and important final
reviews were done by [Mary Barnes]{.contact-name}. [Paul
Jones]{.contact-name} helped tremendously as editor for changes
addressing IESG review comments.[¶](#section-appendix.c-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.d .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Gonzalo Camarillo]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Ericsson]{.org}
:::

::: {.left dir="auto"}
[Hirsalantie 11]{.street-address}
:::

::: {.left dir="auto"}
FI-[02420]{.postal-code} [Jorvas]{.locality}
:::

::: {.left dir="auto"}
[Finland]{.country-name}
:::

::: email
Email: <gonzalo.camarillo@ericsson.com>
:::

::: {.left dir="auto"}
[Keith Drage]{.fn .nameRole}
:::

::: email
Email: <drageke@ntlworld.com>
:::

::: {.left dir="auto"}
[Tom Kristensen]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Jotron AS]{.org}
:::

::: {.left dir="auto"}
[Ringdalskogen 8]{.street-address}
:::

::: {.left dir="auto"}
[3270]{.postal-code} [Larvik]{.locality}
:::

::: {.left dir="auto"}
[Norway]{.country-name}
:::

::: email
Email: [tom.kristensen\@jotron.com,
tomkri\@ifi.uio.no](mailto:tom.kristensen@jotron.com,%20tomkri@ifi.uio.no){.email}
:::

::: {.left dir="auto"}
[Jörg Ott]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Technical University Munich]{.org}
:::

::: {.left dir="auto"}
[Boltzmannstrasse 3]{.street-address}
:::

::: {.left dir="auto"}
[85748]{.postal-code} [Garching]{.locality}
:::

::: {.left dir="auto"}
[Germany]{.country-name}
:::

::: email
Email: <ott@in.tum.de>
:::

::: {.left dir="auto"}
[Charles Eckel]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Cisco]{.org}
:::

::: {.left dir="auto"}
[707 Tasman Drive]{.street-address}
:::

::: {.left dir="auto"}
[Milpitas]{.locality}, [California]{.region} [95035]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <eckelcu@cisco.com>
:::
:::
:::
