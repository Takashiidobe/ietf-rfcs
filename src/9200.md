  RFC 9200        ACE-OAuth         August 2022
  --------------- ----------------- -------------
  Seitz, et al.   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9200](https://www.rfc-editor.org/rfc/rfc9200){.eref}

Category:
:   Standards Track

Published:
:   August 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    L. Seitz
    :::

    ::: org
    Combitech
    :::
    :::

    ::: author
    ::: author-name
    G. Selander
    :::

    ::: org
    Ericsson
    :::
    :::

    ::: author
    ::: author-name
    E. Wahlstroem
    :::
    :::

    ::: author
    ::: author-name
    S. Erdtman
    :::

    ::: org
    Spotify AB
    :::
    :::

    ::: author
    ::: author-name
    H. Tschofenig
    :::

    ::: org
    Arm Ltd.
    :::
    :::
:::

# RFC 9200 {#rfcnum}

# Authentication and Authorization for Constrained Environments Using the OAuth 2.0 Framework (ACE-OAuth) {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This specification defines a framework for authentication and
authorization in Internet of Things (IoT) environments called ACE‑OAuth.
The framework is based on a set of building blocks including OAuth 2.0
and the Constrained Application Protocol (CoAP), thus transforming a
well-known and widely used authorization solution into a form suitable
for IoT devices. Existing specifications are used where possible, but
extensions are added and profiles are defined to better serve the IoT
use cases.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9200>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Overview](#name-overview){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [OAuth 2.0](#name-oauth-20){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [CoAP](#name-coap){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Protocol
    Interactions](#name-protocol-interactions){.xref}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Framework](#name-framework){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Discovering Authorization
        Servers](#name-discovering-authorization-s){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Unauthorized Resource Request
        Message](#name-unauthorized-resource-reque){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [AS Request Creation
        Hints](#name-as-request-creation-hints){.xref}

        -   ::: {#section-toc.1-1.5.2.3.2.1}
            [5.3.1](#section-5.3.1){.xref}.  [The Client-Nonce
            Parameter](#name-the-client-nonce-parameter){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [Authorization
        Grants](#name-authorization-grants){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [Client
        Credentials](#name-client-credentials){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.6}
        [5.6](#section-5.6){.xref}.  [AS
        Authentication](#name-as-authentication){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.7}
        [5.7](#section-5.7){.xref}.  [The Authorization
        Endpoint](#name-the-authorization-endpoint){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.8}
        [5.8](#section-5.8){.xref}.  [The Token
        Endpoint](#name-the-token-endpoint){.xref}

        -   ::: {#section-toc.1-1.5.2.8.2.1}
            [5.8.1](#section-5.8.1){.xref}.  [Client-to-AS
            Request](#name-client-to-as-request){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.8.2.2}
            [5.8.2](#section-5.8.2){.xref}.  [AS-to-Client
            Response](#name-as-to-client-response){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.8.2.3}
            [5.8.3](#section-5.8.3){.xref}.  [Error
            Response](#name-error-response){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.8.2.4}
            [5.8.4](#section-5.8.4){.xref}.  [Request and Response
            Parameters](#name-request-and-response-parame){.xref}

            -   ::: {#section-toc.1-1.5.2.8.2.4.2.1}
                [5.8.4.1](#section-5.8.4.1){.xref}.  [Grant
                Type](#name-grant-type){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.8.2.4.2.2}
                [5.8.4.2](#section-5.8.4.2){.xref}.  [Token
                Type](#name-token-type){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.8.2.4.2.3}
                [5.8.4.3](#section-5.8.4.3){.xref}.  [Profile](#name-profile){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.8.2.4.2.4}
                [5.8.4.4](#section-5.8.4.4){.xref}.  [Client-Nonce](#name-client-nonce){.xref}
                :::
            :::

        -   ::: {#section-toc.1-1.5.2.8.2.5}
            [5.8.5](#section-5.8.5){.xref}.  [Mapping Parameters to
            CBOR](#name-mapping-parameters-to-cbor){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.9}
        [5.9](#section-5.9){.xref}.  [The Introspection
        Endpoint](#name-the-introspection-endpoint){.xref}

        -   ::: {#section-toc.1-1.5.2.9.2.1}
            [5.9.1](#section-5.9.1){.xref}.  [Introspection
            Request](#name-introspection-request){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.9.2.2}
            [5.9.2](#section-5.9.2){.xref}.  [Introspection
            Response](#name-introspection-response){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.9.2.3}
            [5.9.3](#section-5.9.3){.xref}.  [Error
            Response](#name-error-response-2){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.9.2.4}
            [5.9.4](#section-5.9.4){.xref}.  [Mapping Introspection
            Parameters to
            CBOR](#name-mapping-introspection-param){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.10}
        [5.10](#section-5.10){.xref}. [The Access
        Token](#name-the-access-token){.xref}

        -   ::: {#section-toc.1-1.5.2.10.2.1}
            [5.10.1](#section-5.10.1){.xref}.  [The Authorization
            Information
            Endpoint](#name-the-authorization-informati){.xref}

            -   ::: {#section-toc.1-1.5.2.10.2.1.2.1}
                [5.10.1.1](#section-5.10.1.1){.xref}.  [Verifying an
                Access Token](#name-verifying-an-access-token){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.10.2.1.2.2}
                [5.10.1.2](#section-5.10.1.2){.xref}.  [Protecting the
                Authorization Information
                Endpoint](#name-protecting-the-authorizatio){.xref}
                :::
            :::

        -   ::: {#section-toc.1-1.5.2.10.2.2}
            [5.10.2](#section-5.10.2){.xref}.  [Client Requests to the
            RS](#name-client-requests-to-the-rs){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.10.2.3}
            [5.10.3](#section-5.10.3){.xref}.  [Token
            Expiration](#name-token-expiration){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.10.2.4}
            [5.10.4](#section-5.10.4){.xref}.  [Key
            Expiration](#name-key-expiration){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Protecting
        Tokens](#name-protecting-tokens){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Communication
        Security](#name-communication-security){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Long-Term
        Credentials](#name-long-term-credentials){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [Unprotected AS Request Creation
        Hints](#name-unprotected-as-request-crea){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.5}
        [6.5](#section-6.5){.xref}.  [Minimal Security Requirements for
        Communication](#name-minimal-security-requiremen){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.6}
        [6.6](#section-6.6){.xref}.  [Token Freshness and
        Expiration](#name-token-freshness-and-expirat){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.7}
        [6.7](#section-6.7){.xref}.  [Combining
        Profiles](#name-combining-profiles){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.8}
        [6.8](#section-6.8){.xref}.  [Unprotected
        Information](#name-unprotected-information){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.9}
        [6.9](#section-6.9){.xref}.  [Identifying
        Audiences](#name-identifying-audiences){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.10}
        [6.10](#section-6.10){.xref}. [Denial of Service Against or with
        Introspection](#name-denial-of-service-against-o){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Privacy
    Considerations](#name-privacy-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [ACE Authorization Server Request
        Creation Hints](#name-ace-authorization-server-re){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [CoRE Resource
        Types](#name-core-resource-types){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [8.3](#section-8.3){.xref}.  [OAuth Extensions
        Errors](#name-oauth-extensions-errors){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.4}
        [8.4](#section-8.4){.xref}.  [OAuth Error Code CBOR
        Mappings](#name-oauth-error-code-cbor-mappi){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.5}
        [8.5](#section-8.5){.xref}.  [OAuth Grant Type CBOR
        Mappings](#name-oauth-grant-type-cbor-mappi){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.6}
        [8.6](#section-8.6){.xref}.  [OAuth Access Token
        Types](#name-oauth-access-token-types){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.7}
        [8.7](#section-8.7){.xref}.  [OAuth Access Token Type CBOR
        Mappings](#name-oauth-access-token-type-cbo){.xref}

        -   ::: {#section-toc.1-1.8.2.7.2.1}
            [8.7.1](#section-8.7.1){.xref}.  [Initial Registry
            Contents](#name-initial-registry-contents){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.8.2.8}
        [8.8](#section-8.8){.xref}.  [ACE
        Profiles](#name-ace-profiles){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.9}
        [8.9](#section-8.9){.xref}.  [OAuth
        Parameters](#name-oauth-parameters){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.10}
        [8.10](#section-8.10){.xref}. [OAuth Parameters CBOR
        Mappings](#name-oauth-parameters-cbor-mappi){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.11}
        [8.11](#section-8.11){.xref}. [OAuth Introspection Response
        Parameters](#name-oauth-introspection-respons){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.12}
        [8.12](#section-8.12){.xref}. [OAuth Token Introspection
        Response CBOR
        Mappings](#name-oauth-token-introspection-r){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.13}
        [8.13](#section-8.13){.xref}. [JSON Web Token
        Claims](#name-json-web-token-claims){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.14}
        [8.14](#section-8.14){.xref}. [CBOR Web Token
        Claims](#name-cbor-web-token-claims){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.15}
        [8.15](#section-8.15){.xref}. [Media Type
        Registration](#name-media-type-registration){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.16}
        [8.16](#section-8.16){.xref}. [CoAP
        Content-Formats](#name-coap-content-formats){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.17}
        [8.17](#section-8.17){.xref}. [Expert Review
        Instructions](#name-expert-review-instructions){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [Appendix A](#appendix-A){.xref}.  [Design
    Justification](#name-design-justification){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [Appendix B](#appendix-B){.xref}.  [Roles and
    Responsibilities](#name-roles-and-responsibilities){.xref}
    :::

-   ::: {#section-toc.1-1.12}
    [Appendix C](#appendix-C){.xref}.  [Requirements on
    Profiles](#name-requirements-on-profiles){.xref}
    :::

-   ::: {#section-toc.1-1.13}
    [Appendix D](#appendix-D){.xref}.  [Assumptions on AS Knowledge
    about the C and RS](#name-assumptions-on-as-knowledge){.xref}
    :::

-   ::: {#section-toc.1-1.14}
    [Appendix E](#appendix-E){.xref}.  [Differences to OAuth
    2.0](#name-differences-to-oauth-20){.xref}
    :::

-   ::: {#section-toc.1-1.15}
    [Appendix F](#appendix-F){.xref}.  [Deployment
    Examples](#name-deployment-examples){.xref}

    -   ::: {#section-toc.1-1.15.2.1}
        [F.1](#appendix-F.1){.xref}.  [Local Token
        Validation](#name-local-token-validation){.xref}
        :::

    -   ::: {#section-toc.1-1.15.2.2}
        [F.2](#appendix-F.2){.xref}.  [Introspection Aided Token
        Validation](#name-introspection-aided-token-v){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.16}
    [](#appendix-G){.xref}[Acknowledgments](#name-acknowledgments){.xref}
    :::

-   ::: {#section-toc.1-1.17}
    [](#appendix-H){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#intro}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Authorization is the process for granting approval to an entity to
access a generic resource \[[RFC4949](#RFC4949){.xref}\]. The
authorization task itself can best be described as granting access to a
requesting client for a resource hosted on a device, i.e., the resource
server (RS). This exchange is mediated by one or multiple authorization
servers (ASes). Managing authorization for a large number of devices and
users can be a complex task.[¶](#section-1-1){.pilcrow}

While prior work on authorization solutions for the Web and for the
mobile environment also applies to the Internet of Things (IoT)
environment, many IoT devices are constrained, for example, in terms of
processing capabilities, available memory, etc. For such devices, the
Constrained Application Protocol (CoAP) \[[RFC7252](#RFC7252){.xref}\]
can alleviate some resource concerns when used instead of HTTP to
implement the communication flows of this
specification.[¶](#section-1-2){.pilcrow}

[Appendix A](#constraints){.xref} gives an overview of the constraints
considered in this design, and a more detailed treatment of constraints
can be found in \[[RFC7228](#RFC7228){.xref}\]. This design aims to
accommodate different IoT deployments as well as a continuous range of
device and network capabilities. Taking energy consumption as an
example, at one end, there are energy-harvesting or battery-powered
devices that have a tight power budget; on the other end, there are
mains-powered devices; and all levels exist in
between.[¶](#section-1-3){.pilcrow}

Hence, IoT devices may be very different in terms of available
processing and message exchange capabilities, and there is a need to
support many different authorization use cases
\[[RFC7744](#RFC7744){.xref}\].[¶](#section-1-4){.pilcrow}

This specification describes a framework for Authentication and
Authorization for Constrained Environments (ACE) built on reuse of OAuth
2.0 \[[RFC6749](#RFC6749){.xref}\], thereby extending authorization to
Internet of Things devices. This specification contains the necessary
building blocks for adjusting OAuth 2.0 to IoT
environments.[¶](#section-1-5){.pilcrow}

Profiles of this framework are available in separate specifications,
such as \[[RFC9202](#RFC9202){.xref}\] or
\[[RFC9203](#RFC9203){.xref}\]. Such profiles may specify the use of the
framework for a specific security protocol and the underlying transports
for use in a specific deployment environment to improve
interoperability. Implementations may claim conformance with a specific
profile, whereby implementations utilizing the same profile
interoperate, while implementations of different profiles are not
expected to be interoperable. More powerful devices, such as mobile
phones and tablets, may implement multiple profiles and will therefore
be able to interact with a wider range of constrained devices.
Requirements on profiles are described at contextually appropriate
places throughout this specification and also summarized in [Appendix
C](#app_profileRequirements){.xref}.[¶](#section-1-6){.pilcrow}
:::
:::

::: {#terminology}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}

Certain security-related terms, such as \"authentication\",
\"authorization\", \"confidentiality\", \"(data) integrity\", \"message
authentication code\", and \"verify\", are taken from
\[[RFC4949](#RFC4949){.xref}\].[¶](#section-2-2){.pilcrow}

Since exchanges in this specification are described as RESTful protocol
interactions, HTTP \[[RFC9110](#RFC9110){.xref}\] offers useful
terminology. (Note that \"RESTful\" refers to the Representational State
Transfer (REST) architecture.)[¶](#section-2-3){.pilcrow}

Terminology for entities in the architecture is defined in OAuth 2.0
\[[RFC6749](#RFC6749){.xref}\], such as client (C), resource server
(RS), and authorization server (AS).[¶](#section-2-4){.pilcrow}

Note that the term \"endpoint\" is used here following its OAuth
definition, which is to denote resources, such as token and
introspection at the AS and authz-info at the RS (see [Section
5.10.1](#tokenAuthInfoEndpoint){.xref} for a definition of the
authz-info endpoint). The CoAP definition, which is \"\[a\]n entity
participating in the CoAP protocol\" \[[RFC7252](#RFC7252){.xref}\], is
not used in this specification.[¶](#section-2-5){.pilcrow}

The specification in this document is called the \"framework\" or \"ACE
framework\". When referring to \"profiles of this framework\", it refers
to additional specifications that define the use of this specification
with concrete transport and communication security protocols (e.g., CoAP
over DTLS).[¶](#section-2-6){.pilcrow}

The term \"Access Information\" is used for parameters, other than the
access token, provided to the client by the AS to enable it to access
the RS (e.g., public key of the RS or profile supported by
RS).[¶](#section-2-7){.pilcrow}

The term \"authorization information\" is used to denote all
information, including the claims of relevant access tokens, that an RS
uses to determine whether an access request should be
granted.[¶](#section-2-8){.pilcrow}

Throughout this document, examples for CBOR data items are expressed in
CBOR extended diagnostic notation as defined in [Section
8](https://www.rfc-editor.org/rfc/rfc8949#section-8){.relref} of
\[[RFC8949](#RFC8949){.xref}\] and [Appendix
G](https://www.rfc-editor.org/rfc/rfc8610#appendix-G){.relref} of
\[[RFC8610](#RFC8610){.xref}\] (\"diagnostic notation\"), unless noted
otherwise. We often use diagnostic notation comments to provide a
textual representation of the numeric parameter names and
values.[¶](#section-2-9){.pilcrow}
:::
:::

::: {#overview}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Overview](#name-overview){.section-name .selfRef} {#name-overview}

This specification defines the ACE framework for authorization in the
Internet of Things environment. It consists of a set of building
blocks.[¶](#section-3-1){.pilcrow}

The basic block is the OAuth 2.0 \[[RFC6749](#RFC6749){.xref}\]
framework, which enjoys widespread deployment. Many IoT devices can
support OAuth 2.0 without any additional extensions, but for certain
constrained settings, additional profiling is
needed.[¶](#section-3-2){.pilcrow}

Another building block is the lightweight web transfer protocol CoAP
\[[RFC7252](#RFC7252){.xref}\], for those communication environments
where HTTP is not appropriate. CoAP typically runs on top of UDP, which
further reduces overhead and message exchanges. While this specification
defines extensions for the use of OAuth over CoAP, other underlying
protocols are not prohibited from being supported in the future, such as
HTTP/2 \[[RFC9113](#RFC9113){.xref}\], Message Queuing Telemetry
Transport (MQTT) \[[MQTT5.0](#MQTT5.0){.xref}\], Bluetooth Low Energy
(BLE) \[[BLE](#BLE){.xref}\], and QUIC \[[RFC9000](#RFC9000){.xref}\].
Note that this document specifies protocol exchanges in terms of RESTful
verbs, such as GET and POST. Future profiles using protocols that do not
support these verbs [MUST]{.bcp14} specify how the corresponding
protocol messages are transmitted instead.[¶](#section-3-3){.pilcrow}

A third building block is the Concise Binary Object Representation
(CBOR) \[[RFC8949](#RFC8949){.xref}\], for encodings where JSON
\[[RFC8259](#RFC8259){.xref}\] is not sufficiently compact. CBOR is a
binary encoding designed for small code and message size. Self-contained
tokens and protocol message payloads are encoded in CBOR when CoAP is
used. When CoAP is not used, the use of CBOR remains
[RECOMMENDED]{.bcp14}.[¶](#section-3-4){.pilcrow}

A fourth building block is CBOR Object Signing and Encryption (COSE)
\[[RFC8152](#RFC8152){.xref}\], which enables object-level layer
security as an alternative or complement to transport layer security
(DTLS \[[RFC6347](#RFC6347){.xref}\] \[[RFC9147](#RFC9147){.xref}\] or
TLS \[[RFC8446](#RFC8446){.xref}\]). COSE is used to secure
self-contained tokens, such as proof-of-possession (PoP) tokens, which
are an extension to the OAuth bearer tokens. The default token format is
defined in CBOR Web Token (CWT) \[[RFC8392](#RFC8392){.xref}\].
Application-layer security for CoAP using COSE can be provided with
Object Security for Constrained RESTful Environments (OSCORE)
\[[RFC8613](#RFC8613){.xref}\].[¶](#section-3-5){.pilcrow}

With the building blocks listed above, solutions satisfying various IoT
device and network constraints are possible. A list of constraints is
described in detail in \[[RFC7228](#RFC7228){.xref}\], and a description
of how the building blocks mentioned above relate to the various
constraints can be found in [Appendix
A](#constraints){.xref}.[¶](#section-3-6){.pilcrow}

Luckily, not every IoT device suffers from all constraints.
Nevertheless, the ACE framework takes all these aspects into account and
allows several different deployment variants to coexist, rather than
mandating a one-size-fits-all solution. It is important to cover the
wide range of possible interworking use cases and the different
requirements from a security point of view. Once IoT deployments mature,
popular deployment variants will be documented in the form of ACE
profiles.[¶](#section-3-7){.pilcrow}

::: {#oauth2Overview}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [OAuth 2.0](#name-oauth-20){.section-name .selfRef} {#name-oauth-20}

The OAuth 2.0 authorization framework enables a client to obtain scoped
access to a resource with the permission of a resource owner.
Authorization information, or references to it, is passed between the
nodes using access tokens. These access tokens are issued to clients by
an authorization server with the approval of the resource owner. The
client uses the access token to access the protected resources hosted by
the resource server.[¶](#section-3.1-1){.pilcrow}

A number of OAuth 2.0 terms are used within this
specification:[¶](#section-3.1-2){.pilcrow}

[]{.break}

Access Tokens:

:   Access tokens are credentials needed to access protected resources.
    An access token is a data structure representing authorization
    permissions issued by the AS to the client. Access tokens are
    generated by the AS and consumed by the RS. The access token content
    is opaque to the client.[¶](#section-3.1-3.2.1){.pilcrow}

    Access tokens can have different formats and various methods of
    utilization (e.g., cryptographic properties) based on the security
    requirements of the given
    deployment.[¶](#section-3.1-3.2.2){.pilcrow}

:   

Introspection:
:   Introspection is a method for a resource server, or potentially a
    client, to query the authorization server for the active state and
    content of a received access token. This is particularly useful in
    those cases where the authorization decisions are very dynamic
    and/or where the received access token itself is an opaque
    reference, rather than a self-contained token. More information
    about introspection in OAuth 2.0 can be found in
    \[[RFC7662](#RFC7662){.xref}\].[¶](#section-3.1-3.4){.pilcrow}
:   

Refresh Tokens:

:   Refresh tokens are credentials used to obtain access tokens. Refresh
    tokens are issued to the client by the authorization server and are
    used to obtain a new access token when the current access token
    expires or to obtain additional access tokens with identical or
    narrower scope (such access tokens may have a shorter lifetime and
    fewer permissions than authorized by the resource owner). Issuing a
    refresh token is optional at the discretion of the authorization
    server. If the authorization server issues a refresh token, it is
    included when issuing an access token (i.e., step (B) in [Figure
    1](#fig_protocolFlow){.xref}).[¶](#section-3.1-3.6.1){.pilcrow}

    A refresh token in OAuth 2.0 is a string representing the
    authorization granted to the client by the resource owner. The
    string is usually opaque to the client. The token denotes an
    identifier used to retrieve the authorization information. Unlike
    access tokens, refresh tokens are intended for use only with
    authorization servers and are never sent to resource servers. In
    this framework, refresh tokens are encoded in binary instead of
    strings, if used.[¶](#section-3.1-3.6.2){.pilcrow}

:   

Proof-of-Possession Tokens:

:   A token may be bound to a cryptographic key, which is then used to
    bind the token to a request authorized by the token. Such tokens are
    called proof-of-possession tokens (or PoP
    tokens).[¶](#section-3.1-3.8.1){.pilcrow}

    The proof-of-possession security concept used here assumes that the
    AS acts as a trusted third party that binds keys to tokens. In the
    case of access tokens, these so-called PoP keys are then used by the
    client to demonstrate the possession of the secret to the RS when
    accessing the resource. The RS, when receiving an access token,
    needs to verify that the key used by the client matches the one
    bound to the access token. When this specification uses the term
    \"access token\", it is assumed to be a PoP access token unless
    specifically stated otherwise.[¶](#section-3.1-3.8.2){.pilcrow}

    The key bound to the token (the PoP key) may use either symmetric or
    asymmetric cryptography. The appropriate choice of the kind of
    cryptography depends on the constraints of the IoT devices as well
    as on the security requirements of the use
    case.[¶](#section-3.1-3.8.3){.pilcrow}

    []{.break}

    Symmetric PoP key:

    :   The AS generates a random, symmetric PoP key. The key is either
        stored to be returned on introspection calls or included in the
        token. Either the whole token or only the key [MUST]{.bcp14} be
        encrypted in the latter case. The PoP key is also returned to
        client together with the token, protected by the secure
        channel.[¶](#section-3.1-3.8.4.2.1){.pilcrow}

    :   

    Asymmetric PoP key:
    :   An asymmetric key pair is generated by the client and the public
        key is sent to the AS (if it does not already have knowledge of
        the client\'s public key). Information about the public key,
        which is the PoP key in this case, is either stored to be
        returned on introspection calls or included inside the token and
        sent back to the client. The resource server consuming the token
        can identify the public key from the information in the token,
        which allows the client to use the corresponding private key for
        the proof of possession.[¶](#section-3.1-3.8.4.4){.pilcrow}
    :   

    The token is either a simple reference or a structured information
    object (e.g., CWT \[[RFC8392](#RFC8392){.xref}\]) protected by a
    cryptographic wrapper (e.g., COSE \[[RFC8152](#RFC8152){.xref}\]).
    The choice of PoP key does not necessarily imply a specific
    credential type for the integrity protection of the
    token.[¶](#section-3.1-3.8.5){.pilcrow}

:   

Scopes and Permissions:

:   In OAuth 2.0, the client specifies the type of permissions it is
    seeking to obtain (via the `scope` parameter) in the access token
    request. In turn, the AS may use the `scope` response parameter to
    inform the client of the scope of the access token issued. As the
    client could be a constrained device as well, this specification
    defines the use of CBOR encoding (see [Section
    5](#oauthProfile){.xref}) for such requests and
    responses.[¶](#section-3.1-3.10.1){.pilcrow}

    The values of the `scope` parameter in OAuth 2.0 are expressed as a
    list of space-delimited, case-sensitive strings with a semantic that
    is well known to the AS and the RS. More details about the concept
    of scopes are found under [Section
    3.3](https://www.rfc-editor.org/rfc/rfc6749#section-3.3){.relref} of
    \[[RFC6749](#RFC6749){.xref}\].[¶](#section-3.1-3.10.2){.pilcrow}

:   

Claims:

:   Information carried in the access token or returned from
    introspection, called claims, is in the form of name-value pairs. An
    access token may, for example, include a claim identifying the AS
    that issued the token (via the `iss` claim) and what audience the
    access token is intended for (via the `aud` claim). The audience of
    an access token can be a specific resource, one resource, or many
    resource servers. The resource owner policies influence what claims
    are put into the access token by the authorization
    server.[¶](#section-3.1-3.12.1){.pilcrow}

    While the structure and encoding of the access token varies
    throughout deployments, a standardized format has been defined with
    the JSON Web Token (JWT) \[[RFC7519](#RFC7519){.xref}\], where
    claims are encoded as a JSON object. In
    \[[RFC8392](#RFC8392){.xref}\], the CBOR Web Token (CWT) has been
    defined as an equivalent format using CBOR
    encoding.[¶](#section-3.1-3.12.2){.pilcrow}

:   

Token and Introspection Endpoints:

:   The AS hosts the token endpoint that allows a client to request
    access tokens. The client makes a POST request to the token endpoint
    on the AS and receives the access token in the response (if the
    request was successful).[¶](#section-3.1-3.14.1){.pilcrow}

    In some deployments, a token introspection endpoint is provided by
    the AS, which can be used by the RS and potentially the client, if
    they need to request additional information regarding a received
    access token. The requesting entity makes a POST request to the
    introspection endpoint on the AS and receives information about the
    access token in the response. (See \"Introspection\"
    above.)[¶](#section-3.1-3.14.2){.pilcrow}

:   
:::
:::

::: {#coap}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [CoAP](#name-coap){.section-name .selfRef} {#name-coap}

CoAP is an application-layer protocol similar to HTTP but specifically
designed for constrained environments. CoAP typically uses
datagram-oriented transport, such as UDP, where reordering and loss of
packets can occur. A security solution needs to take the latter aspects
into account.[¶](#section-3.2-1){.pilcrow}

While HTTP uses headers and query strings to convey additional
information about a request, CoAP encodes such information into header
parameters called \'options\'.[¶](#section-3.2-2){.pilcrow}

CoAP supports application-layer fragmentation of the CoAP payloads
through block-wise transfers \[[RFC7959](#RFC7959){.xref}\]. However,
block-wise transfer does not increase the size limits of CoAP options;
therefore, data encoded in options has to be kept
small.[¶](#section-3.2-3){.pilcrow}

Transport layer security for CoAP can be provided by DTLS or TLS
\[[RFC6347](#RFC6347){.xref}\] \[[RFC8446](#RFC8446){.xref}\]
\[[RFC9147](#RFC9147){.xref}\]. CoAP defines a number of proxy
operations that require transport layer security to be terminated at the
proxy. One approach for protecting CoAP communication end-to-end through
proxies, and also to support security for CoAP over a different
transport in a uniform way, is to provide security at the application
layer using an object-based security mechanism, such as COSE
\[[RFC8152](#RFC8152){.xref}\].[¶](#section-3.2-4){.pilcrow}

One application of COSE is OSCORE \[[RFC8613](#RFC8613){.xref}\], which
provides end-to-end confidentiality, integrity and replay protection,
and a secure binding between CoAP request and response messages. In
OSCORE, the CoAP messages are wrapped in COSE objects and sent using
CoAP.[¶](#section-3.2-5){.pilcrow}

In this framework, the use of CoAP as replacement for HTTP is
[RECOMMENDED]{.bcp14} for use in constrained environments. For
communication security, this framework does not make an explicit
protocol recommendation, since the choice depends on the requirements of
the specific application. DTLS \[[RFC6347](#RFC6347){.xref}\]
\[[RFC9147](#RFC9147){.xref}\] and OSCORE \[[RFC8613](#RFC8613){.xref}\]
are mentioned as examples; other protocols fulfilling the requirements
from [Section 6.5](#minimalCommSecReq){.xref} are also
applicable.[¶](#section-3.2-6){.pilcrow}
:::
:::
:::
:::

::: {#specs}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Protocol Interactions](#name-protocol-interactions){.section-name .selfRef} {#name-protocol-interactions}

The ACE framework is based on the OAuth 2.0 protocol interactions using
the token endpoint and optionally the introspection endpoint. A client
obtains an access token, and optionally a refresh token, from an AS
using the token endpoint and subsequently presents the access token to
an RS to gain access to a protected resource. In most deployments, the
RS can process the access token locally; however, in some cases, the RS
may present it to the AS via the introspection endpoint to get fresh
information. These interactions are shown in [Figure
1](#fig_protocolFlow){.xref}. An overview of various OAuth concepts is
provided in [Section
3.1](#oauth2Overview){.xref}.[¶](#section-4-1){.pilcrow}

[]{#name-basic-protocol-flow}

::: {#fig_protocolFlow}
::: {#section-4-2.1 .alignLeft .art-text .artwork}
    +--------+                               +---------------+
    |        |---(A)-- Token Request ------->|               |
    |        |                               | Authorization |
    |        |<--(B)-- Access Token ---------|    Server     |
    |        |    + Access Information       |               |
    |        |    + Refresh Token (optional) +---------------+
    |        |                                      ^ |
    |        |            Introspection Request  (D)| |
    | Client |                         Response     | |(E)
    |        |            (optional exchange)       | |
    |        |                                      | v
    |        |                               +--------------+
    |        |---(C)-- Token + Request ----->|              |
    |        |                               |   Resource   |
    |        |<--(F)-- Protected Resource ---|    Server    |
    |        |                               |              |
    +--------+                               +--------------+
:::

[Figure 1](#figure-1){.selfRef}: [Basic Protocol
Flow](#name-basic-protocol-flow){.selfRef}
:::

[]{.break}

Requesting an Access Token (A):

:   The client makes an access token request to the token endpoint at
    the AS. This framework assumes the use of PoP access tokens (see
    [Section 3.1](#oauth2Overview){.xref} for a short description)
    wherein the AS binds a key to an access token. The client may
    include permissions it seeks to obtain and information about the
    credentials it wants to use for proof of possession (e.g.,
    symmetric/asymmetric cryptography or a reference to a specific key)
    of the access token.[¶](#section-4-3.2.1){.pilcrow}

:   

Access Token Response (B):

:   If the request from the client has been successfully verified,
    authenticated, and authorized, the AS returns an access token and
    optionally a refresh token. Note that only certain grant types
    support refresh tokens. The AS can also return additional
    parameters, referred to as \"Access Information\". In addition to
    the response parameters defined by OAuth 2.0 and the PoP access
    token extension, this framework defines parameters that can be used
    to inform the client about capabilities of the RS, e.g., the profile
    the RS supports. More information about these parameters can be
    found in [Section
    5.8.4](#tokenParams){.xref}.[¶](#section-4-3.4.1){.pilcrow}

:   

Resource Request (C):

:   The client interacts with the RS to request access to the protected
    resource and provides the access token. The protocol to use between
    the client and the RS is not restricted to CoAP. HTTP, HTTP/2
    \[[RFC9113](#RFC9113){.xref}\], QUIC \[[RFC9000](#RFC9000){.xref}\],
    MQTT \[[MQTT5.0](#MQTT5.0){.xref}\], Bluetooth Low Energy
    \[[BLE](#BLE){.xref}\], etc., are also viable
    candidates.[¶](#section-4-3.6.1){.pilcrow}

    Depending on the device limitations and the selected protocol, this
    exchange may be split up into two
    parts:[¶](#section-4-3.6.2){.pilcrow}

    []{.break}

    \(1\)
    :   the client sends the access token containing, or referencing,
        the authorization information to the RS that will be used for
        subsequent resource requests by the client,
        and[¶](#section-4-3.6.3.1){.pilcrow}
    :   

    \(2\)
    :   the client makes the resource access request using the
        communication security protocol and other Access Information
        obtained from the AS.[¶](#section-4-3.6.3.2){.pilcrow}
    :   

    The client and the RS mutually authenticate using the security
    protocol specified in the profile (see step (B)) and the keys
    obtained in the access token or the Access Information. The RS
    verifies that the token is integrity protected and originated by the
    AS. It then compares the claims contained in the access token with
    the resource request. If the RS is online, validation can be handed
    over to the AS using token introspection (see messages (D) and (E))
    over HTTP or CoAP.[¶](#section-4-3.6.4){.pilcrow}

:   

Token Introspection Request (D):

:   A resource server may be configured to introspect the access token
    by including it in a request to the introspection endpoint at that
    AS. Token introspection over CoAP is defined in [Section
    5.9](#introspectionEndpoint){.xref} and for HTTP in
    \[[RFC7662](#RFC7662){.xref}\].[¶](#section-4-3.8.1){.pilcrow}

    Note that token introspection is an optional step and can be omitted
    if the token is self-contained and the resource server is prepared
    to perform the token validation on its
    own.[¶](#section-4-3.8.2){.pilcrow}

:   

Token Introspection Response (E):

:   The AS validates the token and returns the most recent parameters,
    such as `scope`, `audience`, validity, etc., associated with it back
    to the RS. The RS then uses the received parameters to process the
    request to either accept or to deny
    it.[¶](#section-4-3.10.1){.pilcrow}

:   

Protected Resource (F):
:   If the request from the client is authorized, the RS fulfills the
    request and returns a response with the appropriate response code.
    The RS uses the dynamically established keys to protect the response
    according to the communication security protocol
    used.[¶](#section-4-3.12){.pilcrow}
:   

The OAuth 2.0 framework defines a number of \"protocol flows\" via grant
types, which have been extended further with extensions to OAuth 2.0
(such as \[[RFC7521](#RFC7521){.xref}\] and
\[[RFC8628](#RFC8628){.xref}\]). What grant type works best depends on
the usage scenario; \[[RFC7744](#RFC7744){.xref}\] describes many
different IoT use cases, but there are two grant types that cover a
majority of these scenarios, namely the authorization code grant
(described in [Section
4.1](https://www.rfc-editor.org/rfc/rfc6749#section-4.1){.relref} of
\[[RFC6749](#RFC6749){.xref}\]) and the client credentials grant
(described in [Section
4.4](https://www.rfc-editor.org/rfc/rfc6749#section-4.4){.relref} of
\[[RFC6749](#RFC6749){.xref}\]). The authorization code grant is a good
fit for use with apps running on smartphones and tablets that request
access to IoT devices, a common scenario in the smart home environment,
where users need to go through an authentication and authorization phase
(at least during the initial setup phase). The native apps guidelines
described in \[[RFC8252](#RFC8252){.xref}\] are applicable to this use
case. The client credentials grant is a good fit for use with IoT
devices where the OAuth client itself is constrained. In such a case,
the resource owner has prearranged access rights for the client with the
authorization server, which is often accomplished using a commissioning
tool.[¶](#section-4-4){.pilcrow}

The consent of the resource owner, for giving a client access to a
protected resource, can be provided dynamically as in the classical
OAuth flows, or it could be preconfigured by the resource owner as
authorization policies at the AS, which the AS evaluates when a token
request arrives. The resource owner and the requesting party (i.e.,
client owner) are not shown in [Figure
1](#fig_protocolFlow){.xref}.[¶](#section-4-5){.pilcrow}

This framework supports a wide variety of communication security
mechanisms between the ACE entities, such as the client, AS, and RS. It
is assumed that the client has been registered (also called enrolled or
onboarded) to an AS using a mechanism defined outside the scope of this
document. In practice, various techniques for onboarding have been used,
such as factory-based provisioning or the use of commissioning tools.
Regardless of the onboarding technique, this provisioning procedure
implies that the client and the AS exchange credentials and
configuration parameters. These credentials are used to mutually
authenticate each other and to protect messages exchanged between the
client and the AS.[¶](#section-4-6){.pilcrow}

It is also assumed that the RS has been registered with the AS,
potentially in a similar way as the client has been registered with the
AS. Established keying material between the AS and the RS allows the AS
to apply cryptographic protection to the access token to ensure that its
content cannot be modified and, if needed, that the content is
confidentiality protected. Confidentiality protection of the access
token content would be provided on top of confidentiality protection via
a communication security protocol.[¶](#section-4-7){.pilcrow}

The keying material necessary for establishing communication security
between the C and RS is dynamically established as part of the protocol
described in this document.[¶](#section-4-8){.pilcrow}

At the start of the protocol, there is an optional discovery step where
the client discovers the resource server and the resources this server
hosts. In this step, the client might also determine what permissions
are needed to access the protected resource. A generic procedure is
described in [Section 5.1](#asDiscovery){.xref}; profiles [MAY]{.bcp14}
define other procedures for discovery.[¶](#section-4-9){.pilcrow}

In Bluetooth Low Energy, for example, advertisements are broadcast by a
peripheral, including information about the primary services. In CoAP,
as a second example, a client can make a request to
\"/.well-known/core\" to obtain information about available resources,
which are returned in a standardized format, as described in
\[[RFC6690](#RFC6690){.xref}\].[¶](#section-4-10){.pilcrow}
:::
:::

::: {#oauthProfile}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Framework](#name-framework){.section-name .selfRef} {#name-framework}

The following sections detail the profiling and extensions of OAuth 2.0
for constrained environments, which constitutes the ACE
framework.[¶](#section-5-1){.pilcrow}

[]{.break}

Credential Provisioning

:   In constrained environments, it cannot be assumed that the client
    and the RS are part of a common key infrastructure. Therefore, the
    AS provisions credentials and associated information to allow mutual
    authentication between the client and the RS. The resulting security
    association between the client and the RS may then also be used to
    bind these credentials to the access tokens the client
    uses.[¶](#section-5-2.2.1){.pilcrow}

:   

Proof of Possession

:   The ACE framework, by default, implements proof of possession for
    access tokens, i.e., that the token holder can prove being a holder
    of the key bound to the token. The binding is provided by the `cnf`
    (confirmation) claim \[[RFC8747](#RFC8747){.xref}\], indicating what
    key is used for proof of possession. If a client needs to submit a
    new access token, e.g., to obtain additional access rights, they can
    request that the AS binds this token to the same key as the previous
    one.[¶](#section-5-2.4.1){.pilcrow}

:   

ACE Profiles
:   The client or RS may be limited in the encodings or protocols it
    supports. To support a variety of different deployment settings,
    specific interactions between the client and RS are defined in an
    ACE profile. In the ACE framework, the AS is expected to manage the
    matching of compatible profile choices between a client and an RS.
    The AS informs the client of the selected profile using the
    `ace_profile` parameter in the token
    response.[¶](#section-5-2.6){.pilcrow}
:   

OAuth 2.0 requires the use of TLS to protect the communication between
the AS and client when requesting an access token between the client and
RS when accessing a resource and between the AS and RS if introspection
is used. In constrained settings, TLS is not always feasible or
desirable. Nevertheless, it is [REQUIRED]{.bcp14} that the
communications named above are encrypted, integrity protected, and
protected against message replay. It is also [REQUIRED]{.bcp14} that the
communicating endpoints perform mutual authentication. Furthermore, it
[MUST]{.bcp14} be assured that responses are bound to the requests in
the sense that the receiver of a response can be certain that the
response actually belongs to a certain request. Note that setting up
such a secure communication may require some unprotected messages to be
exchanged first (e.g., sending the token from the client to the
RS).[¶](#section-5-3){.pilcrow}

Profiles [MUST]{.bcp14} specify a communication security protocol
between the client and RS that provides the features required above.
Profiles [MUST]{.bcp14} specify a communication security protocol
[RECOMMENDED]{.bcp14} to be used between the client and AS that provides
the features required above. Profiles [MUST]{.bcp14} specify, for
introspection, a communication security protocol [RECOMMENDED]{.bcp14}
to be used between the RS and AS that provides the features required
above. These recommendations enable interoperability between different
implementations without the need to define a new profile if the
communication between the C and AS, or between the RS and AS, is
protected with a different security protocol complying with the security
requirements above.[¶](#section-5-4){.pilcrow}

In OAuth 2.0, the communication with the Token and the Introspection
endpoints at the AS is assumed to be via HTTP and may use Uri-query
parameters. When profiles of this framework use CoAP instead, it is
[REQUIRED]{.bcp14} to use of the following alternative instead of
Uri-query parameters: The sender (client or RS) encodes the parameters
of its request as a CBOR map and submits that map as the payload of the
POST request. The CBOR encoding for a number of OAuth 2.0 parameters is
specified in this document; if a profile needs to use other OAuth 2.0
parameters with CoAP, it [MUST]{.bcp14} specify their CBOR
encoding.[¶](#section-5-5){.pilcrow}

Profiles that use CBOR encoding of protocol message parameters at the
outermost encoding layer [MUST]{.bcp14} use the Content-Format
\"application/ace+cbor\". If CoAP is used for communication, the
Content-Format [MUST]{.bcp14} be abbreviated with the ID: 19 (see
[Section
8.16](#IANAcoapContentFormat){.xref}).[¶](#section-5-6){.pilcrow}

The OAuth 2.0 AS uses a JSON structure in the payload of its responses
both to the client and RS. If CoAP is used, it is [REQUIRED]{.bcp14} to
use CBOR \[[RFC8949](#RFC8949){.xref}\] instead of JSON. Depending on
the profile, the CBOR payload [MAY]{.bcp14} be enclosed in a non-CBOR
cryptographic wrapper.[¶](#section-5-7){.pilcrow}

::: {#asDiscovery}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Discovering Authorization Servers](#name-discovering-authorization-s){.section-name .selfRef} {#name-discovering-authorization-s}

The C must discover the AS in charge of the RS to determine where to
request the access token. To do so, the C 1) must find out the AS URI to
which the token request message must be sent and 2) [MUST]{.bcp14}
validate that the AS with this URI is authorized to provide access
tokens for this RS.[¶](#section-5.1-1){.pilcrow}

In order to determine the AS URI, the C [MAY]{.bcp14} send an initial
Unauthorized Resource Request message to the RS. The RS then denies the
request and sends the address of its AS back to the C (see [Section
5.2](#rreq){.xref}). How the C validates the AS authorization is not in
scope for this document. The C may, for example, ask its owner if this
AS is authorized for this RS. The C may also use a mechanism that
addresses both problems at once (e.g., by querying a dedicated secure
service provided by the client owner) .[¶](#section-5.1-2){.pilcrow}
:::
:::

::: {#rreq}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Unauthorized Resource Request Message](#name-unauthorized-resource-reque){.section-name .selfRef} {#name-unauthorized-resource-reque}

An Unauthorized Resource Request message is a request for any resource
hosted by the RS for which the client does not have authorization
granted. The RSs [MUST]{.bcp14} treat any request for a protected
resource as an Unauthorized Resource Request message when any of the
following hold:[¶](#section-5.2-1){.pilcrow}

-   [The request has been received on an unsecured
    channel.[¶](#section-5.2-2.1){.pilcrow}]{#section-5.2-2.1}
-   [The RS has no valid access token for the sender of the request
    regarding the requested action on that
    resource.[¶](#section-5.2-2.2){.pilcrow}]{#section-5.2-2.2}
-   [The RS has a valid access token for the sender of the request, but
    that token does not authorize the requested action on the requested
    resource.[¶](#section-5.2-2.3){.pilcrow}]{#section-5.2-2.3}

Note: These conditions ensure that the RS can handle requests
autonomously once access was granted and a secure channel has been
established between the C and RS. The authz-info endpoint, as part of
the process for authorizing to protected resources, is not itself a
protected resource and [MUST NOT]{.bcp14} be protected as specified
above (cf. [Section
5.10.1](#tokenAuthInfoEndpoint){.xref}).[¶](#section-5.2-3){.pilcrow}

Unauthorized Resource Request messages [MUST]{.bcp14} be denied with an
\"unauthorized_client\" error response. In this response, the resource
server [SHOULD]{.bcp14} provide proper AS Request Creation Hints to
enable the client to request an access token from the RS\'s AS, as
described in [Section 5.3](#asInfo){.xref}.[¶](#section-5.2-4){.pilcrow}

The handling of all client requests (including unauthorized ones) by the
RS is described in [Section
5.10.2](#requestC2RS){.xref}.[¶](#section-5.2-5){.pilcrow}
:::
:::

::: {#asInfo}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [AS Request Creation Hints](#name-as-request-creation-hints){.section-name .selfRef} {#name-as-request-creation-hints}

The AS Request Creation Hints are sent by an RS as a response to an
Unauthorized Resource Request message (see [Section 5.2](#rreq){.xref})
to help the sender of the Unauthorized Resource Request message acquire
a valid access token. The AS Request Creation Hints are a CBOR or JSON
map, with an [OPTIONAL]{.bcp14} element `AS` specifying an absolute URI
(see [Section
4.3](https://www.rfc-editor.org/rfc/rfc3986#section-4.3){.relref} of
\[[RFC3986](#RFC3986){.xref}\]) that identifies the appropriate AS for
the RS.[¶](#section-5.3-1){.pilcrow}

The message can also contain the following [OPTIONAL]{.bcp14}
parameters:[¶](#section-5.3-2){.pilcrow}

-   [An `audience` element contains an identifier the client should
    request at the AS, as suggested by the RS. With this parameter, when
    included in the access token request to the AS, the AS is able to
    restrict the use of the access token to specific RSs. See [Section
    6.9](#audience){.xref} for a discussion of this
    parameter.[¶](#section-5.3-3.1){.pilcrow}]{#section-5.3-3.1}
-   [A `kid` (key identifier) element contains the key identifier of a
    key used in an existing security association between the client and
    the RS. The RS expects the client to request an access token bound
    to this key in order to avoid having to reestablish the security
    association.[¶](#section-5.3-3.2){.pilcrow}]{#section-5.3-3.2}
-   [A `cnonce` element contains a client-nonce. See [Section
    5.3.1](#cnonceParam){.xref}.[¶](#section-5.3-3.3){.pilcrow}]{#section-5.3-3.3}
-   [A `scope` element contains the suggested scope that the client
    should request towards the
    AS.[¶](#section-5.3-3.4){.pilcrow}]{#section-5.3-3.4}

[Table 1](#table_asinfo){.xref} summarizes the parameters that may be
part of the AS Request Creation Hints.[¶](#section-5.3-4){.pilcrow}

[]{#name-as-request-creation-hints-2}

::: {#table_asinfo}
  Name       CBOR Key   Value Type
  ---------- ---------- ---------------------
  AS         1          text string
  kid        2          byte string
  audience   5          text string
  scope      9          text or byte string
  cnonce     39         byte string

  : [Table 1](#table-1){.selfRef}: [AS Request Creation
  Hints](#name-as-request-creation-hints-2){.selfRef}
:::

Note that the schema part of the AS parameter may need to be adapted to
the security protocol that is used between the client and the AS. Thus,
the example AS value \"coap://as.example.com/token\" might need to be
transformed to \"coaps://as.example.com/token\". It is assumed that the
client can determine the correct schema part on its own depending on the
way it communicates with the AS.[¶](#section-5.3-6){.pilcrow}

[Figure 2](#fig_as-info-payload){.xref} shows an example for an AS
Request Creation Hints payload using diagnostic
notation.[¶](#section-5.3-7){.pilcrow}

[]{#name-as-request-creation-hints-p}

::: {#fig_as-info-payload}
::: {#section-5.3-8.1}
``` {.lang-cbor-diag .sourcecode}
    4.01 Unauthorized
    Content-Format: application/ace+cbor
    Payload :
    {
     / AS / 1 : "coaps://as.example.com/token",
     / audience / 5 : "coaps://rs.example.com",
     / scope / 9 : "rTempC",
     / cnonce / 39 : h'e0a156bb3f'
    }
```
:::

[Figure 2](#figure-2){.selfRef}: [AS Request Creation Hints Payload
Example](#name-as-request-creation-hints-p){.selfRef}
:::

In the example above, the response parameter `AS` points the receiver of
this message to the URI \"coaps://as.example.com/token\" to request
access tokens. The RS sending this response uses an internal clock that
is not synchronized with the clock of the AS. Therefore, it cannot
reliably verify the expiration time of access tokens it receives.
Nevertheless, to ensure a certain level of access token freshness, the
RS has included a `cnonce` parameter (see [Section
5.3.1](#cnonceParam){.xref}) in the response. (The hex sequence of the
`cnonce` parameter is encoded in CBOR-based notation in this
example.)[¶](#section-5.3-9){.pilcrow}

[Figure 3](#fig_as-info-cbor){.xref} illustrates the mandatory use of
binary encoding of the message payload shown in [Figure
2](#fig_as-info-payload){.xref}.[¶](#section-5.3-10){.pilcrow}

[]{#name-as-request-creation-hints-e}

::: {#fig_as-info-cbor}
::: {#section-5.3-11.1}
``` {.lang-cbor-pretty .sourcecode}
a4                                   # map(4)
   01                                # unsigned(1) (=AS)
   78 1c                             # text(28)
      636f6170733a2f2f61732e657861
      6d706c652e636f6d2f746f6b656e   # "coaps://as.example.com/token"
   05                                # unsigned(5) (=audience)
   76                                # text(22)
      636f6170733a2f2f72732e657861
      6d706c652e636f6d               # "coaps://rs.example.com"
   09                                # unsigned(9) (=scope)
   66                                # text(6)
      7254656d7043                   # "rTempC"
   18 27                             # unsigned(39) (=cnonce)
   45                                # bytes(5)
      e0a156bb3f                     #
```
:::

[Figure 3](#figure-3){.selfRef}: [AS Request Creation Hints Example
Encoded in CBOR](#name-as-request-creation-hints-e){.selfRef}
:::

::: {#cnonceParam}
::: {#section-5.3.1 .section}
#### [5.3.1.](#section-5.3.1){.section-number .selfRef} [The Client-Nonce Parameter](#name-the-client-nonce-parameter){.section-name .selfRef} {#name-the-client-nonce-parameter}

If the RS does not synchronize its clock with the AS, it could be
tricked into accepting old access tokens that are either expired or have
been compromised. In order to ensure some level of token freshness in
that case, the RS can use the `cnonce` (client-nonce) parameter. The
processing requirements for this parameter are as
follows:[¶](#section-5.3.1-1){.pilcrow}

-   [An RS sending a `cnonce` parameter in an AS Request Creation Hints
    message [MUST]{.bcp14} store information to validate that a given
    cnonce is fresh. How this is implemented internally is out of scope
    for this specification. Expiration of client-nonces should be based
    roughly on the time it would take a client to obtain an access token
    after receiving the AS Request Creation Hints, with some allowance
    for unexpected
    delays.[¶](#section-5.3.1-2.1){.pilcrow}]{#section-5.3.1-2.1}
-   [A client receiving a `cnonce` parameter in an AS Request Creation
    Hints message [MUST]{.bcp14} include this in the parameters when
    requesting an access token at the AS, using the `cnonce` parameter
    from [Section
    5.8.4.4](#cnonceParamToken){.xref}.[¶](#section-5.3.1-2.2){.pilcrow}]{#section-5.3.1-2.2}
-   [If an AS grants an access token request containing a `cnonce`
    parameter, it [MUST]{.bcp14} include this value in the access token,
    using the `cnonce` claim specified in [Section
    5.10](#accessToken){.xref}.[¶](#section-5.3.1-2.3){.pilcrow}]{#section-5.3.1-2.3}
-   [An RS that is using the client-nonce mechanism and that receives an
    access token [MUST]{.bcp14} verify that this token contains a
    `cnonce` claim, with a client-nonce value that is fresh according to
    the information stored at the first step above. If the `cnonce`
    claim is not present or if the `cnonce` claim value is not fresh,
    the RS [MUST]{.bcp14} discard the access token. If this was an
    interaction with the authz-info endpoint, the RS [MUST]{.bcp14} also
    respond with an error message using a response code equivalent to
    the CoAP code 4.01
    (Unauthorized).[¶](#section-5.3.1-2.4){.pilcrow}]{#section-5.3.1-2.4}
:::
:::
:::
:::

::: {#authorizationGrants}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [Authorization Grants](#name-authorization-grants){.section-name .selfRef} {#name-authorization-grants}

To request an access token, the client obtains authorization from the
resource owner or uses its client credentials as a grant. The
authorization is expressed in the form of an authorization
grant.[¶](#section-5.4-1){.pilcrow}

The OAuth framework \[[RFC6749](#RFC6749){.xref}\] defines four grant
types. The grant types can be split up into two groups: those granted on
behalf of the resource owner (password, authorization code, implicit)
and those for the client (client credentials). Further grant types have
been added later, such as an assertion-based authorization grant defined
in \[[RFC7521](#RFC7521){.xref}\].[¶](#section-5.4-2){.pilcrow}

The grant type is selected depending on the use case. In cases where the
client acts on behalf of the resource owner, the authorization code
grant is recommended. If the client acts on behalf of the resource owner
but does not have any display or has very limited interaction
possibilities, it is recommended to use the device code grant defined in
\[[RFC8628](#RFC8628){.xref}\]. In cases where the client acts
autonomously, the client credentials grant is
recommended.[¶](#section-5.4-3){.pilcrow}

For details on the different grant types, see [Section
1.3](https://www.rfc-editor.org/rfc/rfc6749#section-1.3){.relref} of
\[[RFC6749](#RFC6749){.xref}\]. The OAuth 2.0 framework provides an
extension mechanism for defining additional grant types, so profiles of
this framework [MAY]{.bcp14} define additional grant types, if
needed.[¶](#section-5.4-4){.pilcrow}
:::
:::

::: {#clientCredentials}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [Client Credentials](#name-client-credentials){.section-name .selfRef} {#name-client-credentials}

Authentication of the client is mandatory independent of the grant type
when requesting an access token from the token endpoint. In the case of
the client credentials grant type, the authentication and grant
coincide.[¶](#section-5.5-1){.pilcrow}

Client registration and provisioning of client credentials to the client
is out of scope for this specification.[¶](#section-5.5-2){.pilcrow}

The OAuth framework defines one client credential type in [Section
2.3.1](https://www.rfc-editor.org/rfc/rfc6749#section-2.3.1){.relref} of
\[[RFC6749](#RFC6749){.xref}\] that comprises the client_id and
client_secret values. \[[OAUTH-RPCC](#I-D.erdtman-oauth-rpcc){.xref}\]
adds raw public key and pre-shared key to the client credentials type.
Profiles of this framework [MAY]{.bcp14} extend it with an additional
client credentials type using client
certificates.[¶](#section-5.5-3){.pilcrow}
:::
:::

::: {#ASAuthentication}
::: {#section-5.6 .section}
### [5.6.](#section-5.6){.section-number .selfRef} [AS Authentication](#name-as-authentication){.section-name .selfRef} {#name-as-authentication}

The client credentials grant does not, by default, authenticate the AS
that the client connects to. In classic OAuth, the AS is authenticated
with a TLS server certificate.[¶](#section-5.6-1){.pilcrow}

Profiles of this framework [MUST]{.bcp14} specify how clients
authenticate the AS and how communication security is implemented. By
default, server side TLS certificates, as defined by OAuth 2.0, are
required.[¶](#section-5.6-2){.pilcrow}
:::
:::

::: {#authorizeEndpoint}
::: {#section-5.7 .section}
### [5.7.](#section-5.7){.section-number .selfRef} [The Authorization Endpoint](#name-the-authorization-endpoint){.section-name .selfRef} {#name-the-authorization-endpoint}

The OAuth 2.0 authorization endpoint is used to interact with the
resource owner and obtain an authorization grant in certain grant flows.
The primary use case for the ACE-OAuth framework is for
machine-to-machine interactions that do not involve the resource owner
in the authorization flow; therefore, this endpoint is out of scope
here. Future profiles may define constrained adaptation mechanisms for
this endpoint as well. Nonconstrained clients interacting with
constrained resource servers can use the specification in [Section
3.1](https://www.rfc-editor.org/rfc/rfc6749#section-3.1){.relref} of
\[[RFC6749](#RFC6749){.xref}\] and the attack countermeasures suggested
in [Section
4.2](https://www.rfc-editor.org/rfc/rfc6819#section-4.2){.relref} of
\[[RFC6819](#RFC6819){.xref}\].[¶](#section-5.7-1){.pilcrow}
:::
:::

::: {#tokenEndpoint}
::: {#section-5.8 .section}
### [5.8.](#section-5.8){.section-number .selfRef} [The Token Endpoint](#name-the-token-endpoint){.section-name .selfRef} {#name-the-token-endpoint}

In standard OAuth 2.0, the AS provides the token endpoint for submitting
access token requests. This framework extends the functionality of the
token endpoint, giving the AS the possibility to help the client and RS
establish shared keys or exchange their public keys. Furthermore, this
framework defines encodings using CBOR as a substitute for
JSON.[¶](#section-5.8-1){.pilcrow}

The endpoint may also be exposed over HTTPS, as in classical OAuth or
even other transports. A profile [MUST]{.bcp14} define the details of
the mapping between the fields described below and these transports. If
HTTPS with JSON is used, the semantics of Sections
[4.1.3](https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3){.relref}
and
[4.1.4](https://www.rfc-editor.org/rfc/rfc6749#section-4.1.4){.relref}
of the OAuth 2.0 specification \[[RFC6749](#RFC6749){.xref}\]
[MUST]{.bcp14} be followed (with additions as described below). If CBOR
is used as the payload format, the semantics described in this section
[MUST]{.bcp14} be followed.[¶](#section-5.8-2){.pilcrow}

For the AS to be able to issue a token, the client [MUST]{.bcp14} be
authenticated and present a valid grant for the scopes requested.
Profiles of this framework [MUST]{.bcp14} specify how the AS
authenticates the client and how the communication between the client
and AS is protected, fulfilling the requirements specified in [Section
5](#oauthProfile){.xref}.[¶](#section-5.8-3){.pilcrow}

The default name of this endpoint in a url-path [SHOULD]{.bcp14} be
\'/token\'. However, implementations are not required to use this name
and can define their own instead.[¶](#section-5.8-4){.pilcrow}

::: {#tokenRequest}
::: {#section-5.8.1 .section}
#### [5.8.1.](#section-5.8.1){.section-number .selfRef} [Client-to-AS Request](#name-client-to-as-request){.section-name .selfRef} {#name-client-to-as-request}

The client sends a POST request to the token endpoint at the AS. The
profile [MUST]{.bcp14} specify how the communication is protected. The
content of the request consists of the parameters specified in the
relevant subsection of Section
[4](https://www.rfc-editor.org/rfc/rfc6749#section-4){.relref} of the
OAuth 2.0 specification \[[RFC6749](#RFC6749){.xref}\], depending on the
grant type, with the following exceptions and
additions:[¶](#section-5.8.1-1){.pilcrow}

-   [The `grant_type` parameter is [OPTIONAL]{.bcp14} in the context of
    this framework (as opposed to [REQUIRED]{.bcp14} in
    \[[RFC6749](#RFC6749){.xref}\]). If that parameter is missing, the
    default value \"client_credentials\" is
    implied.[¶](#section-5.8.1-2.1){.pilcrow}]{#section-5.8.1-2.1}
-   [The `audience` parameter from \[[RFC8693](#RFC8693){.xref}\] is
    [OPTIONAL]{.bcp14} to request an access token bound to a specific
    audience.[¶](#section-5.8.1-2.2){.pilcrow}]{#section-5.8.1-2.2}
-   [The `cnonce` parameter defined in [Section
    5.8.4.4](#cnonceParamToken){.xref} is [REQUIRED]{.bcp14} if the RS
    provided a client-nonce in the AS Request Creation Hints message
    ([Section
    5.3](#asInfo){.xref}).[¶](#section-5.8.1-2.3){.pilcrow}]{#section-5.8.1-2.3}
-   [The `scope` parameter [MAY]{.bcp14} be encoded as a byte string
    instead of the string encoding specified in [Section
    3.3](https://www.rfc-editor.org/rfc/rfc6749#section-3.3){.relref} of
    \[[RFC6749](#RFC6749){.xref}\] or in order to allow compact encoding
    of complex scopes. The syntax of such a binary encoding is
    explicitly not specified here and left to profiles or applications.
    Note specifically that a binary encoded scope does not necessarily
    use the space character \'0x20\' to delimit
    scope-tokens.[¶](#section-5.8.1-2.4){.pilcrow}]{#section-5.8.1-2.4}
-   [The client can send an empty (null value) `ace_profile` parameter
    to indicate that it wants the AS to include the `ace_profile`
    parameter in the response. See [Section
    5.8.4.3](#paramProfile){.xref}.[¶](#section-5.8.1-2.5){.pilcrow}]{#section-5.8.1-2.5}
-   [A client [MUST]{.bcp14} be able to use the parameters from
    \[[RFC9201](#RFC9201){.xref}\] in an access token request to the
    token endpoint, and the AS [MUST]{.bcp14} be able to process these
    additional
    parameters.[¶](#section-5.8.1-2.6){.pilcrow}]{#section-5.8.1-2.6}

The default behavior is that the AS generates a symmetric
proof-of-possession key for the client. In order to use an asymmetric
key pair or to reuse a key previously established with the RS, the
client is supposed to use the `req_cnf` parameter from
\[[RFC9201](#RFC9201){.xref}\].[¶](#section-5.8.1-3){.pilcrow}

If CoAP is used, then these parameters [MUST]{.bcp14} be provided in a
CBOR map (see [Table
5](#table_cborTokenParameters){.xref}).[¶](#section-5.8.1-4){.pilcrow}

When HTTP is used as a transport, then the client makes a request to the
token endpoint; the parameters [MUST]{.bcp14} be encoded as defined in
[Appendix B](https://www.rfc-editor.org/rfc/rfc6749#appendix-B){.relref}
of \[[RFC6749](#RFC6749){.xref}\].[¶](#section-5.8.1-5){.pilcrow}

The following examples illustrate different types of requests for
proof-of-possession tokens.[¶](#section-5.8.1-6){.pilcrow}

[Figure 4](#fig_symmATreq){.xref} shows a request for a token with a
symmetric proof-of-possession key, using diagnostic
notation.[¶](#section-5.8.1-7){.pilcrow}

[]{#name-example-request-for-an-acce}

::: {#fig_symmATreq}
::: {#section-5.8.1-8.1}
``` {.lang-cbor-diag .sourcecode}
Header: POST (Code=0.02)
Uri-Host: "as.example.com"
Uri-Path: "token"
Content-Format: application/ace+cbor
Payload:
{
  / client_id / 24 : "myclient",
  / audience /  5  : "tempSensor4711"
}
```
:::

[Figure 4](#figure-4){.selfRef}: [Example Request for an Access Token
Bound to a Symmetric Key](#name-example-request-for-an-acce){.selfRef}
:::

[Figure 5](#fig_asymmATreq){.xref} shows a request for a token with an
asymmetric proof-of-possession key. Note that, in this example, OSCORE
\[[RFC8613](#RFC8613){.xref}\] is used to provide object-security;
therefore, the Content-Format is \"application/oscore\" wrapping the
\"application/ace+cbor\" type content. The OSCORE option has a decoded
interpretation appended in parentheses for the reader\'s convenience.
Also note that, in this example, the audience is implicitly known by
both the client and AS. Furthermore, note that this example uses the
`req_cnf` parameter from
\[[RFC9201](#RFC9201){.xref}\].[¶](#section-5.8.1-9){.pilcrow}

[]{#name-example-token-request-bound}

::: {#fig_asymmATreq}
::: {#section-5.8.1-10.1}
``` {.lang-cbor-diag .sourcecode}
Header: POST (Code=0.02)
Uri-Host: "as.example.com"
Uri-Path: "token"
OSCORE: 0x09, 0x05, 0x44, 0x6C
  (h=0, k=1, n=001, partialIV= 0x05, kid=[0x44, 0x6C])
Content-Format: application/oscore
Payload:
  0x44025d1/ ... (full payload omitted for brevity) ... /68b3825e

Decrypted payload:
{
  / client_id / 24 : "myclient",
  / req_cnf / 4 : {
    / COSE_Key / 1 : {
      / kty /  1 : 2 / EC2 /,
      / kid /  2 : h'11',
      / crv / -1 : 1 / P-256 /,
      / x /   -2 : b64'usWxHK2PmfnHKwXPS54m0kTcGJ90UiglWiGahtagnv8',
      / y /   -3 : b64'IBOL+C3BttVivg+lSreASjpkttcsz+1rb7btKLv8EX4'
    }
  }
}
```
:::

[Figure 5](#figure-5){.selfRef}: [Example Token Request Bound to an
Asymmetric Key](#name-example-token-request-bound){.selfRef}
:::

[Figure 6](#fig_kidATreq){.xref} shows a request for a token where a
previously communicated proof-of-possession key is only referenced using
the `req_cnf` parameter from
\[[RFC9201](#RFC9201){.xref}\].[¶](#section-5.8.1-11){.pilcrow}

[]{#name-example-request-for-an-acces}

::: {#fig_kidATreq}
::: {#section-5.8.1-12.1}
``` {.lang-cbor-diag .sourcecode}
Header: POST (Code=0.02)
Uri-Host: "as.example.com"
Uri-Path: "token"
Content-Format: application/ace+cbor
Payload:
{
  / client_id / 24 : "myclient",
  / audience /   5 : "valve424",
  / scope /      9 : "read",
  / req_cnf /    4 : {
     / kid /        3 : b64'6kg0dXJM13U'
  }
}
```
:::

[Figure 6](#figure-6){.selfRef}: [Example Request for an Access Token
Bound to a Key Reference](#name-example-request-for-an-acces){.selfRef}
:::

Refresh tokens are typically not stored as securely as
proof-of-possession keys in requesting clients.
Proof-of-possession-based refresh token requests [MUST NOT]{.bcp14}
request different proof-of-possession keys or different audiences in
token requests. Refresh token requests can only be used to request
access tokens bound to the same proof-of-possession key and the same
audience as access tokens issued in the initial token
request.[¶](#section-5.8.1-13){.pilcrow}
:::
:::

::: {#tokenResponse}
::: {#section-5.8.2 .section}
#### [5.8.2.](#section-5.8.2){.section-number .selfRef} [AS-to-Client Response](#name-as-to-client-response){.section-name .selfRef} {#name-as-to-client-response}

If the access token request has been successfully verified by the AS and
the client is authorized to obtain an access token corresponding to its
access token request, the AS sends a response with the response code
equivalent to the CoAP response code 2.01 (Created). If the client
request was invalid, or not authorized, the AS returns an error
response, as described in [Section
5.8.3](#errorsToken){.xref}.[¶](#section-5.8.2-1){.pilcrow}

Note that the AS decides which token type and profile to use when
issuing a successful response. It is assumed that the AS has prior
knowledge of the capabilities of the client and the RS (see [Appendix
D](#app_registration){.xref}). This prior knowledge may, for example, be
set by the use of a dynamic client registration protocol exchange
\[[RFC7591](#RFC7591){.xref}\]. If the client has requested a specific
proof-of-possession key using the `req_cnf` parameter from
\[[RFC9201](#RFC9201){.xref}\], this may also influence which profile
the AS selects, as it needs to support the use of the key type requested
by the client.[¶](#section-5.8.2-2){.pilcrow}

The content of the successful reply is the Access Information. When
using CoAP, the payload [MUST]{.bcp14} be encoded as a CBOR map; when
using HTTP, the encoding is a JSON map, as specified in [Section
5.1](https://www.rfc-editor.org/rfc/rfc6749#section-5.1){.relref} of
\[[RFC6749](#RFC6749){.xref}\]. In both cases, the parameters specified
in [Section
5.1](https://www.rfc-editor.org/rfc/rfc6749#section-5.1){.relref} of
\[[RFC6749](#RFC6749){.xref}\] are used, with the following additions
and changes:[¶](#section-5.8.2-3){.pilcrow}

[]{.break}

ace_profile:
:   This parameter is [OPTIONAL]{.bcp14} unless the request included an
    empty `ace_profile` parameter, in which case it is MANDATORY. This
    indicates the profile that the client [MUST]{.bcp14} use towards the
    RS. See [Section 5.8.4.3](#paramProfile){.xref} for the formatting
    of this parameter. If this parameter is absent, the AS assumes that
    the client implicitly knows which profile to use towards the
    RS.[¶](#section-5.8.2-4.2){.pilcrow}
:   

`token_type`:
:   This parameter is [OPTIONAL]{.bcp14}, as opposed to
    [REQUIRED]{.bcp14} in \[[RFC6749](#RFC6749){.xref}\]. By default,
    implementations of this framework [SHOULD]{.bcp14} assume that the
    `token_type` is \"PoP\". If a specific use case requires another
    `token_type` (e.g., \"Bearer\") to be used, then this parameter is
    [REQUIRED]{.bcp14}.[¶](#section-5.8.2-4.4){.pilcrow}
:   

Furthermore, \[[RFC9201](#RFC9201){.xref}\] defines additional
parameters that the AS [MUST]{.bcp14} be able to use when responding to
a request to the token endpoint.[¶](#section-5.8.2-5){.pilcrow}

[Table 2](#table_rsinfo){.xref} summarizes the parameters that can
currently be part of the Access Information. Future extensions may
define additional parameters.[¶](#section-5.8.2-6){.pilcrow}

[]{#name-access-information-paramete}

::: {#table_rsinfo}
  Parameter name        Specified in
  --------------------- --------------------------------
  `access_token`        \[[RFC6749](#RFC6749){.xref}\]
  `token_type`          \[[RFC6749](#RFC6749){.xref}\]
  `expires_in`          \[[RFC6749](#RFC6749){.xref}\]
  `refresh_token`       \[[RFC6749](#RFC6749){.xref}\]
  `scope`               \[[RFC6749](#RFC6749){.xref}\]
  `state`               \[[RFC6749](#RFC6749){.xref}\]
  `error`               \[[RFC6749](#RFC6749){.xref}\]
  `error_description`   \[[RFC6749](#RFC6749){.xref}\]
  `error_uri`           \[[RFC6749](#RFC6749){.xref}\]
  `ace_profile`         RFC 9200
  `cnf`                 \[[RFC9201](#RFC9201){.xref}\]
  `rs_cnf`              \[[RFC9201](#RFC9201){.xref}\]

  : [Table 2](#table-2){.selfRef}: [Access Information
  Parameters](#name-access-information-paramete){.selfRef}
:::

[Figure 7](#fig_symmATres){.xref} shows a response containing a token
and a `cnf` parameter with a symmetric proof-of-possession key, which is
defined in \[[RFC9201](#RFC9201){.xref}\]. Note that the key identifier
`kid` is only used to simplify indexing and retrieving the key, and no
assumptions should be made that it is unique in the domains of either
the client or the RS.[¶](#section-5.8.2-8){.pilcrow}

[]{#name-example-as-response-with-an}

::: {#fig_symmATres}
::: {#section-5.8.2-9.1}
``` {.lang-cbor-diag .sourcecode}
Header: Created (Code=2.01)
Content-Format: application/ace+cbor
Payload:
{
  / access_token / 1 : b64'SlAV32hk'/ ...
   (remainder of CWT omitted for brevity;
   CWT contains COSE_Key in the cnf claim)/,
  / ace_profile / 38 : "coap_dtls",
  / expires_in /   2 : 3600,
  / cnf / 8 : {
    / COSE_Key / 1 : {
      / kty / 1 : 4 / Symmetric /,
      / kid / 2 : b64'39Gqlw',
      / k /  -1 : b64'hJtXhkV8FJG+Onbc6mxC'
    }
  }
}
```
:::

[Figure 7](#figure-7){.selfRef}: [Example AS Response with an Access
Token Bound to a Symmetric
Key](#name-example-as-response-with-an){.selfRef}
:::
:::
:::

::: {#errorsToken}
::: {#section-5.8.3 .section}
#### [5.8.3.](#section-5.8.3){.section-number .selfRef} [Error Response](#name-error-response){.section-name .selfRef} {#name-error-response}

The error responses for interactions with the AS are generally
equivalent to the ones defined in [Section
5.2](https://www.rfc-editor.org/rfc/rfc6749#section-5.2){.relref} of
\[[RFC6749](#RFC6749){.xref}\], with the following
exceptions:[¶](#section-5.8.3-1){.pilcrow}

-   [When using CoAP, the payload [MUST]{.bcp14} be encoded as a CBOR
    map, with the Content-Format \"application/ace+cbor\". When using
    HTTP, the payload is encoded in JSON, as specified in [Section
    5.2](https://www.rfc-editor.org/rfc/rfc6749#section-5.2){.relref} of
    \[[RFC6749](#RFC6749){.xref}\].[¶](#section-5.8.3-2.1){.pilcrow}]{#section-5.8.3-2.1}
-   [A response code equivalent to the CoAP code 4.00 (Bad Request)
    [MUST]{.bcp14} be used for all error responses, except for
    invalid_client, where a response code equivalent to the CoAP code
    4.01 (Unauthorized) [MAY]{.bcp14} be used under the same conditions
    as specified in [Section
    5.2](https://www.rfc-editor.org/rfc/rfc6749#section-5.2){.relref} of
    \[[RFC6749](#RFC6749){.xref}\].[¶](#section-5.8.3-2.2){.pilcrow}]{#section-5.8.3-2.2}
-   [The parameters `error`, `error_description`, and `error_uri`
    [MUST]{.bcp14} be abbreviated using the codes specified in [Table
    5](#table_cborTokenParameters){.xref}, when a CBOR encoding is
    used.[¶](#section-5.8.3-2.3){.pilcrow}]{#section-5.8.3-2.3}
-   [The error code (i.e., value of the `error` parameter)
    [MUST]{.bcp14} be abbreviated, as specified in [Table
    3](#table_cborErrorCodes){.xref}, when a CBOR encoding is
    used.[¶](#section-5.8.3-2.4){.pilcrow}]{#section-5.8.3-2.4}

[]{#name-cbor-abbreviations-for-comm}

::: {#table_cborErrorCodes}
  Name                          CBOR Values   Original Specification
  ----------------------------- ------------- --------------------------------------------------------------------------------------------------------------
  `invalid_request`             1             [Section 5.2](https://www.rfc-editor.org/rfc/rfc6749#section-5.2){.relref} of \[[RFC6749](#RFC6749){.xref}\]
  `invalid_client`              2             [Section 5.2](https://www.rfc-editor.org/rfc/rfc6749#section-5.2){.relref} of \[[RFC6749](#RFC6749){.xref}\]
  `invalid_grant`               3             [Section 5.2](https://www.rfc-editor.org/rfc/rfc6749#section-5.2){.relref} of \[[RFC6749](#RFC6749){.xref}\]
  `unauthorized_client`         4             [Section 5.2](https://www.rfc-editor.org/rfc/rfc6749#section-5.2){.relref} of \[[RFC6749](#RFC6749){.xref}\]
  `unsupported_grant_type`      5             [Section 5.2](https://www.rfc-editor.org/rfc/rfc6749#section-5.2){.relref} of \[[RFC6749](#RFC6749){.xref}\]
  `invalid_scope`               6             [Section 5.2](https://www.rfc-editor.org/rfc/rfc6749#section-5.2){.relref} of \[[RFC6749](#RFC6749){.xref}\]
  `unsupported_pop_key`         7             RFC 9200
  `incompatible_ace_profiles`   8             RFC 9200

  : [Table 3](#table-3){.selfRef}: [CBOR Abbreviations for Common Error
  Codes](#name-cbor-abbreviations-for-comm){.selfRef}
:::

In addition to the error responses defined in OAuth 2.0, the following
behavior [MUST]{.bcp14} be implemented by the
AS:[¶](#section-5.8.3-4){.pilcrow}

-   [If the client submits an asymmetric key in the token request that
    the RS cannot process, the AS [MUST]{.bcp14} reject that request
    with a response code equivalent to the CoAP code 4.00 (Bad Request),
    including the error code \"unsupported_pop_key\" specified in [Table
    3](#table_cborErrorCodes){.xref}.[¶](#section-5.8.3-5.1){.pilcrow}]{#section-5.8.3-5.1}
-   [If the client and the RS it has requested an access token for do
    not share a common profile, the AS [MUST]{.bcp14} reject that
    request with a response code equivalent to the CoAP code 4.00 (Bad
    Request), including the error code \"incompatible_ace_profiles\"
    specified in [Table
    3](#table_cborErrorCodes){.xref}.[¶](#section-5.8.3-5.2){.pilcrow}]{#section-5.8.3-5.2}
:::
:::

::: {#tokenParams}
::: {#section-5.8.4 .section}
#### [5.8.4.](#section-5.8.4){.section-number .selfRef} [Request and Response Parameters](#name-request-and-response-parame){.section-name .selfRef} {#name-request-and-response-parame}

This section provides more detail about the new parameters that can be
used in access token requests and responses, as well as abbreviations
for more compact encoding of existing parameters and common parameter
values.[¶](#section-5.8.4-1){.pilcrow}

::: {#paramGrantType}
::: {#section-5.8.4.1 .section}
##### [5.8.4.1.](#section-5.8.4.1){.section-number .selfRef} [Grant Type](#name-grant-type){.section-name .selfRef} {#name-grant-type}

The abbreviations specified in the registry defined in [Section
8.5](#IANAGrantTypeMappings){.xref} [MUST]{.bcp14} be used in CBOR
encodings instead of the string values defined in
\[[RFC6749](#RFC6749){.xref}\] if CBOR payloads are
used.[¶](#section-5.8.4.1-1){.pilcrow}

[]{#name-cbor-abbreviations-for-commo}

::: {#table_grant_types}
  Name                   CBOR Value   Original Specification
  ---------------------- ------------ ------------------------------------------------------------------------------------------------------------------
  `password`             0            [Section 4.3.2](https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2){.relref} of \[[RFC6749](#RFC6749){.xref}\]
  `authorization_code`   1            [Section 4.1.3](https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3){.relref} of \[[RFC6749](#RFC6749){.xref}\]
  `client_credentials`   2            [Section 4.4.2](https://www.rfc-editor.org/rfc/rfc6749#section-4.4.2){.relref} of \[[RFC6749](#RFC6749){.xref}\]
  `refresh_token`        3            [Section 6](https://www.rfc-editor.org/rfc/rfc6749#section-6){.relref} of \[[RFC6749](#RFC6749){.xref}\]

  : [Table 4](#table-4){.selfRef}: [CBOR Abbreviations for Common Grant
  Types](#name-cbor-abbreviations-for-commo){.selfRef}
:::
:::
:::

::: {#paramTokenType}
::: {#section-5.8.4.2 .section}
##### [5.8.4.2.](#section-5.8.4.2){.section-number .selfRef} [Token Type](#name-token-type){.section-name .selfRef} {#name-token-type}

The `token_type` parameter, defined in [Section
5.1](https://www.rfc-editor.org/rfc/rfc6749#section-5.1){.relref} of
\[[RFC6749](#RFC6749){.xref}\], allows the AS to indicate to the client
which type of access token it is receiving (e.g., a bearer
token).[¶](#section-5.8.4.2-1){.pilcrow}

This document registers the new value \"PoP\" for the \"OAuth Access
Token Types\" registry, specifying a proof-of-possession token. How the
proof of possession by the client to the RS is performed [MUST]{.bcp14}
be specified by the profiles.[¶](#section-5.8.4.2-2){.pilcrow}

The values in the `token_type` parameter [MUST]{.bcp14} use the CBOR
abbreviations defined in the registry specified by [Section
8.7](#IANATokenTypeMappings){.xref} if a CBOR encoding is
used.[¶](#section-5.8.4.2-3){.pilcrow}

In this framework, the \"pop\" value for the `token_type` parameter is
the default. The AS may, however, provide a different value from those
registered in
\[[IANA.OAuthAccessTokenTypes](#IANA.OAuthAccessTokenTypes){.xref}\].[¶](#section-5.8.4.2-4){.pilcrow}
:::
:::

::: {#paramProfile}
::: {#section-5.8.4.3 .section}
##### [5.8.4.3.](#section-5.8.4.3){.section-number .selfRef} [Profile](#name-profile){.section-name .selfRef} {#name-profile}

Profiles of this framework [MUST]{.bcp14} define the communication
protocol and the communication security protocol between the client and
the RS. The security protocol [MUST]{.bcp14} provide encryption,
integrity, and replay protection. It [MUST]{.bcp14} also provide a
binding between requests and responses. Furthermore, profiles
[MUST]{.bcp14} define a list of allowed proof-of-possession methods if
they support proof-of-possession
tokens.[¶](#section-5.8.4.3-1){.pilcrow}

A profile [MUST]{.bcp14} specify an identifier that [MUST]{.bcp14} be
used to uniquely identify itself in the `ace_profile` parameter. The
textual representation of the profile identifier is intended for human
readability and for JSON-based interactions; it [MUST NOT]{.bcp14} be
used for CBOR-based interactions. Profiles [MUST]{.bcp14} register their
identifier in the registry defined in [Section
8.8](#IANAProfile){.xref}.[¶](#section-5.8.4.3-2){.pilcrow}

Profiles [MAY]{.bcp14} define additional parameters for both the token
request and the Access Information in the access token response in order
to support negotiation or signaling of profile-specific
parameters.[¶](#section-5.8.4.3-3){.pilcrow}

Clients that want the AS to provide them with the `ace_profile`
parameter in the access token response can indicate that by sending an
`ace_profile` parameter with a null value for CBOR-based interactions,
or an empty string if CBOR is not used, in the access token
request.[¶](#section-5.8.4.3-4){.pilcrow}
:::
:::

::: {#cnonceParamToken}
::: {#section-5.8.4.4 .section}
##### [5.8.4.4.](#section-5.8.4.4){.section-number .selfRef} [Client-Nonce](#name-client-nonce){.section-name .selfRef} {#name-client-nonce}

This parameter [MUST]{.bcp14} be sent from the client to the AS if it
previously received a `cnonce` parameter in the AS Request Creation
Hints ([Section 5.3](#asInfo){.xref}). The parameter is encoded as a
byte string for CBOR-based interactions and as a string (base64url
without padding encoded binary \[[RFC4648](#RFC4648){.xref}\]) if CBOR
is not used. It [MUST]{.bcp14} copy the value from the `cnonce`
parameter in the AS Request Creation
Hints.[¶](#section-5.8.4.4-1){.pilcrow}
:::
:::
:::
:::

::: {#tokenCborParams}
::: {#section-5.8.5 .section}
#### [5.8.5.](#section-5.8.5){.section-number .selfRef} [Mapping Parameters to CBOR](#name-mapping-parameters-to-cbor){.section-name .selfRef} {#name-mapping-parameters-to-cbor}

If CBOR encoding is used, all OAuth parameters in access token requests
and responses [MUST]{.bcp14} be mapped to CBOR types, as specified in
the registry defined by [Section
8.10](#IANAOAuthParameterMappingsRegistry){.xref}, using the given
integer abbreviation for the map keys.[¶](#section-5.8.5-1){.pilcrow}

Note that we have aligned the abbreviations corresponding to claims with
the abbreviations defined in
\[[RFC8392](#RFC8392){.xref}\].[¶](#section-5.8.5-2){.pilcrow}

Note also that abbreviations from -24 to 23 have a 1-byte encoding size
in CBOR. We have thus chosen to assign abbreviations in that range to
parameters we expect to be used most frequently in constrained
scenarios.[¶](#section-5.8.5-3){.pilcrow}

[]{#name-cbor-mappings-used-in-token}

::: {#table_cborTokenParameters}
  Name                  CBOR Key   Value Type            Original Specification
  --------------------- ---------- --------------------- --------------------------------
  `access_token`        1          byte string           \[[RFC6749](#RFC6749){.xref}\]
  `expires_in`          2          unsigned integer      \[[RFC6749](#RFC6749){.xref}\]
  `audience`            5          text string           \[[RFC8693](#RFC8693){.xref}\]
  `scope`               9          text or byte string   \[[RFC6749](#RFC6749){.xref}\]
  `client_id`           24         text string           \[[RFC6749](#RFC6749){.xref}\]
  `client_secret`       25         byte string           \[[RFC6749](#RFC6749){.xref}\]
  `response_type`       26         text string           \[[RFC6749](#RFC6749){.xref}\]
  `redirect_uri`        27         text string           \[[RFC6749](#RFC6749){.xref}\]
  `state`               28         text string           \[[RFC6749](#RFC6749){.xref}\]
  `code`                29         byte string           \[[RFC6749](#RFC6749){.xref}\]
  `error`               30         integer               \[[RFC6749](#RFC6749){.xref}\]
  `error_description`   31         text string           \[[RFC6749](#RFC6749){.xref}\]
  `error_uri`           32         text string           \[[RFC6749](#RFC6749){.xref}\]
  `grant_type`          33         unsigned integer      \[[RFC6749](#RFC6749){.xref}\]
  `token_type`          34         integer               \[[RFC6749](#RFC6749){.xref}\]
  `username`            35         text string           \[[RFC6749](#RFC6749){.xref}\]
  `password`            36         text string           \[[RFC6749](#RFC6749){.xref}\]
  `refresh_token`       37         byte string           \[[RFC6749](#RFC6749){.xref}\]
  `ace_profile`         38         integer               RFC 9200
  `cnonce`              39         byte string           RFC 9200

  : [Table 5](#table-5){.selfRef}: [CBOR Mappings Used in Token Requests
  and Responses](#name-cbor-mappings-used-in-token){.selfRef}
:::
:::
:::
:::
:::

::: {#introspectionEndpoint}
::: {#section-5.9 .section}
### [5.9.](#section-5.9){.section-number .selfRef} [The Introspection Endpoint](#name-the-introspection-endpoint){.section-name .selfRef} {#name-the-introspection-endpoint}

Token introspection \[[RFC7662](#RFC7662){.xref}\] [MAY]{.bcp14} be
implemented by the AS and the RS. When implemented, it [MAY]{.bcp14} be
used by the RS and to query the AS for metadata about a given token,
e.g., validity or scope. Analogous to the protocol defined in
\[[RFC7662](#RFC7662){.xref}\] for HTTP and JSON, this section defines
adaptations to more constrained environments using CBOR and leaving the
choice of the application protocol to the profile. The client
[MAY]{.bcp14} also implement and use introspection analogously to the RS
to obtain information about a given token.[¶](#section-5.9-1){.pilcrow}

Communication between the requesting entity and the introspection
endpoint at the AS [MUST]{.bcp14} be integrity protected and encrypted.
The communication security protocol [MUST]{.bcp14} also provide a
binding between requests and responses. Furthermore, the two interacting
parties [MUST]{.bcp14} perform mutual authentication. Finally, the AS
[SHOULD]{.bcp14} verify that the requesting entity has the right to
access introspection information about the provided token. Profiles of
this framework that support introspection [MUST]{.bcp14} specify how
authentication and communication security between the requesting entity
and the AS is implemented.[¶](#section-5.9-2){.pilcrow}

The default name of this endpoint in a url-path [SHOULD]{.bcp14} be
\'/introspect\'. However, implementations are not required to use this
name and can define their own instead.[¶](#section-5.9-3){.pilcrow}

::: {#introReq}
::: {#section-5.9.1 .section}
#### [5.9.1.](#section-5.9.1){.section-number .selfRef} [Introspection Request](#name-introspection-request){.section-name .selfRef} {#name-introspection-request}

The requesting entity sends a POST request to the introspection endpoint
at the AS. The profile [MUST]{.bcp14} specify how the communication is
protected. If CoAP is used, the payload [MUST]{.bcp14} be encoded as a
CBOR map with a `token` entry containing the access token. Further
optional parameters representing additional context that is known by the
requesting entity to aid the AS in its response [MAY]{.bcp14} be
included.[¶](#section-5.9.1-1){.pilcrow}

For CoAP-based interaction, all messages [MUST]{.bcp14} use the content
type \"application/ace+cbor\". For HTTP, the encoding defined in
[Section
2.1](https://www.rfc-editor.org/rfc/rfc7662#section-2.1){.relref} of
\[[RFC7662](#RFC7662){.xref}\] is used.[¶](#section-5.9.1-2){.pilcrow}

The same parameters are required and optional as in [Section
2.1](https://www.rfc-editor.org/rfc/rfc7662#section-2.1){.relref} of
\[[RFC7662](#RFC7662){.xref}\].[¶](#section-5.9.1-3){.pilcrow}

For example, [Figure 8](#fig_introReq){.xref} shows an RS calling the
token introspection endpoint at the AS to query about an OAuth 2.0
proof-of-possession token. Note that object security based on OSCORE
\[[RFC8613](#RFC8613){.xref}\] is assumed in this example; therefore,
the Content-Format is \"application/oscore\". [Figure
9](#fig_introReq-payl){.xref} shows the decoded
payload.[¶](#section-5.9.1-4){.pilcrow}

[]{#name-example-introspection-reque}

::: {#fig_introReq}
::: {#section-5.9.1-5.1}
``` sourcecode
Header: POST (Code=0.02)
Uri-Host: "as.example.com"
Uri-Path: "introspect"
OSCORE: 0x09, 0x05, 0x25
Content-Format: application/oscore
Payload:
... COSE content ...
```
:::

[Figure 8](#figure-8){.selfRef}: [Example Introspection
Request](#name-example-introspection-reque){.selfRef}
:::

[]{#name-decoded-payload}

::: {#fig_introReq-payl}
::: {#section-5.9.1-6.1}
``` {.lang-cbor-diag .sourcecode}
{
  / token / 11  : b64'7gj0dXJQ43U',
  / token_type_hint / 33 : 2 / PoP /
}
```
:::

[Figure 9](#figure-9){.selfRef}: [Decoded
Payload](#name-decoded-payload){.selfRef}
:::
:::
:::

::: {#introRes}
::: {#section-5.9.2 .section}
#### [5.9.2.](#section-5.9.2){.section-number .selfRef} [Introspection Response](#name-introspection-response){.section-name .selfRef} {#name-introspection-response}

If the introspection request is authorized and successfully processed,
the AS sends a response with the response code equivalent to the CoAP
code 2.01 (Created). If the introspection request was invalid, not
authorized, or couldn\'t be processed, the AS returns an error response,
as described in [Section
5.9.3](#errorsIntro){.xref}.[¶](#section-5.9.2-1){.pilcrow}

In a successful response, the AS encodes the response parameters in a
map. If CoAP is used, this [MUST]{.bcp14} be encoded as a CBOR map; if
HTTP is used, the JSON encoding specified in [Section
2.2](https://www.rfc-editor.org/rfc/rfc7662#section-2.2){.relref} of
\[[RFC7662](#RFC7662){.xref}\] is used. The map containing the response
payload includes the same required and optional parameters as in
[Section
2.2](https://www.rfc-editor.org/rfc/rfc7662#section-2.2){.relref} of
\[[RFC7662](#RFC7662){.xref}\], with the following
additions:[¶](#section-5.9.2-2){.pilcrow}

[]{.break}

`ace_profile`
:   This parameter is [OPTIONAL]{.bcp14}. This indicates the profile
    that the RS [MUST]{.bcp14} use with the client. See [Section
    5.8.4.3](#paramProfile){.xref} for more details on the formatting of
    this parameter. If this parameter is absent, the AS assumes that the
    RS implicitly knows which profile to use towards the
    client.[¶](#section-5.9.2-3.2){.pilcrow}
:   

`cnonce`
:   This parameter is [OPTIONAL]{.bcp14}. This is a client-nonce
    provided to the AS by the client. The RS [MUST]{.bcp14} verify that
    this corresponds to the client-nonce previously provided to the
    client in the AS Request Creation Hints. See Sections
    [5.3](#asInfo){.xref} and [5.8.4.4](#cnonceParamToken){.xref}. Its
    value is a byte string when encoded in CBOR and is the base64url
    encoding of this byte string without padding when encoded in JSON
    \[[RFC4648](#RFC4648){.xref}\].[¶](#section-5.9.2-3.4){.pilcrow}
:   

`cti`
:   This parameter is [OPTIONAL]{.bcp14}. This is the `cti` claim
    associated to this access token. This parameter has the same meaning
    and processing rules as the `jti` parameter defined in [Section
    3.1.2](https://www.rfc-editor.org/rfc/rfc7662#section-3.1.2){.relref}
    of \[[RFC7662](#RFC7662){.xref}\] except that its value is a byte
    string when encoded in CBOR and is the base64url encoding of this
    byte string without padding when encoded in JSON
    \[[RFC4648](#RFC4648){.xref}\].[¶](#section-5.9.2-3.6){.pilcrow}
:   

`exi`
:   This parameter is [OPTIONAL]{.bcp14}. This is the `expires_in` claim
    associated to this access token. See [Section
    5.10.3](#tokenExpiration){.xref}.[¶](#section-5.9.2-3.8){.pilcrow}
:   

Furthermore, \[[RFC9201](#RFC9201){.xref}\] defines more parameters that
the AS [MUST]{.bcp14} be able to use when responding to a request to the
introspection endpoint.[¶](#section-5.9.2-4){.pilcrow}

For example, [Figure 10](#fig_introRes){.xref} shows an AS response to
the introspection request in [Figure 8](#fig_introReq){.xref}. Note that
this example contains the `cnf` parameter defined in
\[[RFC9201](#RFC9201){.xref}\].[¶](#section-5.9.2-5){.pilcrow}

[]{#name-example-introspection-respo}

::: {#fig_introRes}
::: {#section-5.9.2-6.1}
``` {.lang-cbor-diag .sourcecode}
Header: Created (Code=2.01)
Content-Format: application/ace+cbor
Payload:
{
  / active /      10 : true,
  / scope /        9 : "read",
  / ace_profile / 38 : 1 / coap_dtls /,
  / cnf /          8 : {
    / COSE_Key / 1 : {
      / kty / 1 : 4 / Symmetric /,
      / kid / 2 : b64'39Gqlw',
      / k /  -1 : b64'hJtXhkV8FJG+Onbc6mxC'
    }
  }
}
```
:::

[Figure 10](#figure-10){.selfRef}: [Example Introspection
Response](#name-example-introspection-respo){.selfRef}
:::
:::
:::

::: {#errorsIntro}
::: {#section-5.9.3 .section}
#### [5.9.3.](#section-5.9.3){.section-number .selfRef} [Error Response](#name-error-response-2){.section-name .selfRef} {#name-error-response-2}

The error responses for CoAP-based interactions with the AS are
equivalent to the ones for HTTP-based interactions, as defined in
[Section
2.3](https://www.rfc-editor.org/rfc/rfc7662#section-2.3){.relref} of
\[[RFC7662](#RFC7662){.xref}\], with the following
differences:[¶](#section-5.9.3-1){.pilcrow}

-   [If content is sent and CoAP is used, the payload [MUST]{.bcp14} be
    encoded as a CBOR map and the Content-Format
    \"application/ace+cbor\" [MUST]{.bcp14} be used. For HTTP, the
    encoding defined in [Section
    2.3](https://www.rfc-editor.org/rfc/rfc6749#section-2.3){.relref} of
    \[[RFC6749](#RFC6749){.xref}\] is
    used.[¶](#section-5.9.3-2.1){.pilcrow}]{#section-5.9.3-2.1}
-   [If the credentials used by the requesting entity (usually the RS)
    are invalid, the AS [MUST]{.bcp14} respond with the response code
    equivalent to the CoAP code 4.01 (Unauthorized) and use the required
    and optional parameters from [Section
    2.3](https://www.rfc-editor.org/rfc/rfc7662#section-2.3){.relref} of
    \[[RFC7662](#RFC7662){.xref}\].[¶](#section-5.9.3-2.2){.pilcrow}]{#section-5.9.3-2.2}
-   [If the requesting entity does not have the right to perform this
    introspection request, the AS [MUST]{.bcp14} respond with a response
    code equivalent to the CoAP code 4.03 (Forbidden). In this case, no
    payload is
    returned.[¶](#section-5.9.3-2.3){.pilcrow}]{#section-5.9.3-2.3}
-   [The parameters `error`, `error_description`, and `error_uri`
    [MUST]{.bcp14} be abbreviated using the codes specified in [Table
    5](#table_cborTokenParameters){.xref}.[¶](#section-5.9.3-2.4){.pilcrow}]{#section-5.9.3-2.4}
-   [The error codes [MUST]{.bcp14} be abbreviated using the codes
    specified in the registry defined by [Section
    8.4](#IANAErrorCBORMappings){.xref}.[¶](#section-5.9.3-2.5){.pilcrow}]{#section-5.9.3-2.5}

Note that a properly formed and authorized query for an inactive or
otherwise invalid token does not warrant an error response by this
specification. In these cases, the authorization server [MUST]{.bcp14}
instead respond with an introspection response with the `active` field
set to \"false\".[¶](#section-5.9.3-3){.pilcrow}
:::
:::

::: {#introParamsCbor}
::: {#section-5.9.4 .section}
#### [5.9.4.](#section-5.9.4){.section-number .selfRef} [Mapping Introspection Parameters to CBOR](#name-mapping-introspection-param){.section-name .selfRef} {#name-mapping-introspection-param}

If CBOR is used, the introspection request and response parameters
[MUST]{.bcp14} be mapped to CBOR types, as specified in the registry
defined by [Section
8.12](#IANAIntrospectionEndpointCBORMappingsRegistry){.xref}, using the
given integer abbreviation for the map
key.[¶](#section-5.9.4-1){.pilcrow}

Note that we have aligned abbreviations that correspond to a claim with
the abbreviations defined in \[[RFC8392](#RFC8392){.xref}\] and the
abbreviations of parameters with the same name from [Section
5.8.5](#tokenCborParams){.xref}.[¶](#section-5.9.4-2){.pilcrow}

[]{#name-cbor-mappings-for-token-int}

::: {#table_cborIntrospectionParameters}
  Parameter name        CBOR Key   Value Type                         Original Specification
  --------------------- ---------- ---------------------------------- --------------------------------
  `iss`                 1          text string                        \[[RFC7662](#RFC7662){.xref}\]
  `sub`                 2          text string                        \[[RFC7662](#RFC7662){.xref}\]
  `aud`                 3          text string                        \[[RFC7662](#RFC7662){.xref}\]
  `exp`                 4          integer or floating-point number   \[[RFC7662](#RFC7662){.xref}\]
  `nbf`                 5          integer or floating-point number   \[[RFC7662](#RFC7662){.xref}\]
  `iat`                 6          integer or floating-point number   \[[RFC7662](#RFC7662){.xref}\]
  `cti`                 7          byte string                        RFC 9200
  `scope`               9          text or byte string                \[[RFC7662](#RFC7662){.xref}\]
  `active`              10         True or False                      \[[RFC7662](#RFC7662){.xref}\]
  `token`               11         byte string                        \[[RFC7662](#RFC7662){.xref}\]
  `client_id`           24         text string                        \[[RFC7662](#RFC7662){.xref}\]
  `error`               30         integer                            \[[RFC7662](#RFC7662){.xref}\]
  `error_description`   31         text string                        \[[RFC7662](#RFC7662){.xref}\]
  `error_uri`           32         text string                        \[[RFC7662](#RFC7662){.xref}\]
  `token_type_hint`     33         text string                        \[[RFC7662](#RFC7662){.xref}\]
  `token_type`          34         integer                            \[[RFC7662](#RFC7662){.xref}\]
  `username`            35         text string                        \[[RFC7662](#RFC7662){.xref}\]
  `ace_profile`         38         integer                            RFC 9200
  `cnonce`              39         byte string                        RFC 9200
  exi                   40         unsigned integer                   RFC 9200

  : [Table 6](#table-6){.selfRef}: [CBOR Mappings for Token
  Introspection Parameters](#name-cbor-mappings-for-token-int){.selfRef}
:::
:::
:::
:::
:::

::: {#accessToken}
::: {#section-5.10 .section}
### [5.10.](#section-5.10){.section-number .selfRef} [The Access Token](#name-the-access-token){.section-name .selfRef} {#name-the-access-token}

In this framework, the use of CBOR Web Token (CWT) as specified in
\[[RFC8392](#RFC8392){.xref}\] is
[RECOMMENDED]{.bcp14}.[¶](#section-5.10-1){.pilcrow}

In order to facilitate offline processing of access tokens, this
document uses the `cnf` claim from \[[RFC8747](#RFC8747){.xref}\] and
the `scope` claim from \[[RFC8693](#RFC8693){.xref}\] for JWT- and
CWT-encoded tokens. In addition to string encoding specified for the
`scope` claim, a binary encoding [MAY]{.bcp14} be used. The syntax of
such an encoding is explicitly not specified here and left to profiles
or applications, specifically note that a binary encoded scope does not
necessarily use the space character \'0x20\' to delimit
scope-tokens.[¶](#section-5.10-2){.pilcrow}

If the AS needs to convey a hint to the RS about which profile it should
use to communicate with the client, the AS [MAY]{.bcp14} include an
`ace_profile` claim in the access token, with the same syntax and
semantics as defined in [Section
5.8.4.3](#paramProfile){.xref}.[¶](#section-5.10-3){.pilcrow}

If the client submitted a `cnonce` parameter in the access token request
([Section 5.8.4.4](#cnonceParamToken){.xref}), the AS [MUST]{.bcp14}
include the value of this parameter in the `cnonce` claim specified
here. The `cnonce` claim uses binary
encoding.[¶](#section-5.10-4){.pilcrow}

::: {#tokenAuthInfoEndpoint}
::: {#section-5.10.1 .section}
#### [5.10.1.](#section-5.10.1){.section-number .selfRef} [The Authorization Information Endpoint](#name-the-authorization-informati){.section-name .selfRef} {#name-the-authorization-informati}

The access token, containing authorization information and information
about the proof-of-possession method used by the client, needs to be
transported to the RS so that the RS can authenticate and authorize the
client request.[¶](#section-5.10.1-1){.pilcrow}

This section defines a method for transporting the access token to the
RS using a RESTful protocol, such as CoAP. Profiles of this framework
[MAY]{.bcp14} define other methods for token
transport.[¶](#section-5.10.1-2){.pilcrow}

The method consists of an authz-info endpoint, implemented by the RS. A
client using this method [MUST]{.bcp14} make a POST request to the
authz-info endpoint at the RS with the access token in the payload. The
CoAP Content-Format or HTTP media type [MUST]{.bcp14} reflect the format
of the token, e.g., \"application/cwt\", for CBOR Web Tokens; if no
Content-Format or media type is defined for the token format,
\"application/octet-stream\" [MUST]{.bcp14} be
used.[¶](#section-5.10.1-3){.pilcrow}

The RS receiving the token [MUST]{.bcp14} verify the validity of the
token. If the token is valid, the RS [MUST]{.bcp14} respond to the POST
request with a response code equivalent to CoAP code 2.01 (Created).
[Section 5.10.1.1](#verifyToken){.xref} outlines how an RS
[MUST]{.bcp14} proceed to verify the validity of an access
token.[¶](#section-5.10.1-4){.pilcrow}

The RS [MUST]{.bcp14} be prepared to store at least one access token for
future use. This is a difference as to how access tokens are handled in
OAuth 2.0, where the access token is typically sent along with each
request and therefore not stored at the
RS.[¶](#section-5.10.1-5){.pilcrow}

When using this framework, it is [RECOMMENDED]{.bcp14} that an RS stores
only one token per proof-of-possession key. This means that an
additional token linked to the same key will supersede any existing
token at the RS by replacing the corresponding authorization
information. The reason is that this greatly simplifies (constrained)
implementations, with respect to required storage and resolving a
request to the applicable token. The use of multiple access tokens for a
single client increases the strain on the resource server, as it must
consider every access token and calculate the actual permissions of the
client. Also, tokens may contradict each other, which may lead the
server to enforce wrong permissions. If one of the access tokens expires
earlier than others, the resulting permissions may offer insufficient
protection.[¶](#section-5.10.1-6){.pilcrow}

If the payload sent to the authz-info endpoint does not parse to a
token, the RS [MUST]{.bcp14} respond with a response code equivalent to
the CoAP code 4.00 (Bad Request).[¶](#section-5.10.1-7){.pilcrow}

The RS [MAY]{.bcp14} make an introspection request to validate the token
before responding to the POST request to the authz-info endpoint, e.g.,
if the token is an opaque reference. Some transport protocols may
provide a way to indicate that the RS is busy and the client should
retry after an interval; this type of status update would be appropriate
while the RS is waiting for an introspection
response.[¶](#section-5.10.1-8){.pilcrow}

Profiles [MUST]{.bcp14} specify whether the authz-info endpoint is
protected, including whether error responses from this endpoint are
protected. Note that since the token contains information that allows
the client and the RS to establish a security context in the first
place, mutual authentication may not be possible at this
point.[¶](#section-5.10.1-9){.pilcrow}

The default name of this endpoint in a url-path is \'/authz-info\';
however, implementations are not required to use this name and can
define their own instead.[¶](#section-5.10.1-10){.pilcrow}

::: {#verifyToken}
::: {#section-5.10.1.1 .section}
##### [5.10.1.1.](#section-5.10.1.1){.section-number .selfRef} [Verifying an Access Token](#name-verifying-an-access-token){.section-name .selfRef} {#name-verifying-an-access-token}

When an RS receives an access token, it [MUST]{.bcp14} verify it before
storing it. The details of token verification depends on various
aspects, including the token encoding, the type of token, the security
protection applied to the token, and the claims. The token encoding
matters since the security protection differs between the token
encodings. For example, a CWT token uses COSE, while a JWT token uses
JSON Object Signing and Encryption (JOSE). The type of token also has an
influence on the verification procedure since tokens may be
self-contained, whereby token verification may happen locally at the RS,
while a reference token requires further interaction with the
authorization server, for example, using token introspection, to obtain
the claims associated with the token reference. Self-contained tokens
[MUST]{.bcp14} at least be integrity protected, but they [MAY]{.bcp14}
also be encrypted.[¶](#section-5.10.1.1-1){.pilcrow}

For self-contained tokens, the RS [MUST]{.bcp14} process the security
protection of the token first, as specified by the respective token
format. For CWT, the description can be found in
\[[RFC8392](#RFC8392){.xref}\]; for JWT, the relevant specification is
\[[RFC7519](#RFC7519){.xref}\]. This [MUST]{.bcp14} include a
verification that security protection (and thus the token) was generated
by an AS that has the right to issue access tokens for this
RS.[¶](#section-5.10.1.1-2){.pilcrow}

In case the token is communicated by reference, the RS needs to obtain
the claims first. When the RS uses token introspection, the relevant
specification is \[[RFC7662](#RFC7662){.xref}\] with CoAP transport
specified in [Section
5.9](#introspectionEndpoint){.xref}.[¶](#section-5.10.1.1-3){.pilcrow}

Errors may happen during this initial processing
stage:[¶](#section-5.10.1.1-4){.pilcrow}

-   [If the verification of the security wrapper fails, or the token was
    issued by an AS that does not have the right to issue tokens for the
    receiving RS, the RS [MUST]{.bcp14} discard the token and, if this
    was an interaction with authz-info, return an error message with a
    response code equivalent to the CoAP code 4.01
    (Unauthorized).[¶](#section-5.10.1.1-5.1){.pilcrow}]{#section-5.10.1.1-5.1}
-   [If the claims cannot be obtained, the RS [MUST]{.bcp14} discard the
    token and, in case of an interaction via the authz-info endpoint,
    return an error message with a response code equivalent to the CoAP
    code 4.00 (Bad
    Request).[¶](#section-5.10.1.1-5.2){.pilcrow}]{#section-5.10.1.1-5.2}

Next, the RS [MUST]{.bcp14} verify claims, if present, contained in the
access token. Errors are returned when claim checks fail, in the order
of priority of this list:[¶](#section-5.10.1.1-6){.pilcrow}

[]{.break}

`iss`
:   The `iss` claim (if present) must identify the AS that has produced
    the security protection for the access token. If that is not the
    case, the RS [MUST]{.bcp14} discard the token. If this was an
    interaction with authz-info, the RS [MUST]{.bcp14} also respond with
    a response code equivalent to the CoAP code 4.01
    (Unauthorized).[¶](#section-5.10.1.1-7.2){.pilcrow}
:   

`exp`
:   The expiration date must be in the future. If that is not the case,
    the RS [MUST]{.bcp14} discard the token. If this was an interaction
    with authz-info, the RS [MUST]{.bcp14} also respond with a response
    code equivalent to the CoAP code 4.01 (Unauthorized). Note that the
    RS has to terminate access rights to the protected resources at the
    time when the tokens expire.[¶](#section-5.10.1.1-7.4){.pilcrow}
:   

`aud`
:   The `aud` claim must refer to an audience that the RS identifies
    with. If that is not the case, the RS [MUST]{.bcp14} discard the
    token. If this was an interaction with authz-info, the RS
    [MUST]{.bcp14} also respond with a response code equivalent to the
    CoAP code 4.03 (Forbidden).[¶](#section-5.10.1.1-7.6){.pilcrow}
:   

`scope`
:   The RS must recognize value of the `scope` claim. If that is not the
    case, the RS [MUST]{.bcp14} discard the token. If this was an
    interaction with authz-info, the RS [MUST]{.bcp14} also respond with
    a response code equivalent to the CoAP code 4.00 (Bad Request). The
    RS [MAY]{.bcp14} provide additional information in the error
    response to clarify what went
    wrong.[¶](#section-5.10.1.1-7.8){.pilcrow}
:   

Additional processing may be needed for other claims in a way specific
to a profile or the underlying
application.[¶](#section-5.10.1.1-8){.pilcrow}

Note that the `sub` (Subject) claim cannot always be verified when the
token is submitted to the RS since the client may not have authenticated
yet. Also note that a counter for the `exi` (expires in) claim
[MUST]{.bcp14} be initialized when the RS first verifies this
token.[¶](#section-5.10.1.1-9){.pilcrow}

Also note that profiles of this framework may define access token
transport mechanisms that do not allow for error responses. Therefore,
the error messages specified here only apply if the token was sent to
the authz-info endpoint.[¶](#section-5.10.1.1-10){.pilcrow}

When sending error responses, the RS [MAY]{.bcp14} use the error codes
from [Section
3.1](https://www.rfc-editor.org/rfc/rfc6750#section-3.1){.relref} of
\[[RFC6750](#RFC6750){.xref}\] to provide additional details to the
client.[¶](#section-5.10.1.1-11){.pilcrow}
:::
:::

::: {#protAuthzInfo}
::: {#section-5.10.1.2 .section}
##### [5.10.1.2.](#section-5.10.1.2){.section-number .selfRef} [Protecting the Authorization Information Endpoint](#name-protecting-the-authorizatio){.section-name .selfRef} {#name-protecting-the-authorizatio}

As this framework can be used in RESTful environments, it is important
to make sure that attackers cannot perform unauthorized requests on the
authz-info endpoints, other than submitting access
tokens.[¶](#section-5.10.1.2-1){.pilcrow}

Specifically, it [SHOULD NOT]{.bcp14} be possible to perform GET,
DELETE, or PUT on the authz-info
endpoint.[¶](#section-5.10.1.2-2){.pilcrow}

The RS [SHOULD]{.bcp14} implement rate-limiting measures to mitigate
attacks aiming to overload the processing capacity of the RS by
repeatedly submitting tokens. For CoAP-based communication, the RS could
use the mechanisms from \[[RFC8516](#RFC8516){.xref}\] to indicate that
it is overloaded.[¶](#section-5.10.1.2-3){.pilcrow}
:::
:::
:::
:::

::: {#requestC2RS}
::: {#section-5.10.2 .section}
#### [5.10.2.](#section-5.10.2){.section-number .selfRef} [Client Requests to the RS](#name-client-requests-to-the-rs){.section-name .selfRef} {#name-client-requests-to-the-rs}

Before sending a request to an RS, the client [MUST]{.bcp14} verify that
the keys used to protect this communication are still valid. See
[Section 5.10.4](#keyExpiration){.xref} for details on how the client
determines the validity of the keys
used.[¶](#section-5.10.2-1){.pilcrow}

If an RS receives a request from a client and the target resource
requires authorization, the RS [MUST]{.bcp14} first verify that it has
an access token that authorizes this request and that the client has
performed the proof-of-possession binding for that token to the
request.[¶](#section-5.10.2-2){.pilcrow}

The response code [MUST]{.bcp14} be 4.01 (Unauthorized) in case the
client has not performed the proof of possession or if the RS has no
valid access token for the client. If the RS has an access token for the
client but the token does not authorize access for the resource that was
requested, the RS [MUST]{.bcp14} reject the request with a 4.03
(Forbidden). If the RS has an access token for the client but it does
not cover the action that was requested on the resource, the RS
[MUST]{.bcp14} reject the request with a 4.05 (Method Not
Allowed).[¶](#section-5.10.2-3){.pilcrow}

Note: The use of the response codes 4.03 and 4.05 is intended to prevent
infinite loops where a client optimistically tries to access a requested
resource with any access token received from AS. As malicious clients
could pretend to be the C to determine the C\'s privileges, these
detailed response codes must be used only when a certain level of
security is already available, which can be achieved only when the
client is authenticated.[¶](#section-5.10.2-4){.pilcrow}

Note: The RS [MAY]{.bcp14} use introspection for timely validation of an
access token at the time when a request is
presented.[¶](#section-5.10.2-5){.pilcrow}

Note: Matching the claims of the access token (e.g., `scope`) to a
specific request is application
specific.[¶](#section-5.10.2-6){.pilcrow}

If the request matches a valid token and the client has performed the
proof of possession for that token, the RS continues to process the
request as specified by the underlying
application.[¶](#section-5.10.2-7){.pilcrow}
:::
:::

::: {#tokenExpiration}
::: {#section-5.10.3 .section}
#### [5.10.3.](#section-5.10.3){.section-number .selfRef} [Token Expiration](#name-token-expiration){.section-name .selfRef} {#name-token-expiration}

Depending on the capabilities of the RS, there are various ways in which
it can verify the expiration of a received access token. The following
is a list of the possibilities including what functionality they require
of the RS.[¶](#section-5.10.3-1){.pilcrow}

-   [The token is a CWT and includes an `exp` claim and possibly the
    `nbf` claim. The RS verifies these by comparing them to values from
    its internal clock, as defined in \[[RFC7519](#RFC7519){.xref}\]. In
    this case, the RS\'s internal clock must reflect the current date
    and time or at least be synchronized with the AS\'s clock. How this
    clock synchronization would be performed is out of scope for this
    specification.[¶](#section-5.10.3-2.1){.pilcrow}]{#section-5.10.3-2.1}

-   [The RS verifies the validity of the token by performing an
    introspection request, as specified in [Section
    5.9](#introspectionEndpoint){.xref}. This requires the RS to have a
    reliable network connection to the AS and to be able to handle two
    secure sessions in parallel (C to RS and RS to
    AS).[¶](#section-5.10.3-2.2){.pilcrow}]{#section-5.10.3-2.2}

-   [In order to support token expiration for devices that have no
    reliable way of synchronizing their internal clocks, this
    specification defines the following approach: The claim `exi`
    (expires in) can be used to provide the RS with the lifetime of the
    token in seconds from the time the RS first receives the token. This
    mechanism only works for self-contained tokens, i.e., CWTs and JWTs.
    For CWTs, this parameter is encoded as an unsigned integer, while
    JWTs encode this as JSON
    number.[¶](#section-5.10.3-2.3){.pilcrow}]{#section-5.10.3-2.3}

-   ::: {#section-5.10.3-2.4}
    Processing this claim requires that the RS does the
    following:[¶](#section-5.10.3-2.4.1){.pilcrow}

    -   [For each token the RS receives that contains an `exi` claim,
        keep track of the time it received that token and revisit that
        list regularly to expunge expired
        tokens.[¶](#section-5.10.3-2.4.2.1){.pilcrow}]{#section-5.10.3-2.4.2.1}

    -   ::: {#section-5.10.3-2.4.2.2}
        Keep track of the identifiers of tokens containing the `exi`
        claim that have expired (in order to avoid accepting them
        again). In order to avoid an unbounded memory usage growth, this
        [MUST]{.bcp14} be implemented in the following way when the
        `exi` claim is used:[¶](#section-5.10.3-2.4.2.2.1){.pilcrow}

        -   [When creating the token, the AS [MUST]{.bcp14} add a `cti`
            claim (or `jti` for JWTs) to the access token. The value of
            this claim [MUST]{.bcp14} be created as the binary
            representation of the concatenation of the identifier of the
            RS with a sequence number counting the tokens containing an
            `exi` claim, issued by this AS for the
            RS.[¶](#section-5.10.3-2.4.2.2.2.1){.pilcrow}]{#section-5.10.3-2.4.2.2.2.1}
        -   [The RS [MUST]{.bcp14} store the highest sequence number of
            an expired token containing the `exi` claim that it has seen
            and treat tokens with lower sequence numbers as expired.
            Note that this could lead to discarding valid tokens with
            lower sequence numbers if the AS where to issue tokens of
            different validity time for the same RS. The assumption is
            that typically tokens in such a scenario would all have the
            same validity
            time.[¶](#section-5.10.3-2.4.2.2.2.2){.pilcrow}]{#section-5.10.3-2.4.2.2.2.2}
        :::
    :::

If a token that authorizes a long-running request, such as a CoAP
Observe \[[RFC7641](#RFC7641){.xref}\], expires, the RS [MUST]{.bcp14}
send an error response with the response code equivalent to the CoAP
code 4.01 (Unauthorized) to the client and then terminate processing the
long-running request.[¶](#section-5.10.3-3){.pilcrow}
:::
:::

::: {#keyExpiration}
::: {#section-5.10.4 .section}
#### [5.10.4.](#section-5.10.4){.section-number .selfRef} [Key Expiration](#name-key-expiration){.section-name .selfRef} {#name-key-expiration}

The AS provides the client with key material that the RS uses. This can
either be a common symmetric PoP key or an asymmetric key used by the RS
to authenticate towards the client. Since there is currently no
expiration metadata associated to those keys, the client has no way of
knowing if these keys are still valid. This may lead to situations where
the client sends requests containing sensitive information to the RS
using a key that is expired and possibly in the hands of an attacker or
where the client accepts responses from the RS that are not properly
protected and could possibly have been forged by an
attacker.[¶](#section-5.10.4-1){.pilcrow}

In order to prevent this, the client must assume that those keys are
only valid as long as the related access token is. Since the access
token is opaque to the client, one of the following methods
[MUST]{.bcp14} be used to inform the client about the validity of an
access token:[¶](#section-5.10.4-2){.pilcrow}

-   [The client knows a default validity time for all tokens it is using
    (i.e., how long a token is valid after being issued). This
    information could be provisioned to the client when it is registered
    at the AS or published by the AS in a way that the client can
    query.[¶](#section-5.10.4-3.1){.pilcrow}]{#section-5.10.4-3.1}
-   [The AS informs the client about the token validity using the
    `expires_in` parameter in the Access
    Information.[¶](#section-5.10.4-3.2){.pilcrow}]{#section-5.10.4-3.2}

A client that is not able to obtain information about the expiration of
a token [MUST NOT]{.bcp14} use this
token.[¶](#section-5.10.4-4){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#security}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

Security considerations applicable to authentication and authorization
in RESTful environments provided in OAuth 2.0
\[[RFC6749](#RFC6749){.xref}\] apply to this work. Furthermore,
\[[RFC6819](#RFC6819){.xref}\] provides additional security
considerations for OAuth, which apply to IoT deployments as well. If the
introspection endpoint is used, the security considerations from
\[[RFC7662](#RFC7662){.xref}\] also apply.[¶](#section-6-1){.pilcrow}

The following subsections address issues specific to this document and
its use in constrained environments.[¶](#section-6-2){.pilcrow}

::: {#tokenProtection}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Protecting Tokens](#name-protecting-tokens){.section-name .selfRef} {#name-protecting-tokens}

A large range of threats can be mitigated by protecting the contents of
the access token by using a digital signature or a keyed message digest,
e.g., a Message Authentication Code (MAC) or an Authenticated Encryption
with Associated Data (AEAD) algorithm. Consequently, the token integrity
protection [MUST]{.bcp14} be applied to prevent the token from being
modified, particularly since it contains a reference to the symmetric
key or the asymmetric key used for proof of possession. If the access
token contains the symmetric key, this symmetric key [MUST]{.bcp14} be
encrypted by the authorization server so that only the resource server
can decrypt it. Note that using an AEAD algorithm is preferable over
using a MAC unless the token needs to be publicly
readable.[¶](#section-6.1-1){.pilcrow}

If the token is intended for multiple recipients (i.e., an audience that
is a group), integrity protection of the token with a symmetric key,
shared between the AS and the recipients, is not sufficient, since any
of the recipients could modify the token undetected by the other
recipients. Therefore, a token with a multirecipient audience
[MUST]{.bcp14} be protected with an asymmetric
signature.[¶](#section-6.1-2){.pilcrow}

It is important for the authorization server to include the identity of
the intended recipient (the audience), typically a single resource
server (or a list of resource servers), in the token. The same shared
secret [MUST NOT]{.bcp14} be used as a proof-of-possession key with
multiple resource servers, since the benefit from using the
proof-of-possession concept is then significantly
reduced.[¶](#section-6.1-3){.pilcrow}

If clients are capable of doing so, they should frequently request fresh
access tokens, as this allows the AS to keep the lifetime of the tokens
short. This allows the AS to use shorter proof-of-possession key sizes,
which translate to a performance benefit for the client and for the
resource server. Shorter keys also lead to shorter messages
(particularly with asymmetric keying
material).[¶](#section-6.1-4){.pilcrow}

When authorization servers bind symmetric keys to access tokens, they
[SHOULD]{.bcp14} scope these access tokens to a specific
permission.[¶](#section-6.1-5){.pilcrow}

In certain situations, it may be necessary to revoke an access token
that is still valid. Client-initiated revocation is specified in
\[[RFC7009](#RFC7009){.xref}\] for OAuth 2.0. Other revocation
mechanisms are currently not specified, as the underlying assumption in
OAuth is that access tokens are issued with a relatively short lifetime.
This may not hold true for disconnected constrained devices needing
access tokens with relatively long lifetimes and would therefore
necessitate further standardization work that is out of scope for this
document.[¶](#section-6.1-6){.pilcrow}
:::
:::

::: {#commSec}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Communication Security](#name-communication-security){.section-name .selfRef} {#name-communication-security}

Communication with the authorization server [MUST]{.bcp14} use
confidentiality protection. This step is extremely important since the
client or the RS may obtain the proof-of-possession key from the
authorization server for use with a specific access token. Not using
confidentiality protection exposes this secret (and the access token) to
an eavesdropper, thereby completely negating proof-of-possession
security. The requirements for communication security of profiles are
specified in [Section
5](#oauthProfile){.xref}.[¶](#section-6.2-1){.pilcrow}

Additional protection for the access token can be applied by encrypting
it, for example, encryption of CWTs is specified in [Section
7.1](https://www.rfc-editor.org/rfc/rfc8392#section-7.1){.relref} of
\[[RFC8392](#RFC8392){.xref}\]. Such additional protection can be
necessary if the token is later transferred over an insecure connection
(e.g., when it is sent to the authz-info
endpoint).[¶](#section-6.2-2){.pilcrow}

Care must be taken by developers to prevent leakage of the PoP
credentials (i.e., the private key or the symmetric key). An adversary
in possession of the PoP credentials bound to the access token will be
able to impersonate the client. Be aware that this is a real risk with
many constrained environments, since adversaries may get physical access
to the devices and can therefore use physical extraction techniques to
gain access to memory contents. This risk can be mitigated to some
extent by making sure that keys are refreshed frequently, by using
software isolation techniques, and by using hardware
security.[¶](#section-6.2-3){.pilcrow}
:::
:::

::: {#keys}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Long-Term Credentials](#name-long-term-credentials){.section-name .selfRef} {#name-long-term-credentials}

Both the clients and RSs have long-term credentials that are used to
secure communications and authenticate to the AS. These credentials need
to be protected against unauthorized access. In constrained devices
deployed in publicly accessible places, such protection can be difficult
to achieve without specialized hardware (e.g., secure key storage
memory).[¶](#section-6.3-1){.pilcrow}

If credentials are lost or compromised, the operator of the affected
devices needs to have procedures to invalidate any access these
credentials give and needs to revoke tokens linked to such credentials.
The loss of a credential linked to a specific device [MUST NOT]{.bcp14}
lead to a compromise of other credentials not linked to that device;
therefore, secret keys used for authentication [MUST NOT]{.bcp14} be
shared between more than two parties.[¶](#section-6.3-2){.pilcrow}

Operators of the clients or RSs [SHOULD]{.bcp14} have procedures in
place to replace credentials that are suspected to have been compromised
or that have been lost.[¶](#section-6.3-3){.pilcrow}

Operators also [SHOULD]{.bcp14} have procedures for decommissioning
devices that include securely erasing credentials and other
security-critical material in the devices being
decommissioned.[¶](#section-6.3-4){.pilcrow}
:::
:::

::: {#unprotected-as-information}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [Unprotected AS Request Creation Hints](#name-unprotected-as-request-crea){.section-name .selfRef} {#name-unprotected-as-request-crea}

Initially, no secure channel exists to protect the communication between
the C and RS. Thus, the C cannot determine if the AS Request Creation
Hints contained in an unprotected response from the RS to an
unauthorized request (see [Section 5.3](#asInfo){.xref}) are authentic.
Therefore, the C [MUST]{.bcp14} determine if an AS is authorized to
provide access tokens for a certain RS. How this determination is
implemented is out of scope for this document and left to the
applications.[¶](#section-6.4-1){.pilcrow}
:::
:::

::: {#minimalCommSecReq}
::: {#section-6.5 .section}
### [6.5.](#section-6.5){.section-number .selfRef} [Minimal Security Requirements for Communication](#name-minimal-security-requiremen){.section-name .selfRef} {#name-minimal-security-requiremen}

This section summarizes the minimal requirements for the communication
security of the different protocol
interactions.[¶](#section-6.5-1){.pilcrow}

[]{.break}

C-AS
:   All communication between the client and the authorization server
    [MUST]{.bcp14} be encrypted and integrity and replay protected.
    Furthermore, responses from the AS to the client [MUST]{.bcp14} be
    bound to the client\'s request to avoid attacks where the attacker
    swaps the intended response for an older one valid for a previous
    request. This requires that the client and the authorization server
    have previously exchanged either a shared secret or their public
    keys in order to negotiate a secure communication. Furthermore, the
    client [MUST]{.bcp14} be able to determine whether an AS has the
    authority to issue access tokens for a certain RS. This can, for
    example, be done through preconfigured lists or through an online
    lookup mechanism that in turn also must be
    secured.[¶](#section-6.5-2.2){.pilcrow}
:   

RS-AS
:   The communication between the resource server and the authorization
    server via the introspection endpoint [MUST]{.bcp14} be encrypted
    and integrity and replay protected. Furthermore, responses from the
    AS to the RS [MUST]{.bcp14} be bound to the RS\'s request. This
    requires that the RS and the authorization server have previously
    exchanged either a shared secret or their public keys in order to
    negotiate a secure communication. Furthermore, the RS [MUST]{.bcp14}
    be able to determine whether an AS has the authority to issue access
    tokens itself. This is usually configured out of band but could also
    be performed through an online lookup mechanism, provided that it is
    also secured in the same way.[¶](#section-6.5-2.4){.pilcrow}
:   

C-RS
:   The initial communication between the client and the resource server
    cannot be secured in general, since the RS is not in possession of
    on access token for that client, which would carry the necessary
    parameters. If both parties support DTLS without client
    authentication, it is [RECOMMENDED]{.bcp14} to use this mechanism
    for protecting the initial communication. After the client has
    successfully transmitted the access token to the RS, a secure
    communication protocol [MUST]{.bcp14} be established between the
    client and RS for the actual resource request. This protocol
    [MUST]{.bcp14} provide confidentiality, integrity, and replay
    protection, as well as a binding between requests and responses.
    This requires that the client learned either the RS\'s public key or
    received a symmetric proof-of-possession key bound to the access
    token from the AS. The RS must have learned either the client\'s
    public key, a shared symmetric key from the claims in the token, or
    an introspection request. Since ACE does not provide profile
    negotiation between the C and RS, the client [MUST]{.bcp14} have
    learned what profile the RS supports (e.g., from the AS or
    preconfigured) and initiated the communication
    accordingly.[¶](#section-6.5-2.6){.pilcrow}
:   
:::
:::

::: {#nonce}
::: {#section-6.6 .section}
### [6.6.](#section-6.6){.section-number .selfRef} [Token Freshness and Expiration](#name-token-freshness-and-expirat){.section-name .selfRef} {#name-token-freshness-and-expirat}

An RS that is offline faces the problem of clock drift. Since it cannot
synchronize its clock with the AS, it may be tricked into accepting old
access tokens that are no longer valid or have been compromised. In
order to prevent this, an RS may use the nonce-based mechanism
(`cnonce`) defined in [Section 5.3](#asInfo){.xref} to ensure freshness
of an Access Token subsequently presented to this
RS.[¶](#section-6.6-1){.pilcrow}

Another problem with clock drift is that evaluating the standard token
expiration claim `exp` can give unpredictable
results.[¶](#section-6.6-2){.pilcrow}

Acceptable ranges of clock drift are highly dependent on the concrete
application. Important factors are how long access tokens are valid and
how critical timely expiration of the access token
is.[¶](#section-6.6-3){.pilcrow}

The expiration mechanism implemented by the `exi` claim, based on the
first time the RS sees the token, was defined to provide a more
predictable alternative. The `exi` approach has some drawbacks that need
to be considered:[¶](#section-6.6-4){.pilcrow}

-   [A malicious client may hold back tokens with the `exi` claim in
    order to prolong their
    lifespan.[¶](#section-6.6-5.1){.pilcrow}]{#section-6.6-5.1}
-   [If an RS loses state (e.g., due to an unscheduled reboot), it may
    lose the current values of counters tracking the `exi` claims of
    tokens it is
    storing.[¶](#section-6.6-5.2){.pilcrow}]{#section-6.6-5.2}

The first drawback is inherent to the deployment scenario and the `exi`
solution. It can therefore not be mitigated without requiring the RS be
online at times. The second drawback can be mitigated by regularly
storing the value of `exi` counters to persistent
memory.[¶](#section-6.6-6){.pilcrow}
:::
:::

::: {#mixnmatch}
::: {#section-6.7 .section}
### [6.7.](#section-6.7){.section-number .selfRef} [Combining Profiles](#name-combining-profiles){.section-name .selfRef} {#name-combining-profiles}

There may be use cases where different transport and security protocols
are allowed for the different interactions, and, if that is not
explicitly covered by an existing profile, it corresponds to combining
profiles into a new one. For example, a new profile could specify that a
previously defined MQTT-TLS profile is used between the client and the
RS in combination with a previously defined CoAP-DTLS profile for
interactions between the client and the AS. The new profile that
combines existing profiles [MUST]{.bcp14} specify how the existing
profiles\' security requirements remain satisfied. Therefore, any
profile [MUST]{.bcp14} clearly specify its security requirements and
[MUST]{.bcp14} document if its security depends on the combination of
various protocol interactions.[¶](#section-6.7-1){.pilcrow}
:::
:::

::: {#infoLeak}
::: {#section-6.8 .section}
### [6.8.](#section-6.8){.section-number .selfRef} [Unprotected Information](#name-unprotected-information){.section-name .selfRef} {#name-unprotected-information}

Communication with the authz-info endpoint, as well as the various error
responses defined in this framework, potentially includes sending
information over an unprotected channel. These messages may leak
information to an adversary or may be manipulated by active attackers to
induce incorrect behavior. For example, error responses for requests to
the authorization information endpoint can reveal information about an
otherwise opaque access token to an adversary who has intercepted this
token.[¶](#section-6.8-1){.pilcrow}

As far as error messages are concerned, this framework is written under
the assumption that, in general, the benefits of detailed error messages
outweigh the risk due to information leakage. For particular use cases
where this assessment does not apply, detailed error messages can be
replaced by more generic ones.[¶](#section-6.8-2){.pilcrow}

In some scenarios, it may be possible to protect the communication with
the authz-info endpoint (e.g., through DTLS with only server-side
authentication). In cases where this is not possible, it is
[RECOMMENDED]{.bcp14} to use encrypted CWTs or tokens that are opaque
references and need to be subjected to introspection by the
RS.[¶](#section-6.8-3){.pilcrow}

If the initial Unauthorized Resource Request message (see [Section
5.2](#rreq){.xref}) is used, the client [MUST]{.bcp14} make sure that it
is not sending sensitive content in this request. While GET and DELETE
requests only reveal the target URI of the resource, POST and PUT
requests would reveal the whole payload of the intended
operation.[¶](#section-6.8-4){.pilcrow}

Since the client is not authenticated at the point when it is submitting
an access token to the authz-info endpoint, attackers may be pretending
to be a client and trying to trick an RS to use an obsolete profile that
in turn specifies a vulnerable security mechanism via the authz-info
endpoint. Such an attack would require a valid access token containing
an `ace_profile` claim requesting the use of said obsolete profile.
Resource owners should update the configuration of their RSs to prevent
them from using such obsolete profiles.[¶](#section-6.8-5){.pilcrow}
:::
:::

::: {#audience}
::: {#section-6.9 .section}
### [6.9.](#section-6.9){.section-number .selfRef} [Identifying Audiences](#name-identifying-audiences){.section-name .selfRef} {#name-identifying-audiences}

The `aud` claim, as defined in \[[RFC7519](#RFC7519){.xref}\], and the
equivalent `audience` parameter from \[[RFC8693](#RFC8693){.xref}\] are
intentionally vague on how to match the audience value to a specific RS.
This is intended to allow application-specific semantics to be used.
This section attempts to give some general guidance for the use of
audiences in constrained environments.[¶](#section-6.9-1){.pilcrow}

URLs are not a good way of identifying mobile devices that can switch
networks and thus be associated with new URLs. If the audience
represents a single RS and asymmetric keys are used, the RS can be
uniquely identified by a hash of its public key. If this approach is
used, it is [RECOMMENDED]{.bcp14} to apply the procedure from [Section
3](https://www.rfc-editor.org/rfc/rfc6920#section-3){.relref} of
\[[RFC6920](#RFC6920){.xref}\].[¶](#section-6.9-2){.pilcrow}

If the audience addresses a group of resource servers, the mapping of a
group identifier to an individual RS has to be provisioned to each RS
before the group-audience is usable. Managing dynamic groups could be an
issue if any RS is not always reachable when the groups\' memberships
change. Furthermore, issuing access tokens bound to symmetric
proof-of-possession keys that apply to a group-audience is problematic,
as an RS that is in possession of the access token can impersonate the
client towards the other RSs that are part of the group. It is therefore
[NOT RECOMMENDED]{.bcp14} to issue access tokens bound to a
group-audience and symmetric proof-of possession
keys.[¶](#section-6.9-3){.pilcrow}

Even the client must be able to determine the correct values to put into
the `audience` parameter in order to obtain a token for the intended RS.
Errors in this process can lead to the client inadvertently obtaining a
token for the wrong RS. The correct values for `audience` can either be
provisioned to the client as part of its configuration or dynamically
looked up by the client in some directory. In the latter case, the
integrity and correctness of the directory data must be assured. Note
that the `audience` hint provided by the RS as part of the AS Request
Creation Hints ([Section 5.3](#asInfo){.xref}) is not typically source
authenticated and integrity protected and should therefore not be
treated a trusted value.[¶](#section-6.9-4){.pilcrow}
:::
:::

::: {#introDos}
::: {#section-6.10 .section}
### [6.10.](#section-6.10){.section-number .selfRef} [Denial of Service Against or with Introspection](#name-denial-of-service-against-o){.section-name .selfRef} {#name-denial-of-service-against-o}

The optional introspection mechanism provided by OAuth and supported in
the ACE framework allows for two types of attacks that need to be
considered by implementers.[¶](#section-6.10-1){.pilcrow}

First, an attacker could perform a denial-of-service attack against the
introspection endpoint at the AS in order to prevent validation of
access tokens. To maintain the security of the system, an RS that is
configured to use introspection [MUST NOT]{.bcp14} allow access based on
a token for which it couldn\'t reach the introspection
endpoint.[¶](#section-6.10-2){.pilcrow}

Second, an attacker could use the fact that an RS performs introspection
to perform a denial-of-service attack against that RS by repeatedly
sending tokens to its authz-info endpoint that require an introspection
call. The RS can mitigate such attacks by implementing rate limits on
how many introspection requests they perform in a given time interval
for a certain client IP address submitting tokens to /authz-info. When
that limit has been reached, incoming requests from that address are
rejected for a certain amount of time. A general rate limit on the
introspection requests should also be considered in order to mitigate
distributed attacks.[¶](#section-6.10-3){.pilcrow}
:::
:::
:::
:::

::: {#privacy}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Privacy Considerations](#name-privacy-considerations){.section-name .selfRef} {#name-privacy-considerations}

Implementers and users should be aware of the privacy implications of
the different possible deployments of this
framework.[¶](#section-7-1){.pilcrow}

The AS is in a very central position and can potentially learn sensitive
information about the clients requesting access tokens. If the client
credentials grant is used, the AS can track what kind of access the
client intends to perform. With other grants, this can be prevented by
the resource owner. To do so, the resource owner needs to bind the
grants it issues to anonymous, ephemeral credentials that do not allow
the AS to link different grants and thus different access token requests
by the same client.[¶](#section-7-2){.pilcrow}

The claims contained in a token can reveal privacy-sensitive information
about the client and the RS to any party having access to them (whether
by processing the content of a self-contained token or by
introspection). The AS [SHOULD]{.bcp14} be configured to minimize the
information about clients and RSs disclosed in the tokens it
issues.[¶](#section-7-3){.pilcrow}

If tokens are only integrity protected and not encrypted, they may
reveal information to attackers listening on the wire or be able to
acquire the access tokens in some other way. In the case of CWTs, the
token may, e.g., reveal the audience, the scope, and the confirmation
method used by the client. The latter may reveal the identity of the
device or application running the client. This may be linkable to the
identity of the person using the client (if there is a person and not a
machine-to-machine interaction).[¶](#section-7-4){.pilcrow}

Clients using asymmetric keys for proof of possession should be aware of
the consequences of using the same key pair for proof of possession
towards different RSs. A set of colluding RSs or an attacker able to
obtain the access tokens will be able to link the requests or even to
determine the client\'s identity.[¶](#section-7-5){.pilcrow}

An unprotected response to an unauthorized request (see [Section
5.3](#asInfo){.xref}) may disclose information about the RS and/or its
existing relationship with the C. It is advisable to include as little
information as possible in an unencrypted response. Even the absolute
URI of the AS may reveal sensitive information about the service that
the RS provides. Developers must ensure that the RS does not disclose
information that has an impact on the privacy of the stakeholders in the
AS Request Creation Hints. They may choose to use a different mechanism
for the discovery of the AS if necessary. If means of encrypting
communication between the C and RS already exist, more detailed
information may be included with an error response to provide the C with
sufficient information to react on that particular
error.[¶](#section-7-6){.pilcrow}
:::
:::

::: {#iana}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document creates several registries with a registration policy of
Expert Review; guidelines to the experts are given in [Section
8.17](#IANAinstructions){.xref}.[¶](#section-8-1){.pilcrow}

::: {#IANAASInformation}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [ACE Authorization Server Request Creation Hints](#name-ace-authorization-server-re){.section-name .selfRef} {#name-ace-authorization-server-re}

This specification establishes the IANA \"ACE Authorization Server
Request Creation Hints\" registry.[¶](#section-8.1-1){.pilcrow}

The columns of the registry are:[¶](#section-8.1-2){.pilcrow}

[]{.break}

Name:
:   The name of the parameter.[¶](#section-8.1-3.2){.pilcrow}
:   

CBOR Key:
:   CBOR map key for the parameter. Different ranges of values use
    different registration policies \[[RFC8126](#RFC8126){.xref}\].
    Integer values from -256 to 255 are designated as Standards Action.
    Integer values from -65536 to -257 and from 256 to 65535 are
    designated as Specification Required. Integer values greater than
    65535 are designated as Expert Review. Integer values less than
    -65536 are marked as Private Use.[¶](#section-8.1-3.4){.pilcrow}
:   

Value Type:
:   The CBOR data types allowable for the values of this
    parameter.[¶](#section-8.1-3.6){.pilcrow}
:   

Reference:
:   This contains a pointer to the public specification of the Request
    Creation Hint abbreviation, if one
    exists.[¶](#section-8.1-3.8){.pilcrow}
:   

This registry has been initially populated by the values in [Table
1](#table_asinfo){.xref}. The Reference column for all of these entries
is this document.[¶](#section-8.1-4){.pilcrow}
:::
:::

::: {#IANAcoreRT}
::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [CoRE Resource Types](#name-core-resource-types){.section-name .selfRef} {#name-core-resource-types}

IANA has registered a new Resource Type (rt=) Link Target Attribute in
the \"Resource Type (rt=) Link Target Attribute Values\" subregistry
under the \"Constrained RESTful Environments (CoRE) Parameters\"
\[[IANA.CoreParameters](#IANA.CoreParameters){.xref}\]
registry:[¶](#section-8.2-1){.pilcrow}

[]{.break}

Value:
:   `ace.ai`[¶](#section-8.2-2.2){.pilcrow}
:   

Description:
:   ACE-OAuth authz-info endpoint
    resource.[¶](#section-8.2-2.4){.pilcrow}
:   

Reference:
:   RFC 9200[¶](#section-8.2-2.6){.pilcrow}
:   

Specific ACE-OAuth profiles can use this common resource type for
defining their profile-specific discovery
processes.[¶](#section-8.2-3){.pilcrow}
:::
:::

::: {#IANAOAuthErrorCodes}
::: {#section-8.3 .section}
### [8.3.](#section-8.3){.section-number .selfRef} [OAuth Extensions Errors](#name-oauth-extensions-errors){.section-name .selfRef} {#name-oauth-extensions-errors}

This specification registers the following error values in the \"OAuth
Extensions Error Registry\"
\[[IANA.OAuthExtensionsErrorRegistry](#IANA.OAuthExtensionsErrorRegistry){.xref}\].[¶](#section-8.3-1){.pilcrow}

[]{.break}

Name:
:   `unsupported_pop_key`[¶](#section-8.3-2.2){.pilcrow}
:   

Usage Location:
:   token error response[¶](#section-8.3-2.4){.pilcrow}
:   

Protocol Extension:
:   RFC 9200[¶](#section-8.3-2.6){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-8.3-2.8){.pilcrow}
:   

Reference:
:   [Section 5.8.3](#errorsToken){.xref} of RFC
    9200[¶](#section-8.3-2.10){.pilcrow}
:   

[]{.break}

Name:
:   `incompatible_ace_profiles`[¶](#section-8.3-3.2){.pilcrow}
:   

Usage Location:
:   token error response[¶](#section-8.3-3.4){.pilcrow}
:   

Protocol Extension:
:   RFC 9200[¶](#section-8.3-3.6){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-8.3-3.8){.pilcrow}
:   

Reference:
:   [Section 5.8.3](#errorsToken){.xref} of RFC
    9200[¶](#section-8.3-3.10){.pilcrow}
:   
:::
:::

::: {#IANAErrorCBORMappings}
::: {#section-8.4 .section}
### [8.4.](#section-8.4){.section-number .selfRef} [OAuth Error Code CBOR Mappings](#name-oauth-error-code-cbor-mappi){.section-name .selfRef} {#name-oauth-error-code-cbor-mappi}

This specification establishes the IANA \"OAuth Error Code CBOR
Mappings\" registry.[¶](#section-8.4-1){.pilcrow}

The columns of the registry are:[¶](#section-8.4-2){.pilcrow}

[]{.break}

Name:
:   The OAuth Error Code name, refers to the name in [Section
    5.2](https://www.rfc-editor.org/rfc/rfc6749#section-5.2){.relref} of
    \[[RFC6749](#RFC6749){.xref}\], e.g.,
    \"invalid_request\".[¶](#section-8.4-3.2){.pilcrow}
:   

CBOR Value:
:   CBOR abbreviation for this error code. Integer values less than
    -65536 are marked as Private Use; all other values use the
    registration policy Expert Review
    \[[RFC8126](#RFC8126){.xref}\].[¶](#section-8.4-3.4){.pilcrow}
:   

Reference:
:   This contains a pointer to the public specification of the error
    code abbreviation, if one exists.[¶](#section-8.4-3.6){.pilcrow}
:   

Original Specification:
:   This contains a pointer to the public specification of the error
    code, if one exists.[¶](#section-8.4-3.8){.pilcrow}
:   

This registry has been initially populated by the values in [Table
3](#table_cborErrorCodes){.xref}. The Reference column for all of these
entries is this document.[¶](#section-8.4-4){.pilcrow}
:::
:::

::: {#IANAGrantTypeMappings}
::: {#section-8.5 .section}
### [8.5.](#section-8.5){.section-number .selfRef} [OAuth Grant Type CBOR Mappings](#name-oauth-grant-type-cbor-mappi){.section-name .selfRef} {#name-oauth-grant-type-cbor-mappi}

This specification establishes the IANA \"OAuth Grant Type CBOR
Mappings\" registry.[¶](#section-8.5-1){.pilcrow}

The columns of this registry are:[¶](#section-8.5-2){.pilcrow}

[]{.break}

Name:
:   The name of the grant type, as specified in [Section
    1.3](https://www.rfc-editor.org/rfc/rfc6749#section-1.3){.relref} of
    \[[RFC6749](#RFC6749){.xref}\].[¶](#section-8.5-3.2){.pilcrow}
:   

CBOR Value:
:   CBOR abbreviation for this grant type. Integer values less than
    -65536 are marked as Private Use; all other values use the
    registration policy Expert Review
    \[[RFC8126](#RFC8126){.xref}\].[¶](#section-8.5-3.4){.pilcrow}
:   

Reference:
:   This contains a pointer to the public specification of the grant
    type abbreviation, if one exists.[¶](#section-8.5-3.6){.pilcrow}
:   

Original Specification:
:   This contains a pointer to the public specification of the grant
    type, if one exists.[¶](#section-8.5-3.8){.pilcrow}
:   

This registry has been initially populated by the values in [Table
4](#table_grant_types){.xref}. The Reference column for all of these
entries is this document.[¶](#section-8.5-4){.pilcrow}
:::
:::

::: {#IANAOAuthTokenType}
::: {#section-8.6 .section}
### [8.6.](#section-8.6){.section-number .selfRef} [OAuth Access Token Types](#name-oauth-access-token-types){.section-name .selfRef} {#name-oauth-access-token-types}

This section registers the following new token type in the \"OAuth
Access Token Types\" registry
\[[IANA.OAuthAccessTokenTypes](#IANA.OAuthAccessTokenTypes){.xref}\].[¶](#section-8.6-1){.pilcrow}

[]{.break}

Name:
:   `PoP`[¶](#section-8.6-2.2){.pilcrow}
:   

Additional Token Endpoint Response Parameters:
:   `cnf`, `rs_cnf` (see [Section
    3.1](https://www.rfc-editor.org/rfc/rfc8747#section-3.1){.relref} of
    \[[RFC8747](#RFC8747){.xref}\] and [Section
    3.2](https://www.rfc-editor.org/rfc/rfc9201#section-3.2){.relref} of
    \[[RFC9201](#RFC9201){.xref}\]).[¶](#section-8.6-2.4){.pilcrow}
:   

HTTP Authentication Scheme(s):
:   N/A[¶](#section-8.6-2.6){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-8.6-2.8){.pilcrow}
:   

Reference:
:   RFC 9200[¶](#section-8.6-2.10){.pilcrow}
:   
:::
:::

::: {#IANATokenTypeMappings}
::: {#section-8.7 .section}
### [8.7.](#section-8.7){.section-number .selfRef} [OAuth Access Token Type CBOR Mappings](#name-oauth-access-token-type-cbo){.section-name .selfRef} {#name-oauth-access-token-type-cbo}

This specification establishes the IANA \"OAuth Access Token Type CBOR
Mappings\" registry.[¶](#section-8.7-1){.pilcrow}

The columns of this registry are:[¶](#section-8.7-2){.pilcrow}

[]{.break}

Name:
:   The name of the token type, as registered in the \"OAuth Access
    Token Types\" registry, e.g.,
    \"Bearer\".[¶](#section-8.7-3.2){.pilcrow}
:   

CBOR Value:
:   CBOR abbreviation for this token type. Integer values less than
    -65536 are marked as Private Use; all other values use the
    registration policy Expert Review
    \[[RFC8126](#RFC8126){.xref}\].[¶](#section-8.7-3.4){.pilcrow}
:   

Reference:
:   This contains a pointer to the public specification of the OAuth
    token type abbreviation, if one
    exists.[¶](#section-8.7-3.6){.pilcrow}
:   

Original Specification:
:   This contains a pointer to the public specification of the OAuth
    token type, if one exists.[¶](#section-8.7-3.8){.pilcrow}
:   

::: {#IANATokenTypeMappingsInitial}
::: {#section-8.7.1 .section}
#### [8.7.1.](#section-8.7.1){.section-number .selfRef} [Initial Registry Contents](#name-initial-registry-contents){.section-name .selfRef} {#name-initial-registry-contents}

[]{.break}

Name:
:   `Bearer`[¶](#section-8.7.1-1.2){.pilcrow}
:   

CBOR Value:
:   1[¶](#section-8.7.1-1.4){.pilcrow}
:   

Reference:
:   RFC 9200[¶](#section-8.7.1-1.6){.pilcrow}
:   

Original Specification:
:   \[[RFC6749](#RFC6749){.xref}\][¶](#section-8.7.1-1.8){.pilcrow}
:   

[]{.break}

Name:
:   `PoP`[¶](#section-8.7.1-2.2){.pilcrow}
:   

CBOR Value:
:   2[¶](#section-8.7.1-2.4){.pilcrow}
:   

Reference:
:   RFC 9200[¶](#section-8.7.1-2.6){.pilcrow}
:   

Original Specification:
:   RFC 9200[¶](#section-8.7.1-2.8){.pilcrow}
:   
:::
:::
:::
:::

::: {#IANAProfile}
::: {#section-8.8 .section}
### [8.8.](#section-8.8){.section-number .selfRef} [ACE Profiles](#name-ace-profiles){.section-name .selfRef} {#name-ace-profiles}

This specification establishes the IANA \"ACE Profile\"
registry.[¶](#section-8.8-1){.pilcrow}

The columns of this registry are:[¶](#section-8.8-2){.pilcrow}

[]{.break}

Name:
:   The name of the profile to be used as the value of the profile
    attribute.[¶](#section-8.8-3.2){.pilcrow}
:   

Description:
:   Text giving an overview of the profile and the context it is
    developed for.[¶](#section-8.8-3.4){.pilcrow}
:   

CBOR Value:
:   CBOR abbreviation for this profile name. Different ranges of values
    use different registration policies \[[RFC8126](#RFC8126){.xref}\].
    Integer values from -256 to 255 are designated as Standards Action.
    Integer values from -65536 to -257 and from 256 to 65535 are
    designated as Specification Required. Integer values greater than
    65535 are designated as Expert Review. Integer values less than
    -65536 are marked as Private Use.[¶](#section-8.8-3.6){.pilcrow}
:   

Reference:
:   This contains a pointer to the public specification of the profile
    abbreviation, if one exists.[¶](#section-8.8-3.8){.pilcrow}
:   
:::
:::

::: {#IANAOAuthParameter}
::: {#section-8.9 .section}
### [8.9.](#section-8.9){.section-number .selfRef} [OAuth Parameters](#name-oauth-parameters){.section-name .selfRef} {#name-oauth-parameters}

This specification registers the following parameter in the \"OAuth
Parameters\" registry
\[[IANA.OAuthParameters](#IANA.OAuthParameters){.xref}\]:[¶](#section-8.9-1){.pilcrow}

[]{.break}

Name:
:   `ace_profile`[¶](#section-8.9-2.2){.pilcrow}
:   

Parameter Usage Location:
:   token response[¶](#section-8.9-2.4){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-8.9-2.6){.pilcrow}
:   

Reference:
:   Sections [5.8.2](#tokenResponse){.xref} and
    [5.8.4.3](#paramProfile){.xref} of RFC
    9200[¶](#section-8.9-2.8){.pilcrow}
:   
:::
:::

::: {#IANAOAuthParameterMappingsRegistry}
::: {#section-8.10 .section}
### [8.10.](#section-8.10){.section-number .selfRef} [OAuth Parameters CBOR Mappings](#name-oauth-parameters-cbor-mappi){.section-name .selfRef} {#name-oauth-parameters-cbor-mappi}

This specification establishes the IANA \"OAuth Parameters CBOR
Mappings\" registry.[¶](#section-8.10-1){.pilcrow}

The columns of this registry are:[¶](#section-8.10-2){.pilcrow}

[]{.break}

Name:
:   The OAuth Parameter name, refers to the name in the OAuth parameter
    registry, e.g., `client_id`.[¶](#section-8.10-3.2){.pilcrow}
:   

CBOR Key:
:   CBOR map key for this parameter. Integer values less than -65536 are
    marked as Private Use; all other values use the registration policy
    Expert Review
    \[[RFC8126](#RFC8126){.xref}\].[¶](#section-8.10-3.4){.pilcrow}
:   

Value Type:
:   The allowable CBOR data types for values of this
    parameter.[¶](#section-8.10-3.6){.pilcrow}
:   

Reference:
:   This contains a pointer to the public specification of the OAuth
    parameter abbreviation, if one
    exists.[¶](#section-8.10-3.8){.pilcrow}
:   

Original Specification
:   This contains a pointer to the public specification of the OAuth
    parameter, if one exists.[¶](#section-8.10-3.10){.pilcrow}
:   

This registry has been initially populated by the values in [Table
5](#table_cborTokenParameters){.xref}. The Reference column for all of
these entries is this document.[¶](#section-8.10-4){.pilcrow}
:::
:::

::: {#IANAOAuthIntrospectionResponseParameterRegistration}
::: {#section-8.11 .section}
### [8.11.](#section-8.11){.section-number .selfRef} [OAuth Introspection Response Parameters](#name-oauth-introspection-respons){.section-name .selfRef} {#name-oauth-introspection-respons}

This specification registers the following parameters in the \"OAuth
Token Introspection Response\" registry
\[[IANA.TokenIntrospectionResponse](#IANA.TokenIntrospectionResponse){.xref}\].[¶](#section-8.11-1){.pilcrow}

[]{.break}

Name:
:   `ace_profile`[¶](#section-8.11-2.2){.pilcrow}
:   

Description:
:   The ACE profile used between the client and
    RS.[¶](#section-8.11-2.4){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-8.11-2.6){.pilcrow}
:   

Reference:
:   [Section 5.9.2](#introRes){.xref} of RFC
    9200[¶](#section-8.11-2.8){.pilcrow}
:   

[]{.break}

Name:
:   `cnonce`[¶](#section-8.11-3.2){.pilcrow}
:   

Description:
:   \"client-nonce\". A nonce previously provided to the AS by the RS
    via the client. Used to verify token freshness when the RS cannot
    synchronize its clock with the AS.[¶](#section-8.11-3.4){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-8.11-3.6){.pilcrow}
:   

Reference:
:   [Section 5.9.2](#introRes){.xref} of RFC
    9200[¶](#section-8.11-3.8){.pilcrow}
:   

[]{.break}

Name
:   `cti`[¶](#section-8.11-4.2){.pilcrow}
:   

Description
:   \"CWT ID\". The identifier of a CWT as defined in
    \[[RFC8392](#RFC8392){.xref}\].[¶](#section-8.11-4.4){.pilcrow}
:   

Change Controller
:   IETF[¶](#section-8.11-4.6){.pilcrow}
:   

Reference
:   [Section 5.9.2](#introRes){.xref} of RFC
    9200[¶](#section-8.11-4.8){.pilcrow}
:   

[]{.break}

Name:
:   `exi`[¶](#section-8.11-5.2){.pilcrow}
:   

Description:
:   \"Expires in\". Lifetime of the token in seconds from the time the
    RS first sees it. Used to implement a weaker form of token
    expiration for devices that cannot synchronize their internal
    clocks.[¶](#section-8.11-5.4){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-8.11-5.6){.pilcrow}
:   

Reference:
:   [Section 5.9.2](#introRes){.xref} of RFC
    9200[¶](#section-8.11-5.8){.pilcrow}
:   
:::
:::

::: {#IANAIntrospectionEndpointCBORMappingsRegistry}
::: {#section-8.12 .section}
### [8.12.](#section-8.12){.section-number .selfRef} [OAuth Token Introspection Response CBOR Mappings](#name-oauth-token-introspection-r){.section-name .selfRef} {#name-oauth-token-introspection-r}

This specification establishes the IANA \"OAuth Token Introspection
Response CBOR Mappings\" registry.[¶](#section-8.12-1){.pilcrow}

The columns of this registry are:[¶](#section-8.12-2){.pilcrow}

[]{.break}

Name:
:   The OAuth Parameter name, refers to the name in the OAuth parameter
    registry, e.g., `client_id`.[¶](#section-8.12-3.2){.pilcrow}
:   

CBOR Key:
:   CBOR map key for this parameter. Integer values less than -65536 are
    marked as Private Use; all other values use the registration policy
    Expert Review
    \[[RFC8126](#RFC8126){.xref}\].[¶](#section-8.12-3.4){.pilcrow}
:   

Value Type:
:   The allowable CBOR data types for values of this
    parameter.[¶](#section-8.12-3.6){.pilcrow}
:   

Reference:
:   This contains a pointer to the public specification of the
    introspection response parameter abbreviation, if one
    exists.[¶](#section-8.12-3.8){.pilcrow}
:   

Original Specification
:   This contains a pointer to the public specification of the OAuth
    Token Introspection parameter, if one
    exists.[¶](#section-8.12-3.10){.pilcrow}
:   

This registry has been initially populated by the values in [Table
6](#table_cborIntrospectionParameters){.xref}. The Reference column for
all of these entries is this document.[¶](#section-8.12-4){.pilcrow}

Note that the mappings of parameters corresponding to claim names
intentionally coincide with the CWT claim name mappings from
\[[RFC8392](#RFC8392){.xref}\].[¶](#section-8.12-5){.pilcrow}
:::
:::

::: {#IANAJWTClaims}
::: {#section-8.13 .section}
### [8.13.](#section-8.13){.section-number .selfRef} [JSON Web Token Claims](#name-json-web-token-claims){.section-name .selfRef} {#name-json-web-token-claims}

This specification registers the following new claims in the \"JSON Web
Token Claims\" subregistry under the \"JSON Web Token (JWT)\" registry
\[[IANA.JsonWebTokenClaims](#IANA.JsonWebTokenClaims){.xref}\]:[¶](#section-8.13-1){.pilcrow}

[]{.break}

Claim Name:
:   `ace_profile`[¶](#section-8.13-2.2){.pilcrow}
:   

Claim Description:
:   The ACE profile a token is supposed to be used
    with.[¶](#section-8.13-2.4){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-8.13-2.6){.pilcrow}
:   

Reference:
:   [Section 5.10](#accessToken){.xref} of RFC
    9200[¶](#section-8.13-2.8){.pilcrow}
:   

[]{.break}

Claim Name:
:   `cnonce`[¶](#section-8.13-3.2){.pilcrow}
:   

Claim Description:
:   \"client-nonce\". A nonce previously provided to the AS by the RS
    via the client. Used to verify token freshness when the RS cannot
    synchronize its clock with the AS.[¶](#section-8.13-3.4){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-8.13-3.6){.pilcrow}
:   

Reference:
:   [Section 5.10](#accessToken){.xref} of RFC
    9200[¶](#section-8.13-3.8){.pilcrow}
:   

[]{.break}

Claim Name:
:   `exi`[¶](#section-8.13-4.2){.pilcrow}
:   

Claim Description:
:   \"Expires in\". Lifetime of the token in seconds from the time the
    RS first sees it. Used to implement a weaker form of token
    expiration for devices that cannot synchronize their internal
    clocks.[¶](#section-8.13-4.4){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-8.13-4.6){.pilcrow}
:   

Reference:
:   [Section 5.10.3](#tokenExpiration){.xref} of RFC
    9200[¶](#section-8.13-4.8){.pilcrow}
:   
:::
:::

::: {#IANACWTClaims}
::: {#section-8.14 .section}
### [8.14.](#section-8.14){.section-number .selfRef} [CBOR Web Token Claims](#name-cbor-web-token-claims){.section-name .selfRef} {#name-cbor-web-token-claims}

This specification registers the following new claims in the \"CBOR Web
Token (CWT) Claims\" registry
\[[IANA.CborWebTokenClaims](#IANA.CborWebTokenClaims){.xref}\].[¶](#section-8.14-1){.pilcrow}

[]{.break}

Claim Name:
:   `ace_profile`[¶](#section-8.14-2.2){.pilcrow}
:   

Claim Description:
:   The ACE profile a token is supposed to be used
    with.[¶](#section-8.14-2.4){.pilcrow}
:   

JWT Claim Name:
:   `ace_profile`[¶](#section-8.14-2.6){.pilcrow}
:   

Claim Key:
:   38[¶](#section-8.14-2.8){.pilcrow}
:   

Claim Value Type:
:   integer[¶](#section-8.14-2.10){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-8.14-2.12){.pilcrow}
:   

Reference:
:   [Section 5.10](#accessToken){.xref} of RFC
    9200[¶](#section-8.14-2.14){.pilcrow}
:   

[]{.break}

Claim Name:
:   `cnonce`[¶](#section-8.14-3.2){.pilcrow}
:   

Claim Description:
:   The client-nonce sent to the AS by the RS via the
    client.[¶](#section-8.14-3.4){.pilcrow}
:   

JWT Claim Name:
:   `cnonce`[¶](#section-8.14-3.6){.pilcrow}
:   

Claim Key:
:   39[¶](#section-8.14-3.8){.pilcrow}
:   

Claim Value Type:
:   byte string[¶](#section-8.14-3.10){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-8.14-3.12){.pilcrow}
:   

Reference:
:   [Section 5.10](#accessToken){.xref} of RFC
    9200[¶](#section-8.14-3.14){.pilcrow}
:   

[]{.break}

Claim Name:
:   `exi`[¶](#section-8.14-4.2){.pilcrow}
:   

Claim Description:
:   The expiration time of a token measured from when it was received at
    the RS in seconds.[¶](#section-8.14-4.4){.pilcrow}
:   

JWT Claim Name:
:   `exi`[¶](#section-8.14-4.6){.pilcrow}
:   

Claim Key:
:   40[¶](#section-8.14-4.8){.pilcrow}
:   

Claim Value Type:
:   unsigned integer[¶](#section-8.14-4.10){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-8.14-4.12){.pilcrow}
:   

Reference:
:   [Section 5.10.3](#tokenExpiration){.xref} of RFC
    9200[¶](#section-8.14-4.14){.pilcrow}
:   

[]{.break}

Claim Name:
:   `scope`[¶](#section-8.14-5.2){.pilcrow}
:   

Claim Description:
:   The scope of an access token, as defined in
    \[[RFC6749](#RFC6749){.xref}\].[¶](#section-8.14-5.4){.pilcrow}
:   

JWT Claim Name:
:   `scope`[¶](#section-8.14-5.6){.pilcrow}
:   

Claim Key:
:   9[¶](#section-8.14-5.8){.pilcrow}
:   

Claim Value Type:
:   byte string or text string[¶](#section-8.14-5.10){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-8.14-5.12){.pilcrow}
:   

Reference:
:   [Section
    4.2](https://www.rfc-editor.org/rfc/rfc8693#section-4.2){.relref} of
    \[[RFC8693](#RFC8693){.xref}\][¶](#section-8.14-5.14){.pilcrow}
:   
:::
:::

::: {#IANAmediaType}
::: {#section-8.15 .section}
### [8.15.](#section-8.15){.section-number .selfRef} [Media Type Registration](#name-media-type-registration){.section-name .selfRef} {#name-media-type-registration}

This specification registers the \"application/ace+cbor\" media type for
messages of the protocols defined in this document carrying parameters
encoded in CBOR. This registration follows the procedures specified in
\[[RFC6838](#RFC6838){.xref}\].[¶](#section-8.15-1){.pilcrow}

[]{.break}

Type name:
:   application[¶](#section-8.15-2.2){.pilcrow}
:   

Subtype name:
:   ace+cbor[¶](#section-8.15-2.4){.pilcrow}
:   

Required parameters:
:   N/A[¶](#section-8.15-2.6){.pilcrow}
:   

Optional parameters:
:   N/A[¶](#section-8.15-2.8){.pilcrow}
:   

Encoding considerations:
:   Must be encoded as a CBOR map containing the protocol parameters
    defined in RFC 9200.[¶](#section-8.15-2.10){.pilcrow}
:   

Security considerations:
:   See [Section 6](#security){.xref} of RFC
    9200[¶](#section-8.15-2.12){.pilcrow}
:   

Interoperability considerations:
:   N/A[¶](#section-8.15-2.14){.pilcrow}
:   

Published specification:
:   RFC 9200[¶](#section-8.15-2.16){.pilcrow}
:   

Applications that use this media type:
:   The type is used by authorization servers, clients, and resource
    servers that support the ACE framework with CBOR encoding, as
    specified in RFC 9200.[¶](#section-8.15-2.18){.pilcrow}
:   

Fragment identifier considerations:
:   N/A[¶](#section-8.15-2.20){.pilcrow}
:   

Additional information:
:   N/A[¶](#section-8.15-2.22){.pilcrow}
:   

Person & email address to contact for further information:
:   \
    IESG \<iesg\@ietf.org>[¶](#section-8.15-2.24){.pilcrow}
:   

Intended usage:
:   COMMON[¶](#section-8.15-2.26){.pilcrow}
:   

Restrictions on usage:
:   none[¶](#section-8.15-2.28){.pilcrow}
:   

Author:
:   Ludwig Seitz
    \<ludwig.seitz\@combitech.se>[¶](#section-8.15-2.30){.pilcrow}
:   

Change controller:
:   IETF[¶](#section-8.15-2.32){.pilcrow}
:   
:::
:::

::: {#IANAcoapContentFormat}
::: {#section-8.16 .section}
### [8.16.](#section-8.16){.section-number .selfRef} [CoAP Content-Formats](#name-coap-content-formats){.section-name .selfRef} {#name-coap-content-formats}

The following entry has been registered in the \"CoAP Content-Formats\"
registry:[¶](#section-8.16-1){.pilcrow}

[]{.break}

Media Type:
:   application/ace+cbor[¶](#section-8.16-2.2){.pilcrow}
:   

Encoding:
:   \-[¶](#section-8.16-2.4){.pilcrow}
:   

ID:
:   19[¶](#section-8.16-2.6){.pilcrow}
:   

Reference:
:   RFC 9200[¶](#section-8.16-2.8){.pilcrow}
:   
:::
:::

::: {#IANAinstructions}
::: {#section-8.17 .section}
### [8.17.](#section-8.17){.section-number .selfRef} [Expert Review Instructions](#name-expert-review-instructions){.section-name .selfRef} {#name-expert-review-instructions}

All of the IANA registries established in this document are defined to
use a registration policy of Expert Review. This section gives some
general guidelines for what the experts should be looking for, but they
are being designated as experts for a reason, so they should be given
substantial latitude.[¶](#section-8.17-1){.pilcrow}

Expert Reviewers should take into consideration the following
points:[¶](#section-8.17-2){.pilcrow}

-   [Point squatting should be discouraged. Reviewers are encouraged to
    get sufficient information for registration requests to ensure that
    the usage is not going to duplicate one that is already registered
    and that the point is likely to be used in deployments. The zones
    tagged as Private Use are intended for testing purposes and closed
    environments; code points in other ranges should not be assigned for
    testing.[¶](#section-8.17-3.1){.pilcrow}]{#section-8.17-3.1}
-   [Specifications are needed for the first-come, first-serve range if
    they are expected to be used outside of closed environments in an
    interoperable way. When specifications are not provided, the
    description provided needs to have sufficient information to
    identify what the point is being used
    for.[¶](#section-8.17-3.2){.pilcrow}]{#section-8.17-3.2}
-   [Experts should take into account the expected usage of fields when
    approving point assignment. The fact that there is a range for
    Standards Track documents does not mean that a Standards Track
    document cannot have points assigned outside of that range. The
    length of the encoded value should be weighed against how many code
    points of that length are left, i.e., the size of device it will be
    used on.[¶](#section-8.17-3.3){.pilcrow}]{#section-8.17-3.3}
-   [Since a high degree of overlap is expected between these registries
    and the contents of the OAuth parameters
    \[[IANA.OAuthParameters](#IANA.OAuthParameters){.xref}\] registries,
    experts should require new registrations to maintain alignment with
    parameters from OAuth that have comparable functionality. Deviation
    from this alignment should only be allowed if there are functional
    differences that are motivated by the use case and that cannot be
    easily or efficiently addressed by comparable OAuth
    parameters.[¶](#section-8.17-3.4){.pilcrow}]{#section-8.17-3.4}
:::
:::
:::
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[IANA.CborWebTokenClaims\]
:   [IANA]{.refAuthor}, [\"CBOR Web Token (CWT) Claims\"]{.refTitle},
    \<<https://www.iana.org/assignments/cwt>\>.
:   

\[IANA.CoreParameters\]
:   [IANA]{.refAuthor}, [\"Constrained RESTful Environments (CoRE)
    Parameters\"]{.refTitle},
    \<<https://www.iana.org/assignments/core-parameters>\>.
:   

\[IANA.JsonWebTokenClaims\]
:   [IANA]{.refAuthor}, [\"JSON Web Token Claims\"]{.refTitle},
    \<<https://www.iana.org/assignments/jwt>\>.
:   

\[IANA.OAuthAccessTokenTypes\]
:   [IANA]{.refAuthor}, [\"OAuth Access Token Types\"]{.refTitle},
    \<<https://www.iana.org/assignments/oauth-parameters>\>.
:   

\[IANA.OAuthExtensionsErrorRegistry\]
:   [IANA]{.refAuthor}, [\"OAuth Extensions Error
    Registry\"]{.refTitle},
    \<<https://www.iana.org/assignments/oauth-parameters>\>.
:   

\[IANA.OAuthParameters\]
:   [IANA]{.refAuthor}, [\"OAuth Parameters\"]{.refTitle},
    \<<https://www.iana.org/assignments/oauth-parameters>\>.
:   

\[IANA.TokenIntrospectionResponse\]
:   [IANA]{.refAuthor}, [\"OAuth Token Introspection
    Response\"]{.refTitle},
    \<<https://www.iana.org/assignments/oauth-parameters>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC3986\]
:   [Berners-Lee, T.]{.refAuthor}, [Fielding, R.]{.refAuthor}, and [L.
    Masinter]{.refAuthor}, [\"Uniform Resource Identifier (URI): Generic
    Syntax\"]{.refTitle}, [STD 66]{.seriesInfo}, [RFC
    3986]{.seriesInfo}, [DOI 10.17487/RFC3986]{.seriesInfo}, January
    2005, \<<https://www.rfc-editor.org/info/rfc3986>\>.
:   

\[RFC4648\]
:   [Josefsson, S.]{.refAuthor}, [\"The Base16, Base32, and Base64 Data
    Encodings\"]{.refTitle}, [RFC 4648]{.seriesInfo}, [DOI
    10.17487/RFC4648]{.seriesInfo}, October 2006,
    \<<https://www.rfc-editor.org/info/rfc4648>\>.
:   

\[RFC6347\]
:   [Rescorla, E.]{.refAuthor} and [N. Modadugu]{.refAuthor},
    [\"Datagram Transport Layer Security Version 1.2\"]{.refTitle}, [RFC
    6347]{.seriesInfo}, [DOI 10.17487/RFC6347]{.seriesInfo}, January
    2012, \<<https://www.rfc-editor.org/info/rfc6347>\>.
:   

\[RFC6749\]
:   [Hardt, D., Ed.]{.refAuthor}, [\"The OAuth 2.0 Authorization
    Framework\"]{.refTitle}, [RFC 6749]{.seriesInfo}, [DOI
    10.17487/RFC6749]{.seriesInfo}, October 2012,
    \<<https://www.rfc-editor.org/info/rfc6749>\>.
:   

\[RFC6750\]
:   [Jones, M.]{.refAuthor} and [D. Hardt]{.refAuthor}, [\"The OAuth 2.0
    Authorization Framework: Bearer Token Usage\"]{.refTitle}, [RFC
    6750]{.seriesInfo}, [DOI 10.17487/RFC6750]{.seriesInfo}, October
    2012, \<<https://www.rfc-editor.org/info/rfc6750>\>.
:   

\[RFC6838\]
:   [Freed, N.]{.refAuthor}, [Klensin, J.]{.refAuthor}, and [T.
    Hansen]{.refAuthor}, [\"Media Type Specifications and Registration
    Procedures\"]{.refTitle}, [BCP 13]{.seriesInfo}, [RFC
    6838]{.seriesInfo}, [DOI 10.17487/RFC6838]{.seriesInfo}, January
    2013, \<<https://www.rfc-editor.org/info/rfc6838>\>.
:   

\[RFC6920\]
:   [Farrell, S.]{.refAuthor}, [Kutscher, D.]{.refAuthor},
    [Dannewitz, C.]{.refAuthor}, [Ohlman, B.]{.refAuthor},
    [Keranen, A.]{.refAuthor}, and [P. Hallam-Baker]{.refAuthor},
    [\"Naming Things with Hashes\"]{.refTitle}, [RFC 6920]{.seriesInfo},
    [DOI 10.17487/RFC6920]{.seriesInfo}, April 2013,
    \<<https://www.rfc-editor.org/info/rfc6920>\>.
:   

\[RFC7252\]
:   [Shelby, Z.]{.refAuthor}, [Hartke, K.]{.refAuthor}, and [C.
    Bormann]{.refAuthor}, [\"The Constrained Application Protocol
    (CoAP)\"]{.refTitle}, [RFC 7252]{.seriesInfo}, [DOI
    10.17487/RFC7252]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7252>\>.
:   

\[RFC7519\]
:   [Jones, M.]{.refAuthor}, [Bradley, J.]{.refAuthor}, and [N.
    Sakimura]{.refAuthor}, [\"JSON Web Token (JWT)\"]{.refTitle}, [RFC
    7519]{.seriesInfo}, [DOI 10.17487/RFC7519]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7519>\>.
:   

\[RFC7662\]
:   [Richer, J., Ed.]{.refAuthor}, [\"OAuth 2.0 Token
    Introspection\"]{.refTitle}, [RFC 7662]{.seriesInfo}, [DOI
    10.17487/RFC7662]{.seriesInfo}, October 2015,
    \<<https://www.rfc-editor.org/info/rfc7662>\>.
:   

\[RFC8126\]
:   [Cotton, M.]{.refAuthor}, [Leiba, B.]{.refAuthor}, and [T.
    Narten]{.refAuthor}, [\"Guidelines for Writing an IANA
    Considerations Section in RFCs\"]{.refTitle}, [BCP 26]{.seriesInfo},
    [RFC 8126]{.seriesInfo}, [DOI 10.17487/RFC8126]{.seriesInfo}, June
    2017, \<<https://www.rfc-editor.org/info/rfc8126>\>.
:   

\[RFC8152\]
:   [Schaad, J.]{.refAuthor}, [\"CBOR Object Signing and Encryption
    (COSE)\"]{.refTitle}, [RFC 8152]{.seriesInfo}, [DOI
    10.17487/RFC8152]{.seriesInfo}, July 2017,
    \<<https://www.rfc-editor.org/info/rfc8152>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8392\]
:   [Jones, M.]{.refAuthor}, [Wahlstroem, E.]{.refAuthor},
    [Erdtman, S.]{.refAuthor}, and [H. Tschofenig]{.refAuthor}, [\"CBOR
    Web Token (CWT)\"]{.refTitle}, [RFC 8392]{.seriesInfo}, [DOI
    10.17487/RFC8392]{.seriesInfo}, May 2018,
    \<<https://www.rfc-editor.org/info/rfc8392>\>.
:   

\[RFC8610\]
:   [Birkholz, H.]{.refAuthor}, [Vigano, C.]{.refAuthor}, and [C.
    Bormann]{.refAuthor}, [\"Concise Data Definition Language (CDDL): A
    Notational Convention to Express Concise Binary Object
    Representation (CBOR) and JSON Data Structures\"]{.refTitle}, [RFC
    8610]{.seriesInfo}, [DOI 10.17487/RFC8610]{.seriesInfo}, June 2019,
    \<<https://www.rfc-editor.org/info/rfc8610>\>.
:   

\[RFC8693\]
:   [Jones, M.]{.refAuthor}, [Nadalin, A.]{.refAuthor}, [Campbell, B.,
    Ed.]{.refAuthor}, [Bradley, J.]{.refAuthor}, and [C.
    Mortimore]{.refAuthor}, [\"OAuth 2.0 Token Exchange\"]{.refTitle},
    [RFC 8693]{.seriesInfo}, [DOI 10.17487/RFC8693]{.seriesInfo},
    January 2020, \<<https://www.rfc-editor.org/info/rfc8693>\>.
:   

\[RFC8747\]
:   [Jones, M.]{.refAuthor}, [Seitz, L.]{.refAuthor},
    [Selander, G.]{.refAuthor}, [Erdtman, S.]{.refAuthor}, and [H.
    Tschofenig]{.refAuthor}, [\"Proof-of-Possession Key Semantics for
    CBOR Web Tokens (CWTs)\"]{.refTitle}, [RFC 8747]{.seriesInfo}, [DOI
    10.17487/RFC8747]{.seriesInfo}, March 2020,
    \<<https://www.rfc-editor.org/info/rfc8747>\>.
:   

\[RFC8949\]
:   [Bormann, C.]{.refAuthor} and [P. Hoffman]{.refAuthor}, [\"Concise
    Binary Object Representation (CBOR)\"]{.refTitle}, [STD
    94]{.seriesInfo}, [RFC 8949]{.seriesInfo}, [DOI
    10.17487/RFC8949]{.seriesInfo}, December 2020,
    \<<https://www.rfc-editor.org/info/rfc8949>\>.
:   

\[RFC9201\]
:   [Seitz, L.]{.refAuthor}, [\"Additional OAuth Parameters for
    Authentication and Authorization in Constrained Environments
    (ACE)\"]{.refTitle}, [RFC 9201]{.seriesInfo}, [DOI
    10.17487/RFC9201]{.seriesInfo}, August 2022,
    \<<https://www.rfc-editor.org/info/rfc9201>\>.
:   
:::

::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[BLE\]
:   [Bluetooth Special Interest Group]{.refAuthor}, [\"Core
    Specification 5.3\"]{.refTitle}, [Section 4.4]{.seriesInfo}, July
    2021,
    \<<https://www.bluetooth.com/specifications/bluetooth-core-specification/>\>.
:   

\[DCAF\]
:   [Gerdes, S.]{.refAuthor}, [Bergmann, O.]{.refAuthor}, and [C.
    Bormann]{.refAuthor}, [\"Delegated CoAP Authentication and
    Authorization Framework (DCAF)\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-gerdes-ace-dcaf-authorize-04]{.seriesInfo}, 19 October 2015,
    \<<https://datatracker.ietf.org/doc/html/draft-gerdes-ace-dcaf-authorize-04>\>.
:   

\[Margi10impact\]
:   [Margi, C.]{.refAuthor}, [de Oliveira, B.]{.refAuthor}, [de
    Sousa, G.]{.refAuthor}, [Simplicio Jr, M.]{.refAuthor},
    [Barreto, P.]{.refAuthor}, [Carvalho, T.]{.refAuthor},
    [Naeslund, M.]{.refAuthor}, and [R. Gold]{.refAuthor}, [\"Impact of
    Operating Systems on Wireless Sensor Networks (Security)
    Applications and Testbeds\"]{.refTitle}, [Proceedings of the 19th
    International Conference on Computer Communications and
    Networks]{.refContent}, [DOI
    10.1109/ICCCN.2010.5560028]{.seriesInfo}, August 2010,
    \<<https://doi.org/10.1109/ICCCN.2010.5560028>\>.
:   

\[MQTT5.0\]
:   [Banks, A.]{.refAuthor}, [Briggs, E.]{.refAuthor},
    [Borgendale, K.]{.refAuthor}, and [R. Gupta]{.refAuthor}, [\"MQTT
    Version 5.0\"]{.refTitle}, [OASIS Standard]{.refContent}, March
    2019,
    \<<https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html>\>.
:   

\[OAUTH-RPCC\]
:   [Seitz, L.]{.refAuthor}, [Erdtman, S.]{.refAuthor}, and [M.
    Tiloca]{.refAuthor}, [\"Raw-Public-Key and Pre-Shared-Key as OAuth
    client credentials\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-erdtman-oauth-rpcc-00]{.seriesInfo}, 21
    November 2017,
    \<<https://datatracker.ietf.org/doc/html/draft-erdtman-oauth-rpcc-00>\>.
:   

\[POP-KEY-DIST\]
:   [Bradley, J.]{.refAuthor}, [Hunt, P.]{.refAuthor},
    [Jones, M.]{.refAuthor}, [Tschofenig, H.]{.refAuthor}, and [M.
    Meszaros]{.refAuthor}, [\"OAuth 2.0 Proof-of-Possession:
    Authorization Server to Client Key Distribution\"]{.refTitle}, [Work
    in Progress]{.refContent}, [Internet-Draft,
    draft-ietf-oauth-pop-key-distribution-07]{.seriesInfo}, 27 March
    2019,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-oauth-pop-key-distribution-07>\>.
:   

\[RFC4949\]
:   [Shirey, R.]{.refAuthor}, [\"Internet Security Glossary, Version
    2\"]{.refTitle}, [FYI 36]{.seriesInfo}, [RFC 4949]{.seriesInfo},
    [DOI 10.17487/RFC4949]{.seriesInfo}, August 2007,
    \<<https://www.rfc-editor.org/info/rfc4949>\>.
:   

\[RFC6690\]
:   [Shelby, Z.]{.refAuthor}, [\"Constrained RESTful Environments (CoRE)
    Link Format\"]{.refTitle}, [RFC 6690]{.seriesInfo}, [DOI
    10.17487/RFC6690]{.seriesInfo}, August 2012,
    \<<https://www.rfc-editor.org/info/rfc6690>\>.
:   

\[RFC6819\]
:   [Lodderstedt, T., Ed.]{.refAuthor}, [McGloin, M.]{.refAuthor}, and
    [P. Hunt]{.refAuthor}, [\"OAuth 2.0 Threat Model and Security
    Considerations\"]{.refTitle}, [RFC 6819]{.seriesInfo}, [DOI
    10.17487/RFC6819]{.seriesInfo}, January 2013,
    \<<https://www.rfc-editor.org/info/rfc6819>\>.
:   

\[RFC7009\]
:   [Lodderstedt, T., Ed.]{.refAuthor}, [Dronia, S.]{.refAuthor}, and
    [M. Scurtescu]{.refAuthor}, [\"OAuth 2.0 Token
    Revocation\"]{.refTitle}, [RFC 7009]{.seriesInfo}, [DOI
    10.17487/RFC7009]{.seriesInfo}, August 2013,
    \<<https://www.rfc-editor.org/info/rfc7009>\>.
:   

\[RFC7228\]
:   [Bormann, C.]{.refAuthor}, [Ersue, M.]{.refAuthor}, and [A.
    Keranen]{.refAuthor}, [\"Terminology for Constrained-Node
    Networks\"]{.refTitle}, [RFC 7228]{.seriesInfo}, [DOI
    10.17487/RFC7228]{.seriesInfo}, May 2014,
    \<<https://www.rfc-editor.org/info/rfc7228>\>.
:   

\[RFC7521\]
:   [Campbell, B.]{.refAuthor}, [Mortimore, C.]{.refAuthor},
    [Jones, M.]{.refAuthor}, and [Y. Goland]{.refAuthor}, [\"Assertion
    Framework for OAuth 2.0 Client Authentication and Authorization
    Grants\"]{.refTitle}, [RFC 7521]{.seriesInfo}, [DOI
    10.17487/RFC7521]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7521>\>.
:   

\[RFC7591\]
:   [Richer, J., Ed.]{.refAuthor}, [Jones, M.]{.refAuthor},
    [Bradley, J.]{.refAuthor}, [Machulak, M.]{.refAuthor}, and [P.
    Hunt]{.refAuthor}, [\"OAuth 2.0 Dynamic Client Registration
    Protocol\"]{.refTitle}, [RFC 7591]{.seriesInfo}, [DOI
    10.17487/RFC7591]{.seriesInfo}, July 2015,
    \<<https://www.rfc-editor.org/info/rfc7591>\>.
:   

\[RFC7641\]
:   [Hartke, K.]{.refAuthor}, [\"Observing Resources in the Constrained
    Application Protocol (CoAP)\"]{.refTitle}, [RFC 7641]{.seriesInfo},
    [DOI 10.17487/RFC7641]{.seriesInfo}, September 2015,
    \<<https://www.rfc-editor.org/info/rfc7641>\>.
:   

\[RFC7744\]
:   [Seitz, L., Ed.]{.refAuthor}, [Gerdes, S., Ed.]{.refAuthor},
    [Selander, G.]{.refAuthor}, [Mani, M.]{.refAuthor}, and [S.
    Kumar]{.refAuthor}, [\"Use Cases for Authentication and
    Authorization in Constrained Environments\"]{.refTitle}, [RFC
    7744]{.seriesInfo}, [DOI 10.17487/RFC7744]{.seriesInfo}, January
    2016, \<<https://www.rfc-editor.org/info/rfc7744>\>.
:   

\[RFC7959\]
:   [Bormann, C.]{.refAuthor} and [Z. Shelby, Ed.]{.refAuthor},
    [\"Block-Wise Transfers in the Constrained Application Protocol
    (CoAP)\"]{.refTitle}, [RFC 7959]{.seriesInfo}, [DOI
    10.17487/RFC7959]{.seriesInfo}, August 2016,
    \<<https://www.rfc-editor.org/info/rfc7959>\>.
:   

\[RFC8252\]
:   [Denniss, W.]{.refAuthor} and [J. Bradley]{.refAuthor}, [\"OAuth 2.0
    for Native Apps\"]{.refTitle}, [BCP 212]{.seriesInfo}, [RFC
    8252]{.seriesInfo}, [DOI 10.17487/RFC8252]{.seriesInfo}, October
    2017, \<<https://www.rfc-editor.org/info/rfc8252>\>.
:   

\[RFC8259\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The JavaScript Object Notation
    (JSON) Data Interchange Format\"]{.refTitle}, [STD 90]{.seriesInfo},
    [RFC 8259]{.seriesInfo}, [DOI 10.17487/RFC8259]{.seriesInfo},
    December 2017, \<<https://www.rfc-editor.org/info/rfc8259>\>.
:   

\[RFC8414\]
:   [Jones, M.]{.refAuthor}, [Sakimura, N.]{.refAuthor}, and [J.
    Bradley]{.refAuthor}, [\"OAuth 2.0 Authorization Server
    Metadata\"]{.refTitle}, [RFC 8414]{.seriesInfo}, [DOI
    10.17487/RFC8414]{.seriesInfo}, June 2018,
    \<<https://www.rfc-editor.org/info/rfc8414>\>.
:   

\[RFC8446\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   

\[RFC8516\]
:   [Keranen, A.]{.refAuthor}, [\"\"Too Many Requests\" Response Code
    for the Constrained Application Protocol\"]{.refTitle}, [RFC
    8516]{.seriesInfo}, [DOI 10.17487/RFC8516]{.seriesInfo}, January
    2019, \<<https://www.rfc-editor.org/info/rfc8516>\>.
:   

\[RFC8613\]
:   [Selander, G.]{.refAuthor}, [Mattsson, J.]{.refAuthor},
    [Palombini, F.]{.refAuthor}, and [L. Seitz]{.refAuthor}, [\"Object
    Security for Constrained RESTful Environments
    (OSCORE)\"]{.refTitle}, [RFC 8613]{.seriesInfo}, [DOI
    10.17487/RFC8613]{.seriesInfo}, July 2019,
    \<<https://www.rfc-editor.org/info/rfc8613>\>.
:   

\[RFC8628\]
:   [Denniss, W.]{.refAuthor}, [Bradley, J.]{.refAuthor},
    [Jones, M.]{.refAuthor}, and [H. Tschofenig]{.refAuthor}, [\"OAuth
    2.0 Device Authorization Grant\"]{.refTitle}, [RFC
    8628]{.seriesInfo}, [DOI 10.17487/RFC8628]{.seriesInfo}, August
    2019, \<<https://www.rfc-editor.org/info/rfc8628>\>.
:   

\[RFC9000\]
:   [Iyengar, J., Ed.]{.refAuthor} and [M. Thomson, Ed.]{.refAuthor},
    [\"QUIC: A UDP-Based Multiplexed and Secure Transport\"]{.refTitle},
    [RFC 9000]{.seriesInfo}, [DOI 10.17487/RFC9000]{.seriesInfo}, May
    2021, \<<https://www.rfc-editor.org/info/rfc9000>\>.
:   

\[RFC9110\]
:   [Fielding, R., Ed.]{.refAuthor}, [Nottingham, M., Ed.]{.refAuthor},
    and [J. Reschke, Ed.]{.refAuthor}, [\"HTTP Semantics\"]{.refTitle},
    [STD 97]{.seriesInfo}, [RFC 9110]{.seriesInfo}, [DOI
    10.17487/RFC9110]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9110>\>.
:   

\[RFC9113\]
:   [Thomson, M., Ed.]{.refAuthor} and [C. Benfield, Ed.]{.refAuthor},
    [\"HTTP/2\"]{.refTitle}, [RFC 9113]{.seriesInfo}, [DOI
    10.17487/RFC9113]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9113>\>.
:   

\[RFC9147\]
:   [Rescorla, E.]{.refAuthor}, [Tschofenig, H.]{.refAuthor}, and [N.
    Modadugu]{.refAuthor}, [\"The Datagram Transport Layer Security
    (DTLS) Protocol Version 1.3\"]{.refTitle}, [RFC 9147]{.seriesInfo},
    [DOI 10.17487/RFC9147]{.seriesInfo}, April 2022,
    \<<https://www.rfc-editor.org/info/rfc9147>\>.
:   

\[RFC9202\]
:   [Gerdes, S.]{.refAuthor}, [Bergmann, O.]{.refAuthor},
    [Bormann, C.]{.refAuthor}, [Selander, G.]{.refAuthor}, and [L.
    Seitz]{.refAuthor}, [\"Datagram Transport Layer Security (DTLS)
    Profile for Authentication and Authorization for Constrained
    Environments (ACE)\"]{.refTitle}, [RFC 9202]{.seriesInfo}, [DOI
    10.17487/RFC9202]{.seriesInfo}, August 2022,
    \<<https://www.rfc-editor.org/info/rfc9202>\>.
:   

\[RFC9203\]
:   [Palombini, F.]{.refAuthor}, [Seitz, L.]{.refAuthor},
    [Selander, G.]{.refAuthor}, and [M. Gunnarsson]{.refAuthor}, [\"The
    Object Security for Constrained RESTful Environments (OSCORE)
    Profile of the Authentication and Authorization for Constrained
    Environments (ACE) Framework\"]{.refTitle}, [RFC 9203]{.seriesInfo},
    [DOI 10.17487/RFC9203]{.seriesInfo}, August 2022,
    \<<https://www.rfc-editor.org/info/rfc9203>\>.
:   
:::
:::

::: {#constraints}
::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [Design Justification](#name-design-justification){.section-name .selfRef} {#name-design-justification}

This section provides further insight into the design decisions of the
solution documented in this document. [Section 3](#overview){.xref}
lists several building blocks and briefly summarizes their importance.
The justification for offering some of those building blocks, as opposed
to using OAuth 2.0 as is, is given below.[¶](#appendix-A-1){.pilcrow}

Common IoT constraints are:[¶](#appendix-A-2){.pilcrow}

[]{.break}

Low Power Radio:
:   Many IoT devices are equipped with a small battery that needs to
    last for a long time. For many constrained wireless devices, the
    highest energy cost is associated to transmitting or receiving
    messages (roughly by a factor of 10 compared to AES)
    \[[Margi10impact](#Margi10impact){.xref}\]. It is therefore
    important to keep the total communication overhead low, including
    minimizing the number and size of messages sent and received, which
    has an impact of choice on the message format and protocol. By using
    CoAP over UDP and CBOR-encoded messages, some of these aspects are
    addressed. Security protocols contribute to the communication
    overhead and can, in some cases, be optimized. For example,
    authentication and key establishment may, in certain cases where
    security requirements allow, be replaced by the provisioning of
    security context by a trusted third party, using transport or
    application-layer security.[¶](#appendix-A-3.2){.pilcrow}
:   

Low CPU Speed:
:   Some IoT devices are equipped with processors that are significantly
    slower than those found in most current devices on the Internet.
    This typically has implications on what timely cryptographic
    operations a device is capable of performing, which in turn impacts,
    e.g., protocol latency. Symmetric key cryptography may be used
    instead of the computationally more expensive public key
    cryptography where the security requirements so allow, but this may
    also require support for trusted, third-party-assisted secret key
    establishment using transport- or application-layer
    security.[¶](#appendix-A-3.4){.pilcrow}
:   

Small Amount of Memory:
:   Microcontrollers embedded in IoT devices are often equipped with
    only a small amount of RAM and flash memory, which places
    limitations on what kind of processing can be performed and how much
    code can be put on those devices. To reduce code size, fewer and
    smaller protocol implementations can be put on the firmware of such
    a device. In this case, CoAP may be used instead of HTTP,
    symmetric-key cryptography may be used instead of public-key
    cryptography, and CBOR may be used instead of JSON. An
    authentication and key establishment protocol, e.g., the DTLS
    handshake, in comparison with assisted key establishment, also has
    an impact on memory and code
    footprints.[¶](#appendix-A-3.6){.pilcrow}
:   

User Interface Limitations:
:   Protecting access to resources is both an important security as well
    as privacy feature. End users and enterprise customers may not want
    to give access to the data collected by their IoT device or to
    functions it may offer to third parties. Since the classical
    approach of requesting permissions from end users via a rich user
    interface does not work in many IoT deployment scenarios, these
    functions need to be delegated to user-controlled devices that are
    better suitable for such tasks, such as smartphones and
    tablets.[¶](#appendix-A-3.8){.pilcrow}
:   

Communication Constraints:

:   In certain constrained settings, an IoT device may not be able to
    communicate with a given device at all times. Devices may be
    sleeping or just disconnected from the Internet because of general
    lack of connectivity in the area, cost reasons, or security reasons,
    e.g., to avoid an entry point for denial-of-service
    attacks.[¶](#appendix-A-3.10.1){.pilcrow}

    The communication interactions this framework builds upon (as shown
    graphically in [Figure 1](#fig_protocolFlow){.xref}) may be
    accomplished using a variety of different protocols, and not all
    parts of the message flow are used in all applications due to the
    communication constraints. Deployments making use of CoAP are
    expected, but this framework is not limited to them. Other
    protocols, such as HTTP or Bluetooth Smart communication, that do
    not necessarily use IP could also be used. The latter raises the
    need for application-layer security over the various
    interfaces.[¶](#appendix-A-3.10.2){.pilcrow}

:   

In the light of these constraints, we have made the following design
decisions:[¶](#appendix-A-4){.pilcrow}

[]{.break}

CBOR, COSE, CWT:
:   When using this framework, it is [RECOMMENDED]{.bcp14} to use CBOR
    \[[RFC8949](#RFC8949){.xref}\] as the data format. Where CBOR data
    needs to be protected, the use of COSE
    \[[RFC8152](#RFC8152){.xref}\] is [RECOMMENDED]{.bcp14}.
    Furthermore, where self-contained tokens are needed, it is
    [RECOMMENDED]{.bcp14} to use CWT \[[RFC8392](#RFC8392){.xref}\].
    These measures aim at reducing the size of messages sent over the
    wire, the RAM size of data objects that need to be kept in memory,
    and the size of libraries that devices need to
    support.[¶](#appendix-A-5.2){.pilcrow}
:   

CoAP:
:   When using this framework, it is [RECOMMENDED]{.bcp14} to use CoAP
    \[[RFC7252](#RFC7252){.xref}\] instead of HTTP. This does not
    preclude the use of other protocols specifically aimed at
    constrained devices, e.g., Bluetooth Low Energy (see [Section
    3.2](#coap){.xref}). This aims again at reducing the size of
    messages sent over the wire, the RAM size of data objects that need
    to be kept in memory, and the size of libraries that devices need to
    support.[¶](#appendix-A-5.4){.pilcrow}
:   

Access Information:
:   This framework defines the name \"Access Information\" for data
    concerning the RS that the AS returns to the client in an access
    token response (see [Section 5.8.2](#tokenResponse){.xref}). This
    aims at enabling scenarios where a powerful client supporting
    multiple profiles needs to interact with an RS for which it does not
    know the supported profiles and the raw public
    key.[¶](#appendix-A-5.6){.pilcrow}
:   

Proof of Possession:
:   This framework makes use of proof-of-possession tokens, using the
    `cnf` claim \[[RFC8747](#RFC8747){.xref}\]. A request parameter
    `cnf` and a Response parameter `cnf`, both having a value space
    semantically and syntactically identical to the `cnf` claim, are
    defined for the token endpoint to allow requesting and stating
    confirmation keys. This aims at making token theft harder. Token
    theft is specifically relevant in constrained use cases, as
    communication often passes through middleboxes, which could be able
    to steal bearer tokens and use them to gain unauthorized
    access.[¶](#appendix-A-5.8){.pilcrow}
:   

Authz-Info endpoint:
:   This framework introduces a new way of providing access tokens to an
    RS by exposing an authz-info endpoint to which access tokens can be
    POSTed. This aims at reducing the size of the request message and
    the code complexity at the RS. The size of the request message is
    problematic, since many constrained protocols have severe message
    size limitations at the physical layer (e.g., in the order of 100
    bytes). This means that larger packets get fragmented, which in turn
    combines badly with the high rate of packet loss and the need to
    retransmit the whole message if one packet gets lost. Thus,
    separating sending of the request and sending of the access tokens
    helps to reduce fragmentation.[¶](#appendix-A-5.10){.pilcrow}
:   

Client Credentials Grant:
:   In this framework, the use of the client credentials grant is
    [RECOMMENDED]{.bcp14} for machine-to-machine communication use
    cases, where manual intervention of the resource owner to produce a
    grant token is not feasible. The intention is that the resource
    owner would instead prearrange authorization with the AS based on
    the client\'s own credentials. The client can then (without manual
    intervention) obtain access tokens from the
    AS.[¶](#appendix-A-5.12){.pilcrow}
:   

Introspection:
:   In this framework, the use of access token introspection is
    [RECOMMENDED]{.bcp14} in cases where the client is constrained in a
    way that it cannot easily obtain new access tokens (i.e., it has
    connectivity issues that prevent it from communicating with the AS).
    In that case, it is [RECOMMENDED]{.bcp14} to use a long-term token
    that could be a simple reference. The RS is assumed to be able to
    communicate with the AS and can therefore perform introspection in
    order to learn the claims associated with the token reference. The
    advantage of such an approach is that the resource owner can change
    the claims associated to the token reference without having to be in
    contact with the client, thus granting or revoking access
    rights.[¶](#appendix-A-5.14){.pilcrow}
:   
:::
:::

::: {#app_rolesAndResponsibilities}
::: {#appendix-B .section}
## [Appendix B.](#appendix-B){.section-number .selfRef} [Roles and Responsibilities](#name-roles-and-responsibilities){.section-name .selfRef} {#name-roles-and-responsibilities}

[]{.break}

Resource Owner

:   -   [Make sure that the RS is registered at the AS. This includes
        making known to the AS which profiles, token_type, scopes, and
        key types (symmetric/asymmetric) the RS supports. Also making it
        known to the AS which audience(s) the RS identifies itself
        with.[¶](#appendix-B-1.2.1.1){.pilcrow}]{#appendix-B-1.2.1.1}
    -   [Make sure that clients can discover the AS that is in charge of
        the RS.[¶](#appendix-B-1.2.1.2){.pilcrow}]{#appendix-B-1.2.1.2}
    -   [If the client-credentials grant is used, make sure that the AS
        has the necessary, up-to-date access control policies for the
        RS.[¶](#appendix-B-1.2.1.3){.pilcrow}]{#appendix-B-1.2.1.3}

:   

Requesting Party

:   -   [Make sure that the client is provisioned the necessary
        credentials to authenticate to the
        AS.[¶](#appendix-B-1.4.1.1){.pilcrow}]{#appendix-B-1.4.1.1}
    -   [Make sure that the client is configured to follow the security
        requirements of the requesting party when issuing requests
        (e.g., minimum communication security requirements or trust
        anchors).[¶](#appendix-B-1.4.1.2){.pilcrow}]{#appendix-B-1.4.1.2}
    -   [Register the client at the AS. This includes making known to
        the AS which profiles, token_types, and key types
        (symmetric/asymmetric) for the
        client.[¶](#appendix-B-1.4.1.3){.pilcrow}]{#appendix-B-1.4.1.3}

:   

Authorization Server

:   -   [Register the RS and manage corresponding security
        contexts.[¶](#appendix-B-1.6.1.1){.pilcrow}]{#appendix-B-1.6.1.1}
    -   [Register clients and authentication
        credentials.[¶](#appendix-B-1.6.1.2){.pilcrow}]{#appendix-B-1.6.1.2}
    -   [Allow resource owners to configure and update access control
        policies related to their registered
        RSs.[¶](#appendix-B-1.6.1.3){.pilcrow}]{#appendix-B-1.6.1.3}
    -   [Expose the token endpoint to allow clients to request
        tokens.[¶](#appendix-B-1.6.1.4){.pilcrow}]{#appendix-B-1.6.1.4}
    -   [Authenticate clients that wish to request a
        token.[¶](#appendix-B-1.6.1.5){.pilcrow}]{#appendix-B-1.6.1.5}
    -   [Process a token request using the authorization policies
        configured for the
        RS.[¶](#appendix-B-1.6.1.6){.pilcrow}]{#appendix-B-1.6.1.6}
    -   [Optionally, expose the introspection endpoint that allows RSs
        to submit token introspection
        requests.[¶](#appendix-B-1.6.1.7){.pilcrow}]{#appendix-B-1.6.1.7}
    -   [If providing an introspection endpoint, authenticate RSs that
        wish to get an introspection
        response.[¶](#appendix-B-1.6.1.8){.pilcrow}]{#appendix-B-1.6.1.8}
    -   [If providing an introspection endpoint, process token
        introspection
        requests.[¶](#appendix-B-1.6.1.9){.pilcrow}]{#appendix-B-1.6.1.9}
    -   [Optionally, handle token
        revocation.[¶](#appendix-B-1.6.1.10){.pilcrow}]{#appendix-B-1.6.1.10}
    -   [Optionally, provide discovery metadata. See
        \[[RFC8414](#RFC8414){.xref}\].[¶](#appendix-B-1.6.1.11){.pilcrow}]{#appendix-B-1.6.1.11}
    -   [Optionally, handle refresh
        tokens.[¶](#appendix-B-1.6.1.12){.pilcrow}]{#appendix-B-1.6.1.12}

:   

Client

:   -   [Discover the AS in charge of the RS that is to be targeted with
        a
        request.[¶](#appendix-B-1.8.1.1){.pilcrow}]{#appendix-B-1.8.1.1}

    -   ::: {#appendix-B-1.8.1.2}
        Submit the token request (see step (A) of [Figure
        1](#fig_protocolFlow){.xref}).[¶](#appendix-B-1.8.1.2.1){.pilcrow}

        -   [Authenticate to the
            AS.[¶](#appendix-B-1.8.1.2.2.1){.pilcrow}]{#appendix-B-1.8.1.2.2.1}
        -   [Optionally (if not preconfigured), specify which RS, which
            resource(s), and which action(s) the request(s) will
            target.[¶](#appendix-B-1.8.1.2.2.2){.pilcrow}]{#appendix-B-1.8.1.2.2.2}
        -   [If raw public keys (RPKs) or certificates are used, make
            sure the AS has the right RPK or certificate for this
            client.[¶](#appendix-B-1.8.1.2.2.3){.pilcrow}]{#appendix-B-1.8.1.2.2.3}
        :::

    -   ::: {#appendix-B-1.8.1.3}
        Process the access token and Access Information (see step (B) of
        [Figure
        1](#fig_protocolFlow){.xref}).[¶](#appendix-B-1.8.1.3.1){.pilcrow}

        -   [Check that the Access Information provides the necessary
            security parameters (e.g., PoP key or information on
            communication security protocols supported by the
            RS).[¶](#appendix-B-1.8.1.3.2.1){.pilcrow}]{#appendix-B-1.8.1.3.2.1}
        -   [Safely store the proof-of-possession
            key.[¶](#appendix-B-1.8.1.3.2.2){.pilcrow}]{#appendix-B-1.8.1.3.2.2}
        -   [If provided by the AS, safely store the refresh
            token.[¶](#appendix-B-1.8.1.3.2.3){.pilcrow}]{#appendix-B-1.8.1.3.2.3}
        :::

    -   ::: {#appendix-B-1.8.1.4}
        Send the token and request to the RS (see step (C) of [Figure
        1](#fig_protocolFlow){.xref}).[¶](#appendix-B-1.8.1.4.1){.pilcrow}

        -   [Authenticate towards the RS (this could coincide with the
            proof-of-possession
            process).[¶](#appendix-B-1.8.1.4.2.1){.pilcrow}]{#appendix-B-1.8.1.4.2.1}
        -   [Transmit the token as specified by the AS (default is to
            the authz-info endpoint; alternative options are specified
            by
            profiles).[¶](#appendix-B-1.8.1.4.2.2){.pilcrow}]{#appendix-B-1.8.1.4.2.2}
        -   [Perform the proof-of-possession procedure as specified by
            the profile in use (this may already have been taken care of
            through the authentication
            procedure).[¶](#appendix-B-1.8.1.4.2.3){.pilcrow}]{#appendix-B-1.8.1.4.2.3}
        :::

    -   [Process the RS response (see step (F) of [Figure
        1](#fig_protocolFlow){.xref}) of the
        RS.[¶](#appendix-B-1.8.1.5){.pilcrow}]{#appendix-B-1.8.1.5}

:   

Resource Server

:   -   [Expose a way to submit access tokens. By default, this is the
        authz-info
        endpoint.[¶](#appendix-B-1.10.1.1){.pilcrow}]{#appendix-B-1.10.1.1}

    -   ::: {#appendix-B-1.10.1.2}
        Process an access token.[¶](#appendix-B-1.10.1.2.1){.pilcrow}

        -   [Verify the token is from a recognized
            AS.[¶](#appendix-B-1.10.1.2.2.1){.pilcrow}]{#appendix-B-1.10.1.2.2.1}
        -   [Check the token\'s
            integrity.[¶](#appendix-B-1.10.1.2.2.2){.pilcrow}]{#appendix-B-1.10.1.2.2.2}
        -   [Verify that the token applies to this
            RS.[¶](#appendix-B-1.10.1.2.2.3){.pilcrow}]{#appendix-B-1.10.1.2.2.3}
        -   [Check that the token has not expired (if the token provides
            expiration
            information).[¶](#appendix-B-1.10.1.2.2.4){.pilcrow}]{#appendix-B-1.10.1.2.2.4}
        -   [Store the token so that it can be retrieved in the context
            of a matching
            request.[¶](#appendix-B-1.10.1.2.2.5){.pilcrow}]{#appendix-B-1.10.1.2.2.5}

        Note: The order proposed here is not normative; any process that
        arrives at an equivalent result can be used. A noteworthy
        consideration is whether one can use cheap operations early on
        to quickly discard nonapplicable or invalid tokens before
        performing expensive cryptographic operations (e.g., doing an
        expiration check before verifying a
        signature).[¶](#appendix-B-1.10.1.2.3){.pilcrow}
        :::

    -   ::: {#appendix-B-1.10.1.3}
        Process a request.[¶](#appendix-B-1.10.1.3.1){.pilcrow}

        -   [Set up communication security with the
            client.[¶](#appendix-B-1.10.1.3.2.1){.pilcrow}]{#appendix-B-1.10.1.3.2.1}
        -   [Authenticate the
            client.[¶](#appendix-B-1.10.1.3.2.2){.pilcrow}]{#appendix-B-1.10.1.3.2.2}
        -   [Match the client against existing
            tokens.[¶](#appendix-B-1.10.1.3.2.3){.pilcrow}]{#appendix-B-1.10.1.3.2.3}
        -   [Check that tokens belonging to the client actually
            authorize the requested
            action.[¶](#appendix-B-1.10.1.3.2.4){.pilcrow}]{#appendix-B-1.10.1.3.2.4}
        -   [Optionally, check that the matching tokens are still valid,
            using introspection (if this is
            possible.)[¶](#appendix-B-1.10.1.3.2.5){.pilcrow}]{#appendix-B-1.10.1.3.2.5}
        :::

    -   [Send a response following the agreed upon communication
        security
        mechanism(s).[¶](#appendix-B-1.10.1.4){.pilcrow}]{#appendix-B-1.10.1.4}

    -   [Safely store credentials, such as raw public keys, for
        authentication or proof-of-possession keys linked to access
        tokens.[¶](#appendix-B-1.10.1.5){.pilcrow}]{#appendix-B-1.10.1.5}

:   
:::
:::

::: {#app_profileRequirements}
::: {#appendix-C .section}
## [Appendix C.](#appendix-C){.section-number .selfRef} [Requirements on Profiles](#name-requirements-on-profiles){.section-name .selfRef} {#name-requirements-on-profiles}

This section lists the requirements on profiles of this framework for
the convenience of profile designers.[¶](#appendix-C-1){.pilcrow}

-   [Optionally, define new methods for the client to discover the
    necessary permissions and AS for accessing a resource different from
    the one proposed in Sections [5.1](#asDiscovery){.xref} and
    [4](#specs){.xref}[¶](#appendix-C-2.1){.pilcrow}]{#appendix-C-2.1}
-   [Optionally, specify new grant types ([Section
    5.4](#authorizationGrants){.xref}).[¶](#appendix-C-2.2){.pilcrow}]{#appendix-C-2.2}
-   [Optionally, define the use of client certificates as client
    credential type ([Section
    5.5](#clientCredentials){.xref}).[¶](#appendix-C-2.3){.pilcrow}]{#appendix-C-2.3}
-   [Specify the communication protocol the client and RS must use
    (e.g., CoAP) (Sections [5](#oauthProfile){.xref} and
    [5.8.4.3](#paramProfile){.xref}).[¶](#appendix-C-2.4){.pilcrow}]{#appendix-C-2.4}
-   [Specify the security protocol the client and RS must use to protect
    their communication (e.g., OSCORE or DTLS). This must provide
    encryption and integrity and replay protection ([Section
    5.8.4.3](#paramProfile){.xref}).[¶](#appendix-C-2.5){.pilcrow}]{#appendix-C-2.5}
-   [Specify how the client and the RS mutually authenticate ([Section
    4](#specs){.xref}).[¶](#appendix-C-2.6){.pilcrow}]{#appendix-C-2.6}
-   [Specify the proof-of-possession protocol(s) and how to select one
    if several are available. Also specify which key types (e.g.,
    symmetric/asymmetric) are supported by a specific
    proof-of-possession protocol ([Section
    5.8.4.2](#paramTokenType){.xref}).[¶](#appendix-C-2.7){.pilcrow}]{#appendix-C-2.7}
-   [Specify a unique `ace_profile` identifier ([Section
    5.8.4.3](#paramProfile){.xref}).[¶](#appendix-C-2.8){.pilcrow}]{#appendix-C-2.8}
-   [If introspection is supported, specify the communication and
    security protocol for introspection ([Section
    5.9](#introspectionEndpoint){.xref}).[¶](#appendix-C-2.9){.pilcrow}]{#appendix-C-2.9}
-   [Specify the communication and security protocol for interactions
    between the client and AS. This must provide encryption, integrity
    protection, replay protection, and a binding between requests and
    responses (Sections [5](#oauthProfile){.xref} and
    [5.8](#tokenEndpoint){.xref}).[¶](#appendix-C-2.10){.pilcrow}]{#appendix-C-2.10}
-   [Specify how/if the authz-info endpoint is protected, including how
    error responses are protected ([Section
    5.10.1](#tokenAuthInfoEndpoint){.xref}).[¶](#appendix-C-2.11){.pilcrow}]{#appendix-C-2.11}
-   [Optionally, define other methods of token transport than the
    authz-info endpoint ([Section
    5.10.1](#tokenAuthInfoEndpoint){.xref}).[¶](#appendix-C-2.12){.pilcrow}]{#appendix-C-2.12}
:::
:::

::: {#app_registration}
::: {#appendix-D .section}
## [Appendix D.](#appendix-D){.section-number .selfRef} [Assumptions on AS Knowledge about the C and RS](#name-assumptions-on-as-knowledge){.section-name .selfRef} {#name-assumptions-on-as-knowledge}

This section lists the assumptions on what an AS should know about a
client and an RS in order to be able to respond to requests to the token
and introspection endpoints. How this information is established is out
of scope for this document.[¶](#appendix-D-1){.pilcrow}

-   [The identifier of the client or
    RS.[¶](#appendix-D-2.1){.pilcrow}]{#appendix-D-2.1}
-   [The profiles that the client or RS
    supports.[¶](#appendix-D-2.2){.pilcrow}]{#appendix-D-2.2}
-   [The scopes that the RS
    supports.[¶](#appendix-D-2.3){.pilcrow}]{#appendix-D-2.3}
-   [The audiences that the RS identifies
    with.[¶](#appendix-D-2.4){.pilcrow}]{#appendix-D-2.4}
-   [The key types (e.g., pre-shared symmetric key, raw public key, key
    length, and other key parameters) that the client or RS
    supports.[¶](#appendix-D-2.5){.pilcrow}]{#appendix-D-2.5}
-   [The types of access tokens the RS supports (e.g.,
    CWT).[¶](#appendix-D-2.6){.pilcrow}]{#appendix-D-2.6}
-   [If the RS supports CWTs, the COSE parameters for the crypto wrapper
    (e.g., algorithm, key-wrap algorithm, and key-length) that the RS
    supports.[¶](#appendix-D-2.7){.pilcrow}]{#appendix-D-2.7}
-   [The expiration time for access tokens issued to this RS (unless the
    RS accepts a default time chosen by the
    AS).[¶](#appendix-D-2.8){.pilcrow}]{#appendix-D-2.8}
-   [The symmetric key shared between the client and AS (if
    any).[¶](#appendix-D-2.9){.pilcrow}]{#appendix-D-2.9}
-   [The symmetric key shared between the RS and AS (if
    any).[¶](#appendix-D-2.10){.pilcrow}]{#appendix-D-2.10}
-   [The raw public key of the client or RS (if
    any).[¶](#appendix-D-2.11){.pilcrow}]{#appendix-D-2.11}
-   [Whether the RS has synchronized time (and thus is able to use the
    `exp` claim) or
    not.[¶](#appendix-D-2.12){.pilcrow}]{#appendix-D-2.12}
:::
:::

::: {#app_diffOAuth}
::: {#appendix-E .section}
## [Appendix E.](#appendix-E){.section-number .selfRef} [Differences to OAuth 2.0](#name-differences-to-oauth-20){.section-name .selfRef} {#name-differences-to-oauth-20}

This document adapts OAuth 2.0 to be suitable for constrained
environments. This section lists the main differences from the normative
requirements of OAuth 2.0.[¶](#appendix-E-1){.pilcrow}

[]{.break}

Use of TLS
:   OAuth 2.0 requires the use of TLS to protect the communication
    between the AS and client when requesting an access token, between
    the client and RS when accessing a resource, and between the AS and
    RS if introspection is used. This framework requires similar
    security properties but does not require that they be realized with
    TLS. See [Section
    5](#oauthProfile){.xref}.[¶](#appendix-E-2.2){.pilcrow}
:   

Cardinality of `grant_type` parameter
:   In client-to-AS requests using OAuth 2.0, the `grant_type` parameter
    is required (per \[[RFC6749](#RFC6749){.xref}\]). In this framework,
    this parameter is optional. See [Section
    5.8.1](#tokenRequest){.xref}.[¶](#appendix-E-2.4){.pilcrow}
:   

Encoding of `scope` parameter
:   In client-to-AS requests using OAuth 2.0, the `scope` parameter is
    string encoded (per \[[RFC6749](#RFC6749){.xref}\]). In this
    framework, this parameter may also be encoded as a byte string. See
    [Section 5.8.1](#tokenRequest){.xref}.[¶](#appendix-E-2.6){.pilcrow}
:   

Cardinality of `token_type` parameter
:   In AS-to-client responses using OAuth 2.0, the `token_type`
    parameter is required (per \[[RFC6749](#RFC6749){.xref}\]). In this
    framework, this parameter is optional. See [Section
    5.8.2](#tokenResponse){.xref}.[¶](#appendix-E-2.8){.pilcrow}
:   

Access token retention
:   In OAuth 2.0, the access token may be sent with every request to the
    RS. The exact use of access tokens depends on the semantics of the
    application and the session management concept it uses. In this
    framework, the RS must be able to store these tokens for later use.
    See [Section
    5.10.1](#tokenAuthInfoEndpoint){.xref}.[¶](#appendix-E-2.10){.pilcrow}
:   
:::
:::

::: {#app_options}
::: {#appendix-F .section}
## [Appendix F.](#appendix-F){.section-number .selfRef} [Deployment Examples](#name-deployment-examples){.section-name .selfRef} {#name-deployment-examples}

There is a large variety of IoT deployments, as is indicated in
[Appendix A](#constraints){.xref}, and this section highlights a few
common variants. This section is not normative but illustrates how the
framework can be applied.[¶](#appendix-F-1){.pilcrow}

For each of the deployment variants, there are a number of possible
security setups between clients, resource servers, and authorization
servers. The main focus in the following subsections is on how
authorization of a client request for a resource hosted by an RS is
performed. This requires the security of the requests and responses
between the clients and the RS to be
considered.[¶](#appendix-F-2){.pilcrow}

Note: CBOR diagnostic notation is used for examples of requests and
responses.[¶](#appendix-F-3){.pilcrow}

::: {#localTokenValidation}
::: {#appendix-F.1 .section}
### [F.1.](#appendix-F.1){.section-number .selfRef} [Local Token Validation](#name-local-token-validation){.section-name .selfRef} {#name-local-token-validation}

In this scenario, the case where the resource server is offline is
considered, i.e., it is not connected to the AS at the time of the
access request. This access procedure involves steps (A), (B), (C), and
(F) of [Figure
1](#fig_protocolFlow){.xref}.[¶](#appendix-F.1-1){.pilcrow}

Since the resource server must be able to verify the access token
locally, self-contained access tokens must be
used.[¶](#appendix-F.1-2){.pilcrow}

This example shows the interactions between a client, the authorization
server, and a temperature sensor acting as a resource server. Message
exchanges A and B are shown in [Figure
11](#fig_RSOffline){.xref}.[¶](#appendix-F.1-3){.pilcrow}

[]{.break}

A:

:   The client first generates a public-private key pair used for
    communication security with the
    RS.[¶](#appendix-F.1-4.2.1){.pilcrow}

    The client sends a CoAP POST request to the token endpoint at the
    AS. The security of this request can be transport or application
    layer. It is up the communication security profile to define. In the
    example, it is assumed that both the client and AS have performed
    mutual authentication, e.g., via DTLS. The request contains the
    public key of the client and the `audience` parameter set to
    \"tempSensorInLivingRoom\", a value that the temperature sensor
    identifies itself with. The AS evaluates the request and authorizes
    the client to access the resource.[¶](#appendix-F.1-4.2.2){.pilcrow}

:   

B:

:   The AS responds with a 2.05 (Content) response containing the Access
    Information, including the access token. The PoP access token
    contains the public key of the client, and the Access Information
    contains the public key of the RS. For communication security, this
    example uses DTLS RawPublicKey between the client and the RS. The
    issued token will have a short validity time, i.e., `exp` close to
    `iat`, in order to mitigate attacks using stolen client credentials.
    The token includes claims, such as `scope`, with the authorized
    access that an owner of the temperature device can enjoy. In this
    example, the `scope` claim issued by the AS informs the RS that the
    owner of the token that can prove the possession of a key is
    authorized to make a GET request against the /temperature resource
    and a POST request on the /firmware resource. Note that the syntax
    and semantics of the `scope` claim are application
    specific.[¶](#appendix-F.1-4.4.1){.pilcrow}

    Note: In this example, it is assumed that the client knows what
    resource it wants to access and is therefore able to request
    specific `audience` and `scope` claims for the access
    token.[¶](#appendix-F.1-4.4.2){.pilcrow}

:   

[]{#name-token-request-and-response-}

::: {#fig_RSOffline}
::: {#appendix-F.1-5.1 .alignLeft .art-text .artwork}
             Authorization
      Client    Server
        |         |
        |<=======>| DTLS Connection Establishment
        |         |   and mutual authentication
        |         |
    A:  +-------->| Header: POST (Code=0.02)
        |  POST   | Uri-Path:"token"
        |         | Content-Format: application/ace+cbor
        |         | Payload: <Request-Payload>
        |         |
    B:  |<--------+ Header: 2.05 Content
        |  2.05   | Content-Format: application/ace+cbor
        |         | Payload: <Response-Payload>
        |         |
:::

[Figure 11](#figure-11){.selfRef}: [Token Request and Response Using
Client Credentials](#name-token-request-and-response-){.selfRef}
:::

The information contained in the Request-Payload and the
Response-Payload is shown in [Figure 12](#fig_RSOfflineReq){.xref}. Note
that the parameter `rs_cnf` from \[[RFC9201](#RFC9201){.xref}\] is used
to inform the client about the resource server\'s public
key.[¶](#appendix-F.1-6){.pilcrow}

[]{#name-request-and-response-payloa}

::: {#fig_RSOfflineReq}
::: {#appendix-F.1-7.1}
``` {.lang-cbor-diag .sourcecode}
Request-Payload :
{
  / audience / 5 : "tempSensorInLivingRoom",
  / client_id / 24 : "myclient",
  / req_cnf / 4 : {
  / COSE_Key / 1 : {
      / kid / 2 : b64'1Bg8vub9tLe1gHMzV76e',
      / kty / 1 : 2 / EC2 /,
      / crv / -1 : 1 / P-256 /,
      / x / -2 : b64'f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU',
      / y / -3 : b64'x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0'
    }
  }
}

Response-Payload :
{
  / access_token / 1 : b64'0INDoQEKoQVNKkXfb7xaWqMT'/ .../,
  / rs_cnf / 41 : {
    / COSE_Key / 1 : {
      / kid / 2 : b64'c29tZSBwdWJsaWMga2V5IGlk',
      / kty / 1 : 2 / EC2 /,
      / crv / -1 : 1 / P-256 /,
      / x / -2   : b64'MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4',
      / y / -3   : b64'4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM'
    }
  }
}
```
:::

[Figure 12](#figure-12){.selfRef}: [Request and Response Payload
Details](#name-request-and-response-payloa){.selfRef}
:::

The content of the access token is shown in [Figure
13](#fig_BothcborMappingValueAsymmetricCWT){.xref}.[¶](#appendix-F.1-8){.pilcrow}

[]{#name-access-token-including-publ}

::: {#fig_BothcborMappingValueAsymmetricCWT}
::: {#appendix-F.1-9.1}
``` {.lang-cbor-diag .sourcecode}
{
  / aud / 3 : "tempSensorInLivingRoom",
  / iat / 6 : 1563451500,
  / exp / 4 : 1563453000,
  / scope / 9 :  "temperature_g firmware_p",
  / cnf / 8 : {
    / COSE_Key / 1 : {
      / kid / 2 : b64'1Bg8vub9tLe1gHMzV76e',
      / kty / 1 : 2 / EC2 /,
      / crv / -1 : 1 / P-256 /,
      / x / -2 : b64'f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU',
      / y / -3 : b64'x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0'
    }
  }
}
```
:::

[Figure 13](#figure-13){.selfRef}: [Access Token Including Public Key of
the Client](#name-access-token-including-publ){.selfRef}
:::

Messages C and F are shown in Figures
[14](#fig_RSOfflinePostAccessTokenAsymmetric){.xref} and
[15](#fig_RSOfflineDTLSRequestAndResponse){.xref}.[¶](#appendix-F.1-10){.pilcrow}

[]{.break}

C:
:   The client then sends the PoP access token to the authz-info
    endpoint at the RS. This is a plain CoAP POST request, i.e., no
    transport or application-layer security is used between the client
    and RS since the token is integrity protected between the AS and RS.
    The RS verifies that the PoP access token was created by a known and
    trusted AS, which it applies to this RS, and that it is valid. The
    RS caches the security context together with authorization
    information about this client contained in the PoP access
    token.[¶](#appendix-F.1-11.2){.pilcrow}
:   

[]{#name-access-token-provisioning-t}

::: {#fig_RSOfflinePostAccessTokenAsymmetric}
::: {#appendix-F.1-12.1 .alignLeft .art-text .artwork}
               Resource
     Client     Server
        |         |
    C:  +-------->| Header: POST (Code=0.02)
        |  POST   | Uri-Path:"authz-info"
        |         | Payload: 0INDoQEKoQVN ...
        |         |
        |<--------+ Header: 2.04 Changed
        |  2.04   |
        |         |
:::

[Figure 14](#figure-14){.selfRef}: [Access Token Provisioning to the
RS](#name-access-token-provisioning-t){.selfRef}
:::

The client and the RS runs the DTLS handshake using the raw public keys
established in steps B and C.[¶](#appendix-F.1-13){.pilcrow}

The client sends a CoAP GET request to /temperature on the RS over DTLS.
The RS verifies that the request is authorized based on previously
established security context.[¶](#appendix-F.1-14){.pilcrow}

[]{.break}

F:
:   The RS responds over the same DTLS channel with a CoAP 2.05 Content
    response containing a resource representation as
    payload.[¶](#appendix-F.1-15.2){.pilcrow}
:   

[]{#name-resource-request-and-respon}

::: {#fig_RSOfflineDTLSRequestAndResponse}
::: {#appendix-F.1-16.1 .alignLeft .art-text .artwork}
               Resource
     Client     Server
        |         |
        |<=======>| DTLS Connection Establishment
        |         |   using Raw Public Keys
        |         |
        +-------->| Header: GET (Code=0.01)
        | GET     | Uri-Path: "temperature"
        |         |
        |         |
        |         |
    F:  |<--------+ Header: 2.05 Content
        | 2.05    | Payload: <sensor value>
        |         |
:::

[Figure 15](#figure-15){.selfRef}: [Resource Request and Response
Protected by DTLS](#name-resource-request-and-respon){.selfRef}
:::
:::
:::

::: {#introspectionAidedTokenValidation}
::: {#appendix-F.2 .section}
### [F.2.](#appendix-F.2){.section-number .selfRef} [Introspection Aided Token Validation](#name-introspection-aided-token-v){.section-name .selfRef} {#name-introspection-aided-token-v}

In this deployment scenario, it is assumed that a client is not able to
access the AS at the time of the access request, whereas the RS is
assumed to be connected to the back-end infrastructure. Thus, the RS can
make use of token introspection. This access procedure involves steps
(A)-(F) of [Figure 1](#fig_protocolFlow){.xref} but assumes steps (A)
and (B) have been carried out during a phase when the client had
connectivity to the AS.[¶](#appendix-F.2-1){.pilcrow}

Since the client is assumed to be offline, at least for a certain period
of time, a preprovisioned access token has to be long lived. Since the
client is constrained, the token will not be self-contained (i.e., not a
CWT) but instead just a reference. The resource server uses its
connectivity to learn about the claims associated to the access token by
using introspection, which is shown in the example
below.[¶](#appendix-F.2-2){.pilcrow}

In the example, interactions between an offline client (key fob), an RS
(online lock), and an AS is shown. It is assumed that there is a
provisioning step where the client has access to the AS. This
corresponds to message exchanges A and B, which are shown in [Figure
16](#fig_cOffline){.xref}.[¶](#appendix-F.2-3){.pilcrow}

Authorization consent from the resource owner can be preconfigured, but
it can also be provided via an interactive flow with the resource owner.
An example of this for the key fob case could be that the resource owner
has a connected car and buys a generic key to use with the car. To
authorize the key fob, the owner connects it to a computer that then
provides the UI for the device. After that, OAuth 2.0 implicit flow can
be used to authorize the key for the car at the car manufacturer\'s
AS.[¶](#appendix-F.2-4){.pilcrow}

Note: In this example, the client does not know the exact door it will
be used to access since the token request is not sent at the time of
access. So the `scope` and `audience` parameters are set quite wide to
start with, while tailored values narrowing down the claims to the
specific RS being accessed can be provided to that RS during an
introspection step.[¶](#appendix-F.2-5){.pilcrow}

[]{.break}

A:
:   The client sends a CoAP POST request to the token endpoint at the
    AS. The request contains the `audience` parameter set to
    \"PACS1337\" (Physical Access System (PACS)), a value that
    identifies the physical access control system to which the
    individual doors are connected. The AS generates an access token as
    an opaque string, which it can match to the specific client and the
    targeted audience. It furthermore generates a symmetric
    proof-of-possession key. The communication security and
    authentication between the client and AS is assumed to have been
    provided at the transport layer (e.g., via DTLS) using a pre-shared
    security context (pre-shared key (PSK), RPK, or
    certificate).[¶](#appendix-F.2-6.2){.pilcrow}
:   

B:
:   The AS responds with a CoAP 2.05 Content response, containing as
    payload the Access Information, including the access token and the
    symmetric proof-of-possession key. Communication security between
    the C and RS will be DTLS and PreSharedKey. The PoP key is used as
    the PreSharedKey.[¶](#appendix-F.2-6.4){.pilcrow}
:   

Note: In this example, we are using a symmetric key for a multi-RS
audience, which is not recommended normally (see [Section
6.9](#audience){.xref}). However, in this case, the risk is deemed to be
acceptable, since all the doors are part of the same physical access
control system; therefore, the risk of a malicious RS impersonating the
client towards another RS is low.[¶](#appendix-F.2-7){.pilcrow}

[]{#name-token-request-and-response-u}

::: {#fig_cOffline}
::: {#appendix-F.2-8.1 .alignLeft .art-text .artwork}
             Authorization
     Client     Server
        |         |
        |<=======>| DTLS Connection Establishment
        |         |   and mutual authentication
        |         |
    A:  +-------->| Header: POST (Code=0.02)
        |  POST   | Uri-Path:"token"
        |         | Content-Format: application/ace+cbor
        |         | Payload: <Request-Payload>
        |         |
    B:  |<--------+ Header: 2.05 Content
        |         | Content-Format: application/ace+cbor
        |  2.05   | Payload: <Response-Payload>
        |         |
:::

[Figure 16](#figure-16){.selfRef}: [Token Request and Response Using
Client Credentials](#name-token-request-and-response-u){.selfRef}
:::

The information contained in the Request-Payload and the
Response-Payload is shown in [Figure
17](#fig_cOfflineReq){.xref}.[¶](#appendix-F.2-9){.pilcrow}

[]{#name-request-and-response-payload}

::: {#fig_cOfflineReq}
::: {#appendix-F.2-10.1}
``` {.lang-cbor-diag .sourcecode}
Request-Payload:
{
  / client_id / 24 : "keyfob",
  / audience / 5   : "PACS1337"
}

Response-Payload:
{
  / access_token / 1 : b64'VGVzdCB0b2tlbg',
  / cnf / 8 : {
    / COSE_Key / 1 : {
      / kid / 2 : b64'c29tZSBwdWJsaWMga2V5IGlk',
      / kty / 1 : 4 / Symmetric /,
      / k / -1  : b64'ZoRSOrFzN_FzUA5XKMYoVHyzff5oRJxl-IXRtztJ6uE'
    }
  }
}
```
:::

[Figure 17](#figure-17){.selfRef}: [Request and Response Payload for the
C Offline](#name-request-and-response-payload){.selfRef}
:::

In this case, the access token is just an opaque byte string referencing
the authorization information at the AS.[¶](#appendix-F.2-11){.pilcrow}

[]{.break}

C:
:   Next, the client POSTs the access token to the authz-info endpoint
    in the RS. This is a plain CoAP request, i.e., no DTLS between the
    client and RS. Since the token is an opaque string, the RS cannot
    verify it on its own, and thus defers to respond to the client with
    a status code until after step E.[¶](#appendix-F.2-12.2){.pilcrow}
:   

D:
:   The RS sends the token to the introspection endpoint on the AS using
    a CoAP POST request. In this example, the RS and AS are assumed to
    have performed mutual authentication using a pre-shared security
    context (PSK, RPK, or certificate) with the RS acting as the DTLS
    client.[¶](#appendix-F.2-12.4){.pilcrow}
:   

E:

:   The AS provides the introspection response (2.05 Content) containing
    parameters about the token. This includes the confirmation key
    (`cnf`) parameter that allows the RS to verify the client\'s proof
    of possession in step F. Note that our example in [Figure
    19](#fig_cOfflineIntroReq){.xref} assumes a preestablished key
    (e.g., one used by the client and the RS for a previous token) that
    is now only referenced by its key identifier
    `kid`.[¶](#appendix-F.2-12.6.1){.pilcrow}

    After receiving message E, the RS responds to the client\'s POST in
    step C with the CoAP response code 2.01
    (Created).[¶](#appendix-F.2-12.6.2){.pilcrow}

:   

[]{#name-token-introspection-for-the}

::: {#fig_cOfflineIntrospection}
::: {#appendix-F.2-13.1 .alignLeft .art-text .artwork}
               Resource
      Client    Server
        |         |
    C:  +-------->| Header: POST (T=CON, Code=0.02)
        |  POST   | Uri-Path:"authz-info"
        |         | Payload: b64'VGVzdCB0b2tlbg'
        |         |
        |         |     Authorization
        |         |       Server
        |         |          |
        |      D: +--------->| Header: POST (Code=0.02)
        |         |  POST    | Uri-Path: "introspect"
        |         |          | Content-Format: application/ace+cbor
        |         |          | Payload: <Request-Payload>
        |         |          |
        |      E: |<---------+ Header: 2.05 Content
        |         |  2.05    | Content-Format: application/ace+cbor
        |         |          | Payload: <Response-Payload>
        |         |          |
        |         |
        |<--------+ Header: 2.01 Created
        |  2.01   |
        |         |
:::

[Figure 18](#figure-18){.selfRef}: [Token Introspection for the C
Offline](#name-token-introspection-for-the){.selfRef}
:::

The information contained in the Request-Payload and the
Response-Payload is shown in [Figure
19](#fig_cOfflineIntroReq){.xref}.[¶](#appendix-F.2-14){.pilcrow}

[]{#name-request-and-response-payload-}

::: {#fig_cOfflineIntroReq}
::: {#appendix-F.2-15.1}
``` {.lang-cbor-diag .sourcecode}
Request-Payload:
{
  / token /     11 : b64'VGVzdCB0b2tlbg',
  / client_id / 24 : "FrontDoor"
}

Response-Payload:
{
  / active / 10 : true,
  / aud /     3 : "lockOfDoor4711",
  / scope /   9 : "open close",
  / iat /     6 : 1563454000,
  / cnf /     8 : {
         / kid / 3 : b64'c29tZSBwdWJsaWMga2V5IGlk'
  }
}
```
:::

[Figure 19](#figure-19){.selfRef}: [Request and Response Payload for
Introspection](#name-request-and-response-payload-){.selfRef}
:::

The client uses the symmetric PoP key to establish a DTLS PreSharedKey
secure connection to the RS. The CoAP request PUT is sent to the
uri-path /state on the RS, changing the state of the door to
locked.[¶](#appendix-F.2-16){.pilcrow}

[]{.break}

F:
:   The RS responds with an appropriate response over the secure DTLS
    channel.[¶](#appendix-F.2-17.2){.pilcrow}
:   

[]{#name-resource-request-and-respons}

::: {#fig_cOfflineDTLSRequestAndResponse}
::: {#appendix-F.2-18.1 .alignLeft .art-text .artwork}
               Resource
      Client    Server
        |         |
        |<=======>| DTLS Connection Establishment
        |         |   using Pre Shared Key
        |         |
        +-------->| Header: PUT (Code=0.03)
        | PUT     | Uri-Path: "state"
        |         | Payload: <new state for the lock>
        |         |
    F:  |<--------+ Header: 2.04 Changed
        | 2.04    | Payload: <new state for the lock>
        |         |
:::

[Figure 20](#figure-20){.selfRef}: [Resource Request and Response
Protected by OSCORE](#name-resource-request-and-respons){.selfRef}
:::
:::
:::
:::
:::

::: {#Acknowledgments}
::: {#appendix-G .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

This document is a product of the ACE Working Group of the
IETF.[¶](#appendix-G-1){.pilcrow}

Thanks to [Eve Maler]{.contact-name} for her contributions to the use of
OAuth 2.0 and Unlicensed Mobile Access (UMA) in IoT scenarios, [Robert
Taylor]{.contact-name} for his discussion input, and [Mališa
Vučinić]{.contact-name} for his input on the predecessors of this
proposal.[¶](#appendix-G-2){.pilcrow}

Thanks to the authors of
\"\[[POP-KEY-DIST](#I-D.ietf-oauth-pop-key-distribution){.xref}\][OAuth
2.0 Proof-of-Possession: Authorization Server to Client Key
Distribution](#I-D.ietf-oauth-pop-key-distribution){.xref}\"
\[[POP-KEY-DIST](#I-D.ietf-oauth-pop-key-distribution){.xref}\], from
where parts of the security considerations where
copied.[¶](#appendix-G-3){.pilcrow}

Thanks to [Stefanie Gerdes]{.contact-name}, [Olaf
Bergmann]{.contact-name}, and [Carsten Bormann]{.contact-name} for
contributing their work on AS discovery from \"[Delegated CoAP
Authentication and Authorization Framework
(DCAF)](#I-D.gerdes-ace-dcaf-authorize){.xref}\"
\[[DCAF](#I-D.gerdes-ace-dcaf-authorize){.xref}\] (see [Section
5.1](#asDiscovery){.xref}) and the considerations on multiple access
tokens.[¶](#appendix-G-4){.pilcrow}

Thanks to [Jim Schaad]{.contact-name} and [Mike Jones]{.contact-name}
for their comprehensive reviews.[¶](#appendix-G-5){.pilcrow}

Thanks to [Benjamin Kaduk]{.contact-name} for his input on various
questions related to this work.[¶](#appendix-G-6){.pilcrow}

Thanks to [Cigdem Sengul]{.contact-name} for some very useful review
comments.[¶](#appendix-G-7){.pilcrow}

Thanks to [Carsten Bormann]{.contact-name} for contributing the text for
the CoRE Resource Type registry.[¶](#appendix-G-8){.pilcrow}

Thanks to [Roman Danyliw]{.contact-name} for suggesting [Appendix
E](#app_diffOAuth){.xref} (including its
contents).[¶](#appendix-G-9){.pilcrow}

[Ludwig Seitz]{.contact-name} and [Göran Selander]{.contact-name} worked
on this document as part of the CelticPlus project CyberWI, with funding
from Vinnova. [Ludwig Seitz]{.contact-name} has also received further
funding for this work by Vinnova in the context of the CelticNext
project CRITISEC.[¶](#appendix-G-10){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-H .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Ludwig Seitz]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Combitech]{.org}
:::

::: {.left dir="auto"}
[Djäknegatan 31]{.street-address}
:::

::: {.left dir="auto"}
SE-[211 35]{.postal-code} [Malmö]{.locality}
:::

::: {.left dir="auto"}
[Sweden]{.country-name}
:::

::: email
Email: <ludwig.seitz@combitech.com>
:::

::: {.left dir="auto"}
[Göran Selander]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Ericsson]{.org}
:::

::: {.left dir="auto"}
SE-[164 80]{.postal-code} [Kista]{.locality}
:::

::: {.left dir="auto"}
[Sweden]{.country-name}
:::

::: email
Email: <goran.selander@ericsson.com>
:::

::: {.left dir="auto"}
[Erik Wahlstroem]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Sweden]{.country-name}
:::

::: email
Email: <erik@wahlstromstekniska.se>
:::

::: {.left dir="auto"}
[Samuel Erdtman]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Spotify AB]{.org}
:::

::: {.left dir="auto"}
[Birger Jarlsgatan 61, 4tr]{.street-address}
:::

::: {.left dir="auto"}
SE-[113 56]{.postal-code} [Stockholm]{.locality}
:::

::: {.left dir="auto"}
[Sweden]{.country-name}
:::

::: email
Email: <erdtman@spotify.com>
:::

::: {.left dir="auto"}
[Hannes Tschofenig]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Arm Ltd.]{.org}
:::

::: {.left dir="auto"}
[6067]{.postal-code} [Absam]{.locality}
:::

::: {.left dir="auto"}
[Austria]{.country-name}
:::

::: email
Email: <Hannes.Tschofenig@arm.com>
:::
:::
:::
