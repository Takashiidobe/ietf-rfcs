  RFC 8961   Requirements for Time-Based Loss Detecti   November 2020
  ---------- ------------------------------------------ ---------------
  Allman     Best Current Practice                      \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8961](https://www.rfc-editor.org/rfc/rfc8961){.eref}

BCP:
:   233

Category:
:   Best Current Practice

Published:
:   November 2020

ISSN:
:   2070-1721

Author:

:   ::: author
    ::: author-name
    M. Allman
    :::

    ::: org
    ICSI
    :::
    :::
:::

# RFC 8961 {#rfcnum}

# Requirements for Time-Based Loss Detection {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

Many protocols must detect packet loss for various reasons (e.g., to
ensure reliability using retransmissions or to understand the level of
congestion along a network path). While many mechanisms have been
designed to detect loss, ultimately, protocols can only count on the
passage of time without delivery confirmation to declare a packet
\"lost\". Each implementation of a time-based loss detection mechanism
represents a balance between correctness and timeliness; therefore, no
implementation suits all situations. This document provides high-level
requirements for time-based loss detectors appropriate for general use
in unicast communication across the Internet. Within the requirements,
implementations have latitude to define particulars that best address
each situation.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This memo documents an Internet Best Current
Practice.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on BCPs
is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8961>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.1.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Context](#name-context){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Scope](#name-scope){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Requirements](#name-requirements){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Discussion](#name-discussion){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [References](#name-references){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.8.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.8.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [](#section-appendix.a){.xref}[Acknowledgments](#name-acknowledgments){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [](#section-appendix.b){.xref}[Author\'s
    Address](#name-authors-address){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::
:::
:::

::: {#sect-1}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

As a network of networks, the Internet consists of a large variety of
links and systems that support a wide variety of tasks and workloads.
The service provided by the network varies from best-effort delivery
among loosely connected components to highly predictable delivery within
controlled environments (e.g., between physically connected nodes,
within a tightly controlled data center). Each path through the network
has a set of path properties, e.g., available capacity, delay, and
packet loss. Given the range of networks that make up the Internet,
these properties range from largely static to highly
dynamic.[¶](#section-1-1){.pilcrow}

This document provides guidelines for developing an understanding of one
path property: packet loss. In particular, we offer guidelines for
developing and implementing time-based loss detectors that have been
gradually learned over the last several decades. We focus on the general
case where the loss properties of a path are (a) unknown a priori and
(b) dynamically varying over time. Further, while there are numerous
root causes of packet loss, we leverage the conservative notion that
loss is an implicit indication of congestion
\[[RFC5681](#RFC5681){.xref}\]. While this stance is not always correct,
as a general assumption it has historically served us well
\[[Jac88](#Jac88){.xref}\]. As we discuss further in [Section
2](#sect-2){.xref}, the guidelines in this document should be viewed as
a general default for unicast communication across best-effort networks
and not as optimal \-- or even applicable \-- for all
situations.[¶](#section-1-2){.pilcrow}

Given that packet loss is routine in best-effort networks, loss
detection is a crucial activity for many protocols and applications and
is generally undertaken for two major
reasons:[¶](#section-1-3){.pilcrow}

[]{.break}

\(1\)

:   Ensuring reliable data delivery[¶](#section-1-4.1.1){.pilcrow}

    This requires a data sender to develop an understanding of which
    transmitted packets have not arrived at the receiver. This knowledge
    allows the sender to retransmit missing
    data.[¶](#section-1-4.1.2){.pilcrow}

:   

\(2\)

:   Congestion control[¶](#section-1-4.2.1){.pilcrow}

    As we mention above, packet loss is often taken as an implicit
    indication that the sender is transmitting too fast and is
    overwhelming some portion of the network path. Data senders can
    therefore use loss to trigger transmission rate
    reductions.[¶](#section-1-4.2.2){.pilcrow}

:   

Various mechanisms are used to detect losses in a packet stream. Often,
we use continuous or periodic acknowledgments from the recipient to
inform the sender\'s notion of which pieces of data are missing.
However, despite our best intentions and most robust mechanisms, we
cannot place ultimate faith in receiving such acknowledgments but can
only truly depend on the passage of time. Therefore, our ultimate
backstop to ensuring that we detect all loss is a timeout. That is, the
sender sets some expectation for how long to wait for confirmation of
delivery for a given piece of data. When this time period passes without
delivery confirmation, the sender concludes the data was lost in
transit.[¶](#section-1-5){.pilcrow}

The specifics of time-based loss detection schemes represent a tradeoff
between correctness and responsiveness. In other words, we wish to
simultaneously:[¶](#section-1-6){.pilcrow}

-   [wait long enough to ensure the detection of loss is correct,
    and[¶](#section-1-7.1){.pilcrow}]{#section-1-7.1}
-   [minimize the amount of delay we impose on applications (before
    repairing loss) and the network (before we reduce the
    congestion).[¶](#section-1-7.2){.pilcrow}]{#section-1-7.2}

Serving both of these goals is difficult, as they pull in opposite
directions \[[AP99](#AP99){.xref}\]. By not waiting long enough to
accurately determine a packet has been lost, we may provide a needed
retransmission in a timely manner but risk both sending unnecessary
(\"spurious\") retransmissions and needlessly lowering the transmission
rate. By waiting long enough that we are unambiguously certain a packet
has been lost, we cannot repair losses in a timely manner and we risk
prolonging network congestion.[¶](#section-1-8){.pilcrow}

Many protocols and applications \-- such as TCP
\[[RFC6298](#RFC6298){.xref}\], SCTP \[[RFC4960](#RFC4960){.xref}\], and
SIP \[[RFC3261](#RFC3261){.xref}\] \-- use their own time-based loss
detection mechanisms. At this point, our experience leads to a
recognition that often specific tweaks that deviate from standardized
time-based loss detectors do not materially impact network safety with
respect to congestion control \[[AP99](#AP99){.xref}\]. Therefore, in
this document we outline a set of high-level, protocol-agnostic
requirements for time-based loss detection. The intent is to provide a
safe foundation on which implementations have the flexibility to
instantiate mechanisms that best realize their specific
goals.[¶](#section-1-9){.pilcrow}

::: {#sect-1.1}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-1){.pilcrow}
:::
:::
:::
:::

::: {#sect-2}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Context](#name-context){.section-name .selfRef} {#name-context}

This document is different from the way we ideally like to engineer
systems. Usually, we strive to understand high-level requirements as a
starting point. We then methodically engineer specific protocols,
algorithms, and systems that meet these requirements. Within the IETF
standards process, we have derived many time-based loss detection
schemes without the benefit of some over-arching requirements document
\-- because we had no idea how to write such a document! Therefore, we
made the best specific decisions we could in response to specific
needs.[¶](#section-2-1){.pilcrow}

At this point, however, the community\'s experience has matured to the
point where we can define a set of general, high-level requirements for
time-based loss detection schemes. We now understand how to separate the
strategies these mechanisms use that are crucial for network safety from
those small details that do not materially impact network safety. The
requirements in this document may not be appropriate in all cases. In
particular, the guidelines in [Section 4](#sect-4){.xref} are concerned
with the general case, but specific situations may allow for more
flexibility in terms of loss detection because specific facets of the
environment are known (e.g., when operating over a single physical link
or within a tightly controlled data center). Therefore, variants,
deviations, or wholly different time-based loss detectors may be
necessary or useful in some cases. The correct way to view this document
is as the default case and not as one-size-fits-all guidance that is
optimal in all cases.[¶](#section-2-2){.pilcrow}

Adding a requirements umbrella to a body of existing specifications is
inherently messy and we run the risk of creating inconsistencies with
both past and future mechanisms. Therefore, we make the following
statements about the relationship of this document to past and future
specifications:[¶](#section-2-3){.pilcrow}

-   [This document does not update or obsolete any existing RFC. These
    previous specifications \-- while generally consistent with the
    requirements in this document \-- reflect community consensus, and
    this document does not change that
    consensus.[¶](#section-2-4.1){.pilcrow}]{#section-2-4.1}
-   [The requirements in this document are meant to provide for network
    safety and, as such, [SHOULD]{.bcp14} be used by all future
    time-based loss detection
    mechanisms.[¶](#section-2-4.2){.pilcrow}]{#section-2-4.2}
-   [The requirements in this document may not be appropriate in all
    cases; therefore, deviations and variants may be necessary in the
    future (hence the \"[SHOULD]{.bcp14}\" in the last bullet). However,
    inconsistencies [MUST]{.bcp14} be (a) explained and (b) gather
    consensus.[¶](#section-2-4.3){.pilcrow}]{#section-2-4.3}
:::
:::

::: {#sect-3}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Scope](#name-scope){.section-name .selfRef} {#name-scope}

The principles we outline in this document are protocol-agnostic and
widely applicable. We make the following scope statements about the
application of the requirements discussed in [Section
4](#sect-4){.xref}:[¶](#section-3-1){.pilcrow}

[]{.break}

(S.1)
:   While there are a bevy of uses for timers in protocols \-- from
    rate-based pacing to connection failure detection and beyond \--
    this document is focused only on loss
    detection.[¶](#section-3-2.1){.pilcrow}
:   

(S.2)

:   The requirements for time-based loss detection mechanisms in this
    document are for the primary or \"last resort\" loss detection
    mechanism, whether the mechanism is the sole loss repair strategy or
    works in concert with other
    mechanisms.[¶](#section-3-2.2.1){.pilcrow}

    While a straightforward time-based loss detector is sufficient for
    simple protocols like DNS \[[RFC1034](#RFC1034){.xref}\]
    \[[RFC1035](#RFC1035){.xref}\], more complex protocols often use
    more advanced loss detectors to aid performance. For instance, TCP
    and SCTP have methods to detect (and repair) loss based on explicit
    endpoint state sharing \[[RFC2018](#RFC2018){.xref}\]
    \[[RFC4960](#RFC4960){.xref}\] \[[RFC6675](#RFC6675){.xref}\]. Such
    mechanisms often provide more timely and precise loss detection than
    time-based loss detectors. However, these mechanisms do not obviate
    the need for a \"retransmission timeout\" or \"RTO\" because, as we
    discuss in [Section 1](#sect-1){.xref}, only the passage of time can
    ultimately be relied upon to detect loss. In other words, we
    ultimately cannot count on acknowledgments to arrive at the data
    sender to indicate which packets never arrived at the receiver. In
    cases such as these, we need a time-based loss detector to function
    as a \"last resort\".[¶](#section-3-2.2.2){.pilcrow}

    Also, note that some recent proposals have incorporated time as a
    component of advanced loss detection methods either as an aggressive
    first loss detector in certain situations or in conjunction with
    endpoint state sharing
    \[[DCCM13](#I-D.dukkipati-tcpm-tcp-loss-probe){.xref}\]
    \[[CCDJ20](#I-D.ietf-tcpm-rack){.xref}\]
    \[[IS20](#I-D.ietf-quic-recovery){.xref}\]. While these mechanisms
    can aid timely loss recovery, the protocol ultimately leans on
    another more conservative timer to ensure reliability when these
    mechanisms break down. The requirements in this document are only
    directly applicable to last-resort loss detection. However, we
    expect that many of the requirements can serve as useful guidelines
    for more aggressive non-last-resort timers as
    well.[¶](#section-3-2.2.3){.pilcrow}

:   

(S.3)

:   The requirements in this document apply only to endpoint-to-endpoint
    unicast communication. Reliable multicast (e.g.,
    \[[RFC5740](#RFC5740){.xref}\]) protocols are explicitly outside the
    scope of this document.[¶](#section-3-2.3.1){.pilcrow}

    Protocols such as SCTP \[[RFC4960](#RFC4960){.xref}\] and Multipath
    TCP (MP-TCP) \[[RFC6182](#RFC6182){.xref}\] that communicate in a
    unicast fashion with multiple specific endpoints can leverage the
    requirements in this document provided they track state and follow
    the requirements for each endpoint independently. That is, if host A
    communicates with addresses B and C, A needs to use independent
    time-based loss detector instances for traffic sent to B and
    C.[¶](#section-3-2.3.2){.pilcrow}

:   

(S.4)
:   There are cases where state is shared across connections or flows
    (e.g., \[[RFC2140](#RFC2140){.xref}\] and
    \[[RFC3124](#RFC3124){.xref}\]). State pertaining to time-based loss
    detection is often discussed as sharable. These situations raise
    issues that the simple flow-oriented time-based loss detection
    mechanism discussed in this document does not consider (e.g., how
    long to preserve state between connections). Therefore, while the
    general principles given in [Section 4](#sect-4){.xref} are likely
    applicable, sharing time-based loss detection information across
    flows is outside the scope of this
    document.[¶](#section-3-2.4){.pilcrow}
:   
:::
:::

::: {#sect-4}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Requirements](#name-requirements){.section-name .selfRef} {#name-requirements}

We now list the requirements that apply when designing primary or
last-resort time-based loss detection mechanisms. For historical reasons
and ease of exposition, we refer to the time between sending a packet
and determining the packet has been lost due to lack of delivery
confirmation as the \"retransmission timeout\" or \"RTO\". After the RTO
passes without delivery confirmation, the sender may safely assume the
packet is lost. However, as discussed above, the detected loss need not
be repaired (i.e., the loss could be detected only for congestion
control and not reliability purposes).[¶](#section-4-1){.pilcrow}

[]{.break}

\(1\)

:   As we note above, loss detection happens when a sender does not
    receive delivery confirmation within some expected period of time.
    In the absence of any knowledge about the latency of a path, the
    initial RTO [MUST]{.bcp14} be conservatively set to no less than 1
    second.[¶](#section-4-2.1.1){.pilcrow}

    Correctness is of the utmost importance when transmitting into a
    network with unknown properties
    because:[¶](#section-4-2.1.2){.pilcrow}

    -   [Premature loss detection can trigger spurious retransmits that
        could cause issues when a network is already
        congested.[¶](#section-4-2.1.3.1){.pilcrow}]{#section-4-2.1.3.1}
    -   [Premature loss detection can needlessly cause congestion
        control to dramatically lower the sender\'s allowed transmission
        rate, especially since the rate is already likely low at this
        stage of the communication. Recovering from such a rate change
        can take a relatively long
        time.[¶](#section-4-2.1.3.2){.pilcrow}]{#section-4-2.1.3.2}
    -   [Finally, as discussed below, sometimes using time-based loss
        detection and retransmissions can cause ambiguities in assessing
        the latency of a network path. Therefore, it is especially
        important for the first latency sample to be free of ambiguities
        such that there is a baseline for the remainder of the
        communication.[¶](#section-4-2.1.3.3){.pilcrow}]{#section-4-2.1.3.3}

    The specific constant (1 second) comes from the analysis of Internet
    round-trip times (RTTs) found in [Appendix
    A](https://www.rfc-editor.org/rfc/rfc6298#appendix-A){.relref} of
    \[[RFC6298](#RFC6298){.xref}\].[¶](#section-4-2.1.4){.pilcrow}

:   

\(2\)

:   We now specify four requirements that pertain to setting an expected
    time interval for delivery
    confirmation.[¶](#section-4-2.2.1){.pilcrow}

    Often, measuring the time required for delivery confirmation is
    framed as assessing the RTT of the network path. The RTT is the
    minimum amount of time required to receive delivery confirmation and
    also often follows protocol behavior whereby acknowledgments are
    generated quickly after data arrives. For instance, this is the case
    for the RTO used by TCP \[[RFC6298](#RFC6298){.xref}\] and SCTP
    \[[RFC4960](#RFC4960){.xref}\]. However, this is somewhat
    misleading, and the expected latency is better framed as the
    \"feedback time\" (FT). In other words, the expectation is not
    always simply a network property; it can include additional time
    before a sender should reasonably expect a
    response.[¶](#section-4-2.2.2){.pilcrow}

    For instance, consider a UDP-based DNS request from a client to a
    recursive resolver \[[RFC1035](#RFC1035){.xref}\]. When the request
    can be served from the resolver\'s cache, the feedback time (FT)
    likely well approximates the network RTT between the client and
    resolver. However, on a cache miss, the resolver will request the
    needed information from one or more authoritative DNS servers, which
    will non-trivially increase the FT compared to the network RTT
    between the client and resolver.[¶](#section-4-2.2.3){.pilcrow}

    Therefore, we express the requirements in terms of FT. Again, for
    ease of exposition, we use \"RTO\" to indicate the interval between
    a packet transmission and the decision that the packet has been
    lost, regardless of whether the packet will be
    retransmitted.[¶](#section-4-2.2.4){.pilcrow}

    []{.break}

    \(a\)

    :   The RTO [SHOULD]{.bcp14} be set based on multiple observations
        of the FT when available.[¶](#section-4-2.2.5.1.1){.pilcrow}

        In other words, the RTO should represent an empirically derived
        reasonable amount of time that the sender should wait for
        delivery confirmation before deciding the given data is lost.
        Network paths are inherently dynamic; therefore, it is crucial
        to incorporate multiple recent FT samples in the RTO to take
        into account the delay variation across
        time.[¶](#section-4-2.2.5.1.2){.pilcrow}

        For example, TCP\'s RTO \[[RFC6298](#RFC6298){.xref}\] would
        satisfy this requirement due to its use of an exponentially
        weighted moving average (EWMA) to combine multiple FT samples
        into a \"smoothed RTT\". In the name of conservativeness, TCP
        goes further to also include an explicit variance term when
        computing the RTO.[¶](#section-4-2.2.5.1.3){.pilcrow}

        While multiple FT samples are crucial for capturing the delay
        dynamics of a path, we explicitly do not tightly specify the
        process \-- including the number of FT samples to use and
        how/when to age samples out of the RTO calculation \-- as the
        particulars could depend on the situation and/or goals of each
        specific loss detector.[¶](#section-4-2.2.5.1.4){.pilcrow}

        Finally, FT samples come from packet exchanges between peers. We
        encourage protocol designers \-- especially for new protocols
        \-- to strive to ensure the feedback is not easily spoofable by
        on- or off-path attackers such that they can perturb a host\'s
        notion of the FT. Ideally, all messages would be
        cryptographically secure, but given that this is not always
        possible \-- especially in legacy protocols \-- using a healthy
        amount of randomness in the packets is
        encouraged.[¶](#section-4-2.2.5.1.5){.pilcrow}

    :   

    \(b\)

    :   FT observations [SHOULD]{.bcp14} be taken and incorporated into
        the RTO at least once per RTT or as frequently as data is
        exchanged in cases where that happens less frequently than once
        per RTT.[¶](#section-4-2.2.5.2.1){.pilcrow}

        Internet measurements show that taking only a single FT sample
        per TCP connection results in a relatively poorly performing RTO
        mechanism \[[AP99](#AP99){.xref}\], hence this requirement that
        the FT be sampled continuously throughout the lifetime of
        communication.[¶](#section-4-2.2.5.2.2){.pilcrow}

        As an example, TCP takes an FT sample roughly once per RTT, or,
        if using the timestamp option \[[RFC7323](#RFC7323){.xref}\], on
        each acknowledgment arrival. \[[AP99](#AP99){.xref}\] shows that
        both these approaches result in roughly equivalent performance
        for the RTO estimator.[¶](#section-4-2.2.5.2.3){.pilcrow}

    :   

    \(c\)

    :   FT observations [MAY]{.bcp14} be taken from non-data
        exchanges.[¶](#section-4-2.2.5.3.1){.pilcrow}

        Some protocols use non-data exchanges for various reasons, e.g.,
        keepalives, heartbeats, and control messages. To the extent that
        the latency of these exchanges mirrors data exchange, they can
        be leveraged to take FT samples within the RTO mechanism. Such
        samples can help protocols keep their RTO accurate during lulls
        in data transmission. However, given that these messages may not
        be subject to the same delays as data transmission, we do not
        take a general view on whether this is useful or
        not.[¶](#section-4-2.2.5.3.2){.pilcrow}

    :   

    \(d\)

    :   An RTO mechanism [MUST NOT]{.bcp14} use ambiguous FT
        samples.[¶](#section-4-2.2.5.4.1){.pilcrow}

        Assume two copies of some packet X are transmitted at times t0
        and t1. Then, at time t2, the sender receives confirmation that
        X in fact arrived. In some cases, it is not clear which copy of
        X triggered the confirmation; hence, the actual FT is either
        t2-t1 or t2-t0, but which is a mystery. Therefore, in this
        situation, an implementation [MUST NOT]{.bcp14} use either
        version of the FT sample and hence not update the RTO (as
        discussed in \[[KP87](#KP87){.xref}\] and
        \[[RFC6298](#RFC6298){.xref}\]).[¶](#section-4-2.2.5.4.2){.pilcrow}

        There are cases where two copies of some data are transmitted in
        a way whereby the sender can tell which is being acknowledged by
        an incoming ACK. For example, TCP\'s timestamp option
        \[[RFC7323](#RFC7323){.xref}\] allows for packets to be uniquely
        identified and hence avoid the ambiguity. In such cases, there
        is no ambiguity and the resulting samples can update the
        RTO.[¶](#section-4-2.2.5.4.3){.pilcrow}

    :   

:   

\(3\)

:   Loss detected by the RTO mechanism [MUST]{.bcp14} be taken as an
    indication of network congestion and the sending rate adapted using
    a standard mechanism (e.g., TCP collapses the congestion window to
    one packet
    \[[RFC5681](#RFC5681){.xref}\]).[¶](#section-4-2.3.1){.pilcrow}

    This ensures network safety.[¶](#section-4-2.3.2){.pilcrow}

    An exception to this rule is if an IETF standardized mechanism
    determines that a particular loss is due to a non-congestion event
    (e.g., packet corruption). In such a case, a congestion control
    action is not required. Additionally, congestion control actions
    taken based on time-based loss detection could be reversed when a
    standard mechanism post facto determines that the cause of the loss
    was not congestion (e.g.,
    \[[RFC5682](#RFC5682){.xref}\]).[¶](#section-4-2.3.3){.pilcrow}

:   

\(4\)

:   Each time the RTO is used to detect a loss, the value of the RTO
    [MUST]{.bcp14} be exponentially backed off such that the next firing
    requires a longer interval. The backoff [SHOULD]{.bcp14} be removed
    after either (a) the subsequent successful transmission of
    non-retransmitted data, or (b) an RTO passes without detecting
    additional losses. The former will generally be quicker. The latter
    covers cases where loss is detected but not
    repaired.[¶](#section-4-2.4.1){.pilcrow}

    A maximum value [MAY]{.bcp14} be placed on the RTO. The maximum RTO
    [MUST NOT]{.bcp14} be less than 60 seconds (as specified in
    \[[RFC6298](#RFC6298){.xref}\]).[¶](#section-4-2.4.2){.pilcrow}

    This ensures network safety.[¶](#section-4-2.4.3){.pilcrow}

    As with guideline (3), an exception to this rule exists if an IETF
    standardized mechanism determines that a particular loss is not due
    to congestion.[¶](#section-4-2.4.4){.pilcrow}

:   
:::
:::

::: {#sect-5}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Discussion](#name-discussion){.section-name .selfRef} {#name-discussion}

We note that research has shown the tension between the responsiveness
and correctness of time-based loss detection seems to be a fundamental
tradeoff in the context of TCP \[[AP99](#AP99){.xref}\]. That is, making
the RTO more aggressive (e.g., via changing TCP\'s exponentially
weighted moving average (EWMA) gains, lowering the minimum RTO, etc.)
can reduce the time required to detect actual loss. However, at the same
time, such aggressiveness leads to more cases of mistakenly declaring
packets lost that ultimately arrived at the receiver. Therefore, being
as aggressive as the requirements given in the previous section allow in
any particular situation may not be the best course of action because
detecting loss, even if falsely, carries a requirement to invoke a
congestion response that will ultimately reduce the transmission
rate.[¶](#section-5-1){.pilcrow}

While the tradeoff between responsiveness and correctness seems
fundamental, the tradeoff can be made less relevant if the sender can
detect and recover from mistaken loss detection. Several mechanisms have
been proposed for this purpose, such as Eifel
\[[RFC3522](#RFC3522){.xref}\], Forward RTO-Recovery (F-RTO)
\[[RFC5682](#RFC5682){.xref}\], and Duplicate Selective Acknowledgement
(DSACK) \[[RFC2883](#RFC2883){.xref}\] \[[RFC3708](#RFC3708){.xref}\].
Using such mechanisms may allow a data originator to tip towards being
more responsive without incurring (as much of) the attendant costs of
mistakenly declaring packets to be lost.[¶](#section-5-2){.pilcrow}

Also, note that, in addition to the experiments discussed in
\[[AP99](#AP99){.xref}\], the Linux TCP implementation has been using
various non-standard RTO mechanisms for many years seemingly without
large-scale problems (e.g., using different EWMA gains than specified in
\[[RFC6298](#RFC6298){.xref}\]). Further, a number of TCP
implementations use a steady-state minimum RTO that is less than the 1
second specified in \[[RFC6298](#RFC6298){.xref}\]. While the
implication of these deviations from the standard may be more spurious
retransmits (per \[[AP99](#AP99){.xref}\]), we are aware of no
large-scale network safety issues caused by this change to the minimum
RTO. This informs the guidelines in the last section (e.g., there is no
minimum RTO specified).[¶](#section-5-3){.pilcrow}

Finally, we note that while allowing implementations to be more
aggressive could in fact increase the number of needless
retransmissions, the above requirements fail safely in that they insist
on exponential backoff and a transmission rate reduction. Therefore,
providing implementers more latitude than they have traditionally been
given in IETF specifications of RTO mechanisms does not somehow open the
flood gates to aggressive behavior. Since there is a downside to being
aggressive, the incentives for proper behavior are retained in the
mechanism.[¶](#section-5-4){.pilcrow}
:::
:::

::: {#sect-6}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

This document does not alter the security properties of time-based loss
detection mechanisms. See \[[RFC6298](#RFC6298){.xref}\] for a
discussion of these within the context of
TCP.[¶](#section-6-1){.pilcrow}
:::
:::

::: {#sect-7}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-7-1){.pilcrow}
:::
:::

::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   
:::

::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[AP99\]
:   [Allman, M.]{.refAuthor}[ and V. Paxson]{.refAuthor}, [\"On
    Estimating End-to-End Network Path Properties\"]{.refTitle},
    [Proceedings of the ACM SIGCOMM Technical Symposium]{.refContent},
    September 1999.
:   

\[CCDJ20\]
:   [Cheng, Y.]{.refAuthor}[, Cardwell, N.]{.refAuthor}[,
    Dukkipati, N.]{.refAuthor}[, and P. Jha]{.refAuthor}, [\"The
    RACK-TLP loss detection algorithm for TCP\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-tcpm-rack-13]{.seriesInfo}, 2 November 2020,
    \<<https://tools.ietf.org/html/draft-ietf-tcpm-rack-13>\>.
:   

\[DCCM13\]
:   [Dukkipati, N.]{.refAuthor}[, Cardwell, N.]{.refAuthor}[,
    Cheng, Y.]{.refAuthor}[, and M. Mathis]{.refAuthor}, [\"Tail Loss
    Probe (TLP): An Algorithm for Fast Recovery of Tail
    Losses\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft,
    draft-dukkipati-tcpm-tcp-loss-probe-01]{.seriesInfo}, 25 February
    2013,
    \<<https://tools.ietf.org/html/draft-dukkipati-tcpm-tcp-loss-probe-01>\>.
:   

\[IS20\]
:   [Iyengar, J., Ed.]{.refAuthor}[ and I. Swett, Ed.]{.refAuthor},
    [\"QUIC Loss Detection and Congestion Control\"]{.refTitle}, [Work
    in Progress]{.refContent}, [Internet-Draft,
    draft-ietf-quic-recovery-32]{.seriesInfo}, 20 October 2020,
    \<<https://tools.ietf.org/html/draft-ietf-quic-recovery-32>\>.
:   

\[Jac88\]
:   [Jacobson, V.]{.refAuthor}, [\"Congestion avoidance and
    control\"]{.refTitle}, [ACM SIGCOMM]{.refContent}, [DOI
    10.1145/52325.52356]{.seriesInfo}, August 1988,
    \<<https://doi.org/10.1145/52325.52356>\>.
:   

\[KP87\]
:   [Karn, P.]{.refAuthor}[ and C. Partridge]{.refAuthor}, [\"Improving
    Round-Trip Time Estimates in Reliable Transport
    Protocols\"]{.refTitle}, [SIGCOMM 87]{.refContent}.
:   

\[RFC1034\]
:   [Mockapetris, P.]{.refAuthor}, [\"Domain names - concepts and
    facilities\"]{.refTitle}, [STD 13]{.seriesInfo}, [RFC
    1034]{.seriesInfo}, [DOI 10.17487/RFC1034]{.seriesInfo}, November
    1987, \<<https://www.rfc-editor.org/info/rfc1034>\>.
:   

\[RFC1035\]
:   [Mockapetris, P.]{.refAuthor}, [\"Domain names - implementation and
    specification\"]{.refTitle}, [STD 13]{.seriesInfo}, [RFC
    1035]{.seriesInfo}, [DOI 10.17487/RFC1035]{.seriesInfo}, November
    1987, \<<https://www.rfc-editor.org/info/rfc1035>\>.
:   

\[RFC2018\]
:   [Mathis, M.]{.refAuthor}[, Mahdavi, J.]{.refAuthor}[,
    Floyd, S.]{.refAuthor}[, and A. Romanow]{.refAuthor}, [\"TCP
    Selective Acknowledgment Options\"]{.refTitle}, [RFC
    2018]{.seriesInfo}, [DOI 10.17487/RFC2018]{.seriesInfo}, October
    1996, \<<https://www.rfc-editor.org/info/rfc2018>\>.
:   

\[RFC2140\]
:   [Touch, J.]{.refAuthor}, [\"TCP Control Block
    Interdependence\"]{.refTitle}, [RFC 2140]{.seriesInfo}, [DOI
    10.17487/RFC2140]{.seriesInfo}, April 1997,
    \<<https://www.rfc-editor.org/info/rfc2140>\>.
:   

\[RFC2883\]
:   [Floyd, S.]{.refAuthor}[, Mahdavi, J.]{.refAuthor}[,
    Mathis, M.]{.refAuthor}[, and M. Podolsky]{.refAuthor}, [\"An
    Extension to the Selective Acknowledgement (SACK) Option for
    TCP\"]{.refTitle}, [RFC 2883]{.seriesInfo}, [DOI
    10.17487/RFC2883]{.seriesInfo}, July 2000,
    \<<https://www.rfc-editor.org/info/rfc2883>\>.
:   

\[RFC3124\]
:   [Balakrishnan, H.]{.refAuthor}[ and S. Seshan]{.refAuthor}, [\"The
    Congestion Manager\"]{.refTitle}, [RFC 3124]{.seriesInfo}, [DOI
    10.17487/RFC3124]{.seriesInfo}, June 2001,
    \<<https://www.rfc-editor.org/info/rfc3124>\>.
:   

\[RFC3261\]
:   [Rosenberg, J.]{.refAuthor}[, Schulzrinne, H.]{.refAuthor}[,
    Camarillo, G.]{.refAuthor}[, Johnston, A.]{.refAuthor}[,
    Peterson, J.]{.refAuthor}[, Sparks, R.]{.refAuthor}[,
    Handley, M.]{.refAuthor}[, and E. Schooler]{.refAuthor}, [\"SIP:
    Session Initiation Protocol\"]{.refTitle}, [RFC 3261]{.seriesInfo},
    [DOI 10.17487/RFC3261]{.seriesInfo}, June 2002,
    \<<https://www.rfc-editor.org/info/rfc3261>\>.
:   

\[RFC3522\]
:   [Ludwig, R.]{.refAuthor}[ and M. Meyer]{.refAuthor}, [\"The Eifel
    Detection Algorithm for TCP\"]{.refTitle}, [RFC 3522]{.seriesInfo},
    [DOI 10.17487/RFC3522]{.seriesInfo}, April 2003,
    \<<https://www.rfc-editor.org/info/rfc3522>\>.
:   

\[RFC3708\]
:   [Blanton, E.]{.refAuthor}[ and M. Allman]{.refAuthor}, [\"Using TCP
    Duplicate Selective Acknowledgement (DSACKs) and Stream Control
    Transmission Protocol (SCTP) Duplicate Transmission Sequence Numbers
    (TSNs) to Detect Spurious Retransmissions\"]{.refTitle}, [RFC
    3708]{.seriesInfo}, [DOI 10.17487/RFC3708]{.seriesInfo}, February
    2004, \<<https://www.rfc-editor.org/info/rfc3708>\>.
:   

\[RFC4960\]
:   [Stewart, R., Ed.]{.refAuthor}, [\"Stream Control Transmission
    Protocol\"]{.refTitle}, [RFC 4960]{.seriesInfo}, [DOI
    10.17487/RFC4960]{.seriesInfo}, September 2007,
    \<<https://www.rfc-editor.org/info/rfc4960>\>.
:   

\[RFC5681\]
:   [Allman, M.]{.refAuthor}[, Paxson, V.]{.refAuthor}[, and E.
    Blanton]{.refAuthor}, [\"TCP Congestion Control\"]{.refTitle}, [RFC
    5681]{.seriesInfo}, [DOI 10.17487/RFC5681]{.seriesInfo}, September
    2009, \<<https://www.rfc-editor.org/info/rfc5681>\>.
:   

\[RFC5682\]
:   [Sarolahti, P.]{.refAuthor}[, Kojo, M.]{.refAuthor}[,
    Yamamoto, K.]{.refAuthor}[, and M. Hata]{.refAuthor}, [\"Forward
    RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious
    Retransmission Timeouts with TCP\"]{.refTitle}, [RFC
    5682]{.seriesInfo}, [DOI 10.17487/RFC5682]{.seriesInfo}, September
    2009, \<<https://www.rfc-editor.org/info/rfc5682>\>.
:   

\[RFC5740\]
:   [Adamson, B.]{.refAuthor}[, Bormann, C.]{.refAuthor}[,
    Handley, M.]{.refAuthor}[, and J. Macker]{.refAuthor},
    [\"NACK-Oriented Reliable Multicast (NORM) Transport
    Protocol\"]{.refTitle}, [RFC 5740]{.seriesInfo}, [DOI
    10.17487/RFC5740]{.seriesInfo}, November 2009,
    \<<https://www.rfc-editor.org/info/rfc5740>\>.
:   

\[RFC6182\]
:   [Ford, A.]{.refAuthor}[, Raiciu, C.]{.refAuthor}[,
    Handley, M.]{.refAuthor}[, Barre, S.]{.refAuthor}[, and J.
    Iyengar]{.refAuthor}, [\"Architectural Guidelines for Multipath TCP
    Development\"]{.refTitle}, [RFC 6182]{.seriesInfo}, [DOI
    10.17487/RFC6182]{.seriesInfo}, March 2011,
    \<<https://www.rfc-editor.org/info/rfc6182>\>.
:   

\[RFC6298\]
:   [Paxson, V.]{.refAuthor}[, Allman, M.]{.refAuthor}[,
    Chu, J.]{.refAuthor}[, and M. Sargent]{.refAuthor}, [\"Computing
    TCP\'s Retransmission Timer\"]{.refTitle}, [RFC 6298]{.seriesInfo},
    [DOI 10.17487/RFC6298]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6298>\>.
:   

\[RFC6675\]
:   [Blanton, E.]{.refAuthor}[, Allman, M.]{.refAuthor}[,
    Wang, L.]{.refAuthor}[, Jarvinen, I.]{.refAuthor}[,
    Kojo, M.]{.refAuthor}[, and Y. Nishida]{.refAuthor}, [\"A
    Conservative Loss Recovery Algorithm Based on Selective
    Acknowledgment (SACK) for TCP\"]{.refTitle}, [RFC
    6675]{.seriesInfo}, [DOI 10.17487/RFC6675]{.seriesInfo}, August
    2012, \<<https://www.rfc-editor.org/info/rfc6675>\>.
:   

\[RFC7323\]
:   [Borman, D.]{.refAuthor}[, Braden, B.]{.refAuthor}[,
    Jacobson, V.]{.refAuthor}[, and R. Scheffenegger, Ed.]{.refAuthor},
    [\"TCP Extensions for High Performance\"]{.refTitle}, [RFC
    7323]{.seriesInfo}, [DOI 10.17487/RFC7323]{.seriesInfo}, September
    2014, \<<https://www.rfc-editor.org/info/rfc7323>\>.
:   
:::
:::

::: {#acknowledgments}
::: {#section-appendix.a .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

This document benefits from years of discussions with [Ethan
Blanton]{.contact-name}, [Sally Floyd]{.contact-name}, [Jana
Iyengar]{.contact-name}, [Shawn Ostermann]{.contact-name}, [Vern
Paxson]{.contact-name}, and the members of the TCPM and TCPIMPL Working
Groups. [Ran Atkinson]{.contact-name}, [Yuchung Cheng]{.contact-name},
[David Black]{.contact-name}, [Stewart Bryant]{.contact-name}, [Martin
Duke]{.contact-name}, [Wesley Eddy]{.contact-name}, [Gorry
Fairhurst]{.contact-name}, [Rahul Arvind Jadhav]{.contact-name},
[Benjamin Kaduk]{.contact-name}, [Mirja Kühlewind]{.contact-name},
[Nicolas Kuhn]{.contact-name}, [Jonathan Looney]{.contact-name}, and
[Michael Scharf]{.contact-name} provided useful comments on previous
draft versions of this document.[¶](#section-appendix.a-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.b .section}
## [Author\'s Address](#name-authors-address){.section-name .selfRef} {#name-authors-address}

::: {.left dir="auto"}
[Mark Allman]{.fn .nameRole}
:::

::: {.left dir="auto"}
[International Computer Science Institute]{.org}
:::

::: {.left dir="auto"}
[2150 Shattuck Ave., Suite 1100]{.street-address}
:::

::: {.left dir="auto"}
[Berkeley]{.locality}, [CA]{.region} [94704]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <mallman@icir.org>
:::

::: url
URI: <https://www.icir.org/mallman>
:::
:::
:::
