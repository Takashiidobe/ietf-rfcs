  RFC 9106           Argon2          September 2021
  ------------------ --------------- ----------------
  Biryukov, et al.   Informational   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Research Task Force (IRTF)

RFC:
:   [9106](https://www.rfc-editor.org/rfc/rfc9106){.eref}

Category:
:   Informational

Published:
:   September 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    A. Biryukov
    :::

    ::: org
    University of Luxembourg
    :::
    :::

    ::: author
    ::: author-name
    D. Dinu
    :::

    ::: org
    University of Luxembourg
    :::
    :::

    ::: author
    ::: author-name
    D. Khovratovich
    :::

    ::: org
    ABDK Consulting
    :::
    :::

    ::: author
    ::: author-name
    S. Josefsson
    :::

    ::: org
    SJD AB
    :::
    :::
:::

# RFC 9106 {#rfcnum}

# Argon2 Memory-Hard Function for Password Hashing and Proof-of-Work Applications {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes the Argon2 memory-hard function for password
hashing and proof-of-work applications. We provide an
implementer-oriented description with test vectors. The purpose is to
simplify adoption of Argon2 for Internet protocols. This document is a
product of the Crypto Forum Research Group (CFRG) in the
IRTF.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for informational
purposes.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Research Task Force (IRTF).
The IRTF publishes the results of Internet-related research and
development activities. These results might not be suitable for
deployment. This RFC represents the consensus of the Crypto Forum
Research Group of the Internet Research Task Force (IRTF). Documents
approved for publication by the IRSG are not candidates for any level of
Internet Standard; see Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9106>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Requirements
        Language](#name-requirements-language){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Notation and
    Conventions](#name-notation-and-conventions){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Argon2
    Algorithm](#name-argon2-algorithm){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Argon2 Inputs and
        Outputs](#name-argon2-inputs-and-outputs){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Argon2
        Operation](#name-argon2-operation){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Variable-Length Hash Function
        H\'](#name-variable-length-hash-functi){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [Indexing](#name-indexing){.xref}

        -   ::: {#section-toc.1-1.3.2.4.2.1}
            [3.4.1](#section-3.4.1){.xref}.  [Computing the 32-Bit
            Values J_1 and
            J_2](#name-computing-the-32-bit-values){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.4.2.2}
            [3.4.2](#section-3.4.2){.xref}.  [Mapping J_1 and J_2 to
            Reference Block Index
            \[l\]\[z\]](#name-mapping-j_1-and-j_2-to-refe){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.5}
        [3.5](#section-3.5){.xref}.  [Compression Function
        G](#name-compression-function-g){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.6}
        [3.6](#section-3.6){.xref}.  [Permutation
        P](#name-permutation-p){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Parameter
    Choice](#name-parameter-choice){.xref}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Test Vectors](#name-test-vectors){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Argon2d Test
        Vectors](#name-argon2d-test-vectors){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Argon2i Test
        Vectors](#name-argon2i-test-vectors){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Argon2id Test
        Vectors](#name-argon2id-test-vectors){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Security as a Hash Function and
        KDF](#name-security-as-a-hash-function){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Security against Time-Space
        Trade-off Attacks](#name-security-against-time-space){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Security for Time-Bounded
        Defenders](#name-security-for-time-bounded-d){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [Recommendations](#name-recommendations){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [](#appendix-A){.xref}[Acknowledgements](#name-acknowledgements){.xref}
    :::

-   ::: {#section-toc.1-1.10}
    [](#appendix-B){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#intro}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

This document describes the [Argon2](#ARGON2ESP){.xref}
\[[ARGON2ESP](#ARGON2ESP){.xref}\] memory-hard function for password
hashing and proof-of-work applications. We provide an
implementer-oriented description with test vectors. The purpose is to
simplify adoption of Argon2 for Internet protocols. This document
corresponds to version 1.3 of the Argon2 hash
function.[¶](#section-1-1){.pilcrow}

Argon2 is a [memory-hard function](#HARD){.xref}
\[[HARD](#HARD){.xref}\]. It is a streamlined design. It aims at the
highest memory-filling rate and effective use of multiple computing
units, while still providing defense against trade-off attacks. Argon2
is optimized for the x86 architecture and exploits the cache and memory
organization of the recent Intel and AMD processors. Argon2 has one
primary variant, Argon2id, and two supplementary variants, Argon2d and
Argon2i. Argon2d uses data-dependent memory access, which makes it
suitable for cryptocurrencies and proof-of-work applications with no
threats from side-channel timing attacks. Argon2i uses data-independent
memory access, which is preferred for password hashing and
password-based key derivation. Argon2id works as Argon2i for the first
half of the first pass over the memory and as Argon2d for the rest, thus
providing both side-channel attack protection and brute-force cost
savings due to time-memory trade-offs. Argon2i makes more passes over
the memory to protect from [trade-off attacks](#AB15){.xref}
\[[AB15](#AB15){.xref}\].[¶](#section-1-2){.pilcrow}

Argon2id [MUST]{.bcp14} be supported by any implementation of this
document, whereas Argon2d and Argon2i [MAY]{.bcp14} be
supported.[¶](#section-1-3){.pilcrow}

Argon2 is also a mode of operation over a fixed-input-length compression
function G and a variable-input-length hash function H. Even though
Argon2 can be potentially used with an arbitrary function H, as long as
it provides outputs up to 64 bytes, the [BLAKE2b
function](#RFC7693){.xref} \[[BLAKE2](#RFC7693){.xref}\] is used in this
document.[¶](#section-1-4){.pilcrow}

For further background and discussion, see the [Argon2
paper](#ARGON2){.xref}
\[[ARGON2](#ARGON2){.xref}\].[¶](#section-1-5){.pilcrow}

This document represents the consensus of the Crypto Forum Research
Group (CFRG).[¶](#section-1-6){.pilcrow}

::: {#reqs}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Requirements Language](#name-requirements-language){.section-name .selfRef} {#name-requirements-language}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-1){.pilcrow}
:::
:::
:::
:::

::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Notation and Conventions](#name-notation-and-conventions){.section-name .selfRef} {#name-notation-and-conventions}

[]{.break}

x\^y
:   integer x multiplied by itself integer y
    times[¶](#section-2-1.2){.pilcrow}
:   

a\*b
:   multiplication of integer a and integer
    b[¶](#section-2-1.4){.pilcrow}
:   

c-d
:   subtraction of integer d from integer c[¶](#section-2-1.6){.pilcrow}
:   

E_f
:   variable E with subscript index f[¶](#section-2-1.8){.pilcrow}
:   

g / h
:   integer g divided by integer h. The result is a rational
    number.[¶](#section-2-1.10){.pilcrow}
:   

I(j)
:   function I evaluated at j[¶](#section-2-1.12){.pilcrow}
:   

K \|\| L
:   string K concatenated with string L[¶](#section-2-1.14){.pilcrow}
:   

a XOR b
:   bitwise exclusive-or between bitstrings a and
    b[¶](#section-2-1.16){.pilcrow}
:   

a mod b
:   remainder of integer a modulo integer b, always in range \[0,
    b-1\][¶](#section-2-1.18){.pilcrow}
:   

a >\>\> n
:   rotation of 64-bit string a to the right by n
    bits[¶](#section-2-1.20){.pilcrow}
:   

trunc(a)
:   the 64-bit value, truncated to the 32 least significant
    bits[¶](#section-2-1.22){.pilcrow}
:   

floor(a)
:   the largest integer not bigger than a[¶](#section-2-1.24){.pilcrow}
:   

ceil(a)
:   the smallest integer not smaller than
    a[¶](#section-2-1.26){.pilcrow}
:   

extract(a, i)
:   the i-th set of 32 bits from bitstring a, starting from
    0-th[¶](#section-2-1.28){.pilcrow}
:   

\|A\|
:   the number of elements in set A[¶](#section-2-1.30){.pilcrow}
:   

LE32(a)
:   32-bit integer a converted to a byte string in little endian (for
    example, 123456 (decimal) is 40 E2 01
    00)[¶](#section-2-1.32){.pilcrow}
:   

LE64(a)
:   64-bit integer a converted to a byte string in little endian (for
    example, 123456 (decimal) is 40 E2 01 00 00 00 00
    00)[¶](#section-2-1.34){.pilcrow}
:   

int32(s)
:   32-bit string s is converted to a non-negative integer in little
    endian[¶](#section-2-1.36){.pilcrow}
:   

int64(s)
:   64-bit string s is converted to a non-negative integer in little
    endian[¶](#section-2-1.38){.pilcrow}
:   

length(P)
:   the byte length of string P expressed as 32-bit
    integer[¶](#section-2-1.40){.pilcrow}
:   

ZERO(P)
:   the P-byte zero string[¶](#section-2-1.42){.pilcrow}
:   
:::

::: {#argon2-algorithm}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Argon2 Algorithm](#name-argon2-algorithm){.section-name .selfRef} {#name-argon2-algorithm}

::: {#argon2-inouts}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Argon2 Inputs and Outputs](#name-argon2-inputs-and-outputs){.section-name .selfRef} {#name-argon2-inputs-and-outputs}

Argon2 has the following input parameters:[¶](#section-3.1-1){.pilcrow}

-   [Message string P, which is a password for password hashing
    applications. It [MUST]{.bcp14} have a length not greater than
    2\^(32)-1 bytes.[¶](#section-3.1-2.1){.pilcrow}]{#section-3.1-2.1}
-   [Nonce S, which is a salt for password hashing applications. It
    [MUST]{.bcp14} have a length not greater than 2\^(32)-1 bytes. 16
    bytes is [RECOMMENDED]{.bcp14} for password hashing. The salt
    [SHOULD]{.bcp14} be unique for each
    password.[¶](#section-3.1-2.2){.pilcrow}]{#section-3.1-2.2}
-   [Degree of parallelism p determines how many independent (but
    synchronizing) computational chains (lanes) can be run. It
    [MUST]{.bcp14} be an integer value from 1 to
    2\^(24)-1.[¶](#section-3.1-2.3){.pilcrow}]{#section-3.1-2.3}
-   [Tag length T [MUST]{.bcp14} be an integer number of bytes from 4 to
    2\^(32)-1.[¶](#section-3.1-2.4){.pilcrow}]{#section-3.1-2.4}
-   [Memory size m [MUST]{.bcp14} be an integer number of kibibytes from
    8\*p to 2\^(32)-1. The actual number of blocks is m\', which is m
    rounded down to the nearest multiple of
    4\*p.[¶](#section-3.1-2.5){.pilcrow}]{#section-3.1-2.5}
-   [Number of passes t (used to tune the running time independently of
    the memory size) [MUST]{.bcp14} be an integer number from 1 to
    2\^(32)-1.[¶](#section-3.1-2.6){.pilcrow}]{#section-3.1-2.6}
-   [Version number v [MUST]{.bcp14} be one byte
    0x13.[¶](#section-3.1-2.7){.pilcrow}]{#section-3.1-2.7}
-   [Secret value K is [OPTIONAL]{.bcp14}. If used, it [MUST]{.bcp14}
    have a length not greater than 2\^(32)-1
    bytes.[¶](#section-3.1-2.8){.pilcrow}]{#section-3.1-2.8}
-   [Associated data X is [OPTIONAL]{.bcp14}. If used, it [MUST]{.bcp14}
    have a length not greater than 2\^(32)-1
    bytes.[¶](#section-3.1-2.9){.pilcrow}]{#section-3.1-2.9}
-   [Type y [MUST]{.bcp14} be 0 for Argon2d, 1 for Argon2i, or 2 for
    Argon2id.[¶](#section-3.1-2.10){.pilcrow}]{#section-3.1-2.10}

The Argon2 output, or \"tag\", is a string T bytes
long.[¶](#section-3.1-3){.pilcrow}
:::
:::

::: {#argon2-operation}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Argon2 Operation](#name-argon2-operation){.section-name .selfRef} {#name-argon2-operation}

Argon2 uses an internal compression function G with two 1024-byte
inputs, a 1024-byte output, and an internal hash function H\^x(), with x
being its output length in bytes. Here, H\^x() applied to string A is
the BLAKE2b (\[[BLAKE2](#RFC7693){.xref}\], [Section
3.3](https://www.rfc-editor.org/rfc/rfc7693#section-3.3){.relref})
function, which takes (d,ll,kk=0,nn=x) as parameters, where d is A
padded to a multiple of 128 bytes and ll is the length of d in bytes.
The compression function G is based on its internal permutation. A
variable-length hash function H\' built upon H is also used. G is
described in [Section 3.5](#G-function){.xref}, and H\' is described in
[Section 3.3](#H-function){.xref}.[¶](#section-3.2-1){.pilcrow}

The Argon2 operation is as follows.[¶](#section-3.2-2){.pilcrow}

1.  ::: {#section-3.2-3.1}
    Establish H_0 as the 64-byte value as shown below. If K, X, or S has
    zero length, it is just absent, but its length field
    remains.[¶](#section-3.2-3.1.1){.pilcrow}

    []{#name-h_0-generation}
    ::: {#section-3.2-3.1.2.1 .artwork .art-text .alignLeft}
        H_0 = H^(64)(LE32(p) || LE32(T) || LE32(m) || LE32(t) ||
                LE32(v) || LE32(y) || LE32(length(P)) || P ||
                LE32(length(S)) || S ||  LE32(length(K)) || K ||
                LE32(length(X)) || X)
    :::

    [Figure 1](#figure-1){.selfRef}: [H_0
    Generation](#name-h_0-generation){.selfRef}
    :::

2.  ::: {#section-3.2-3.2}
    Allocate the memory as m\' 1024-byte blocks, where m\' is derived
    as:[¶](#section-3.2-3.2.1){.pilcrow}

    []{#name-memory-allocation}
    ::: {#section-3.2-3.2.2.1 .artwork .art-text .alignLeft}
        m' = 4 * p * floor (m / 4p)
    :::

    [Figure 2](#figure-2){.selfRef}: [Memory
    Allocation](#name-memory-allocation){.selfRef}
    For p lanes, the memory is organized in a matrix B\[i\]\[j\] of
    blocks with p rows (lanes) and q = m\' / p
    columns.[¶](#section-3.2-3.2.3){.pilcrow}
    :::

3.  ::: {#section-3.2-3.3}
    Compute B\[i\]\[0\] for all i ranging from (and including) 0 to (not
    including) p.[¶](#section-3.2-3.3.1){.pilcrow}

    []{#name-lane-starting-blocks}
    ::: {#section-3.2-3.3.2.1 .artwork .art-text .alignLeft}
        B[i][0] = H'^(1024)(H_0 || LE32(0) || LE32(i))
    :::

    [Figure 3](#figure-3){.selfRef}: [Lane Starting
    Blocks](#name-lane-starting-blocks){.selfRef}
    :::

4.  ::: {#section-3.2-3.4}
    Compute B\[i\]\[1\] for all i ranging from (and including) 0 to (not
    including) p.[¶](#section-3.2-3.4.1){.pilcrow}

    []{#name-second-lane-blocks}
    ::: {#section-3.2-3.4.2.1 .artwork .art-text .alignLeft}
        B[i][1] = H'^(1024)(H_0 || LE32(1) || LE32(i))
    :::

    [Figure 4](#figure-4){.selfRef}: [Second Lane
    Blocks](#name-second-lane-blocks){.selfRef}
    :::

5.  ::: {#section-3.2-3.5}
    ::: {#step5}
    Compute B\[i\]\[j\] for all i ranging from (and including) 0 to (not
    including) p and for all j ranging from (and including) 2 to (not
    including) q. The computation [MUST]{.bcp14} proceed slicewise
    ([Section 3.4](#indexing){.xref}): first, blocks from slice 0 are
    computed for all lanes (in an arbitrary order of lanes), then blocks
    from slice 1 are computed, etc. The block indices l and z are
    determined for each i, j differently for Argon2d, Argon2i, and
    Argon2id.[¶](#section-3.2-3.5.1){.pilcrow}
    :::

    []{#name-further-block-generation}
    ::: {#section-3.2-3.5.2.1 .artwork .art-text .alignLeft}
        B[i][j] = G(B[i][j-1], B[l][z])
    :::

    [Figure 5](#figure-5){.selfRef}: [Further Block
    Generation](#name-further-block-generation){.selfRef}
    :::

6.  ::: {#section-3.2-3.6}
    If the number of passes t is larger than 1, we repeat [step
    5](#step5){.xref}. We compute B\[i\]\[0\] and B\[i\]\[j\] for all i
    raging from (and including) 0 to (not including) p and for all j
    ranging from (and including) 1 to (not including) q. However, blocks
    are computed differently as the old value is XORed with the new
    one:[¶](#section-3.2-3.6.1){.pilcrow}

    []{#name-further-passes}
    ::: {#section-3.2-3.6.2.1 .artwork .art-text .alignLeft}
        B[i][0] = G(B[i][q-1], B[l][z]) XOR B[i][0];
        B[i][j] = G(B[i][j-1], B[l][z]) XOR B[i][j].
    :::

    [Figure 6](#figure-6){.selfRef}: [Further
    Passes](#name-further-passes){.selfRef}
    :::

7.  ::: {#section-3.2-3.7}
    After t steps have been iterated, the final block C is computed as
    the XOR of the last column:[¶](#section-3.2-3.7.1){.pilcrow}

    []{#name-final-block}
    ::: {#section-3.2-3.7.2.1 .artwork .art-text .alignLeft}
        C = B[0][q-1] XOR B[1][q-1] XOR ... XOR B[p-1][q-1]
    :::

    [Figure 7](#figure-7){.selfRef}: [Final
    Block](#name-final-block){.selfRef}
    :::

8.  [The output tag is computed as
    H\'\^T(C).[¶](#section-3.2-3.8){.pilcrow}]{#section-3.2-3.8}
:::
:::

::: {#H-function}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Variable-Length Hash Function H\'](#name-variable-length-hash-functi){.section-name .selfRef} {#name-variable-length-hash-functi}

Let V_i be a 64-byte block and W_i be its first 32 bytes. Then we define
function H\' as follows:[¶](#section-3.3-1){.pilcrow}

[]{#name-function-h-for-tag-and-init}

::: {#section-3.3-2.1}
``` {.sourcecode .lang-pseudocode}
        if T <= 64
            H'^T(A) = H^T(LE32(T)||A)
        else
            r = ceil(T/32)-2
            V_1 = H^(64)(LE32(T)||A)
            V_2 = H^(64)(V_1)
            ...
            V_r = H^(64)(V_{r-1})
            V_{r+1} = H^(T-32*r)(V_{r})
            H'^T(X) = W_1 || W_2 || ... || W_r || V_{r+1}
```
:::

[Figure 8](#figure-8){.selfRef}: [Function H\' for Tag and Initial Block
Computations](#name-function-h-for-tag-and-init){.selfRef}
:::
:::

::: {#indexing}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [Indexing](#name-indexing){.section-name .selfRef} {#name-indexing}

To enable parallel block computation, we further partition the memory
matrix into SL = 4 vertical slices. The intersection of a slice and a
lane is called a segment, which has a length of q/SL. Segments of the
same slice can be computed in parallel and do not reference blocks from
each other. All other blocks can be
referenced.[¶](#section-3.4-1){.pilcrow}

[]{#name-single-pass-argon2-with-p-l}

::: {#section-3.4-2.1 .artwork .art-text .alignLeft}
        slice 0    slice 1    slice 2    slice 3
        ___/\___   ___/\___   ___/\___   ___/\___
       /        \ /        \ /        \ /        \
      +----------+----------+----------+----------+
      |          |          |          |          | > lane 0
      +----------+----------+----------+----------+
      |          |          |          |          | > lane 1
      +----------+----------+----------+----------+
      |          |          |          |          | > lane 2
      +----------+----------+----------+----------+
      |         ...        ...        ...         | ...
      +----------+----------+----------+----------+
      |          |          |          |          | > lane p - 1
      +----------+----------+----------+----------+
:::

[Figure 9](#figure-9){.selfRef}: [Single-Pass Argon2 with p Lanes and 4
Slices](#name-single-pass-argon2-with-p-l){.selfRef}

::: {#section-3.4.1 .section}
#### [3.4.1.](#section-3.4.1){.section-number .selfRef} [Computing the 32-Bit Values J_1 and J_2](#name-computing-the-32-bit-values){.section-name .selfRef} {#name-computing-the-32-bit-values}

::: {#section-3.4.1.1 .section}
##### [3.4.1.1.](#section-3.4.1.1){.section-number .selfRef} [Argon2d](#name-argon2d){.section-name .selfRef} {#name-argon2d}

J_1 is given by the first 32 bits of block B\[i\]\[j-1\], while J_2 is
given by the next 32 bits of block
B\[i\]\[j-1\]:[¶](#section-3.4.1.1-1){.pilcrow}

[]{#name-deriving-j1j2-in-argon2d}

::: {#section-3.4.1.1-2.1 .artwork .art-text .alignLeft}
    J_1 = int32(extract(B[i][j-1], 0))
    J_2 = int32(extract(B[i][j-1], 1))
:::

[Figure 10](#figure-10){.selfRef}: [Deriving J1,J2 in
Argon2d](#name-deriving-j1j2-in-argon2d){.selfRef}
:::

::: {#section-3.4.1.2 .section}
##### [3.4.1.2.](#section-3.4.1.2){.section-number .selfRef} [Argon2i](#name-argon2i){.section-name .selfRef} {#name-argon2i}

For each segment, we do the following. First, we compute the value Z
as:[¶](#section-3.4.1.2-1){.pilcrow}

[]{#name-input-to-compute-j1j2-in-ar}

::: {#section-3.4.1.2-2.1 .artwork .art-text .alignLeft}
    Z= ( LE64(r) || LE64(l) || LE64(sl) || LE64(m') ||
         LE64(t) || LE64(y) )
:::

[Figure 11](#figure-11){.selfRef}: [Input to Compute J1,J2 in
Argon2i](#name-input-to-compute-j1j2-in-ar){.selfRef}

where[¶](#section-3.4.1.2-3){.pilcrow}

[]{.break}

r:
:   the pass number[¶](#section-3.4.1.2-4.2){.pilcrow}
:   

l:
:   the lane number[¶](#section-3.4.1.2-4.4){.pilcrow}
:   

sl:
:   the slice number[¶](#section-3.4.1.2-4.6){.pilcrow}
:   

m\':
:   the total number of memory blocks[¶](#section-3.4.1.2-4.8){.pilcrow}
:   

t:
:   the total number of passes[¶](#section-3.4.1.2-4.10){.pilcrow}
:   

y:
:   the Argon2 type (0 for Argon2d, 1 for Argon2i, 2 for
    Argon2id)[¶](#section-3.4.1.2-4.12){.pilcrow}
:   

Then we compute:[¶](#section-3.4.1.2-5){.pilcrow}

::: {#section-3.4.1.2-6 .artwork .art-text .alignLeft}
    q/(128*SL) 1024-byte values
    G(ZERO(1024),G(ZERO(1024),
    Z || LE64(1) || ZERO(968) )),
    G(ZERO(1024),G(ZERO(1024),
    Z || LE64(2) || ZERO(968) )),... ,
    G(ZERO(1024),G(ZERO(1024),
    Z || LE64(q/(128*SL)) || ZERO(968) )),

[¶](#section-3.4.1.2-6){.pilcrow}
:::

which are partitioned into q/(SL) 8-byte values X, which are viewed as
X1\|\|X2 and converted to J_1=int32(X1) and
J_2=int32(X2).[¶](#section-3.4.1.2-7){.pilcrow}

The values r, l, sl, m\', t, y, and i are represented as 8 bytes in
little endian.[¶](#section-3.4.1.2-8){.pilcrow}
:::

::: {#section-3.4.1.3 .section}
##### [3.4.1.3.](#section-3.4.1.3){.section-number .selfRef} [Argon2id](#name-argon2id){.section-name .selfRef} {#name-argon2id}

If the pass number is 0 and the slice number is 0 or 1, then compute J_1
and J_2 as for Argon2i, else compute J_1 and J_2 as for
Argon2d.[¶](#section-3.4.1.3-1){.pilcrow}
:::
:::

::: {#section-3.4.2 .section}
#### [3.4.2.](#section-3.4.2){.section-number .selfRef} [Mapping J_1 and J_2 to Reference Block Index \[l\]\[z\]](#name-mapping-j_1-and-j_2-to-refe){.section-name .selfRef} {#name-mapping-j_1-and-j_2-to-refe}

The value of l = J_2 mod p gives the index of the lane from which the
block will be taken. For the first pass (r=0) and the first slice
(sl=0), the block is taken from the current
lane.[¶](#section-3.4.2-1){.pilcrow}

The set W contains the indices that are referenced according to the
following rules:[¶](#section-3.4.2-2){.pilcrow}

1.  [If l is the current lane, then W includes the indices of all blocks
    in the last SL - 1 = 3 segments computed and finished, as well as
    the blocks computed in the current segment in the current pass
    excluding
    B\[i\]\[j-1\].[¶](#section-3.4.2-3.1){.pilcrow}]{#section-3.4.2-3.1}
2.  [If l is not the current lane, then W includes the indices of all
    blocks in the last SL - 1 = 3 segments computed and finished in
    lane l. If B\[i\]\[j\] is the first block of a segment, then the
    very last index from W is
    excluded.[¶](#section-3.4.2-3.2){.pilcrow}]{#section-3.4.2-3.2}

Then take a block from W with a nonuniform distribution over \[0, \|W\|)
using the following mapping:[¶](#section-3.4.2-4){.pilcrow}

[]{#name-computing-j1}

::: {#section-3.4.2-5.1 .artwork .art-text .alignLeft}
    J_1 -> |W|(1 - J_1^2 / 2^(64))
:::

[Figure 12](#figure-12){.selfRef}: [Computing
J1](#name-computing-j1){.selfRef}

To avoid floating point computation, the following approximation is
used:[¶](#section-3.4.2-6){.pilcrow}

[]{#name-computing-j1-part-2}

::: {#section-3.4.2-7.1 .artwork .art-text .alignLeft}
    x = J_1^2 / 2^(32)
    y = (|W| * x) / 2^(32)
    zz = |W| - 1 - y
:::

[Figure 13](#figure-13){.selfRef}: [Computing J1, Part
2](#name-computing-j1-part-2){.selfRef}

Then take the zz-th index from W; it will be the z value for the
reference block index \[l\]\[z\].[¶](#section-3.4.2-8){.pilcrow}
:::
:::
:::

::: {#G-function}
::: {#section-3.5 .section}
### [3.5.](#section-3.5){.section-number .selfRef} [Compression Function G](#name-compression-function-g){.section-name .selfRef} {#name-compression-function-g}

The compression function G is built upon the BLAKE2b-based
transformation P. P operates on the 128-byte input, which can be viewed
as eight 16-byte registers:[¶](#section-3.5-1){.pilcrow}

[]{#name-blake-round-function-p}

::: {#section-3.5-2.1 .artwork .art-text .alignLeft}
    P(A_0, A_1, ... ,A_7) = (B_0, B_1, ... ,B_7)
:::

[Figure 14](#figure-14){.selfRef}: [Blake Round Function
P](#name-blake-round-function-p){.selfRef}

The compression function G(X, Y) operates on two 1024-byte blocks X and
Y. It first computes R = X XOR Y. Then R is viewed as an 8x8 matrix of
16-byte registers R_0, R_1, \... , R_63. Then P is first applied to each
row, and then to each column to get Z:[¶](#section-3.5-3){.pilcrow}

[]{#name-core-of-compression-functio}

::: {#section-3.5-4.1 .artwork .art-text .alignLeft}
    ( Q_0,  Q_1,  Q_2, ... ,  Q_7) <- P( R_0,  R_1,  R_2, ... ,  R_7)
    ( Q_8,  Q_9, Q_10, ... , Q_15) <- P( R_8,  R_9, R_10, ... , R_15)
                                  ...
    (Q_56, Q_57, Q_58, ... , Q_63) <- P(R_56, R_57, R_58, ... , R_63)
    ( Z_0,  Z_8, Z_16, ... , Z_56) <- P( Q_0,  Q_8, Q_16, ... , Q_56)
    ( Z_1,  Z_9, Z_17, ... , Z_57) <- P( Q_1,  Q_9, Q_17, ... , Q_57)
                                  ...
    ( Z_7, Z_15, Z 23, ... , Z_63) <- P( Q_7, Q_15, Q_23, ... , Q_63)
:::

[Figure 15](#figure-15){.selfRef}: [Core of Compression Function
G](#name-core-of-compression-functio){.selfRef}

Finally, G outputs Z XOR R:[¶](#section-3.5-5){.pilcrow}

::: {#section-3.5-6 .artwork .art-text .alignLeft}
    G: (X, Y) -> R -> Q -> Z -> Z XOR R

[¶](#section-3.5-6){.pilcrow}
:::

[]{#name-argon2-compression-function}

::: {#section-3.5-7.1 .artwork .art-text .alignLeft}
                             +---+       +---+
                             | X |       | Y |
                             +---+       +---+
                               |           |
                               ---->XOR<----
                             --------|
                             |      \ /
                             |     +---+
                             |     | R |
                             |     +---+
                             |       |
                             |      \ /
                             |   P rowwise
                             |       |
                             |      \ /
                             |     +---+
                             |     | Q |
                             |     +---+
                             |       |
                             |      \ /
                             |  P columnwise
                             |       |
                             |      \ /
                             |     +---+
                             |     | Z |
                             |     +---+
                             |       |
                             |      \ /
                             ------>XOR
                                     |
                                    \ /
:::

[Figure 16](#figure-16){.selfRef}: [Argon2 Compression Function
G](#name-argon2-compression-function){.selfRef}
:::
:::

::: {#P-permutation}
::: {#section-3.6 .section}
### [3.6.](#section-3.6){.section-number .selfRef} [Permutation P](#name-permutation-p){.section-name .selfRef} {#name-permutation-p}

Permutation P is based on the round function of BLAKE2b. The eight
16-byte inputs S_0, S_1, \... , S_7 are viewed as a 4x4 matrix of 64-bit
words, where S_i = (v\_{2\*i+1} \|\|
v\_{2\*i}):[¶](#section-3.6-1){.pilcrow}

[]{#name-matrix-element-labeling}

::: {#section-3.6-2.1 .artwork .art-text .alignLeft}
             v_0  v_1  v_2  v_3
             v_4  v_5  v_6  v_7
             v_8  v_9 v_10 v_11
            v_12 v_13 v_14 v_15
:::

[Figure 17](#figure-17){.selfRef}: [Matrix Element
Labeling](#name-matrix-element-labeling){.selfRef}

It works as follows:[¶](#section-3.6-3){.pilcrow}

[]{#name-feeding-matrix-elements-to-}

::: {#section-3.6-4.1 .artwork .art-text .alignLeft}
            GB(v_0, v_4,  v_8, v_12)
            GB(v_1, v_5,  v_9, v_13)
            GB(v_2, v_6, v_10, v_14)
            GB(v_3, v_7, v_11, v_15)

            GB(v_0, v_5, v_10, v_15)
            GB(v_1, v_6, v_11, v_12)
            GB(v_2, v_7,  v_8, v_13)
            GB(v_3, v_4,  v_9, v_14)
:::

[Figure 18](#figure-18){.selfRef}: [Feeding Matrix Elements to
GB](#name-feeding-matrix-elements-to-){.selfRef}

GB(a, b, c, d) is defined as follows:[¶](#section-3.6-5){.pilcrow}

[]{#name-details-of-gb}

::: {#section-3.6-6.1 .artwork .art-text .alignLeft}
            a = (a + b + 2 * trunc(a) * trunc(b)) mod 2^(64)
            d = (d XOR a) >>> 32
            c = (c + d + 2 * trunc(c) * trunc(d)) mod 2^(64)
            b = (b XOR c) >>> 24

            a = (a + b + 2 * trunc(a) * trunc(b)) mod 2^(64)
            d = (d XOR a) >>> 16
            c = (c + d + 2 * trunc(c) * trunc(d)) mod 2^(64)
            b = (b XOR c) >>> 63
:::

[Figure 19](#figure-19){.selfRef}: [Details of
GB](#name-details-of-gb){.selfRef}

The modular additions in GB are combined with 64-bit multiplications.
Multiplications are the only difference from the original BLAKE2b
design. This choice is done to increase the circuit depth and thus the
running time of ASIC implementations, while having roughly the same
running time on CPUs thanks to parallelism and
pipelining.[¶](#section-3.6-7){.pilcrow}
:::
:::
:::
:::

::: {#parameter-choice}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Parameter Choice](#name-parameter-choice){.section-name .selfRef} {#name-parameter-choice}

Argon2d is optimized for settings where the adversary does not get
regular access to system memory or CPU, i.e., they cannot run
side-channel attacks based on the timing information, nor can they
recover the password much faster using garbage collection. These
settings are more typical for backend servers and cryptocurrency
minings. For practice, we suggest the following
settings:[¶](#section-4-1){.pilcrow}

-   [Cryptocurrency mining, which takes 0.1 seconds on a 2 GHz CPU using
    1 core \-- Argon2d with 2 lanes and 250 MB of
    RAM.[¶](#section-4-2.1){.pilcrow}]{#section-4-2.1}

Argon2id is optimized for more realistic settings, where the adversary
can possibly access the same machine, use its CPU, or mount cold-boot
attacks. We suggest the following settings:[¶](#section-4-3){.pilcrow}

-   [Backend server authentication, which takes 0.5 seconds on a 2 GHz
    CPU using 4 cores \-- Argon2id with 8 lanes and 4 GiB of
    RAM.[¶](#section-4-4.1){.pilcrow}]{#section-4-4.1}
-   [Key derivation for hard-drive encryption, which takes 3 seconds on
    a 2 GHz CPU using 2 cores \-- Argon2id with 4 lanes and 6 GiB of
    RAM.[¶](#section-4-4.2){.pilcrow}]{#section-4-4.2}
-   [Frontend server authentication, which takes 0.5 seconds on a 2 GHz
    CPU using 2 cores \-- Argon2id with 4 lanes and 1 GiB of
    RAM.[¶](#section-4-4.3){.pilcrow}]{#section-4-4.3}

We recommend the following procedure to select the type and the
parameters for practical use of Argon2.[¶](#section-4-5){.pilcrow}

1.  [If a uniformly safe option that is not tailored to your application
    or hardware is acceptable, select Argon2id with t=1 iteration, p=4
    lanes, m=2\^(21) (2 GiB of RAM), 128-bit salt, and 256-bit tag size.
    This is the FIRST [RECOMMENDED]{.bcp14}
    option.[¶](#section-4-6.1){.pilcrow}]{#section-4-6.1}
2.  [If much less memory is available, a uniformly safe option is
    Argon2id with t=3 iterations, p=4 lanes, m=2\^(16) (64 MiB of RAM),
    128-bit salt, and 256-bit tag size. This is the SECOND
    [RECOMMENDED]{.bcp14}
    option.[¶](#section-4-6.2){.pilcrow}]{#section-4-6.2}
3.  [Otherwise, start with selecting the type y. If you do not know the
    difference between the types or you consider side-channel attacks to
    be a viable threat, choose
    Argon2id.[¶](#section-4-6.3){.pilcrow}]{#section-4-6.3}
4.  [Select p=4 lanes.[¶](#section-4-6.4){.pilcrow}]{#section-4-6.4}
5.  [Figure out the maximum amount of memory that each call can afford
    and translate it to the parameter
    m.[¶](#section-4-6.5){.pilcrow}]{#section-4-6.5}
6.  [Figure out the maximum amount of time (in seconds) that each call
    can afford.[¶](#section-4-6.6){.pilcrow}]{#section-4-6.6}
7.  [Select the salt length. A length of 128 bits is sufficient for all
    applications but can be reduced to 64 bits in the case of space
    constraints.[¶](#section-4-6.7){.pilcrow}]{#section-4-6.7}
8.  [Select the tag length. A length of 128 bits is sufficient for most
    applications, including key derivation. If longer keys are needed,
    select longer tags.[¶](#section-4-6.8){.pilcrow}]{#section-4-6.8}
9.  [If side-channel attacks are a viable threat or if you\'re
    uncertain, enable the memory-wiping option in the library
    call.[¶](#section-4-6.9){.pilcrow}]{#section-4-6.9}
10. [Run the scheme of type y, memory m, and p lanes using a different
    number of passes t. Figure out the maximum t such that the running
    time does not exceed the affordable time. If it even exceeds for t =
    1, reduce m
    accordingly.[¶](#section-4-6.10){.pilcrow}]{#section-4-6.10}
11. [Use Argon2 with determined values m, p, and
    t.[¶](#section-4-6.11){.pilcrow}]{#section-4-6.11}
:::
:::

::: {#test-vectors}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Test Vectors](#name-test-vectors){.section-name .selfRef} {#name-test-vectors}

This section contains test vectors for
Argon2.[¶](#section-5-1){.pilcrow}

::: {#argon2d-test-vectors}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Argon2d Test Vectors](#name-argon2d-test-vectors){.section-name .selfRef} {#name-argon2d-test-vectors}

We provide test vectors with complete outputs (tags). For the
convenience of developers, we also provide some interim variables \--
concretely, the first and last memory blocks of each
pass.[¶](#section-5.1-1){.pilcrow}

::: {#section-5.1-2}
``` {.sourcecode .lang-test-vectors}
=======================================
Argon2d version number 19
=======================================
Memory: 32 KiB
Passes: 3
Parallelism: 4 lanes
Tag length: 32 bytes
Password[32]: 01 01 01 01 01 01 01 01
              01 01 01 01 01 01 01 01
              01 01 01 01 01 01 01 01
              01 01 01 01 01 01 01 01
Salt[16]: 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02
Secret[8]: 03 03 03 03 03 03 03 03
Associated data[12]: 04 04 04 04 04 04 04 04 04 04 04 04
Pre-hashing digest: b8 81 97 91 a0 35 96 60
                    bb 77 09 c8 5f a4 8f 04
                    d5 d8 2c 05 c5 f2 15 cc
                    db 88 54 91 71 7c f7 57
                    08 2c 28 b9 51 be 38 14
                    10 b5 fc 2e b7 27 40 33
                    b9 fd c7 ae 67 2b ca ac
                    5d 17 90 97 a4 af 31 09

 After pass 0:
Block 0000 [  0]: db2fea6b2c6f5c8a
Block 0000 [  1]: 719413be00f82634
Block 0000 [  2]: a1e3f6dd42aa25cc
Block 0000 [  3]: 3ea8efd4d55ac0d1
...
Block 0031 [124]: 28d17914aea9734c
Block 0031 [125]: 6a4622176522e398
Block 0031 [126]: 951aa08aeecb2c05
Block 0031 [127]: 6a6c49d2cb75d5b6

 After pass 1:
Block 0000 [  0]: d3801200410f8c0d
Block 0000 [  1]: 0bf9e8a6e442ba6d
Block 0000 [  2]: e2ca92fe9c541fcc
Block 0000 [  3]: 6269fe6db177a388
...
Block 0031 [124]: 9eacfcfbdb3ce0fc
Block 0031 [125]: 07dedaeb0aee71ac
Block 0031 [126]: 074435fad91548f4
Block 0031 [127]: 2dbfff23f31b5883

 After pass 2:
Block 0000 [  0]: 5f047b575c5ff4d2
Block 0000 [  1]: f06985dbf11c91a8
Block 0000 [  2]: 89efb2759f9a8964
Block 0000 [  3]: 7486a73f62f9b142
...
Block 0031 [124]: 57cfb9d20479da49
Block 0031 [125]: 4099654bc6607f69
Block 0031 [126]: f142a1126075a5c8
Block 0031 [127]: c341b3ca45c10da5
Tag: 51 2b 39 1b 6f 11 62 97
     53 71 d3 09 19 73 42 94
     f8 68 e3 be 39 84 f3 c1
     a1 3a 4d b9 fa be 4a cb
```

[¶](#section-5.1-2){.pilcrow}
:::
:::
:::

::: {#argon2i-test-vectors}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Argon2i Test Vectors](#name-argon2i-test-vectors){.section-name .selfRef} {#name-argon2i-test-vectors}

::: {#section-5.2-1}
``` {.sourcecode .lang-test-vectors}
=======================================
Argon2i version number 19
=======================================
Memory: 32 KiB
Passes: 3
Parallelism: 4 lanes
Tag length: 32 bytes
Password[32]: 01 01 01 01 01 01 01 01
              01 01 01 01 01 01 01 01
              01 01 01 01 01 01 01 01
              01 01 01 01 01 01 01 01
Salt[16]: 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02
Secret[8]: 03 03 03 03 03 03 03 03
Associated data[12]: 04 04 04 04 04 04 04 04 04 04 04 04
Pre-hashing digest: c4 60 65 81 52 76 a0 b3
                    e7 31 73 1c 90 2f 1f d8
                    0c f7 76 90 7f bb 7b 6a
                    5c a7 2e 7b 56 01 1f ee
                    ca 44 6c 86 dd 75 b9 46
                    9a 5e 68 79 de c4 b7 2d
                    08 63 fb 93 9b 98 2e 5f
                    39 7c c7 d1 64 fd da a9

 After pass 0:
Block 0000 [  0]: f8f9e84545db08f6
Block 0000 [  1]: 9b073a5c87aa2d97
Block 0000 [  2]: d1e868d75ca8d8e4
Block 0000 [  3]: 349634174e1aebcc
...
Block 0031 [124]: 975f596583745e30
Block 0031 [125]: e349bdd7edeb3092
Block 0031 [126]: b751a689b7a83659
Block 0031 [127]: c570f2ab2a86cf00

 After pass 1:
Block 0000 [  0]: b2e4ddfcf76dc85a
Block 0000 [  1]: 4ffd0626c89a2327
Block 0000 [  2]: 4af1440fff212980
Block 0000 [  3]: 1e77299c7408505b
...
Block 0031 [124]: e4274fd675d1e1d6
Block 0031 [125]: 903fffb7c4a14c98
Block 0031 [126]: 7e5db55def471966
Block 0031 [127]: 421b3c6e9555b79d

 After pass 2:
Block 0000 [  0]: af2a8bd8482c2f11
Block 0000 [  1]: 785442294fa55e6d
Block 0000 [  2]: 9256a768529a7f96
Block 0000 [  3]: 25a1c1f5bb953766
...
Block 0031 [124]: 68cf72fccc7112b9
Block 0031 [125]: 91e8c6f8bb0ad70d
Block 0031 [126]: 4f59c8bd65cbb765
Block 0031 [127]: 71e436f035f30ed0
Tag: c8 14 d9 d1 dc 7f 37 aa
     13 f0 d7 7f 24 94 bd a1
     c8 de 6b 01 6d d3 88 d2
     99 52 a4 c4 67 2b 6c e8
```

[¶](#section-5.2-1){.pilcrow}
:::
:::
:::

::: {#argon2id-test-vectors}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Argon2id Test Vectors](#name-argon2id-test-vectors){.section-name .selfRef} {#name-argon2id-test-vectors}

::: {#section-5.3-1}
``` {.sourcecode .lang-test-vectors}
=======================================
Argon2id version number 19
=======================================
Memory: 32 KiB, Passes: 3,
Parallelism: 4 lanes, Tag length: 32 bytes
Password[32]: 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
Salt[16]: 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02
Secret[8]: 03 03 03 03 03 03 03 03
Associated data[12]: 04 04 04 04 04 04 04 04 04 04 04 04
Pre-hashing digest: 28 89 de 48 7e b4 2a e5 00 c0 00 7e d9 25 2f
 10 69 ea de c4 0d 57 65 b4 85 de 6d c2 43 7a 67 b8 54 6a 2f 0a
 cc 1a 08 82 db 8f cf 74 71 4b 47 2e 94 df 42 1a 5d a1 11 2f fa
 11 43 43 70 a1 e9 97

 After pass 0:
Block 0000 [  0]: 6b2e09f10671bd43
Block 0000 [  1]: f69f5c27918a21be
Block 0000 [  2]: dea7810ea41290e1
Block 0000 [  3]: 6787f7171870f893
...
Block 0031 [124]: 377fa81666dc7f2b
Block 0031 [125]: 50e586398a9c39c8
Block 0031 [126]: 6f732732a550924a
Block 0031 [127]: 81f88b28683ea8e5

 After pass 1:
Block 0000 [  0]: 3653ec9d01583df9
Block 0000 [  1]: 69ef53a72d1e1fd3
Block 0000 [  2]: 35635631744ab54f
Block 0000 [  3]: 599512e96a37ab6e
...
Block 0031 [124]: 4d4b435cea35caa6
Block 0031 [125]: c582210d99ad1359
Block 0031 [126]: d087971b36fd6d77
Block 0031 [127]: a55222a93754c692

 After pass 2:
Block 0000 [  0]: 942363968ce597a4
Block 0000 [  1]: a22448c0bdad5760
Block 0000 [  2]: a5f80662b6fa8748
Block 0000 [  3]: a0f9b9ce392f719f
...
Block 0031 [124]: d723359b485f509b
Block 0031 [125]: cb78824f42375111
Block 0031 [126]: 35bc8cc6e83b1875
Block 0031 [127]: 0b012846a40f346a
Tag: 0d 64 0d f5 8d 78 76 6c 08 c0 37 a3 4a 8b 53 c9 d0
 1e f0 45 2d 75 b6 5e b5 25 20 e9 6b 01 e6 59
```

[¶](#section-5.3-1){.pilcrow}
:::
:::
:::
:::
:::

::: {#iana}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-6-1){.pilcrow}
:::
:::

::: {#security}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

::: {#security-hash}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Security as a Hash Function and KDF](#name-security-as-a-hash-function){.section-name .selfRef} {#name-security-as-a-hash-function}

The collision and preimage resistance levels of Argon2 are equivalent to
those of the underlying BLAKE2b hash function. To produce a collision,
2\^(256) inputs are needed. To find a preimage, 2\^(512) inputs must be
tried.[¶](#section-7.1-1){.pilcrow}

The KDF security is determined by the key length and the size of the
internal state of hash function H\'. To distinguish the output of the
keyed Argon2 from random, a minimum of (2\^(128),2\^length(K)) calls to
BLAKE2b are needed.[¶](#section-7.1-2){.pilcrow}
:::
:::

::: {#security-tradeoff}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Security against Time-Space Trade-off Attacks](#name-security-against-time-space){.section-name .selfRef} {#name-security-against-time-space}

Time-space trade-offs allow computing a memory-hard function storing
fewer memory blocks at the cost of more calls to the internal
compression function. The advantage of trade-off attacks is measured in
the reduction factor to the time-area product, where memory and extra
compression function cores contribute to the area and time is increased
to accommodate the recomputation of missed blocks. A high reduction
factor may potentially speed up the preimage
search.[¶](#section-7.2-1){.pilcrow}

The best-known attack on the 1-pass and 2-pass Argon2i is the
low-storage attack described in \[[CBS16](#CBS16){.xref}\], which
reduces the time-area product (using the peak memory value) by the
factor of 5. The best attack on Argon2i with 3 passes or more is
described in \[[AB16](#AB16){.xref}\], with the reduction factor being a
function of memory size and the number of passes (e.g., for 1 gibibyte
of memory, a reduction factor of 3 for 3 passes, 2.5 for 4 passes, 2 for
6 passes). The reduction factor grows by about 0.5 with every doubling
of the memory size. To completely prevent time-space trade-offs from
\[[AB16](#AB16){.xref}\], the number of passes [MUST]{.bcp14} exceed the
binary logarithm of memory minus 26. Asymptotically, the best attack on
1-pass Argon2i is given in \[[BZ17](#BZ17){.xref}\], with maximal
advantage of the adversary upper bounded by O(m\^(0.233)), where m is
the number of blocks. This attack is also asymptotically optimal as
\[[BZ17](#BZ17){.xref}\] also proves the upper bound on any attack is
O(m\^(0.25)).[¶](#section-7.2-2){.pilcrow}

The best trade-off attack on t-pass Argon2d is the ranking trade-off
attack, which reduces the time-area product by the factor of
1.33.[¶](#section-7.2-3){.pilcrow}

The best attack on Argon2id can be obtained by complementing the best
attack on the 1-pass Argon2i with the best attack on a multi-pass
Argon2d. Thus, the best trade-off attack on 1-pass Argon2id is the
combined low-storage attack (for the first half of the memory) and the
ranking attack (for the second half), which generate the factor of about
2.1. The best trade-off attack on t-pass Argon2id is the ranking
trade-off attack, which reduces the time-area product by the factor of
1.33.[¶](#section-7.2-4){.pilcrow}
:::
:::

::: {#security-general}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Security for Time-Bounded Defenders](#name-security-for-time-bounded-d){.section-name .selfRef} {#name-security-for-time-bounded-d}

A bottleneck in a system employing the password hashing function is
often the function latency rather than memory costs. A rational defender
would then maximize the brute-force costs for the attacker equipped with
a list of hashes, salts, and timing information for fixed computing time
on the defender\'s machine. The attack cost estimates from
\[[AB16](#AB16){.xref}\] imply that for Argon2i, 3 passes is almost
optimal for most reasonable memory sizes; for Argon2d and Argon2id, 1
pass maximizes the attack costs for the constant defender
time.[¶](#section-7.3-1){.pilcrow}
:::
:::

::: {#security-recommend}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [Recommendations](#name-recommendations){.section-name .selfRef} {#name-recommendations}

The Argon2id variant with t=1 and 2 GiB memory is the FIRST
[RECOMMENDED]{.bcp14} option and is suggested as a default setting for
all environments. This setting is secure against side-channel attacks
and maximizes adversarial costs on dedicated brute-force hardware. The
Argon2id variant with t=3 and 64 MiB memory is the SECOND
[RECOMMENDED]{.bcp14} option and is suggested as a default setting for
memory-constrained environments.[¶](#section-7.4-1){.pilcrow}
:::
:::
:::
:::

::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[BLAKE2\]
:   [Saarinen, M-J., Ed.]{.refAuthor} and [J-P. Aumasson]{.refAuthor},
    [\"The BLAKE2 Cryptographic Hash and Message Authentication Code
    (MAC)\"]{.refTitle}, [RFC 7693]{.seriesInfo}, [DOI
    10.17487/RFC7693]{.seriesInfo}, November 2015,
    \<<https://www.rfc-editor.org/info/rfc7693>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   
:::

::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[AB15\]
:   [Biryukov, A.]{.refAuthor} and [D. Khovratovich]{.refAuthor},
    [\"Tradeoff Cryptanalysis of Memory-Hard Functions\"]{.refTitle},
    [ASIACRYPT 2015]{.refContent}, [DOI
    10.1007/978-3-662-48800-3_26]{.seriesInfo}, December 2015,
    \<<https://eprint.iacr.org/2015/227.pdf>\>.
:   

\[AB16\]
:   [Alwen, J.]{.refAuthor} and [J. Blocki]{.refAuthor}, [\"Efficiently
    Computing Data-Independent Memory-Hard Functions\"]{.refTitle},
    [CRYPTO 2016]{.refContent}, [DOI
    10.1007/978-3-662-53008-5_9]{.seriesInfo}, March 2016,
    \<<https://eprint.iacr.org/2016/115.pdf>\>.
:   

\[ARGON2\]
:   [Biryukov, A.]{.refAuthor}, [Dinu, D.]{.refAuthor}, and [D.
    Khovratovich]{.refAuthor}, [\"Argon2: the memory-hard function for
    password hashing and other applications\"]{.refTitle}, March 2017,
    \<<https://www.cryptolux.org/images/0/0d/Argon2.pdf>\>.
:   

\[ARGON2ESP\]
:   [Biryukov, A.]{.refAuthor}, [Dinu, D.]{.refAuthor}, and [D.
    Khovratovich]{.refAuthor}, [\"Argon2: New Generation of Memory-Hard
    Functions for Password Hashing and Other Applications\"]{.refTitle},
    [Euro SnP 2016]{.refContent}, [DOI
    10.1109/EuroSP.2016.31]{.seriesInfo}, March 2016,
    \<<https://www.cryptolux.org/images/d/d0/Argon2ESP.pdf>\>.
:   

\[BZ17\]
:   [Blocki, J.]{.refAuthor} and [S. Zhou]{.refAuthor}, [\"On the
    Depth-Robustness and Cumulative Pebbling Cost of
    Argon2i\"]{.refTitle}, [TCC 2017]{.refContent}, [DOI
    10.1007/978-3-319-70500-2_15]{.seriesInfo}, May 2017,
    \<<https://eprint.iacr.org/2017/442.pdf>\>.
:   

\[CBS16\]
:   [Boneh, D.]{.refAuthor}, [Corrigan-Gibbs, H.]{.refAuthor}, and [S.
    Schechter]{.refAuthor}, [\"Balloon Hashing: A Memory-Hard Function
    Providing Provable Protection Against Sequential
    Attacks\"]{.refTitle}, [ASIACRYPT 2016]{.refContent}, [DOI
    10.1007/978-3-662-53887-6_8]{.seriesInfo}, May 2017,
    \<<https://eprint.iacr.org/2016/027.pdf>\>.
:   

\[HARD\]
:   [Alwen, J.]{.refAuthor} and [V. Serbinenko]{.refAuthor}, [\"High
    Parallel Complexity Graphs and Memory-Hard Functions\"]{.refTitle},
    [STOC \'15]{.refContent}, [DOI
    10.1145/2746539.2746622]{.seriesInfo}, June 2015,
    \<<https://eprint.iacr.org/2014/238.pdf>\>.
:   
:::
:::

::: {#ack}
::: {#appendix-A .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

We greatly thank the following individuals who helped in preparing and
reviewing this document: [Jean-Philippe Aumasson]{.contact-name},
[Samuel Neves]{.contact-name}, [Joel Alwen]{.contact-name}, [Jeremiah
Blocki]{.contact-name}, [Bill Cox]{.contact-name}, [Arnold
Reinhold]{.contact-name}, [Solar Designer]{.contact-name}, [Russ
Housley]{.contact-name}, [Stanislav Smyshlyaev]{.contact-name}, [Kenny
Paterson]{.contact-name}, [Alexey Melnikov]{.contact-name}, and [Gwynne
Raskind]{.contact-name}.[¶](#appendix-A-1){.pilcrow}

The work described in this document was done before [Daniel
Dinu]{.contact-name} joined Intel, while he was at the University of
Luxembourg.[¶](#appendix-A-2){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-B .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Alex Biryukov]{.fn .nameRole}
:::

::: {.left dir="auto"}
[University of Luxembourg]{.org}
:::

::: email
Email: <alex.biryukov@uni.lu>
:::

::: {.left dir="auto"}
[Daniel Dinu]{.fn .nameRole}
:::

::: {.left dir="auto"}
[University of Luxembourg]{.org}
:::

::: email
Email: <daniel.dinu@intel.com>
:::

::: {.left dir="auto"}
[Dmitry Khovratovich]{.fn .nameRole}
:::

::: {.left dir="auto"}
[ABDK Consulting]{.org}
:::

::: email
Email: <khovratovich@gmail.com>
:::

::: {.left dir="auto"}
[Simon Josefsson]{.fn .nameRole}
:::

::: {.left dir="auto"}
[SJD AB]{.org}
:::

::: email
Email: <simon@josefsson.org>
:::

::: url
URI: [http://josefsson.org/](https://josefsson.org/){.url}
:::
:::
:::
