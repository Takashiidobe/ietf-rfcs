  RFC 9222            ASA Guidelines   March 2022
  ------------------- ---------------- ------------
  Carpenter, et al.   Informational    \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9222](https://www.rfc-editor.org/rfc/rfc9222){.eref}

Category:
:   Informational

Published:
:   March 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    B. Carpenter
    :::

    ::: org
    Univ. of Auckland
    :::
    :::

    ::: author
    ::: author-name
    L. Ciavaglia
    :::

    ::: org
    Rakuten Mobile
    :::
    :::

    ::: author
    ::: author-name
    S. Jiang
    :::

    ::: org
    Huawei Technologies Co., Ltd
    :::
    :::

    ::: author
    ::: author-name
    P. Peloso
    :::

    ::: org
    Nokia
    :::
    :::
:::

# RFC 9222 {#rfcnum}

# Guidelines for Autonomic Service Agents {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document proposes guidelines for the design of Autonomic Service
Agents for autonomic networks. Autonomic Service Agents, together with
the Autonomic Network Infrastructure, the Autonomic Control Plane, and
the GeneRic Autonomic Signaling Protocol, constitute base elements of an
autonomic networking ecosystem.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for informational
purposes.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Not all documents approved
by the IESG are candidates for any level of Internet Standard; see
Section 2 of RFC 7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9222>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Logical Structure of an Autonomic Service
    Agent](#name-logical-structure-of-an-aut){.xref}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Interaction with the Autonomic Networking
    Infrastructure](#name-interaction-with-the-autono){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Interaction with the Security
        Mechanisms](#name-interaction-with-the-securi){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Interaction with the Autonomic
        Control Plane](#name-interaction-with-the-autonom){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Interaction with GRASP and its
        API](#name-interaction-with-grasp-and-){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Interaction with Policy
        Mechanisms](#name-interaction-with-policy-mec){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Interaction with Non-autonomic Components
    and Systems](#name-interaction-with-non-autono){.xref}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Design of GRASP
    Objectives](#name-design-of-grasp-objectives){.xref}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Life Cycle](#name-life-cycle){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Installation
        Phase](#name-installation-phase){.xref}

        -   ::: {#section-toc.1-1.7.2.1.2.1}
            [7.1.1](#section-7.1.1){.xref}.  [Installation Phase Inputs
            and Outputs](#name-installation-phase-inputs-a){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Instantiation
        Phase](#name-instantiation-phase){.xref}

        -   ::: {#section-toc.1-1.7.2.2.2.1}
            [7.2.1](#section-7.2.1){.xref}.  [Operator\'s
            Goal](#name-operators-goal){.xref}
            :::

        -   ::: {#section-toc.1-1.7.2.2.2.2}
            [7.2.2](#section-7.2.2){.xref}.  [Instantiation Phase Inputs
            and Outputs](#name-instantiation-phase-inputs-){.xref}
            :::

        -   ::: {#section-toc.1-1.7.2.2.2.3}
            [7.2.3](#section-7.2.3){.xref}.  [Instantiation Phase
            Requirements](#name-instantiation-phase-require){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Operation
        Phase](#name-operation-phase){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [Removal
        Phase](#name-removal-phase){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Coordination and Data
    Models](#name-coordination-and-data-model){.xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Coordination between Autonomic
        Functions](#name-coordination-between-autono){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Coordination with Traditional
        Management Functions](#name-coordination-with-tradition){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [8.3](#section-8.3){.xref}.  [Data
        Models](#name-data-models){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Robustness](#name-robustness){.xref}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Security
    Considerations](#name-security-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.12.2.1}
        [12.1](#section-12.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [12.2](#section-12.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [Appendix A](#appendix-A){.xref}.  [Example Logic
    Flows](#name-example-logic-flows){.xref}
    :::

-   ::: {#section-toc.1-1.14}
    [](#appendix-B){.xref}[Acknowledgements](#name-acknowledgements){.xref}
    :::

-   ::: {#section-toc.1-1.15}
    [](#appendix-C){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#intro}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

This document proposes guidelines for the design of Autonomic Service
Agents (ASAs) in the context of an Autonomic Network (AN) based on the
Autonomic Network Infrastructure (ANI) outlined in the autonomic
networking reference model \[[RFC8993](#RFC8993){.xref}\]. This
infrastructure makes use of the Autonomic Control Plane (ACP)
\[[RFC8994](#RFC8994){.xref}\] and the GeneRic Autonomic Signaling
Protocol (GRASP) \[[RFC8990](#RFC8990){.xref}\]. A general introduction
to this environment may be found at \[[IPJ](#IPJ){.xref}\], which also
includes explanatory diagrams, and a summary of terminology is in
[Section 2](#terminology){.xref}.[¶](#section-1-1){.pilcrow}

This document is a contribution to the description of an autonomic
networking ecosystem, recognizing that a deployable autonomic network
needs more than just ACP and GRASP implementations. Such an autonomic
network must achieve management tasks that a Network Operations Center
(NOC) cannot readily achieve manually, such as continuous resource
optimization or automated fault detection and repair. These tasks, and
other management automation goals, are described at length in
\[[RFC7575](#RFC7575){.xref}\]. The net result should be significant
operational improvement. To achieve this, the autonomic networking
ecosystem must include at least a library of ASAs and corresponding
GRASP technical objective definitions. A GRASP objective
\[[RFC8990](#RFC8990){.xref}\] is a data structure whose main contents
are a name and a value. The value consists of a single configurable
parameter or a set of parameters of some
kind.[¶](#section-1-2){.pilcrow}

There must also be tools to deploy and oversee ASAs, and integration
with existing operational mechanisms \[[RFC8368](#RFC8368){.xref}\].
However, this document focuses on the design of ASAs, with some
reference to implementation and operational
aspects.[¶](#section-1-3){.pilcrow}

There is considerable literature about autonomic agents with a variety
of proposals about how they should be characterized. Some examples are
\[[DEMOLA06](#DEMOLA06){.xref}\],
\[[HUEBSCHER08](#HUEBSCHER08){.xref}\],
\[[MOVAHEDI12](#MOVAHEDI12){.xref}\], and \[[GANA13](#GANA13){.xref}\].
However, for the present document, the basic definitions and goals for
autonomic networking given in \[[RFC7575](#RFC7575){.xref}\] apply.
According to RFC 7575, an Autonomic Service Agent is \"An agent
implemented on an autonomic node that implements an autonomic function,
either in part (in the case of a distributed function) or
whole.\"[¶](#section-1-4){.pilcrow}

ASAs must be distinguished from other forms of software components. They
are components of network or service management; they do not in
themselves provide services to end users. They do, however, provide
management services to network operators and administrators. For
example, the services envisaged for network function virtualization
(NFV) \[[NFV](#NFV){.xref}\] or for service function chaining (SFC)
\[[RFC7665](#RFC7665){.xref}\] might be managed by an ASA rather than by
traditional configuration tools.[¶](#section-1-5){.pilcrow}

Another example is that an existing script running within a router to
locally monitor or configure functions or services could be upgraded to
an ASA that could communicate with peer scripts on neighboring or remote
routers. A high-level API will allow such upgraded scripts to take full
advantage of the secure ACP and the discovery, negotiation, and
synchronization features of GRASP. Familiar tasks such as configuring an
Interior Gateway Protocol (IGP) on neighboring routers or even
exchanging IGP security keys could be performed securely in this way.
This document mainly addresses issues affecting quite complex ASAs, but
initially, the most useful ASAs may in fact be rather simple evolutions
of existing scripts.[¶](#section-1-6){.pilcrow}

The reference model \[[RFC8993](#RFC8993){.xref}\] for autonomic
networks explains further the functionality of ASAs by adding the
following:[¶](#section-1-7){.pilcrow}

> \[An ASA is\] a process that makes use of the features provided by the
> ANI to achieve its own goals, usually including interaction with other
> ASAs via GRASP \[[RFC8990](#RFC8990){.xref}\] or otherwise. Of course,
> it also interacts with the specific targets of its function, using any
> suitable mechanism. Unless its function is very simple, the ASA will
> need to handle overlapping asynchronous operations. It may therefore
> be a quite complex piece of software in its own right, forming part of
> the application layer above the ANI.[¶](#section-1-8){.pilcrow}

As mentioned, there will certainly be simple ASAs that manage a single
objective in a straightforward way and do not need asynchronous
operations. In nodes where computing power and memory space are limited,
ASAs should run at a much lower frequency than the primary workload, so
CPU load should not be a big issue, but memory footprint in a
constrained node is certainly a concern. ASAs installed in constrained
devices will have limited functionality. In such cases, many aspects of
the current document do not apply. However, in the general case, an ASA
may be a relatively complex software component that will in many cases
control and monitor simpler entities in the same or remote host(s). For
example, a device controller that manages tens or hundreds of simple
devices might contain a single ASA.[¶](#section-1-9){.pilcrow}

The remainder of this document offers guidance on the design of complex
ASAs. Some of the material may be familiar to those experienced in
distributed fault-tolerant and real-time control systems. Robustness and
security are of particular importance in autonomic networks and are
discussed in Sections [9](#robust){.xref} and
[10](#security){.xref}.[¶](#section-1-10){.pilcrow}
:::
:::

::: {#terminology}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

This section summarizes various acronyms and terminology used in the
document. Where no other reference is given, please consult
\[[RFC8993](#RFC8993){.xref}\] or
\[[RFC7575](#RFC7575){.xref}\].[¶](#section-2-1){.pilcrow}

[]{.break}

Autonomic:
:   self-managing (self-configuring, self-protecting, self- healing,
    self-optimizing), but allowing high-level guidance by a central
    entity such as a NOC[¶](#section-2-2.2){.pilcrow}
:   

Autonomic Function:
:   a function that adapts on its own to a changing
    environment[¶](#section-2-2.4){.pilcrow}
:   

Autonomic Node:
:   a node that employs autonomic functions[¶](#section-2-2.6){.pilcrow}
:   

ACP:
:   Autonomic Control Plane
    \[[RFC8994](#RFC8994){.xref}\][¶](#section-2-2.8){.pilcrow}
:   

AN:
:   Autonomic Network; a network of autonomic nodes, which interact
    directly with each other[¶](#section-2-2.10){.pilcrow}
:   

ANI:
:   Autonomic Network Infrastructure[¶](#section-2-2.12){.pilcrow}
:   

ASA:
:   Autonomic Service Agent; an agent installed on an autonomic node
    that implements an autonomic function, either partially (in the case
    of a distributed function) or
    completely[¶](#section-2-2.14){.pilcrow}
:   

BRSKI:
:   Bootstrapping Remote Secure Key Infrastructure
    \[[RFC8995](#RFC8995){.xref}\][¶](#section-2-2.16){.pilcrow}
:   

CBOR:
:   Concise Binary Object
    Representation\[[RFC8949](#RFC8949){.xref}\][¶](#section-2-2.18){.pilcrow}
:   

GRASP:
:   GeneRric Autonomic Signaling Protocol
    \[[RFC8990](#RFC8990){.xref}\][¶](#section-2-2.20){.pilcrow}
:   

GRASP API:
:   GRASP Application Programming Interface
    \[[RFC8991](#RFC8991){.xref}\][¶](#section-2-2.22){.pilcrow}
:   

NOC:
:   Network Operations Center
    \[[RFC8368](#RFC8368){.xref}\][¶](#section-2-2.24){.pilcrow}
:   

Objective:
:   A GRASP technical objective is a data structure whose main contents
    are a name and a value. The value consists of a single configurable
    parameter or a set of parameters of some kind
    \[[RFC8990](#RFC8990){.xref}\].[¶](#section-2-2.26){.pilcrow}
:   
:::
:::

::: {#structure}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Logical Structure of an Autonomic Service Agent](#name-logical-structure-of-an-aut){.section-name .selfRef} {#name-logical-structure-of-an-aut}

As mentioned above, all but the simplest ASAs will need to support
asynchronous operations. Different programming environments support
asynchronicity in different ways. In this document, we use an explicit
multi-threading model to describe operations. This is illustrative, and
alternatives to multi-threading are discussed in detail in connection
with the GRASP API (see [Section
4.3](#api){.xref}).[¶](#section-3-1){.pilcrow}

A typical ASA will have a main thread that performs various initial
housekeeping actions such as:[¶](#section-3-2){.pilcrow}

-   [obtain authorization credentials, if
    needed[¶](#section-3-3.1){.pilcrow}]{#section-3-3.1}
-   [register the ASA with
    GRASP[¶](#section-3-3.2){.pilcrow}]{#section-3-3.2}
-   [acquire relevant policy
    parameters[¶](#section-3-3.3){.pilcrow}]{#section-3-3.3}
-   [declare data structures for relevant GRASP
    objectives[¶](#section-3-3.4){.pilcrow}]{#section-3-3.4}
-   [register with GRASP those objectives that it will actively
    manage[¶](#section-3-3.5){.pilcrow}]{#section-3-3.5}
-   [launch a self-monitoring
    thread[¶](#section-3-3.6){.pilcrow}]{#section-3-3.6}
-   [enter its main loop[¶](#section-3-3.7){.pilcrow}]{#section-3-3.7}

The logic of the main loop will depend on the details of the autonomic
function concerned. Whenever asynchronous operations are required, extra
threads may be launched. Examples of such threads
include:[¶](#section-3-4){.pilcrow}

-   [repeatedly flood an objective to the AN so that any ASA can receive
    the objective\'s latest
    value[¶](#section-3-5.1){.pilcrow}]{#section-3-5.1}
-   [accept incoming synchronization requests for an objective managed
    by this ASA[¶](#section-3-5.2){.pilcrow}]{#section-3-5.2}
-   [accept incoming negotiation requests for an objective managed by
    this ASA, and then conduct the resulting negotiation with the
    counterpart ASA[¶](#section-3-5.3){.pilcrow}]{#section-3-5.3}
-   [manage subsidiary non-autonomic devices
    directly[¶](#section-3-5.4){.pilcrow}]{#section-3-5.4}

These threads should all either exit after their job is done or enter a
wait state for new work to avoid wasting system
resources.[¶](#section-3-6){.pilcrow}

According to the degree of parallelism needed by the application, some
of these threads might be launched in multiple instances. In particular,
if negotiation sessions with other ASAs are expected to be long or to
involve wait states, the ASA designer might allow for multiple
simultaneous negotiating threads, with appropriate use of queues and
synchronization primitives to maintain
consistency.[¶](#section-3-7){.pilcrow}

The main loop itself could act as the initiator of synchronization
requests or negotiation requests when the ASA needs data or resources
from other ASAs. In particular, the main loop should watch for changes
in policy parameters that affect its operation and, if appropriate,
occasionally refresh authorization credentials. It should also do
whatever is required to avoid unnecessary resource consumption, for
example, by limiting its frequency of
execution.[¶](#section-3-8){.pilcrow}

The self-monitoring thread is of considerable importance. Failure of
autonomic service agents is highly undesirable. To a large extent, this
depends on careful coding and testing, with no unhandled error returns
or exceptions, but if there is nevertheless some sort of failure, the
self-monitoring thread should detect it, fix it if possible, and, in the
worst case, restart the entire ASA.[¶](#section-3-9){.pilcrow}

[Appendix A](#eg){.xref} presents some example logic flows in informal
pseudocode.[¶](#section-3-10){.pilcrow}
:::
:::

::: {#interact}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Interaction with the Autonomic Networking Infrastructure](#name-interaction-with-the-autono){.section-name .selfRef} {#name-interaction-with-the-autono}

::: {#interacts}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Interaction with the Security Mechanisms](#name-interaction-with-the-securi){.section-name .selfRef} {#name-interaction-with-the-securi}

An ASA by definition runs in an autonomic node. Before any normal ASAs
are started, such nodes must be bootstrapped into the autonomic
network\'s secure key infrastructure, typically in accordance with
\[[RFC8995](#RFC8995){.xref}\]. This key infrastructure will be used to
secure the ACP (next section) and may be used by ASAs to set up
additional secure interactions with their peers, if
needed.[¶](#section-4.1-1){.pilcrow}

Note that the secure bootstrap process itself incorporates simple
special-purpose ASAs that use a restricted mode of GRASP ([Section
4](https://www.rfc-editor.org/rfc/rfc8995#section-4){.relref} of
\[[RFC8995](#RFC8995){.xref}\]).[¶](#section-4.1-2){.pilcrow}
:::
:::

::: {#interacta}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Interaction with the Autonomic Control Plane](#name-interaction-with-the-autonom){.section-name .selfRef} {#name-interaction-with-the-autonom}

In a normal autonomic network, ASAs will run as clients of the ACP,
which will provide a fully secured network environment for all
communication with other ASAs, in most cases mediated by GRASP (next
section).[¶](#section-4.2-1){.pilcrow}

Note that the ACP formation process itself incorporates simple
special-purpose ASAs that use a restricted mode of GRASP ([Section
6.4](https://www.rfc-editor.org/rfc/rfc8994#section-6.4){.relref} of
\[[RFC8994](#RFC8994){.xref}\]).[¶](#section-4.2-2){.pilcrow}
:::
:::

::: {#api}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Interaction with GRASP and its API](#name-interaction-with-grasp-and-){.section-name .selfRef} {#name-interaction-with-grasp-and-}

In a node where a significant number of ASAs are installed, GRASP
\[[RFC8990](#RFC8990){.xref}\] is likely to run as a separate process
with its API \[[RFC8991](#RFC8991){.xref}\] available in user space.
Thus, ASAs may operate without special privilege, unless they need it
for other reasons. The ASA\'s view of GRASP is built around GRASP
objectives ([Section 6](#objdes){.xref}), defined as data structures
containing administrative information such as the objective\'s unique
name, and its current value. The format and size of the value is not
restricted by the protocol, except that it must be possible to serialize
it for transmission in Concise Binary Object Representation (CBOR)
\[[RFC8949](#RFC8949){.xref}\], subject only to GRASP\'s maximum message
size as discussed in [Section
6](#objdes){.xref}.[¶](#section-4.3-1){.pilcrow}

As discussed in [Section 3](#structure){.xref}, GRASP is an asynchronous
protocol, and this document uses a multi-threading model to describe
operations. In many programming environments, an \"event loop\" model is
used instead, in which case each thread would be implemented as an event
handler called in turn by the main loop. For this case, the GRASP API
must provide non-blocking calls and possibly support callbacks. This
topic is discussed in more detail in \[[RFC8991](#RFC8991){.xref}\], and
other asynchronicity models are also possible. Whenever necessary, the
GRASP session identifier will be used to distinguish simultaneous
operations.[¶](#section-4.3-2){.pilcrow}

The GRASP API should offer the following
features:[¶](#section-4.3-3){.pilcrow}

-   [Registration functions, so that an ASA can register itself and the
    objectives that it
    manages.[¶](#section-4.3-4.1){.pilcrow}]{#section-4.3-4.1}
-   [A discovery function, by which an ASA can discover other ASAs
    supporting a given
    objective.[¶](#section-4.3-4.2){.pilcrow}]{#section-4.3-4.2}
-   [A negotiation request function, by which an ASA can start
    negotiation of an objective with a counterpart ASA. With this, there
    is a corresponding listening function for an ASA that wishes to
    respond to negotiation requests and a set of functions to support
    negotiating steps. Once a negotiation starts, it is a symmetric
    process with both sides sending successive objective values to each
    other until agreement is reached (or the negotiation
    fails).[¶](#section-4.3-4.3){.pilcrow}]{#section-4.3-4.3}
-   [A synchronization function, by which an ASA can request the current
    value of an objective from a counterpart ASA. With this, there is a
    corresponding listening function for an ASA that wishes to respond
    to synchronization requests. Unlike negotiation, synchronization is
    an asymmetric process in which the listener sends a single objective
    value to the
    requester.[¶](#section-4.3-4.4){.pilcrow}]{#section-4.3-4.4}
-   [A flood function, by which an ASA can cause the current value of an
    objective to be flooded throughout the AN so that any ASA can
    receive it.[¶](#section-4.3-4.5){.pilcrow}]{#section-4.3-4.5}

For further details and some additional housekeeping functions, see
\[[RFC8991](#RFC8991){.xref}\].[¶](#section-4.3-5){.pilcrow}

The GRASP API is intended to support the various interactions expected
between most ASAs, such as the interactions outlined in [Section
3](#structure){.xref}. However, if ASAs require additional communication
between themselves, they can do so directly over the ACP to benefit from
its security. One option is to use GRASP discovery and synchronization
as a rendezvous mechanism between two ASAs, passing communication
parameters such as a TCP port number via GRASP. The use of TLS over the
ACP for such communications is advisable, as described in [Section
6.9.2](https://www.rfc-editor.org/rfc/rfc8994#section-6.9.2){.relref} of
\[[RFC8994](#RFC8994){.xref}\].[¶](#section-4.3-6){.pilcrow}
:::
:::

::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Interaction with Policy Mechanisms](#name-interaction-with-policy-mec){.section-name .selfRef} {#name-interaction-with-policy-mec}

At the time of writing, the policy mechanisms for the ANI are undefined.
In particular, the use of declarative policies (aka Intents) for the
definition and management of an ASA\'s behaviors remains a research
topic
\[[IBN-CONCEPTS](#I-D.irtf-nmrg-ibn-concepts-definitions){.xref}\].[¶](#section-4.4-1){.pilcrow}

In the cases where ASAs are defined as closed control loops, the
specifications defined in \[[ZSM009-1](#ZSM009-1){.xref}\] regarding
imperative and declarative goal statements may be
applicable.[¶](#section-4.4-2){.pilcrow}

In the ANI, policy dissemination is expected to operate by an
information distribution mechanism (e.g., via GRASP
\[[RFC8990](#RFC8990){.xref}\]) that can reach all autonomic nodes and
therefore every ASA. However, each ASA must be capable of operating
\"out of the box\" in the absence of locally defined policy, so every
ASA implementation must include carefully chosen default values and
settings for all policy parameters.[¶](#section-4.4-3){.pilcrow}
:::
:::
:::

::: {#nonauto}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Interaction with Non-autonomic Components and Systems](#name-interaction-with-non-autono){.section-name .selfRef} {#name-interaction-with-non-autono}

To have any external effects, an ASA must also interact with
non-autonomic components of the node where it is installed. For example,
an ASA whose purpose is to manage a resource must interact with that
resource. An ASA managing an entity that is also managed by local
software must interact with that software. For example, if such
management is performed by NETCONF \[[RFC6241](#RFC6241){.xref}\], the
ASA must interact with the NETCONF server as an independent NETCONF
client in the same node to avoid any inconsistency between configuration
changes delivered via NETCONF and configuration changes made by the
ASA.[¶](#section-5-1){.pilcrow}

In an environment where systems are virtualized and specialized using
techniques such as network function virtualization or network slicing,
there will be a design choice whether ASAs are deployed once per
physical node or once per virtual context. A related issue is whether
the ANI as a whole is deployed once on a physical network or whether
several virtual ANIs are deployed. This aspect needs to be considered by
the ASA designer.[¶](#section-5-2){.pilcrow}
:::
:::

::: {#objdes}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Design of GRASP Objectives](#name-design-of-grasp-objectives){.section-name .selfRef} {#name-design-of-grasp-objectives}

The design of an ASA will often require the design of a new GRASP
objective. The general rules for the format of GRASP objectives, their
names, and IANA registration are given in
\[[RFC8990](#RFC8990){.xref}\]. Additionally, that document discusses
various general considerations for the design of objectives, which are
not repeated here. However, note that GRASP, like HTTP, does not provide
transactional integrity. In particular, steps in a GRASP negotiation are
not idempotent. The design of a GRASP objective and the logic flow of
the ASA should take this into account. One approach, which should be
used when possible, is to design objectives with idempotent semantics.
If this is not possible, typically if an ASA is allocating part of a
shared resource to other ASAs, it needs to ensure that the same part of
the resource is not allocated twice. The easiest way is to run only one
negotiation at a time. If an ASA is capable of overlapping several
negotiations, it must avoid interference between these
negotiations.[¶](#section-6-1){.pilcrow}

Negotiations will always end, normally because one end or the other
declares success or failure. If this does not happen, either a timeout
or exhaustion of the loop count will occur. The definition of a GRASP
objective should describe a specific negotiation policy if it is not
self-evident.[¶](#section-6-2){.pilcrow}

GRASP allows a \"dry run\" mode of negotiation, where a negotiation
session follows its normal course but is not committed at either end
until a subsequent live negotiation session. If dry run mode is defined
for the objective, its specification, and every implementation, must
consider what state needs to be saved following a dry run negotiation,
such that a subsequent live negotiation can be expected to succeed. It
must be clear how long this state is kept and what happens if the live
negotiation occurs after this state is deleted. An ASA that requests a
dry run negotiation must take account of the possibility that a
successful dry run is followed by a failed live negotiation. Because of
these complexities, the dry run mechanism should only be supported by
objectives and ASAs where there is a significant benefit from
it.[¶](#section-6-3){.pilcrow}

The actual value field of an objective is limited by the GRASP protocol
definition to any data structure that can be expressed in Concise Binary
Object Representation (CBOR) \[[RFC8949](#RFC8949){.xref}\]. For some
objectives, a single data item will suffice, for example, an integer, a
floating point number, a UTF-8 string, or an arbitrary byte string. For
more complex cases, a simple tuple structure such as \[item1, item2,
item3\] could be used. Since CBOR is closely linked to JSON, it is also
rather easy to define an objective whose value is a JSON structure. The
formats acceptable by the GRASP API will limit the options in practice.
A generic solution is for the API to accept and deliver the value field
in raw CBOR, with the ASA itself encoding and decoding it via a CBOR
library ([Section
2.3.2.4](https://www.rfc-editor.org/rfc/rfc8991#section-2.3.2.4){.relref}
of \[[RFC8991](#RFC8991){.xref}\]).[¶](#section-6-4){.pilcrow}

The maximum size of the value field of an objective is limited by the
GRASP maximum message size. If the default maximum size specified as
GRASP_DEF_MAX_SIZE by \[[RFC8990](#RFC8990){.xref}\] is not enough, the
specification of the objective must indicate the required maximum
message size for both unicast and multicast
messages.[¶](#section-6-5){.pilcrow}

A mapping from YANG to CBOR is defined by
\[[CBOR-YANG](#I-D.ietf-core-yang-cbor){.xref}\]. Subject to the size
limit defined for GRASP messages, nothing prevents objectives
transporting YANG in this way.[¶](#section-6-6){.pilcrow}

The flexibility of CBOR implies that the value field of many objectives
can be extended in service, to add additional information or alternative
content, especially if JSON-like structures are used. This has
consequences for the robustness of ASAs, as discussed in [Section
9](#robust){.xref}.[¶](#section-6-7){.pilcrow}
:::
:::

::: {#life}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Life Cycle](#name-life-cycle){.section-name .selfRef} {#name-life-cycle}

The ASA life cycle is discussed in
\[[AUTONOMIC-FUNCTION](#I-D.peloso-anima-autonomic-function){.xref}\],
from which the following text was derived. It does not cover all
details, and some of the terms used would require precise definitions in
a given implementation.[¶](#section-7-1){.pilcrow}

In simple cases, autonomic functions could be permanent, in the sense
that ASAs are shipped as part of a product and persist throughout the
product\'s life. However, in complex cases, a more likely situation is
that ASAs need to be installed or updated dynamically because of new
requirements or bugs. This section describes one approach to the
resulting life cycle of individual ASAs. It does not consider wider
issues such as updates of shared libraries.[¶](#section-7-2){.pilcrow}

Because continuity of service is fundamental to autonomic networking,
the process of seamlessly replacing a running instance of an ASA with a
new version needs to be part of the ASA\'s design. The implication of
service continuity on the design of ASAs can be illustrated along the
three main phases of the ASA life cycle, namely installation,
instantiation, and operation.[¶](#section-7-3){.pilcrow}

[]{#name-life-cycle-of-an-autonomic-}

::: {#Fig_LC}
::: {#section-7-4.1 .alignLeft .art-text .artwork}
                      +--------------+
    Undeployed ------>|              |------> Undeployed
                      |  Installed   |
                  +-->|              |---+
         Mandate  |   +--------------+   | Receives a
       is revoked |   +--------------+   |  Mandate
                  +---|              |<--+
                      | Instantiated |
                  +-->|              |---+
              set |   +--------------+   | set
             down |   +--------------+   | up
                  +---|              |<--+
                      |  Operational |
                      |              |
                      +--------------+
:::

[Figure 1](#figure-1){.selfRef}: [Life Cycle of an Autonomic Service
Agent](#name-life-cycle-of-an-autonomic-){.selfRef}
:::

::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Installation Phase](#name-installation-phase){.section-name .selfRef} {#name-installation-phase}

We define \"installation\" to mean that a piece of software is loaded
into a device, along with any necessary libraries, but is not yet
activated.[¶](#section-7.1-1){.pilcrow}

Before being able to instantiate and run ASAs, the operator will first
provision the infrastructure with the sets of ASA software corresponding
to its needs and objectives. Such software must be checked for integrity
and authenticity before installation. The provisioning of the
infrastructure is realized in the installation phase and consists of
installing (or checking the availability of) the pieces of software of
the different ASAs in a set of Installation Hosts within the autonomic
network.[¶](#section-7.1-2){.pilcrow}

There are three properties applicable to the installation of
ASAs:[¶](#section-7.1-3){.pilcrow}

-   [The dynamic installation property allows installing an ASA on
    demand, on any hosts compatible with the
    ASA.[¶](#section-7.1-4.1){.pilcrow}]{#section-7.1-4.1}
-   [The decoupling property allows an ASA on one machine to control
    resources in another machine (known as \"decoupled
    mode\").[¶](#section-7.1-4.2){.pilcrow}]{#section-7.1-4.2}
-   [The multiplicity property allows controlling multiple sets of
    resources from a single
    ASA.[¶](#section-7.1-4.3){.pilcrow}]{#section-7.1-4.3}

These three properties are very important in the context of the
installation phase as their variations condition how the ASA could be
installed on the infrastructure.[¶](#section-7.1-5){.pilcrow}

::: {#section-7.1.1 .section}
#### [7.1.1.](#section-7.1.1){.section-number .selfRef} [Installation Phase Inputs and Outputs](#name-installation-phase-inputs-a){.section-name .selfRef} {#name-installation-phase-inputs-a}

Inputs are:[¶](#section-7.1.1-1){.pilcrow}

-   [\[ASA_type\]: specifies which ASA to
    install.[¶](#section-7.1.1-2.1){.pilcrow}]{#section-7.1.1-2.1}
-   [\[Installation_target_infrastructure\]: specifies the candidate
    installation
    Hosts.[¶](#section-7.1.1-2.2){.pilcrow}]{#section-7.1.1-2.2}
-   [\[ASA_placement_function\]: specifies how the installation phase
    will meet the operator\'s needs and objectives for the provision of
    the infrastructure. This function is only useful in the decoupled
    mode. It can be as simple as an explicit list of hosts on which the
    ASAs are to be installed, or it could consist of operator-defined
    criteria and
    constraints.[¶](#section-7.1.1-2.3){.pilcrow}]{#section-7.1.1-2.3}

The main output of the installation phase is a \[List_of_ASAs\]
installed on \[List_of_hosts\]. This output is also useful for the
coordination function where it acts as a static interaction map (see
[Section 8.1](#coordi){.xref}).[¶](#section-7.1.1-3){.pilcrow}

The condition to validate in order to pass to next phase is to ensure
that \[List_of_ASAs\] are correctly installed on \[List_of_hosts\]. A
minimum set of primitives to support the installation of ASAs could be
the following: install (List_of_ASAs,
Installation_target_infrastructure, ASA_placement_function) and
uninstall (List_of_ASAs).[¶](#section-7.1.1-4){.pilcrow}
:::
:::

::: {#Sec_Inst}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Instantiation Phase](#name-instantiation-phase){.section-name .selfRef} {#name-instantiation-phase}

We define \"instantiation\" as the operation of creating a single ASA
instance from the corresponding piece of installed
software.[¶](#section-7.2-1){.pilcrow}

Once the ASAs are installed on the appropriate hosts in the network,
these ASAs may start to operate. From the operator viewpoint, an
operating ASA means the ASA manages the network resources as per the
objectives given. At the ASA local level, operating means executing
their control loop algorithm.[¶](#section-7.2-2){.pilcrow}

There are two aspects to take into consideration. First, having a piece
of code installed and available to run on a host is not the same as
having an agent based on this piece of code running inside the host.
Second, in a coupled case, determining which resources are controlled by
an ASA is straightforward (the ASA runs on the same autonomic node as
the resources it is controlling). In a decoupled mode, determining this
is a bit more complex: a starting agent will have to either discover the
set of resources it ought to control, or such information has to be
communicated to the ASA.[¶](#section-7.2-3){.pilcrow}

The instantiation phase of an ASA covers both these aspects: starting
the agent code (when this does not start automatically) and determining
which resources have to be controlled (when this is not
straightforward).[¶](#section-7.2-4){.pilcrow}

::: {#Sec_Inst_Goal}
::: {#section-7.2.1 .section}
#### [7.2.1.](#section-7.2.1){.section-number .selfRef} [Operator\'s Goal](#name-operators-goal){.section-name .selfRef} {#name-operators-goal}

Through this phase, the operator wants to control its autonomic network
regarding at least two aspects:[¶](#section-7.2.1-1){.pilcrow}

1.  [determine the scope of autonomic functions by instructing which
    network resources have to be managed by which autonomic function
    (and more precisely by which release of the ASA software code, e.g.,
    version number or
    provider).[¶](#section-7.2.1-2.1){.pilcrow}]{#section-7.2.1-2.1}
2.  [determine how the autonomic functions are organized by
    instantiating a set of ASAs across one or more autonomic nodes and
    instructing them accordingly about the other ASAs in the set as
    necessary.[¶](#section-7.2.1-2.2){.pilcrow}]{#section-7.2.1-2.2}

In this phase, the operator may also want to set goals for autonomic
functions, e.g., by configuring GRASP
objectives.[¶](#section-7.2.1-3){.pilcrow}

The operator\'s goal can be summarized in an instruction to the
autonomic ecosystem matching the following format, explained in detail
in the next sub-section:[¶](#section-7.2.1-4){.pilcrow}

\[Instances_of_ASA_type\] ready to control
\[Instantiation_target_infrastructure\] with
\[Instantiation_target_parameters\][¶](#section-7.2.1-5){.pilcrow}
:::
:::

::: {#Sec_Inst_InOut}
::: {#section-7.2.2 .section}
#### [7.2.2.](#section-7.2.2){.section-number .selfRef} [Instantiation Phase Inputs and Outputs](#name-instantiation-phase-inputs-){.section-name .selfRef} {#name-instantiation-phase-inputs-}

Inputs are:[¶](#section-7.2.2-1){.pilcrow}

-   [\[Instances_of_ASA_type\]: specifies which ASAs to
    instantiate[¶](#section-7.2.2-2.1){.pilcrow}]{#section-7.2.2-2.1}
-   [\[Instantiation_target_infrastructure\]: specifies which resources
    are to be managed by the autonomic function; this can be the whole
    network or a subset of it like a domain, a physical segment, or even
    a specific list of
    resources.[¶](#section-7.2.2-2.2){.pilcrow}]{#section-7.2.2-2.2}
-   [\[Instantiation_target_parameters\]: specifies which GRASP
    objectives are to be sent to ASAs (e.g., an optimization
    target)[¶](#section-7.2.2-2.3){.pilcrow}]{#section-7.2.2-2.3}

Outputs are:[¶](#section-7.2.2-3){.pilcrow}

-   [\[Set_of_ASA_resources_relations\]: describes which resources are
    managed by which ASA instances; this is not a formal message but a
    resulting configuration log for a set of
    ASAs.[¶](#section-7.2.2-4.1){.pilcrow}]{#section-7.2.2-4.1}
:::
:::

::: {#Sec_Inst_Reqs}
::: {#section-7.2.3 .section}
#### [7.2.3.](#section-7.2.3){.section-number .selfRef} [Instantiation Phase Requirements](#name-instantiation-phase-require){.section-name .selfRef} {#name-instantiation-phase-require}

The instructions described in [Section 7.2](#Sec_Inst){.xref} could be
either of the following:[¶](#section-7.2.3-1){.pilcrow}

-   [Sent to a targeted ASA. In this case, the receiving Agent will have
    to manage the specified list of
    \[Instantiation_target_infrastructure\], with the
    \[Instantiation_target_parameters\].[¶](#section-7.2.3-2.1){.pilcrow}]{#section-7.2.3-2.1}
-   [Broadcast to all ASAs. In this case, the ASAs would determine from
    the list which ASAs would handle which
    \[Instantiation_target_infrastructure\], with the
    \[Instantiation_target_parameters\].[¶](#section-7.2.3-2.2){.pilcrow}]{#section-7.2.3-2.2}

These instructions may be grouped as a specific data structure referred
to as an ASA Instance Mandate. The specification of such an ASA Instance
Mandate is beyond the scope of this
document.[¶](#section-7.2.3-3){.pilcrow}

The conclusion of this instantiation phase is a set of ASA instances
ready to operate. These ASA instances are characterized by the resources
they manage, the metrics being monitored, and the actions that can be
executed (like modifying certain parameter values). The description of
the ASA instance may be defined in an ASA Instance Manifest data
structure. The specification of such an ASA Instance Manifest is beyond
the scope of this document.[¶](#section-7.2.3-4){.pilcrow}

The ASA Instance Manifest does not only serve informational purposes
such as acknowledgement of successful instantiation to the operator but
is also necessary for further autonomic operations
with:[¶](#section-7.2.3-5){.pilcrow}

-   [coordinated entities (see [Section
    8.1](#coordi){.xref})[¶](#section-7.2.3-6.1){.pilcrow}]{#section-7.2.3-6.1}
-   [collaborative entities with purposes such as to establish knowledge
    exchange (some ASAs may produce knowledge or monitor metrics that
    would be useful for other
    ASAs)[¶](#section-7.2.3-6.2){.pilcrow}]{#section-7.2.3-6.2}
:::
:::
:::
:::

::: {#Sec_Operation}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Operation Phase](#name-operation-phase){.section-name .selfRef} {#name-operation-phase}

During the operation phase, the operator
can:[¶](#section-7.3-1){.pilcrow}

-   [activate/deactivate ASAs: enable/disable their autonomic
    loops[¶](#section-7.3-2.1){.pilcrow}]{#section-7.3-2.1}
-   [modify ASA targets: set different technical
    objectives[¶](#section-7.3-2.2){.pilcrow}]{#section-7.3-2.2}
-   [modify ASAs managed resources: update the Instance Mandate to
    specify a different set of resources to manage (only applicable to
    decoupled ASAs)[¶](#section-7.3-2.3){.pilcrow}]{#section-7.3-2.3}

During the operation phase, running ASAs can interact with other
ASAs:[¶](#section-7.3-3){.pilcrow}

-   [in order to exchange knowledge (e.g., an ASA providing traffic
    predictions to a load balancing
    ASA)[¶](#section-7.3-4.1){.pilcrow}]{#section-7.3-4.1}
-   [in order to collaboratively reach an objective (e.g., ASAs
    pertaining to the same autonomic function will collaborate, e.g., in
    the case of a load balancing function, by modifying link metrics
    according to neighboring resource
    loads)[¶](#section-7.3-4.2){.pilcrow}]{#section-7.3-4.2}

During the operation phase, running ASAs are expected to apply
coordination schemes as per [Section
8.1](#coordi){.xref}.[¶](#section-7.3-5){.pilcrow}
:::
:::

::: {#Sec_Removal}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [Removal Phase](#name-removal-phase){.section-name .selfRef} {#name-removal-phase}

When an ASA is removed from service and uninstalled, the above steps are
reversed. It is important that its data, especially any security key
material, is purged.[¶](#section-7.4-1){.pilcrow}
:::
:::
:::
:::

::: {#coordm}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Coordination and Data Models](#name-coordination-and-data-model){.section-name .selfRef} {#name-coordination-and-data-model}

::: {#coordi}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Coordination between Autonomic Functions](#name-coordination-between-autono){.section-name .selfRef} {#name-coordination-between-autono}

Some autonomic functions will be completely independent of each other.
However, others are at risk of interfering with each other; for example,
two different optimization functions might both attempt to modify the
same underlying parameter in different ways. In a complete system, a
method is needed for identifying ASAs that might interfere with each
other and coordinating their actions when
necessary.[¶](#section-8.1-1){.pilcrow}
:::
:::

::: {#coordt}
::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Coordination with Traditional Management Functions](#name-coordination-with-tradition){.section-name .selfRef} {#name-coordination-with-tradition}

Some ASAs will have functions that overlap with existing configuration
tools and network management mechanisms such as command-line interfaces,
DHCP, DHCPv6, SNMP, NETCONF, and RESTCONF. This is, of course, an
existing problem whenever multiple configuration tools are in use by the
NOC. Each ASA designer will need to consider this issue and how to avoid
clashes and inconsistencies in various deployment scenarios. Some
specific considerations for interaction with OAM tools are given in
\[[RFC8368](#RFC8368){.xref}\]. As another example,
\[[RFC8992](#RFC8992){.xref}\] describes how autonomic management of
IPv6 prefixes can interact with prefix delegation via DHCPv6. The
description of a GRASP objective and of an ASA using it should include a
discussion of any such interactions.[¶](#section-8.2-1){.pilcrow}
:::
:::

::: {#datam}
::: {#section-8.3 .section}
### [8.3.](#section-8.3){.section-number .selfRef} [Data Models](#name-data-models){.section-name .selfRef} {#name-data-models}

Management functions often include a shared data model, quite likely to
be expressed in a formal notation such as YANG. This aspect should not
be an afterthought in the design of an ASA. To the contrary, the design
of the ASA and of its GRASP objectives should match the data model; as
noted in [Section 6](#objdes){.xref}, YANG serialized as CBOR may be
used directly as the value of a GRASP
objective.[¶](#section-8.3-1){.pilcrow}
:::
:::
:::
:::

::: {#robust}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Robustness](#name-robustness){.section-name .selfRef} {#name-robustness}

It is of great importance that all components of an autonomic system are
highly robust. Although ASA designers should aim for their component to
never fail, it is more important to design the ASA to assume that
failures will happen and to gracefully recover from those failures when
they occur. Hence, this section lists various aspects of robustness that
ASA designers should consider:[¶](#section-9-1){.pilcrow}

1.  [If despite all precautions, an ASA does encounter a fatal error, it
    should in any case restart automatically and try again. To mitigate
    a loop in case of persistent failure, a suitable pause should be
    inserted before such a restart. The length of the pause depends on
    the use case; randomization and exponential backoff should be
    considered.[¶](#section-9-2.1){.pilcrow}]{#section-9-2.1}
2.  [If a newly received or calculated value for a parameter falls out
    of bounds, the corresponding parameter should be either left
    unchanged or restored to a value known to be safe in all
    configurations.[¶](#section-9-2.2){.pilcrow}]{#section-9-2.2}
3.  [If a GRASP synchronization or negotiation session fails for any
    reason, it may be repeated after a suitable pause. The length of the
    pause depends on the use case; randomization and exponential backoff
    should be considered.[¶](#section-9-2.3){.pilcrow}]{#section-9-2.3}
4.  [If a session fails repeatedly, the ASA should consider that its
    peer has failed, and it should cause GRASP to flush its discovery
    cache and repeat peer
    discovery.[¶](#section-9-2.4){.pilcrow}]{#section-9-2.4}
5.  [In any case, it may be prudent to repeat discovery periodically,
    depending on the use
    case.[¶](#section-9-2.5){.pilcrow}]{#section-9-2.5}
6.  [Any received GRASP message should be checked. If it is wrongly
    formatted, it should be ignored. Within a unicast session, an
    Invalid message (M_INVALID) may be sent. This function may be
    provided by the GRASP implementation
    itself.[¶](#section-9-2.6){.pilcrow}]{#section-9-2.6}
7.  [Any received GRASP objective should be checked. Basic formatting
    errors like invalid CBOR will likely be detected by GRASP itself,
    but the ASA is responsible for checking the precise syntax and
    semantics of a received objective. If it is wrongly formatted, it
    should be ignored. Within a negotiation session, a Negotiation End
    message (M_END) with a Decline option (O_DECLINE) should be sent. An
    ASA may log such events for diagnostic
    purposes.[¶](#section-9-2.7){.pilcrow}]{#section-9-2.7}
8.  [On the other hand, the definitions of GRASP objectives are very
    likely to be extended, using the flexibility of CBOR or JSON.
    Therefore, ASAs should be able to deal gracefully with unknown
    components within the values of objectives. The specification of an
    objective should describe how unknown components are to be handled
    (ignored, logged and ignored, or rejected as an
    error).[¶](#section-9-2.8){.pilcrow}]{#section-9-2.8}
9.  [If an ASA receives either an Invalid message (M_INVALID) or a
    Negotiation End message (M_END) with a Decline option (O_DECLINE),
    one possible reason is that the peer ASA does not support a new
    feature of either GRASP or the objective in question. In such a
    case, the ASA may choose to repeat the operation concerned without
    using that new
    feature.[¶](#section-9-2.9){.pilcrow}]{#section-9-2.9}
10. [All other possible exceptions should be handled in an orderly way.
    There should be no such thing as an unhandled exception (but see
    point 1 above).[¶](#section-9-2.10){.pilcrow}]{#section-9-2.10}

At a slightly more general level, ASAs are not services in themselves,
but they automate services. This has a fundamental impact on how to
design robust ASAs. In general, when an ASA observes a particular state
(1) of operations of the services/resources it controls, it typically
aims to improve this state to a better state, say (2). Ideally, the ASA
is built so that it can ensure that any error encountered can still lead
to returning to (1) instead of a state (3), which is worse than (1). One
example instance of this principle is \"make-before-break\" used in
reconfiguration of routing protocols in manual operations. This
principle of operations can accordingly be coded into the operation of
an ASA. The GRASP dry run option mentioned in [Section
6](#objdes){.xref} is another tool helpful for this ASA design goal of
\"test-before-make\".[¶](#section-9-3){.pilcrow}
:::
:::

::: {#security}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

ASAs are intended to run in an environment that is protected by the
Autonomic Control Plane \[[RFC8994](#RFC8994){.xref}\], admission to
which depends on an initial secure bootstrap process such as BRSKI
\[[RFC8995](#RFC8995){.xref}\]. Those documents describe security
considerations relating to the use of and properties provided by the ACP
and BRSKI, respectively. Such an ACP can provide keying material for
mutual authentication between ASAs as well as confidential communication
channels for messages between ASAs. In some deployments, a secure
partition of the link layer might be used instead. GRASP itself has
significant security considerations \[[RFC8990](#RFC8990){.xref}\].
However, this does not relieve ASAs of responsibility for security. When
ASAs configure or manage network elements outside the ACP, potentially
in a different physical node, they must interact with other
non-autonomic software components to perform their management functions.
The details are specific to each case, but this has an important
security implication. An ASA might act as a loophole by which the
managed entity could penetrate the security boundary of the ANI. Thus,
ASAs must be designed to avoid loopholes such as passing on executable
code or proxying unverified commands and should, if possible, operate in
an unprivileged mode. In particular, they must use secure coding
practices, e.g., carefully validate all incoming information and avoid
unnecessary elevation of privilege. This will apply in particular when
an ASA interacts with a management component such as a NETCONF
server.[¶](#section-10-1){.pilcrow}

A similar situation will arise if an ASA acts as a gateway between two
separate autonomic networks, i.e., it has access to two separate ACPs.
Such an ASA must also be designed to avoid loopholes and to validate
incoming information from both sides.[¶](#section-10-2){.pilcrow}

As a reminder, GRASP does not intrinsically provide transactional
integrity ([Section 6](#objdes){.xref}).[¶](#section-10-3){.pilcrow}

As appropriate to their specific functions, ASAs should take account of
relevant privacy considerations
\[[RFC6973](#RFC6973){.xref}\].[¶](#section-10-4){.pilcrow}

The initial version of the autonomic infrastructure assumes that all
autonomic nodes are trusted by virtue of their admission to the ACP.
ASAs are therefore trusted to manipulate any GRASP objective simply
because they are installed on a node that has successfully joined the
ACP. In the general case, a node may have multiple roles, and a role may
use multiple ASAs, each using multiple GRASP objectives. Additional
mechanisms for the fine-grained authorization of nodes and ASAs to
manipulate specific GRASP objectives could be designed. Meanwhile, we
repeat that ASAs should run without special privilege if possible.
Independently of this, interfaces between ASAs and the router
configuration and monitoring services of the node can be subject to
authentication that provides more fine-grained authorization for
specific services. These additional authentication parameters could be
passed to an ASA during its instantiation
phase.[¶](#section-10-5){.pilcrow}
:::
:::

::: {#iana}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-11-1){.pilcrow}
:::
:::

::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-12.1 .section}
### [12.1.](#section-12.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC8949\]
:   [Bormann, C.]{.refAuthor} and [P. Hoffman]{.refAuthor}, [\"Concise
    Binary Object Representation (CBOR)\"]{.refTitle}, [STD
    94]{.seriesInfo}, [RFC 8949]{.seriesInfo}, [DOI
    10.17487/RFC8949]{.seriesInfo}, December 2020,
    \<<https://www.rfc-editor.org/info/rfc8949>\>.
:   

\[RFC8990\]
:   [Bormann, C.]{.refAuthor}, [Carpenter, B., Ed.]{.refAuthor}, and [B.
    Liu, Ed.]{.refAuthor}, [\"GeneRic Autonomic Signaling Protocol
    (GRASP)\"]{.refTitle}, [RFC 8990]{.seriesInfo}, [DOI
    10.17487/RFC8990]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc8990>\>.
:   

\[RFC8994\]
:   [Eckert, T., Ed.]{.refAuthor}, [Behringer, M., Ed.]{.refAuthor}, and
    [S. Bjarnason]{.refAuthor}, [\"An Autonomic Control Plane
    (ACP)\"]{.refTitle}, [RFC 8994]{.seriesInfo}, [DOI
    10.17487/RFC8994]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc8994>\>.
:   

\[RFC8995\]
:   [Pritikin, M.]{.refAuthor}, [Richardson, M.]{.refAuthor},
    [Eckert, T.]{.refAuthor}, [Behringer, M.]{.refAuthor}, and [K.
    Watsen]{.refAuthor}, [\"Bootstrapping Remote Secure Key
    Infrastructure (BRSKI)\"]{.refTitle}, [RFC 8995]{.seriesInfo}, [DOI
    10.17487/RFC8995]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc8995>\>.
:   
:::

::: {#section-12.2 .section}
### [12.2.](#section-12.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[AUTONOMIC-FUNCTION\]
:   [Pierre, P.]{.refAuthor} and [L. Ciavaglia]{.refAuthor}, [\"A Day in
    the Life of an Autonomic Function\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-peloso-anima-autonomic-function-01]{.seriesInfo}, 21 March
    2016,
    \<<https://datatracker.ietf.org/doc/html/draft-peloso-anima-autonomic-function-01>\>.
:   

\[CBOR-YANG\]
:   [Veillette, M., Ed.]{.refAuthor}, [Petrov, I., Ed.]{.refAuthor},
    [Pelov, A.]{.refAuthor}, [Bormann, C.]{.refAuthor}, and [M.
    Richardson]{.refAuthor}, [\"CBOR Encoding of Data Modeled with
    YANG\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-core-yang-cbor-18]{.seriesInfo},
    December 2021,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-core-yang-cbor-18>\>.
:   

\[DEMOLA06\]
:   [De Mola, F.]{.refAuthor} and [R. Quitadamo]{.refAuthor}, [\"Towards
    an Agent Model for Future Autonomic Communications\"]{.refTitle},
    [Proceedings of the 7th WOA 2006 Workshop From Objects to Agents
    51-59]{.seriesInfo}, September 2006.
:   

\[GANA13\]
:   [ETSI]{.refAuthor}, [\"Autonomic network engineering for the
    self-managing Future Internet (AFI); Generic Autonomic Network
    Architecture (An Architectural Reference Model for Autonomic
    Networking, Cognitive Networking and Self-Management)\"]{.refTitle},
    [GS AFI 002]{.refContent}, [V1.1.1]{.refContent}, April 2013,
    \<<https://www.etsi.org/deliver/etsi_gs/AFI/001_099/002/01.01.01_60/gs_afi002v010101p.pdf>\>.
:   

\[HUEBSCHER08\]
:   [Huebscher, M. C.]{.refAuthor} and [J. A. McCann]{.refAuthor}, [\"A
    survey of autonomic computing - degrees, models, and
    applications\"]{.refTitle}, [ACM Computing Surveys
    (CSUR)]{.refContent}, [Volume 40, Issue 3]{.refContent}, [DOI
    10.1145/1380584.1380585]{.seriesInfo}, August 2008,
    \<<https://doi.org/10.1145/1380584.1380585>\>.
:   

\[IBN-CONCEPTS\]
:   [Clemm, A.]{.refAuthor}, [Ciavaglia, L.]{.refAuthor}, [Granville, L.
    Z.]{.refAuthor}, and [J. Tantsura]{.refAuthor}, [\"Intent-Based
    Networking - Concepts and Definitions\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-irtf-nmrg-ibn-concepts-definitions-09]{.seriesInfo}, 24 March
    2022,
    \<<https://datatracker.ietf.org/doc/html/draft-irtf-nmrg-ibn-concepts-definitions-09>\>.
:   

\[IPJ\]
:   [Behringer, M.]{.refAuthor}, [Bormann, C.]{.refAuthor},
    [Carpenter, B. E.]{.refAuthor}, [Eckert, T.]{.refAuthor}, [Campos
    Nobre, J.]{.refAuthor}, [Jiang, S.]{.refAuthor},
    [Li, Y.]{.refAuthor}, and [M. C. Richardson]{.refAuthor},
    [\"Autonomic Networking Gets Serious\"]{.refTitle}, [The Internet
    Protocol Journal]{.refContent}, [Volume 24, Issue 3, Page(s) 2 -
    18]{.refContent}, [ISSN 1944-1134]{.refContent}, October 2021,
    \<<https://ipj.dreamhosters.com/wp-content/uploads/2021/10/243-ipj.pdf>\>.
:   

\[MOVAHEDI12\]
:   [Movahedi, Z.]{.refAuthor}, [Ayari, M.]{.refAuthor},
    [Langar, R.]{.refAuthor}, and [G. Pujolle]{.refAuthor}, [\"A Survey
    of Autonomic Network Architectures and Evaluation
    Criteria\"]{.refTitle}, [IEEE Communications Surveys &
    Tutorials]{.refContent}, [Volume 14, Issue 2, Pages 464 -
    490]{.refContent}, [DOI
    10.1109/SURV.2011.042711.00078]{.seriesInfo}, 2012,
    \<<https://doi.org/10.1109/SURV.2011.042711.00078>\>.
:   

\[NFV\]
:   [ETSI]{.refAuthor}, [\"Network Functions
    Virtualisation\"]{.refTitle}, [SDN and OpenFlow World
    Congress]{.refContent}, October 2012,
    \<<https://portal.etsi.org/NFV/NFV_White_Paper.pdf>\>.
:   

\[RFC6241\]
:   [Enns, R., Ed.]{.refAuthor}, [Bjorklund, M., Ed.]{.refAuthor},
    [Schoenwaelder, J., Ed.]{.refAuthor}, and [A. Bierman,
    Ed.]{.refAuthor}, [\"Network Configuration Protocol
    (NETCONF)\"]{.refTitle}, [RFC 6241]{.seriesInfo}, [DOI
    10.17487/RFC6241]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6241>\>.
:   

\[RFC6973\]
:   [Cooper, A.]{.refAuthor}, [Tschofenig, H.]{.refAuthor},
    [Aboba, B.]{.refAuthor}, [Peterson, J.]{.refAuthor},
    [Morris, J.]{.refAuthor}, [Hansen, M.]{.refAuthor}, and [R.
    Smith]{.refAuthor}, [\"Privacy Considerations for Internet
    Protocols\"]{.refTitle}, [RFC 6973]{.seriesInfo}, [DOI
    10.17487/RFC6973]{.seriesInfo}, July 2013,
    \<<https://www.rfc-editor.org/info/rfc6973>\>.
:   

\[RFC7575\]
:   [Behringer, M.]{.refAuthor}, [Pritikin, M.]{.refAuthor},
    [Bjarnason, S.]{.refAuthor}, [Clemm, A.]{.refAuthor},
    [Carpenter, B.]{.refAuthor}, [Jiang, S.]{.refAuthor}, and [L.
    Ciavaglia]{.refAuthor}, [\"Autonomic Networking: Definitions and
    Design Goals\"]{.refTitle}, [RFC 7575]{.seriesInfo}, [DOI
    10.17487/RFC7575]{.seriesInfo}, June 2015,
    \<<https://www.rfc-editor.org/info/rfc7575>\>.
:   

\[RFC7665\]
:   [Halpern, J., Ed.]{.refAuthor} and [C. Pignataro, Ed.]{.refAuthor},
    [\"Service Function Chaining (SFC) Architecture\"]{.refTitle}, [RFC
    7665]{.seriesInfo}, [DOI 10.17487/RFC7665]{.seriesInfo}, October
    2015, \<<https://www.rfc-editor.org/info/rfc7665>\>.
:   

\[RFC8368\]
:   [Eckert, T., Ed.]{.refAuthor} and [M. Behringer]{.refAuthor},
    [\"Using an Autonomic Control Plane for Stable Connectivity of
    Network Operations, Administration, and Maintenance
    (OAM)\"]{.refTitle}, [RFC 8368]{.seriesInfo}, [DOI
    10.17487/RFC8368]{.seriesInfo}, May 2018,
    \<<https://www.rfc-editor.org/info/rfc8368>\>.
:   

\[RFC8991\]
:   [Carpenter, B.]{.refAuthor}, [Liu, B., Ed.]{.refAuthor},
    [Wang, W.]{.refAuthor}, and [X. Gong]{.refAuthor}, [\"GeneRic
    Autonomic Signaling Protocol Application Program Interface (GRASP
    API)\"]{.refTitle}, [RFC 8991]{.seriesInfo}, [DOI
    10.17487/RFC8991]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc8991>\>.
:   

\[RFC8992\]
:   [Jiang, S., Ed.]{.refAuthor}, [Du, Z.]{.refAuthor},
    [Carpenter, B.]{.refAuthor}, and [Q. Sun]{.refAuthor}, [\"Autonomic
    IPv6 Edge Prefix Management in Large-Scale Networks\"]{.refTitle},
    [RFC 8992]{.seriesInfo}, [DOI 10.17487/RFC8992]{.seriesInfo}, May
    2021, \<<https://www.rfc-editor.org/info/rfc8992>\>.
:   

\[RFC8993\]
:   [Behringer, M., Ed.]{.refAuthor}, [Carpenter, B.]{.refAuthor},
    [Eckert, T.]{.refAuthor}, [Ciavaglia, L.]{.refAuthor}, and [J.
    Nobre]{.refAuthor}, [\"A Reference Model for Autonomic
    Networking\"]{.refTitle}, [RFC 8993]{.seriesInfo}, [DOI
    10.17487/RFC8993]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc8993>\>.
:   

\[ZSM009-1\]
:   [ETSI]{.refAuthor}, [\"Zero-touch network and Service Management
    (ZSM); Closed-Loop Automation; Part 1: Enablers\"]{.refTitle}, [GS
    ZSM 009-1]{.refContent}, [Version 1.1.1]{.refContent}, June 2021,
    \<<https://www.etsi.org/deliver/etsi_gs/ZSM/001_099/00901/01.01.01_60/gs_ZSM00901v010101p.pdf>\>.
:   
:::
:::

::: {#eg}
::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [Example Logic Flows](#name-example-logic-flows){.section-name .selfRef} {#name-example-logic-flows}

This appendix describes generic logic flows that combine to act as an
Autonomic Service Agent (ASA) for resource management. Note that these
are illustrative examples and are in no sense requirements. As long as
the rules of GRASP are followed, a real implementation could be
different. The reader is assumed to be familiar with GRASP
\[[RFC8990](#RFC8990){.xref}\] and its conceptual API
\[[RFC8991](#RFC8991){.xref}\].[¶](#appendix-A-1){.pilcrow}

A complete autonomic function for a distributed resource will consist of
a number of instances of the ASA placed at relevant points in a network.
Specific details will, of course, depend on the resource concerned. One
example is IP address prefix management, as specified in
\[[RFC8992](#RFC8992){.xref}\]. In this case, an instance of the ASA
will exist in each delegating router.[¶](#appendix-A-2){.pilcrow}

An underlying assumption is that there is an initial source of the
resource in question, referred to here as an origin ASA. The other ASAs,
known as delegators, obtain supplies of the resource from the origin,
delegate quantities of the resource to consumers that request it, and
recover it when no longer needed.[¶](#appendix-A-3){.pilcrow}

Another assumption is there is a set of network-wide policy parameters,
which the origin will provide to the delegators. These parameters will
control how the delegators decide how much resource to provide to
consumers. Thus, the ASA logic has two operating modes: origin and
delegator. When running as an origin, it starts by obtaining a quantity
of the resource from the NOC, and it acts as a source of policy
parameters, via both GRASP flooding and GRASP synchronization. (In some
scenarios, flooding or synchronization alone might be sufficient, but
this example includes both.)[¶](#appendix-A-4){.pilcrow}

When running as a delegator, it starts with an empty resource pool,
acquires the policy parameters by GRASP synchronization, and delegates
quantities of the resource to consumers that request it. Both as an
origin and as a delegator, when its pool is low, it seeks quantities of
the resource by requesting GRASP negotiation with peer ASAs. When its
pool is sufficient, it hands out resource to peer ASAs in response to
negotiation requests. Thus, over time, the initial resource pool held by
the origin will be shared among all the delegators according to
demand.[¶](#appendix-A-5){.pilcrow}

In theory, a network could include any number of origins and any number
of delegators, with the only condition being that each origin\'s initial
resource pool is unique. A realistic scenario is to have exactly one
origin and as many delegators as you like. A scenario with no origin is
useless.[¶](#appendix-A-6){.pilcrow}

An implementation requirement is that resource pools are kept in stable
storage. Otherwise, if a delegator exits for any reason, all the
resources it has obtained or delegated are lost. If an origin exits, its
entire spare pool is lost. The logic for using stable storage and for
crash recovery is not included in the pseudocode below, which focuses on
communication between ASAs. Since GRASP operations are not intrinsically
idempotent, data integrity during failure scenarios is the
responsibility of the ASA designer. This is a complex topic in its own
right that is not discussed in the present
document.[¶](#appendix-A-7){.pilcrow}

The description below does not implement GRASP\'s dry run function. That
would require temporarily marking any resource handed out in a dry run
negotiation as reserved, until either the peer obtains it in a live run,
or a suitable timeout occurs.[¶](#appendix-A-8){.pilcrow}

The main data structures used in each instance of the ASA
are:[¶](#appendix-A-9){.pilcrow}

-   [resource_pool: an ordered list of available resources, for example.
    Depending on the nature of the resource, units of resource are split
    when appropriate, and a background garbage collector recombines
    split resources if they are returned to the
    pool.[¶](#appendix-A-10.1){.pilcrow}]{#appendix-A-10.1}
-   [delegated_list: where a delegator stores the resources it has given
    to subsidiary
    devices.[¶](#appendix-A-10.2){.pilcrow}]{#appendix-A-10.2}

Possible main logic flows are below, using a threaded implementation
model. As noted above, alternative approaches to asynchronous operations
are possible. The transformation to an event loop model should be
apparent; each thread would correspond to one event in the event
loop.[¶](#appendix-A-11){.pilcrow}

The GRASP objectives are as follows:[¶](#appendix-A-12){.pilcrow}

-   [\[\"EX1.Resource\", flags, loop_count, value\], where the value
    depends on the resource concerned but will typically include its
    size and
    identification.[¶](#appendix-A-13.1){.pilcrow}]{#appendix-A-13.1}
-   [\[\"EX1.Params\", flags, loop_count, value\], where the value will
    be, for example, a JSON object defining the applicable
    parameters.[¶](#appendix-A-13.2){.pilcrow}]{#appendix-A-13.2}

In the outline logic flows below, these objectives are represented
simply by their names.[¶](#appendix-A-14){.pilcrow}

::: {#appendix-A-15}
``` {.lang-pseudocode .sourcecode}
MAIN PROGRAM:

Create empty resource_pool (and an associated lock)
Create empty delegated_list
Determine whether to act as origin
if origin:
    Obtain initial resource_pool contents from NOC
    Obtain value of EX1.Params from NOC
Register ASA with GRASP
Register GRASP objectives EX1.Resource and EX1.Params
if origin:
    Start FLOODER thread to flood EX1.Params
    Start SYNCHRONIZER listener for EX1.Params
Start MAIN_NEGOTIATOR thread for EX1.Resource
if not origin:
    Obtain value of EX1.Params from GRASP flood or synchronization
    Start DELEGATOR thread
Start GARBAGE_COLLECTOR thread
good_peer = none
do forever:
    if resource_pool is low:
        Calculate amount A of resource needed
        Discover peers using GRASP M_DISCOVER / M_RESPONSE
        if good_peer in peers:
            peer = good_peer
        else:
            peer =  #any choice among peers
        grasp.request_negotiate("EX1.Resource", peer)
        #i.e., send negotiation request
        Wait for response (M_NEGOTIATE, M_END or M_WAIT)
        if OK:
            if offered amount of resource sufficient:
                Send M_END + O_ACCEPT #negotiation succeeded
                Add resource to pool
                good_peer = peer      #remember this choice
            else:
                Send M_END + O_DECLINE #negotiation failed
                good_peer = none       #forget this choice
    sleep() #periodic timer suitable for application scenario
```

[¶](#appendix-A-15){.pilcrow}
:::

::: {#appendix-A-16}
``` {.lang-pseudocode .sourcecode}
MAIN_NEGOTIATOR thread:

do forever:
    grasp.listen_negotiate("EX1.Resource")
    #i.e., wait for negotiation request
    Start a separate new NEGOTIATOR thread for requested amount A
```

[¶](#appendix-A-16){.pilcrow}
:::

::: {#appendix-A-17}
``` {.lang-pseudocode .sourcecode}
NEGOTIATOR thread:

Request resource amount A from resource_pool
if not OK:
    while not OK and A > Amin:
        A = A-1
        Request resource amount A from resource_pool
if OK:
    Offer resource amount A to peer by GRASP M_NEGOTIATE
    if received M_END + O_ACCEPT:
        #negotiation succeeded
    elif received M_END + O_DECLINE or other error:
        #negotiation failed
        Return resource to resource_pool
else:
    Send M_END + O_DECLINE #negotiation failed
#thread exits
```

[¶](#appendix-A-17){.pilcrow}
:::

::: {#appendix-A-18}
``` {.lang-pseudocode .sourcecode}
DELEGATOR thread:

do forever:
    Wait for request or release for resource amount A
    if request:
        Get resource amount A from resource_pool
        if OK:
            Delegate resource to consumer #atomic
            Record in delegated_list      #operation
        else:
            Signal failure to consumer
            Signal main thread that resource_pool is low
    else:
        Delete resource from delegated_list
        Return resource amount A to resource_pool
```

[¶](#appendix-A-18){.pilcrow}
:::

::: {#appendix-A-19}
``` {.lang-pseudocode .sourcecode}
SYNCHRONIZER thread:

do forever:
    Wait for  M_REQ_SYN message for EX1.Params
    Reply with M_SYNCH message for EX1.Params
```

[¶](#appendix-A-19){.pilcrow}
:::

::: {#appendix-A-20}
``` {.lang-pseudocode .sourcecode}
FLOODER thread:

do forever:
    Send M_FLOOD message for EX1.Params
    sleep() #periodic timer suitable for application scenario
```

[¶](#appendix-A-20){.pilcrow}
:::

::: {#appendix-A-21}
``` {.lang-pseudocode .sourcecode}
GARBAGE_COLLECTOR thread:

do forever:
    Search resource_pool for adjacent resources
    Merge adjacent resources
    sleep() #periodic timer suitable for application scenario
```

[¶](#appendix-A-21){.pilcrow}
:::
:::
:::

::: {#ack}
::: {#appendix-B .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

Valuable comments were received from [Michael Behringer]{.contact-name},
[Menachem Dodge]{.contact-name}, [Martin Dürst]{.contact-name},
[Toerless Eckert]{.contact-name}, [Thomas Fossati]{.contact-name}, [Alex
Galis]{.contact-name}, [Bing Liu]{.contact-name}, [Benno
Overeinder]{.contact-name}, [Michael Richardson]{.contact-name}, [Rob
Wilton]{.contact-name}, and other IESG
members.[¶](#appendix-B-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-C .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Brian Carpenter]{.fn .nameRole}
:::

::: {.left dir="auto"}
[School of Computer Science\
University of Auckland\
PB 92019]{.street-address}
:::

::: {.left dir="auto"}
[Auckland]{.locality} [1142]{.postal-code}
:::

::: {.left dir="auto"}
[New Zealand]{.country-name}
:::

::: email
Email: <brian.e.carpenter@gmail.com>
:::

::: {.left dir="auto"}
[Laurent Ciavaglia]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Rakuten Mobile]{.org}
:::

::: {.left dir="auto"}
[Paris]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <laurent.ciavaglia@rakuten.com>
:::

::: {.left dir="auto"}
[Sheng Jiang]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Huawei Technologies Co., Ltd]{.org}
:::

::: {.left dir="auto"}
[Q14 Huawei Campus\
156 Beiqing Road\
Hai-Dian District]{.street-address}
:::

::: {.left dir="auto"}
[Beijing]{.locality}
:::

::: {.left dir="auto"}
[100095]{.postal-code}
:::

::: {.left dir="auto"}
[China]{.country-name}
:::

::: email
Email: <jiangsheng@huawei.com>
:::

::: {.left dir="auto"}
[Pierre Peloso]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Nokia]{.org}
:::

::: {.left dir="auto"}
[Villarceaux]{.street-address}
:::

::: {.left dir="auto"}
[91460]{.postal-code} [Nozay]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <pierre.peloso@nokia.com>
:::
:::
:::
