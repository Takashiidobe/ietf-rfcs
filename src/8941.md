  RFC 8941            Structured Field Values for HTTP   February 2021
  ------------------- ---------------------------------- ---------------
  Nottingham & Kamp   Standards Track                    \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8941](https://www.rfc-editor.org/rfc/rfc8941){.eref}

Category:
:   Standards Track

Published:
:   February 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    M. Nottingham
    :::

    ::: org
    Fastly
    :::
    :::

    ::: author
    ::: author-name
    P-H. Kamp
    :::

    ::: org
    The Varnish Cache Project
    :::
    :::
:::

# RFC 8941 {#rfcnum}

# Structured Field Values for HTTP {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes a set of data types and associated algorithms
that are intended to make it easier and safer to define and handle HTTP
header and trailer fields, known as \"Structured Fields\", \"Structured
Headers\", or \"Structured Trailers\". It is intended for use by
specifications of new HTTP fields that wish to use a common syntax that
is more restrictive than traditional HTTP field
values.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8941>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Intentionally Strict
        Processing](#name-intentionally-strict-proces){.xref}[¶](#section-toc.1-1.1.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.1.2.2}
        [1.2](#section-1.2){.xref}.  [Notational
        Conventions](#name-notational-conventions){.xref}[¶](#section-toc.1-1.1.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Defining New Structured
    Fields](#name-defining-new-structured-fie){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Structured Data
    Types](#name-structured-data-types){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Lists](#name-lists){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.3.2.1.2.1}
            [3.1.1](#section-3.1.1){.xref}.  [Inner
            Lists](#name-inner-lists){.xref}[¶](#section-toc.1-1.3.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.1.2.2}
            [3.1.2](#section-3.1.2){.xref}.  [Parameters](#name-parameters){.xref}[¶](#section-toc.1-1.3.2.1.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Dictionaries](#name-dictionaries){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Items](#name-items){.xref}[¶](#section-toc.1-1.3.2.3.1){.pilcrow}

        -   ::: {#section-toc.1-1.3.2.3.2.1}
            [3.3.1](#section-3.3.1){.xref}.  [Integers](#name-integers){.xref}[¶](#section-toc.1-1.3.2.3.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.2}
            [3.3.2](#section-3.3.2){.xref}.  [Decimals](#name-decimals){.xref}[¶](#section-toc.1-1.3.2.3.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.3}
            [3.3.3](#section-3.3.3){.xref}.  [Strings](#name-strings){.xref}[¶](#section-toc.1-1.3.2.3.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.4}
            [3.3.4](#section-3.3.4){.xref}.  [Tokens](#name-tokens){.xref}[¶](#section-toc.1-1.3.2.3.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.5}
            [3.3.5](#section-3.3.5){.xref}.  [Byte
            Sequences](#name-byte-sequences){.xref}[¶](#section-toc.1-1.3.2.3.2.5.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.6}
            [3.3.6](#section-3.3.6){.xref}.  [Booleans](#name-booleans){.xref}[¶](#section-toc.1-1.3.2.3.2.6.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Working with Structured Fields in
    HTTP](#name-working-with-structured-fie){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Serializing Structured
        Fields](#name-serializing-structured-fiel){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.4.2.1.2.1}
            [4.1.1](#section-4.1.1){.xref}.  [Serializing a
            List](#name-serializing-a-list){.xref}[¶](#section-toc.1-1.4.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.2}
            [4.1.2](#section-4.1.2){.xref}.  [Serializing a
            Dictionary](#name-serializing-a-dictionary){.xref}[¶](#section-toc.1-1.4.2.1.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.3}
            [4.1.3](#section-4.1.3){.xref}.  [Serializing an
            Item](#name-serializing-an-item){.xref}[¶](#section-toc.1-1.4.2.1.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.4}
            [4.1.4](#section-4.1.4){.xref}.  [Serializing an
            Integer](#name-serializing-an-integer){.xref}[¶](#section-toc.1-1.4.2.1.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.5}
            [4.1.5](#section-4.1.5){.xref}.  [Serializing a
            Decimal](#name-serializing-a-decimal){.xref}[¶](#section-toc.1-1.4.2.1.2.5.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.6}
            [4.1.6](#section-4.1.6){.xref}.  [Serializing a
            String](#name-serializing-a-string){.xref}[¶](#section-toc.1-1.4.2.1.2.6.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.7}
            [4.1.7](#section-4.1.7){.xref}.  [Serializing a
            Token](#name-serializing-a-token){.xref}[¶](#section-toc.1-1.4.2.1.2.7.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.8}
            [4.1.8](#section-4.1.8){.xref}.  [Serializing a Byte
            Sequence](#name-serializing-a-byte-sequence){.xref}[¶](#section-toc.1-1.4.2.1.2.8.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.9}
            [4.1.9](#section-4.1.9){.xref}.  [Serializing a
            Boolean](#name-serializing-a-boolean){.xref}[¶](#section-toc.1-1.4.2.1.2.9.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Parsing Structured
        Fields](#name-parsing-structured-fields){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.4.2.2.2.1}
            [4.2.1](#section-4.2.1){.xref}.  [Parsing a
            List](#name-parsing-a-list){.xref}[¶](#section-toc.1-1.4.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.2}
            [4.2.2](#section-4.2.2){.xref}.  [Parsing a
            Dictionary](#name-parsing-a-dictionary){.xref}[¶](#section-toc.1-1.4.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.3}
            [4.2.3](#section-4.2.3){.xref}.  [Parsing an
            Item](#name-parsing-an-item){.xref}[¶](#section-toc.1-1.4.2.2.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.4}
            [4.2.4](#section-4.2.4){.xref}.  [Parsing an Integer or
            Decimal](#name-parsing-an-integer-or-decim){.xref}[¶](#section-toc.1-1.4.2.2.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.5}
            [4.2.5](#section-4.2.5){.xref}.  [Parsing a
            String](#name-parsing-a-string){.xref}[¶](#section-toc.1-1.4.2.2.2.5.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.6}
            [4.2.6](#section-4.2.6){.xref}.  [Parsing a
            Token](#name-parsing-a-token){.xref}[¶](#section-toc.1-1.4.2.2.2.6.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.7}
            [4.2.7](#section-4.2.7){.xref}.  [Parsing a Byte
            Sequence](#name-parsing-a-byte-sequence){.xref}[¶](#section-toc.1-1.4.2.2.2.7.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.8}
            [4.2.8](#section-4.2.8){.xref}.  [Parsing a
            Boolean](#name-parsing-a-boolean){.xref}[¶](#section-toc.1-1.4.2.2.2.8.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [References](#name-references){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [Appendix A](#section-appendix.a){.xref}.  [Frequently Asked
    Questions](#name-frequently-asked-questions){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}

    -   ::: {#section-toc.1-1.8.2.1}
        [A.1](#section-a.1){.xref}.  [Why Not
        JSON?](#name-why-not-json){.xref}[¶](#section-toc.1-1.8.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [Appendix B](#section-appendix.b){.xref}.  [Implementation
    Notes](#name-implementation-notes){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [](#section-appendix.c){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [](#section-appendix.d){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Specifying the syntax of new HTTP header (and trailer) fields is an
onerous task; even with the guidance in [Section
8.3.1](https://www.rfc-editor.org/rfc/rfc7231#section-8.3.1){.relref} of
\[[RFC7231](#RFC7231){.xref}\], there are many decisions \-- and
pitfalls \-- for a prospective HTTP field
author.[¶](#section-1-1){.pilcrow}

Once a field is defined, bespoke parsers and serializers often need to
be written, because each field value has a slightly different handling
of what looks like common syntax.[¶](#section-1-2){.pilcrow}

This document introduces a set of common data structures for use in
definitions of new HTTP field values to address these problems. In
particular, it defines a generic, abstract model for them, along with a
concrete serialization for expressing that model in HTTP
\[[RFC7230](#RFC7230){.xref}\] header and trailer
fields.[¶](#section-1-3){.pilcrow}

An HTTP field that is defined as a \"Structured Header\" or \"Structured
Trailer\" (if the field can be either, it is a \"Structured Field\")
uses the types defined in this specification to define its syntax and
basic handling rules, thereby simplifying both its definition by
specification writers and handling by
implementations.[¶](#section-1-4){.pilcrow}

Additionally, future versions of HTTP can define alternative
serializations of the abstract model of these structures, allowing
fields that use that model to be transmitted more efficiently without
being redefined.[¶](#section-1-5){.pilcrow}

Note that it is not a goal of this document to redefine the syntax of
existing HTTP fields; the mechanisms described herein are only intended
to be used with fields that explicitly opt into
them.[¶](#section-1-6){.pilcrow}

[Section 2](#specify){.xref} describes how to specify a Structured
Field.[¶](#section-1-7){.pilcrow}

[Section 3](#types){.xref} defines a number of abstract data types that
can be used in Structured Fields.[¶](#section-1-8){.pilcrow}

Those abstract types can be serialized into and parsed from HTTP field
values using the algorithms described in [Section
4](#text){.xref}.[¶](#section-1-9){.pilcrow}

::: {#strict}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Intentionally Strict Processing](#name-intentionally-strict-proces){.section-name .selfRef} {#name-intentionally-strict-proces}

This specification intentionally defines strict parsing and
serialization behaviors using step-by-step algorithms; the only error
handling defined is to fail the operation
altogether.[¶](#section-1.1-1){.pilcrow}

It is designed to encourage faithful implementation and good
interoperability. Therefore, an implementation that tried to be helpful
by being more tolerant of input would make interoperability worse, since
that would create pressure on other implementations to implement similar
(but likely subtly different) workarounds.[¶](#section-1.1-2){.pilcrow}

In other words, strict processing is an intentional feature of this
specification; it allows non-conformant input to be discovered and
corrected by the producer early and avoids both interoperability and
security issues that might otherwise
result.[¶](#section-1.1-3){.pilcrow}

Note that as a result of this strictness, if a field is appended to by
multiple parties (e.g., intermediaries or different components in the
sender), an error in one party\'s value is likely to cause the entire
field value to fail parsing.[¶](#section-1.1-4){.pilcrow}
:::
:::

::: {#notational-conventions}
::: {#section-1.2 .section}
### [1.2.](#section-1.2){.section-number .selfRef} [Notational Conventions](#name-notational-conventions){.section-name .selfRef} {#name-notational-conventions}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.2-1){.pilcrow}

This document uses algorithms to specify parsing and serialization
behaviors and the Augmented Backus-Naur Form (ABNF) notation of
\[[RFC5234](#RFC5234){.xref}\] to illustrate expected syntax in HTTP
header fields. In doing so, it uses the VCHAR, SP, DIGIT, ALPHA, and
DQUOTE rules from \[[RFC5234](#RFC5234){.xref}\]. It also includes the
tchar and OWS rules from
\[[RFC7230](#RFC7230){.xref}\].[¶](#section-1.2-2){.pilcrow}

When parsing from HTTP fields, implementations [MUST]{.bcp14} have
behavior that is indistinguishable from following the algorithms. If
there is disagreement between the parsing algorithms and ABNF, the
specified algorithms take precedence.[¶](#section-1.2-3){.pilcrow}

For serialization to HTTP fields, the ABNF illustrates their expected
wire representations, and the algorithms define the recommended way to
produce them. Implementations [MAY]{.bcp14} vary from the specified
behavior so long as the output is still correctly handled by the parsing
algorithm described in [Section
4.2](#text-parse){.xref}.[¶](#section-1.2-4){.pilcrow}
:::
:::
:::
:::

::: {#specify}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Defining New Structured Fields](#name-defining-new-structured-fie){.section-name .selfRef} {#name-defining-new-structured-fie}

To specify an HTTP field as a Structured Field, its authors need
to:[¶](#section-2-1){.pilcrow}

-   [Normatively reference this specification. Recipients and generators
    of the field need to know that the requirements of this document are
    in effect.[¶](#section-2-2.1){.pilcrow}]{#section-2-2.1}
-   [Identify whether the field is a Structured Header (i.e., it can
    only be used in the header section \-- the common case), a
    Structured Trailer (only in the trailer section), or a Structured
    Field (both).[¶](#section-2-2.2){.pilcrow}]{#section-2-2.2}
-   [Specify the type of the field value; either List ([Section
    3.1](#list){.xref}), Dictionary ([Section 3.2](#dictionary){.xref}),
    or Item ([Section
    3.3](#item){.xref}).[¶](#section-2-2.3){.pilcrow}]{#section-2-2.3}
-   [Define the semantics of the field
    value.[¶](#section-2-2.4){.pilcrow}]{#section-2-2.4}
-   [Specify any additional constraints upon the field value, as well as
    the consequences when those constraints are
    violated.[¶](#section-2-2.5){.pilcrow}]{#section-2-2.5}

Typically, this means that a field definition will specify the top-level
type \-- List, Dictionary, or Item \-- and then define its allowable
types and constraints upon them. For example, a header defined as a List
might have all Integer members, or a mix of types; a header defined as
an Item might allow only Strings, and additionally only strings
beginning with the letter \"Q\", or strings in lowercase. Likewise,
Inner Lists ([Section 3.1.1](#inner-list){.xref}) are only valid when a
field definition explicitly allows them.[¶](#section-2-3){.pilcrow}

When parsing fails, the entire field is ignored (see [Section
4.2](#text-parse){.xref}); in most situations, violating field-specific
constraints should have the same effect. Thus, if a header is defined as
an Item and required to be an Integer, but a String is received, the
field will by default be ignored. If the field requires different error
handling, this should be explicitly
specified.[¶](#section-2-4){.pilcrow}

Both Items and Inner Lists allow parameters as an extensibility
mechanism; this means that values can later be extended to accommodate
more information, if need be. To preserve forward compatibility, field
specifications are discouraged from defining the presence of an
unrecognized parameter as an error condition.[¶](#section-2-5){.pilcrow}

To further assure that this extensibility is available in the future,
and to encourage consumers to use a complete parser implementation, a
field definition can specify that \"grease\" parameters be added by
senders. A specification could stipulate that all parameters that fit a
defined pattern are reserved for this use and then encourage them to be
sent on some portion of requests. This helps to discourage recipients
from writing a parser that does not account for
Parameters.[¶](#section-2-6){.pilcrow}

Specifications that use Dictionaries can also allow for forward
compatibility by requiring that the presence of \-- as well as value and
type associated with \-- unknown members be ignored. Subsequent
specifications can then add additional members, specifying constraints
on them as appropriate.[¶](#section-2-7){.pilcrow}

An extension to a Structured Field can then require that an entire field
value be ignored by a recipient that understands the extension if
constraints on the value it defines are not
met.[¶](#section-2-8){.pilcrow}

A field definition cannot relax the requirements of this specification
because doing so would preclude handling by generic software; they can
only add additional constraints (for example, on the numeric range of
Integers and Decimals, the format of Strings and Tokens, the types
allowed in a Dictionary\'s values, or the number of Items in a List).
Likewise, field definitions can only use this specification for the
entire field value, not a portion thereof.[¶](#section-2-9){.pilcrow}

This specification defines minimums for the length or number of various
structures supported by implementations. It does not specify maximum
sizes in most cases, but authors should be aware that HTTP
implementations do impose various limits on the size of individual
fields, the total number of fields, and/or the size of the entire header
or trailer section.[¶](#section-2-10){.pilcrow}

Specifications can refer to a field name as a \"structured header
name\", \"structured trailer name\", or \"structured field name\" as
appropriate. Likewise, they can refer its field value as a \"structured
header value\", \"structured trailer value\", or \"structured field
value\" as necessary. Field definitions are encouraged to use the ABNF
rules beginning with \"sf-\" defined in this specification; other rules
in this specification are not intended to be used in field
definitions.[¶](#section-2-11){.pilcrow}

For example, a fictitious Foo-Example header field might be specified
as:[¶](#section-2-12){.pilcrow}

> 42\. Foo-Example Header[¶](#section-2-13.1){.pilcrow}
>
> The Foo-Example HTTP header field conveys information about how much
> Foo the message has.[¶](#section-2-13.2){.pilcrow}
>
> Foo-Example is an Item Structured Header \[RFC8941\]. Its value MUST
> be an Integer (Section 3.3.1 of \[RFC8941\]). Its ABNF
> is:[¶](#section-2-13.3){.pilcrow}
>
> ::: {#section-2-13.4 .artwork .art-text .alignLeft}
>        Foo-Example = sf-integer
>
> [¶](#section-2-13.4){.pilcrow}
> :::
>
> Its value indicates the amount of Foo in the message, and it MUST be
> between 0 and 10, inclusive; other values MUST cause the entire header
> field to be ignored.[¶](#section-2-13.5){.pilcrow}
>
> The following parameter is defined:[¶](#section-2-13.6){.pilcrow}
>
> -   [A parameter whose key is \"foourl\", and whose value is a String
>     (Section 3.3.3 of \[RFC8941\]), conveying the Foo URL for the
>     message. See below for processing
>     requirements.[¶](#section-2-13.7.1){.pilcrow}]{#section-2-13.7.1}
>
> \"foourl\" contains a URI-reference (Section 4.1 of \[RFC3986\]). If
> its value is not a valid URI-reference, the entire header field MUST
> be ignored. If its value is a relative reference (Section 4.2 of
> \[RFC3986\]), it MUST be resolved (Section 5 of \[RFC3986\]) before
> being used.[¶](#section-2-13.8){.pilcrow}
>
> For example:[¶](#section-2-13.9){.pilcrow}
>
> ::: {#section-2-13.10 .artwork .art-text .alignLeft}
>        Foo-Example: 2; foourl="https://foo.example.com/"
>
> [¶](#section-2-13.10){.pilcrow}
> :::
:::
:::

::: {#types}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Structured Data Types](#name-structured-data-types){.section-name .selfRef} {#name-structured-data-types}

This section defines the abstract types for Structured Fields. The ABNF
provided represents the on-wire format in HTTP field
values.[¶](#section-3-1){.pilcrow}

In summary:[¶](#section-3-2){.pilcrow}

-   [There are three top-level types that an HTTP field can be defined
    as: Lists, Dictionaries, and
    Items.[¶](#section-3-3.1){.pilcrow}]{#section-3-3.1}
-   [Lists and Dictionaries are containers; their members can be Items
    or Inner Lists (which are themselves arrays of
    Items).[¶](#section-3-3.2){.pilcrow}]{#section-3-3.2}
-   [Both Items and Inner Lists can be Parameterized with key/value
    pairs.[¶](#section-3-3.3){.pilcrow}]{#section-3-3.3}

::: {#list}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Lists](#name-lists){.section-name .selfRef} {#name-lists}

Lists are arrays of zero or more members, each of which can be an Item
([Section 3.3](#item){.xref}) or an Inner List ([Section
3.1.1](#inner-list){.xref}), both of which can be Parameterized
([Section 3.1.2](#param){.xref}).[¶](#section-3.1-1){.pilcrow}

The ABNF for Lists in HTTP fields is:[¶](#section-3.1-2){.pilcrow}

::: {#section-3.1-3}
``` {.sourcecode .lang-abnf}
sf-list       = list-member *( OWS "," OWS list-member )
list-member   = sf-item / inner-list
```

[¶](#section-3.1-3){.pilcrow}
:::

Each member is separated by a comma and optional whitespace. For
example, a field whose value is defined as a List of Tokens could look
like:[¶](#section-3.1-4){.pilcrow}

::: {#section-3.1-5}
``` {.sourcecode .lang-http-message}
Example-List: sugar, tea, rum
```

[¶](#section-3.1-5){.pilcrow}
:::

An empty List is denoted by not serializing the field at all. This
implies that fields defined as Lists have a default empty
value.[¶](#section-3.1-6){.pilcrow}

Note that Lists can have their members split across multiple lines of
the same header or trailer section, as per [Section
3.2.2](https://www.rfc-editor.org/rfc/rfc7230#section-3.2.2){.relref} of
\[[RFC7230](#RFC7230){.xref}\]; for example, the following are
equivalent:[¶](#section-3.1-7){.pilcrow}

::: {#section-3.1-8}
``` {.sourcecode .lang-http-message}
Example-List: sugar, tea, rum
```

[¶](#section-3.1-8){.pilcrow}
:::

and[¶](#section-3.1-9){.pilcrow}

::: {#section-3.1-10}
``` {.sourcecode .lang-http-message}
Example-List: sugar, tea
Example-List: rum
```

[¶](#section-3.1-10){.pilcrow}
:::

However, individual members of a List cannot be safely split between
lines; see [Section 4.2](#text-parse){.xref} for
details.[¶](#section-3.1-11){.pilcrow}

Parsers [MUST]{.bcp14} support Lists containing at least 1024 members.
Field specifications can constrain the types and cardinality of
individual List values as they require.[¶](#section-3.1-12){.pilcrow}

::: {#inner-list}
::: {#section-3.1.1 .section}
#### [3.1.1.](#section-3.1.1){.section-number .selfRef} [Inner Lists](#name-inner-lists){.section-name .selfRef} {#name-inner-lists}

An Inner List is an array of zero or more Items ([Section
3.3](#item){.xref}). Both the individual Items and the Inner List itself
can be Parameterized ([Section
3.1.2](#param){.xref}).[¶](#section-3.1.1-1){.pilcrow}

The ABNF for Inner Lists is:[¶](#section-3.1.1-2){.pilcrow}

::: {#section-3.1.1-3}
``` {.sourcecode .lang-abnf}
inner-list    = "(" *SP [ sf-item *( 1*SP sf-item ) *SP ] ")"
                parameters
```

[¶](#section-3.1.1-3){.pilcrow}
:::

Inner Lists are denoted by surrounding parenthesis, and their values are
delimited by one or more spaces. A field whose value is defined as a
List of Inner Lists of Strings could look
like:[¶](#section-3.1.1-4){.pilcrow}

::: {#section-3.1.1-5}
``` {.sourcecode .lang-http-message}
Example-List: ("foo" "bar"), ("baz"), ("bat" "one"), ()
```

[¶](#section-3.1.1-5){.pilcrow}
:::

Note that the last member in this example is an empty Inner
List.[¶](#section-3.1.1-6){.pilcrow}

A header field whose value is defined as a List of Inner Lists with
Parameters at both levels could look
like:[¶](#section-3.1.1-7){.pilcrow}

::: {#section-3.1.1-8}
``` {.sourcecode .lang-http-message}
Example-List: ("foo"; a=1;b=2);lvl=5, ("bar" "baz");lvl=1
```

[¶](#section-3.1.1-8){.pilcrow}
:::

Parsers [MUST]{.bcp14} support Inner Lists containing at least 256
members. Field specifications can constrain the types and cardinality of
individual Inner List members as they
require.[¶](#section-3.1.1-9){.pilcrow}
:::
:::

::: {#param}
::: {#section-3.1.2 .section}
#### [3.1.2.](#section-3.1.2){.section-number .selfRef} [Parameters](#name-parameters){.section-name .selfRef} {#name-parameters}

Parameters are an ordered map of key-value pairs that are associated
with an Item ([Section 3.3](#item){.xref}) or Inner List ([Section
3.1.1](#inner-list){.xref}). The keys are unique within the scope of the
Parameters they occur within, and the values are bare items (i.e., they
themselves cannot be parameterized; see [Section
3.3](#item){.xref}).[¶](#section-3.1.2-1){.pilcrow}

Implementations [MUST]{.bcp14} provide access to Parameters both by
index and by key. Specifications [MAY]{.bcp14} use either means of
accessing them.[¶](#section-3.1.2-2){.pilcrow}

The ABNF for Parameters is:[¶](#section-3.1.2-3){.pilcrow}

::: {#section-3.1.2-4}
``` {.sourcecode .lang-abnf}
parameters    = *( ";" *SP parameter )
parameter     = param-key [ "=" param-value ]
param-key     = key
key           = ( lcalpha / "*" )
                *( lcalpha / DIGIT / "_" / "-" / "." / "*" )
lcalpha       = %x61-7A ; a-z
param-value   = bare-item
```

[¶](#section-3.1.2-4){.pilcrow}
:::

Note that parameters are ordered as serialized, and parameter keys
cannot contain uppercase letters. A parameter is separated from its Item
or Inner List and other parameters by a semicolon. For
example:[¶](#section-3.1.2-5){.pilcrow}

::: {#section-3.1.2-6}
``` {.sourcecode .lang-http-message}
Example-List: abc;a=1;b=2; cde_456, (ghi;jk=4 l);q="9";r=w
```

[¶](#section-3.1.2-6){.pilcrow}
:::

Parameters whose value is Boolean (see [Section 3.3.6](#boolean){.xref})
true [MUST]{.bcp14} omit that value when serialized. For example, the
\"a\" parameter here is true, while the \"b\" parameter is
false:[¶](#section-3.1.2-7){.pilcrow}

::: {#section-3.1.2-8}
``` {.sourcecode .lang-http-message}
Example-Integer: 1; a; b=?0
```

[¶](#section-3.1.2-8){.pilcrow}
:::

Note that this requirement is only on serialization; parsers are still
required to correctly handle the true value when it appears in a
parameter.[¶](#section-3.1.2-9){.pilcrow}

Parsers [MUST]{.bcp14} support at least 256 parameters on an Item or
Inner List, and support parameter keys with at least 64 characters.
Field specifications can constrain the order of individual parameters,
as well as their values\' types as
required.[¶](#section-3.1.2-10){.pilcrow}
:::
:::
:::
:::

::: {#dictionary}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Dictionaries](#name-dictionaries){.section-name .selfRef} {#name-dictionaries}

Dictionaries are ordered maps of key-value pairs, where the keys are
short textual strings and the values are Items ([Section
3.3](#item){.xref}) or arrays of Items, both of which can be
Parameterized ([Section 3.1.2](#param){.xref}). There can be zero or
more members, and their keys are unique in the scope of the Dictionary
they occur within.[¶](#section-3.2-1){.pilcrow}

Implementations [MUST]{.bcp14} provide access to Dictionaries both by
index and by key. Specifications [MAY]{.bcp14} use either means of
accessing the members.[¶](#section-3.2-2){.pilcrow}

The ABNF for Dictionaries is:[¶](#section-3.2-3){.pilcrow}

::: {#section-3.2-4}
``` {.sourcecode .lang-abnf}
sf-dictionary  = dict-member *( OWS "," OWS dict-member )
dict-member    = member-key ( parameters / ( "=" member-value ))
member-key     = key
member-value   = sf-item / inner-list
```

[¶](#section-3.2-4){.pilcrow}
:::

Members are ordered as serialized and separated by a comma with optional
whitespace. Member keys cannot contain uppercase characters. Keys and
values are separated by \"=\" (without whitespace). For
example:[¶](#section-3.2-5){.pilcrow}

::: {#section-3.2-6}
``` {.sourcecode .lang-http-message}
Example-Dict: en="Applepie", da=:w4ZibGV0w6ZydGU=:
```

[¶](#section-3.2-6){.pilcrow}
:::

Note that in this example, the final \"=\" is due to the inclusion of a
Byte Sequence; see [Section
3.3.5](#binary){.xref}.[¶](#section-3.2-7){.pilcrow}

Members whose value is Boolean (see [Section 3.3.6](#boolean){.xref})
true [MUST]{.bcp14} omit that value when serialized. For example, here
both \"b\" and \"c\" are true:[¶](#section-3.2-8){.pilcrow}

::: {#section-3.2-9}
``` {.sourcecode .lang-http-message}
Example-Dict: a=?0, b, c; foo=bar
```

[¶](#section-3.2-9){.pilcrow}
:::

Note that this requirement is only on serialization; parsers are still
required to correctly handle the true Boolean value when it appears in
Dictionary values.[¶](#section-3.2-10){.pilcrow}

A Dictionary with a member whose value is an Inner List of
Tokens:[¶](#section-3.2-11){.pilcrow}

::: {#section-3.2-12}
``` {.sourcecode .lang-http-message}
Example-Dict: rating=1.5, feelings=(joy sadness)
```

[¶](#section-3.2-12){.pilcrow}
:::

A Dictionary with a mix of Items and Inner Lists, some with
parameters:[¶](#section-3.2-13){.pilcrow}

::: {#section-3.2-14}
``` {.sourcecode .lang-http-message}
Example-Dict: a=(1 2), b=3, c=4;aa=bb, d=(5 6);valid
```

[¶](#section-3.2-14){.pilcrow}
:::

As with Lists, an empty Dictionary is represented by omitting the entire
field. This implies that fields defined as Dictionaries have a default
empty value.[¶](#section-3.2-15){.pilcrow}

Typically, a field specification will define the semantics of
Dictionaries by specifying the allowed type(s) for individual members by
their keys, as well as whether their presence is required or optional.
Recipients [MUST]{.bcp14} ignore members whose keys that are undefined
or unknown, unless the field\'s specification specifically disallows
them.[¶](#section-3.2-16){.pilcrow}

Note that Dictionaries can have their members split across multiple
lines of the same header or trailer section; for example, the following
are equivalent:[¶](#section-3.2-17){.pilcrow}

::: {#section-3.2-18}
``` {.sourcecode .lang-http-message}
Example-Dict: foo=1, bar=2
```

[¶](#section-3.2-18){.pilcrow}
:::

and[¶](#section-3.2-19){.pilcrow}

::: {#section-3.2-20}
``` {.sourcecode .lang-http-message}
Example-Dict: foo=1
Example-Dict: bar=2
```

[¶](#section-3.2-20){.pilcrow}
:::

However, individual members of a Dictionary cannot be safely split
between lines; see [Section 4.2](#text-parse){.xref} for
details.[¶](#section-3.2-21){.pilcrow}

Parsers [MUST]{.bcp14} support Dictionaries containing at least 1024
key/value pairs and keys with at least 64 characters. Field
specifications can constrain the order of individual Dictionary members,
as well as their values\' types as
required.[¶](#section-3.2-22){.pilcrow}
:::
:::

::: {#item}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Items](#name-items){.section-name .selfRef} {#name-items}

An Item can be an Integer ([Section 3.3.1](#integer){.xref}), a Decimal
([Section 3.3.2](#decimal){.xref}), a String ([Section
3.3.3](#string){.xref}), a Token ([Section 3.3.4](#token){.xref}), a
Byte Sequence ([Section 3.3.5](#binary){.xref}), or a Boolean ([Section
3.3.6](#boolean){.xref}). It can have associated parameters ([Section
3.1.2](#param){.xref}).[¶](#section-3.3-1){.pilcrow}

The ABNF for Items is:[¶](#section-3.3-2){.pilcrow}

::: {#section-3.3-3}
``` {.sourcecode .lang-abnf}
sf-item   = bare-item parameters
bare-item = sf-integer / sf-decimal / sf-string / sf-token
            / sf-binary / sf-boolean
```

[¶](#section-3.3-3){.pilcrow}
:::

For example, a header field that is defined to be an Item that is an
Integer might look like:[¶](#section-3.3-4){.pilcrow}

::: {#section-3.3-5}
``` {.sourcecode .lang-http-message}
Example-Integer: 5
```

[¶](#section-3.3-5){.pilcrow}
:::

or with parameters:[¶](#section-3.3-6){.pilcrow}

::: {#section-3.3-7}
``` {.sourcecode .lang-http-message}
Example-Integer: 5; foo=bar
```

[¶](#section-3.3-7){.pilcrow}
:::

::: {#integer}
::: {#section-3.3.1 .section}
#### [3.3.1.](#section-3.3.1){.section-number .selfRef} [Integers](#name-integers){.section-name .selfRef} {#name-integers}

Integers have a range of -999,999,999,999,999 to 999,999,999,999,999
inclusive (i.e., up to fifteen digits, signed), for IEEE 754
compatibility
\[[IEEE754](#IEEE754){.xref}\].[¶](#section-3.3.1-1){.pilcrow}

The ABNF for Integers is:[¶](#section-3.3.1-2){.pilcrow}

::: {#section-3.3.1-3}
``` {.sourcecode .lang-abnf}
sf-integer = ["-"] 1*15DIGIT
```

[¶](#section-3.3.1-3){.pilcrow}
:::

For example:[¶](#section-3.3.1-4){.pilcrow}

::: {#section-3.3.1-5}
``` {.sourcecode .lang-http-message}
Example-Integer: 42
```

[¶](#section-3.3.1-5){.pilcrow}
:::

Integers larger than 15 digits can be supported in a variety of ways;
for example, by using a String ([Section 3.3.3](#string){.xref}), a Byte
Sequence ([Section 3.3.5](#binary){.xref}), or a parameter on an Integer
that acts as a scaling factor.[¶](#section-3.3.1-6){.pilcrow}

While it is possible to serialize Integers with leading zeros (e.g.,
\"0002\", \"-01\") and signed zero (\"-0\"), these distinctions may not
be preserved by implementations.[¶](#section-3.3.1-7){.pilcrow}

Note that commas in Integers are used in this section\'s prose only for
readability; they are not valid in the wire
format.[¶](#section-3.3.1-8){.pilcrow}
:::
:::

::: {#decimal}
::: {#section-3.3.2 .section}
#### [3.3.2.](#section-3.3.2){.section-number .selfRef} [Decimals](#name-decimals){.section-name .selfRef} {#name-decimals}

Decimals are numbers with an integer and a fractional component. The
integer component has at most 12 digits; the fractional component has at
most three digits.[¶](#section-3.3.2-1){.pilcrow}

The ABNF for decimals is:[¶](#section-3.3.2-2){.pilcrow}

::: {#section-3.3.2-3}
``` {.sourcecode .lang-abnf}
sf-decimal  = ["-"] 1*12DIGIT "." 1*3DIGIT
```

[¶](#section-3.3.2-3){.pilcrow}
:::

For example, a header whose value is defined as a Decimal could look
like:[¶](#section-3.3.2-4){.pilcrow}

::: {#section-3.3.2-5}
``` {.sourcecode .lang-http-message}
Example-Decimal: 4.5
```

[¶](#section-3.3.2-5){.pilcrow}
:::

While it is possible to serialize Decimals with leading zeros (e.g.,
\"0002.5\", \"-01.334\"), trailing zeros (e.g., \"5.230\", \"-0.40\"),
and signed zero (e.g., \"-0.0\"), these distinctions may not be
preserved by implementations.[¶](#section-3.3.2-6){.pilcrow}

Note that the serialization algorithm ([Section
4.1.5](#ser-decimal){.xref}) rounds input with more than three digits of
precision in the fractional component. If an alternative rounding
strategy is desired, this should be specified by the header definition
to occur before serialization.[¶](#section-3.3.2-7){.pilcrow}
:::
:::

::: {#string}
::: {#section-3.3.3 .section}
#### [3.3.3.](#section-3.3.3){.section-number .selfRef} [Strings](#name-strings){.section-name .selfRef} {#name-strings}

Strings are zero or more printable ASCII \[[RFC0020](#RFC0020){.xref}\]
characters (i.e., the range %x20 to %x7E). Note that this excludes tabs,
newlines, carriage returns, etc.[¶](#section-3.3.3-1){.pilcrow}

The ABNF for Strings is:[¶](#section-3.3.3-2){.pilcrow}

::: {#section-3.3.3-3}
``` {.sourcecode .lang-abnf}
sf-string = DQUOTE *chr DQUOTE
chr       = unescaped / escaped
unescaped = %x20-21 / %x23-5B / %x5D-7E
escaped   = "\" ( DQUOTE / "\" )
```

[¶](#section-3.3.3-3){.pilcrow}
:::

Strings are delimited with double quotes, using a backslash (\"\\\") to
escape double quotes and backslashes. For
example:[¶](#section-3.3.3-4){.pilcrow}

::: {#section-3.3.3-5}
``` {.sourcecode .lang-http-message}
Example-String: "hello world"
```

[¶](#section-3.3.3-5){.pilcrow}
:::

Note that Strings only use DQUOTE as a delimiter; single quotes do not
delimit Strings. Furthermore, only DQUOTE and \"\\\" can be escaped;
other characters after \"\\\" [MUST]{.bcp14} cause parsing to
fail.[¶](#section-3.3.3-6){.pilcrow}

Unicode is not directly supported in Strings, because it causes a number
of interoperability issues, and \-- with few exceptions \-- field values
do not require it.[¶](#section-3.3.3-7){.pilcrow}

When it is necessary for a field value to convey non-ASCII content, a
Byte Sequence ([Section 3.3.5](#binary){.xref}) can be specified, along
with a character encoding (preferably UTF-8
\[[STD63](#STD63){.xref}\]).[¶](#section-3.3.3-8){.pilcrow}

Parsers [MUST]{.bcp14} support Strings (after any decoding) with at
least 1024 characters.[¶](#section-3.3.3-9){.pilcrow}
:::
:::

::: {#token}
::: {#section-3.3.4 .section}
#### [3.3.4.](#section-3.3.4){.section-number .selfRef} [Tokens](#name-tokens){.section-name .selfRef} {#name-tokens}

Tokens are short textual words; their abstract model is identical to
their expression in the HTTP field value
serialization.[¶](#section-3.3.4-1){.pilcrow}

The ABNF for Tokens is:[¶](#section-3.3.4-2){.pilcrow}

::: {#section-3.3.4-3}
``` {.sourcecode .lang-abnf}
sf-token = ( ALPHA / "*" ) *( tchar / ":" / "/" )
```

[¶](#section-3.3.4-3){.pilcrow}
:::

For example:[¶](#section-3.3.4-4){.pilcrow}

::: {#section-3.3.4-5}
``` {.sourcecode .lang-http-message}
Example-Token: foo123/456
```

[¶](#section-3.3.4-5){.pilcrow}
:::

Parsers [MUST]{.bcp14} support Tokens with at least 512
characters.[¶](#section-3.3.4-6){.pilcrow}

Note that Token allows the same characters as the \"token\" ABNF rule
defined in \[[RFC7230](#RFC7230){.xref}\], with the exceptions that the
first character is required to be either ALPHA or \"\*\", and \":\" and
\"/\" are also allowed in subsequent
characters.[¶](#section-3.3.4-7){.pilcrow}
:::
:::

::: {#binary}
::: {#section-3.3.5 .section}
#### [3.3.5.](#section-3.3.5){.section-number .selfRef} [Byte Sequences](#name-byte-sequences){.section-name .selfRef} {#name-byte-sequences}

Byte Sequences can be conveyed in Structured
Fields.[¶](#section-3.3.5-1){.pilcrow}

The ABNF for a Byte Sequence is:[¶](#section-3.3.5-2){.pilcrow}

::: {#section-3.3.5-3}
``` {.sourcecode .lang-abnf}
sf-binary = ":" *(base64) ":"
base64    = ALPHA / DIGIT / "+" / "/" / "="
```

[¶](#section-3.3.5-3){.pilcrow}
:::

A Byte Sequence is delimited with colons and encoded using base64
(\[[RFC4648](#RFC4648){.xref}\], [Section
4](https://www.rfc-editor.org/rfc/rfc4648#section-4){.relref}). For
example:[¶](#section-3.3.5-4){.pilcrow}

::: {#section-3.3.5-5}
``` {.sourcecode .lang-http-message}
Example-ByteSequence: :cHJldGVuZCB0aGlzIGlzIGJpbmFyeSBjb250ZW50Lg==:
```

[¶](#section-3.3.5-5){.pilcrow}
:::

Parsers [MUST]{.bcp14} support Byte Sequences with at least 16384 octets
after decoding.[¶](#section-3.3.5-6){.pilcrow}
:::
:::

::: {#boolean}
::: {#section-3.3.6 .section}
#### [3.3.6.](#section-3.3.6){.section-number .selfRef} [Booleans](#name-booleans){.section-name .selfRef} {#name-booleans}

Boolean values can be conveyed in Structured
Fields.[¶](#section-3.3.6-1){.pilcrow}

The ABNF for a Boolean is:[¶](#section-3.3.6-2){.pilcrow}

::: {#section-3.3.6-3}
``` {.sourcecode .lang-abnf}
sf-boolean = "?" boolean
boolean    = "0" / "1"
```

[¶](#section-3.3.6-3){.pilcrow}
:::

A Boolean is indicated with a leading \"?\" character followed by a
\"1\" for a true value or \"0\" for false. For
example:[¶](#section-3.3.6-4){.pilcrow}

::: {#section-3.3.6-5}
``` {.sourcecode .lang-http-message}
Example-Boolean: ?1
```

[¶](#section-3.3.6-5){.pilcrow}
:::

Note that in Dictionary ([Section 3.2](#dictionary){.xref}) and
Parameter ([Section 3.1.2](#param){.xref}) values, Boolean true is
indicated by omitting the value.[¶](#section-3.3.6-6){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#text}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Working with Structured Fields in HTTP](#name-working-with-structured-fie){.section-name .selfRef} {#name-working-with-structured-fie}

This section defines how to serialize and parse Structured Fields in
textual HTTP field values and other encodings compatible with them
(e.g., in HTTP/2 \[[RFC7540](#RFC7540){.xref}\] before compression with
HPACK \[[RFC7541](#RFC7541){.xref}\]).[¶](#section-4-1){.pilcrow}

::: {#text-serialize}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Serializing Structured Fields](#name-serializing-structured-fiel){.section-name .selfRef} {#name-serializing-structured-fiel}

Given a structure defined in this specification, return an ASCII string
suitable for use in an HTTP field value.[¶](#section-4.1-1){.pilcrow}

1.  [If the structure is a Dictionary or List and its value is empty
    (i.e., it has no members), do not serialize the field at all (i.e.,
    omit both the field-name and
    field-value).[¶](#section-4.1-2.1){.pilcrow}]{#section-4.1-2.1}
2.  [If the structure is a List, let output_string be the result of
    running Serializing a List ([Section 4.1.1](#ser-list){.xref}) with
    the structure.[¶](#section-4.1-2.2){.pilcrow}]{#section-4.1-2.2}
3.  [Else, if the structure is a Dictionary, let output_string be the
    result of running Serializing a Dictionary ([Section
    4.1.2](#ser-dictionary){.xref}) with the
    structure.[¶](#section-4.1-2.3){.pilcrow}]{#section-4.1-2.3}
4.  [Else, if the structure is an Item, let output_string be the result
    of running Serializing an Item ([Section 4.1.3](#ser-item){.xref})
    with the
    structure.[¶](#section-4.1-2.4){.pilcrow}]{#section-4.1-2.4}
5.  [Else, fail
    serialization.[¶](#section-4.1-2.5){.pilcrow}]{#section-4.1-2.5}
6.  [Return output_string converted into an array of bytes, using ASCII
    encoding
    \[[RFC0020](#RFC0020){.xref}\].[¶](#section-4.1-2.6){.pilcrow}]{#section-4.1-2.6}

::: {#ser-list}
::: {#section-4.1.1 .section}
#### [4.1.1.](#section-4.1.1){.section-number .selfRef} [Serializing a List](#name-serializing-a-list){.section-name .selfRef} {#name-serializing-a-list}

Given an array of (member_value, parameters) tuples as input_list,
return an ASCII string suitable for use in an HTTP field
value.[¶](#section-4.1.1-1){.pilcrow}

1.  [Let output be an empty
    string.[¶](#section-4.1.1-2.1){.pilcrow}]{#section-4.1.1-2.1}

2.  ::: {#section-4.1.1-2.2}
    For each (member_value, parameters) of
    input_list:[¶](#section-4.1.1-2.2.1){.pilcrow}

    1.  [If member_value is an array, append the result of running
        Serializing an Inner List ([Section
        4.1.1.1](#ser-innerlist){.xref}) with (member_value, parameters)
        to
        output.[¶](#section-4.1.1-2.2.2.1){.pilcrow}]{#section-4.1.1-2.2.2.1}

    2.  [Otherwise, append the result of running Serializing an Item
        ([Section 4.1.3](#ser-item){.xref}) with (member_value,
        parameters) to
        output.[¶](#section-4.1.1-2.2.2.2){.pilcrow}]{#section-4.1.1-2.2.2.2}

    3.  ::: {#section-4.1.1-2.2.2.3}
        If more member_values remain in
        input_list:[¶](#section-4.1.1-2.2.2.3.1){.pilcrow}

        1.  [Append \",\" to
            output.[¶](#section-4.1.1-2.2.2.3.2.1){.pilcrow}]{#section-4.1.1-2.2.2.3.2.1}
        2.  [Append a single SP to
            output.[¶](#section-4.1.1-2.2.2.3.2.2){.pilcrow}]{#section-4.1.1-2.2.2.3.2.2}
        :::
    :::

3.  [Return
    output.[¶](#section-4.1.1-2.3){.pilcrow}]{#section-4.1.1-2.3}

::: {#ser-innerlist}
::: {#section-4.1.1.1 .section}
##### [4.1.1.1.](#section-4.1.1.1){.section-number .selfRef} [Serializing an Inner List](#name-serializing-an-inner-list){.section-name .selfRef} {#name-serializing-an-inner-list}

Given an array of (member_value, parameters) tuples as inner_list, and
parameters as list_parameters, return an ASCII string suitable for use
in an HTTP field value.[¶](#section-4.1.1.1-1){.pilcrow}

1.  [Let output be the string
    \"(\".[¶](#section-4.1.1.1-2.1){.pilcrow}]{#section-4.1.1.1-2.1}

2.  ::: {#section-4.1.1.1-2.2}
    For each (member_value, parameters) of
    inner_list:[¶](#section-4.1.1.1-2.2.1){.pilcrow}

    1.  [Append the result of running Serializing an Item ([Section
        4.1.3](#ser-item){.xref}) with (member_value, parameters) to
        output.[¶](#section-4.1.1.1-2.2.2.1){.pilcrow}]{#section-4.1.1.1-2.2.2.1}
    2.  [If more values remain in inner_list, append a single SP to
        output.[¶](#section-4.1.1.1-2.2.2.2){.pilcrow}]{#section-4.1.1.1-2.2.2.2}
    :::

3.  [Append \")\" to
    output.[¶](#section-4.1.1.1-2.3){.pilcrow}]{#section-4.1.1.1-2.3}

4.  [Append the result of running Serializing Parameters ([Section
    4.1.1.2](#ser-params){.xref}) with list_parameters to
    output.[¶](#section-4.1.1.1-2.4){.pilcrow}]{#section-4.1.1.1-2.4}

5.  [Return
    output.[¶](#section-4.1.1.1-2.5){.pilcrow}]{#section-4.1.1.1-2.5}
:::
:::

::: {#ser-params}
::: {#section-4.1.1.2 .section}
##### [4.1.1.2.](#section-4.1.1.2){.section-number .selfRef} [Serializing Parameters](#name-serializing-parameters){.section-name .selfRef} {#name-serializing-parameters}

Given an ordered Dictionary as input_parameters (each member having a
param_key and a param_value), return an ASCII string suitable for use in
an HTTP field value.[¶](#section-4.1.1.2-1){.pilcrow}

1.  [Let output be an empty
    string.[¶](#section-4.1.1.2-2.1){.pilcrow}]{#section-4.1.1.2-2.1}

2.  ::: {#section-4.1.1.2-2.2}
    For each param_key with a value of param_value in
    input_parameters:[¶](#section-4.1.1.2-2.2.1){.pilcrow}

    1.  [Append \";\" to
        output.[¶](#section-4.1.1.2-2.2.2.1){.pilcrow}]{#section-4.1.1.2-2.2.2.1}

    2.  [Append the result of running Serializing a Key ([Section
        4.1.1.3](#ser-key){.xref}) with param_key to
        output.[¶](#section-4.1.1.2-2.2.2.2){.pilcrow}]{#section-4.1.1.2-2.2.2.2}

    3.  ::: {#section-4.1.1.2-2.2.2.3}
        If param_value is not Boolean
        true:[¶](#section-4.1.1.2-2.2.2.3.1){.pilcrow}

        1.  [Append \"=\" to
            output.[¶](#section-4.1.1.2-2.2.2.3.2.1){.pilcrow}]{#section-4.1.1.2-2.2.2.3.2.1}
        2.  [Append the result of running Serializing a bare Item
            ([Section 4.1.3.1](#ser-bare-item){.xref}) with param_value
            to
            output.[¶](#section-4.1.1.2-2.2.2.3.2.2){.pilcrow}]{#section-4.1.1.2-2.2.2.3.2.2}
        :::
    :::

3.  [Return
    output.[¶](#section-4.1.1.2-2.3){.pilcrow}]{#section-4.1.1.2-2.3}
:::
:::

::: {#ser-key}
::: {#section-4.1.1.3 .section}
##### [4.1.1.3.](#section-4.1.1.3){.section-number .selfRef} [Serializing a Key](#name-serializing-a-key){.section-name .selfRef} {#name-serializing-a-key}

Given a key as input_key, return an ASCII string suitable for use in an
HTTP field value.[¶](#section-4.1.1.3-1){.pilcrow}

1.  [Convert input_key into a sequence of ASCII characters; if
    conversion fails, fail
    serialization.[¶](#section-4.1.1.3-2.1){.pilcrow}]{#section-4.1.1.3-2.1}
2.  [If input_key contains characters not in lcalpha, DIGIT, \"\_\",
    \"-\", \".\", or \"\*\", fail
    serialization.[¶](#section-4.1.1.3-2.2){.pilcrow}]{#section-4.1.1.3-2.2}
3.  [If the first character of input_key is not lcalpha or \"\*\", fail
    serialization.[¶](#section-4.1.1.3-2.3){.pilcrow}]{#section-4.1.1.3-2.3}
4.  [Let output be an empty
    string.[¶](#section-4.1.1.3-2.4){.pilcrow}]{#section-4.1.1.3-2.4}
5.  [Append input_key to
    output.[¶](#section-4.1.1.3-2.5){.pilcrow}]{#section-4.1.1.3-2.5}
6.  [Return
    output.[¶](#section-4.1.1.3-2.6){.pilcrow}]{#section-4.1.1.3-2.6}
:::
:::
:::
:::

::: {#ser-dictionary}
::: {#section-4.1.2 .section}
#### [4.1.2.](#section-4.1.2){.section-number .selfRef} [Serializing a Dictionary](#name-serializing-a-dictionary){.section-name .selfRef} {#name-serializing-a-dictionary}

Given an ordered Dictionary as input_dictionary (each member having a
member_key and a tuple value of (member_value, parameters)), return an
ASCII string suitable for use in an HTTP field
value.[¶](#section-4.1.2-1){.pilcrow}

1.  [Let output be an empty
    string.[¶](#section-4.1.2-2.1){.pilcrow}]{#section-4.1.2-2.1}

2.  ::: {#section-4.1.2-2.2}
    For each member_key with a value of (member_value, parameters) in
    input_dictionary:[¶](#section-4.1.2-2.2.1){.pilcrow}

    1.  [Append the result of running Serializing a Key ([Section
        4.1.1.3](#ser-key){.xref}) with member\'s member_key to
        output.[¶](#section-4.1.2-2.2.2.1){.pilcrow}]{#section-4.1.2-2.2.2.1}

    2.  ::: {#section-4.1.2-2.2.2.2}
        If member_value is Boolean
        true:[¶](#section-4.1.2-2.2.2.2.1){.pilcrow}

        1.  [Append the result of running Serializing Parameters
            ([Section 4.1.1.2](#ser-params){.xref}) with parameters to
            output.[¶](#section-4.1.2-2.2.2.2.2.1){.pilcrow}]{#section-4.1.2-2.2.2.2.2.1}
        :::

    3.  ::: {#section-4.1.2-2.2.2.3}
        Otherwise:[¶](#section-4.1.2-2.2.2.3.1){.pilcrow}

        1.  [Append \"=\" to
            output.[¶](#section-4.1.2-2.2.2.3.2.1){.pilcrow}]{#section-4.1.2-2.2.2.3.2.1}
        2.  [If member_value is an array, append the result of running
            Serializing an Inner List ([Section
            4.1.1.1](#ser-innerlist){.xref}) with (member_value,
            parameters) to
            output.[¶](#section-4.1.2-2.2.2.3.2.2){.pilcrow}]{#section-4.1.2-2.2.2.3.2.2}
        3.  [Otherwise, append the result of running Serializing an Item
            ([Section 4.1.3](#ser-item){.xref}) with (member_value,
            parameters) to
            output.[¶](#section-4.1.2-2.2.2.3.2.3){.pilcrow}]{#section-4.1.2-2.2.2.3.2.3}
        :::

    4.  ::: {#section-4.1.2-2.2.2.4}
        If more members remain in
        input_dictionary:[¶](#section-4.1.2-2.2.2.4.1){.pilcrow}

        1.  [Append \",\" to
            output.[¶](#section-4.1.2-2.2.2.4.2.1){.pilcrow}]{#section-4.1.2-2.2.2.4.2.1}
        2.  [Append a single SP to
            output.[¶](#section-4.1.2-2.2.2.4.2.2){.pilcrow}]{#section-4.1.2-2.2.2.4.2.2}
        :::
    :::

3.  [Return
    output.[¶](#section-4.1.2-2.3){.pilcrow}]{#section-4.1.2-2.3}
:::
:::

::: {#ser-item}
::: {#section-4.1.3 .section}
#### [4.1.3.](#section-4.1.3){.section-number .selfRef} [Serializing an Item](#name-serializing-an-item){.section-name .selfRef} {#name-serializing-an-item}

Given an Item as bare_item and Parameters as item_parameters, return an
ASCII string suitable for use in an HTTP field
value.[¶](#section-4.1.3-1){.pilcrow}

1.  [Let output be an empty
    string.[¶](#section-4.1.3-2.1){.pilcrow}]{#section-4.1.3-2.1}
2.  [Append the result of running Serializing a Bare Item ([Section
    4.1.3.1](#ser-bare-item){.xref}) with bare_item to
    output.[¶](#section-4.1.3-2.2){.pilcrow}]{#section-4.1.3-2.2}
3.  [Append the result of running Serializing Parameters ([Section
    4.1.1.2](#ser-params){.xref}) with item_parameters to
    output.[¶](#section-4.1.3-2.3){.pilcrow}]{#section-4.1.3-2.3}
4.  [Return
    output.[¶](#section-4.1.3-2.4){.pilcrow}]{#section-4.1.3-2.4}

::: {#ser-bare-item}
::: {#section-4.1.3.1 .section}
##### [4.1.3.1.](#section-4.1.3.1){.section-number .selfRef} [Serializing a Bare Item](#name-serializing-a-bare-item){.section-name .selfRef} {#name-serializing-a-bare-item}

Given an Item as input_item, return an ASCII string suitable for use in
an HTTP field value.[¶](#section-4.1.3.1-1){.pilcrow}

1.  [If input_item is an Integer, return the result of running
    Serializing an Integer ([Section 4.1.4](#ser-integer){.xref}) with
    input_item.[¶](#section-4.1.3.1-2.1){.pilcrow}]{#section-4.1.3.1-2.1}
2.  [If input_item is a Decimal, return the result of running
    Serializing a Decimal ([Section 4.1.5](#ser-decimal){.xref}) with
    input_item.[¶](#section-4.1.3.1-2.2){.pilcrow}]{#section-4.1.3.1-2.2}
3.  [If input_item is a String, return the result of running Serializing
    a String ([Section 4.1.6](#ser-string){.xref}) with
    input_item.[¶](#section-4.1.3.1-2.3){.pilcrow}]{#section-4.1.3.1-2.3}
4.  [If input_item is a Token, return the result of running Serializing
    a Token ([Section 4.1.7](#ser-token){.xref}) with
    input_item.[¶](#section-4.1.3.1-2.4){.pilcrow}]{#section-4.1.3.1-2.4}
5.  [If input_item is a Byte Sequence, return the result of running
    Serializing a Byte Sequence ([Section 4.1.8](#ser-binary){.xref})
    with
    input_item.[¶](#section-4.1.3.1-2.5){.pilcrow}]{#section-4.1.3.1-2.5}
6.  [If input_item is a Boolean, return the result of running
    Serializing a Boolean ([Section 4.1.9](#ser-boolean){.xref}) with
    input_item.[¶](#section-4.1.3.1-2.6){.pilcrow}]{#section-4.1.3.1-2.6}
7.  [Otherwise, fail
    serialization.[¶](#section-4.1.3.1-2.7){.pilcrow}]{#section-4.1.3.1-2.7}
:::
:::
:::
:::

::: {#ser-integer}
::: {#section-4.1.4 .section}
#### [4.1.4.](#section-4.1.4){.section-number .selfRef} [Serializing an Integer](#name-serializing-an-integer){.section-name .selfRef} {#name-serializing-an-integer}

Given an Integer as input_integer, return an ASCII string suitable for
use in an HTTP field value.[¶](#section-4.1.4-1){.pilcrow}

1.  [If input_integer is not an integer in the range of
    -999,999,999,999,999 to 999,999,999,999,999 inclusive, fail
    serialization.[¶](#section-4.1.4-2.1){.pilcrow}]{#section-4.1.4-2.1}
2.  [Let output be an empty
    string.[¶](#section-4.1.4-2.2){.pilcrow}]{#section-4.1.4-2.2}
3.  [If input_integer is less than (but not equal to) 0, append \"-\" to
    output.[¶](#section-4.1.4-2.3){.pilcrow}]{#section-4.1.4-2.3}
4.  [Append input_integer\'s numeric value represented in base 10 using
    only decimal digits to
    output.[¶](#section-4.1.4-2.4){.pilcrow}]{#section-4.1.4-2.4}
5.  [Return
    output.[¶](#section-4.1.4-2.5){.pilcrow}]{#section-4.1.4-2.5}
:::
:::

::: {#ser-decimal}
::: {#section-4.1.5 .section}
#### [4.1.5.](#section-4.1.5){.section-number .selfRef} [Serializing a Decimal](#name-serializing-a-decimal){.section-name .selfRef} {#name-serializing-a-decimal}

Given a decimal number as input_decimal, return an ASCII string suitable
for use in an HTTP field value.[¶](#section-4.1.5-1){.pilcrow}

1.  [If input_decimal is not a decimal number, fail
    serialization.[¶](#section-4.1.5-2.1){.pilcrow}]{#section-4.1.5-2.1}
2.  [If input_decimal has more than three significant digits to the
    right of the decimal point, round it to three decimal places,
    rounding the final digit to the nearest value, or to the even value
    if it is
    equidistant.[¶](#section-4.1.5-2.2){.pilcrow}]{#section-4.1.5-2.2}
3.  [If input_decimal has more than 12 significant digits to the left of
    the decimal point after rounding, fail
    serialization.[¶](#section-4.1.5-2.3){.pilcrow}]{#section-4.1.5-2.3}
4.  [Let output be an empty
    string.[¶](#section-4.1.5-2.4){.pilcrow}]{#section-4.1.5-2.4}
5.  [If input_decimal is less than (but not equal to) 0, append \"-\" to
    output.[¶](#section-4.1.5-2.5){.pilcrow}]{#section-4.1.5-2.5}
6.  [Append input_decimal\'s integer component represented in base 10
    (using only decimal digits) to output; if it is zero, append
    \"0\".[¶](#section-4.1.5-2.6){.pilcrow}]{#section-4.1.5-2.6}
7.  [Append \".\" to
    output.[¶](#section-4.1.5-2.7){.pilcrow}]{#section-4.1.5-2.7}
8.  [If input_decimal\'s fractional component is zero, append \"0\" to
    output.[¶](#section-4.1.5-2.8){.pilcrow}]{#section-4.1.5-2.8}
9.  [Otherwise, append the significant digits of input_decimal\'s
    fractional component represented in base 10 (using only decimal
    digits) to
    output.[¶](#section-4.1.5-2.9){.pilcrow}]{#section-4.1.5-2.9}
10. [Return
    output.[¶](#section-4.1.5-2.10){.pilcrow}]{#section-4.1.5-2.10}
:::
:::

::: {#ser-string}
::: {#section-4.1.6 .section}
#### [4.1.6.](#section-4.1.6){.section-number .selfRef} [Serializing a String](#name-serializing-a-string){.section-name .selfRef} {#name-serializing-a-string}

Given a String as input_string, return an ASCII string suitable for use
in an HTTP field value.[¶](#section-4.1.6-1){.pilcrow}

1.  [Convert input_string into a sequence of ASCII characters; if
    conversion fails, fail
    serialization.[¶](#section-4.1.6-2.1){.pilcrow}]{#section-4.1.6-2.1}

2.  [If input_string contains characters in the range %x00-1f or %x7f-ff
    (i.e., not in VCHAR or SP), fail
    serialization.[¶](#section-4.1.6-2.2){.pilcrow}]{#section-4.1.6-2.2}

3.  [Let output be the string
    DQUOTE.[¶](#section-4.1.6-2.3){.pilcrow}]{#section-4.1.6-2.3}

4.  ::: {#section-4.1.6-2.4}
    For each character char in
    input_string:[¶](#section-4.1.6-2.4.1){.pilcrow}

    1.  ::: {#section-4.1.6-2.4.2.1}
        If char is \"\\\" or
        DQUOTE:[¶](#section-4.1.6-2.4.2.1.1){.pilcrow}

        1.  [Append \"\\\" to
            output.[¶](#section-4.1.6-2.4.2.1.2.1){.pilcrow}]{#section-4.1.6-2.4.2.1.2.1}
        :::

    2.  [Append char to
        output.[¶](#section-4.1.6-2.4.2.2){.pilcrow}]{#section-4.1.6-2.4.2.2}
    :::

5.  [Append DQUOTE to
    output.[¶](#section-4.1.6-2.5){.pilcrow}]{#section-4.1.6-2.5}

6.  [Return
    output.[¶](#section-4.1.6-2.6){.pilcrow}]{#section-4.1.6-2.6}
:::
:::

::: {#ser-token}
::: {#section-4.1.7 .section}
#### [4.1.7.](#section-4.1.7){.section-number .selfRef} [Serializing a Token](#name-serializing-a-token){.section-name .selfRef} {#name-serializing-a-token}

Given a Token as input_token, return an ASCII string suitable for use in
an HTTP field value.[¶](#section-4.1.7-1){.pilcrow}

1.  [Convert input_token into a sequence of ASCII characters; if
    conversion fails, fail
    serialization.[¶](#section-4.1.7-2.1){.pilcrow}]{#section-4.1.7-2.1}
2.  [If the first character of input_token is not ALPHA or \"\*\", or
    the remaining portion contains a character not in tchar, \":\", or
    \"/\", fail
    serialization.[¶](#section-4.1.7-2.2){.pilcrow}]{#section-4.1.7-2.2}
3.  [Let output be an empty
    string.[¶](#section-4.1.7-2.3){.pilcrow}]{#section-4.1.7-2.3}
4.  [Append input_token to
    output.[¶](#section-4.1.7-2.4){.pilcrow}]{#section-4.1.7-2.4}
5.  [Return
    output.[¶](#section-4.1.7-2.5){.pilcrow}]{#section-4.1.7-2.5}
:::
:::

::: {#ser-binary}
::: {#section-4.1.8 .section}
#### [4.1.8.](#section-4.1.8){.section-number .selfRef} [Serializing a Byte Sequence](#name-serializing-a-byte-sequence){.section-name .selfRef} {#name-serializing-a-byte-sequence}

Given a Byte Sequence as input_bytes, return an ASCII string suitable
for use in an HTTP field value.[¶](#section-4.1.8-1){.pilcrow}

1.  [If input_bytes is not a sequence of bytes, fail
    serialization.[¶](#section-4.1.8-2.1){.pilcrow}]{#section-4.1.8-2.1}
2.  [Let output be an empty
    string.[¶](#section-4.1.8-2.2){.pilcrow}]{#section-4.1.8-2.2}
3.  [Append \":\" to
    output.[¶](#section-4.1.8-2.3){.pilcrow}]{#section-4.1.8-2.3}
4.  [Append the result of base64-encoding input_bytes as per
    \[[RFC4648](#RFC4648){.xref}\], [Section
    4](https://www.rfc-editor.org/rfc/rfc4648#section-4){.relref},
    taking account of the requirements
    below.[¶](#section-4.1.8-2.4){.pilcrow}]{#section-4.1.8-2.4}
5.  [Append \":\" to
    output.[¶](#section-4.1.8-2.5){.pilcrow}]{#section-4.1.8-2.5}
6.  [Return
    output.[¶](#section-4.1.8-2.6){.pilcrow}]{#section-4.1.8-2.6}

The encoded data is required to be padded with \"=\", as per
\[[RFC4648](#RFC4648){.xref}\], [Section
3.2](https://www.rfc-editor.org/rfc/rfc4648#section-3.2){.relref}.[¶](#section-4.1.8-3){.pilcrow}

Likewise, encoded data [SHOULD]{.bcp14} have pad bits set to zero, as
per \[[RFC4648](#RFC4648){.xref}\], [Section
3.5](https://www.rfc-editor.org/rfc/rfc4648#section-3.5){.relref},
unless it is not possible to do so due to implementation
constraints.[¶](#section-4.1.8-4){.pilcrow}
:::
:::

::: {#ser-boolean}
::: {#section-4.1.9 .section}
#### [4.1.9.](#section-4.1.9){.section-number .selfRef} [Serializing a Boolean](#name-serializing-a-boolean){.section-name .selfRef} {#name-serializing-a-boolean}

Given a Boolean as input_boolean, return an ASCII string suitable for
use in an HTTP field value.[¶](#section-4.1.9-1){.pilcrow}

1.  [If input_boolean is not a boolean, fail
    serialization.[¶](#section-4.1.9-2.1){.pilcrow}]{#section-4.1.9-2.1}
2.  [Let output be an empty
    string.[¶](#section-4.1.9-2.2){.pilcrow}]{#section-4.1.9-2.2}
3.  [Append \"?\" to
    output.[¶](#section-4.1.9-2.3){.pilcrow}]{#section-4.1.9-2.3}
4.  [If input_boolean is true, append \"1\" to
    output.[¶](#section-4.1.9-2.4){.pilcrow}]{#section-4.1.9-2.4}
5.  [If input_boolean is false, append \"0\" to
    output.[¶](#section-4.1.9-2.5){.pilcrow}]{#section-4.1.9-2.5}
6.  [Return
    output.[¶](#section-4.1.9-2.6){.pilcrow}]{#section-4.1.9-2.6}
:::
:::
:::
:::

::: {#text-parse}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Parsing Structured Fields](#name-parsing-structured-fields){.section-name .selfRef} {#name-parsing-structured-fields}

When a receiving implementation parses HTTP fields that are known to be
Structured Fields, it is important that care be taken, as there are a
number of edge cases that can cause interoperability or even security
problems. This section specifies the algorithm for doing
so.[¶](#section-4.2-1){.pilcrow}

Given an array of bytes as input_bytes that represent the chosen
field\'s field-value (which is empty if that field is not present) and
field_type (one of \"dictionary\", \"list\", or \"item\"), return the
parsed header value.[¶](#section-4.2-2){.pilcrow}

1.  [Convert input_bytes into an ASCII string input_string; if
    conversion fails, fail
    parsing.[¶](#section-4.2-3.1){.pilcrow}]{#section-4.2-3.1}
2.  [Discard any leading SP characters from
    input_string.[¶](#section-4.2-3.2){.pilcrow}]{#section-4.2-3.2}
3.  [If field_type is \"list\", let output be the result of running
    Parsing a List ([Section 4.2.1](#parse-list){.xref}) with
    input_string.[¶](#section-4.2-3.3){.pilcrow}]{#section-4.2-3.3}
4.  [If field_type is \"dictionary\", let output be the result of
    running Parsing a Dictionary ([Section
    4.2.2](#parse-dictionary){.xref}) with
    input_string.[¶](#section-4.2-3.4){.pilcrow}]{#section-4.2-3.4}
5.  [If field_type is \"item\", let output be the result of running
    Parsing an Item ([Section 4.2.3](#parse-item){.xref}) with
    input_string.[¶](#section-4.2-3.5){.pilcrow}]{#section-4.2-3.5}
6.  [Discard any leading SP characters from
    input_string.[¶](#section-4.2-3.6){.pilcrow}]{#section-4.2-3.6}
7.  [If input_string is not empty, fail
    parsing.[¶](#section-4.2-3.7){.pilcrow}]{#section-4.2-3.7}
8.  [Otherwise, return
    output.[¶](#section-4.2-3.8){.pilcrow}]{#section-4.2-3.8}

When generating input_bytes, parsers [MUST]{.bcp14} combine all field
lines in the same section (header or trailer) that case-insensitively
match the field name into one comma-separated field-value, as per
\[[RFC7230](#RFC7230){.xref}\], [Section
3.2.2](https://www.rfc-editor.org/rfc/rfc7230#section-3.2.2){.relref};
this assures that the entire field value is processed
correctly.[¶](#section-4.2-4){.pilcrow}

For Lists and Dictionaries, this has the effect of correctly
concatenating all of the field\'s lines, as long as individual members
of the top-level data structure are not split across multiple header
instances. The parsing algorithms for both types allow tab characters,
since these might be used to combine field lines by some
implementations.[¶](#section-4.2-5){.pilcrow}

Strings split across multiple field lines will have unpredictable
results, because one or more commas (with optional whitespace) will
become part of the string output by the parser. Since concatenation
might be done by an upstream intermediary, the results are not under the
control of the serializer or the parser, even when they are both under
the control of the same party.[¶](#section-4.2-6){.pilcrow}

Tokens, Integers, Decimals, and Byte Sequences cannot be split across
multiple field lines because the inserted commas will cause parsing to
fail.[¶](#section-4.2-7){.pilcrow}

Parsers [MAY]{.bcp14} fail when processing a field value spread across
multiple field lines, when one of those lines does not parse as that
field. For example, a parsing handling an Example-String field that\'s
defined as an sf-string is allowed to fail when processing this field
section:[¶](#section-4.2-8){.pilcrow}

::: {#section-4.2-9}
``` {.sourcecode .lang-http-message}
Example-String: "foo
Example-String: bar"
```

[¶](#section-4.2-9){.pilcrow}
:::

If parsing fails \-- including when calling another algorithm \-- the
entire field value [MUST]{.bcp14} be ignored (i.e., treated as if the
field were not present in the section). This is intentionally strict, to
improve interoperability and safety, and specifications referencing this
document are not allowed to loosen this
requirement.[¶](#section-4.2-10){.pilcrow}

Note that this requirement does not apply to an implementation that is
not parsing the field; for example, an intermediary is not required to
strip a failing field from a message before forwarding
it.[¶](#section-4.2-11){.pilcrow}

::: {#parse-list}
::: {#section-4.2.1 .section}
#### [4.2.1.](#section-4.2.1){.section-number .selfRef} [Parsing a List](#name-parsing-a-list){.section-name .selfRef} {#name-parsing-a-list}

Given an ASCII string as input_string, return an array of
(item_or_inner_list, parameters) tuples. input_string is modified to
remove the parsed value.[¶](#section-4.2.1-1){.pilcrow}

1.  [Let members be an empty
    array.[¶](#section-4.2.1-2.1){.pilcrow}]{#section-4.2.1-2.1}

2.  ::: {#section-4.2.1-2.2}
    While input_string is not empty:[¶](#section-4.2.1-2.2.1){.pilcrow}

    1.  [Append the result of running Parsing an Item or Inner List
        ([Section 4.2.1.1](#parse-item-or-list){.xref}) with
        input_string to
        members.[¶](#section-4.2.1-2.2.2.1){.pilcrow}]{#section-4.2.1-2.2.2.1}
    2.  [Discard any leading OWS characters from
        input_string.[¶](#section-4.2.1-2.2.2.2){.pilcrow}]{#section-4.2.1-2.2.2.2}
    3.  [If input_string is empty, return
        members.[¶](#section-4.2.1-2.2.2.3){.pilcrow}]{#section-4.2.1-2.2.2.3}
    4.  [Consume the first character of input_string; if it is not
        \",\", fail
        parsing.[¶](#section-4.2.1-2.2.2.4){.pilcrow}]{#section-4.2.1-2.2.2.4}
    5.  [Discard any leading OWS characters from
        input_string.[¶](#section-4.2.1-2.2.2.5){.pilcrow}]{#section-4.2.1-2.2.2.5}
    6.  [If input_string is empty, there is a trailing comma; fail
        parsing.[¶](#section-4.2.1-2.2.2.6){.pilcrow}]{#section-4.2.1-2.2.2.6}
    :::

3.  [No structured data has been found; return members (which is
    empty).[¶](#section-4.2.1-2.3){.pilcrow}]{#section-4.2.1-2.3}

::: {#parse-item-or-list}
::: {#section-4.2.1.1 .section}
##### [4.2.1.1.](#section-4.2.1.1){.section-number .selfRef} [Parsing an Item or Inner List](#name-parsing-an-item-or-inner-li){.section-name .selfRef} {#name-parsing-an-item-or-inner-li}

Given an ASCII string as input_string, return the tuple
(item_or_inner_list, parameters), where item_or_inner_list can be either
a single bare item or an array of (bare_item, parameters) tuples.
input_string is modified to remove the parsed
value.[¶](#section-4.2.1.1-1){.pilcrow}

1.  [If the first character of input_string is \"(\", return the result
    of running Parsing an Inner List ([Section
    4.2.1.2](#parse-innerlist){.xref}) with
    input_string.[¶](#section-4.2.1.1-2.1){.pilcrow}]{#section-4.2.1.1-2.1}
2.  [Return the result of running Parsing an Item ([Section
    4.2.3](#parse-item){.xref}) with
    input_string.[¶](#section-4.2.1.1-2.2){.pilcrow}]{#section-4.2.1.1-2.2}
:::
:::

::: {#parse-innerlist}
::: {#section-4.2.1.2 .section}
##### [4.2.1.2.](#section-4.2.1.2){.section-number .selfRef} [Parsing an Inner List](#name-parsing-an-inner-list){.section-name .selfRef} {#name-parsing-an-inner-list}

Given an ASCII string as input_string, return the tuple (inner_list,
parameters), where inner_list is an array of (bare_item, parameters)
tuples. input_string is modified to remove the parsed
value.[¶](#section-4.2.1.2-1){.pilcrow}

1.  [Consume the first character of input_string; if it is not \"(\",
    fail
    parsing.[¶](#section-4.2.1.2-2.1){.pilcrow}]{#section-4.2.1.2-2.1}

2.  [Let inner_list be an empty
    array.[¶](#section-4.2.1.2-2.2){.pilcrow}]{#section-4.2.1.2-2.2}

3.  ::: {#section-4.2.1.2-2.3}
    While input_string is not
    empty:[¶](#section-4.2.1.2-2.3.1){.pilcrow}

    1.  [Discard any leading SP characters from
        input_string.[¶](#section-4.2.1.2-2.3.2.1){.pilcrow}]{#section-4.2.1.2-2.3.2.1}

    2.  ::: {#section-4.2.1.2-2.3.2.2}
        If the first character of input_string is
        \")\":[¶](#section-4.2.1.2-2.3.2.2.1){.pilcrow}

        1.  [Consume the first character of
            input_string.[¶](#section-4.2.1.2-2.3.2.2.2.1){.pilcrow}]{#section-4.2.1.2-2.3.2.2.2.1}
        2.  [Let parameters be the result of running Parsing Parameters
            ([Section 4.2.3.2](#parse-param){.xref}) with
            input_string.[¶](#section-4.2.1.2-2.3.2.2.2.2){.pilcrow}]{#section-4.2.1.2-2.3.2.2.2.2}
        3.  [Return the tuple (inner_list,
            parameters).[¶](#section-4.2.1.2-2.3.2.2.2.3){.pilcrow}]{#section-4.2.1.2-2.3.2.2.2.3}
        :::

    3.  [Let item be the result of running Parsing an Item ([Section
        4.2.3](#parse-item){.xref}) with
        input_string.[¶](#section-4.2.1.2-2.3.2.3){.pilcrow}]{#section-4.2.1.2-2.3.2.3}

    4.  [Append item to
        inner_list.[¶](#section-4.2.1.2-2.3.2.4){.pilcrow}]{#section-4.2.1.2-2.3.2.4}

    5.  [If the first character of input_string is not SP or \")\", fail
        parsing.[¶](#section-4.2.1.2-2.3.2.5){.pilcrow}]{#section-4.2.1.2-2.3.2.5}
    :::

4.  [The end of the Inner List was not found; fail
    parsing.[¶](#section-4.2.1.2-2.4){.pilcrow}]{#section-4.2.1.2-2.4}
:::
:::
:::
:::

::: {#parse-dictionary}
::: {#section-4.2.2 .section}
#### [4.2.2.](#section-4.2.2){.section-number .selfRef} [Parsing a Dictionary](#name-parsing-a-dictionary){.section-name .selfRef} {#name-parsing-a-dictionary}

Given an ASCII string as input_string, return an ordered map whose
values are (item_or_inner_list, parameters) tuples. input_string is
modified to remove the parsed value.[¶](#section-4.2.2-1){.pilcrow}

1.  [Let dictionary be an empty, ordered
    map.[¶](#section-4.2.2-2.1){.pilcrow}]{#section-4.2.2-2.1}

2.  ::: {#section-4.2.2-2.2}
    While input_string is not empty:[¶](#section-4.2.2-2.2.1){.pilcrow}

    1.  [Let this_key be the result of running Parsing a Key ([Section
        4.2.3.3](#parse-key){.xref}) with
        input_string.[¶](#section-4.2.2-2.2.2.1){.pilcrow}]{#section-4.2.2-2.2.2.1}

    2.  ::: {#section-4.2.2-2.2.2.2}
        If the first character of input_string is
        \"=\":[¶](#section-4.2.2-2.2.2.2.1){.pilcrow}

        1.  [Consume the first character of
            input_string.[¶](#section-4.2.2-2.2.2.2.2.1){.pilcrow}]{#section-4.2.2-2.2.2.2.2.1}
        2.  [Let member be the result of running Parsing an Item or
            Inner List ([Section 4.2.1.1](#parse-item-or-list){.xref})
            with
            input_string.[¶](#section-4.2.2-2.2.2.2.2.2){.pilcrow}]{#section-4.2.2-2.2.2.2.2.2}
        :::

    3.  ::: {#section-4.2.2-2.2.2.3}
        Otherwise:[¶](#section-4.2.2-2.2.2.3.1){.pilcrow}

        1.  [Let value be Boolean
            true.[¶](#section-4.2.2-2.2.2.3.2.1){.pilcrow}]{#section-4.2.2-2.2.2.3.2.1}
        2.  [Let parameters be the result of running Parsing Parameters
            ([Section 4.2.3.2](#parse-param){.xref}) with
            input_string.[¶](#section-4.2.2-2.2.2.3.2.2){.pilcrow}]{#section-4.2.2-2.2.2.3.2.2}
        3.  [Let member be the tuple (value,
            parameters).[¶](#section-4.2.2-2.2.2.3.2.3){.pilcrow}]{#section-4.2.2-2.2.2.3.2.3}
        :::

    4.  [If dictionary already contains a key this_key (comparing
        character for character), overwrite its value with
        member.[¶](#section-4.2.2-2.2.2.4){.pilcrow}]{#section-4.2.2-2.2.2.4}

    5.  [Otherwise, append key this_key with value member to
        dictionary.[¶](#section-4.2.2-2.2.2.5){.pilcrow}]{#section-4.2.2-2.2.2.5}

    6.  [Discard any leading OWS characters from
        input_string.[¶](#section-4.2.2-2.2.2.6){.pilcrow}]{#section-4.2.2-2.2.2.6}

    7.  [If input_string is empty, return
        dictionary.[¶](#section-4.2.2-2.2.2.7){.pilcrow}]{#section-4.2.2-2.2.2.7}

    8.  [Consume the first character of input_string; if it is not
        \",\", fail
        parsing.[¶](#section-4.2.2-2.2.2.8){.pilcrow}]{#section-4.2.2-2.2.2.8}

    9.  [Discard any leading OWS characters from
        input_string.[¶](#section-4.2.2-2.2.2.9){.pilcrow}]{#section-4.2.2-2.2.2.9}

    10. [If input_string is empty, there is a trailing comma; fail
        parsing.[¶](#section-4.2.2-2.2.2.10){.pilcrow}]{#section-4.2.2-2.2.2.10}
    :::

3.  [No structured data has been found; return dictionary (which is
    empty).[¶](#section-4.2.2-2.3){.pilcrow}]{#section-4.2.2-2.3}

Note that when duplicate Dictionary keys are encountered, all but the
last instance are ignored.[¶](#section-4.2.2-3){.pilcrow}
:::
:::

::: {#parse-item}
::: {#section-4.2.3 .section}
#### [4.2.3.](#section-4.2.3){.section-number .selfRef} [Parsing an Item](#name-parsing-an-item){.section-name .selfRef} {#name-parsing-an-item}

Given an ASCII string as input_string, return a (bare_item, parameters)
tuple. input_string is modified to remove the parsed
value.[¶](#section-4.2.3-1){.pilcrow}

1.  [Let bare_item be the result of running Parsing a Bare Item
    ([Section 4.2.3.1](#parse-bare-item){.xref}) with
    input_string.[¶](#section-4.2.3-2.1){.pilcrow}]{#section-4.2.3-2.1}
2.  [Let parameters be the result of running Parsing Parameters
    ([Section 4.2.3.2](#parse-param){.xref}) with
    input_string.[¶](#section-4.2.3-2.2){.pilcrow}]{#section-4.2.3-2.2}
3.  [Return the tuple (bare_item,
    parameters).[¶](#section-4.2.3-2.3){.pilcrow}]{#section-4.2.3-2.3}

::: {#parse-bare-item}
::: {#section-4.2.3.1 .section}
##### [4.2.3.1.](#section-4.2.3.1){.section-number .selfRef} [Parsing a Bare Item](#name-parsing-a-bare-item){.section-name .selfRef} {#name-parsing-a-bare-item}

Given an ASCII string as input_string, return a bare Item. input_string
is modified to remove the parsed value.[¶](#section-4.2.3.1-1){.pilcrow}

1.  [If the first character of input_string is a \"-\" or a DIGIT,
    return the result of running Parsing an Integer or Decimal ([Section
    4.2.4](#parse-number){.xref}) with
    input_string.[¶](#section-4.2.3.1-2.1){.pilcrow}]{#section-4.2.3.1-2.1}
2.  [If the first character of input_string is a DQUOTE, return the
    result of running Parsing a String ([Section
    4.2.5](#parse-string){.xref}) with
    input_string.[¶](#section-4.2.3.1-2.2){.pilcrow}]{#section-4.2.3.1-2.2}
3.  [If the first character of input_string is an ALPHA or \"\*\",
    return the result of running Parsing a Token ([Section
    4.2.6](#parse-token){.xref}) with
    input_string.[¶](#section-4.2.3.1-2.3){.pilcrow}]{#section-4.2.3.1-2.3}
4.  [If the first character of input_string is \":\", return the result
    of running Parsing a Byte Sequence ([Section
    4.2.7](#parse-binary){.xref}) with
    input_string.[¶](#section-4.2.3.1-2.4){.pilcrow}]{#section-4.2.3.1-2.4}
5.  [If the first character of input_string is \"?\", return the result
    of running Parsing a Boolean ([Section
    4.2.8](#parse-boolean){.xref}) with
    input_string.[¶](#section-4.2.3.1-2.5){.pilcrow}]{#section-4.2.3.1-2.5}
6.  [Otherwise, the item type is unrecognized; fail
    parsing.[¶](#section-4.2.3.1-2.6){.pilcrow}]{#section-4.2.3.1-2.6}
:::
:::

::: {#parse-param}
::: {#section-4.2.3.2 .section}
##### [4.2.3.2.](#section-4.2.3.2){.section-number .selfRef} [Parsing Parameters](#name-parsing-parameters){.section-name .selfRef} {#name-parsing-parameters}

Given an ASCII string as input_string, return an ordered map whose
values are bare Items. input_string is modified to remove the parsed
value.[¶](#section-4.2.3.2-1){.pilcrow}

1.  [Let parameters be an empty, ordered
    map.[¶](#section-4.2.3.2-2.1){.pilcrow}]{#section-4.2.3.2-2.1}

2.  ::: {#section-4.2.3.2-2.2}
    While input_string is not
    empty:[¶](#section-4.2.3.2-2.2.1){.pilcrow}

    1.  [If the first character of input_string is not \";\", exit the
        loop.[¶](#section-4.2.3.2-2.2.2.1){.pilcrow}]{#section-4.2.3.2-2.2.2.1}

    2.  [Consume the \";\" character from the beginning of
        input_string.[¶](#section-4.2.3.2-2.2.2.2){.pilcrow}]{#section-4.2.3.2-2.2.2.2}

    3.  [Discard any leading SP characters from
        input_string.[¶](#section-4.2.3.2-2.2.2.3){.pilcrow}]{#section-4.2.3.2-2.2.2.3}

    4.  [Let param_key be the result of running Parsing a Key ([Section
        4.2.3.3](#parse-key){.xref}) with
        input_string.[¶](#section-4.2.3.2-2.2.2.4){.pilcrow}]{#section-4.2.3.2-2.2.2.4}

    5.  [Let param_value be Boolean
        true.[¶](#section-4.2.3.2-2.2.2.5){.pilcrow}]{#section-4.2.3.2-2.2.2.5}

    6.  ::: {#section-4.2.3.2-2.2.2.6}
        If the first character of input_string is
        \"=\":[¶](#section-4.2.3.2-2.2.2.6.1){.pilcrow}

        1.  [Consume the \"=\" character at the beginning of
            input_string.[¶](#section-4.2.3.2-2.2.2.6.2.1){.pilcrow}]{#section-4.2.3.2-2.2.2.6.2.1}
        2.  [Let param_value be the result of running Parsing a Bare
            Item ([Section 4.2.3.1](#parse-bare-item){.xref}) with
            input_string.[¶](#section-4.2.3.2-2.2.2.6.2.2){.pilcrow}]{#section-4.2.3.2-2.2.2.6.2.2}
        :::

    7.  [If parameters already contains a key param_key (comparing
        character for character), overwrite its value with
        param_value.[¶](#section-4.2.3.2-2.2.2.7){.pilcrow}]{#section-4.2.3.2-2.2.2.7}

    8.  [Otherwise, append key param_key with value param_value to
        parameters.[¶](#section-4.2.3.2-2.2.2.8){.pilcrow}]{#section-4.2.3.2-2.2.2.8}
    :::

3.  [Return
    parameters.[¶](#section-4.2.3.2-2.3){.pilcrow}]{#section-4.2.3.2-2.3}

Note that when duplicate parameter keys are encountered, all but the
last instance are ignored.[¶](#section-4.2.3.2-3){.pilcrow}
:::
:::

::: {#parse-key}
::: {#section-4.2.3.3 .section}
##### [4.2.3.3.](#section-4.2.3.3){.section-number .selfRef} [Parsing a Key](#name-parsing-a-key){.section-name .selfRef} {#name-parsing-a-key}

Given an ASCII string as input_string, return a key. input_string is
modified to remove the parsed value.[¶](#section-4.2.3.3-1){.pilcrow}

1.  [If the first character of input_string is not lcalpha or \"\*\",
    fail
    parsing.[¶](#section-4.2.3.3-2.1){.pilcrow}]{#section-4.2.3.3-2.1}

2.  [Let output_string be an empty
    string.[¶](#section-4.2.3.3-2.2){.pilcrow}]{#section-4.2.3.3-2.2}

3.  ::: {#section-4.2.3.3-2.3}
    While input_string is not
    empty:[¶](#section-4.2.3.3-2.3.1){.pilcrow}

    1.  [If the first character of input_string is not one of lcalpha,
        DIGIT, \"\_\", \"-\", \".\", or \"\*\", return
        output_string.[¶](#section-4.2.3.3-2.3.2.1){.pilcrow}]{#section-4.2.3.3-2.3.2.1}
    2.  [Let char be the result of consuming the first character of
        input_string.[¶](#section-4.2.3.3-2.3.2.2){.pilcrow}]{#section-4.2.3.3-2.3.2.2}
    3.  [Append char to
        output_string.[¶](#section-4.2.3.3-2.3.2.3){.pilcrow}]{#section-4.2.3.3-2.3.2.3}
    :::

4.  [Return
    output_string.[¶](#section-4.2.3.3-2.4){.pilcrow}]{#section-4.2.3.3-2.4}
:::
:::
:::
:::

::: {#parse-number}
::: {#section-4.2.4 .section}
#### [4.2.4.](#section-4.2.4){.section-number .selfRef} [Parsing an Integer or Decimal](#name-parsing-an-integer-or-decim){.section-name .selfRef} {#name-parsing-an-integer-or-decim}

Given an ASCII string as input_string, return an Integer or Decimal.
input_string is modified to remove the parsed
value.[¶](#section-4.2.4-1){.pilcrow}

NOTE: This algorithm parses both Integers ([Section
3.3.1](#integer){.xref}) and Decimals ([Section
3.3.2](#decimal){.xref}), and returns the corresponding
structure.[¶](#section-4.2.4-2){.pilcrow}

1.  [Let type be
    \"integer\".[¶](#section-4.2.4-3.1){.pilcrow}]{#section-4.2.4-3.1}

2.  [Let sign be
    1.[¶](#section-4.2.4-3.2){.pilcrow}]{#section-4.2.4-3.2}

3.  [Let input_number be an empty
    string.[¶](#section-4.2.4-3.3){.pilcrow}]{#section-4.2.4-3.3}

4.  [If the first character of input_string is \"-\", consume it and set
    sign to -1.[¶](#section-4.2.4-3.4){.pilcrow}]{#section-4.2.4-3.4}

5.  [If input_string is empty, there is an empty integer; fail
    parsing.[¶](#section-4.2.4-3.5){.pilcrow}]{#section-4.2.4-3.5}

6.  [If the first character of input_string is not a DIGIT, fail
    parsing.[¶](#section-4.2.4-3.6){.pilcrow}]{#section-4.2.4-3.6}

7.  ::: {#section-4.2.4-3.7}
    While input_string is not empty:[¶](#section-4.2.4-3.7.1){.pilcrow}

    1.  [Let char be the result of consuming the first character of
        input_string.[¶](#section-4.2.4-3.7.2.1){.pilcrow}]{#section-4.2.4-3.7.2.1}

    2.  [If char is a DIGIT, append it to
        input_number.[¶](#section-4.2.4-3.7.2.2){.pilcrow}]{#section-4.2.4-3.7.2.2}

    3.  ::: {#section-4.2.4-3.7.2.3}
        Else, if type is \"integer\" and char is
        \".\":[¶](#section-4.2.4-3.7.2.3.1){.pilcrow}

        1.  [If input_number contains more than 12 characters, fail
            parsing.[¶](#section-4.2.4-3.7.2.3.2.1){.pilcrow}]{#section-4.2.4-3.7.2.3.2.1}
        2.  [Otherwise, append char to input_number and set type to
            \"decimal\".[¶](#section-4.2.4-3.7.2.3.2.2){.pilcrow}]{#section-4.2.4-3.7.2.3.2.2}
        :::

    4.  [Otherwise, prepend char to input_string, and exit the
        loop.[¶](#section-4.2.4-3.7.2.4){.pilcrow}]{#section-4.2.4-3.7.2.4}

    5.  [If type is \"integer\" and input_number contains more than 15
        characters, fail
        parsing.[¶](#section-4.2.4-3.7.2.5){.pilcrow}]{#section-4.2.4-3.7.2.5}

    6.  [If type is \"decimal\" and input_number contains more than 16
        characters, fail
        parsing.[¶](#section-4.2.4-3.7.2.6){.pilcrow}]{#section-4.2.4-3.7.2.6}
    :::

8.  ::: {#section-4.2.4-3.8}
    If type is \"integer\":[¶](#section-4.2.4-3.8.1){.pilcrow}

    1.  [Parse input_number as an integer and let output_number be the
        product of the result and
        sign.[¶](#section-4.2.4-3.8.2.1){.pilcrow}]{#section-4.2.4-3.8.2.1}
    :::

9.  ::: {#section-4.2.4-3.9}
    Otherwise:[¶](#section-4.2.4-3.9.1){.pilcrow}

    1.  [If the final character of input_number is \".\", fail
        parsing.[¶](#section-4.2.4-3.9.2.1){.pilcrow}]{#section-4.2.4-3.9.2.1}
    2.  [If the number of characters after \".\" in input_number is
        greater than three, fail
        parsing.[¶](#section-4.2.4-3.9.2.2){.pilcrow}]{#section-4.2.4-3.9.2.2}
    3.  [Parse input_number as a decimal number and let output_number be
        the product of the result and
        sign.[¶](#section-4.2.4-3.9.2.3){.pilcrow}]{#section-4.2.4-3.9.2.3}
    :::

10. [Return
    output_number.[¶](#section-4.2.4-3.10){.pilcrow}]{#section-4.2.4-3.10}
:::
:::

::: {#parse-string}
::: {#section-4.2.5 .section}
#### [4.2.5.](#section-4.2.5){.section-number .selfRef} [Parsing a String](#name-parsing-a-string){.section-name .selfRef} {#name-parsing-a-string}

Given an ASCII string as input_string, return an unquoted String.
input_string is modified to remove the parsed
value.[¶](#section-4.2.5-1){.pilcrow}

1.  [Let output_string be an empty
    string.[¶](#section-4.2.5-2.1){.pilcrow}]{#section-4.2.5-2.1}

2.  [If the first character of input_string is not DQUOTE, fail
    parsing.[¶](#section-4.2.5-2.2){.pilcrow}]{#section-4.2.5-2.2}

3.  [Discard the first character of
    input_string.[¶](#section-4.2.5-2.3){.pilcrow}]{#section-4.2.5-2.3}

4.  ::: {#section-4.2.5-2.4}
    While input_string is not empty:[¶](#section-4.2.5-2.4.1){.pilcrow}

    1.  [Let char be the result of consuming the first character of
        input_string.[¶](#section-4.2.5-2.4.2.1){.pilcrow}]{#section-4.2.5-2.4.2.1}

    2.  ::: {#section-4.2.5-2.4.2.2}
        If char is a backslash
        (\"\\\"):[¶](#section-4.2.5-2.4.2.2.1){.pilcrow}

        1.  [If input_string is now empty, fail
            parsing.[¶](#section-4.2.5-2.4.2.2.2.1){.pilcrow}]{#section-4.2.5-2.4.2.2.2.1}
        2.  [Let next_char be the result of consuming the first
            character of
            input_string.[¶](#section-4.2.5-2.4.2.2.2.2){.pilcrow}]{#section-4.2.5-2.4.2.2.2.2}
        3.  [If next_char is not DQUOTE or \"\\\", fail
            parsing.[¶](#section-4.2.5-2.4.2.2.2.3){.pilcrow}]{#section-4.2.5-2.4.2.2.2.3}
        4.  [Append next_char to
            output_string.[¶](#section-4.2.5-2.4.2.2.2.4){.pilcrow}]{#section-4.2.5-2.4.2.2.2.4}
        :::

    3.  [Else, if char is DQUOTE, return
        output_string.[¶](#section-4.2.5-2.4.2.3){.pilcrow}]{#section-4.2.5-2.4.2.3}

    4.  [Else, if char is in the range %x00-1f or %x7f-ff (i.e., it is
        not in VCHAR or SP), fail
        parsing.[¶](#section-4.2.5-2.4.2.4){.pilcrow}]{#section-4.2.5-2.4.2.4}

    5.  [Else, append char to
        output_string.[¶](#section-4.2.5-2.4.2.5){.pilcrow}]{#section-4.2.5-2.4.2.5}
    :::

5.  [Reached the end of input_string without finding a closing DQUOTE;
    fail parsing.[¶](#section-4.2.5-2.5){.pilcrow}]{#section-4.2.5-2.5}
:::
:::

::: {#parse-token}
::: {#section-4.2.6 .section}
#### [4.2.6.](#section-4.2.6){.section-number .selfRef} [Parsing a Token](#name-parsing-a-token){.section-name .selfRef} {#name-parsing-a-token}

Given an ASCII string as input_string, return a Token. input_string is
modified to remove the parsed value.[¶](#section-4.2.6-1){.pilcrow}

1.  [If the first character of input_string is not ALPHA or \"\*\", fail
    parsing.[¶](#section-4.2.6-2.1){.pilcrow}]{#section-4.2.6-2.1}

2.  [Let output_string be an empty
    string.[¶](#section-4.2.6-2.2){.pilcrow}]{#section-4.2.6-2.2}

3.  ::: {#section-4.2.6-2.3}
    While input_string is not empty:[¶](#section-4.2.6-2.3.1){.pilcrow}

    1.  [If the first character of input_string is not in tchar, \":\",
        or \"/\", return
        output_string.[¶](#section-4.2.6-2.3.2.1){.pilcrow}]{#section-4.2.6-2.3.2.1}
    2.  [Let char be the result of consuming the first character of
        input_string.[¶](#section-4.2.6-2.3.2.2){.pilcrow}]{#section-4.2.6-2.3.2.2}
    3.  [Append char to
        output_string.[¶](#section-4.2.6-2.3.2.3){.pilcrow}]{#section-4.2.6-2.3.2.3}
    :::

4.  [Return
    output_string.[¶](#section-4.2.6-2.4){.pilcrow}]{#section-4.2.6-2.4}
:::
:::

::: {#parse-binary}
::: {#section-4.2.7 .section}
#### [4.2.7.](#section-4.2.7){.section-number .selfRef} [Parsing a Byte Sequence](#name-parsing-a-byte-sequence){.section-name .selfRef} {#name-parsing-a-byte-sequence}

Given an ASCII string as input_string, return a Byte Sequence.
input_string is modified to remove the parsed
value.[¶](#section-4.2.7-1){.pilcrow}

1.  [If the first character of input_string is not \":\", fail
    parsing.[¶](#section-4.2.7-2.1){.pilcrow}]{#section-4.2.7-2.1}
2.  [Discard the first character of
    input_string.[¶](#section-4.2.7-2.2){.pilcrow}]{#section-4.2.7-2.2}
3.  [If there is not a \":\" character before the end of input_string,
    fail parsing.[¶](#section-4.2.7-2.3){.pilcrow}]{#section-4.2.7-2.3}
4.  [Let b64_content be the result of consuming content of input_string
    up to but not including the first instance of the character
    \":\".[¶](#section-4.2.7-2.4){.pilcrow}]{#section-4.2.7-2.4}
5.  [Consume the \":\" character at the beginning of
    input_string.[¶](#section-4.2.7-2.5){.pilcrow}]{#section-4.2.7-2.5}
6.  [If b64_content contains a character not included in ALPHA, DIGIT,
    \"+\", \"/\", and \"=\", fail
    parsing.[¶](#section-4.2.7-2.6){.pilcrow}]{#section-4.2.7-2.6}
7.  [Let binary_content be the result of base64-decoding
    \[[RFC4648](#RFC4648){.xref}\] b64_content, synthesizing padding if
    necessary (note the requirements about recipient behavior below). If
    base64 decoding fails, parsing
    fails.[¶](#section-4.2.7-2.7){.pilcrow}]{#section-4.2.7-2.7}
8.  [Return
    binary_content.[¶](#section-4.2.7-2.8){.pilcrow}]{#section-4.2.7-2.8}

Because some implementations of base64 do not allow rejection of encoded
data that is not properly \"=\" padded (see
\[[RFC4648](#RFC4648){.xref}\], [Section
3.2](https://www.rfc-editor.org/rfc/rfc4648#section-3.2){.relref}),
parsers [SHOULD NOT]{.bcp14} fail when \"=\" padding is not present,
unless they cannot be configured to do
so.[¶](#section-4.2.7-3){.pilcrow}

Because some implementations of base64 do not allow rejection of encoded
data that has non-zero pad bits (see \[[RFC4648](#RFC4648){.xref}\],
[Section
3.5](https://www.rfc-editor.org/rfc/rfc4648#section-3.5){.relref}),
parsers [SHOULD NOT]{.bcp14} fail when non-zero pad bits are present,
unless they cannot be configured to do
so.[¶](#section-4.2.7-4){.pilcrow}

This specification does not relax the requirements in
\[[RFC4648](#RFC4648){.xref}\], Sections
[3.1](https://www.rfc-editor.org/rfc/rfc4648#section-3.1){.relref} and
[3.3](https://www.rfc-editor.org/rfc/rfc4648#section-3.3){.relref};
therefore, parsers [MUST]{.bcp14} fail on characters outside the base64
alphabet and on line feeds in encoded
data.[¶](#section-4.2.7-5){.pilcrow}
:::
:::

::: {#parse-boolean}
::: {#section-4.2.8 .section}
#### [4.2.8.](#section-4.2.8){.section-number .selfRef} [Parsing a Boolean](#name-parsing-a-boolean){.section-name .selfRef} {#name-parsing-a-boolean}

Given an ASCII string as input_string, return a Boolean. input_string is
modified to remove the parsed value.[¶](#section-4.2.8-1){.pilcrow}

1.  [If the first character of input_string is not \"?\", fail
    parsing.[¶](#section-4.2.8-2.1){.pilcrow}]{#section-4.2.8-2.1}
2.  [Discard the first character of
    input_string.[¶](#section-4.2.8-2.2){.pilcrow}]{#section-4.2.8-2.2}
3.  [If the first character of input_string matches \"1\", discard the
    first character, and return
    true.[¶](#section-4.2.8-2.3){.pilcrow}]{#section-4.2.8-2.3}
4.  [If the first character of input_string matches \"0\", discard the
    first character, and return
    false.[¶](#section-4.2.8-2.4){.pilcrow}]{#section-4.2.8-2.4}
5.  [No value has matched; fail
    parsing.[¶](#section-4.2.8-2.5){.pilcrow}]{#section-4.2.8-2.5}
:::
:::
:::
:::
:::
:::

::: {#iana-considerations}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-5-1){.pilcrow}
:::
:::

::: {#security-considerations}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

The size of most types defined by Structured Fields is not limited; as a
result, extremely large fields could be an attack vector (e.g., for
resource consumption). Most HTTP implementations limit the sizes of
individual fields as well as the overall header or trailer section size
to mitigate such attacks.[¶](#section-6-1){.pilcrow}

It is possible for parties with the ability to inject new HTTP fields to
change the meaning of a Structured Field. In some circumstances, this
will cause parsing to fail, but it is not possible to reliably fail in
all such circumstances.[¶](#section-6-2){.pilcrow}
:::
:::

::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC0020\]
:   [Cerf, V.]{.refAuthor}, [\"ASCII format for network
    interchange\"]{.refTitle}, [STD 80]{.seriesInfo}, [RFC
    20]{.seriesInfo}, [DOI 10.17487/RFC0020]{.seriesInfo}, October 1969,
    \<<https://www.rfc-editor.org/info/rfc20>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC4648\]
:   [Josefsson, S.]{.refAuthor}, [\"The Base16, Base32, and Base64 Data
    Encodings\"]{.refTitle}, [RFC 4648]{.seriesInfo}, [DOI
    10.17487/RFC4648]{.seriesInfo}, October 2006,
    \<<https://www.rfc-editor.org/info/rfc4648>\>.
:   

\[RFC5234\]
:   [Crocker, D., Ed.]{.refAuthor}[ and P. Overell]{.refAuthor},
    [\"Augmented BNF for Syntax Specifications: ABNF\"]{.refTitle}, [STD
    68]{.seriesInfo}, [RFC 5234]{.seriesInfo}, [DOI
    10.17487/RFC5234]{.seriesInfo}, January 2008,
    \<<https://www.rfc-editor.org/info/rfc5234>\>.
:   

\[RFC7230\]
:   [Fielding, R., Ed.]{.refAuthor}[ and J. Reschke, Ed.]{.refAuthor},
    [\"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and
    Routing\"]{.refTitle}, [RFC 7230]{.seriesInfo}, [DOI
    10.17487/RFC7230]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7230>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   
:::

::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[IEEE754\]
:   [IEEE]{.refAuthor}, [\"IEEE Standard for Floating-Point
    Arithmetic\"]{.refTitle}, [DOI
    10.1109/IEEESTD.2019.8766229]{.seriesInfo}, [IEEE
    754-2019]{.seriesInfo}, July 2019,
    \<<https://ieeexplore.ieee.org/document/8766229>\>.
:   

\[RFC7231\]
:   [Fielding, R., Ed.]{.refAuthor}[ and J. Reschke, Ed.]{.refAuthor},
    [\"Hypertext Transfer Protocol (HTTP/1.1): Semantics and
    Content\"]{.refTitle}, [RFC 7231]{.seriesInfo}, [DOI
    10.17487/RFC7231]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7231>\>.
:   

\[RFC7493\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The I-JSON Message
    Format\"]{.refTitle}, [RFC 7493]{.seriesInfo}, [DOI
    10.17487/RFC7493]{.seriesInfo}, March 2015,
    \<<https://www.rfc-editor.org/info/rfc7493>\>.
:   

\[RFC7540\]
:   [Belshe, M.]{.refAuthor}[, Peon, R.]{.refAuthor}[, and M. Thomson,
    Ed.]{.refAuthor}, [\"Hypertext Transfer Protocol Version 2
    (HTTP/2)\"]{.refTitle}, [RFC 7540]{.seriesInfo}, [DOI
    10.17487/RFC7540]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7540>\>.
:   

\[RFC7541\]
:   [Peon, R.]{.refAuthor}[ and H. Ruellan]{.refAuthor}, [\"HPACK:
    Header Compression for HTTP/2\"]{.refTitle}, [RFC
    7541]{.seriesInfo}, [DOI 10.17487/RFC7541]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7541>\>.
:   

\[RFC8259\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The JavaScript Object Notation
    (JSON) Data Interchange Format\"]{.refTitle}, [STD 90]{.seriesInfo},
    [RFC 8259]{.seriesInfo}, [DOI 10.17487/RFC8259]{.seriesInfo},
    December 2017, \<<https://www.rfc-editor.org/info/rfc8259>\>.
:   

\[STD63\]
:   [Yergeau, F.]{.refAuthor}, [\"UTF-8, a transformation format of ISO
    10646\"]{.refTitle}, [STD 63]{.seriesInfo}, [RFC 3629]{.seriesInfo},
    November 2003, \<<https://www.rfc-editor.org/info/std63>\>.
:   
:::
:::

::: {#faq}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Frequently Asked Questions](#name-frequently-asked-questions){.section-name .selfRef} {#name-frequently-asked-questions}

::: {#why-not-json}
::: {#section-a.1 .section}
## [A.1.](#section-a.1){.section-number .selfRef} [Why Not JSON?](#name-why-not-json){.section-name .selfRef} {#name-why-not-json}

Earlier proposals for Structured Fields were based upon JSON
\[[RFC8259](#RFC8259){.xref}\]. However, constraining its use to make it
suitable for HTTP header fields required senders and recipients to
implement specific additional handling.[¶](#section-a.1-1){.pilcrow}

For example, JSON has specification issues around large numbers and
objects with duplicate members. Although advice for avoiding these
issues is available (e.g., \[[RFC7493](#RFC7493){.xref}\]), it cannot be
relied upon.[¶](#section-a.1-2){.pilcrow}

Likewise, JSON strings are by default Unicode strings, which have a
number of potential interoperability issues (e.g., in comparison).
Although implementers can be advised to avoid non-ASCII content where
unnecessary, this is difficult to enforce.[¶](#section-a.1-3){.pilcrow}

Another example is JSON\'s ability to nest content to arbitrary depths.
Since the resulting memory commitment might be unsuitable (e.g., in
embedded and other limited server deployments), it\'s necessary to limit
it in some fashion; however, existing JSON implementations have no such
limits, and even if a limit is specified, it\'s likely that some field
definition will find a need to violate it.[¶](#section-a.1-4){.pilcrow}

Because of JSON\'s broad adoption and implementation, it is difficult to
impose such additional constraints across all implementations; some
deployments would fail to enforce them, thereby harming
interoperability. In short, if it looks like JSON, people will be
tempted to use a JSON parser/serializer on field
values.[¶](#section-a.1-5){.pilcrow}

Since a major goal for Structured Fields is to improve interoperability
and simplify implementation, these concerns led to a format that
requires a dedicated parser and serializer.[¶](#section-a.1-6){.pilcrow}

Additionally, there were widely shared feelings that JSON doesn\'t
\"look right\" in HTTP fields.[¶](#section-a.1-7){.pilcrow}
:::
:::
:::
:::

::: {#implementation-notes}
::: {#section-appendix.b .section}
## [Appendix B.](#section-appendix.b){.section-number .selfRef} [Implementation Notes](#name-implementation-notes){.section-name .selfRef} {#name-implementation-notes}

A generic implementation of this specification should expose the
top-level serialize ([Section 4.1](#text-serialize){.xref}) and parse
([Section 4.2](#text-parse){.xref}) functions. They need not be
functions; for example, it could be implemented as an object, with
methods for each of the different top-level
types.[¶](#section-appendix.b-1){.pilcrow}

For interoperability, it\'s important that generic implementations be
complete and follow the algorithms closely; see [Section
1.1](#strict){.xref}. To aid this, a common test suite is being
maintained by the community at
\<<https://github.com/httpwg/structured-field-tests>\>.[¶](#section-appendix.b-2){.pilcrow}

Implementers should note that Dictionaries and Parameters are
order-preserving maps. Some fields may not convey meaning in the
ordering of these data types, but it should still be exposed so that it
will be available to applications that need to use
it.[¶](#section-appendix.b-3){.pilcrow}

Likewise, implementations should note that it\'s important to preserve
the distinction between Tokens and Strings. While most programming
languages have native types that map to the other types well, it may be
necessary to create a wrapper \"token\" object or use a parameter on
functions to assure that these types remain
separate.[¶](#section-appendix.b-4){.pilcrow}

The serialization algorithm is defined in a way that it is not strictly
limited to the data types defined in [Section 3](#types){.xref} in every
case. For example, Decimals are designed to take broader input and round
to allowed values.[¶](#section-appendix.b-5){.pilcrow}

Implementations are allowed to limit the size of different structures,
subject to the minimums defined for each type. When a structure exceeds
an implementation limit, that structure fails parsing or
serialization.[¶](#section-appendix.b-6){.pilcrow}
:::
:::

::: {#acknowledgements}
::: {#section-appendix.c .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

Many thanks to [Matthew Kerwin]{.contact-name} for his detailed feedback
and careful consideration during the development of this
specification.[¶](#section-appendix.c-1){.pilcrow}

Thanks also to [Ian Clelland]{.contact-name}, [Roy
Fielding]{.contact-name}, [Anne van Kesteren]{.contact-name}, [Kazuho
Oku]{.contact-name}, [Evert Pot]{.contact-name}, [Julian
Reschke]{.contact-name}, [Martin Thomson]{.contact-name}, [Mike
West]{.contact-name}, and [Jeffrey Yasskin]{.contact-name} for their
contributions.[¶](#section-appendix.c-2){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.d .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Mark Nottingham]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Fastly]{.org}
:::

::: {.left dir="auto"}
[Prahran]{.locality} [VIC]{.region}
:::

::: {.left dir="auto"}
[Australia]{.country-name}
:::

::: email
Email: <mnot@mnot.net>
:::

::: url
URI: <https://www.mnot.net/>
:::

::: {.left dir="auto"}
[Poul-Henning Kamp]{.fn .nameRole}
:::

::: {.left dir="auto"}
[The Varnish Cache Project]{.org}
:::

::: email
Email: <phk@varnish-cache.org>
:::
:::
:::
