  RFC 8724           LPWAN SCHC        April 2020
  ------------------ ----------------- ------------
  Minaburo, et al.   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8724](https://www.rfc-editor.org/rfc/rfc8724){.eref}

Category:
:   Standards Track

Published:
:   April 2020

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    A. Minaburo
    :::

    ::: org
    Acklio
    :::
    :::

    ::: author
    ::: author-name
    L. Toutain
    :::

    ::: org
    IMT Atlantique
    :::
    :::

    ::: author
    ::: author-name
    C. Gomez
    :::

    ::: org
    Universitat Politecnica de Catalunya
    :::
    :::

    ::: author
    ::: author-name
    D. Barthel
    :::

    ::: org
    Orange Labs
    :::
    :::

    ::: author
    ::: author-name
    JC. Zuniga
    :::

    ::: org
    SIGFOX
    :::
    :::
:::

# RFC 8724 {#rfcnum}

# SCHC: Generic Framework for Static Context Header Compression and Fragmentation {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document defines the Static Context Header Compression and
fragmentation (SCHC) framework, which provides both a header compression
mechanism and an optional fragmentation mechanism. SCHC has been
designed with Low-Power Wide Area Networks (LPWANs) in
mind.[¶](#section-abstract-1){.pilcrow}

SCHC compression is based on a common static context stored both in the
LPWAN device and in the network infrastructure side. This document
defines a generic header compression mechanism and its application to
compress IPv6/UDP headers.[¶](#section-abstract-2){.pilcrow}

This document also specifies an optional fragmentation and reassembly
mechanism. It can be used to support the IPv6 MTU requirement over the
LPWAN technologies. Fragmentation is needed for IPv6 datagrams that,
after SCHC compression or when such compression was not possible, still
exceed the Layer 2 maximum payload
size.[¶](#section-abstract-3){.pilcrow}

The SCHC header compression and fragmentation mechanisms are independent
of the specific LPWAN technology over which they are used. This document
defines generic functionalities and offers flexibility with regard to
parameter settings and mechanism choices. This document standardizes the
exchange over the LPWAN between two SCHC entities. Settings and choices
specific to a technology or a product are expected to be grouped into
profiles, which are specified in other documents. Data models for the
context and profiles are out of scope.[¶](#section-abstract-4){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8724>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Requirements
    Notation](#name-requirements-notation){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [LPWAN
    Architecture](#name-lpwan-architecture){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [SCHC
    Overview](#name-schc-overview){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [SCHC Packet
        Format](#name-schc-packet-format){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Functional
        Mapping](#name-functional-mapping){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [RuleID](#name-ruleid){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Compression/Decompression](#name-compression-decompression){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [SCHC C/D
        Rules](#name-schc-c-d-rules){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Packet
        Processing](#name-packet-processing){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Matching
        Operators](#name-matching-operators){.xref}[¶](#section-toc.1-1.7.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [Compression/Decompression Actions
        (CDA)](#name-compression-decompression-a){.xref}[¶](#section-toc.1-1.7.2.4.1){.pilcrow}

        -   ::: {#section-toc.1-1.7.2.4.2.1}
            [7.4.1](#section-7.4.1){.xref}.  [Processing Fixed-Length
            Fields](#name-processing-fixed-length-fie){.xref}[¶](#section-toc.1-1.7.2.4.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.7.2.4.2.2}
            [7.4.2](#section-7.4.2){.xref}.  [Processing Variable-Length
            Fields](#name-processing-variable-length-){.xref}[¶](#section-toc.1-1.7.2.4.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.7.2.4.2.3}
            [7.4.3](#section-7.4.3){.xref}.  [Not-Sent
            CDA](#name-not-sent-cda){.xref}[¶](#section-toc.1-1.7.2.4.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.7.2.4.2.4}
            [7.4.4](#section-7.4.4){.xref}.  [Value-Sent
            CDA](#name-value-sent-cda){.xref}[¶](#section-toc.1-1.7.2.4.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.7.2.4.2.5}
            [7.4.5](#section-7.4.5){.xref}.  [Mapping-Sent
            CDA](#name-mapping-sent-cda){.xref}[¶](#section-toc.1-1.7.2.4.2.5.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.7.2.4.2.6}
            [7.4.6](#section-7.4.6){.xref}.  [LSB
            CDA](#name-lsb-cda){.xref}[¶](#section-toc.1-1.7.2.4.2.6.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.7.2.4.2.7}
            [7.4.7](#section-7.4.7){.xref}.  [DevIID, AppIID
            CDA](#name-deviid-appiid-cda){.xref}[¶](#section-toc.1-1.7.2.4.2.7.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.7.2.4.2.8}
            [7.4.8](#section-7.4.8){.xref}.  [Compute-\*](#name-compute-){.xref}[¶](#section-toc.1-1.7.2.4.2.8.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Fragmentation/Reassembly](#name-fragmentation-reassembly){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Overview](#name-overview){.xref}[¶](#section-toc.1-1.8.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [SCHC F/R Protocol
        Elements](#name-schc-f-r-protocol-elements){.xref}[¶](#section-toc.1-1.8.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.8.2.2.2.1}
            [8.2.1](#section-8.2.1){.xref}.  [Messages](#name-messages){.xref}[¶](#section-toc.1-1.8.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.2.2.2}
            [8.2.2](#section-8.2.2){.xref}.  [Tiles, Windows, Bitmaps,
            Timers,
            Counters](#name-tiles-windows-bitmaps-timer){.xref}[¶](#section-toc.1-1.8.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.2.2.3}
            [8.2.3](#section-8.2.3){.xref}.  [Integrity
            Checking](#name-integrity-checking){.xref}[¶](#section-toc.1-1.8.2.2.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.2.2.4}
            [8.2.4](#section-8.2.4){.xref}.  [Header
            Fields](#name-header-fields){.xref}[¶](#section-toc.1-1.8.2.2.2.4.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [8.3](#section-8.3){.xref}.  [SCHC F/R Message
        Formats](#name-schc-f-r-message-formats){.xref}[¶](#section-toc.1-1.8.2.3.1){.pilcrow}

        -   ::: {#section-toc.1-1.8.2.3.2.1}
            [8.3.1](#section-8.3.1){.xref}.  [SCHC Fragment
            Format](#name-schc-fragment-format){.xref}[¶](#section-toc.1-1.8.2.3.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.3.2.2}
            [8.3.2](#section-8.3.2){.xref}.  [SCHC ACK
            Format](#name-schc-ack-format){.xref}[¶](#section-toc.1-1.8.2.3.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.3.2.3}
            [8.3.3](#section-8.3.3){.xref}.  [SCHC ACK REQ
            Format](#name-schc-ack-req-format){.xref}[¶](#section-toc.1-1.8.2.3.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.3.2.4}
            [8.3.4](#section-8.3.4){.xref}.  [SCHC Sender-Abort
            Format](#name-schc-sender-abort-format){.xref}[¶](#section-toc.1-1.8.2.3.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.3.2.5}
            [8.3.5](#section-8.3.5){.xref}.  [SCHC Receiver-Abort
            Format](#name-schc-receiver-abort-format){.xref}[¶](#section-toc.1-1.8.2.3.2.5.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.8.2.4}
        [8.4](#section-8.4){.xref}.  [SCHC F/R
        Modes](#name-schc-f-r-modes){.xref}[¶](#section-toc.1-1.8.2.4.1){.pilcrow}

        -   ::: {#section-toc.1-1.8.2.4.2.1}
            [8.4.1](#section-8.4.1){.xref}.  [No-ACK
            Mode](#name-no-ack-mode){.xref}[¶](#section-toc.1-1.8.2.4.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.4.2.2}
            [8.4.2](#section-8.4.2){.xref}.  [ACK-Always
            Mode](#name-ack-always-mode){.xref}[¶](#section-toc.1-1.8.2.4.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.4.2.3}
            [8.4.3](#section-8.4.3){.xref}.  [ACK-on-Error
            Mode](#name-ack-on-error-mode){.xref}[¶](#section-toc.1-1.8.2.4.2.3.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Padding
    Management](#name-padding-management){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [SCHC Compression for IPv6 and UDP
    Headers](#name-schc-compression-for-ipv6-a){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}

    -   ::: {#section-toc.1-1.10.2.1}
        [10.1](#section-10.1){.xref}.  [IPv6 Version
        Field](#name-ipv6-version-field){.xref}[¶](#section-toc.1-1.10.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [10.2](#section-10.2){.xref}.  [IPv6 Traffic Class
        Field](#name-ipv6-traffic-class-field){.xref}[¶](#section-toc.1-1.10.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.3}
        [10.3](#section-10.3){.xref}.  [Flow Label
        Field](#name-flow-label-field){.xref}[¶](#section-toc.1-1.10.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.4}
        [10.4](#section-10.4){.xref}.  [Payload Length
        Field](#name-payload-length-field){.xref}[¶](#section-toc.1-1.10.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.5}
        [10.5](#section-10.5){.xref}.  [Next Header
        Field](#name-next-header-field){.xref}[¶](#section-toc.1-1.10.2.5.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.6}
        [10.6](#section-10.6){.xref}.  [Hop Limit
        Field](#name-hop-limit-field){.xref}[¶](#section-toc.1-1.10.2.6.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.7}
        [10.7](#section-10.7){.xref}.  [IPv6 Addresses
        Fields](#name-ipv6-addresses-fields){.xref}[¶](#section-toc.1-1.10.2.7.1){.pilcrow}

        -   ::: {#section-toc.1-1.10.2.7.2.1}
            [10.7.1](#section-10.7.1){.xref}.  [IPv6 Source and
            Destination
            Prefixes](#name-ipv6-source-and-destination){.xref}[¶](#section-toc.1-1.10.2.7.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.10.2.7.2.2}
            [10.7.2](#section-10.7.2){.xref}.  [IPv6 Source and
            Destination
            IID](#name-ipv6-source-and-destination-){.xref}[¶](#section-toc.1-1.10.2.7.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.10.2.8}
        [10.8](#section-10.8){.xref}.  [IPv6 Extension
        Headers](#name-ipv6-extension-headers){.xref}[¶](#section-toc.1-1.10.2.8.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.9}
        [10.9](#section-10.9){.xref}.  [UDP Source and Destination
        Ports](#name-udp-source-and-destination-){.xref}[¶](#section-toc.1-1.10.2.9.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.10}
        [10.10](#section-10.10){.xref}. [UDP Length
        Field](#name-udp-length-field){.xref}[¶](#section-toc.1-1.10.2.10.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.11}
        [10.11](#section-10.11){.xref}. [UDP Checksum
        Field](#name-udp-checksum-field){.xref}[¶](#section-toc.1-1.10.2.11.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}

    -   ::: {#section-toc.1-1.12.2.1}
        [12.1](#section-12.1){.xref}.  [Security Considerations for SCHC
        Compression/Decompression](#name-security-considerations-for){.xref}[¶](#section-toc.1-1.12.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.12.2.1.2.1}
            [12.1.1](#section-12.1.1){.xref}.  [Forged SCHC
            Packet](#name-forged-schc-packet){.xref}[¶](#section-toc.1-1.12.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.12.2.1.2.2}
            [12.1.2](#section-12.1.2){.xref}.  [Compressed Packet Size
            as a Side Channel to Guess a Secret
            Token](#name-compressed-packet-size-as-a){.xref}[¶](#section-toc.1-1.12.2.1.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.12.2.1.2.3}
            [12.1.3](#section-12.1.3){.xref}.  [Decompressed Packet
            Different from the Original
            Packet](#name-decompressed-packet-differe){.xref}[¶](#section-toc.1-1.12.2.1.2.3.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [12.2](#section-12.2){.xref}.  [Security Considerations for SCHC
        Fragmentation/Reassembly](#name-security-considerations-for-){.xref}[¶](#section-toc.1-1.12.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.12.2.2.2.1}
            [12.2.1](#section-12.2.1){.xref}.  [Buffer Reservation
            Attack](#name-buffer-reservation-attack){.xref}[¶](#section-toc.1-1.12.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.12.2.2.2.2}
            [12.2.2](#section-12.2.2){.xref}.  [Corrupt Fragment
            Attack](#name-corrupt-fragment-attack){.xref}[¶](#section-toc.1-1.12.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.12.2.2.2.3}
            [12.2.3](#section-12.2.3){.xref}.  [Fragmentation as a Way
            to Bypass Network
            Inspection](#name-fragmentation-as-a-way-to-b){.xref}[¶](#section-toc.1-1.12.2.2.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.12.2.2.2.4}
            [12.2.4](#section-12.2.4){.xref}.  [Privacy Issues
            Associated with SCHC Header
            Fields](#name-privacy-issues-associated-w){.xref}[¶](#section-toc.1-1.12.2.2.2.4.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [13](#section-13){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}

    -   ::: {#section-toc.1-1.13.2.1}
        [13.1](#section-13.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.13.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.13.2.2}
        [13.2](#section-13.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.13.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.14}
    [Appendix A](#section-appendix.a){.xref}.  [Compression
    Examples](#name-compression-examples){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.15}
    [Appendix B](#section-appendix.b){.xref}.  [Fragmentation
    Examples](#name-fragmentation-examples){.xref}[¶](#section-toc.1-1.15.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.16}
    [Appendix C](#section-appendix.c){.xref}.  [Fragmentation State
    Machines](#name-fragmentation-state-machine){.xref}[¶](#section-toc.1-1.16.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.17}
    [Appendix D](#section-appendix.d){.xref}.  [SCHC
    Parameters](#name-schc-parameters){.xref}[¶](#section-toc.1-1.17.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.18}
    [Appendix E](#section-appendix.e){.xref}.  [Supporting Multiple
    Window Sizes for
    Fragmentation](#name-supporting-multiple-window-){.xref}[¶](#section-toc.1-1.18.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.19}
    [Appendix F](#section-appendix.f){.xref}.  [ACK-Always and
    ACK-on-Error on Quasi-Bidirectional
    Links](#name-ack-always-and-ack-on-error){.xref}[¶](#section-toc.1-1.19.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.20}
    [](#section-appendix.g){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.20.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.21}
    [](#section-appendix.h){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.21.1){.pilcrow}
    :::
:::
:::

::: {#Introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

This document defines the Static Context Header Compression and
fragmentation (SCHC) framework, which provides both a header compression
mechanism and an optional fragmentation mechanism. SCHC has been
designed with Low-Power Wide Area Networks (LPWANs) in
mind.[¶](#section-1-1){.pilcrow}

LPWAN technologies impose some strict limitations on traffic. For
instance, devices sleep most of the time and may only receive data
during short periods of time after transmission, in order to preserve
battery. LPWAN technologies are also characterized by a greatly reduced
data unit and/or payload size (see
\[[RFC8376](#RFC8376){.xref}\]).[¶](#section-1-2){.pilcrow}

Header compression is needed for efficient Internet connectivity to a
node within an LPWAN. The following properties of LPWANs can be
exploited to get an efficient header
compression:[¶](#section-1-3){.pilcrow}

-   [The network topology is star-oriented, which means that all packets
    between the same source-destination pair follow the same path. For
    the needs of this document, the architecture can simply be described
    as Devices (Dev) exchanging information with LPWAN Application
    Servers (Apps) through a Network Gateway
    (NGW).[¶](#section-1-4.1){.pilcrow}]{#section-1-4.1}
-   [Because devices embed built-in applications, the traffic flows to
    be compressed are known in advance. Indeed, new applications are
    less frequently installed in an LPWAN device than they are in a
    general-purpose computer or
    smartphone.[¶](#section-1-4.2){.pilcrow}]{#section-1-4.2}

SCHC compression uses a Context (a set of Rules) in which information
about header fields is stored. This Context is static: the values of the
header fields and the actions to do compression/decompression do not
change over time. This avoids the need for complex resynchronization
mechanisms. Indeed, a return path may be more restricted/expensive, or
may sometimes be completely unavailable \[[RFC8376](#RFC8376){.xref}\].
A compression protocol that relies on feedback is not compatible with
the characteristics of such LPWANs.[¶](#section-1-5){.pilcrow}

In most cases, a small Rule identifier is enough to represent the full
IPv6/UDP headers. The SCHC header compression mechanism is independent
of the specific LPWAN technology over which it is
used.[¶](#section-1-6){.pilcrow}

Furthermore, some LPWAN technologies do not provide a fragmentation
functionality; to support the IPv6 MTU requirement of 1280 bytes
\[[RFC8200](#RFC8200){.xref}\], they require a fragmentation protocol at
the adaptation layer below IPv6. Accordingly, this document defines an
optional fragmentation/reassembly mechanism to help LPWAN technologies
support the IPv6 MTU requirement.[¶](#section-1-7){.pilcrow}

This document defines generic functionality and offers flexibility with
regard to parameter settings and mechanism choices. Technology-specific
settings are expected to be grouped into Profiles specified in other
documents.[¶](#section-1-8){.pilcrow}
:::
:::

::: {#requirements-notation}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Requirements Notation](#name-requirements-notation){.section-name .selfRef} {#name-requirements-notation}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}
:::
:::

::: {#LPWAN-Archi}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [LPWAN Architecture](#name-lpwan-architecture){.section-name .selfRef} {#name-lpwan-architecture}

LPWAN architectures are similar among them, but each LPWAN technology
names architecture elements differently. In this document, we use
terminology from \[[RFC8376](#RFC8376){.xref}\], which identifies the
following entities in a typical LPWAN (see [Figure
1](#Fig-LPWANarchi){.xref}):[¶](#section-3-1){.pilcrow}

-   [Devices (Dev) are the end-devices or hosts (e.g., sensors,
    actuators, etc.). There can be a very high density of devices per
    Radio Gateway.[¶](#section-3-2.1){.pilcrow}]{#section-3-2.1}
-   [The Radio Gateway (RGW) is the endpoint of the constrained
    link.[¶](#section-3-2.2){.pilcrow}]{#section-3-2.2}
-   [The Network Gateway (NGW) is the interconnection node between the
    Radio Gateway and the
    Internet.[¶](#section-3-2.3){.pilcrow}]{#section-3-2.3}
-   [The Application Server (App) is the endpoint of the
    application-level protocol on the Internet
    side.[¶](#section-3-2.4){.pilcrow}]{#section-3-2.4}

[]{#name-lpwan-architecture-simplifi}

::: {#Fig-LPWANarchi}
::: {#section-3-3.1 .artwork .art-text .alignLeft}
     ()   ()   ()       |
      ()  () () ()     / \       +---------+
    () () () () () () /   \======|    ^    |             +-----------+
     ()  ()   ()     |           | <--|--> |             |Application|
    ()  ()  ()  ()  / \==========|    v    |=============|   Server  |
      ()  ()  ()   /   \         +---------+             +-----------+
     Dev            RGWs             NGW                      App
:::

[Figure 1](#figure-1){.selfRef}: [LPWAN Architecture (Simplified from
That Shown in RFC 8376)](#name-lpwan-architecture-simplifi){.selfRef}
:::
:::
:::

::: {#Term}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

This section defines terminology and abbreviations used in this
document. It extends the terminology of
\[[RFC8376](#RFC8376){.xref}\].[¶](#section-4-1){.pilcrow}

The SCHC acronym is pronounced like \"sheek\" in English (or \"chic\" in
French). Therefore, this document writes \"a SCHC Packet\" instead of
\"an SCHC Packet\".[¶](#section-4-2){.pilcrow}

App:
:   LPWAN Application Server, as defined by
    \[[RFC8376](#RFC8376){.xref}\]. It runs an application
    sending/receiving packets to/from the
    Dev.[¶](#section-4-3.2){.pilcrow}
:   

AppIID:
:   Application Interface Identifier. The IID that identifies the App
    interface.[¶](#section-4-3.4){.pilcrow}
:   

Compression Residue:
:   The bits that remain to be sent (beyond the RuleID itself) after
    applying the SCHC compression.[¶](#section-4-3.6){.pilcrow}
:   

Context:
:   A set of Rules used to compress/decompress headers, or to
    fragment/reassemble a packet.[¶](#section-4-3.8){.pilcrow}
:   

Dev:
:   Device, as defined by
    \[[RFC8376](#RFC8376){.xref}\].[¶](#section-4-3.10){.pilcrow}
:   

DevIID:
:   Device Interface Identifier. The IID that identifies the Dev
    interface.[¶](#section-4-3.12){.pilcrow}
:   

Downlink:
:   From the App to the Dev.[¶](#section-4-3.14){.pilcrow}
:   

IID:
:   Interface Identifier. See the IPv6 addressing architecture
    \[[RFC7136](#RFC7136){.xref}\].[¶](#section-4-3.16){.pilcrow}
:   

L2:
:   Layer 2. The immediate lower layer that SCHC interfaces with, for
    example an underlying LPWAN technology. It does not necessarily
    correspond to the OSI model definition of Layer
    2.[¶](#section-4-3.18){.pilcrow}
:   

L2 Word:
:   This is the minimum subdivision of payload data that the L2 will
    carry. In most L2 technologies, the L2 Word is an octet. In
    bit-oriented radio technologies, the L2 Word might be a single bit.
    The L2 Word size is assumed to be constant over time for each
    device.[¶](#section-4-3.20){.pilcrow}
:   

Padding:
:   Extra bits that may be appended by SCHC to a data unit that it
    passes down to L2 for transmission. SCHC itself operates on bits,
    not bytes, and does not have any alignment prerequisite. See
    [Section 9](#Padding){.xref}.[¶](#section-4-3.22){.pilcrow}
:   

Profile:
:   SCHC offers variations in the way it is operated, with a number of
    parameters listed in [Appendix D](#SCHCParams){.xref}. A Profile
    indicates a particular setting of all these parameters. Both ends of
    a SCHC communication must be provisioned with the same Profile
    information and with the same set of Rules before the communication
    starts, so that there is no ambiguity in how they expect to
    communicate.[¶](#section-4-3.24){.pilcrow}
:   

Rule:
:   Part of the Context that describes how a packet is
    compressed/decompressed or
    fragmented/reassembled.[¶](#section-4-3.26){.pilcrow}
:   

RuleID:
:   Rule Identifier. An identifier for a
    Rule.[¶](#section-4-3.28){.pilcrow}
:   

SCHC:
:   Static Context Header Compression and fragmentation (SCHC), a
    generic framework.[¶](#section-4-3.30){.pilcrow}
:   

SCHC C/D:
:   SCHC Compressor/Decompressor, or SCHC Compression/Decompression. The
    SCHC entity or mechanism used on both sides, at the Dev and at the
    network, to achieve compression/decompression of
    headers.[¶](#section-4-3.32){.pilcrow}
:   

SCHC F/R:
:   SCHC Fragmenter/Reassembler or SCHC Fragmentation/Reassembly. The
    SCHC entity or mechanism used on both sides, at the Dev and at the
    network, to achieve fragmentation/reassembly of SCHC
    Packets.[¶](#section-4-3.34){.pilcrow}
:   

SCHC Packet:
:   A packet (e.g., an IPv6 packet) whose header has been compressed as
    per the header compression mechanism defined in this document. If
    the header compression process is unable to actually compress the
    packet header, the packet with the uncompressed header is still
    called a SCHC Packet (in this case, a RuleID is used to indicate
    that the packet header has not been compressed). See [Section
    7](#SCHComp){.xref} for more details.[¶](#section-4-3.36){.pilcrow}
:   

Uplink:
:   From the Dev to the App.[¶](#section-4-3.38){.pilcrow}
:   

Additional terminology for the optional SCHC F/R is found in [Section
8.2](#FragTools){.xref}.[¶](#section-4-4){.pilcrow}

Additional terminology for SCHC C/D is found in [Section
7.1](#schc-cd-rules){.xref}.[¶](#section-4-5){.pilcrow}
:::
:::

::: {#Overview}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [SCHC Overview](#name-schc-overview){.section-name .selfRef} {#name-schc-overview}

SCHC can be characterized as an adaptation layer between an upper layer
(for example, IPv6) and an underlying layer (for example, an LPWAN
technology). SCHC comprises two sublayers (i.e., the Compression
sublayer and the Fragmentation sublayer), as shown in [Figure
2](#Fig-IntroLayers){.xref}.[¶](#section-5-1){.pilcrow}

[]{#name-example-of-protocol-stack-c}

::: {#Fig-IntroLayers}
::: {#section-5-2.1 .artwork .art-text .alignLeft}
                 +----------------+
                 |      IPv6      |
              +- +----------------+
              |  |   Compression  |
        SCHC <   +----------------+
              |  |  Fragmentation |
              +- +----------------+
                 |LPWAN technology|
                 +----------------+
:::

[Figure 2](#figure-2){.selfRef}: [Example of Protocol Stack Comprising
IPv6, SCHC, and an LPWAN
Technology](#name-example-of-protocol-stack-c){.selfRef}
:::

Before an upper layer packet (e.g., an IPv6 packet) is transmitted to
the underlying layer, header compression is first attempted. The
resulting packet is called a \"SCHC Packet\", whether or not any
compression is performed. If needed by the underlying layer, the
optional SCHC fragmentation [MAY]{.bcp14} be applied to the SCHC Packet.
The inverse operations take place at the receiver. This process is
illustrated in [Figure
3](#Fig-Operations){.xref}.[¶](#section-5-3){.pilcrow}

[]{#name-schc-operations-at-the-send}

::: {#Fig-Operations}
::: {#section-5-4.1 .artwork .art-text .alignLeft}
    A packet (e.g., an IPv6 packet)
             |                                           ^
             v                                           |
    +------------------+                      +--------------------+
    | SCHC Compression |                      | SCHC Decompression |
    +------------------+                      +--------------------+
             |                                           ^
             |   If no fragmentation (*)                 |
             +-------------- SCHC Packet  -------------->|
             |                                           |
             v                                           |
    +--------------------+                       +-----------------+
    | SCHC Fragmentation |                       | SCHC Reassembly |
    +--------------------+                       +-----------------+
          |     ^                                     |     ^
          |     |                                     |     |
          |     +---------- SCHC ACK (+) -------------+     |
          |                                                 |
          +-------------- SCHC Fragments -------------------+

            Sender                                    Receiver

    *: the decision not to use SCHC fragmentation is left to each Profile
    +: optional, depends on Fragmentation mode
:::

[Figure 3](#figure-3){.selfRef}: [SCHC Operations at the Sender and the
Receiver](#name-schc-operations-at-the-send){.selfRef}
:::

::: {#schc-packet-format}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [SCHC Packet Format](#name-schc-packet-format){.section-name .selfRef} {#name-schc-packet-format}

The SCHC Packet is composed of the Compressed Header followed by the
payload from the original packet (see [Figure 4](#Fig-SCHCpckt){.xref}).
The Compressed Header itself is composed of the RuleID and a Compression
Residue, which is the output of compressing the packet header with the
Rule identified by that RuleID (see [Section 7](#SCHComp){.xref}). The
Compression Residue may be empty. Both the RuleID and the Compression
Residue potentially have a variable size, and are not necessarily a
multiple of bytes in size.[¶](#section-5.1-1){.pilcrow}

[]{#name-schc-packet}

::: {#Fig-SCHCpckt}
::: {#section-5.1-2.1 .artwork .art-text .alignLeft}
    |------- Compressed Header -------|
    +---------------------------------+--------------------+
    |  RuleID  |  Compression Residue |      Payload       |
    +---------------------------------+--------------------+
:::

[Figure 4](#figure-4){.selfRef}: [SCHC
Packet](#name-schc-packet){.selfRef}
:::
:::
:::

::: {#FunctionalMapping}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Functional Mapping](#name-functional-mapping){.section-name .selfRef} {#name-functional-mapping}

[Figure 5](#Fig-archi){.xref} maps the functional elements of [Figure
3](#Fig-Operations){.xref} onto the LPWAN architecture elements of
[Figure 1](#Fig-LPWANarchi){.xref}.[¶](#section-5.2-1){.pilcrow}

[]{#name-architectural-mapping}

::: {#Fig-archi}
::: {#section-5.2-2.1 .artwork .art-text .alignLeft}
            Dev                                               App
    +----------------+                               +----+ +----+ +----+
    | App1 App2 App3 |                               |App1| |App2| |App3|
    |                |                               |    | |    | |    |
    |       UDP      |                               |UDP | |UDP | |UDP |
    |      IPv6      |                               |IPv6| |IPv6| |IPv6|
    |                |                               |    | |    | |    |
    |SCHC C/D and F/R|                               |    | |    | |    |
    +--------+-------+                               +----+ +----+ +----+
             |  +---+     +---+    +----+    +----+    .      .      .
             +~ |RGW| === |NGW| == |SCHC| == |SCHC|..... Internet ....
                +---+     +---+    |F/R |    |C/D |
                                   +----+    +----+
:::

[Figure 5](#figure-5){.selfRef}: [Architectural
Mapping](#name-architectural-mapping){.selfRef}
:::

SCHC C/D and SCHC F/R are located on both sides of the LPWAN
transmission, hereafter called the \"Dev side\" and the \"Network
Infrastructure side\".[¶](#section-5.2-3){.pilcrow}

The operation in the Uplink direction is as follows. The Device
application uses IPv6 or IPv6/UDP protocols. Before sending the packets,
the Dev compresses their headers using SCHC C/D; if the SCHC Packet
resulting from the compression needs to be fragmented by SCHC, SCHC F/R
is performed (see [Section 8](#Frag){.xref}). The resulting SCHC
Fragments are sent to an LPWAN Radio Gateway (RGW), which forwards them
to a Network Gateway (NGW). The NGW sends the data to a SCHC F/R for
reassembly (if needed) and then to the SCHC C/D for decompression. After
decompression, the packet can be sent over the Internet to one or
several Apps.[¶](#section-5.2-4){.pilcrow}

The SCHC F/R and SCHC C/D on the Network Infrastructure side can be part
of the NGW or located in the Internet as long as a tunnel is established
between them and the NGW. For some LPWAN technologies, it may be
suitable to locate the SCHC F/R functionality nearer the NGW, in order
to better deal with time constraints of such
technologies.[¶](#section-5.2-5){.pilcrow}

The SCHC C/Ds on both sides [MUST]{.bcp14} share the same set of Rules.
So [MUST]{.bcp14} the SCHC F/Rs on both
sides.[¶](#section-5.2-6){.pilcrow}

The operation in the Downlink direction is similar to that in the Uplink
direction, only reversing the order in which the architecture elements
are traversed.[¶](#section-5.2-7){.pilcrow}
:::
:::
:::
:::

::: {#RuleID}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [RuleID](#name-ruleid){.section-name .selfRef} {#name-ruleid}

RuleIDs identify the Rules used for compression/decompression or for
fragmentation/reassembly.[¶](#section-6-1){.pilcrow}

The scope of the RuleID of a compression/decompression Rule is the link
between the SCHC C/D in a given Dev and the corresponding SCHC C/D in
the Network Infrastructure side. The scope of the RuleID of a
fragmentation/reassembly Rule is the link between the SCHC F/R in a
given Dev and the corresponding SCHC F/R in the Network Infrastructure
side. If such a link is bidirectional, the scope includes both
directions.[¶](#section-6-2){.pilcrow}

The RuleIDs are therefore specific to the Context related to one Dev.
Hence, multiple Dev instances, which refer to different Contexts,
[MAY]{.bcp14} reuse the same RuleID for different Rules. On the Network
Infrastructure side, in order to identify the correct Rule to be applied
to Uplink traffic, the SCHC C/D or SCHC F/R needs to associate the
RuleID with the Dev identifier. Similarly, for Downlink traffic, the
SCHC C/D or SCHC F/R on the Network Infrastructure side first needs to
identify the destination Dev before looking for the appropriate Rule
(and associated RuleID) in the Context of that
Dev.[¶](#section-6-3){.pilcrow}

Inside their scopes, Rules for compression/decompression and Rules for
fragmentation/reassembly share the same RuleID
space.[¶](#section-6-4){.pilcrow}

The size of the RuleIDs is not specified in this document, as it is
implementation-specific and can vary according to the LPWAN technology
and the number of Rules, among other things. It is defined in
Profiles.[¶](#section-6-5){.pilcrow}

The RuleIDs are used:[¶](#section-6-6){.pilcrow}

-   ::: {#section-6-7.1}
    For SCHC C/D, to identify the Rule that is used to compress a packet
    header.[¶](#section-6-7.1.1){.pilcrow}

    -   [At least one RuleID [MUST]{.bcp14} be allocated to tagging
        packets for which SCHC compression was not possible (i.e., no
        matching compression Rule was
        found).[¶](#section-6-7.1.2.1){.pilcrow}]{#section-6-7.1.2.1}
    :::

-   ::: {#section-6-7.2}
    In SCHC F/R, to identify the specific mode and settings of
    fragmentation/reassembly for one direction of data traffic (Uplink
    or Downlink).[¶](#section-6-7.2.1){.pilcrow}

    -   [When SCHC F/R is used for both communication directions, at
        least two RuleID values are needed for fragmentation/reassembly:
        one per direction of data traffic. This is because
        fragmentation/reassembly may entail control messages flowing in
        the reverse direction compared to data
        traffic.[¶](#section-6-7.2.2.1){.pilcrow}]{#section-6-7.2.2.1}
    :::
:::
:::

::: {#SCHComp}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Compression/Decompression](#name-compression-decompression){.section-name .selfRef} {#name-compression-decompression}

Compression with SCHC is based on using a set of Rules, which
constitutes the Context of SCHC C/D, to compress or decompress headers.
SCHC avoids Context synchronization traffic, which consumes considerable
bandwidth in other header compression mechanisms such as RObust Header
Compression (RoHC) \[[RFC5795](#RFC5795){.xref}\]. Since the content of
packets is highly predictable in LPWANs, static Contexts can be stored
beforehand. The Contexts [MUST]{.bcp14} be stored at both ends, and they
can be learned by a provisioning protocol, by out-of-band means, or by
pre-provisioning. The way the Contexts are provisioned is out of the
scope of this document.[¶](#section-7-1){.pilcrow}

::: {#schc-cd-rules}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [SCHC C/D Rules](#name-schc-c-d-rules){.section-name .selfRef} {#name-schc-c-d-rules}

The main idea of the SCHC compression scheme is to transmit the RuleID
to the other end instead of sending known field values. This RuleID
identifies a Rule that matches the original packet values. Hence, when a
value is known by both ends, it is only necessary to send the
corresponding RuleID over the LPWAN. The manner by which Rules are
generated is out of the scope of this document. The Rules [MAY]{.bcp14}
be changed at run-time, but the mechanism is out of scope of this
document.[¶](#section-7.1-1){.pilcrow}

The SCHC C/D Context is a set of Rules. See [Figure 6](#Fig-ctxt){.xref}
for a high-level, abstract representation of the Context. The formal
specification of the representation of the Rules is outside the scope of
this document.[¶](#section-7.1-2){.pilcrow}

Each Rule itself contains a list of Field Descriptors composed of a
Field Identifier (FID), a Field Length (FL), a Field Position (FP), a
Direction Indicator (DI), a Target Value (TV), a Matching Operator (MO),
and a Compression/Decompression Action
(CDA).[¶](#section-7.1-3){.pilcrow}

[]{#name-a-schc-c-d-context}

::: {#Fig-ctxt}
::: {#section-7.1-4.1 .artwork .art-text .alignLeft}
      /-----------------------------------------------------------------\
      |                         Rule N                                  |
     /-----------------------------------------------------------------\|
     |                       Rule i                                    ||
    /-----------------------------------------------------------------\||
    |  (FID)            Rule 1                                        |||
    |+-------+--+--+--+------------+-----------------+---------------+|||
    ||Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
    |+-------+--+--+--+------------+-----------------+---------------+|||
    ||Field 2|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
    |+-------+--+--+--+------------+-----------------+---------------+|||
    ||...    |..|..|..|   ...      | ...             | ...           ||||
    |+-------+--+--+--+------------+-----------------+---------------+||/
    ||Field N|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act|||
    |+-------+--+--+--+------------+-----------------+---------------+|/
    |                                                                 |
    \-----------------------------------------------------------------/
:::

[Figure 6](#figure-6){.selfRef}: [A SCHC C/D
Context](#name-a-schc-c-d-context){.selfRef}
:::

A Rule does not describe how the compressor parses a packet header to
find and identify each field (e.g., the IPv6 Source Address, the UDP
Destination Port, or a CoAP URI path option). It is assumed that there
is a protocol parser alongside SCHC that is able to identify all the
fields encountered in the headers to be compressed, and to label them
with a Field ID. Rules only describe the compression/decompression
behavior for each header field, after it has been
identified.[¶](#section-7.1-5){.pilcrow}

In a Rule, the Field Descriptors are listed in the order in which the
fields appear in the packet header. The Field Descriptors describe the
header fields with the following entries:[¶](#section-7.1-6){.pilcrow}

-   [Field Identifier (FID) designates a protocol and field (e.g., UDP
    Destination Port), unambiguously among all protocols that a SCHC
    compressor processes. In the presence of protocol nesting, the Field
    ID also identifies the
    nesting.[¶](#section-7.1-7.1){.pilcrow}]{#section-7.1-7.1}

-   [Field Length (FL) represents the length of the original field. It
    can be either a fixed value (in bits) if the length is known when
    the Rule is created or a type if the length is variable. The length
    of a header field is defined by its own protocol specification
    (e.g., IPv6 or UDP). If the length is variable, the type defines the
    process to compute the length and its unit (bits,
    bytes\...).[¶](#section-7.1-7.2){.pilcrow}]{#section-7.1-7.2}

-   [Field Position (FP): most often, a field only occurs once in a
    packet header. However, some fields may occur multiple times. An
    example is the uri-path of CoAP. FP indicates which occurrence this
    Field Descriptor applies to. The default value is 1. The value 1
    designates the first occurrence. The value 0 is special. It means
    \"don\'t care\", see [Section
    7.2](#PProcessing){.xref}.[¶](#section-7.1-7.3){.pilcrow}]{#section-7.1-7.3}

-   ::: {#section-7.1-7.4}
    A Direction Indicator (DI) indicates the packet direction(s) this
    Field Descriptor applies to. It allows for asymmetric processing,
    using the same Rule. Three values are
    possible:[¶](#section-7.1-7.4.1){.pilcrow}

    Up:
    :   this Field Descriptor is only applicable to packets traveling
        Uplink.[¶](#section-7.1-7.4.2.2){.pilcrow}
    :   

    Dw:
    :   this Field Descriptor is only applicable to packets traveling
        Downlink.[¶](#section-7.1-7.4.2.4){.pilcrow}
    :   

    Bi:
    :   this Field Descriptor is applicable to packets traveling Uplink
        or Downlink.[¶](#section-7.1-7.4.2.6){.pilcrow}
    :   
    :::

-   [Target Value (TV) is the value used to match against the packet
    header field. The Target Value can be a scalar value of any type
    (integer, strings, etc.) or a more complex structure (array, list,
    etc.). The types and representations are out of scope for this
    document.[¶](#section-7.1-7.5){.pilcrow}]{#section-7.1-7.5}

-   [Matching Operator (MO) is the operator used to match the field
    value and the Target Value. The Matching Operator may require some
    parameters. The set of MOs defined in this document can be found in
    [Section
    7.3](#chap-MO){.xref}.[¶](#section-7.1-7.6){.pilcrow}]{#section-7.1-7.6}

-   [Compression/Decompression Action (CDA) describes the pair of
    actions that are performed at the compressor to compress a header
    field and at the decompressor to recover the original value of the
    header field. Some CDAs might use parameter values for their
    operation. The set of CDAs defined in this document can be found in
    [Section
    7.4](#chap-CDA){.xref}.[¶](#section-7.1-7.7){.pilcrow}]{#section-7.1-7.7}
:::
:::

::: {#PProcessing}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Packet Processing](#name-packet-processing){.section-name .selfRef} {#name-packet-processing}

The compression/decompression process follows several
phases:[¶](#section-7.2-1){.pilcrow}

Compression Rule selection:

:   the general idea is to browse the Rule set to find a Rule that has a
    matching Field Descriptor (given the DI and FP) for all and only
    those header fields that appear in the packet being compressed. The
    detailed algorithm is the
    following:[¶](#section-7.2-2.2.1){.pilcrow}

    -   [The first step is to check the FIDs. If any header field of the
        packet being examined cannot be matched with a Field Descriptor
        with the correct FID, the Rule [MUST]{.bcp14} be disregarded. If
        any Field Descriptor in the Rule has a FID that cannot be
        matched to one of the header fields of the packet being
        examined, the Rule [MUST]{.bcp14} be
        disregarded.[¶](#section-7.2-2.2.2.1){.pilcrow}]{#section-7.2-2.2.2.1}

    -   [The next step is to match the Field Descriptors by their
        direction, using the DI. If any field of the packet header
        cannot be matched with a Field Descriptor with the correct FID
        and DI, the Rule [MUST]{.bcp14} be
        disregarded.[¶](#section-7.2-2.2.2.2){.pilcrow}]{#section-7.2-2.2.2.2}

    -   ::: {#section-7.2-2.2.2.3}
        Then, the Field Descriptors are further selected according to
        FP. If any field of the packet header cannot be matched with a
        Field Descriptor with the correct FID, DI and FP, the Rule
        [MUST]{.bcp14} be
        disregarded.[¶](#section-7.2-2.2.2.3.1){.pilcrow}

        The value 0 for FP means \"don\'t care\", i.e., the comparison
        of this Field Descriptor\'s FP with the position of the field of
        the packet header being compressed returns True, whatever that
        position. FP=0 can be useful to build compression Rules for
        protocol headers in which some fields order is irrelevant. An
        example could be uri-queries in CoAP. Care needs to be exercised
        when writing Rules containing FP=0 values. Indeed, it may result
        in decompressed packets having fields ordered differently
        compared to the original
        packet.[¶](#section-7.2-2.2.2.3.2){.pilcrow}
        :::

    -   ::: {#section-7.2-2.2.2.4}
        Once each header field has been associated with a Field
        Descriptor with matching FID, DI, and FP, each packet field\'s
        value is then compared to the corresponding TV stored in the
        Rule for that specific field, using the MO. If every field in
        the packet header satisfies the corresponding MOs of a Rule
        (i.e., all MO results are True), that Rule is valid for use to
        compress the header. Otherwise, the Rule [MUST]{.bcp14} be
        disregarded.[¶](#section-7.2-2.2.2.4.1){.pilcrow}

        This specification does not prevent multiple Rules from matching
        the above steps and, therefore, being valid for use. Which Rule
        to use among multiple valid Rules is left to the implementation.
        As long as the same Rule set is installed at both ends, this
        degree of freedom does not constitute an interoperability
        issue.[¶](#section-7.2-2.2.2.4.2){.pilcrow}
        :::

    -   [If no valid compression Rule is found, then the packet
        [MUST]{.bcp14} be sent uncompressed using the RuleID dedicated
        to this purpose (see [Section 6](#RuleID){.xref}). The entire
        packet header is the Compression Residue (see [Figure
        4](#Fig-SCHCpckt){.xref}). Sending an uncompressed header is
        likely to require SCHC
        F/R.[¶](#section-7.2-2.2.2.5){.pilcrow}]{#section-7.2-2.2.2.5}

:   

Compression:
:   if a valid Rule is found, each field of the header is compressed
    according to the CDAs of the Rule. The fields are compressed in the
    order that the Field Descriptors appear in the Rule. The compression
    of each field results in a residue, which may be empty. The
    Compression Residue for the packet header is the concatenation of
    the non-empty residues for each field of the header, in the order
    the Field Descriptors appear in the Rule. The order in which the
    Field Descriptors appear in the Rule is therefore semantically
    important.[¶](#section-7.2-2.4){.pilcrow}
:   

[]{#name-compression-residue-structu}

::: {#Fig-CompRes}
::: {#section-7.2-3.1 .artwork .art-text .alignLeft}
        |------------------- Compression Residue -------------------|
        +-----------------+-----------------+-----+-----------------+
        | field 1 residue | field 2 residue | ... | field N residue |
        +-----------------+-----------------+-----+-----------------+
:::

[Figure 7](#figure-7){.selfRef}: [Compression Residue
Structure](#name-compression-residue-structu){.selfRef}
:::

Sending:
:   The RuleID is sent to the other end jointly with the Compression
    Residue (which could be empty) or the uncompressed header, and
    directly followed by the payload (see [Figure
    4](#Fig-SCHCpckt){.xref}). The way the RuleID is sent will be
    specified in the Profile and is out of the scope of the present
    document. For example, it could be included in an L2 header or sent
    as part of the L2 payload.[¶](#section-7.2-4.2){.pilcrow}
:   

Decompression:

:   when decompressing, on the Network Infrastructure side, the SCHC C/D
    needs to find the correct Rule based on the L2 address of the Dev. 
    On the Dev side, only the RuleID is needed to identify the correct
    Rule since the Dev typically only holds Rules that apply to
    itself.[¶](#section-7.2-4.4.1){.pilcrow}

    This Rule describes the compressed header format. From this, the
    decompressor determines the order of the residues, the fixed-size or
    variable-size nature of each residue (see [Section
    7.4.2](#var-length-field){.xref}), and the size of the fixed-size
    residues.[¶](#section-7.2-4.4.2){.pilcrow}

    Therefore, from the received compressed header, it can retrieve all
    the residue values and associate them to the corresponding header
    fields.[¶](#section-7.2-4.4.3){.pilcrow}

    For each field in the header, the receiver applies the CDA action
    associated with that field in order to reconstruct the original
    header field value. The CDA application order can be different from
    the order in which the fields are listed in the Rule. In particular,
    Compute-\* [MUST]{.bcp14} be applied after the application of the
    CDAs of all the fields it computes
    on.[¶](#section-7.2-4.4.4){.pilcrow}

:   
:::
:::

::: {#chap-MO}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Matching Operators](#name-matching-operators){.section-name .selfRef} {#name-matching-operators}

MOs are functions used at the compression side of SCHC C/D. They are not
typed and can be applied to integer, string or any other data type. The
result of the operation can either be True or False. The following MOs
are defined:[¶](#section-7.3-1){.pilcrow}

equal:
:   The match result is True if the field value in the packet matches
    the TV.[¶](#section-7.3-2.2){.pilcrow}
:   

ignore:
:   No matching is attempted between the field value in the packet and
    the TV in the Rule. The result is always
    True.[¶](#section-7.3-2.4){.pilcrow}
:   

MSB(x):
:   A match is obtained if the most significant (leftmost) x bits of the
    packet header field value are equal to the TV in the Rule. The x
    parameter of the MSB MO indicates how many bits are involved in the
    comparison. If the FL is described as variable, the x parameter must
    be a multiple of the FL unit. For example, x must be multiple of 8
    if the unit of the variable length is
    bytes.[¶](#section-7.3-2.6){.pilcrow}
:   

match-mapping:
:   With match-mapping, TV is a list of values. Each value of the list
    is identified by an index. Compression is achieved by sending the
    index instead of the original header field value. This operator
    matches if the header field value is equal to one of the values in
    the target list.[¶](#section-7.3-2.8){.pilcrow}
:   
:::
:::

::: {#chap-CDA}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [Compression/Decompression Actions (CDA)](#name-compression-decompression-a){.section-name .selfRef} {#name-compression-decompression-a}

The CDA specifies the actions taken during the compression of header
fields and the inverse action taken by the decompressor to restore the
original value. The CDAs defined by this document are described in
detail in [Section 7.4.3](#NotSentCDA){.xref} to [Section
7.4.8](#compute-){.xref}. They are summarized in [Table
1](#Fig-function){.xref}.[¶](#section-7.4-1){.pilcrow}

[]{#name-compression-and-decompressi}

::: {#Fig-function}
  Action         Compression                         Decompression
  -------------- ----------------------------------- -----------------------------------
  not-sent       elided                              use TV stored in Rule
  value-sent     send                                use received value
  mapping-sent   send index                          retrieve value from TV list
  LSB            send least significant bits (LSB)   concatenate TV and received value
  compute-\*     elided                              recompute at decompressor
  DevIID         elided                              build IID from L2 Dev addr
  AppIID         elided                              build IID from L2 App addr

  : [Table 1](#table-1){.selfRef}: [Compression and Decompression
  Actions](#name-compression-and-decompressi){.selfRef}
:::

The first column shows the action\'s name. The second and third columns
show the compression and decompression behaviors for each
action.[¶](#section-7.4-3){.pilcrow}

::: {#fixed-length-field}
::: {#section-7.4.1 .section}
#### [7.4.1.](#section-7.4.1){.section-number .selfRef} [Processing Fixed-Length Fields](#name-processing-fixed-length-fie){.section-name .selfRef} {#name-processing-fixed-length-fie}

If the field is identified in the Field Descriptor as being of fixed
length, then applying the CDA to compress this field results in a fixed
amount of bits. The residue for that field is simply the bits resulting
from applying the CDA to the field. This value may be empty (e.g.,
not-sent CDA), in which case the field residue is absent from the
Compression Residue.[¶](#section-7.4.1-1){.pilcrow}

[]{#name-fixed-size-field-residue-st}

::: {#Fig-FieldResFixLength}
::: {#section-7.4.1-2.1 .artwork .art-text .alignLeft}
    |- field residue -|
    +-----------------+
    |      value      |
    +-----------------+
:::

[Figure 8](#figure-8){.selfRef}: [Fixed-Size Field Residue
Structure](#name-fixed-size-field-residue-st){.selfRef}
:::
:::
:::

::: {#var-length-field}
::: {#section-7.4.2 .section}
#### [7.4.2.](#section-7.4.2){.section-number .selfRef} [Processing Variable-Length Fields](#name-processing-variable-length-){.section-name .selfRef} {#name-processing-variable-length-}

If the field is identified in the Field Descriptor as being of variable
length, then applying the CDA to compress this field may result in a
value of fixed size (e.g., not-sent or mapping-sent) or of variable size
(e.g., value-sent or LSB). In the latter case, the residue for that
field is the bits that result from applying the CDA to the field,
preceded with the size of the value. The most significant bit of the
size is stored to the left (leftmost bit of the residue
field).[¶](#section-7.4.2-1){.pilcrow}

[]{#name-variable-size-field-residue}

::: {#Fig-FieldResVarLength}
::: {#section-7.4.2-2.1 .artwork .art-text .alignLeft}
    |--- field residue ---|
    +-------+-------------+
    |  size |    value    |
    +-------+-------------+
:::

[Figure 9](#figure-9){.selfRef}: [Variable-Size Field Residue
Structure](#name-variable-size-field-residue){.selfRef}
:::

The size (using the unit defined in the FL) is encoded on 4, 12, or 28
bits as follows:[¶](#section-7.4.2-3){.pilcrow}

-   [If the size is between 0 and 14, it is encoded as a 4-bit unsigned
    integer.[¶](#section-7.4.2-4.1){.pilcrow}]{#section-7.4.2-4.1}
-   [Sizes between 15 and 254 are encoded as 0b1111 followed by the
    8-bit unsigned
    integer.[¶](#section-7.4.2-4.2){.pilcrow}]{#section-7.4.2-4.2}
-   [Larger sizes are encoded as 0xfff followed by the 16-bit unsigned
    integer.[¶](#section-7.4.2-4.3){.pilcrow}]{#section-7.4.2-4.3}

If the field is identified in the Field Descriptor as being of variable
length and this field is not present in the packet header being
compressed, size 0 [MUST]{.bcp14} be sent to denote its
absence.[¶](#section-7.4.2-5){.pilcrow}
:::
:::

::: {#NotSentCDA}
::: {#section-7.4.3 .section}
#### [7.4.3.](#section-7.4.3){.section-number .selfRef} [Not-Sent CDA](#name-not-sent-cda){.section-name .selfRef} {#name-not-sent-cda}

The not-sent action can be used when the field value is specified in a
Rule and, therefore, known by both the Compressor and the Decompressor.
This action [SHOULD]{.bcp14} be used with the \"equal\" MO. If MO is
\"ignore\", there is a risk of having a decompressed field value that is
different from the original field that was
compressed.[¶](#section-7.4.3-1){.pilcrow}

The compressor does not send any residue for a field on which not-sent
compression is applied.[¶](#section-7.4.3-2){.pilcrow}

The decompressor restores the field value with the TV stored in the
matched Rule identified by the received
RuleID.[¶](#section-7.4.3-3){.pilcrow}
:::
:::

::: {#value-sent-cda}
::: {#section-7.4.4 .section}
#### [7.4.4.](#section-7.4.4){.section-number .selfRef} [Value-Sent CDA](#name-value-sent-cda){.section-name .selfRef} {#name-value-sent-cda}

The value-sent action can be used when the field value is not known by
both the Compressor and the Decompressor. The field is sent in its
entirety, using the same bit order as in the original packet
header.[¶](#section-7.4.4-1){.pilcrow}

If this action is performed on a variable-length field, the size of the
residue value (using the units defined in FL) [MUST]{.bcp14} be sent as
described in [Section
7.4.2](#var-length-field){.xref}.[¶](#section-7.4.4-2){.pilcrow}

This action is generally used with the \"ignore\"
MO.[¶](#section-7.4.4-3){.pilcrow}
:::
:::

::: {#mapping-sent-cda}
::: {#section-7.4.5 .section}
#### [7.4.5.](#section-7.4.5){.section-number .selfRef} [Mapping-Sent CDA](#name-mapping-sent-cda){.section-name .selfRef} {#name-mapping-sent-cda}

The mapping-sent action is used to send an index (the index into the TV
list of values) instead of the original value. This action is used
together with the \"match-mapping\" MO.[¶](#section-7.4.5-1){.pilcrow}

On the compressor side, the match-mapping MO searches the TV for a match
with the header field value. The mapping-sent CDA then sends the
corresponding index as the field residue. The most significant bit of
the index is stored to the left (leftmost bit of the residue
field).[¶](#section-7.4.5-2){.pilcrow}

On the decompressor side, the CDA uses the received index to restore the
field value by looking up the list in the
TV.[¶](#section-7.4.5-3){.pilcrow}

The number of bits sent is the minimal size for coding all the possible
indices.[¶](#section-7.4.5-4){.pilcrow}

The first element in the list [MUST]{.bcp14} be represented by index
value 0, and successive elements in the list [MUST]{.bcp14} have indices
incremented by 1.[¶](#section-7.4.5-5){.pilcrow}
:::
:::

::: {#lsb-cda}
::: {#section-7.4.6 .section}
#### [7.4.6.](#section-7.4.6){.section-number .selfRef} [LSB CDA](#name-lsb-cda){.section-name .selfRef} {#name-lsb-cda}

The LSB action is used together with the \"MSB(x)\" MO to avoid sending
the most significant part of the packet field if that part is already
known by the receiving end.[¶](#section-7.4.6-1){.pilcrow}

The compressor sends the LSBs as the field residue value. The number of
bits sent is the original header field length minus the length specified
in the MSB(x) MO. The bits appear in the residue in the same bit order
as in the original packet header.[¶](#section-7.4.6-2){.pilcrow}

The decompressor concatenates the x most significant bits of the TV and
the received residue value.[¶](#section-7.4.6-3){.pilcrow}

If this action is performed on a variable-length field, the size of the
residue value (using the units defined in FL) [MUST]{.bcp14} be sent as
described in [Section
7.4.2](#var-length-field){.xref}.[¶](#section-7.4.6-4){.pilcrow}
:::
:::

::: {#deviid-appiid-cda}
::: {#section-7.4.7 .section}
#### [7.4.7.](#section-7.4.7){.section-number .selfRef} [DevIID, AppIID CDA](#name-deviid-appiid-cda){.section-name .selfRef} {#name-deviid-appiid-cda}

These actions are used to process the DevIID and AppIID of the IPv6
addresses, respectively. AppIID CDA is less common since most current
LPWAN technologies frames contain a single L2 address, which is the
Dev\'s address.[¶](#section-7.4.7-1){.pilcrow}

The DevIID value [MAY]{.bcp14} be computed from the Dev ID present in
the L2 header, or from some other stable identifier. The computation is
specific to each Profile and [MAY]{.bcp14} depend on the Dev ID
size.[¶](#section-7.4.7-2){.pilcrow}

In the Downlink direction, at the compressor, the DevIID CDA may be used
to generate the L2 addresses on the LPWAN, based on the packet\'s
Destination Address.[¶](#section-7.4.7-3){.pilcrow}
:::
:::

::: {#compute-}
::: {#section-7.4.8 .section}
#### [7.4.8.](#section-7.4.8){.section-number .selfRef} [Compute-\*](#name-compute-){.section-name .selfRef} {#name-compute-}

Some fields can be elided at the compressor and recomputed locally at
the decompressor.[¶](#section-7.4.8-1){.pilcrow}

Because the field is uniquely identified by its FID (e.g., IPv6 length),
the relevant protocol specification unambiguously defines the algorithm
for such computation.[¶](#section-7.4.8-2){.pilcrow}

An example of a field that knows how to recompute itself is IPv6
length.[¶](#section-7.4.8-3){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#Frag}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Fragmentation/Reassembly](#name-fragmentation-reassembly){.section-name .selfRef} {#name-fragmentation-reassembly}

::: {#overview}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Overview](#name-overview){.section-name .selfRef} {#name-overview}

In LPWAN technologies, the L2 MTU typically ranges from tens to hundreds
of bytes. Some of these technologies do not have an internal
fragmentation/reassembly mechanism.[¶](#section-8.1-1){.pilcrow}

The optional SCHC F/R functionality enables such LPWAN technologies to
comply with the IPv6 MTU requirement of 1280 bytes
\[[RFC8200](#RFC8200){.xref}\]. It is [OPTIONAL]{.bcp14} to implement
per this specification, but Profiles may specify that it is
[REQUIRED]{.bcp14}.[¶](#section-8.1-2){.pilcrow}

This specification includes several SCHC F/R modes, which allow for a
range of reliability options such as optional SCHC Fragment
retransmission. More modes may be defined in the
future.[¶](#section-8.1-3){.pilcrow}

The same SCHC F/R mode [MUST]{.bcp14} be used for all SCHC Fragments of
a given SCHC Packet. This document does not specify which mode(s) must
be implemented and used over a specific LPWAN technology. That
information will be given in Profiles.[¶](#section-8.1-4){.pilcrow}

SCHC allows transmitting non-fragmented SCHC Packet concurrently with
fragmented SCHC Packets. In addition, SCHC F/R provides protocol
elements that allow transmitting several fragmented SCHC Packets
concurrently, i.e., interleaving the transmission of fragments from
different fragmented SCHC Packets. A Profile [MAY]{.bcp14} restrict the
latter behavior.[¶](#section-8.1-5){.pilcrow}

The L2 Word size (see [Section 4](#Term){.xref}) determines the encoding
of some messages. SCHC F/R usually generates SCHC Fragments and SCHC
ACKs that are multiples of L2 Words.[¶](#section-8.1-6){.pilcrow}
:::
:::

::: {#FragTools}
::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [SCHC F/R Protocol Elements](#name-schc-f-r-protocol-elements){.section-name .selfRef} {#name-schc-f-r-protocol-elements}

This subsection describes the different elements that are used to enable
the SCHC F/R functionality defined in this document. These elements
include the SCHC F/R messages, tiles, windows, bitmaps, counters,
timers, and header fields.[¶](#section-8.2-1){.pilcrow}

The elements are described here in a generic manner. Their application
to each SCHC F/R mode is found in [Section
8.4](#FragModes){.xref}.[¶](#section-8.2-2){.pilcrow}

::: {#messages}
::: {#section-8.2.1 .section}
#### [8.2.1.](#section-8.2.1){.section-number .selfRef} [Messages](#name-messages){.section-name .selfRef} {#name-messages}

SCHC F/R defines the following messages:[¶](#section-8.2.1-1){.pilcrow}

SCHC Fragment:
:   A message that carries part of a SCHC Packet from the sender to the
    receiver.[¶](#section-8.2.1-2.2){.pilcrow}
:   

SCHC ACK:
:   An acknowledgement for fragmentation, by the receiver to the sender.
    This message is used to indicate whether or not the reception of
    pieces of, or the whole of, the fragmented SCHC Packet was
    successful.[¶](#section-8.2.1-2.4){.pilcrow}
:   

SCHC ACK REQ:
:   A request by the sender for a SCHC ACK from the
    receiver.[¶](#section-8.2.1-2.6){.pilcrow}
:   

SCHC Sender-Abort:
:   A message by the sender telling the receiver that it has aborted the
    transmission of a fragmented SCHC
    Packet.[¶](#section-8.2.1-2.8){.pilcrow}
:   

SCHC Receiver-Abort:
:   A message by the receiver to tell the sender to abort the
    transmission of a fragmented SCHC
    Packet.[¶](#section-8.2.1-2.10){.pilcrow}
:   

The format of these messages is provided in [Section
8.3](#Fragfor){.xref}.[¶](#section-8.2.1-3){.pilcrow}
:::
:::

::: {#OtherTools}
::: {#section-8.2.2 .section}
#### [8.2.2.](#section-8.2.2){.section-number .selfRef} [Tiles, Windows, Bitmaps, Timers, Counters](#name-tiles-windows-bitmaps-timer){.section-name .selfRef} {#name-tiles-windows-bitmaps-timer}

::: {#tiles}
::: {#section-8.2.2.1 .section}
##### [8.2.2.1.](#section-8.2.2.1){.section-number .selfRef} [Tiles](#name-tiles){.section-name .selfRef} {#name-tiles}

The SCHC Packet is fragmented into pieces, hereafter called \"tiles\".
The tiles [MUST]{.bcp14} be non-empty and pairwise disjoint. Their union
[MUST]{.bcp14} be equal to the SCHC
Packet.[¶](#section-8.2.2.1-1){.pilcrow}

See [Figure 10](#Fig-TilesExample){.xref} for an
example.[¶](#section-8.2.2.1-2){.pilcrow}

[]{#name-schc-packet-fragmented-in-t}

::: {#Fig-TilesExample}
::: {#section-8.2.2.1-3.1 .artwork .art-text .alignLeft}
                                    SCHC Packet
            +----+--+-----+---+----+-+---+-----+...-----+----+---+------+
    Tiles   |    |  |     |   |    | |   |     |        |    |   |      |
            +----+--+-----+---+----+-+---+-----+...-----+----+---+------+
:::

[Figure 10](#figure-10){.selfRef}: [SCHC Packet Fragmented in
Tiles](#name-schc-packet-fragmented-in-t){.selfRef}
:::

Modes (see [Section 8.4](#FragModes){.xref}) [MAY]{.bcp14} place
additional constraints on tile sizes.[¶](#section-8.2.2.1-4){.pilcrow}

Each SCHC Fragment message carries at least one tile in its Payload, if
the Payload field is present.[¶](#section-8.2.2.1-5){.pilcrow}
:::
:::

::: {#Windows}
::: {#section-8.2.2.2 .section}
##### [8.2.2.2.](#section-8.2.2.2){.section-number .selfRef} [Windows](#name-windows){.section-name .selfRef} {#name-windows}

Some SCHC F/R modes may handle successive tiles in groups, called
windows.[¶](#section-8.2.2.2-1){.pilcrow}

If windows are used:[¶](#section-8.2.2.2-2){.pilcrow}

-   [all the windows of a SCHC Packet, except the last one,
    [MUST]{.bcp14} contain the same number of tiles. This number is
    WINDOW_SIZE.[¶](#section-8.2.2.2-3.1){.pilcrow}]{#section-8.2.2.2-3.1}
-   [WINDOW_SIZE [MUST]{.bcp14} be specified in a
    Profile.[¶](#section-8.2.2.2-3.2){.pilcrow}]{#section-8.2.2.2-3.2}
-   [the windows are
    numbered.[¶](#section-8.2.2.2-3.3){.pilcrow}]{#section-8.2.2.2-3.3}
-   [their numbers [MUST]{.bcp14} increment by 1 from 0 upward, from the
    start of the SCHC Packet to its
    end.[¶](#section-8.2.2.2-3.4){.pilcrow}]{#section-8.2.2.2-3.4}
-   [the last window [MUST]{.bcp14} contain WINDOW_SIZE tiles or
    less.[¶](#section-8.2.2.2-3.5){.pilcrow}]{#section-8.2.2.2-3.5}
-   [tiles are numbered within each
    window.[¶](#section-8.2.2.2-3.6){.pilcrow}]{#section-8.2.2.2-3.6}
-   [the tile indices [MUST]{.bcp14} decrement by 1 from WINDOW_SIZE - 1
    downward, looking from the start of the SCHC Packet toward its
    end.[¶](#section-8.2.2.2-3.7){.pilcrow}]{#section-8.2.2.2-3.7}
-   [therefore, each tile of a SCHC Packet is uniquely identified by a
    window number and a tile index within this
    window.[¶](#section-8.2.2.2-3.8){.pilcrow}]{#section-8.2.2.2-3.8}

See [Figure 11](#Fig-WindowsExample){.xref} for an
example.[¶](#section-8.2.2.2-4){.pilcrow}

[]{#name-schc-packet-fragmented-in-ti}

::: {#Fig-WindowsExample}
::: {#section-8.2.2.2-5.1 .artwork .art-text .alignLeft}
            +---------------------------------------------...-----------+
            |                       SCHC Packet                         |
            +---------------------------------------------...-----------+

    Tile#   | 4 | 3 | 2 | 1 | 0 | 4 | 3 | 2 | 1 | 0 | 4 |     | 0 | 4 |3|
    Window# |-------- 0 --------|-------- 1 --------|- 2  ... 27 -|- 28-|
:::

[Figure 11](#figure-11){.selfRef}: [SCHC Packet Fragmented in Tiles
Grouped in 29 Windows, with WINDOW_SIZE =
5](#name-schc-packet-fragmented-in-ti){.selfRef}
:::

[Appendix E](#MultWinSizes){.xref} discusses the benefits of selecting
one among multiple window sizes depending on the size of the SCHC Packet
to be fragmented.[¶](#section-8.2.2.2-6){.pilcrow}

When windows are used:[¶](#section-8.2.2.2-7){.pilcrow}

-   [Bitmaps (see [Section 8.2.2.3](#Bitmap){.xref}) [MAY]{.bcp14} be
    sent back by the receiver to the sender in a SCHC ACK
    message.[¶](#section-8.2.2.2-8.1){.pilcrow}]{#section-8.2.2.2-8.1}
-   [A Bitmap corresponds to exactly one
    Window.[¶](#section-8.2.2.2-8.2){.pilcrow}]{#section-8.2.2.2-8.2}
:::
:::

::: {#Bitmap}
::: {#section-8.2.2.3 .section}
##### [8.2.2.3.](#section-8.2.2.3){.section-number .selfRef} [Bitmaps](#name-bitmaps){.section-name .selfRef} {#name-bitmaps}

Each bit in the Bitmap for a window corresponds to a tile in the window.
Therefore, each Bitmap has WINDOW_SIZE bits. The bit at the leftmost
position corresponds to the tile numbered WINDOW_SIZE - 1. Consecutive
bits, going right, correspond to sequentially decreasing tile indices.
In Bitmaps for windows that are not the last one of a SCHC Packet, the
bit at the rightmost position corresponds to the tile numbered 0. In the
Bitmap for the last window, the bit at the rightmost position
corresponds either to the tile numbered 0 or to a tile that is
sent/received as \"the last one of the SCHC Packet\" without explicitly
stating its number (see [Section
8.3.1.2](#LastFrag){.xref}).[¶](#section-8.2.2.3-1){.pilcrow}

At the receiver:[¶](#section-8.2.2.3-2){.pilcrow}

-   [a bit set to 1 in the Bitmap indicates that a tile associated with
    that bit position has been correctly received for that
    window.[¶](#section-8.2.2.3-3.1){.pilcrow}]{#section-8.2.2.3-3.1}
-   [a bit set to 0 in the Bitmap indicates that there has been no tile
    correctly received, associated with that bit position, for that
    window. Possible reasons include that the tile was not sent at all,
    not received, or received with
    errors.[¶](#section-8.2.2.3-3.2){.pilcrow}]{#section-8.2.2.3-3.2}
:::
:::

::: {#MiscTools}
::: {#section-8.2.2.4 .section}
##### [8.2.2.4.](#section-8.2.2.4){.section-number .selfRef} [Timers and Counters](#name-timers-and-counters){.section-name .selfRef} {#name-timers-and-counters}

Some SCHC F/R modes can use the following timers and
counters:[¶](#section-8.2.2.4-1){.pilcrow}

Inactivity Timer:
:   a SCHC Fragment receiver uses this timer to abort waiting for a SCHC
    F/R message.[¶](#section-8.2.2.4-2.2){.pilcrow}
:   

Retransmission Timer:
:   a SCHC Fragment sender uses this timer to abort waiting for an
    expected SCHC ACK.[¶](#section-8.2.2.4-2.4){.pilcrow}
:   

Attempts:
:   this counter counts the requests for SCHC ACKs, up to
    MAX_ACK_REQUESTS.[¶](#section-8.2.2.4-2.6){.pilcrow}
:   
:::
:::
:::
:::

::: {#IntegrityChecking}
::: {#section-8.2.3 .section}
#### [8.2.3.](#section-8.2.3){.section-number .selfRef} [Integrity Checking](#name-integrity-checking){.section-name .selfRef} {#name-integrity-checking}

The integrity of the fragmentation-reassembly process of a SCHC Packet
[MUST]{.bcp14} be checked at the receive end. A Profile [MUST]{.bcp14}
specify how integrity checking is
performed.[¶](#section-8.2.3-1){.pilcrow}

It is [RECOMMENDED]{.bcp14} that integrity checking be performed by
computing a Reassembly Check Sequence (RCS) based on the SCHC Packet at
the sender side and transmitting it to the receiver for comparison with
the RCS locally computed after
reassembly.[¶](#section-8.2.3-2){.pilcrow}

The RCS supports UDP checksum elision by SCHC C/D (see [Section
10.11](#UDPchecksum){.xref}).[¶](#section-8.2.3-3){.pilcrow}

The CRC32 polynomial 0xEDB88320 (i.e., the reversed polynomial
representation, which is used in the Ethernet standard
\[[ETHERNET](#ETHERNET){.xref}\]) is [RECOMMENDED]{.bcp14} as the
default algorithm for computing the RCS.[¶](#section-8.2.3-4){.pilcrow}

The RCS [MUST]{.bcp14} be computed on the full SCHC Packet concatenated
with the padding bits, if any, of the SCHC Fragment carrying the last
tile. The rationale is that the SCHC reassembler has no way of knowing
the boundary between the last tile and the padding bits. Indeed, this
requires decompressing the SCHC Packet, which is out of the scope of the
SCHC reassembler.[¶](#section-8.2.3-5){.pilcrow}

The concatenation of the complete SCHC Packet and any padding bits, if
present, of the last SCHC Fragment does not generally constitute an
integer number of bytes. CRC libraries are usually byte oriented. It is
[RECOMMENDED]{.bcp14} that the concatenation of the complete SCHC Packet
and any last fragment padding bits be zero-extended to the next byte
boundary and that the RCS be computed on that byte
array.[¶](#section-8.2.3-6){.pilcrow}
:::
:::

::: {#HeaderFields}
::: {#section-8.2.4 .section}
#### [8.2.4.](#section-8.2.4){.section-number .selfRef} [Header Fields](#name-header-fields){.section-name .selfRef} {#name-header-fields}

The SCHC F/R messages contain the following fields (see the formats in
[Section 8.3](#Fragfor){.xref}):[¶](#section-8.2.4-1){.pilcrow}

RuleID:

:   this field is present in all the SCHC F/R messages. The Rule
    identifies:[¶](#section-8.2.4-2.2.1){.pilcrow}

    -   [that a SCHC F/R message is being carried, as opposed to an
        unfragmented SCHC
        Packet,[¶](#section-8.2.4-2.2.2.1){.pilcrow}]{#section-8.2.4-2.2.2.1}
    -   [which SCHC F/R mode is
        used,[¶](#section-8.2.4-2.2.2.2){.pilcrow}]{#section-8.2.4-2.2.2.2}
    -   [in case this mode uses windows, what the value of WINDOW_SIZE
        is,
        and[¶](#section-8.2.4-2.2.2.3){.pilcrow}]{#section-8.2.4-2.2.2.3}
    -   [what other optional fields are present and what the field sizes
        are.[¶](#section-8.2.4-2.2.2.4){.pilcrow}]{#section-8.2.4-2.2.2.4}

    The Rule tells apart a non-fragmented SCHC Packet from SCHC
    Fragments. It will also tell apart SCHC Fragments of fragmented SCHC
    Packets that use different SCHC F/R modes or different parameters.
    Therefore, interleaved transmission of these is
    possible.[¶](#section-8.2.4-2.2.3){.pilcrow}

    All SCHC F/R messages pertaining to the same SCHC Packet
    [MUST]{.bcp14} bear the same
    RuleID.[¶](#section-8.2.4-2.2.4){.pilcrow}

:   

Datagram Tag (DTag):

:   This field allows differentiating SCHC F/R messages belonging to
    different SCHC Packets that may be using the same RuleID
    simultaneously. Hence, it allows interleaving fragments of a new
    SCHC Packet with fragments of a previous SCHC Packet under the same
    RuleID.[¶](#section-8.2.4-2.4.1){.pilcrow}

    The size of the DTag field (called \"T\", in bits) is defined by
    each Profile for each RuleID. When T is 0, the DTag field does not
    appear in the SCHC F/R messages and the DTag value is defined as
    0.[¶](#section-8.2.4-2.4.2){.pilcrow}

    When T is 0, there can be no more than one fragmented SCHC Packet in
    transit for each fragmentation
    RuleID.[¶](#section-8.2.4-2.4.3){.pilcrow}

    If T is not 0, DTag:[¶](#section-8.2.4-2.4.4){.pilcrow}

    -   [[MUST]{.bcp14} be set to the same value for all the SCHC F/R
        messages related to the same fragmented SCHC Packet,
        and[¶](#section-8.2.4-2.4.5.1){.pilcrow}]{#section-8.2.4-2.4.5.1}
    -   [[MUST]{.bcp14} be set to different values for SCHC F/R messages
        related to different SCHC Packets that are being fragmented
        under the same RuleID and whose transmission may
        overlap.[¶](#section-8.2.4-2.4.5.2){.pilcrow}]{#section-8.2.4-2.4.5.2}

:   

W:

:   The W field is optional. It is only present if windows are used. Its
    presence and size (called \"M\", in bits) is defined by each SCHC
    F/R mode and each Profile for each
    RuleID.[¶](#section-8.2.4-2.6.1){.pilcrow}

    This field carries information pertaining to the window a SCHC F/R
    message relates to. If present, W [MUST]{.bcp14} carry the same
    value for all the SCHC F/R messages related to the same window.
    Depending on the mode and Profile, W may carry the full window
    number, or just the LSB or any other partial representation of the
    window number.[¶](#section-8.2.4-2.6.2){.pilcrow}

:   

Fragment Compressed Number (FCN):

:   The FCN field is present in the SCHC Fragment Header. Its size
    (called \"N\", in bits) is defined by each Profile for each
    RuleID.[¶](#section-8.2.4-2.8.1){.pilcrow}

    This field conveys information about the progress in the sequence of
    tiles being transmitted by SCHC Fragment messages. For example, it
    can contain a partial, efficient representation of a larger-sized
    tile index. The description of the exact use of the FCN field is
    left to each SCHC F/R mode. However, two values are reserved for
    special purposes. They help control the SCHC F/R
    process:[¶](#section-8.2.4-2.8.2){.pilcrow}

    -   [The FCN value with all the bits equal to 1 (called \"All-1\")
        signals that the very last tile of a SCHC Packet has been
        transmitted. By extension, if windows are used, the last window
        of a packet is called the \"All-1\"
        window.[¶](#section-8.2.4-2.8.3.1){.pilcrow}]{#section-8.2.4-2.8.3.1}
    -   [If windows are used, the FCN value with all the bits equal to 0
        (called \"All-0\") signals the last tile of a window that is not
        the last one of the SCHC packet. By extension, such a window is
        called an \"All-0
        window\".[¶](#section-8.2.4-2.8.3.2){.pilcrow}]{#section-8.2.4-2.8.3.2}

:   

Reassembly Check Sequence (RCS):

:   This field only appears in the All-1 SCHC Fragments. Its size
    (called \"U\", in bits) is defined by each Profile for each
    RuleID.[¶](#section-8.2.4-2.10.1){.pilcrow}

    See [Section 8.2.3](#IntegrityChecking){.xref} for the RCS default
    size, default polynomial and details on RCS
    computation.[¶](#section-8.2.4-2.10.2){.pilcrow}

:   

C (integrity Check):

:   C is a 1-bit field. This field is used in the SCHC ACK message to
    report on the reassembled SCHC Packet integrity check (see [Section
    8.2.3](#IntegrityChecking){.xref}).[¶](#section-8.2.4-2.12.1){.pilcrow}

    A value of 1 tells that the integrity check was performed and is
    successful. A value of 0 tells that the integrity check was not
    performed or that it was a
    failure.[¶](#section-8.2.4-2.12.2){.pilcrow}

:   

Compressed Bitmap:

:   The Compressed Bitmap is used together with windows and Bitmaps (see
    [Section 8.2.2.3](#Bitmap){.xref}). Its presence and size is defined
    for each SCHC F/R mode for each
    RuleID.[¶](#section-8.2.4-2.14.1){.pilcrow}

    This field appears in the SCHC ACK message to report on the receiver
    Bitmap (see [Section
    8.3.2.1](#BitmapTrunc){.xref}).[¶](#section-8.2.4-2.14.2){.pilcrow}

:   
:::
:::
:::
:::

::: {#Fragfor}
::: {#section-8.3 .section}
### [8.3.](#section-8.3){.section-number .selfRef} [SCHC F/R Message Formats](#name-schc-f-r-message-formats){.section-name .selfRef} {#name-schc-f-r-message-formats}

This section defines the SCHC Fragment formats, the SCHC ACK format, the
SCHC ACK REQ format and the SCHC Abort
formats.[¶](#section-8.3-1){.pilcrow}

::: {#schc-fragment-format}
::: {#section-8.3.1 .section}
#### [8.3.1.](#section-8.3.1){.section-number .selfRef} [SCHC Fragment Format](#name-schc-fragment-format){.section-name .selfRef} {#name-schc-fragment-format}

A SCHC Fragment conforms to the general format shown in [Figure
12](#Fig-FragFormat){.xref}. It comprises a SCHC Fragment Header and a
SCHC Fragment Payload. The SCHC Fragment Payload carries one or several
tile(s).[¶](#section-8.3.1-1){.pilcrow}

[]{#name-schc-fragment-general-forma}

::: {#Fig-FragFormat}
::: {#section-8.3.1-2.1 .artwork .art-text .alignLeft}
    +-----------------+-----------------------+~~~~~~~~~~~~~~~~~~~~~
    | Fragment Header | Fragment Payload      | padding (as needed)
    +-----------------+-----------------------+~~~~~~~~~~~~~~~~~~~~~
:::

[Figure 12](#figure-12){.selfRef}: [SCHC Fragment General
Format](#name-schc-fragment-general-forma){.selfRef}
:::

::: {#NotLastFrag}
::: {#section-8.3.1.1 .section}
##### [8.3.1.1.](#section-8.3.1.1){.section-number .selfRef} [Regular SCHC Fragment](#name-regular-schc-fragment){.section-name .selfRef} {#name-regular-schc-fragment}

The Regular SCHC Fragment format is shown in [Figure
13](#Fig-NotLastFrag){.xref}. Regular SCHC Fragments are generally used
to carry tiles that are not the last one of a SCHC Packet. The DTag
field and the W field are [OPTIONAL]{.bcp14}, their presence is
specified by each mode and Profile.[¶](#section-8.3.1.1-1){.pilcrow}

[]{#name-detailed-header-format-for-}

::: {#Fig-NotLastFrag}
::: {#section-8.3.1.1-2.1 .artwork .art-text .alignLeft}
    |-- SCHC Fragment Header ----|
             |-- T --|-M-|-- N --|
    +-- ... -+- ... -+---+- ... -+--------...-------+~~~~~~~~~~~~~~~~~~~~
    | RuleID | DTag  | W |  FCN  | Fragment Payload | padding (as needed)
    +-- ... -+- ... -+---+- ... -+--------...-------+~~~~~~~~~~~~~~~~~~~~
:::

[Figure 13](#figure-13){.selfRef}: [Detailed Header Format for Regular
SCHC Fragments](#name-detailed-header-format-for-){.selfRef}
:::

The FCN field [MUST NOT]{.bcp14} contain all bits set to
1.[¶](#section-8.3.1.1-3){.pilcrow}

Profiles [MUST]{.bcp14} ensure that a SCHC Fragment with FCN equal to 0
(called an \"All-0 SCHC Fragment\") is distinguishable by size, even in
the presence of padding, from a SCHC ACK REQ message (see [Section
8.3.3](#ACKREQ){.xref}) with the same RuleID value and with the same T,
M, and N values. This condition is met if the Payload is at least the
size of an L2 Word. This condition is also met if the SCHC Fragment
Header is a multiple of L2 Words.[¶](#section-8.3.1.1-4){.pilcrow}
:::
:::

::: {#LastFrag}
::: {#section-8.3.1.2 .section}
##### [8.3.1.2.](#section-8.3.1.2){.section-number .selfRef} [All-1 SCHC Fragment](#name-all-1-schc-fragment){.section-name .selfRef} {#name-all-1-schc-fragment}

The All-1 SCHC Fragment format is shown in [Figure
14](#Fig-LastFrag){.xref}. The sender uses the All-1 SCHC Fragment
format for the message that completes the emission of a fragmented SCHC
Packet. The DTag field, the W field, the RCS field and the Payload are
[OPTIONAL]{.bcp14}, their presence is specified by each mode and
Profile. At least one of RCS field or Fragment Payload [MUST]{.bcp14} be
present. The FCN field is all ones.[¶](#section-8.3.1.2-1){.pilcrow}

[]{#name-detailed-header-format-for-t}

::: {#Fig-LastFrag}
::: {#section-8.3.1.2-2.1 .artwork .art-text .alignLeft}
    |------- SCHC Fragment Header -------|
             |-- T --|-M-|-- N --|-- U --|
    +-- ... -+- ... -+---+- ... -+- ... -+-----...-----+~~~~~~~~~~~~~~~~~
    | RuleID | DTag  | W | 11..1 |  RCS  | FragPayload | pad. (as needed)
    +-- ... -+- ... -+---+- ... -+- ... -+-----...-----+~~~~~~~~~~~~~~~~~
                           (FCN)
:::

[Figure 14](#figure-14){.selfRef}: [Detailed Header Format for the All-1
SCHC Fragment](#name-detailed-header-format-for-t){.selfRef}
:::

Profiles [MUST]{.bcp14} ensure that an All-1 SCHC Fragment message is
distinguishable by size, even in the presence of padding, from a SCHC
Sender-Abort message (see [Section 8.3.4](#SenderAbort){.xref}) with the
same RuleID value and with the same T, M, and N values. This condition
is met if the RCS is present and is at least the size of an L2 Word or
if the Payload is present and is at least the size an L2 Word. This
condition is also met if the SCHC Sender-Abort Header is a multiple of
L2 Words.[¶](#section-8.3.1.2-3){.pilcrow}
:::
:::
:::
:::

::: {#ACK}
::: {#section-8.3.2 .section}
#### [8.3.2.](#section-8.3.2){.section-number .selfRef} [SCHC ACK Format](#name-schc-ack-format){.section-name .selfRef} {#name-schc-ack-format}

The SCHC ACK message is shown in [Figure 15](#Fig-ACK-Format){.xref}.
The DTag field and the W field are [OPTIONAL]{.bcp14}, their presence is
specified by each mode and Profile. The Compressed Bitmap field
[MUST]{.bcp14} be present in SCHC F/R modes that use windows and [MUST
NOT]{.bcp14} be present in other modes.[¶](#section-8.3.2-1){.pilcrow}

[]{#name-format-of-the-schc-ack-mess}

::: {#Fig-ACK-Format}
::: {#section-8.3.2-2.1 .artwork .art-text .alignLeft}
    |--- SCHC ACK Header ----|
             |-- T --|-M-| 1 |
    +-- ... -+- ... -+---+---+~~~~~~~~~~~~~~~~~~
    | RuleID |  DTag | W |C=1| padding as needed                (success)
    +-- ... -+- ... -+---+---+~~~~~~~~~~~~~~~~~~

    +-- ... -+- ... -+---+---+------ ... ------+~~~~~~~~~~~~~~~
    | RuleID |  DTag | W |C=0|Compressed Bitmap| pad. as needed (failure)
    +-- ... -+- ... -+---+---+------ ... ------+~~~~~~~~~~~~~~~
:::

[Figure 15](#figure-15){.selfRef}: [Format of the SCHC ACK
Message](#name-format-of-the-schc-ack-mess){.selfRef}
:::

The SCHC ACK Header contains a C bit (see [Section
8.2.4](#HeaderFields){.xref}).[¶](#section-8.3.2-3){.pilcrow}

If the C bit is set to 1 (integrity check successful), no Bitmap is
carried.[¶](#section-8.3.2-4){.pilcrow}

If the C bit is set to 0 (integrity check not performed or failed) and
if windows are used, a Compressed Bitmap for the window referred to by
the W field is transmitted as specified in [Section
8.3.2.1](#BitmapTrunc){.xref}.[¶](#section-8.3.2-5){.pilcrow}

::: {#BitmapTrunc}
::: {#section-8.3.2.1 .section}
##### [8.3.2.1.](#section-8.3.2.1){.section-number .selfRef} [Bitmap Compression](#name-bitmap-compression){.section-name .selfRef} {#name-bitmap-compression}

For transmission, the Compressed Bitmap in the SCHC ACK message is
defined by the following algorithm (see [Figure
16](#Fig-Localbitmap){.xref} for a follow-along
example):[¶](#section-8.3.2.1-1){.pilcrow}

-   [Build a temporary SCHC ACK message that contains the Header
    followed by the original Bitmap (see [Section
    8.2.2.3](#Bitmap){.xref} for a description of
    Bitmaps).[¶](#section-8.3.2.1-2.1){.pilcrow}]{#section-8.3.2.1-2.1}
-   [Position scissors at the end of the Bitmap, after its last
    bit.[¶](#section-8.3.2.1-2.2){.pilcrow}]{#section-8.3.2.1-2.2}
-   [While the bit on the left of the scissors is 1 and belongs to the
    Bitmap, keep moving left, then
    stop.[¶](#section-8.3.2.1-2.3){.pilcrow}]{#section-8.3.2.1-2.3}
-   [Then, while the scissors are not on an L2 Word boundary of the SCHC
    ACK message and there is a Bitmap bit on the right of the scissors,
    keep moving right, then
    stop.[¶](#section-8.3.2.1-2.4){.pilcrow}]{#section-8.3.2.1-2.4}
-   [At this point, cut and drop off any bits to the right of the
    scissors.[¶](#section-8.3.2.1-2.5){.pilcrow}]{#section-8.3.2.1-2.5}

When one or more bits have effectively been dropped off as a result of
the above algorithm, the SCHC ACK message is a multiple of L2 Words; no
padding bits will be appended.[¶](#section-8.3.2.1-3){.pilcrow}

Because the SCHC Fragment sender knows the size of the original Bitmap,
it can reconstruct the original Bitmap from the Compressed Bitmap
received in the SCHC ACK message.[¶](#section-8.3.2.1-4){.pilcrow}

[Figure 16](#Fig-Localbitmap){.xref} shows an example where L2 Words are
actually bytes and where the original Bitmap contains 17 bits, the last
15 of which are all set to 1.[¶](#section-8.3.2.1-5){.pilcrow}

[]{#name-schc-ack-header-plus-uncomp}

::: {#Fig-Localbitmap}
::: {#section-8.3.2.1-6.1 .artwork .art-text .alignLeft}
    |--- SCHC ACK Header ----|--------      Bitmap     --------|
             |-- T --|-M-| 1 |
    +-- ... -+- ... -+---+---+---------------------------------+
    | RuleID |  DTag | W |C=0|1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1|
    +-- ... -+- ... -+---+---+---------------------------------+
           next L2 Word boundary ->|
:::

[Figure 16](#figure-16){.selfRef}: [SCHC ACK Header Plus Uncompressed
Bitmap](#name-schc-ack-header-plus-uncomp){.selfRef}
:::

[Figure 17](#Fig-transmittedbitmap){.xref} shows that the last 14 bits
are not sent.[¶](#section-8.3.2.1-7){.pilcrow}

[]{#name-resulting-schc-ack-message-}

::: {#Fig-transmittedbitmap}
::: {#section-8.3.2.1-8.1 .artwork .art-text .alignLeft}
    |--- SCHC ACK Header ----|CpBmp|
             |-- T --|-M-| 1 |
    +-- ... -+- ... -+---+---+-----+
    | RuleID |  DTag | W |C=0|1 0 1|
    +-- ... -+- ... -+---+---+-----+
           next L2 Word boundary ->|
:::

[Figure 17](#figure-17){.selfRef}: [Resulting SCHC ACK Message with
Compressed Bitmap](#name-resulting-schc-ack-message-){.selfRef}
:::

[Figure 18](#Fig-Bitmap-Win){.xref} shows an example of a SCHC ACK with
tile indices ranging from 6 down to 0, where the Bitmap indicates that
the second and the fourth tile of the window have not been correctly
received.[¶](#section-8.3.2.1-9){.pilcrow}

[]{#name-example-of-a-schc-ack-messa}

::: {#Fig-Bitmap-Win}
::: {#section-8.3.2.1-10.1 .artwork .art-text .alignLeft}
    |--- SCHC ACK Header ----|--- Bitmap --|
             |-- T --|-M-| 1 |6 5 4 3 2 1 0| (tile #)
    +--------+-------+---+---+-------------+
    | RuleID |  DTag | W |C=0|1 0 1 0 1 1 1|     uncompressed Bitmap
    +--------+-------+---+---+-------------+
       next L2 Word boundary ->|<-- L2 Word --->|

    +--------+-------+---+---+-------------+~~~~+
    | RuleID |  DTag | W |C=0|1 0 1 0 1 1 1|pad.| transmitted SCHC ACK
    +--------+-------+---+---+-------------+~~~~+
       next L2 Word boundary ->|<-- L2 Word --->|
:::

[Figure 18](#figure-18){.selfRef}: [Example of a SCHC ACK Message,
Missing Tiles](#name-example-of-a-schc-ack-messa){.selfRef}
:::

[Figure 19](#Fig-Bitmap-lastWin){.xref} shows an example of a SCHC ACK
with tile indices ranging from 6 down to 0, where integrity check has
not been performed or has failed and the Bitmap indicates that there is
no missing tile in that window.[¶](#section-8.3.2.1-11){.pilcrow}

[]{#name-example-of-a-schc-ack-messag}

::: {#Fig-Bitmap-lastWin}
::: {#section-8.3.2.1-12.1 .artwork .art-text .alignLeft}
    |--- SCHC ACK Header ----|--- Bitmap --|
             |-- T --|-M-| 1 |6 5 4 3 2 1 0| (tile #)
    +--------+-------+---+---+-------------+
    | RuleID |  DTag | W |C=0|1 1 1 1 1 1 1|  with uncompressed Bitmap
    +--------+-------+---+---+-------------+
       next L2 Word boundary ->|

    +-- ... -+- ... -+---+---+-+
    | RuleID |  DTag | W |C=0|1|                  transmitted SCHC ACK
    +-- ... -+- ... -+---+---+-+
       next L2 Word boundary ->|
:::

[Figure 19](#figure-19){.selfRef}: [Example of a SCHC ACK Message, No
Missing Tile](#name-example-of-a-schc-ack-messag){.selfRef}
:::
:::
:::
:::
:::

::: {#ACKREQ}
::: {#section-8.3.3 .section}
#### [8.3.3.](#section-8.3.3){.section-number .selfRef} [SCHC ACK REQ Format](#name-schc-ack-req-format){.section-name .selfRef} {#name-schc-ack-req-format}

The SCHC ACK REQ is used by a sender to request a SCHC ACK from the
receiver. Its format is shown in [Figure 20](#Fig-ACKREQ){.xref}. The
DTag field and the W field are [OPTIONAL]{.bcp14}, their presence is
specified by each mode and Profile. The FCN field is all
zero.[¶](#section-8.3.3-1){.pilcrow}

[]{#name-schc-ack-req-format-2}

::: {#Fig-ACKREQ}
::: {#section-8.3.3-2.1 .artwork .art-text .alignLeft}
    |--- SCHC ACK REQ Header ----|
             |-- T --|-M-|-- N --|
    +-- ... -+- ... -+---+- ... -+~~~~~~~~~~~~~~~~~~~~~
    | RuleID | DTag  | W |  0..0 | padding (as needed)      (no payload)
    +-- ... -+- ... -+---+- ... -+~~~~~~~~~~~~~~~~~~~~~
:::

[Figure 20](#figure-20){.selfRef}: [SCHC ACK REQ
Format](#name-schc-ack-req-format-2){.selfRef}
:::
:::
:::

::: {#SenderAbort}
::: {#section-8.3.4 .section}
#### [8.3.4.](#section-8.3.4){.section-number .selfRef} [SCHC Sender-Abort Format](#name-schc-sender-abort-format){.section-name .selfRef} {#name-schc-sender-abort-format}

When a SCHC Fragment sender needs to abort an ongoing fragmented SCHC
Packet transmission, it sends a SCHC Sender-Abort message to the SCHC
Fragment receiver.[¶](#section-8.3.4-1){.pilcrow}

The SCHC Sender-Abort format is shown in [Figure
21](#Fig-SenderAbort){.xref}. The DTag field and the W field are
[OPTIONAL]{.bcp14}, their presence is specified by each mode and
Profile. The FCN field is all ones.[¶](#section-8.3.4-2){.pilcrow}

[]{#name-schc-sender-abort-format-2}

::: {#Fig-SenderAbort}
::: {#section-8.3.4-3.1 .artwork .art-text .alignLeft}
    |--- Sender-Abort Header ----|
             |-- T --|-M-|-- N --|
    +-- ... -+- ... -+---+- ... -+~~~~~~~~~~~~~~~~~~~~~
    | RuleID | DTag  | W | 11..1 | padding (as needed)
    +-- ... -+- ... -+---+- ... -+~~~~~~~~~~~~~~~~~~~~~
:::

[Figure 21](#figure-21){.selfRef}: [SCHC Sender-Abort
Format](#name-schc-sender-abort-format-2){.selfRef}
:::

If the W field is present:[¶](#section-8.3.4-4){.pilcrow}

-   [the fragment sender [MUST]{.bcp14} set it to all ones. Other values
    are RESERVED.[¶](#section-8.3.4-5.1){.pilcrow}]{#section-8.3.4-5.1}
-   [the fragment receiver [MUST]{.bcp14} check its value. If the value
    is different from all ones, the message [MUST]{.bcp14} be
    ignored.[¶](#section-8.3.4-5.2){.pilcrow}]{#section-8.3.4-5.2}

The SCHC Sender-Abort [MUST NOT]{.bcp14} be
acknowledged.[¶](#section-8.3.4-6){.pilcrow}
:::
:::

::: {#schc-receiver-abort-format}
::: {#section-8.3.5 .section}
#### [8.3.5.](#section-8.3.5){.section-number .selfRef} [SCHC Receiver-Abort Format](#name-schc-receiver-abort-format){.section-name .selfRef} {#name-schc-receiver-abort-format}

When a SCHC Fragment receiver needs to abort an ongoing fragmented SCHC
Packet transmission, it transmits a SCHC Receiver-Abort message to the
SCHC Fragment sender.[¶](#section-8.3.5-1){.pilcrow}

The SCHC Receiver-Abort format is shown in [Figure
22](#Fig-ReceiverAbort){.xref}. The DTag field and the W field are
[OPTIONAL]{.bcp14}, their presence is specified by each mode and
Profile.[¶](#section-8.3.5-2){.pilcrow}

[]{#name-schc-receiver-abort-format-2}

::: {#Fig-ReceiverAbort}
::: {#section-8.3.5-3.1 .artwork .art-text .alignLeft}
    |-- Receiver-Abort Header ---|
               |--- T ---|-M-| 1 |
    +--- ... --+-- ... --+---+---+-+-+-+-+-+-+-+-+-+-+-+
    |  RuleID  |   DTag  | W |C=1| 1..1|      1..1     |
    +--- ... --+-- ... --+---+---+-+-+-+-+-+-+-+-+-+-+-+
               next L2 Word boundary ->|<-- L2 Word -->|
:::

[Figure 22](#figure-22){.selfRef}: [SCHC Receiver-Abort
Format](#name-schc-receiver-abort-format-2){.selfRef}
:::

If the W field is present:[¶](#section-8.3.5-4){.pilcrow}

-   [the fragment receiver [MUST]{.bcp14} set it to all ones. Other
    values are
    RESERVED.[¶](#section-8.3.5-5.1){.pilcrow}]{#section-8.3.5-5.1}
-   [if the value is different from all ones, the fragment sender
    [MUST]{.bcp14} ignore the
    message.[¶](#section-8.3.5-5.2){.pilcrow}]{#section-8.3.5-5.2}

The SCHC Receiver-Abort has the same header as a SCHC ACK message. The
bits that follow the SCHC Receiver-Abort Header [MUST]{.bcp14} be as
follows:[¶](#section-8.3.5-6){.pilcrow}

-   [if the Header does not end at an L2 Word boundary, append bits set
    to 1 as needed to reach the next L2 Word
    boundary.[¶](#section-8.3.5-7.1){.pilcrow}]{#section-8.3.5-7.1}
-   [append exactly one more L2 Word with bits all set to
    ones.[¶](#section-8.3.5-7.2){.pilcrow}]{#section-8.3.5-7.2}

Such a bit pattern never occurs in a legitimate SCHC ACK. This is how
the fragment sender recognizes a SCHC
Receiver-Abort.[¶](#section-8.3.5-8){.pilcrow}

The SCHC Receiver-Abort [MUST NOT]{.bcp14} be
acknowledged.[¶](#section-8.3.5-9){.pilcrow}
:::
:::
:::
:::

::: {#FragModes}
::: {#section-8.4 .section}
### [8.4.](#section-8.4){.section-number .selfRef} [SCHC F/R Modes](#name-schc-f-r-modes){.section-name .selfRef} {#name-schc-f-r-modes}

This specification includes several SCHC F/R modes
that:[¶](#section-8.4-1){.pilcrow}

-   [allow for a range of reliability options, such as optional SCHC
    Fragment
    retransmission.[¶](#section-8.4-2.1){.pilcrow}]{#section-8.4-2.1}
-   [support various LPWAN characteristics, such as links with variable
    MTU or unidirectional
    links.[¶](#section-8.4-2.2){.pilcrow}]{#section-8.4-2.2}

More modes may be defined in the future.[¶](#section-8.4-3){.pilcrow}

[Appendix B](#FragExamples){.xref} provides examples of fragmentation
sessions based on the modes described
hereafter.[¶](#section-8.4-4){.pilcrow}

[Appendix C](#FSM){.xref} provides examples of Finite State Machines
implementing the SCHC F/R modes described
hereafter.[¶](#section-8.4-5){.pilcrow}

::: {#No-ACK-subsection}
::: {#section-8.4.1 .section}
#### [8.4.1.](#section-8.4.1){.section-number .selfRef} [No-ACK Mode](#name-no-ack-mode){.section-name .selfRef} {#name-no-ack-mode}

The No-ACK mode has been designed under the assumption that data unit
out-of-sequence delivery does not occur between the entity performing
fragmentation and the entity performing reassembly. This mode supports
L2 technologies that have a variable MTU.[¶](#section-8.4.1-1){.pilcrow}

In No-ACK mode, there is no communication from the fragment receiver to
the fragment sender. The sender transmits all the SCHC Fragments without
expecting any acknowledgement. Therefore, No-ACK does not require
bidirectional links: unidirectional links are just
fine.[¶](#section-8.4.1-2){.pilcrow}

In No-ACK mode, only the All-1 SCHC Fragment is padded as needed. The
other SCHC Fragments are intrinsically aligned to L2
Words.[¶](#section-8.4.1-3){.pilcrow}

The tile sizes are not required to be uniform. Windows are not used. The
Retransmission Timer is not used. The Attempts counter is not
used.[¶](#section-8.4.1-4){.pilcrow}

Each Profile [MUST]{.bcp14} specify which RuleID value(s) corresponds to
SCHC F/R messages operating in this mode.[¶](#section-8.4.1-5){.pilcrow}

The W field [MUST NOT]{.bcp14} be present in the SCHC F/R messages. SCHC
ACK [MUST NOT]{.bcp14} be sent. SCHC ACK REQ [MUST NOT]{.bcp14} be sent.
SCHC Sender-Abort [MAY]{.bcp14} be sent. SCHC Receiver-Abort [MUST
NOT]{.bcp14} be sent.[¶](#section-8.4.1-6){.pilcrow}

The value of N (size of the FCN field) is [RECOMMENDED]{.bcp14} to be
1.[¶](#section-8.4.1-7){.pilcrow}

Each Profile, for each RuleID value, [MUST]{.bcp14}
define:[¶](#section-8.4.1-8){.pilcrow}

-   [the size of the DTag
    field,[¶](#section-8.4.1-9.1){.pilcrow}]{#section-8.4.1-9.1}
-   [the size and algorithm for the RCS field,
    and[¶](#section-8.4.1-9.2){.pilcrow}]{#section-8.4.1-9.2}
-   [the expiration time of the Inactivity
    Timer.[¶](#section-8.4.1-9.3){.pilcrow}]{#section-8.4.1-9.3}

Each Profile, for each RuleID value, [MAY]{.bcp14}
define[¶](#section-8.4.1-10){.pilcrow}

-   [a value of N different from the recommended one,
    and[¶](#section-8.4.1-11.1){.pilcrow}]{#section-8.4.1-11.1}
-   [the meaning of values sent in the FCN field, for values different
    from the All-1
    value.[¶](#section-8.4.1-11.2){.pilcrow}]{#section-8.4.1-11.2}

For each active pair of RuleID and DTag values, the receiver
[MUST]{.bcp14} maintain an Inactivity Timer. If the receiver is
under-resourced to do this, it [MUST]{.bcp14} silently drop the related
messages.[¶](#section-8.4.1-12){.pilcrow}

::: {#sender-behavior}
::: {#section-8.4.1.1 .section}
##### [8.4.1.1.](#section-8.4.1.1){.section-number .selfRef} [Sender Behavior](#name-sender-behavior){.section-name .selfRef} {#name-sender-behavior}

At the beginning of the fragmentation of a new SCHC Packet, the fragment
sender [MUST]{.bcp14} select a RuleID and DTag value pair for this SCHC
Packet.[¶](#section-8.4.1.1-1){.pilcrow}

Each SCHC Fragment [MUST]{.bcp14} contain exactly one tile in its
Payload. The tile [MUST]{.bcp14} be at least the size of an L2 Word. The
sender [MUST]{.bcp14} transmit the SCHC Fragments messages in the order
that the tiles appear in the SCHC Packet. Except for the last tile of a
SCHC Packet, each tile [MUST]{.bcp14} be of a size that complements the
SCHC Fragment Header so that the SCHC Fragment is a multiple of L2 Words
without the need for padding bits. Except for the last one, the SCHC
Fragments [MUST]{.bcp14} use the Regular SCHC Fragment format specified
in [Section 8.3.1.1](#NotLastFrag){.xref}. The SCHC Fragment that
carries the last tile [MUST]{.bcp14} be an All-1 SCHC Fragment,
described in [Section
8.3.1.2](#LastFrag){.xref}.[¶](#section-8.4.1.1-2){.pilcrow}

The sender [MAY]{.bcp14} transmit a SCHC
Sender-Abort.[¶](#section-8.4.1.1-3){.pilcrow}

[Figure 39](#Fig-NoACKModeSnd){.xref} shows an example of a
corresponding state machine.[¶](#section-8.4.1.1-4){.pilcrow}
:::
:::

::: {#receiver-behavior}
::: {#section-8.4.1.2 .section}
##### [8.4.1.2.](#section-8.4.1.2){.section-number .selfRef} [Receiver Behavior](#name-receiver-behavior){.section-name .selfRef} {#name-receiver-behavior}

Upon receiving each Regular SCHC
Fragment:[¶](#section-8.4.1.2-1){.pilcrow}

-   [the receiver [MUST]{.bcp14} reset the Inactivity
    Timer.[¶](#section-8.4.1.2-2.1){.pilcrow}]{#section-8.4.1.2-2.1}
-   [the receiver assembles the payloads of the SCHC
    Fragments.[¶](#section-8.4.1.2-2.2){.pilcrow}]{#section-8.4.1.2-2.2}

On receiving an All-1 SCHC Fragment:[¶](#section-8.4.1.2-3){.pilcrow}

-   [the receiver [MUST]{.bcp14} append the All-1 SCHC Fragment Payload
    and the padding bits to the previously received SCHC Fragment
    Payloads for this SCHC
    Packet.[¶](#section-8.4.1.2-4.1){.pilcrow}]{#section-8.4.1.2-4.1}
-   [the receiver [MUST]{.bcp14} perform the integrity
    check.[¶](#section-8.4.1.2-4.2){.pilcrow}]{#section-8.4.1.2-4.2}
-   [if integrity checking fails, the receiver [MUST]{.bcp14} drop the
    reassembled SCHC
    Packet.[¶](#section-8.4.1.2-4.3){.pilcrow}]{#section-8.4.1.2-4.3}
-   [the reassembly operation
    concludes.[¶](#section-8.4.1.2-4.4){.pilcrow}]{#section-8.4.1.2-4.4}

On expiration of the Inactivity Timer, the receiver [MUST]{.bcp14} drop
the SCHC Packet being reassembled.[¶](#section-8.4.1.2-5){.pilcrow}

On receiving a SCHC Sender-Abort, the receiver [MAY]{.bcp14} drop the
SCHC Packet being reassembled.[¶](#section-8.4.1.2-6){.pilcrow}

[Figure 40](#Fig-NoACKModeRcv){.xref} shows an example of a
corresponding state machine.[¶](#section-8.4.1.2-7){.pilcrow}
:::
:::
:::
:::

::: {#ACK-Always-subsection}
::: {#section-8.4.2 .section}
#### [8.4.2.](#section-8.4.2){.section-number .selfRef} [ACK-Always Mode](#name-ack-always-mode){.section-name .selfRef} {#name-ack-always-mode}

The ACK-Always mode has been designed under the following
assumptions:[¶](#section-8.4.2-1){.pilcrow}

-   [Data unit out-of-sequence delivery does not occur between the
    entity performing fragmentation and the entity performing
    reassembly,[¶](#section-8.4.2-2.1){.pilcrow}]{#section-8.4.2-2.1}
-   [The L2 MTU value does not change while the fragments of a SCHC
    Packet are being transmitted,
    and[¶](#section-8.4.2-2.2){.pilcrow}]{#section-8.4.2-2.2}
-   [There is a feedback path from the reassembler to the fragmenter.
    See [Appendix F](#AsymLinks){.xref} for a discussion on using
    ACK-Always mode on quasi-bidirectional
    links.[¶](#section-8.4.2-2.3){.pilcrow}]{#section-8.4.2-2.3}

In ACK-Always mode, windows are used. An acknowledgement, positive or
negative, is transmitted by the fragment receiver to the fragment sender
at the end of the transmission of each window of SCHC
Fragments.[¶](#section-8.4.2-3){.pilcrow}

The tiles are not required to be of uniform size. In ACK-Always mode,
only the All-1 SCHC Fragment is padded as needed. The other SCHC
Fragments are intrinsically aligned to L2
Words.[¶](#section-8.4.2-4){.pilcrow}

Briefly, the algorithm is as follows: after a first blind transmission
of all the tiles of a window, the fragment sender iterates
retransmitting the tiles that are reported missing until the fragment
receiver reports that all the tiles belonging to the window have been
correctly received or until too many attempts were made. The fragment
sender only advances to the next window of tiles when it has ascertained
that all the tiles belonging to the current window have been fully and
correctly received. This results in a per-window lock-step behavior
between the sender and the receiver.[¶](#section-8.4.2-5){.pilcrow}

Each Profile [MUST]{.bcp14} specify which RuleID value(s) correspond to
SCHC F/R messages operating in this mode.[¶](#section-8.4.2-6){.pilcrow}

The W field [MUST]{.bcp14} be present and its size M [MUST]{.bcp14} be 1
bit.[¶](#section-8.4.2-7){.pilcrow}

Each Profile, for each RuleID value, [MUST]{.bcp14}
define:[¶](#section-8.4.2-8){.pilcrow}

-   [the value of
    N,[¶](#section-8.4.2-9.1){.pilcrow}]{#section-8.4.2-9.1}
-   [the value of WINDOW_SIZE, which [MUST]{.bcp14} be strictly less
    than 2\^N,[¶](#section-8.4.2-9.2){.pilcrow}]{#section-8.4.2-9.2}
-   [the size and algorithm for the RCS
    field,[¶](#section-8.4.2-9.3){.pilcrow}]{#section-8.4.2-9.3}
-   [the value of
    T,[¶](#section-8.4.2-9.4){.pilcrow}]{#section-8.4.2-9.4}
-   [the value of
    MAX_ACK_REQUESTS,[¶](#section-8.4.2-9.5){.pilcrow}]{#section-8.4.2-9.5}
-   [the expiration time of the Retransmission Timer,
    and[¶](#section-8.4.2-9.6){.pilcrow}]{#section-8.4.2-9.6}
-   [the expiration time of the Inactivity
    Timer.[¶](#section-8.4.2-9.7){.pilcrow}]{#section-8.4.2-9.7}

For each active pair of RuleID and DTag values, the sender
[MUST]{.bcp14} maintain:[¶](#section-8.4.2-10){.pilcrow}

-   [one Attempts
    counter[¶](#section-8.4.2-11.1){.pilcrow}]{#section-8.4.2-11.1}
-   [one Retransmission
    Timer[¶](#section-8.4.2-11.2){.pilcrow}]{#section-8.4.2-11.2}

For each active pair of RuleID and DTag values, the receiver
[MUST]{.bcp14} maintain[¶](#section-8.4.2-12){.pilcrow}

-   [one Inactivity Timer,
    and[¶](#section-8.4.2-13.1){.pilcrow}]{#section-8.4.2-13.1}
-   [one Attempts
    counter.[¶](#section-8.4.2-13.2){.pilcrow}]{#section-8.4.2-13.2}

::: {#sender-behavior-1}
::: {#section-8.4.2.1 .section}
##### [8.4.2.1.](#section-8.4.2.1){.section-number .selfRef} [Sender Behavior](#name-sender-behavior-2){.section-name .selfRef} {#name-sender-behavior-2}

At the beginning of the fragmentation of a new SCHC Packet, the fragment
sender [MUST]{.bcp14} select a RuleID and DTag value pair for this SCHC
Packet.[¶](#section-8.4.2.1-1){.pilcrow}

Each SCHC Fragment [MUST]{.bcp14} contain exactly one tile in its
Payload. All tiles with the index 0, as well as the last tile,
[MUST]{.bcp14} be at least the size of an L2
Word.[¶](#section-8.4.2.1-2){.pilcrow}

In all SCHC Fragment messages, the W field [MUST]{.bcp14} be filled with
the LSB of the window number that the sender is currently
processing.[¶](#section-8.4.2.1-3){.pilcrow}

For a SCHC Fragment that carries a tile other than the last one of the
SCHC Packet:[¶](#section-8.4.2.1-4){.pilcrow}

-   [the Fragment [MUST]{.bcp14} be of the Regular type specified in
    [Section
    8.3.1.1](#NotLastFrag){.xref}.[¶](#section-8.4.2.1-5.1){.pilcrow}]{#section-8.4.2.1-5.1}
-   [the FCN field [MUST]{.bcp14} contain the tile
    index.[¶](#section-8.4.2.1-5.2){.pilcrow}]{#section-8.4.2.1-5.2}
-   [each tile [MUST]{.bcp14} be of a size that complements the SCHC
    Fragment Header so that the SCHC Fragment is a multiple of L2 Words
    without the need for padding
    bits.[¶](#section-8.4.2.1-5.3){.pilcrow}]{#section-8.4.2.1-5.3}

The SCHC Fragment that carries the last tile [MUST]{.bcp14} be an All-1
SCHC Fragment, described in [Section
8.3.1.2](#LastFrag){.xref}.[¶](#section-8.4.2.1-6){.pilcrow}

The fragment sender [MUST]{.bcp14} start by transmitting the window
numbered 0.[¶](#section-8.4.2.1-7){.pilcrow}

All message receptions being discussed in the rest of this section are
to be understood as \"matching the RuleID and DTag pair being
processed\", even if not spelled out, for
brevity.[¶](#section-8.4.2.1-8){.pilcrow}

The sender starts by a \"blind transmission\" phase, in which it
[MUST]{.bcp14} transmit all the tiles composing the window, in
decreasing tile index order.[¶](#section-8.4.2.1-9){.pilcrow}

Then, it enters a \"retransmission phase\" in which it [MUST]{.bcp14}
initialize an Attempts counter to 0, it [MUST]{.bcp14} start a
Retransmission Timer and it [MUST]{.bcp14} await a SCHC
ACK.[¶](#section-8.4.2.1-10){.pilcrow}

-   ::: {#section-8.4.2.1-11.1}
    Then, upon receiving a SCHC
    ACK:[¶](#section-8.4.2.1-11.1.1){.pilcrow}

    -   [if the SCHC ACK indicates that some tiles are missing at the
        receiver, then the sender [MUST]{.bcp14} transmit all the tiles
        that have been reported missing, it [MUST]{.bcp14} increment
        Attempts, it [MUST]{.bcp14} reset the Retransmission Timer, and
        [MUST]{.bcp14} await the next SCHC
        ACK.[¶](#section-8.4.2.1-11.1.2.1){.pilcrow}]{#section-8.4.2.1-11.1.2.1}
    -   [if the current window is not the last one and the SCHC ACK
        indicates that all tiles were correctly received, the sender
        [MUST]{.bcp14} stop the Retransmission Timer, it [MUST]{.bcp14}
        advance to the next fragmentation window, and it [MUST]{.bcp14}
        start a blind transmission phase as described
        above.[¶](#section-8.4.2.1-11.1.2.2){.pilcrow}]{#section-8.4.2.1-11.1.2.2}
    -   [if the current window is the last one and the SCHC ACK
        indicates that more tiles were received than the sender sent,
        the fragment sender [MUST]{.bcp14} send a SCHC Sender-Abort, and
        it [MAY]{.bcp14} exit with an error
        condition.[¶](#section-8.4.2.1-11.1.2.3){.pilcrow}]{#section-8.4.2.1-11.1.2.3}
    -   [if the current window is the last one and the SCHC ACK
        indicates that all tiles were correctly received, yet the
        integrity check was a failure, the fragment sender
        [MUST]{.bcp14} send a SCHC Sender-Abort, and it [MAY]{.bcp14}
        exit with an error
        condition.[¶](#section-8.4.2.1-11.1.2.4){.pilcrow}]{#section-8.4.2.1-11.1.2.4}
    -   [if the current window is the last one and the SCHC ACK
        indicates that integrity checking was successful, the sender
        exits
        successfully.[¶](#section-8.4.2.1-11.1.2.5){.pilcrow}]{#section-8.4.2.1-11.1.2.5}
    :::

-   ::: {#section-8.4.2.1-11.2}
    on Retransmission Timer
    expiration:[¶](#section-8.4.2.1-11.2.1){.pilcrow}

    -   [if Attempts is strictly less that MAX_ACK_REQUESTS, the
        fragment sender [MUST]{.bcp14} send a SCHC ACK REQ and
        [MUST]{.bcp14} increment the Attempts
        counter.[¶](#section-8.4.2.1-11.2.2.1){.pilcrow}]{#section-8.4.2.1-11.2.2.1}
    -   [otherwise, the fragment sender [MUST]{.bcp14} send a SCHC
        Sender-Abort, and it [MAY]{.bcp14} exit with an error
        condition.[¶](#section-8.4.2.1-11.2.2.2){.pilcrow}]{#section-8.4.2.1-11.2.2.2}
    :::

At any time:[¶](#section-8.4.2.1-12){.pilcrow}

-   [on receiving a SCHC Receiver-Abort, the fragment sender
    [MAY]{.bcp14} exit with an error
    condition.[¶](#section-8.4.2.1-13.1){.pilcrow}]{#section-8.4.2.1-13.1}
-   [on receiving a SCHC ACK that bears a W value different from the W
    value that it currently uses, the fragment sender [MUST]{.bcp14}
    silently discard and ignore that SCHC
    ACK.[¶](#section-8.4.2.1-13.2){.pilcrow}]{#section-8.4.2.1-13.2}

[Figure 41](#Fig-ACKAlwaysSnd){.xref} shows an example of a
corresponding state machine.[¶](#section-8.4.2.1-14){.pilcrow}
:::
:::

::: {#receiver-behavior-1}
::: {#section-8.4.2.2 .section}
##### [8.4.2.2.](#section-8.4.2.2){.section-number .selfRef} [Receiver Behavior](#name-receiver-behavior-2){.section-name .selfRef} {#name-receiver-behavior-2}

On receiving a SCHC Fragment with a RuleID and DTag pair not being
processed at that time:[¶](#section-8.4.2.2-1){.pilcrow}

-   [the receiver [SHOULD]{.bcp14} check if the DTag value has not
    recently been used for that RuleID value, thereby ensuring that the
    received SCHC Fragment is not a remnant of a prior fragmented SCHC
    Packet transmission. The initial value of the Inactivity Timer is
    the [RECOMMENDED]{.bcp14} lifetime for the DTag value at the
    receiver. If the SCHC Fragment is determined to be such a remnant,
    the receiver [MAY]{.bcp14} silently ignore it and discard
    it.[¶](#section-8.4.2.2-2.1){.pilcrow}]{#section-8.4.2.2-2.1}
-   [the receiver [MUST]{.bcp14} start a process to assemble a new SCHC
    Packet with that RuleID and DTag value
    pair.[¶](#section-8.4.2.2-2.2){.pilcrow}]{#section-8.4.2.2-2.2}
-   [the receiver [MUST]{.bcp14} start an Inactivity Timer for that
    RuleID and DTag pair. It [MUST]{.bcp14} initialize an Attempts
    counter to 0 for that RuleID and DTag pair. It [MUST]{.bcp14}
    initialize a window counter to 0. If the receiver is under-resourced
    to do this, it [MUST]{.bcp14} respond to the sender with a SCHC
    Receiver-Abort.[¶](#section-8.4.2.2-2.3){.pilcrow}]{#section-8.4.2.2-2.3}

In the rest of this section, \"local W bit\" means the least significant
bit of the window counter of the
receiver.[¶](#section-8.4.2.2-3){.pilcrow}

On reception of any SCHC F/R message for the RuleID and DTag pair being
processed, the receiver [MUST]{.bcp14} reset the Inactivity Timer
pertaining to that RuleID and DTag
pair.[¶](#section-8.4.2.2-4){.pilcrow}

All message receptions being discussed in the rest of this section are
to be understood as \"matching the RuleID and DTag pair being
processed\", even if not spelled out, for
brevity.[¶](#section-8.4.2.2-5){.pilcrow}

The receiver [MUST]{.bcp14} first initialize an empty Bitmap for the
first window then enter an \"acceptance phase\", in
which:[¶](#section-8.4.2.2-6){.pilcrow}

-   [on receiving a SCHC Fragment or a SCHC ACK REQ, either one having
    the W bit different from the local W bit, the receiver
    [MUST]{.bcp14} silently ignore and discard that
    message.[¶](#section-8.4.2.2-7.1){.pilcrow}]{#section-8.4.2.2-7.1}

-   [on receiving a SCHC ACK REQ with the W bit equal to the local W
    bit, the receiver [MUST]{.bcp14} send a SCHC ACK for this
    window.[¶](#section-8.4.2.2-7.2){.pilcrow}]{#section-8.4.2.2-7.2}

-   ::: {#section-8.4.2.2-7.3}
    on receiving a SCHC Fragment with the W bit equal to the local W
    bit, the receiver [MUST]{.bcp14} assemble the received tile based on
    the window counter and on the FCN field in the SCHC Fragment, and it
    [MUST]{.bcp14} update the
    Bitmap.[¶](#section-8.4.2.2-7.3.1){.pilcrow}

    -   [if the SCHC Fragment received is an All-0 SCHC Fragment, the
        current window is determined to be a not-last window, the
        receiver [MUST]{.bcp14} send a SCHC ACK for this window and it
        [MUST]{.bcp14} enter the \"retransmission phase\" for this
        window.[¶](#section-8.4.2.2-7.3.2.1){.pilcrow}]{#section-8.4.2.2-7.3.2.1}

    -   ::: {#section-8.4.2.2-7.3.2.2}
        if the SCHC Fragment received is an All-1 SCHC Fragment, the
        current window is determined to be the last window, the padding
        bits of the All-1 SCHC Fragment [MUST]{.bcp14} be assembled
        after the received tile, the receiver [MUST]{.bcp14} perform the
        integrity check and it [MUST]{.bcp14} send a SCHC ACK for this
        window. Then:[¶](#section-8.4.2.2-7.3.2.2.1){.pilcrow}

        -   [If the integrity check indicates that the full SCHC Packet
            has been correctly reassembled, the receiver [MUST]{.bcp14}
            enter the \"clean-up phase\" for this
            window.[¶](#section-8.4.2.2-7.3.2.2.2.1){.pilcrow}]{#section-8.4.2.2-7.3.2.2.2.1}
        -   [If the integrity check indicates that the full SCHC Packet
            has not been correctly reassembled, the receiver enters the
            \"retransmission phase\" for this
            window.[¶](#section-8.4.2.2-7.3.2.2.2.2){.pilcrow}]{#section-8.4.2.2-7.3.2.2.2.2}
        :::
    :::

In the \"retransmission phase\":[¶](#section-8.4.2.2-8){.pilcrow}

-   ::: {#section-8.4.2.2-9.1}
    if the window is a not-last
    window:[¶](#section-8.4.2.2-9.1.1){.pilcrow}

    -   [on receiving a SCHC Fragment that is not All-0 or All-1 and
        that has a W bit different from the local W bit, the receiver
        [MUST]{.bcp14} increment its window counter and allocate a fresh
        Bitmap, it [MUST]{.bcp14} assemble the tile received and update
        the Bitmap, and it [MUST]{.bcp14} enter the \"acceptance phase\"
        for that new
        window.[¶](#section-8.4.2.2-9.1.2.1){.pilcrow}]{#section-8.4.2.2-9.1.2.1}

    -   [on receiving a SCHC ACK REQ with a W bit different from the
        local W bit, the receiver [MUST]{.bcp14} increment its window
        counter and allocate a fresh Bitmap, it [MUST]{.bcp14} send a
        SCHC ACK for that new window, and it [MUST]{.bcp14} enter the
        \"acceptance phase\" for that new
        window.[¶](#section-8.4.2.2-9.1.2.2){.pilcrow}]{#section-8.4.2.2-9.1.2.2}

    -   [on receiving a SCHC All-0 Fragment with a W bit different from
        the local W bit, the receiver [MUST]{.bcp14} increment its
        window counter and allocate a fresh Bitmap, it [MUST]{.bcp14}
        assemble the tile received and update the Bitmap, it
        [MUST]{.bcp14} send a SCHC ACK for that new window, and it
        [MUST]{.bcp14} stay in the \"retransmission phase\" for that new
        window.[¶](#section-8.4.2.2-9.1.2.3){.pilcrow}]{#section-8.4.2.2-9.1.2.3}

    -   ::: {#section-8.4.2.2-9.1.2.4}
        on receiving a SCHC All-1 Fragment with a W bit different from
        the local W bit, the receiver [MUST]{.bcp14} increment its
        window counter and allocate a fresh Bitmap; it [MUST]{.bcp14}
        assemble the tile received, including the padding bits; it
        [MUST]{.bcp14} update the Bitmap and perform the integrity
        check; it [MUST]{.bcp14} send a SCHC ACK for the new window,
        which is determined to be the last window.
        Then:[¶](#section-8.4.2.2-9.1.2.4.1){.pilcrow}

        -   [If the integrity check indicates that the full SCHC Packet
            has been correctly reassembled, the receiver [MUST]{.bcp14}
            enter the \"clean-up phase\" for that new
            window.[¶](#section-8.4.2.2-9.1.2.4.2.1){.pilcrow}]{#section-8.4.2.2-9.1.2.4.2.1}
        -   [If the integrity check indicates that the full SCHC Packet
            has not been correctly reassembled, the receiver enters the
            \"retransmission phase\" for that new
            window.[¶](#section-8.4.2.2-9.1.2.4.2.2){.pilcrow}]{#section-8.4.2.2-9.1.2.4.2.2}
        :::

    -   ::: {#section-8.4.2.2-9.1.2.5}
        on receiving a SCHC Fragment with a W bit equal to the local W
        bit:[¶](#section-8.4.2.2-9.1.2.5.1){.pilcrow}

        -   [if the SCHC Fragment received is an All-1 SCHC Fragment,
            the receiver [MUST]{.bcp14} silently ignore it and discard
            it.[¶](#section-8.4.2.2-9.1.2.5.2.1){.pilcrow}]{#section-8.4.2.2-9.1.2.5.2.1}
        -   [otherwise, the receiver [MUST]{.bcp14} assemble the tile
            received and update the Bitmap. If the Bitmap becomes fully
            populated with 1\'s or if the SCHC Fragment is an All-0, the
            receiver [MUST]{.bcp14} send a SCHC ACK for this
            window.[¶](#section-8.4.2.2-9.1.2.5.2.2){.pilcrow}]{#section-8.4.2.2-9.1.2.5.2.2}
        :::

    -   [on receiving a SCHC ACK REQ with the W bit equal to the local W
        bit, the receiver [MUST]{.bcp14} send a SCHC ACK for this
        window.[¶](#section-8.4.2.2-9.1.2.6){.pilcrow}]{#section-8.4.2.2-9.1.2.6}
    :::

-   ::: {#section-8.4.2.2-9.2}
    if the window is the last
    window:[¶](#section-8.4.2.2-9.2.1){.pilcrow}

    -   [on receiving a SCHC Fragment or a SCHC ACK REQ, either one
        having a W bit different from the local W bit, the receiver
        [MUST]{.bcp14} silently ignore and discard that
        message.[¶](#section-8.4.2.2-9.2.2.1){.pilcrow}]{#section-8.4.2.2-9.2.2.1}

    -   [on receiving a SCHC ACK REQ with the W bit equal to the local W
        bit, the receiver [MUST]{.bcp14} send a SCHC ACK for this
        window.[¶](#section-8.4.2.2-9.2.2.2){.pilcrow}]{#section-8.4.2.2-9.2.2.2}

    -   ::: {#section-8.4.2.2-9.2.2.3}
        on receiving a SCHC Fragment with a W bit equal to the local W
        bit:[¶](#section-8.4.2.2-9.2.2.3.1){.pilcrow}

        -   [if the SCHC Fragment received is an All-0 SCHC Fragment,
            the receiver [MUST]{.bcp14} silently ignore it and discard
            it.[¶](#section-8.4.2.2-9.2.2.3.2.1){.pilcrow}]{#section-8.4.2.2-9.2.2.3.2.1}

        -   ::: {#section-8.4.2.2-9.2.2.3.2.2}
            otherwise, the receiver [MUST]{.bcp14} update the Bitmap,
            and it [MUST]{.bcp14} assemble the tile received. If the
            SCHC Fragment received is an All-1 SCHC Fragment, the
            receiver [MUST]{.bcp14} assemble the padding bits of the
            All-1 SCHC Fragment after the received tile, it
            [MUST]{.bcp14} perform the integrity check
            and:[¶](#section-8.4.2.2-9.2.2.3.2.2.1){.pilcrow}

            -   [if the integrity check indicates that the full SCHC
                Packet has been correctly reassembled, the receiver
                [MUST]{.bcp14} send a SCHC ACK and it enters the
                \"clean-up
                phase\".[¶](#section-8.4.2.2-9.2.2.3.2.2.2.1){.pilcrow}]{#section-8.4.2.2-9.2.2.3.2.2.2.1}

            -   ::: {#section-8.4.2.2-9.2.2.3.2.2.2.2}
                if the integrity check indicates that the full SCHC
                Packet has not been correctly
                reassembled:[¶](#section-8.4.2.2-9.2.2.3.2.2.2.2.1){.pilcrow}

                -   [if the SCHC Fragment received was an All-1 SCHC
                    Fragment, the receiver [MUST]{.bcp14} send a SCHC
                    ACK for this
                    window.[¶](#section-8.4.2.2-9.2.2.3.2.2.2.2.2.1){.pilcrow}]{#section-8.4.2.2-9.2.2.3.2.2.2.2.2.1}
                :::
            :::
        :::
    :::

In the \"clean-up phase\":[¶](#section-8.4.2.2-10){.pilcrow}

-   [On receiving an All-1 SCHC Fragment or a SCHC ACK REQ, either one
    having the W bit equal to the local W bit, the receiver
    [MUST]{.bcp14} send a SCHC
    ACK.[¶](#section-8.4.2.2-11.1){.pilcrow}]{#section-8.4.2.2-11.1}
-   [Any other SCHC Fragment received [MUST]{.bcp14} be silently ignored
    and
    discarded.[¶](#section-8.4.2.2-11.2){.pilcrow}]{#section-8.4.2.2-11.2}

At any time, on sending a SCHC ACK, the receiver [MUST]{.bcp14}
increment the Attempts counter.[¶](#section-8.4.2.2-12){.pilcrow}

At any time, on incrementing its window counter, the receiver
[MUST]{.bcp14} reset the Attempts
counter.[¶](#section-8.4.2.2-13){.pilcrow}

At any time, on expiration of the Inactivity Timer, on receiving a SCHC
Sender-Abort or when Attempts reaches MAX_ACK_REQUESTS, the receiver
[MUST]{.bcp14} send a SCHC Receiver-Abort, and it [MAY]{.bcp14} exit the
receive process for that SCHC Packet.[¶](#section-8.4.2.2-14){.pilcrow}

[Figure 42](#Fig-ACKAlwaysRcv){.xref} shows an example of a
corresponding state machine.[¶](#section-8.4.2.2-15){.pilcrow}
:::
:::
:::
:::

::: {#ACK-on-Error-subsection}
::: {#section-8.4.3 .section}
#### [8.4.3.](#section-8.4.3){.section-number .selfRef} [ACK-on-Error Mode](#name-ack-on-error-mode){.section-name .selfRef} {#name-ack-on-error-mode}

The ACK-on-Error mode supports L2 technologies that have variable MTU
and out-of-order delivery. It requires an L2 that provides a feedback
path from the reassembler to the fragmenter. See [Appendix
F](#AsymLinks){.xref} for a discussion on using ACK-on-Error mode on
quasi-bidirectional links.[¶](#section-8.4.3-1){.pilcrow}

In ACK-on-Error mode, windows are used.[¶](#section-8.4.3-2){.pilcrow}

All tiles except the last one and the penultimate one [MUST]{.bcp14} be
of equal size, hereafter called \"regular\". The size of the last tile
[MUST]{.bcp14} be smaller than or equal to the regular tile size.
Regarding the penultimate tile, a Profile [MUST]{.bcp14} pick one of the
following two options:[¶](#section-8.4.3-3){.pilcrow}

-   [The penultimate tile size [MUST]{.bcp14} be the regular tile size,
    or[¶](#section-8.4.3-4.1){.pilcrow}]{#section-8.4.3-4.1}
-   [the penultimate tile size [MUST]{.bcp14} be either the regular tile
    size or the regular tile size minus one L2
    Word.[¶](#section-8.4.3-4.2){.pilcrow}]{#section-8.4.3-4.2}

A SCHC Fragment message carries one or several contiguous tiles, which
may span multiple windows. A SCHC ACK reports on the reception of
exactly one window of tiles.[¶](#section-8.4.3-5){.pilcrow}

See [Figure 23](#Fig-TilesACKonError){.xref} for an
example.[¶](#section-8.4.3-6){.pilcrow}

[]{#name-schc-packet-fragmented-in-til}

::: {#Fig-TilesACKonError}
::: {#section-8.4.3-7.1 .artwork .art-text .alignLeft}
            +---------------------------------------------...-----------+
            |                       SCHC Packet                         |
            +---------------------------------------------...-----------+

    Tile#   | 4 | 3 | 2 | 1 | 0 | 4 | 3 | 2 | 1 | 0 | 4 |     | 0 | 4 |3|
    Window# |-------- 0 --------|-------- 1 --------|- 2  ... 27 -|- 28-|


    SCHC Fragment msg   |-----------|
:::

[Figure 23](#figure-23){.selfRef}: [SCHC Packet Fragmented in Tiles,
ACK-on-Error Mode](#name-schc-packet-fragmented-in-til){.selfRef}
:::

The W field is wide enough that it unambiguously represents an absolute
window number. The fragment receiver sends SCHC ACKs to the fragment
sender about windows for which tiles are missing. No SCHC ACK is sent by
the fragment receiver for windows that it knows have been fully
received.[¶](#section-8.4.3-8){.pilcrow}

The fragment sender retransmits SCHC Fragments for tiles that are
reported missing. It can advance to next windows even before it has
ascertained that all tiles belonging to previous windows have been
correctly received, and it can still later retransmit SCHC Fragments
with tiles belonging to previous windows. Therefore, the sender and the
receiver may operate in a decoupled fashion. The fragmented SCHC Packet
transmission concludes when:[¶](#section-8.4.3-9){.pilcrow}

-   [integrity checking shows that the fragmented SCHC Packet has been
    correctly reassembled at the receive end, and this information has
    been conveyed back to the sender,
    or[¶](#section-8.4.3-10.1){.pilcrow}]{#section-8.4.3-10.1}
-   [too many retransmission attempts were made,
    or[¶](#section-8.4.3-10.2){.pilcrow}]{#section-8.4.3-10.2}
-   [the receiver determines that the transmission of this fragmented
    SCHC Packet has been inactive for too
    long.[¶](#section-8.4.3-10.3){.pilcrow}]{#section-8.4.3-10.3}

Each Profile [MUST]{.bcp14} specify which RuleID value(s) corresponds to
SCHC F/R messages operating in this
mode.[¶](#section-8.4.3-11){.pilcrow}

The W field [MUST]{.bcp14} be present in the SCHC F/R
messages.[¶](#section-8.4.3-12){.pilcrow}

Each Profile, for each RuleID value, [MUST]{.bcp14}
define:[¶](#section-8.4.3-13){.pilcrow}

-   [the tile size (a tile does not need to be multiple of an L2 Word,
    but it [MUST]{.bcp14} be at least the size of an L2
    Word),[¶](#section-8.4.3-14.1){.pilcrow}]{#section-8.4.3-14.1}
-   [the value of
    M,[¶](#section-8.4.3-14.2){.pilcrow}]{#section-8.4.3-14.2}
-   [the value of
    N,[¶](#section-8.4.3-14.3){.pilcrow}]{#section-8.4.3-14.3}
-   [the value of WINDOW_SIZE, which [MUST]{.bcp14} be strictly less
    than 2\^N,[¶](#section-8.4.3-14.4){.pilcrow}]{#section-8.4.3-14.4}
-   [the size and algorithm for the RCS
    field,[¶](#section-8.4.3-14.5){.pilcrow}]{#section-8.4.3-14.5}
-   [the value of
    T,[¶](#section-8.4.3-14.6){.pilcrow}]{#section-8.4.3-14.6}
-   [the value of
    MAX_ACK_REQUESTS,[¶](#section-8.4.3-14.7){.pilcrow}]{#section-8.4.3-14.7}
-   [the expiration time of the Retransmission
    Timer,[¶](#section-8.4.3-14.8){.pilcrow}]{#section-8.4.3-14.8}
-   [the expiration time of the Inactivity
    Timer,[¶](#section-8.4.3-14.9){.pilcrow}]{#section-8.4.3-14.9}
-   [if the last tile is carried in a Regular SCHC Fragment or an All-1
    SCHC Fragment (see [Section 8.4.3.1](#ACK-on-Error-sender){.xref}),
    and[¶](#section-8.4.3-14.10){.pilcrow}]{#section-8.4.3-14.10}
-   [if the penultimate tile [MAY]{.bcp14} be one L2 Word smaller than
    the regular tile size. In this case, the regular tile size
    [MUST]{.bcp14} be at least twice the L2 Word
    size.[¶](#section-8.4.3-14.11){.pilcrow}]{#section-8.4.3-14.11}

For each active pair of RuleID and DTag values, the sender
[MUST]{.bcp14} maintain:[¶](#section-8.4.3-15){.pilcrow}

-   [one Attempts counter,
    and[¶](#section-8.4.3-16.1){.pilcrow}]{#section-8.4.3-16.1}
-   [one Retransmission
    Timer.[¶](#section-8.4.3-16.2){.pilcrow}]{#section-8.4.3-16.2}

For each active pair of RuleID and DTag values, the receiver
[MUST]{.bcp14} maintain:[¶](#section-8.4.3-17){.pilcrow}

-   [one Inactivity Timer,
    and[¶](#section-8.4.3-18.1){.pilcrow}]{#section-8.4.3-18.1}
-   [one Attempts
    counter.[¶](#section-8.4.3-18.2){.pilcrow}]{#section-8.4.3-18.2}

::: {#ACK-on-Error-sender}
::: {#section-8.4.3.1 .section}
##### [8.4.3.1.](#section-8.4.3.1){.section-number .selfRef} [Sender Behavior](#name-sender-behavior-3){.section-name .selfRef} {#name-sender-behavior-3}

At the beginning of the fragmentation of a new SCHC
Packet:[¶](#section-8.4.3.1-1){.pilcrow}

-   [the fragment sender [MUST]{.bcp14} select a RuleID and DTag value
    pair for this SCHC Packet. A Rule [MUST NOT]{.bcp14} be selected if
    the values of M and WINDOW_SIZE for that Rule are such that the SCHC
    Packet cannot be fragmented in (2\^M) \* WINDOW_SIZE tiles or
    less.[¶](#section-8.4.3.1-2.1){.pilcrow}]{#section-8.4.3.1-2.1}
-   [the fragment sender [MUST]{.bcp14} initialize the Attempts counter
    to 0 for that RuleID and DTag value
    pair.[¶](#section-8.4.3.1-2.2){.pilcrow}]{#section-8.4.3.1-2.2}

A Regular SCHC Fragment message carries in its payload one or more
tiles. If more than one tile is carried in one Regular SCHC
Fragment:[¶](#section-8.4.3.1-3){.pilcrow}

-   [the selected tiles [MUST]{.bcp14} be contiguous in the original
    SCHC Packet,
    and[¶](#section-8.4.3.1-4.1){.pilcrow}]{#section-8.4.3.1-4.1}
-   [they [MUST]{.bcp14} be placed in the SCHC Fragment Payload adjacent
    to one another, in the order they appear in the SCHC Packet, from
    the start of the SCHC Packet toward its
    end.[¶](#section-8.4.3.1-4.2){.pilcrow}]{#section-8.4.3.1-4.2}

Tiles that are not the last one [MUST]{.bcp14} be sent in Regular SCHC
Fragments specified in [Section 8.3.1.1](#NotLastFrag){.xref}. The FCN
field [MUST]{.bcp14} contain the tile index of the first tile sent in
that SCHC Fragment.[¶](#section-8.4.3.1-5){.pilcrow}

In a Regular SCHC Fragment message, the sender [MUST]{.bcp14} fill the W
field with the window number of the first tile sent in that SCHC
Fragment.[¶](#section-8.4.3.1-6){.pilcrow}

A Profile [MUST]{.bcp14} define if the last tile of a SCHC Packet is
sent:[¶](#section-8.4.3.1-7){.pilcrow}

-   [in a Regular SCHC Fragment, alone or as part of a multi-tiles
    Payload,[¶](#section-8.4.3.1-8.1){.pilcrow}]{#section-8.4.3.1-8.1}
-   [alone in an All-1 SCHC Fragment,
    or[¶](#section-8.4.3.1-8.2){.pilcrow}]{#section-8.4.3.1-8.2}
-   [with any of the above two
    methods.[¶](#section-8.4.3.1-8.3){.pilcrow}]{#section-8.4.3.1-8.3}

In an All-1 SCHC Fragment message, the sender [MUST]{.bcp14} fill the W
field with the window number of the last tile of the SCHC
Packet.[¶](#section-8.4.3.1-9){.pilcrow}

The fragment sender [MUST]{.bcp14} send SCHC Fragments such that, all
together, they contain all the tiles of the fragmented SCHC
Packet.[¶](#section-8.4.3.1-10){.pilcrow}

The fragment sender [MUST]{.bcp14} send at least one All-1 SCHC
Fragment.[¶](#section-8.4.3.1-11){.pilcrow}

In doing the two items above, the sender [MUST]{.bcp14} ascertain that
the receiver will not receive the last tile through both a Regular SCHC
Fragment and an All-1 SCHC Fragment.[¶](#section-8.4.3.1-12){.pilcrow}

The fragment sender [MUST]{.bcp14} listen for SCHC ACK messages after
having sent:[¶](#section-8.4.3.1-13){.pilcrow}

-   [an All-1 SCHC Fragment,
    or[¶](#section-8.4.3.1-14.1){.pilcrow}]{#section-8.4.3.1-14.1}
-   [a SCHC ACK
    REQ.[¶](#section-8.4.3.1-14.2){.pilcrow}]{#section-8.4.3.1-14.2}

A Profile [MAY]{.bcp14} specify other times at which the fragment sender
[MUST]{.bcp14} listen for SCHC ACK messages. For example, this could be
after sending a complete window of
tiles.[¶](#section-8.4.3.1-15){.pilcrow}

Each time a fragment sender sends an All-1 SCHC Fragment or a SCHC ACK
REQ:[¶](#section-8.4.3.1-16){.pilcrow}

-   [it [MUST]{.bcp14} increment the Attempts counter,
    and[¶](#section-8.4.3.1-17.1){.pilcrow}]{#section-8.4.3.1-17.1}
-   [it [MUST]{.bcp14} reset the Retransmission
    Timer.[¶](#section-8.4.3.1-17.2){.pilcrow}]{#section-8.4.3.1-17.2}

On Retransmission Timer expiration:[¶](#section-8.4.3.1-18){.pilcrow}

-   [if the Attempts counter is strictly less than MAX_ACK_REQUESTS, the
    fragment sender [MUST]{.bcp14} send either the All-1 SCHC Fragment
    or a SCHC ACK REQ with the W field corresponding to the last
    window,[¶](#section-8.4.3.1-19.1){.pilcrow}]{#section-8.4.3.1-19.1}
-   [otherwise, the fragment sender [MUST]{.bcp14} send a SCHC
    Sender-Abort, and it [MAY]{.bcp14} exit with an error
    condition.[¶](#section-8.4.3.1-19.2){.pilcrow}]{#section-8.4.3.1-19.2}

All message receptions being discussed in the rest of this section are
to be understood as \"matching the RuleID and DTag pair being
processed\", even if not spelled out, for
brevity.[¶](#section-8.4.3.1-20){.pilcrow}

On receiving a SCHC ACK:[¶](#section-8.4.3.1-21){.pilcrow}

-   ::: {#section-8.4.3.1-22.1}
    if the W field in the SCHC ACK corresponds to the last window of the
    SCHC Packet:[¶](#section-8.4.3.1-22.1.1){.pilcrow}

    -   [if the C bit is set, the sender [MAY]{.bcp14} exit
        successfully.[¶](#section-8.4.3.1-22.1.2.1){.pilcrow}]{#section-8.4.3.1-22.1.2.1}

    -   ::: {#section-8.4.3.1-22.1.2.2}
        otherwise:[¶](#section-8.4.3.1-22.1.2.2.1){.pilcrow}

        -   ::: {#section-8.4.3.1-22.1.2.2.2.1}
            if the Profile mandates that the last tile be sent in an
            All-1 SCHC
            Fragment:[¶](#section-8.4.3.1-22.1.2.2.2.1.1){.pilcrow}

            -   ::: {#section-8.4.3.1-22.1.2.2.2.1.2.1}
                if the SCHC ACK shows no missing tile at the receiver,
                the
                sender:[¶](#section-8.4.3.1-22.1.2.2.2.1.2.1.1){.pilcrow}

                -   [[MUST]{.bcp14} send a SCHC Sender-Abort,
                    and[¶](#section-8.4.3.1-22.1.2.2.2.1.2.1.2.1){.pilcrow}]{#section-8.4.3.1-22.1.2.2.2.1.2.1.2.1}
                -   [[MAY]{.bcp14} exit with an error
                    condition.[¶](#section-8.4.3.1-22.1.2.2.2.1.2.1.2.2){.pilcrow}]{#section-8.4.3.1-22.1.2.2.2.1.2.1.2.2}
                :::

            -   ::: {#section-8.4.3.1-22.1.2.2.2.1.2.2}
                otherwise:[¶](#section-8.4.3.1-22.1.2.2.2.1.2.2.1){.pilcrow}

                -   [the fragment sender [MUST]{.bcp14} send SCHC
                    Fragment messages containing all the tiles that are
                    reported missing in the SCHC
                    ACK.[¶](#section-8.4.3.1-22.1.2.2.2.1.2.2.2.1){.pilcrow}]{#section-8.4.3.1-22.1.2.2.2.1.2.2.2.1}
                -   [if the last of these SCHC Fragment messages is not
                    an All-1 SCHC Fragment, then the fragment sender
                    [MUST]{.bcp14} in addition send after it a SCHC ACK
                    REQ with the W field corresponding to the last
                    window.[¶](#section-8.4.3.1-22.1.2.2.2.1.2.2.2.2){.pilcrow}]{#section-8.4.3.1-22.1.2.2.2.1.2.2.2.2}
                -   [in doing the two items above, the sender
                    [MUST]{.bcp14} ascertain that the receiver will not
                    receive the last tile through both a Regular SCHC
                    Fragment and an All-1 SCHC
                    Fragment.[¶](#section-8.4.3.1-22.1.2.2.2.1.2.2.2.3){.pilcrow}]{#section-8.4.3.1-22.1.2.2.2.1.2.2.2.3}
                :::
            :::

        -   ::: {#section-8.4.3.1-22.1.2.2.2.2}
            otherwise:[¶](#section-8.4.3.1-22.1.2.2.2.2.1){.pilcrow}

            -   [if the SCHC ACK shows no missing tile at the receiver,
                the sender [MUST]{.bcp14} send the All-1 SCHC
                Fragment[¶](#section-8.4.3.1-22.1.2.2.2.2.2.1){.pilcrow}]{#section-8.4.3.1-22.1.2.2.2.2.2.1}

            -   ::: {#section-8.4.3.1-22.1.2.2.2.2.2.2}
                otherwise:[¶](#section-8.4.3.1-22.1.2.2.2.2.2.2.1){.pilcrow}

                -   [the fragment sender [MUST]{.bcp14} send SCHC
                    Fragment messages containing all the tiles that are
                    reported missing in the SCHC
                    ACK.[¶](#section-8.4.3.1-22.1.2.2.2.2.2.2.2.1){.pilcrow}]{#section-8.4.3.1-22.1.2.2.2.2.2.2.2.1}
                -   [the fragment sender [MUST]{.bcp14} then send either
                    the All-1 SCHC Fragment or a SCHC ACK REQ with the W
                    field corresponding to the last
                    window.[¶](#section-8.4.3.1-22.1.2.2.2.2.2.2.2.2){.pilcrow}]{#section-8.4.3.1-22.1.2.2.2.2.2.2.2.2}
                :::
            :::
        :::
    :::

-   ::: {#section-8.4.3.1-22.2}
    otherwise, the fragment
    sender:[¶](#section-8.4.3.1-22.2.1){.pilcrow}

    -   [[MUST]{.bcp14} send SCHC Fragment messages containing the tiles
        that are reported missing in the SCHC
        ACK.[¶](#section-8.4.3.1-22.2.2.1){.pilcrow}]{#section-8.4.3.1-22.2.2.1}
    -   [then, it [MAY]{.bcp14} send a SCHC ACK REQ with the W field
        corresponding to the last
        window.[¶](#section-8.4.3.1-22.2.2.2){.pilcrow}]{#section-8.4.3.1-22.2.2.2}
    :::

See [Figure 43](#Fig-ACKonerrorSnd){.xref} for one among several
possible examples of a Finite State Machine implementing a sender
behavior obeying this specification.[¶](#section-8.4.3.1-23){.pilcrow}
:::
:::

::: {#ACK-on-Error-receiver}
::: {#section-8.4.3.2 .section}
##### [8.4.3.2.](#section-8.4.3.2){.section-number .selfRef} [Receiver Behavior](#name-receiver-behavior-3){.section-name .selfRef} {#name-receiver-behavior-3}

On receiving a SCHC Fragment with a RuleID and DTag pair not being
processed at that time:[¶](#section-8.4.3.2-1){.pilcrow}

-   [the receiver [SHOULD]{.bcp14} check if the DTag value has not
    recently been used for that RuleID value, thereby ensuring that the
    received SCHC Fragment is not a remnant of a prior fragmented SCHC
    Packet transmission. The initial value of the Inactivity Timer is
    the [RECOMMENDED]{.bcp14} lifetime for the DTag value at the
    receiver. If the SCHC Fragment is determined to be such a remnant,
    the receiver [MAY]{.bcp14} silently ignore it and discard
    it.[¶](#section-8.4.3.2-2.1){.pilcrow}]{#section-8.4.3.2-2.1}
-   [the receiver [MUST]{.bcp14} start a process to assemble a new SCHC
    Packet with that RuleID and DTag value pair. The receiver
    [MUST]{.bcp14} start an Inactivity Timer for that RuleID and DTag
    value pair. It [MUST]{.bcp14} initialize an Attempts counter to 0
    for that RuleID and DTag value pair. If the receiver is
    under-resourced to do this, it [MUST]{.bcp14} respond to the sender
    with a SCHC
    Receiver-Abort.[¶](#section-8.4.3.2-2.2){.pilcrow}]{#section-8.4.3.2-2.2}

On reception of any SCHC F/R message for the RuleID and DTag pair being
processed, the receiver [MUST]{.bcp14} reset the Inactivity Timer
pertaining to that RuleID and DTag
pair.[¶](#section-8.4.3.2-3){.pilcrow}

All message receptions being discussed in the rest of this section are
to be understood as \"matching the RuleID and DTag pair being
processed\", even if not spelled out, for
brevity.[¶](#section-8.4.3.2-4){.pilcrow}

On receiving a SCHC Fragment message, the receiver determines what tiles
were received, based on the payload length and on the W and FCN fields
of the SCHC Fragment.[¶](#section-8.4.3.2-5){.pilcrow}

-   [if the FCN is All-1, if a Payload is present, the full SCHC
    Fragment Payload [MUST]{.bcp14} be assembled including the padding
    bits. This is because the size of the last tile is not known by the
    receiver; therefore, padding bits are indistinguishable from the
    tile data bits, at this stage. They will be removed by the SCHC C/D
    sublayer. If the size of the SCHC Fragment Payload exceeds or equals
    the size of one regular tile plus the size of an L2 Word, this
    [SHOULD]{.bcp14} raise an error
    flag.[¶](#section-8.4.3.2-6.1){.pilcrow}]{#section-8.4.3.2-6.1}

-   ::: {#section-8.4.3.2-6.2}
    otherwise, tiles [MUST]{.bcp14} be assembled based on the a priori
    known tile size.[¶](#section-8.4.3.2-6.2.1){.pilcrow}

    -   [If allowed by the Profile, the end of the payload [MAY]{.bcp14}
        contain the last tile, which may be shorter. Padding bits are
        indistinguishable from the tile data bits, at this
        stage.[¶](#section-8.4.3.2-6.2.2.1){.pilcrow}]{#section-8.4.3.2-6.2.2.1}

    -   [The payload may contain the penultimate tile that, if allowed
        by the Profile, [MAY]{.bcp14} be exactly one L2 Word shorter
        than the regular tile
        size.[¶](#section-8.4.3.2-6.2.2.2){.pilcrow}]{#section-8.4.3.2-6.2.2.2}

    -   ::: {#section-8.4.3.2-6.2.2.3}
        Otherwise, padding bits [MUST]{.bcp14} be discarded. This is
        possible because:[¶](#section-8.4.3.2-6.2.2.3.1){.pilcrow}

        -   [the size of the tiles is known a
            priori,[¶](#section-8.4.3.2-6.2.2.3.2.1){.pilcrow}]{#section-8.4.3.2-6.2.2.3.2.1}
        -   [tiles are larger than an L2 Word,
            and[¶](#section-8.4.3.2-6.2.2.3.2.2){.pilcrow}]{#section-8.4.3.2-6.2.2.3.2.2}
        -   [padding bits are always strictly less than an L2
            Word.[¶](#section-8.4.3.2-6.2.2.3.2.3){.pilcrow}]{#section-8.4.3.2-6.2.2.3.2.3}
        :::
    :::

On receiving a SCHC ACK REQ or an All-1 SCHC
Fragment:[¶](#section-8.4.3.2-7){.pilcrow}

-   [if the receiver knows of any windows with missing tiles for the
    packet being reassembled, it [MUST]{.bcp14} return a SCHC ACK for
    the lowest-numbered such
    window:[¶](#section-8.4.3.2-8.1){.pilcrow}]{#section-8.4.3.2-8.1}

-   ::: {#section-8.4.3.2-8.2}
    otherwise:[¶](#section-8.4.3.2-8.2.1){.pilcrow}

    -   [if it has received at least one tile, it [MUST]{.bcp14} return
        a SCHC ACK for the highest-numbered window it currently has
        tiles
        for,[¶](#section-8.4.3.2-8.2.2.1){.pilcrow}]{#section-8.4.3.2-8.2.2.1}
    -   [otherwise, it [MUST]{.bcp14} return a SCHC ACK for window
        numbered
        0.[¶](#section-8.4.3.2-8.2.2.2){.pilcrow}]{#section-8.4.3.2-8.2.2.2}
    :::

A Profile [MAY]{.bcp14} specify other times and circumstances at which a
receiver sends a SCHC ACK, and which window the SCHC ACK reports about
in these circumstances.[¶](#section-8.4.3.2-9){.pilcrow}

Upon sending a SCHC ACK, the receiver [MUST]{.bcp14} increase the
Attempts counter.[¶](#section-8.4.3.2-10){.pilcrow}

After receiving an All-1 SCHC Fragment, a receiver [MUST]{.bcp14} check
the integrity of the reassembled SCHC Packet at least every time it
prepares for sending a SCHC ACK for the last
window.[¶](#section-8.4.3.2-11){.pilcrow}

Upon receiving a SCHC Sender-Abort, the receiver [MAY]{.bcp14} exit with
an error condition.[¶](#section-8.4.3.2-12){.pilcrow}

Upon expiration of the Inactivity Timer, the receiver [MUST]{.bcp14}
send a SCHC Receiver-Abort, and it [MAY]{.bcp14} exit with an error
condition.[¶](#section-8.4.3.2-13){.pilcrow}

On the Attempts counter exceeding MAX_ACK_REQUESTS, the receiver
[MUST]{.bcp14} send a SCHC Receiver-Abort, and it [MAY]{.bcp14} exit
with an error condition.[¶](#section-8.4.3.2-14){.pilcrow}

Reassembly of the SCHC Packet concludes
when:[¶](#section-8.4.3.2-15){.pilcrow}

-   [a Sender-Abort has been received,
    or[¶](#section-8.4.3.2-16.1){.pilcrow}]{#section-8.4.3.2-16.1}
-   [the Inactivity Timer has expired,
    or[¶](#section-8.4.3.2-16.2){.pilcrow}]{#section-8.4.3.2-16.2}
-   [the Attempts counter has exceeded MAX_ACK_REQUESTS,
    or[¶](#section-8.4.3.2-16.3){.pilcrow}]{#section-8.4.3.2-16.3}
-   [at least an All-1 SCHC Fragment has been received and integrity
    checking of the reassembled SCHC Packet is
    successful.[¶](#section-8.4.3.2-16.4){.pilcrow}]{#section-8.4.3.2-16.4}

See [Figure 44](#Fig-ACKonerrorRcv){.xref} for one among several
possible examples of a Finite State Machine implementing a receiver
behavior obeying this specification. The example provided is meant to
match the sender Finite State Machine of [Figure
43](#Fig-ACKonerrorSnd){.xref}.[¶](#section-8.4.3.2-17){.pilcrow}
:::
:::
:::
:::
:::
:::
:::
:::

::: {#Padding}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Padding Management](#name-padding-management){.section-name .selfRef} {#name-padding-management}

SCHC C/D and SCHC F/R operate on bits, not bytes. SCHC itself does not
have any alignment prerequisite. The size of SCHC Packets can be any
number of bits.[¶](#section-9-1){.pilcrow}

If the L2 constrains the payload to align to coarser boundaries (for
example, bytes), the SCHC messages [MUST]{.bcp14} be padded. When
padding occurs, the number of appended bits [MUST]{.bcp14} be strictly
less than the L2 Word size.[¶](#section-9-2){.pilcrow}

If a SCHC Packet is sent unfragmented (see [Figure
24](#Fig-Operations-Pad){.xref}), it is padded as needed for
transmission.[¶](#section-9-3){.pilcrow}

If a SCHC Packet needs to be fragmented for transmission, it is not
padded in itself. Only the SCHC F/R messages are padded as needed for
transmission. Some SCHC F/R messages are intrinsically aligned to L2
Words.[¶](#section-9-4){.pilcrow}

[]{#name-schc-operations-including-p}

::: {#Fig-Operations-Pad}
::: {#section-9-5.1 .artwork .art-text .alignLeft}
    A packet (e.g., an IPv6 packet)
             |                                           ^ (padding bits
             v                                           |       dropped)
    +------------------+                      +--------------------+
    | SCHC Compression |                      | SCHC Decompression |
    +------------------+                      +--------------------+
             |                                           ^
             |   If no fragmentation,                    |
             +---- SCHC Packet + padding as needed ----->|
             |                                           | (integrity
             v                                           |  checked)
    +--------------------+                       +-----------------+
    | SCHC Fragmentation |                       | SCHC Reassembly |
    +--------------------+                       +-----------------+
         |       ^                                   |       ^
         |       |                                   |       |
         |       +--- SCHC ACK + padding as needed --+       |
         |                                                   |
         +------- SCHC Fragments + padding as needed---------+

            Sender                                    Receiver
:::

[Figure 24](#figure-24){.selfRef}: [SCHC Operations, Including Padding
as Needed](#name-schc-operations-including-p){.selfRef}
:::

Each Profile [MUST]{.bcp14} specify the size of the L2 Word. The L2 Word
might actually be a single bit, in which case no padding will take place
at all.[¶](#section-9-6){.pilcrow}

A Profile [MUST]{.bcp14} define the value of the padding bits if the L2
Word is wider than a single bit. The [RECOMMENDED]{.bcp14} value is
0.[¶](#section-9-7){.pilcrow}
:::
:::

::: {#schc-compression-for-ipv6-and-udp-headers}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [SCHC Compression for IPv6 and UDP Headers](#name-schc-compression-for-ipv6-a){.section-name .selfRef} {#name-schc-compression-for-ipv6-a}

This section lists the IPv6 and UDP header fields and describes how they
can be compressed. An example of a set of Rules for UDP/IPv6 header
compression is provided in [Appendix
A](#compressIPv6){.xref}.[¶](#section-10-1){.pilcrow}

::: {#ipv6-version-field}
::: {#section-10.1 .section}
### [10.1.](#section-10.1){.section-number .selfRef} [IPv6 Version Field](#name-ipv6-version-field){.section-name .selfRef} {#name-ipv6-version-field}

The IPv6 version field is labeled by the protocol parser as being the
\"version\" field of the IPv6 protocol. Therefore, it only exists for
IPv6 packets. In the Rule, TV is set to 6, MO to \"ignore\" and CDA to
\"not-sent\".[¶](#section-10.1-1){.pilcrow}
:::
:::

::: {#ipv6-traffic-class-field}
::: {#section-10.2 .section}
### [10.2.](#section-10.2){.section-number .selfRef} [IPv6 Traffic Class Field](#name-ipv6-traffic-class-field){.section-name .selfRef} {#name-ipv6-traffic-class-field}

If the Diffserv field does not vary and is known by both sides, the
Field Descriptor in the Rule [SHOULD]{.bcp14} contain a TV with this
well-known value, an \"equal\" MO, and a \"not-sent\"
CDA.[¶](#section-10.2-1){.pilcrow}

Otherwise (e.g., ECN bits are to be transmitted), two possibilities can
be considered depending on the variability of the
value:[¶](#section-10.2-2){.pilcrow}

-   [One possibility is to not compress the field and send the original
    value. In the Rule, TV is not set to any particular value, MO is set
    to \"ignore\", and CDA is set to
    \"value-sent\".[¶](#section-10.2-3.1){.pilcrow}]{#section-10.2-3.1}

-   ::: {#section-10.2-3.2}
    If some upper bits in the field are constant and known, a better
    option is to only send the LSBs. In the Rule, TV is set to a value
    with the stable known upper part, MO is set to MSB(x), and CDA to
    LSB.[¶](#section-10.2-3.2.1){.pilcrow}

    ECN functionality depends on both bits of the ECN field, which are
    the 2 LSBs of this field; hence, sending only a single LSB of this
    field is [NOT
    RECOMMENDED]{.bcp14}.[¶](#section-10.2-3.2.2){.pilcrow}
    :::
:::
:::

::: {#flow-label-field}
::: {#section-10.3 .section}
### [10.3.](#section-10.3){.section-number .selfRef} [Flow Label Field](#name-flow-label-field){.section-name .selfRef} {#name-flow-label-field}

If the flow label is not set, i.e., its value is zero, the Field
Descriptor in the Rule [SHOULD]{.bcp14} contain a TV set to zero, an
\"equal\" MO, and a \"not-sent\" CDA.[¶](#section-10.3-1){.pilcrow}

If the flow label is set to a pseudorandom value according to
\[[RFC6437](#RFC6437){.xref}\], in the Rule, TV is not set to any
particular value, MO is set to \"ignore\", and CDA is set to
\"value-sent\".[¶](#section-10.3-2){.pilcrow}

If the flow label is set according to some prior agreement, i.e., by a
flow state establishment method as allowed by
\[[RFC6437](#RFC6437){.xref}\], the Field Descriptor in the Rule
[SHOULD]{.bcp14} contain a TV with this agreed-upon value, an \"equal\"
MO, and a \"not-sent\" CDA.[¶](#section-10.3-3){.pilcrow}
:::
:::

::: {#payload-length-field}
::: {#section-10.4 .section}
### [10.4.](#section-10.4){.section-number .selfRef} [Payload Length Field](#name-payload-length-field){.section-name .selfRef} {#name-payload-length-field}

This field can be elided for the transmission on the LPWAN. The SCHC C/D
recomputes the original payload length value. In the Field Descriptor,
TV is not set, MO is set to \"ignore\", and CDA is
\"compute-\*\".[¶](#section-10.4-1){.pilcrow}
:::
:::

::: {#next-header-field}
::: {#section-10.5 .section}
### [10.5.](#section-10.5){.section-number .selfRef} [Next Header Field](#name-next-header-field){.section-name .selfRef} {#name-next-header-field}

If the Next Header field does not vary and is known by both sides, the
Field Descriptor in the Rule [SHOULD]{.bcp14} contain a TV with this
Next Header value, the MO [SHOULD]{.bcp14} be \"equal\", and the CDA
[SHOULD]{.bcp14} be \"not-sent\".[¶](#section-10.5-1){.pilcrow}

Otherwise, TV is not set in the Field Descriptor, MO is set to
\"ignore\", and CDA is set to \"value-sent\". Alternatively, a
matching-list [MAY]{.bcp14} also be used.[¶](#section-10.5-2){.pilcrow}
:::
:::

::: {#hop-limit-field}
::: {#section-10.6 .section}
### [10.6.](#section-10.6){.section-number .selfRef} [Hop Limit Field](#name-hop-limit-field){.section-name .selfRef} {#name-hop-limit-field}

The field behavior for this field is different for Uplink and Downlink.
In Uplink, since there is no IP forwarding between the Dev and the SCHC
C/D, the value is relatively constant. On the other hand, the Downlink
value depends on Internet routing and can change more frequently. The DI
can be used to distinguish both
directions:[¶](#section-10.6-1){.pilcrow}

-   [in an Up Field Descriptor, elide the field: the TV is set to the
    known constant value, the MO is set to \"equal\" and the CDA is set
    to \"not-sent\".[¶](#section-10.6-2.1){.pilcrow}]{#section-10.6-2.1}
-   [in a Dw Field Descriptor, the Hop Limit is elided for transmission
    and forced to 1 at the receiver, by setting TV to 1, MO to
    \"ignore\" and CDA to \"not-sent\". This prevents any further
    forwarding.[¶](#section-10.6-2.2){.pilcrow}]{#section-10.6-2.2}
:::
:::

::: {#ipv6-addresses-fields}
::: {#section-10.7 .section}
### [10.7.](#section-10.7){.section-number .selfRef} [IPv6 Addresses Fields](#name-ipv6-addresses-fields){.section-name .selfRef} {#name-ipv6-addresses-fields}

As in 6LoWPAN \[[RFC4944](#RFC4944){.xref}\], IPv6 addresses are split
into two 64-bit-long fields; one for the prefix and one for the
Interface Identifier (IID). These fields [SHOULD]{.bcp14} be compressed.
To allow for a single Rule being used for both directions, these values
are identified by their role (Dev or App) and not by their position in
the header (source or destination).[¶](#section-10.7-1){.pilcrow}

::: {#ipv6-source-and-destination-prefixes}
::: {#section-10.7.1 .section}
#### [10.7.1.](#section-10.7.1){.section-number .selfRef} [IPv6 Source and Destination Prefixes](#name-ipv6-source-and-destination){.section-name .selfRef} {#name-ipv6-source-and-destination}

Both ends [MUST]{.bcp14} be configured with the appropriate prefixes.
For a specific flow, the source and destination prefixes can be unique
and stored in the Context. In that case, the TV for the source and
destination prefixes contain the values, the MO is set to \"equal\" and
the CDA is set to \"not-sent\".[¶](#section-10.7.1-1){.pilcrow}

If the Rule is intended to compress packets with different prefix
values, match-mapping [SHOULD]{.bcp14} be used. The different prefixes
are listed in the TV, the MO is set to \"match-mapping\" and the CDA is
set to \"mapping-sent\". See [Figure
26](#Fig-fields){.xref}.[¶](#section-10.7.1-2){.pilcrow}

Otherwise, the TV is not set, the MO is set to \"ignore\", and the CDA
is set to \"value-sent\".[¶](#section-10.7.1-3){.pilcrow}
:::
:::

::: {#ipv6-source-and-destination-iid}
::: {#section-10.7.2 .section}
#### [10.7.2.](#section-10.7.2){.section-number .selfRef} [IPv6 Source and Destination IID](#name-ipv6-source-and-destination-){.section-name .selfRef} {#name-ipv6-source-and-destination-}

If the Dev or App IID are based on an L2 address, then the IID can be
reconstructed with information coming from the L2 header. In that case,
the TV is not set, the MO is set to \"ignore\" and the CDA is set to
\"DevIID\" or \"AppIID\". On LPWAN technologies where the frames carry a
single identifier (corresponding to the Dev), AppIID cannot be
used.[¶](#section-10.7.2-1){.pilcrow}

As described in \[[RFC8065](#RFC8065){.xref}\], it may be undesirable to
build the Dev IPv6 IID out of the Dev address. Another static value is
used instead. In that case, the TV contains the static value, the MO
operator is set to \"equal\" and the CDA is set to
\"not-sent\".[¶](#section-10.7.2-2){.pilcrow}

If several IIDs are possible, then the TV contains the list of possible
IIDs, the MO is set to \"match-mapping\" and the CDA is set to
\"mapping-sent\".[¶](#section-10.7.2-3){.pilcrow}

It may also happen that the IID variability only expresses itself on a
few bytes. In that case, the TV is set to the stable part of the IID,
the MO is set to \"MSB\" and the CDA is set to
\"LSB\".[¶](#section-10.7.2-4){.pilcrow}

Finally, the IID can be sent in its entirety on the L2. In that case,
the TV is not set, the MO is set to \"ignore\", and the CDA is set to
\"value-sent\".[¶](#section-10.7.2-5){.pilcrow}
:::
:::
:::
:::

::: {#ipv6-extension-headers}
::: {#section-10.8 .section}
### [10.8.](#section-10.8){.section-number .selfRef} [IPv6 Extension Headers](#name-ipv6-extension-headers){.section-name .selfRef} {#name-ipv6-extension-headers}

This document does not provide recommendations on how to compress IPv6
extension headers.[¶](#section-10.8-1){.pilcrow}
:::
:::

::: {#udp-source-and-destination-ports}
::: {#section-10.9 .section}
### [10.9.](#section-10.9){.section-number .selfRef} [UDP Source and Destination Ports](#name-udp-source-and-destination-){.section-name .selfRef} {#name-udp-source-and-destination-}

To allow for a single Rule being used for both directions, the UDP port
values are identified by their role (Dev or App) and not by their
position in the header (source or destination). The SCHC C/D
[MUST]{.bcp14} be aware of the traffic direction (Uplink, Downlink) to
select the appropriate field. The following Rules apply for Dev and App
port numbers.[¶](#section-10.9-1){.pilcrow}

If both ends know the port number, it can be elided. The TV contains the
port number, the MO is set to \"equal\", and the CDA is set to
\"not-sent\".[¶](#section-10.9-2){.pilcrow}

If the port variation is on few bits, the TV contains the stable part of
the port number, the MO is set to \"MSB\", and the CDA is set to
\"LSB\".[¶](#section-10.9-3){.pilcrow}

If some well-known values are used, the TV can contain the list of these
values, the MO is set to \"match-mapping\", and the CDA is set to
\"mapping-sent\".[¶](#section-10.9-4){.pilcrow}

Otherwise, the port numbers are sent over the L2. The TV is not set, the
MO is set to \"ignore\" and the CDA is set to
\"value-sent\".[¶](#section-10.9-5){.pilcrow}
:::
:::

::: {#udp-length-field}
::: {#section-10.10 .section}
### [10.10.](#section-10.10){.section-number .selfRef} [UDP Length Field](#name-udp-length-field){.section-name .selfRef} {#name-udp-length-field}

The parser MUST NOT label this field unless the UDP Length value matches
the Payload Length value from the IPv6 header. The TV is not set, the MO
is set to \"ignore\", and the CDA is set to
\"compute-\*\".[¶](#section-10.10-1){.pilcrow}
:::
:::

::: {#UDPchecksum}
::: {#section-10.11 .section}
### [10.11.](#section-10.11){.section-number .selfRef} [UDP Checksum Field](#name-udp-checksum-field){.section-name .selfRef} {#name-udp-checksum-field}

The UDP checksum operation is mandatory with IPv6 for most packets, but
there are exceptions
\[[RFC8200](#RFC8200){.xref}\].[¶](#section-10.11-1){.pilcrow}

For instance, protocols that use UDP as a tunnel encapsulation may
enable zero-checksum mode for a specific port (or set of ports) for
sending and/or receiving. \[[RFC8200](#RFC8200){.xref}\] requires any
node implementing zero-checksum mode to follow the requirements
specified in \"Applicability Statement for the Use of IPv6 UDP Datagrams
with Zero Checksums\"
\[[RFC6936](#RFC6936){.xref}\].[¶](#section-10.11-2){.pilcrow}

6LoWPAN Header Compression \[[RFC6282](#RFC6282){.xref}\] also specifies
that a UDP checksum can be elided by the compressor and recomputed by
the decompressor when an upper layer guarantees the integrity of the UDP
payload and pseudo-header. A specific example of this is when a message
integrity check protects the compressed message between the compressor
that elides the UDP checksum and the decompressor that computes it, with
a strength that is identical or better to the UDP
checksum.[¶](#section-10.11-3){.pilcrow}

Similarly, a SCHC compressor [MAY]{.bcp14} elide the UDP checksum when
another layer guarantees at least equal integrity protection for the UDP
payload and the pseudo-header. In this case, the TV is not set, the MO
is set to \"ignore\", and the CDA is set to
\"compute-\*\".[¶](#section-10.11-4){.pilcrow}

In particular, when SCHC fragmentation is used, a fragmentation RCS of 2
bytes or more provides equal or better protection than the UDP checksum;
in that case, if the compressor is collocated with the fragmentation
point and the decompressor is collocated with the packet reassembly
point, and if the SCHC Packet is fragmented even when it would fit
unfragmented in the L2 MTU, then the compressor [MAY]{.bcp14} verify and
then elide the UDP checksum. Whether and when the UDP Checksum is elided
is to be specified in the Profile.[¶](#section-10.11-5){.pilcrow}

Since the compression happens before the fragmentation, implementers
should understand the risks when dealing with unprotected data below the
transport layer and take special care when manipulating that
data.[¶](#section-10.11-6){.pilcrow}

In other cases, the checksum [SHOULD]{.bcp14} be explicitly sent. The TV
is not set, the MO is set to \"ignore\" and the CDA is set to
\"value-sent\".[¶](#section-10.11-7){.pilcrow}
:::
:::
:::
:::

::: {#iana-considerations}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-11-1){.pilcrow}
:::
:::

::: {#SecConsiderations}
::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

As explained in [Section 5](#Overview){.xref}, SCHC is expected to be
implemented on top of LPWAN technologies, which are expected to
implement security measures.[¶](#section-12-1){.pilcrow}

In this section, we analyze the potential security threats that could be
introduced into an LPWAN by adding the SCHC
functionalities.[¶](#section-12-2){.pilcrow}

::: {#security-considerations-for-schc-compressiondecompression}
::: {#section-12.1 .section}
### [12.1.](#section-12.1){.section-number .selfRef} [Security Considerations for SCHC Compression/Decompression](#name-security-considerations-for){.section-name .selfRef} {#name-security-considerations-for}

::: {#forged-schc-packet}
::: {#section-12.1.1 .section}
#### [12.1.1.](#section-12.1.1){.section-number .selfRef} [Forged SCHC Packet](#name-forged-schc-packet){.section-name .selfRef} {#name-forged-schc-packet}

Let\'s assume that an attacker is able to send a forged SCHC Packet to a
SCHC decompressor.[¶](#section-12.1.1-1){.pilcrow}

Let\'s first consider the case where the RuleID contained in that forged
SCHC Packet does not correspond to a Rule allocated in the Rule table.
An implementation should detect that the RuleID is invalid and should
silently drop the offending SCHC Packet.[¶](#section-12.1.1-2){.pilcrow}

Let\'s now consider that the RuleID corresponds to a Rule in the table.
With the CDAs defined in this document, the reconstructed packet is, at
most, a constant number of bits bigger than the SCHC Packet that was
received. This assumes that the compute-\* decompression actions produce
a bounded number of bits, irrespective of the incoming SCHC Packet. This
property is true for IPv6 Length, UDP Length, and UDP Checksum, for
which the compute-\* CDA is recommended by this
document.[¶](#section-12.1.1-3){.pilcrow}

As a consequence, SCHC decompression does not amplify attacks, beyond
adding a bounded number of bits to the SCHC Packet received. This bound
is determined by the Rule stored in the receiving
device.[¶](#section-12.1.1-4){.pilcrow}

As a general safety measure, a SCHC decompressor should never
reconstruct a packet larger than MAX_PACKET_SIZE (defined in a Profile,
with 1500 bytes as generic default).[¶](#section-12.1.1-5){.pilcrow}
:::
:::

::: {#compressed-packet-size-as-a-side-channel-to-guess-a-secret-token}
::: {#section-12.1.2 .section}
#### [12.1.2.](#section-12.1.2){.section-number .selfRef} [Compressed Packet Size as a Side Channel to Guess a Secret Token](#name-compressed-packet-size-as-a){.section-name .selfRef} {#name-compressed-packet-size-as-a}

Some packet compression methods are known to be susceptible to attacks,
such as BREACH and CRIME. The attack involves injecting arbitrary data
into the packet and observing the resulting compressed packet size. The
observed size potentially reflects correlation between the arbitrary
data and some content that was meant to remain secret, such as a
security token, thereby allowing the attacker to get at the
secret.[¶](#section-12.1.2-1){.pilcrow}

By contrast, SCHC compression takes place header field by header field,
with the SCHC Packet being a mere concatenation of the compression
residues of each of the individual field. Any correlation between header
fields does not result in a change in the SCHC Packet size compressed
under the same Rule.[¶](#section-12.1.2-2){.pilcrow}

If SCHC C/D is used to compress packets that include a secret
information field, such as a token, the Rule set should be designed so
that the size of the compression residue for the field to remain secret
is the same irrespective of the value of the secret information. This is
achieved by, e.g., sending this field in extenso with the \"ignore\" MO
and the \"value-sent\" CDA. This recommendation is disputable if it is
ascertained that the Rule set itself will remain
secret.[¶](#section-12.1.2-3){.pilcrow}
:::
:::

::: {#decompressed-packet-different-from-the-original-packet}
::: {#section-12.1.3 .section}
#### [12.1.3.](#section-12.1.3){.section-number .selfRef} [Decompressed Packet Different from the Original Packet](#name-decompressed-packet-differe){.section-name .selfRef} {#name-decompressed-packet-differe}

As explained in [Section 7.2](#PProcessing){.xref}, using FPs with value
0 in Field Descriptors in a Rule may result in header fields appearing
in the decompressed packet in an order different from that in the
original packet. Likewise, as stated in [Section
7.4.3](#NotSentCDA){.xref}, using an \"ignore\" MO together with a
\"not-sent\" CDA will result in the header field taking the TV value,
which is likely to be different from the original
value.[¶](#section-12.1.3-1){.pilcrow}

Depending on the protocol, the order of header fields in the packet may
or may not be functionally significant.[¶](#section-12.1.3-2){.pilcrow}

Furthermore, if the packet is protected by a checksum or a similar
integrity protection mechanism, and if the checksum is transmitted
instead of being recomputed as part of the decompression, these
situations may result in the packet being considered corrupt and
dropped.[¶](#section-12.1.3-3){.pilcrow}
:::
:::
:::
:::

::: {#security-considerations-for-schc-fragmentationreassembly}
::: {#section-12.2 .section}
### [12.2.](#section-12.2){.section-number .selfRef} [Security Considerations for SCHC Fragmentation/Reassembly](#name-security-considerations-for-){.section-name .selfRef} {#name-security-considerations-for-}

::: {#buffer-reservation-attack}
::: {#section-12.2.1 .section}
#### [12.2.1.](#section-12.2.1){.section-number .selfRef} [Buffer Reservation Attack](#name-buffer-reservation-attack){.section-name .selfRef} {#name-buffer-reservation-attack}

Let\'s assume that an attacker is able to send a forged SCHC Fragment to
a SCHC reassembler.[¶](#section-12.2.1-1){.pilcrow}

A node can perform a buffer reservation attack: the receiver will
reserve buffer space for the SCHC Packet. If the implementation has only
one buffer, other incoming fragmented SCHC Packets will be dropped while
the reassembly buffer is occupied during the reassembly timeout. Once
that timeout expires, the attacker can repeat the same procedure, and
iterate, thus, creating a denial-of-service attack. An implementation
may have multiple reassembly buffers. The cost to mount this attack is
linear with the number of buffers at the target node. Better, the cost
for an attacker can be increased if individual fragments of multiple
SCHC Packets can be stored in the reassembly buffer. The finer grained
the reassembly buffer (down to the smallest tile size), the higher the
cost of the attack. If buffer overload does occur, a smart receiver
could selectively discard SCHC Packets being reassembled based on the
sender behavior, which may help identify which SCHC Fragments have been
sent by the attacker. Another mild countermeasure is for the target to
abort the fragmentation/reassembly session as early as it detects a
non-identical SCHC Fragment duplicate, anticipating for an eventual
corrupt SCHC Packet, so as to save the sender the hassle of sending the
rest of the fragments for this SCHC
Packet.[¶](#section-12.2.1-2){.pilcrow}
:::
:::

::: {#corrupt-fragment-attack}
::: {#section-12.2.2 .section}
#### [12.2.2.](#section-12.2.2){.section-number .selfRef} [Corrupt Fragment Attack](#name-corrupt-fragment-attack){.section-name .selfRef} {#name-corrupt-fragment-attack}

Let\'s assume that an attacker is able to send a forged SCHC Fragment to
a SCHC reassembler. The malicious node is additionally assumed to be
able to hear an incoming communication destined to the target
node.[¶](#section-12.2.2-1){.pilcrow}

It can then send a forged SCHC Fragment that looks like it belongs to a
SCHC Packet already being reassembled at the target node. This can cause
the SCHC Packet to be considered corrupt and to be dropped by the
receiver. The amplification happens here by a single spoofed SCHC
Fragment rendering a full sequence of legitimate SCHC Fragments useless.
If the target uses ACK-Always or ACK-on-Error mode, such a malicious
node can also interfere with the acknowledgement and repetition
algorithm of SCHC F/R. A single spoofed ACK, with all Bitmap bits set to
0, will trigger the repetition of WINDOW_SIZE tiles. This protocol loop
amplification depletes the energy source of the target node and consumes
the channel bandwidth. Similarly, a spoofed ACK REQ will trigger the
sending of a SCHC ACK, which may be much larger than the ACK REQ if
WINDOW_SIZE is large. These consequences should be borne in mind when
defining profiles for SCHC over specific LPWAN
technologies.[¶](#section-12.2.2-2){.pilcrow}
:::
:::

::: {#fragmentation-as-a-way-to-bypass-network-inspection}
::: {#section-12.2.3 .section}
#### [12.2.3.](#section-12.2.3){.section-number .selfRef} [Fragmentation as a Way to Bypass Network Inspection](#name-fragmentation-as-a-way-to-b){.section-name .selfRef} {#name-fragmentation-as-a-way-to-b}

Fragmentation is known for potentially allowing one to force through a
Network Inspection device (e.g., firewall) packets that would be
rejected if unfragmented. This involves sending overlapping fragments to
rewrite fields whose initial value led the Network Inspection device to
allow the flow to go through.[¶](#section-12.2.3-1){.pilcrow}

SCHC F/R is expected to be used over one LPWAN link, where no Network
Inspection device is expected to sit. As described in [Section
5.2](#FunctionalMapping){.xref}, even if the SCHC F/R on the Network
Infrastructure side is located in the Internet, a tunnel is to be
established between it and the NGW.[¶](#section-12.2.3-2){.pilcrow}
:::
:::

::: {#privacy-issues-associated-with-schc-header-fields}
::: {#section-12.2.4 .section}
#### [12.2.4.](#section-12.2.4){.section-number .selfRef} [Privacy Issues Associated with SCHC Header Fields](#name-privacy-issues-associated-w){.section-name .selfRef} {#name-privacy-issues-associated-w}

SCHC F/R allocates a DTag value to fragments belonging to the same SCHC
Packet. Concerns were raised that, if DTag is a wide counter that is
incremented in a predictable fashion for each new fragmented SCHC
Packet, it might lead to a privacy issue, such as enabling tracking of a
device across LPWANs.[¶](#section-12.2.4-1){.pilcrow}

However, SCHC F/R is expected to be used over exactly one LPWAN link. As
described in [Section 5.2](#FunctionalMapping){.xref}, even if the SCHC
F/R on the Network Infrastructure side is located in the Internet, a
tunnel is to be established between it and the NGW. Therefore, assuming
the tunnel provides confidentiality, neither the DTag field nor any
other SCHC-introduced field is visible over the
Internet.[¶](#section-12.2.4-2){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#section-13 .section}
## [13.](#section-13){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-13.1 .section}
### [13.1.](#section-13.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC6936\]
:   [Fairhurst, G.]{.refAuthor}[ and M. Westerlund]{.refAuthor},
    [\"Applicability Statement for the Use of IPv6 UDP Datagrams with
    Zero Checksums\"]{.refTitle}, [RFC 6936]{.seriesInfo}, [DOI
    10.17487/RFC6936]{.seriesInfo}, April 2013,
    \<<https://www.rfc-editor.org/info/rfc6936>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8200\]
:   [Deering, S.]{.refAuthor}[ and R. Hinden]{.refAuthor}, [\"Internet
    Protocol, Version 6 (IPv6) Specification\"]{.refTitle}, [STD
    86]{.seriesInfo}, [RFC 8200]{.seriesInfo}, [DOI
    10.17487/RFC8200]{.seriesInfo}, July 2017,
    \<<https://www.rfc-editor.org/info/rfc8200>\>.
:   

\[RFC8376\]
:   [Farrell, S., Ed.]{.refAuthor}, [\"Low-Power Wide Area Network
    (LPWAN) Overview\"]{.refTitle}, [RFC 8376]{.seriesInfo}, [DOI
    10.17487/RFC8376]{.seriesInfo}, May 2018,
    \<<https://www.rfc-editor.org/info/rfc8376>\>.
:   
:::

::: {#section-13.2 .section}
### [13.2.](#section-13.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[ETHERNET\]
:   [IEEE]{.refAuthor}, [\"IEEE Standard for Ethernet\"]{.refTitle},
    [DOI 10.1109/IEEESTD.2012.6419735]{.seriesInfo}, [IEEE Standard
    802.3-2012]{.seriesInfo}, December 2012,
    \<<https://ieeexplore.ieee.org/document/6419735>\>.
:   

\[RFC4944\]
:   [Montenegro, G.]{.refAuthor}[, Kushalnagar, N.]{.refAuthor}[,
    Hui, J.]{.refAuthor}[, and D. Culler]{.refAuthor}, [\"Transmission
    of IPv6 Packets over IEEE 802.15.4 Networks\"]{.refTitle}, [RFC
    4944]{.seriesInfo}, [DOI 10.17487/RFC4944]{.seriesInfo}, September
    2007, \<<https://www.rfc-editor.org/info/rfc4944>\>.
:   

\[RFC5795\]
:   [Sandlund, K.]{.refAuthor}[, Pelletier, G.]{.refAuthor}[, and L-E.
    Jonsson]{.refAuthor}, [\"The RObust Header Compression (ROHC)
    Framework\"]{.refTitle}, [RFC 5795]{.seriesInfo}, [DOI
    10.17487/RFC5795]{.seriesInfo}, March 2010,
    \<<https://www.rfc-editor.org/info/rfc5795>\>.
:   

\[RFC6282\]
:   [Hui, J., Ed.]{.refAuthor}[ and P. Thubert]{.refAuthor},
    [\"Compression Format for IPv6 Datagrams over IEEE 802.15.4-Based
    Networks\"]{.refTitle}, [RFC 6282]{.seriesInfo}, [DOI
    10.17487/RFC6282]{.seriesInfo}, September 2011,
    \<<https://www.rfc-editor.org/info/rfc6282>\>.
:   

\[RFC6437\]
:   [Amante, S.]{.refAuthor}[, Carpenter, B.]{.refAuthor}[,
    Jiang, S.]{.refAuthor}[, and J. Rajahalme]{.refAuthor}, [\"IPv6 Flow
    Label Specification\"]{.refTitle}, [RFC 6437]{.seriesInfo}, [DOI
    10.17487/RFC6437]{.seriesInfo}, November 2011,
    \<<https://www.rfc-editor.org/info/rfc6437>\>.
:   

\[RFC7136\]
:   [Carpenter, B.]{.refAuthor}[ and S. Jiang]{.refAuthor},
    [\"Significance of IPv6 Interface Identifiers\"]{.refTitle}, [RFC
    7136]{.seriesInfo}, [DOI 10.17487/RFC7136]{.seriesInfo}, February
    2014, \<<https://www.rfc-editor.org/info/rfc7136>\>.
:   

\[RFC8065\]
:   [Thaler, D.]{.refAuthor}, [\"Privacy Considerations for IPv6
    Adaptation-Layer Mechanisms\"]{.refTitle}, [RFC 8065]{.seriesInfo},
    [DOI 10.17487/RFC8065]{.seriesInfo}, February 2017,
    \<<https://www.rfc-editor.org/info/rfc8065>\>.
:   
:::
:::

::: {#compressIPv6}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Compression Examples](#name-compression-examples){.section-name .selfRef} {#name-compression-examples}

This section gives some scenarios of the compression mechanism for
IPv6/UDP. The goal is to illustrate the behavior of
SCHC.[¶](#section-appendix.a-1){.pilcrow}

The mechanisms defined in this document can be applied to a Dev that
embeds some applications running over CoAP. In this example, three flows
are considered. The first flow is for the device management based on
CoAP using Link Local IPv6 addresses and UDP ports 123 and 124 for Dev
and App, respectively. The second flow is a CoAP server for measurements
done by the Dev (using ports 5683) and Global IPv6 Address prefixes
alpha::IID/64 to beta::1/64. The last flow is for legacy applications
using different ports numbers, the destination IPv6 address prefix is
gamma::1/64.[¶](#section-appendix.a-2){.pilcrow}

[Figure 25](#FigStack){.xref} presents the protocol stack. IPv6 and UDP
are represented with dotted lines since these protocols are compressed
on the radio link.[¶](#section-appendix.a-3){.pilcrow}

[]{#name-simplified-protocol-stack-f}

::: {#FigStack}
::: {#section-appendix.a-4.1 .artwork .art-text .alignLeft}
     Management   Data
    +----------+---------+---------+
    |   CoAP   |  CoAP   | legacy  |
    +----||----+---||----+---||----+
    .   UDP    .  UDP    |   UDP   |
    ................................
    .   IPv6   .  IPv6   .  IPv6   .
    +------------------------------+
    |    SCHC Header compression   |
    |      and fragmentation       |
    +------------------------------+
    |      LPWAN L2 technologies   |
    +------------------------------+
             Dev or NGW
:::

[Figure 25](#figure-25){.selfRef}: [Simplified Protocol Stack for
LP-WAN](#name-simplified-protocol-stack-f){.selfRef}
:::

[]{#name-context-rules-rule-0-and-ru}

::: {#Fig-fields}
::: {#section-appendix.a-5.1 .artwork .art-text .alignLeft}
    Rule 0
      Special RuleID used to tag an uncompressed UDP/IPV6 packet.

    Rule 1
     +----------------+--+--+--+---------+--------+------------++------+
     |       FID      |FL|FP|DI|    TV   |   MO   |     CDA    || Sent |
     |                |  |  |  |         |        |            ||[bits]|
     +----------------+--+--+--+---------+---------------------++------+
     |IPv6 Version    |4 |1 |Bi|6        | ignore | not-sent   ||      |
     |IPv6 Diffserv   |8 |1 |Bi|0        | equal  | not-sent   ||      |
     |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |
     |IPv6 Length     |16|1 |Bi|         | ignore | compute-*  ||      |
     |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |
     |IPv6 Hop Limit  |8 |1 |Bi|255      | ignore | not-sent   ||      |
     |IPv6 DevPrefix  |64|1 |Bi|FE80::/64| equal  | not-sent   ||      |
     |IPv6 DevIID     |64|1 |Bi|         | ignore | DevIID     ||      |
     |IPv6 AppPrefix  |64|1 |Bi|FE80::/64| equal  | not-sent   ||      |
     |IPv6 AppIID     |64|1 |Bi|::1      | equal  | not-sent   ||      |
     +================+==+==+==+=========+========+============++======+
     |UDP DevPort     |16|1 |Bi|123      | equal  | not-sent   ||      |
     |UDP AppPort     |16|1 |Bi|124      | equal  | not-sent   ||      |
     |UDP Length      |16|1 |Bi|         | ignore | compute-*  ||      |
     |UDP checksum    |16|1 |Bi|         | ignore | compute-*  ||      |
     +================+==+==+==+=========+========+============++======+
:::

[Figure 26](#figure-26){.selfRef}: [Context Rules - Rule 0 and Rule
1](#name-context-rules-rule-0-and-ru){.selfRef}
:::

[]{#name-context-rules-rule-2}

::: {#Fig-fields1}
::: {#section-appendix.a-6.1 .artwork .art-text .alignLeft}
     Rule 2
     +----------------+--+--+--+---------+--------+------------++------+
     |       FID      |FL|FP|DI|    TV   |   MO   |     CDA    || Sent |
     |                |  |  |  |         |        |            ||[bits]|
     +----------------+--+--+--+---------+--------+------------++------+
     |IPv6 Version    |4 |1 |Bi|6        | ignore | not-sent   ||      |
     |IPv6 Diffserv   |8 |1 |Bi|0        | equal  | not-sent   ||      |
     |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |
     |IPv6 Length     |16|1 |Bi|         | ignore | compute-*  ||      |
     |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |
     |IPv6 Hop Limit  |8 |1 |Bi|255      | ignore | not-sent   ||      |
     |IPv6 DevPrefix  |64|1 |Bi|[alpha/64, match- |mapping-sent||   1  |
     |                |  |  |  |fe80::/64] mapping|            ||      |
     |IPv6 DevIID     |64|1 |Bi|         | ignore | DevIID     ||      |
     |IPv6 AppPrefix  |64|1 |Bi|[beta/64,| match- |mapping-sent||   2  |
     |                |  |  |  |alpha/64,| mapping|            ||      |
     |                |  |  |  |fe80::64]|        |            ||      |
     |IPv6 AppIID     |64|1 |Bi|::1000   | equal  | not-sent   ||      |
     +================+==+==+==+=========+========+============++======+
     |UDP DevPort     |16|1 |Bi|5683     | equal  | not-sent   ||      |
     |UDP AppPort     |16|1 |Bi|5683     | equal  | not-sent   ||      |
     |UDP Length      |16|1 |Bi|         | ignore | compute-*  ||      |
     |UDP checksum    |16|1 |Bi|         | ignore | compute-*  ||      |
     +================+==+==+==+=========+========+============++======+
:::

[Figure 27](#figure-27){.selfRef}: [Context Rules - Rule
2](#name-context-rules-rule-2){.selfRef}
:::

[]{#name-context-rules-rule-3}

::: {#Fig-fields2}
::: {#section-appendix.a-7.1 .artwork .art-text .alignLeft}
     Rule 3
     +----------------+--+--+--+---------+--------+------------++------+
     |       FID      |FL|FP|DI|    TV   |   MO   |     CDA    || Sent |
     |                |  |  |  |         |        |            ||[bits]|
     +----------------+--+--+--+---------+--------+------------++------+
     |IPv6 Version    |4 |1 |Bi|6        | ignore | not-sent   ||      |
     |IPv6 Diffserv   |8 |1 |Bi|0        | equal  | not-sent   ||      |
     |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |
     |IPv6 Length     |16|1 |Bi|         | ignore | compute-*  ||      |
     |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |
     |IPv6 Hop Limit  |8 |1 |Up|255      | ignore | not-sent   ||      |
     |IPv6 Hop Limit  |8 |1 |Dw|         | ignore | value-sent ||   8  |
     |IPv6 DevPrefix  |64|1 |Bi|alpha/64 | equal  | not-sent   ||      |
     |IPv6 DevIID     |64|1 |Bi|         | ignore | DevIID     ||      |
     |IPv6 AppPrefix  |64|1 |Bi|gamma/64 | equal  | not-sent   ||      |
     |IPv6 AppIID     |64|1 |Bi|::1000   | equal  | not-sent   ||      |
     +================+==+==+==+=========+========+============++======+
     |UDP DevPort     |16|1 |Bi|8720     | MSB(12)| LSB        ||   4  |
     |UDP AppPort     |16|1 |Bi|8720     | MSB(12)| LSB        ||   4  |
     |UDP Length      |16|1 |Bi|         | ignore | compute-*  ||      |
     |UDP checksum    |16|1 |Bi|         | ignore | compute-*  ||      |
     +================+==+==+==+=========+========+============++======+
:::

[Figure 28](#figure-28){.selfRef}: [Context Rules - Rule
3](#name-context-rules-rule-3){.selfRef}
:::

Figures [26](#Fig-fields){.xref} to [28](#Fig-fields2){.xref} describe
an example of a Rule set.[¶](#section-appendix.a-8){.pilcrow}

In this example, 0 was chosen as the special RuleID that tags packets
that cannot be compressed with any compression
Rule.[¶](#section-appendix.a-9){.pilcrow}

All the fields described in Rules 1-3 are present in the IPv6 and UDP
headers. The DevIID value is inferred from the L2
header.[¶](#section-appendix.a-10){.pilcrow}

Rules 2-3 use global addresses. The way the Dev learns the prefix is not
in the scope of the document.[¶](#section-appendix.a-11){.pilcrow}

Rule 3 compresses each port number to 4
bits.[¶](#section-appendix.a-12){.pilcrow}
:::
:::

::: {#FragExamples}
::: {#section-appendix.b .section}
## [Appendix B.](#section-appendix.b){.section-number .selfRef} [Fragmentation Examples](#name-fragmentation-examples){.section-name .selfRef} {#name-fragmentation-examples}

This section provides examples for the various fragment reliability
modes specified in this document. In the drawings, Bitmaps are shown in
their uncompressed form.[¶](#section-appendix.b-1){.pilcrow}

[Figure 29](#Fig-Example-Unreliable){.xref} illustrates the transmission
in No-ACK mode of a SCHC Packet that needs 11 SCHC Fragments. FCN is 1
bit wide.[¶](#section-appendix.b-2){.pilcrow}

[]{#name-no-ack-mode-11-schc-fragmen}

::: {#Fig-Example-Unreliable}
::: {#section-appendix.b-3.1 .artwork .art-text .alignLeft}
            Sender               Receiver
              |-------FCN=0-------->|
              |-------FCN=0-------->|
              |-------FCN=0-------->|
              |-------FCN=0-------->|
              |-------FCN=0-------->|
              |-------FCN=0-------->|
              |-------FCN=0-------->|
              |-------FCN=0-------->|
              |-------FCN=0-------->|
              |-------FCN=0-------->|
              |-----FCN=1 + RCS --->| Integrity check: success
            (End)
:::

[Figure 29](#figure-29){.selfRef}: [No-ACK Mode, 11 SCHC
Fragments](#name-no-ack-mode-11-schc-fragmen){.selfRef}
:::

In the following examples, N (the size of the FCN field) is 3 bits. The
All-1 FCN value is therefore 7.[¶](#section-appendix.b-4){.pilcrow}

[Figure 30](#Fig-Example-Win-NoLoss-NACK){.xref} illustrates the
transmission in ACK-on-Error mode of a SCHC Packet fragmented in 11
tiles, with one tile per SCHC Fragment, WINDOW_SIZE=7 and no lost SCHC
Fragment.[¶](#section-appendix.b-5){.pilcrow}

[]{#name-ack-on-error-mode-11-tiles-}

::: {#Fig-Example-Win-NoLoss-NACK}
::: {#section-appendix.b-6.1 .artwork .art-text .alignLeft}
            Sender               Receiver
              |-----W=0, FCN=6----->|
              |-----W=0, FCN=5----->|
              |-----W=0, FCN=4----->|
              |-----W=0, FCN=3----->|
              |-----W=0, FCN=2----->|
              |-----W=0, FCN=1----->|
              |-----W=0, FCN=0----->|
          (no ACK)
              |-----W=1, FCN=6----->|
              |-----W=1, FCN=5----->|
              |-----W=1, FCN=4----->|
              |--W=1, FCN=7 + RCS-->| Integrity check: success
              |<-- ACK, W=1, C=1 ---| C=1
            (End)
:::

[Figure 30](#figure-30){.selfRef}: [ACK-on-Error Mode, 11 Tiles, One
Tile per SCHC Fragment, No Lost SCHC
Fragment](#name-ack-on-error-mode-11-tiles-){.selfRef}
:::

[Figure 31](#Fig-Example-Rel-Window-NACK-Loss){.xref} illustrates the
transmission in ACK-on-Error mode of a SCHC Packet fragmented in 11
tiles, with one tile per SCHC Fragment, WINDOW_SIZE=7, and three lost
SCHC Fragments.[¶](#section-appendix.b-7){.pilcrow}

[]{#name-ack-on-error-mode-11-tiles-o}

::: {#Fig-Example-Rel-Window-NACK-Loss}
::: {#section-appendix.b-8.1 .artwork .art-text .alignLeft}
            Sender               Receiver
              |-----W=0, FCN=6----->|
              |-----W=0, FCN=5----->|
              |-----W=0, FCN=4--X-->|
              |-----W=0, FCN=3----->|
              |-----W=0, FCN=2--X-->|
              |-----W=0, FCN=1----->|
              |-----W=0, FCN=0----->|        6543210
              |<-- ACK, W=0, C=0 ---| Bitmap:1101011
              |-----W=0, FCN=4----->|
              |-----W=0, FCN=2----->|
          (no ACK)
              |-----W=1, FCN=6----->|
              |-----W=1, FCN=5----->|
              |-----W=1, FCN=4--X-->|
              |- W=1, FCN=7 + RCS ->| Integrity check: failure
              |<-- ACK, W=1, C=0 ---| C=0, Bitmap:1100001
              |-----W=1, FCN=4----->| Integrity check: success
              |<-- ACK, W=1, C=1 ---| C=1
            (End)
:::

[Figure 31](#figure-31){.selfRef}: [ACK-on-Error Mode, 11 Tiles, One
Tile per SCHC Fragment, Lost SCHC
Fragments](#name-ack-on-error-mode-11-tiles-o){.selfRef}
:::

[Figure 32](#Figure-Example-ACK-on-Error-VarMTU){.xref} shows an example
of a transmission in ACK-on-Error mode of a SCHC Packet fragmented in 73
tiles, with N=5, WINDOW_SIZE=28, M=2, and three lost SCHC
Fragments.[¶](#section-appendix.b-9){.pilcrow}

[]{#name-ack-on-error-mode-variable-}

::: {#Figure-Example-ACK-on-Error-VarMTU}
::: {#section-appendix.b-10.1 .artwork .art-text .alignLeft}
       Sender               Receiver
        |-----W=0, FCN=27----->| 4 tiles sent
        |-----W=0, FCN=23----->| 4 tiles sent
        |-----W=0, FCN=19----->| 4 tiles sent
        |-----W=0, FCN=15--X-->| 4 tiles sent (not received)
        |-----W=0, FCN=11----->| 4 tiles sent
        |-----W=0, FCN=7 ----->| 4 tiles sent
        |-----W=0, FCN=3 ----->| 4 tiles sent
        |-----W=1, FCN=27----->| 4 tiles sent
        |-----W=1, FCN=23----->| 4 tiles sent
        |-----W=1, FCN=19----->| 4 tiles sent
        |-----W=1, FCN=15----->| 4 tiles sent
        |-----W=1, FCN=11----->| 4 tiles sent
        |-----W=1, FCN=7 ----->| 4 tiles sent
        |-----W=1, FCN=3 --X-->| 4 tiles sent (not received)
        |-----W=2, FCN=27----->| 4 tiles sent
        |-----W=2, FCN=23----->| 4 tiles sent
    ^   |-----W=2, FCN=19----->| 1 tile sent
    |   |-----W=2, FCN=18----->| 1 tile sent
    |   |-----W=2, FCN=17----->| 1 tile sent
        |-----W=2, FCN=16----->| 1 tile sent
    s   |-----W=2, FCN=15----->| 1 tile sent
    m   |-----W=2, FCN=14----->| 1 tile sent
    a   |-----W=2, FCN=13--X-->| 1 tile sent (not received)
    l   |-----W=2, FCN=12----->| 1 tile sent
    l   |---W=2, FCN=31 + RCS->| Integrity check: failure
    e   |<--- ACK, W=0, C=0 ---| C=0, Bitmap:1111111111110000111111111111
    r   |-----W=0, FCN=15----->| 1 tile sent
        |-----W=0, FCN=14----->| 1 tile sent
    L   |-----W=0, FCN=13----->| 1 tile sent
    2   |-----W=0, FCN=12----->| 1 tile sent
        |<--- ACK, W=1, C=0 ---| C=0, Bitmap:1111111111111111111111110000
    M   |-----W=1, FCN=3 ----->| 1 tile sent
    T   |-----W=1, FCN=2 ----->| 1 tile sent
    U   |-----W=1, FCN=1 ----->| 1 tile sent
        |-----W=1, FCN=0 ----->| 1 tile sent
    |   |<--- ACK, W=2, C=0 ---| C=0, Bitmap:1111111111111101000000000001
    |   |-----W=2, FCN=13----->| Integrity check: success
    V   |<--- ACK, W=2, C=1 ---| C=1
      (End)
:::

[Figure 32](#figure-32){.selfRef}: [ACK-on-Error Mode, Variable
MTU](#name-ack-on-error-mode-variable-){.selfRef}
:::

In this example, the L2 MTU becomes reduced just before sending the
\"W=2, FCN=19\" fragment, leaving space for only one tile in each
forthcoming SCHC Fragment. Before retransmissions, the 73 tiles are
carried by a total of 25 SCHC Fragments, the last nine being of smaller
size.[¶](#section-appendix.b-11){.pilcrow}

Note: other sequences of events (e.g., regarding when ACKs are sent by
the Receiver) are also allowed by this specification. Profiles may
restrict this flexibility.[¶](#section-appendix.b-12){.pilcrow}

[Figure 33](#Fig-Example-Rel-Window-ACK-NoLoss){.xref} illustrates the
transmission in ACK-Always mode of a SCHC Packet fragmented in 11 tiles,
with one tile per SCHC Fragment, with N=3, WINDOW_SIZE=7, and no
loss.[¶](#section-appendix.b-13){.pilcrow}

[]{#name-ack-always-mode-11-tiles-on}

::: {#Fig-Example-Rel-Window-ACK-NoLoss}
::: {#section-appendix.b-14.1 .artwork .art-text .alignLeft}
            Sender               Receiver
              |-----W=0, FCN=6----->|
              |-----W=0, FCN=5----->|
              |-----W=0, FCN=4----->|
              |-----W=0, FCN=3----->|
              |-----W=0, FCN=2----->|
              |-----W=0, FCN=1----->|
              |-----W=0, FCN=0----->|
              |<-- ACK, W=0, C=0 ---| Bitmap:1111111
              |-----W=1, FCN=6----->|
              |-----W=1, FCN=5----->|
              |-----W=1, FCN=4----->|
              |--W=1, FCN=7 + RCS-->| Integrity check: success
              |<-- ACK, W=1, C=1 ---| C=1
            (End)
:::

[Figure 33](#figure-33){.selfRef}: [ACK-Always Mode, 11 Tiles, One Tile
per SCHC Fragment, No Loss](#name-ack-always-mode-11-tiles-on){.selfRef}
:::

[Figure 34](#Fig-Example-Rel-Window-ACK-Loss){.xref} illustrates the
transmission in ACK-Always mode of a SCHC Packet fragmented in 11 tiles,
with one tile per SCHC Fragment, N=3, WINDOW_SIZE=7 and three lost SCHC
Fragments.[¶](#section-appendix.b-15){.pilcrow}

[]{#name-ack-always-mode-11-tiles-one}

::: {#Fig-Example-Rel-Window-ACK-Loss}
::: {#section-appendix.b-16.1 .artwork .art-text .alignLeft}
            Sender               Receiver
              |-----W=0, FCN=6----->|
              |-----W=0, FCN=5----->|
              |-----W=0, FCN=4--X-->|
              |-----W=0, FCN=3----->|
              |-----W=0, FCN=2--X-->|
              |-----W=0, FCN=1----->|
              |-----W=0, FCN=0----->|        6543210
              |<-- ACK, W=0, C=0 ---| Bitmap:1101011
              |-----W=0, FCN=4----->|
              |-----W=0, FCN=2----->|
              |<-- ACK, W=0, C=0 ---| Bitmap:1111111
              |-----W=1, FCN=6----->|
              |-----W=1, FCN=5----->|
              |-----W=1, FCN=4--X-->|
              |--W=1, FCN=7 + RCS-->| Integrity check: failure
              |<-- ACK, W=1, C=0 ---| C=0, Bitmap:11000001
              |-----W=1, FCN=4----->| Integrity check: success
              |<-- ACK, W=1, C=1 ---| C=1
            (End)
:::

[Figure 34](#figure-34){.selfRef}: [ACK-Always Mode, 11 Tiles, One Tile
per SCHC Fragment, Three Lost SCHC
Fragments](#name-ack-always-mode-11-tiles-one){.selfRef}
:::

[Figure 35](#Fig-Example-Rel-Window-ACK-Loss-Last-A){.xref} illustrates
the transmission in ACK-Always mode of a SCHC Packet fragmented in six
tiles, with one tile per SCHC Fragment, N=3, WINDOW_SIZE=7, three lost
SCHC Fragments, and only one retry needed to recover each lost SCHC
Fragment.[¶](#section-appendix.b-17){.pilcrow}

[]{#name-ack-always-mode-six-tiles-o}

::: {#Fig-Example-Rel-Window-ACK-Loss-Last-A}
::: {#section-appendix.b-18.1 .artwork .art-text .alignLeft}
              Sender                Receiver
                 |-----W=0, FCN=6----->|
                 |-----W=0, FCN=5----->|
                 |-----W=0, FCN=4--X-->|
                 |-----W=0, FCN=3--X-->|
                 |-----W=0, FCN=2--X-->|
                 |--W=0, FCN=7 + RCS-->| Integrity check: failure
                 |<-- ACK, W=0, C=0 ---| C=0, Bitmap:1100001
                 |-----W=0, FCN=4----->| Integrity check: failure
                 |-----W=0, FCN=3----->| Integrity check: failure
                 |-----W=0, FCN=2----->| Integrity check: success
                 |<-- ACK, W=0, C=1 ---| C=1
               (End)
:::

[Figure 35](#figure-35){.selfRef}: [ACK-Always Mode, Six Tiles, One Tile
per SCHC Fragment, Three Lost SCHC
Fragments](#name-ack-always-mode-six-tiles-o){.selfRef}
:::

[Figure 36](#Fig-Example-Rel-Window-ACK-Loss-Last-B){.xref} illustrates
the transmission in ACK-Always mode of a SCHC Packet fragmented in six
tiles, with one tile per SCHC Fragment, N=3, WINDOW_SIZE=7, three lost
SCHC Fragments, and the second SCHC ACK
lost.[¶](#section-appendix.b-19){.pilcrow}

[]{#name-ack-always-mode-six-tiles-on}

::: {#Fig-Example-Rel-Window-ACK-Loss-Last-B}
::: {#section-appendix.b-20.1 .artwork .art-text .alignLeft}
              Sender                Receiver
                 |-----W=0, FCN=6----->|
                 |-----W=0, FCN=5----->|
                 |-----W=0, FCN=4--X-->|
                 |-----W=0, FCN=3--X-->|
                 |-----W=0, FCN=2--X-->|
                 |--W=0, FCN=7 + RCS-->| Integrity check: failure
                 |<-- ACK, W=0, C=0 ---| C=0, Bitmap:1100001
                 |-----W=0, FCN=4----->| Integrity check: failure
                 |-----W=0, FCN=3----->| Integrity check: failure
                 |-----W=0, FCN=2----->| Integrity check: success
                 |<-X-ACK, W=0, C=1 ---| C=1
        timeout  |                     |
                 |--- W=0, ACK REQ --->| ACK REQ
                 |<-- ACK, W=0, C=1 ---| C=1
               (End)
:::

[Figure 36](#figure-36){.selfRef}: [ACK-Always Mode, Six Tiles, One Tile
per SCHC Fragment, SCHC ACK
Loss](#name-ack-always-mode-six-tiles-on){.selfRef}
:::

[Figure 37](#Fig-Example-Rel-Window-ACK-Loss-Last-C){.xref} illustrates
the transmission in ACK-Always mode of a SCHC Packet fragmented in six
tiles, with N=3, WINDOW_SIZE=7, with three lost SCHC Fragments, and one
retransmitted SCHC Fragment lost
again.[¶](#section-appendix.b-21){.pilcrow}

[]{#name-ack-always-mode-six-tiles-r}

::: {#Fig-Example-Rel-Window-ACK-Loss-Last-C}
::: {#section-appendix.b-22.1 .artwork .art-text .alignLeft}
               Sender                Receiver
                 |-----W=0, FCN=6----->|
                 |-----W=0, FCN=5----->|
                 |-----W=0, FCN=4--X-->|
                 |-----W=0, FCN=3--X-->|
                 |-----W=0, FCN=2--X-->|
                 |--W=0, FCN=7 + RCS-->| Integrity check: failure
                 |<-- ACK, W=0, C=0 ---| C=0, Bitmap:1100001
                 |-----W=0, FCN=4----->| Integrity check: failure
                 |-----W=0, FCN=3----->| Integrity check: failure
                 |-----W=0, FCN=2--X-->|
          timeout|                     |
                 |--- W=0, ACK REQ --->| ACK REQ
                 |<-- ACK, W=0, C=0 ---| C=0, Bitmap: 1111101
                 |-----W=0, FCN=2----->| Integrity check: success
                 |<-- ACK, W=0, C=1 ---| C=1
               (End)
:::

[Figure 37](#figure-37){.selfRef}: [ACK-Always Mode, Six Tiles,
Retransmitted SCHC Fragment Lost
Again](#name-ack-always-mode-six-tiles-r){.selfRef}
:::

[Figure 38](#Fig-Example-MaxWindFCN){.xref} illustrates the transmission
in ACK-Always mode of a SCHC Packet fragmented in 28 tiles, with one
tile per SCHC Fragment, N=5, WINDOW_SIZE=24, and two lost SCHC
Fragments.[¶](#section-appendix.b-23){.pilcrow}

[]{#name-ack-always-mode-28-tiles-on}

::: {#Fig-Example-MaxWindFCN}
::: {#section-appendix.b-24.1 .artwork .art-text .alignLeft}
          Sender               Receiver
            |-----W=0, FCN=23----->|
            |-----W=0, FCN=22----->|
            |-----W=0, FCN=21--X-->|
            |-----W=0, FCN=20----->|
            |-----W=0, FCN=19----->|
            |-----W=0, FCN=18----->|
            |-----W=0, FCN=17----->|
            |-----W=0, FCN=16----->|
            |-----W=0, FCN=15----->|
            |-----W=0, FCN=14----->|
            |-----W=0, FCN=13----->|
            |-----W=0, FCN=12----->|
            |-----W=0, FCN=11----->|
            |-----W=0, FCN=10--X-->|
            |-----W=0, FCN=9 ----->|
            |-----W=0, FCN=8 ----->|
            |-----W=0, FCN=7 ----->|
            |-----W=0, FCN=6 ----->|
            |-----W=0, FCN=5 ----->|
            |-----W=0, FCN=4 ----->|
            |-----W=0, FCN=3 ----->|
            |-----W=0, FCN=2 ----->|
            |-----W=0, FCN=1 ----->|
            |-----W=0, FCN=0 ----->|
            |                      |
            |<--- ACK, W=0, C=0 ---| Bitmap:110111111111101111111111
            |-----W=0, FCN=21----->|
            |-----W=0, FCN=10----->|
            |<--- ACK, W=0, C=0 ---| Bitmap:111111111111111111111111
            |-----W=1, FCN=23----->|
            |-----W=1, FCN=22----->|
            |-----W=1, FCN=21----->|
            |--W=1, FCN=31 + RCS-->| Integrity check: success
            |<--- ACK, W=1, C=1 ---| C=1
          (End)
:::

[Figure 38](#figure-38){.selfRef}: [ACK-Always Mode, 28 Tiles, One Tile
per SCHC Fragment, Lost SCHC
Fragments](#name-ack-always-mode-28-tiles-on){.selfRef}
:::
:::
:::

::: {#FSM}
::: {#section-appendix.c .section}
## [Appendix C.](#section-appendix.c){.section-number .selfRef} [Fragmentation State Machines](#name-fragmentation-state-machine){.section-name .selfRef} {#name-fragmentation-state-machine}

The fragmentation state machines of the sender and the receiver, one for
each of the different reliability modes, are described in the following
figures:[¶](#section-appendix.c-1){.pilcrow}

[]{#name-sender-state-machine-for-th}

::: {#Fig-NoACKModeSnd}
::: {#section-appendix.c-2.1 .artwork .art-text .alignLeft}
                 +===========+
    +------------+  Init     |
    |  FCN=0     +===========+
    |  No Window
    |  No Bitmap
    |                   +-------+
    |          +========+==+    | More Fragments
    |          |           | <--+ ~~~~~~~~~~~~~~~~~~~~
    +--------> |   Send    |      send Fragment (FCN=0)
               +===+=======+
                   |  last fragment
                   |  ~~~~~~~~~~~~
                   |  FCN = 1
                   v  send fragment+RCS
               +============+
               |    END     |
               +============+
:::

[Figure 39](#figure-39){.selfRef}: [Sender State Machine for the No-ACK
Mode](#name-sender-state-machine-for-th){.selfRef}
:::

[]{#name-receiver-state-machine-for-}

::: {#Fig-NoACKModeRcv}
::: {#section-appendix.c-3.1 .artwork .art-text .alignLeft}
                          +------+ Not All-1
               +==========+=+    | ~~~~~~~~~~~~~~~~~~~
               |            + <--+ set Inactivity Timer
               |  RCV Frag  +-------+
               +=+===+======+       |All-1 &
       All-1 &   |   |              |RCS correct
     RCS wrong   |   |Inactivity    |
                 |   |Timer Exp.    |
                 v   |              |
      +==========++  |              v
      |   Error   |<-+     +========+==+
      +===========+        |    END    |
                           +===========+
:::

[Figure 40](#figure-40){.selfRef}: [Receiver State Machine for the
No-ACK Mode](#name-receiver-state-machine-for-){.selfRef}
:::

[]{#name-sender-state-machine-for-the}

::: {#Fig-ACKAlwaysSnd}
::: {#section-appendix.c-4.1 .artwork .art-text .alignLeft}
                  +=======+
                  | INIT  |       FCN!=0 & more frags
                  |       |       ~~~~~~~~~~~~~~~~~~~~~~
                  +======++  +--+ send Window + frag(FCN)
                     W=0 |   |  | FCN-
      Clear lcl_bm       |   |  v set lcl_bm
           FCN=max value |  ++==+========+
                         +> |            |
    +---------------------> |    SEND    |
    |                       +==+===+=====+
    |      FCN==0 & more frags |   | last frag
    |    ~~~~~~~~~~~~~~~~~~~~~ |   | ~~~~~~~~~~~~~~~
    |               set lcl_bm |   | set lcl_bm
    |   send wnd + frag(all-0) |   | send wnd+frag(all-1)+RCS
    |       set Retrans_Timer  |   | set Retrans_Timer
    |                          |   |
    |Recv_wnd == wnd &         |   |
    |lcl_bm==recv_bm &         |   |  +----------------------+
    |more frag                 |   |  | lcl_bm!=rcv-bm       |
    |~~~~~~~~~~~~~~~~~~~~~~    |   |  | ~~~~~~~~~            |
    |Stop Retrans_Timer        |   |  | Attempt++            v
    |clear lcl_bm              v   v  |                +=====+=+
    |window=next_window   +====+===+==+===+            |Resend |
    +---------------------+               |            |Missing|
                     +----+     Wait      |            |Frag   |
    not expected wnd |    |    Bitmap     |            +=======+
    ~~~~~~~~~~~~~~~~ +--->+               ++Retrans_Timer Exp  |
        discard frag      +==+=+===+=+==+=+| ~~~~~~~~~~~~~~~~~ |
                             | |   | ^  ^  |reSend(empty)All-* |
                             | |   | |  |  |Set Retrans_Timer  |
                             | |   | |  +--+Attempt++          |
      C_bit==1 &             | |   | +-------------------------+
    Recv_window==window &    | |   |   all missing frags sent
                 no more frag| |   |   ~~~~~~~~~~~~~~~~~~~~~~
     ~~~~~~~~~~~~~~~~~~~~~~~~| |   |   Set Retrans_Timer
           Stop Retrans_Timer| |   |
     +=============+         | |   |
     |     END     +<--------+ |   |
     +=============+           |   | Attempt > MAX_ACK_REQUESTS
                All-1 Window & |   | ~~~~~~~~~~~~~~~~~~
                   C_bit ==0 & |   v Send Abort
              lcl_bm==recv_bm  | +=+===========+
                  ~~~~~~~~~~~~ +>|    ERROR    |
                    Send Abort   +=============+
:::

[Figure 41](#figure-41){.selfRef}: [Sender State Machine for the
ACK-Always Mode](#name-sender-state-machine-for-the){.selfRef}
:::

[]{#name-receiver-state-machine-for-t}

::: {#Fig-ACKAlwaysRcv}
::: {#section-appendix.c-5.1 .artwork .art-text .alignLeft}
     Not All- & w=expected +---+   +---+w = Not expected
     ~~~~~~~~~~~~~~~~~~~~~ |   |   |   |~~~~~~~~~~~~~~~~
     Set lcl_bm(FCN)       |   v   v   |discard
                          ++===+===+===+=+
    +---------------------+     Rcv      +--->* ABORT
    |  +------------------+   Window     |
    |  |                  +=====+==+=====+
    |  |       All-0 & w=expect |  ^ w =next & not-All
    |  |     ~~~~~~~~~~~~~~~~~~ |  |~~~~~~~~~~~~~~~~~~~~~
    |  |    set lcl_bm(FCN)     |  |expected = next window
    |  |      send lcl_bm       |  |Clear lcl_bm
    |  |                        |  |
    |  | w=expected & not-All   |  |
    |  | ~~~~~~~~~~~~~~~~~~     |  |
    |  |     set lcl_bm(FCN)+-+ |  | +--+ w=next & All-0
    |  |     if lcl_bm full | | |  | |  | ~~~~~~~~~~~~~~~
    |  |     send lcl_bm    | | |  | |  | expected = nxt wnd
    |  |                    v | v  | |  | Clear lcl_bm
    |  |w=expected& All-1 +=+=+=+==+=++ | set lcl_bm(FCN)
    |  |  ~~~~~~~~~~~  +->+    Wait   +<+ send lcl_bm
    |  |    discard    +--|    Next   |
    |  | All-0  +---------+  Window   +--->* ABORT
    |  | ~~~~~  +-------->+========+=++
    |  | snd lcl_bm  All-1 & w=next| |  All-1 & w=nxt
    |  |                & RCS wrong| |  & RCS right
    |  |          ~~~~~~~~~~~~~~~~~| | ~~~~~~~~~~~~~~~~~~
    |  |            set lcl_bm(FCN)| |set lcl_bm(FCN)
    |  |                send lcl_bm| |send lcl_bm
    |  |                           | +----------------------+
    |  |All-1 & w=expected         |                        |
    |  |& RCS wrong                v   +---+ w=expected &   |
    |  |~~~~~~~~~~~~~~~~~~~~  +====+=====+ | RCS wrong      |
    |  |set lcl_bm(FCN)       |          +<+ ~~~~~~~~~~~~~~ |
    |  |send lcl_bm           | Wait End |   set lcl_bm(FCN)|
    |  +--------------------->+          +--->* ABORT       |
    |                         +===+====+=+-+ All-1&RCS wrong|
    |                             |    ^   | ~~~~~~~~~~~~~~~|
    |      w=expected & RCS right |    +---+   send lcl_bm  |
    |      ~~~~~~~~~~~~~~~~~~~~~~ |                         |
    |       set lcl_bm(FCN)       | +-+ Not All-1           |
    |        send lcl_bm          | | | ~~~~~~~~~           |
    |                             | | |  discard            |
    |All-1&w=expected & RCS right | | |                     |
    |~~~~~~~~~~~~~~~~~~~~~~~~~~~~ v | v +----+All-1         |
    |set lcl_bm(FCN)            +=+=+=+=+==+ |~~~~~~~~~     |
    |send lcl_bm                |          +<+Send lcl_bm   |
    +-------------------------->+    END   |                |
                                +==========+<---------------+

           --->* ABORT

           In any state
              on receiving a SCHC ACK REQ
                 Send a SCHC ACK for the current window
:::

[Figure 42](#figure-42){.selfRef}: [Receiver State Machine for the
ACK-Always Mode](#name-receiver-state-machine-for-t){.selfRef}
:::

[]{#name-sender-state-machine-for-the-}

::: {#Fig-ACKonerrorSnd}
::: {#section-appendix.c-6.1 .artwork .art-text .alignLeft}
                      +=======+
                      |       |
                      | INIT  |
                      |       |       FCN!=0 & more frags
                      +======++       ~~~~~~~~~~~~~~~~~~~~~~
         Frag RuleID trigger |   +--+ Send cur_W + frag(FCN);
         ~~~~~~~~~~~~~~~~~~~ |   |  | FCN--;
      cur_W=0; FCN=max_value;|   |  | set [cur_W, cur_Bmp]
        clear [cur_W, Bmp_n];|   |  v
              clear rcv_Bmp  |  ++==+==========+       **BACK_TO_SEND
                             +->+              |   cur_W==rcv_W &
          **BACK_TO_SEND        |     SEND     |   [cur_W,Bmp_n]==rcv_Bmp
    +-------------------------->+              |   & more frags
    |  +----------------------->+              |   ~~~~~~~~~~~~
    |  |                        ++==+==========+   cur_W++;
    |  |      FCN==0 & more frags|  |last frag     clear [cur_W, Bmp_n]
    |  |  ~~~~~~~~~~~~~~~~~~~~~~~|  |~~~~~~~~~
    |  |        set cur_Bmp;     |  |set [cur_W, Bmp_n];
    |  |send cur_W + frag(All-0);|  |send cur_W + frag(All-1)+RCS;
    |  |        set Retrans_Timer|  |set Retrans_Timer
    |  |                         |  | +---------------------------------+
    |  |                         |  | |cur_W ==                         |
    |  |Retrans_Timer expires &  |  | |   rcv_W & [cur_W,Bmp_n]!=rcv_Bmp|
    |  |more Frags               |  | |  ~~~~~~~~~~~~~~~~~~~            |
    |  |~~~~~~~~~~~~~~~~~~~~     |  | |  Attempts++; W=cur_W            |
    |  |stop Retrans_Timer;      |  | | +--------+           rcv_W==Wn &|
    |  |[cur_W,Bmp_n]==cur_Bmp;  v  v | |        v   [Wn,Bmp_n]!=rcv_Bmp|
    |  |cur_W++            +=====+==+=+=+==+   +=+=========+ ~~~~~~~~~~~|
    |  +-------------------+               |   | Resend    | Attempts++;|
    +----------------------+   Wait x ACK  |   | Missing   |       W=Wn |
    +--------------------->+               |   | Frags(W)  +<-----------+
    |         rcv_W==Wn &+-+               |   +======+====+
    | [Wn,Bmp_n]!=rcv_Bmp| ++=+===+===+==+=+          |
    |      ~~~~~~~~~~~~~~|  ^ |   |   |  ^            |
    |        send (cur_W,+--+ |   |   |  +------------+
    |        ALL-0-empty)     |   |   |     all missing frag sent(W)
    |                         |   |   |     ~~~~~~~~~~~~~~~~~
    |  Retrans_Timer expires &|   |   |     set Retrans_Timer
    |            No more Frags|   |   |
    |           ~~~~~~~~~~~~~~|   |   |
    |      stop Retrans_Timer;|   |   |
    |(re)send frag(All-1)+RCS |   |   |
    +-------------------------+   |   |
                     cur_W==rcv_W&|   |
           [cur_W,Bmp_n]==rcv_Bmp&|   | Attempts > MAX_ACK_REQUESTS
      No more Frags & RCS flag==OK|   | ~~~~~~~~~~
                ~~~~~~~~~~~~~~~~~~|   | send Abort
     +=========+stop Retrans_Timer|   |  +===========+
     |   END   +<-----------------+   +->+   ERROR   |
     +=========+                         +===========+
:::

[Figure 43](#figure-43){.selfRef}: [Sender State Machine for the
ACK-on-Error Mode](#name-sender-state-machine-for-the-){.selfRef}
:::

This is an example only. It is not normative. The specification in
[Section 8.4.3.1](#ACK-on-Error-sender){.xref} allows for sequences of
operations different from the one shown
here.[¶](#section-appendix.c-7){.pilcrow}

::: {#section-appendix.c-8 .artwork .art-text .alignLeft}
                     +=======+        New frag RuleID received
                     |       |        ~~~~~~~~~~~~~
                     | INIT  +-------+cur_W=0;clear([cur_W,Bmp_n]);
                     +=======+       |sync=0
                                     |
        Not All* & rcv_W==cur_W+---+ | +--+
          ~~~~~~~~~~~~~~~~~~~~ |   | | | (E)
          set[cur_W,Bmp_n(FCN)]|   v v v  |
                              ++===+=+=+==+=+
       +----------------------+             +--+ All-0&Full[cur_W,Bmp_n]
       |           ABORT *<---+  Rcv Window |  | ~~~~~~~~~~
       |  +-------------------+             +<-+ cur_W++;set Inact_timer;
       |  |                +->+=+=+=+=+=+===+    clear [cur_W,Bmp_n]
       |  | All-0 empty(Wn)|    | | | ^ ^
       |  | ~~~~~~~~~~~~~~ +----+ | | | |rcv_W==cur_W & sync==0;
       |  | sendACK([Wn,Bmp_n])   | | | |& Full([cur_W,Bmp_n])
       |  |                       | | | |& All* || last_miss_frag
       |  |                       | | | |~~~~~~~~~~~~~~~~~~~~~~
       |  |    All* & rcv_W==cur_W|(C)| |sendACK([cur_W,Bmp_n]);
       |  |              & sync==0| | | |cur_W++; clear([cur_W,Bmp_n])
       |  |&no_full([cur_W,Bmp_n])| |(E)|
       |  |      ~~~~~~~~~~~~~~~~ | | | |              +========+
       |  | sendACK([cur_W,Bmp_n])| | | |              | Error/ |
       |  |                       | | | |   +----+     | Abort  |
       |  |                       v v | |   |    |     +===+====+
       |  |                   +===+=+=+=+===+=+ (D)        ^
       |  |                +--+    Wait x     |  |         |
       |  | All-0 empty(Wn)+->| Missing Frags |<-+         |
       |  | ~~~~~~~~~~~~~~    +=============+=+            |
       |  | sendACK([Wn,Bmp_n])             +--------------+
       |  |                                       *ABORT
       v  v
      (A)(B)
                                       (D) All* || last_miss_frag
        (C) All* & sync>0                  & rcv_W!=cur_W & sync>0
            ~~~~~~~~~~~~                   & Full([rcv_W,Bmp_n])
            Wn=oldest[not full(W)];        ~~~~~~~~~~~~~~~~~~~~
            sendACK([Wn,Bmp_n])            Wn=oldest[not full(W)];
                                           sendACK([Wn,Bmp_n]);sync--

                                 ABORT-->* Uplink Only &
                                           Inact_Timer expires
        (E) Not All* & rcv_W!=cur_W        || Attempts > MAX_ACK_REQUESTS
            ~~~~~~~~~~~~~~~~~~~~           ~~~~~~~~~~~~~~~~~~~~~
            sync++; cur_W=rcv_W;           send Abort
            set[cur_W,Bmp_n(FCN)]

[¶](#section-appendix.c-8){.pilcrow}
:::

[]{#name-receiver-state-machine-for-th}

::: {#Fig-ACKonerrorRcv}
::: {#section-appendix.c-9.1 .artwork .art-text .alignLeft}
      (A)(B)
       |  |
       |  | All-1 & rcv_W==cur_W & RCS!=OK        All-0 empty(Wn)
       |  | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~     +-+  ~~~~~~~~~~
       |  | sendACK([cur_W,Bmp_n],C=0)       | v  sendACK([Wn,Bmp_n])
       |  |                      +===========+=++
       |  +--------------------->+   Wait End   +-+
       |                         +=====+=+====+=+ | All-1
       |     rcv_W==cur_W & RCS==OK    | |    ^   | & rcv_W==cur_W
       |     ~~~~~~~~~~~~~~~~~~~~~~    | |    +---+ & RCS!=OK
       |  sendACK([cur_W,Bmp_n],C=1)   | |          ~~~~~~~~~~~~~~~~~~~
       |                               | | sendACK([cur_W,Bmp_n],C=0);
       |                               | |          Attempts++
       |All-1 & Full([cur_W,Bmp_n])    | |
       |& RCS==OK & sync==0            | +-->* ABORT
       |~~~~~~~~~~~~~~~~~~~            v
       |sendACK([cur_W,Bmp_n],C=1)   +=+=========+
       +---------------------------->+    END    |
                                     +===========+
:::

[Figure 44](#figure-44){.selfRef}: [Receiver State Machine for the
ACK-on-Error Mode](#name-receiver-state-machine-for-th){.selfRef}
:::
:::
:::

::: {#SCHCParams}
::: {#section-appendix.d .section}
## [Appendix D.](#section-appendix.d){.section-number .selfRef} [SCHC Parameters](#name-schc-parameters){.section-name .selfRef} {#name-schc-parameters}

This section lists the information that needs to be provided in the
LPWAN technology-specific documents.[¶](#section-appendix.d-1){.pilcrow}

-   [Most common uses cases, deployment
    scenarios.[¶](#section-appendix.d-2.1){.pilcrow}]{#section-appendix.d-2.1}
-   [Mapping of the SCHC architectural elements onto the LPWAN
    architecture.[¶](#section-appendix.d-2.2){.pilcrow}]{#section-appendix.d-2.2}
-   [Assessment of LPWAN integrity
    checking.[¶](#section-appendix.d-2.3){.pilcrow}]{#section-appendix.d-2.3}
-   [Various potential channel conditions for the technology and the
    corresponding recommended use of SCHC C/D and SCHC
    F/R.[¶](#section-appendix.d-2.4){.pilcrow}]{#section-appendix.d-2.4}

This section lists the parameters that need to be defined in the
Profile.[¶](#section-appendix.d-3){.pilcrow}

-   [RuleID numbering scheme, fixed-size or variable-size RuleIDs,
    number of Rules, the way the RuleID is
    transmitted.[¶](#section-appendix.d-4.1){.pilcrow}]{#section-appendix.d-4.1}

-   [maximum packet size that should ever be reconstructed by SCHC
    decompression (MAX_PACKET_SIZE). See [Section
    12](#SecConsiderations){.xref}.[¶](#section-appendix.d-4.2){.pilcrow}]{#section-appendix.d-4.2}

-   [Padding: size of the L2 Word (for most LPWAN technologies, this
    would be a byte; for some technologies, a
    bit).[¶](#section-appendix.d-4.3){.pilcrow}]{#section-appendix.d-4.3}

-   ::: {#section-appendix.d-4.4}
    Decision to use SCHC fragmentation mechanism or not. If yes, the
    document must describe:[¶](#section-appendix.d-4.4.1){.pilcrow}

    -   [reliability mode(s) used, in which cases (e.g., based on link
        channel
        condition).[¶](#section-appendix.d-4.4.2.1){.pilcrow}]{#section-appendix.d-4.4.2.1}
    -   [RuleID values assigned to each mode in
        use.[¶](#section-appendix.d-4.4.2.2){.pilcrow}]{#section-appendix.d-4.4.2.2}
    -   [presence and number of bits for DTag (T) for each RuleID value,
        lifetime of DTag at the
        receiver.[¶](#section-appendix.d-4.4.2.3){.pilcrow}]{#section-appendix.d-4.4.2.3}
    -   [support for interleaved packet transmission, to what
        extent.[¶](#section-appendix.d-4.4.2.4){.pilcrow}]{#section-appendix.d-4.4.2.4}
    -   [WINDOW_SIZE, for modes that use
        windows.[¶](#section-appendix.d-4.4.2.5){.pilcrow}]{#section-appendix.d-4.4.2.5}
    -   [number of bits for W (M) for each RuleID value, for modes that
        use
        windows.[¶](#section-appendix.d-4.4.2.6){.pilcrow}]{#section-appendix.d-4.4.2.6}
    -   [number of bits for FCN (N) for each RuleID value, meaning of
        the FCN
        values.[¶](#section-appendix.d-4.4.2.7){.pilcrow}]{#section-appendix.d-4.4.2.7}
    -   [what makes an All-0 SCHC Fragment and a SCHC ACK REQ
        distinguishable (see [Section
        8.3.1.1](#NotLastFrag){.xref}).[¶](#section-appendix.d-4.4.2.8){.pilcrow}]{#section-appendix.d-4.4.2.8}
    -   [what makes an All-1 SCHC Fragment and a SCHC Sender-Abort
        distinguishable (see [Section
        8.3.1.2](#LastFrag){.xref}).[¶](#section-appendix.d-4.4.2.9){.pilcrow}]{#section-appendix.d-4.4.2.9}
    -   [for RuleIDs that use ACK-on-Error mode: when the last tile of a
        SCHC Packet is to be sent in a Regular SCHC Fragment, alone in
        an All-1 SCHC Fragment or with any of these two
        methods.[¶](#section-appendix.d-4.4.2.10){.pilcrow}]{#section-appendix.d-4.4.2.10}
    -   [for RuleIDs that use ACK-on-Error mode: if the penultimate tile
        of a SCHC Packet is of the regular size only or if it can also
        be one L2 Word
        shorter.[¶](#section-appendix.d-4.4.2.11){.pilcrow}]{#section-appendix.d-4.4.2.11}
    -   [for RuleIDs that use ACK-on-Error mode: times at which the
        sender must listen for SCHC
        ACKs.[¶](#section-appendix.d-4.4.2.12){.pilcrow}]{#section-appendix.d-4.4.2.12}
    -   [size of RCS and algorithm for its computation, for each RuleID,
        if different from the default CRC32. Byte fill-up with zeroes or
        other mechanism, to be specified. Support for UDP checksum
        elision.[¶](#section-appendix.d-4.4.2.13){.pilcrow}]{#section-appendix.d-4.4.2.13}
    -   [Retransmission Timer duration for each RuleID value, if
        applicable to the SCHC F/R
        mode.[¶](#section-appendix.d-4.4.2.14){.pilcrow}]{#section-appendix.d-4.4.2.14}
    -   [Inactivity Timer duration for each RuleID value, if applicable
        to the SCHC F/R
        mode.[¶](#section-appendix.d-4.4.2.15){.pilcrow}]{#section-appendix.d-4.4.2.15}
    -   [MAX_ACK_REQUESTS value for each RuleID value, if applicable to
        the SCHC F/R
        mode.[¶](#section-appendix.d-4.4.2.16){.pilcrow}]{#section-appendix.d-4.4.2.16}
    :::

-   [if L2 Word is wider than a bit and SCHC fragmentation is used,
    value of the padding bits (0 or
    1).[¶](#section-appendix.d-4.5){.pilcrow}]{#section-appendix.d-4.5}

A Profile may define a delay to be added after each SCHC message
transmission for compliance with local regulations or other constraints
imposed by the applications.[¶](#section-appendix.d-5){.pilcrow}

-   [In some LPWAN technologies, as part of energy-saving techniques,
    Downlink transmission is only possible immediately after an Uplink
    transmission. In order to avoid potentially high delay in the
    Downlink transmission of a fragmented SCHC Packet, the SCHC Fragment
    receiver may perform an Uplink transmission as soon as possible
    after reception of a SCHC Fragment that is not the last one. Such
    Uplink transmission may be triggered by the L2 (e.g., an L2 ACK sent
    in response to a SCHC Fragment encapsulated in a L2 PDU that
    requires an L2 ACK) or it may be triggered from an upper layer. See
    [Appendix
    F](#AsymLinks){.xref}.[¶](#section-appendix.d-6.1){.pilcrow}]{#section-appendix.d-6.1}

-   ::: {#section-appendix.d-6.2}
    the following parameters need to be addressed in documents other
    than this one but not necessarily in the LPWAN technology-specific
    documents:[¶](#section-appendix.d-6.2.1){.pilcrow}

    -   [The way the Contexts are
        provisioned.[¶](#section-appendix.d-6.2.2.1){.pilcrow}]{#section-appendix.d-6.2.2.1}
    -   [The way the Rules are
        generated.[¶](#section-appendix.d-6.2.2.2){.pilcrow}]{#section-appendix.d-6.2.2.2}
    :::
:::
:::

::: {#MultWinSizes}
::: {#section-appendix.e .section}
## [Appendix E.](#section-appendix.e){.section-number .selfRef} [Supporting Multiple Window Sizes for Fragmentation](#name-supporting-multiple-window-){.section-name .selfRef} {#name-supporting-multiple-window-}

For ACK-Always or ACK-on-Error, implementers may opt to support a single
window size or multiple window sizes. The latter, when feasible, may
provide performance optimizations. For example, a large WINDOW_SIZE
should be used for packets that need to be split into a large number of
tiles. However, when the number of tiles required to carry a packet is
low, a smaller WINDOW_SIZE and, thus, a shorter Bitmap, may be
sufficient to provide reception status on all tiles. If multiple window
sizes are supported, the RuleID signals what WINDOW_SIZE is in use for a
specific packet transmission.[¶](#section-appendix.e-1){.pilcrow}
:::
:::

::: {#AsymLinks}
::: {#section-appendix.f .section}
## [Appendix F.](#section-appendix.f){.section-number .selfRef} [ACK-Always and ACK-on-Error on Quasi-Bidirectional Links](#name-ack-always-and-ack-on-error){.section-name .selfRef} {#name-ack-always-and-ack-on-error}

The ACK-Always and ACK-on-Error modes of SCHC F/R are bidirectional
protocols: they require a feedback path from the reassembler to the
fragmenter.[¶](#section-appendix.f-1){.pilcrow}

Some LPWAN technologies provide quasi-bidirectional connectivity,
whereby a Downlink transmission from the Network Infrastructure can only
take place right after an Uplink transmission by the
Dev.[¶](#section-appendix.f-2){.pilcrow}

When using SCHC F/R to send fragmented SCHC Packets Downlink over these
quasi-bidirectional links, the following situation may arise: if an
Uplink SCHC ACK is lost, the SCHC ACK REQ message by the sender could be
stuck indefinitely in the Downlink queue at the Network Infrastructure,
waiting for a transmission
opportunity.[¶](#section-appendix.f-3){.pilcrow}

There are many ways by which this deadlock can be avoided. The Dev
application might be sending recurring Uplink messages such as
keep-alive, or the Dev application stack might be sending other
recurring Uplink messages as part of its operation. However, these are
out of the control of this generic SCHC
specification.[¶](#section-appendix.f-4){.pilcrow}

In order to cope with quasi-bidirectional links, a SCHC-over-foo
specification may want to amend the SCHC F/R specification to add a
timer-based retransmission of the SCHC ACK. Below is an example of the
suggested behavior for ACK-Always mode. Because it is an example,
\[[RFC2119](#RFC2119){.xref}\] language is deliberately not used
here.[¶](#section-appendix.f-5){.pilcrow}

For Downlink transmission of a fragmented SCHC Packet in ACK-Always
mode, the SCHC Fragment receiver may support timer-based SCHC ACK
retransmission. In this mechanism, the SCHC Fragment receiver
initializes and starts a timer (the UplinkACK Timer) after the
transmission of a SCHC ACK, except when the SCHC ACK is sent in response
to the last SCHC Fragment of a packet (All-1 fragment). In the latter
case, the SCHC Fragment receiver does not start a timer after
transmission of the SCHC ACK.[¶](#section-appendix.f-6){.pilcrow}

If, after transmission of a SCHC ACK that is not an All-1 fragment, and
before expiration of the corresponding UplinkACK timer, the SCHC
Fragment receiver receives a SCHC Fragment that belongs to the current
window (e.g., a missing SCHC Fragment from the current window) or to the
next window, the UplinkACK timer for the SCHC ACK is stopped. However,
if the UplinkACK timer expires, the SCHC ACK is resent and the UplinkACK
timer is reinitialized and
restarted.[¶](#section-appendix.f-7){.pilcrow}

The default initial value for the UplinkACK Timer, as well as the
maximum number of retries for a specific SCHC ACK, denoted
MAX_ACK_REQUESTS, is to be defined in a Profile. The initial value of
the UplinkACK timer is expected to be greater than that of the
Retransmission timer, in order to make sure that a (buffered) SCHC
Fragment to be retransmitted finds an opportunity for that transmission.
One exception to this recommendation is the special case of the All-1
SCHC Fragment transmission.[¶](#section-appendix.f-8){.pilcrow}

When the SCHC Fragment sender transmits the All-1 SCHC Fragment, it
starts its Retransmission Timer with a large timeout value (e.g.,
several times that of the initial UplinkACK Timer). If a SCHC ACK is
received before expiration of this timer, the SCHC Fragment sender
retransmits any lost SCHC Fragments as reported by the SCHC ACK, or if
the SCHC ACK confirms successful reception of all SCHC Fragments of the
last window, the transmission of the fragmented SCHC Packet is
considered complete. If the timer expires, and no SCHC ACK has been
received since the start of the timer, the SCHC Fragment sender assumes
that the All-1 SCHC Fragment has been successfully received (and
possibly, the last SCHC ACK has been lost: this mechanism assumes that
the Retransmission Timer for the All-1 SCHC Fragment is long enough to
allow several SCHC ACK retries if the All-1 SCHC Fragment has not been
received by the SCHC Fragment receiver, and it also assumes that it is
unlikely that several ACKs become all
lost).[¶](#section-appendix.f-9){.pilcrow}
:::
:::

::: {#acknowledgements}
::: {#section-appendix.g .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

Thanks to (in alphabetical order) [Sergio Aguilar
Romero]{.contact-name}, [David Black]{.contact-name}, [Carsten
Bormann]{.contact-name}, [Deborah Brungard]{.contact-name}, [Brian
Carpenter]{.contact-name}, [Philippe Clavier]{.contact-name}, [Alissa
Cooper]{.contact-name}, [Roman Danyliw]{.contact-name}, [Daniel Ducuara
Beltran]{.contact-name}, [Diego Dujovne]{.contact-name}, [Eduardo Ingles
Sanchez]{.contact-name}, [Rahul Jadhav]{.contact-name}, [Benjamin
Kaduk]{.contact-name}, [Arunprabhu Kandasamy]{.contact-name}, [Suresh
Krishnan]{.contact-name}, [Mirja Kuehlewind]{.contact-name}, [Barry
Leiba]{.contact-name}, [Sergio Lopez Bernal]{.contact-name}, [Antoni
Markovski]{.contact-name}, [Alexey Melnikov]{.contact-name}, [Georgios
Papadopoulos]{.contact-name}, [Alexander Pelov]{.contact-name}, [Charles
Perkins]{.contact-name}, [Edgar Ramos]{.contact-name}, [Alvaro
Retana]{.contact-name}, [Adam Roach]{.contact-name}, [Shoichi
Sakane]{.contact-name}, [Joseph Salowey]{.contact-name}, [Pascal
Thubert]{.contact-name}, and [Eric Vyncke]{.contact-name} for useful
design considerations, reviews and
comments.[¶](#section-appendix.g-1){.pilcrow}

[Carles Gomez]{.contact-name} has been funded in part by the Spanish
Government (Ministerio de Educacion, Cultura y Deporte) through the Jose
Castillejo grant CAS15/00336 and by the ERDF and the Spanish Government
through project TEC2016-79988-P. Part of his contribution to this work
has been carried out during his stay as a visiting scholar at the
Computer Laboratory of the University of
Cambridge.[¶](#section-appendix.g-2){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.h .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Ana Minaburo]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Acklio]{.org}
:::

::: {.left dir="auto"}
[1137A avenue des Champs Blancs]{.street-address}
:::

::: {.left dir="auto"}
[35510 Cesson-Sevigne Cedex]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <ana@ackl.io>
:::

::: {.left dir="auto"}
[Laurent Toutain]{.fn .nameRole}
:::

::: {.left dir="auto"}
[IMT Atlantique]{.org}
:::

::: {.left dir="auto"}
[2 rue de la Chataigneraie\
CS 17607]{.street-address}
:::

::: {.left dir="auto"}
[35576 Cesson-Sevigne Cedex]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <Laurent.Toutain@imt-atlantique.fr>
:::

::: {.left dir="auto"}
[Carles Gomez]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Universitat Politecnica de Catalunya]{.org}
:::

::: {.left dir="auto"}
[C/Esteve Terradas, 7\
08860 Castelldefels]{.street-address}
:::

::: {.left dir="auto"}
[Spain]{.country-name}
:::

::: email
Email: <carlesgo@entel.upc.edu>
:::

::: {.left dir="auto"}
[Dominique Barthel]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Orange Labs]{.org}
:::

::: {.left dir="auto"}
[28 chemin du Vieux Chene\
38243 Meylan]{.street-address}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <dominique.barthel@orange.com>
:::

::: {.left dir="auto"}
[Juan Carlos Zuniga]{.fn .nameRole}
:::

::: {.left dir="auto"}
[SIGFOX]{.org}
:::

::: {.left dir="auto"}
[425 rue Jean Rostand\
31670 Labege]{.street-address}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <JuanCarlos.Zuniga@sigfox.com>
:::
:::
:::
