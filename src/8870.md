  RFC 8870           EKT SRTP          January 2021
  ------------------ ----------------- --------------
  Jennings, et al.   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8870](https://www.rfc-editor.org/rfc/rfc8870){.eref}

Category:
:   Standards Track

Published:
:   January 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    C. Jennings
    :::

    ::: org
    Cisco Systems
    :::
    :::

    ::: author
    ::: author-name
    J. Mattsson
    :::

    ::: org
    Ericsson AB
    :::
    :::

    ::: author
    ::: author-name
    D. McGrew
    :::

    ::: org
    Cisco Systems
    :::
    :::

    ::: author
    ::: author-name
    D. Wing
    :::

    ::: org
    Citrix
    :::
    :::

    ::: author
    ::: author-name
    F. Andreasen
    :::

    ::: org
    Cisco Systems
    :::
    :::
:::

# RFC 8870 {#rfcnum}

# Encrypted Key Transport for DTLS and Secure RTP {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

Encrypted Key Transport (EKT) is an extension to DTLS (Datagram
Transport Layer Security) and the Secure Real-time Transport Protocol
(SRTP) that provides for the secure transport of SRTP master keys,
rollover counters, and other information within SRTP. This facility
enables SRTP for decentralized conferences by distributing a common key
to all of the conference endpoints.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8870>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Overview](#name-overview){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Conventions Used in This
    Document](#name-conventions-used-in-this-do){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Encrypted Key
    Transport](#name-encrypted-key-transport){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [EKTField
        Formats](#name-ektfield-formats){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [SPIs and EKT Parameter
        Sets](#name-spis-and-ekt-parameter-sets){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Packet Processing and State
        Machine](#name-packet-processing-and-state){.xref}[¶](#section-toc.1-1.4.2.3.1){.pilcrow}

        -   ::: {#section-toc.1-1.4.2.3.2.1}
            [4.3.1](#section-4.3.1){.xref}.  [Outbound
            Processing](#name-outbound-processing){.xref}[¶](#section-toc.1-1.4.2.3.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.2}
            [4.3.2](#section-4.3.2){.xref}.  [Inbound
            Processing](#name-inbound-processing){.xref}[¶](#section-toc.1-1.4.2.3.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Ciphers](#name-ciphers){.xref}[¶](#section-toc.1-1.4.2.4.1){.pilcrow}

        -   ::: {#section-toc.1-1.4.2.4.2.1}
            [4.4.1](#section-4.4.1){.xref}.  [AES Key
            Wrap](#name-aes-key-wrap){.xref}[¶](#section-toc.1-1.4.2.4.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.2}
            [4.4.2](#section-4.4.2){.xref}.  [Defining New EKT
            Ciphers](#name-defining-new-ekt-ciphers){.xref}[¶](#section-toc.1-1.4.2.4.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [Synchronizing
        Operation](#name-synchronizing-operation){.xref}[¶](#section-toc.1-1.4.2.5.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.6}
        [4.6](#section-4.6){.xref}.  [Timing and Reliability
        Considerations](#name-timing-and-reliability-cons){.xref}[¶](#section-toc.1-1.4.2.6.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Use of EKT with
    DTLS-SRTP](#name-use-of-ekt-with-dtls-srtp){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [DTLS-SRTP
        Recap](#name-dtls-srtp-recap){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [SRTP EKT Key Transport Extensions
        to
        DTLS-SRTP](#name-srtp-ekt-key-transport-exte){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.5.2.2.2.1}
            [5.2.1](#section-5.2.1){.xref}.  [Negotiating an
            EKTCipher](#name-negotiating-an-ektcipher){.xref}[¶](#section-toc.1-1.5.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.2}
            [5.2.2](#section-5.2.2){.xref}.  [Establishing an EKT
            Key](#name-establishing-an-ekt-key){.xref}[¶](#section-toc.1-1.5.2.2.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Offer/Answer
        Considerations](#name-offer-answer-considerations){.xref}[¶](#section-toc.1-1.5.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [Sending the DTLS EKTKey
        Reliably](#name-sending-the-dtls-ektkey-rel){.xref}[¶](#section-toc.1-1.5.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [EKT Message
        Types](#name-ekt-message-types){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [EKT
        Ciphers](#name-ekt-ciphers-2){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [TLS
        Extensions](#name-tls-extensions){.xref}[¶](#section-toc.1-1.7.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [TLS Handshake
        Type](#name-tls-handshake-type){.xref}[¶](#section-toc.1-1.7.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [References](#name-references){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.8.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.8.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [](#section-appendix.a){.xref}[Acknowledgments](#name-acknowledgments){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [](#section-appendix.b){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The Real-time Transport Protocol (RTP) is designed to allow
decentralized groups with minimal control to establish sessions, such as
for multimedia conferences. Unfortunately, Secure RTP (SRTP)
\[[RFC3711](#RFC3711){.xref}\] cannot be used in many minimal-control
scenarios, because it requires that synchronization source (SSRC) values
and other data be coordinated among all of the participants in a
session. For example, if a participant joins a session that is already
in progress, that participant needs to be informed of the SRTP keys
along with the SSRC, rollover counter (ROC), and other details of the
other SRTP sources.[¶](#section-1-1){.pilcrow}

The inability of SRTP to work in the absence of central control was well
understood during the design of the protocol; the omission was
considered less important than optimizations such as bandwidth
conservation. Additionally, in many situations, SRTP is used in
conjunction with a signaling system that can provide the central control
needed by SRTP. However, there are several cases in which conventional
signaling systems cannot easily provide all of the coordination
required.[¶](#section-1-2){.pilcrow}

This document defines Encrypted Key Transport (EKT) for SRTP and reduces
the amount of external signaling control that is needed in an SRTP
session with multiple receivers. EKT securely distributes the SRTP
master key and other information for each SRTP source. With this method,
SRTP entities are free to choose SSRC values as they see fit and to
start up new SRTP sources with new SRTP master keys within a session
without coordinating with other entities via external signaling or other
external means.[¶](#section-1-3){.pilcrow}

EKT extends DTLS and SRTP to enable a common key encryption key (called
an \"EKTKey\") to be distributed to all endpoints, so that each endpoint
can securely send its SRTP master key and current SRTP ROC to the other
participants in the session. This data furnishes the information needed
by the receiver to instantiate an SRTP receiver
context.[¶](#section-1-4){.pilcrow}

EKT can be used in conferences where the central Media Distributor or
conference bridge cannot decrypt the media, such as the type defined in
\[[RFC8871](#RFC8871){.xref}\]. It can also be used for large-scale
conferences where the conference bridge or Media Distributor can decrypt
all the media but wishes to encrypt the media it is sending just once
and then send the same encrypted media to a large number of
participants. This reduces encryption CPU time in general and is
necessary when sending multicast media.[¶](#section-1-5){.pilcrow}

EKT does not control the manner in which the SSRC is generated. It is
only concerned with distributing the security parameters that an
endpoint needs to associate with a given SSRC in order to decrypt SRTP
packets from that sender.[¶](#section-1-6){.pilcrow}

EKT is not intended to replace external key establishment mechanisms.
Instead, it is used in conjunction with those methods, and it relieves
those methods of the burden of delivering the context for each SRTP
source to every SRTP participant. This document defines how EKT works
with the DTLS-SRTP approach to key establishment, by using keys derived
from the DTLS-SRTP handshake to encipher the EKTKey in addition to the
SRTP media.[¶](#section-1-7){.pilcrow}
:::
:::

::: {#overview}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Overview](#name-overview){.section-name .selfRef} {#name-overview}

This specification defines a way for the server in a DTLS-SRTP
negotiation (see [Section 5](#dtls-srtp-kt){.xref}) to provide an EKTKey
to the client during the DTLS handshake. The EKTKey thus obtained can be
used to encrypt the SRTP master key that is used to encrypt the media
sent by the endpoint. This specification also defines a way to send the
encrypted SRTP master key (with the EKTKey) along with the SRTP packet
(see [Section 4](#srtp_ekt){.xref}). Endpoints that receive this packet
and know the EKTKey can use the EKTKey to decrypt the SRTP master key,
which can then be used to decrypt the SRTP
packet.[¶](#section-2-1){.pilcrow}

One way to use this specification is described in the architecture
defined by \[[RFC8871](#RFC8871){.xref}\]. Each participant in the
conference forms a DTLS-SRTP connection to a common Key Distributor that
distributes the same EKTKey to all the endpoints. Then, each endpoint
picks its own SRTP master key for the media it sends. When sending
media, the endpoint may also include the SRTP master key encrypted with
the EKTKey in the SRTP packet. This allows all the endpoints to decrypt
the media.[¶](#section-2-2){.pilcrow}
:::
:::

::: {#conventions-used-in-this-document}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Conventions Used in This Document](#name-conventions-used-in-this-do){.section-name .selfRef} {#name-conventions-used-in-this-do}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-3-1){.pilcrow}
:::
:::

::: {#srtp_ekt}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Encrypted Key Transport](#name-encrypted-key-transport){.section-name .selfRef} {#name-encrypted-key-transport}

EKT defines a new method of providing SRTP master keys to an endpoint.
In order to convey the ciphertext corresponding to the SRTP master key,
and other additional information, an additional field, called the
\"EKTField\", is added to the SRTP packets. The EKTField appears at the
end of the SRTP packet. It appears after the optional authentication
tag, if one is present; otherwise, the EKTField appears after the
ciphertext portion of the packet.[¶](#section-4-1){.pilcrow}

EKT [MUST NOT]{.bcp14} be used in conjunction with SRTP\'s MKI (Master
Key Identifier) or with SRTP\'s \<From, To>
\[[RFC3711](#RFC3711){.xref}\], as those SRTP features duplicate some of
the functions of EKT. Senders [MUST NOT]{.bcp14} include the MKI when
using EKT. Receivers [SHOULD]{.bcp14} simply ignore any MKI field
received if EKT is in use.[¶](#section-4-2){.pilcrow}

This document defines the use of EKT with SRTP. Its use with the Secure
Real-time Transport Control Protocol (SRTCP) would be similar, but that
topic is left for a future specification. SRTP is preferred for
transmitting keying material because (1) it shares fate with the
transmitted media, (2) SRTP rekeying can occur without concern for RTCP
transmission limits, and (3) it avoids the need for SRTCP compound
packets with RTP translators and mixers.[¶](#section-4-3){.pilcrow}

::: {#EKT}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [EKTField Formats](#name-ektfield-formats){.section-name .selfRef} {#name-ektfield-formats}

The EKTField uses the formats defined in
Figures [1](#tag-format-base){.xref} and
[2](#tag-format-abbreviated){.xref} for the FullEKTField and
ShortEKTField. The EKTField appended to an SRTP packet can be referred
to as an \"EKT Tag\".[¶](#section-4.1-1){.pilcrow}

[]{#name-fullektfield-format}

::: {#tag-format-base}
::: {#section-4.1-2.1 .artwork .art-text .alignCenter}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    :                                                               :
    :                        EKT Ciphertext                         :
    :                                                               :
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Security Parameter Index    |             Epoch             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |            Length             |0 0 0 0 0 0 1 0|
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 1](#figure-1){.selfRef}: [FullEKTField
Format](#name-fullektfield-format){.selfRef}
:::

[]{#name-shortektfield-format}

::: {#tag-format-abbreviated}
::: {#section-4.1-3.1 .artwork .art-text .alignCenter}
     0 1 2 3 4 5 6 7
    +-+-+-+-+-+-+-+-+
    |0 0 0 0 0 0 0 0|
    +-+-+-+-+-+-+-+-+
:::

[Figure 2](#figure-2){.selfRef}: [ShortEKTField
Format](#name-shortektfield-format){.selfRef}
:::

[Figure 3](#tag-formats){.xref} shows the syntax of the EKTField,
expressed in ABNF \[[RFC5234](#RFC5234){.xref}\]. The EKTField is added
to the end of an SRTP packet. The EKTPlaintext is the concatenation of
SRTPMasterKeyLength, SRTPMasterKey, SSRC, and ROC, in that order. The
EKTCiphertext is computed by encrypting the EKTPlaintext using the
EKTKey. Future extensions to the EKTField [MUST]{.bcp14} conform to the
syntax of the ExtensionEKTField.[¶](#section-4.1-4){.pilcrow}

[]{#name-ektfield-syntax}

::: {#tag-formats}
::: {#section-4.1-5.1}
``` {.sourcecode .lang-abnf}
BYTE = %x00-FF

EKTMsgTypeFull = %x02
EKTMsgTypeShort = %x00
EKTMsgTypeExtension = %x03-FF ; Message Type %x01 is not available
                              ; for assignment due to its usage by
                              ; legacy implementations.

EKTMsgLength = 2BYTE

SRTPMasterKeyLength = BYTE
SRTPMasterKey = 1*242BYTE
SSRC = 4BYTE ; SSRC from RTP
ROC = 4BYTE ; ROC from SRTP for the given SSRC

EKTPlaintext = SRTPMasterKeyLength SRTPMasterKey SSRC ROC

EKTCiphertext = 1*251BYTE ; EKTEncrypt(EKTKey, EKTPlaintext)
Epoch = 2BYTE
SPI = 2BYTE

FullEKTField = EKTCiphertext SPI Epoch EKTMsgLength EKTMsgTypeFull

ShortEKTField = EKTMsgTypeShort

ExtensionData = 1*1024BYTE
ExtensionEKTField = ExtensionData EKTMsgLength EKTMsgTypeExtension

EKTField = FullEKTField / ShortEKTField / ExtensionEKTField
```
:::

[Figure 3](#figure-3){.selfRef}: [EKTField
Syntax](#name-ektfield-syntax){.selfRef}
:::

These fields and data elements are defined as
follows:[¶](#section-4.1-6){.pilcrow}

[]{.break}

EKTPlaintext:
:   This is the data that is input to the EKT encryption operation. This
    data never appears on the wire; it is used only in computations
    internal to EKT. This is the concatenation of the SRTP master key
    and its length, the SSRC, and the
    ROC.[¶](#section-4.1-7.2){.pilcrow}
:   

EKTCiphertext:
:   This is the data that is output from the EKT encryption operation
    (see [Section 4.4](#cipher){.xref}). This field is included in SRTP
    packets when EKT is in use. The length of the EKTCiphertext can be
    larger than the length of the EKTPlaintext that was
    encrypted.[¶](#section-4.1-7.4){.pilcrow}
:   

SRTPMasterKey:
:   On the sender side, this is the SRTP master key associated with the
    indicated SSRC.[¶](#section-4.1-7.6){.pilcrow}
:   

SRTPMasterKeyLength:
:   This is the length of the SRTPMasterKey in bytes. This depends on
    the cipher suite negotiated for SRTP using Session Description
    Protocol (SDP) Offer/Answer
    \[[RFC3264](#RFC3264){.xref}\].[¶](#section-4.1-7.8){.pilcrow}
:   

SSRC:
:   On the sender side, this is the SSRC for this SRTP source. The
    length of this field is 32 bits. The SSRC value in the EKT Tag
    [MUST]{.bcp14} be the same as the one in the header of the SRTP
    packet to which the tag is appended.[¶](#section-4.1-7.10){.pilcrow}
:   

Rollover Counter (ROC):
:   On the sender side, this is set to the current value of the SRTP ROC
    in the SRTP context associated with the SSRC in the SRTP packet. The
    length of this field is 32 bits.[¶](#section-4.1-7.12){.pilcrow}
:   

Security Parameter Index (SPI):

:   This field indicates the appropriate EKTKey and other parameters for
    the receiver to use when processing the packet, within a given
    conference. The length of this field is 16 bits, representing a
    two-byte integer in network byte order. The parameters identified by
    this field are as follows:[¶](#section-4.1-7.14.1){.pilcrow}

    -   [The EKT Cipher used to process the
        packet.[¶](#section-4.1-7.14.2.1){.pilcrow}]{#section-4.1-7.14.2.1}
    -   [The EKTKey used to process the
        packet.[¶](#section-4.1-7.14.2.2){.pilcrow}]{#section-4.1-7.14.2.2}
    -   [The SRTP master salt associated with any master key encrypted
        with this EKT Key.  The master salt is communicated separately,
        via signaling, typically along with the EKTKey. (Recall that the
        SRTP master salt is used in the formation of Initialization
        Vectors (IVs) /
        nonces.)[¶](#section-4.1-7.14.2.3){.pilcrow}]{#section-4.1-7.14.2.3}

:   

Epoch:
:   This field indicates how many SRTP keys have been sent for this SSRC
    under the current EKTKey, prior to the current key, as a two‑byte
    integer in network byte order. It starts at zero at the beginning of
    a session and resets to zero whenever the EKTKey is changed (i.e.,
    when a new SPI appears). The epoch for an SSRC increments by one
    every time the sender transmits a new key. The recipient of a
    FullEKTField [MUST]{.bcp14} reject any future FullEKTField for this
    SPI and SSRC that has an epoch value equal to or lower than an epoch
    already seen.[¶](#section-4.1-7.16){.pilcrow}
:   

Together, these data elements are called an \"EKT parameter set\". To
avoid ambiguity, each distinct EKT parameter set that is used
[MUST]{.bcp14} be associated with a distinct SPI
value.[¶](#section-4.1-8){.pilcrow}

[]{.break}

EKTMsgLength:
:   All EKT Message Types other than the ShortEKTField include a length
    in octets (in network byte order) of either the FullEKTField or the
    ExtensionEKTField, including this length field and the EKT Message
    Type (as defined in the next
    paragraph).[¶](#section-4.1-9.2){.pilcrow}
:   

Message Type:
:   The last byte is used to indicate the type of the EKTField. This
    [MUST]{.bcp14} be 2 for the FullEKTField format and 0 for the
    ShortEKTField format. If a received EKT Tag has an unknown Message
    Type, then the receiver [MUST]{.bcp14} discard the whole EKT
    Tag.[¶](#section-4.1-9.4){.pilcrow}
:   
:::
:::

::: {#spis-and-ekt-parameter-sets}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [SPIs and EKT Parameter Sets](#name-spis-and-ekt-parameter-sets){.section-name .selfRef} {#name-spis-and-ekt-parameter-sets}

The SPI identifies the parameters for how the EKT Tag should be
processed:[¶](#section-4.2-1){.pilcrow}

-   [The EKTKey and EKT Cipher used to process the
    packet.[¶](#section-4.2-2.1){.pilcrow}]{#section-4.2-2.1}
-   [The SRTP master salt associated with any master key encrypted with
    this EKT Key.  The master salt is communicated separately, via
    signaling, typically along with the
    EKTKey.[¶](#section-4.2-2.2){.pilcrow}]{#section-4.2-2.2}

Together, these data elements are called an \"EKT parameter set\". To
avoid ambiguity, each distinct EKT parameter set that is used
[MUST]{.bcp14} be associated with a distinct SPI value. The association
of a given parameter set with a given SPI value is configured by some
other protocol, e.g., the DTLS-SRTP extension defined in [Section
5](#dtls-srtp-kt){.xref}.[¶](#section-4.2-3){.pilcrow}
:::
:::

::: {#pkt_proc}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Packet Processing and State Machine](#name-packet-processing-and-state){.section-name .selfRef} {#name-packet-processing-and-state}

At any given time, the SSRC for each SRTP source has associated with it
a single EKT parameter set. This parameter set is used to process all
outbound packets and is called the \"outbound parameter set\" for that
SSRC. There may be other EKT parameter sets that are used by other SRTP
sources in the same session, including other SRTP sources on the same
endpoint (e.g., one endpoint with voice and video might have two EKT
parameter sets, or there might be multiple video sources on an endpoint,
each with their own EKT parameter set). All of the received EKT
parameter sets [SHOULD]{.bcp14} be stored by all of the participants in
an SRTP session, for use in processing inbound SRTP traffic. If a
participant deletes an EKT parameter set (e.g., because of space
limitations), then it will be unable to process Full EKT Tags containing
updated media keys and thus will be unable to receive media from a
participant that has changed its media key.[¶](#section-4.3-1){.pilcrow}

Either the FullEKTField or ShortEKTField is appended at the tail end of
all SRTP packets. The decision regarding which parameter to send and
when is specified in [Section
4.6](#timing){.xref}.[¶](#section-4.3-2){.pilcrow}

::: {#outbound-processing}
::: {#section-4.3.1 .section}
#### [4.3.1.](#section-4.3.1){.section-number .selfRef} [Outbound Processing](#name-outbound-processing){.section-name .selfRef} {#name-outbound-processing}

See [Section 4.6](#timing){.xref}, which describes when to send an SRTP
packet with a FullEKTField. If a FullEKTField is not being sent, then a
ShortEKTField is sent so the receiver can correctly determine how to
process the packet.[¶](#section-4.3.1-1){.pilcrow}

When an SRTP packet is sent with a FullEKTField, the EKTField for that
packet is created per either the steps below or an equivalent set of
steps.[¶](#section-4.3.1-2){.pilcrow}

1.  [The Security Parameter Index (SPI) field is set to the value of the
    SPI that is associated with the outbound parameter
    set.[¶](#section-4.3.1-3.1){.pilcrow}]{#section-4.3.1-3.1}

2.  [The EKTPlaintext field is computed from the SRTP master key, SSRC,
    and ROC fields, as shown in [Section 4.1](#EKT){.xref}. The ROC,
    SRTP master key, and SSRC used in EKT processing [MUST]{.bcp14} be
    the same as the one used in SRTP
    processing.[¶](#section-4.3.1-3.2){.pilcrow}]{#section-4.3.1-3.2}

3.  [The EKTCiphertext field is set to the ciphertext created by
    encrypting the EKTPlaintext with the EKTCipher using the EKTKey as
    the encryption key. The encryption process is detailed in [Section
    4.4](#cipher){.xref}.[¶](#section-4.3.1-3.3){.pilcrow}]{#section-4.3.1-3.3}

4.  ::: {#section-4.3.1-3.4}
    Then, the FullEKTField is formed using the EKTCiphertext and the SPI
    associated with the EKTKey used above. Also appended are the length
    and Message Type using the FullEKTField
    format.[¶](#section-4.3.1-3.4.1){.pilcrow}
    :::

Note: The value of the EKTCiphertext field is identical in successive
packets protected by the same EKTKey and SRTP master key. This value
[MAY]{.bcp14} be cached by an SRTP sender to minimize computational
effort.[¶](#section-4.3.1-4.1){.pilcrow}

The computed value of the FullEKTField is appended to the end of the
SRTP packet, after the encrypted payload.[¶](#section-4.3.1-5){.pilcrow}

When a packet is sent with the ShortEKTField, the ShortEKTField is
simply appended to the packet.[¶](#section-4.3.1-6){.pilcrow}

Outbound packets [SHOULD]{.bcp14} continue to use the old SRTP master
key for 250 ms after sending any new key in a FullEKTField value. This
gives all the receivers in the system time to get the new key before
they start receiving media encrypted with the new key. (The specific
value of 250 ms is chosen to represent a reasonable upper bound on the
amount of latency and jitter that is tolerable in a real-time
context.)[¶](#section-4.3.1-7){.pilcrow}
:::
:::

::: {#inbound-processing}
::: {#section-4.3.2 .section}
#### [4.3.2.](#section-4.3.2){.section-number .selfRef} [Inbound Processing](#name-inbound-processing){.section-name .selfRef} {#name-inbound-processing}

When receiving a packet on an RTP stream, the following steps are
applied for each received SRTP packet.[¶](#section-4.3.2-1){.pilcrow}

1.  [The final byte is checked to determine which EKT format is in use.
    When an SRTP packet contains a ShortEKTField, the ShortEKTField is
    removed from the packet and then normal SRTP processing occurs. If
    the packet contains a FullEKTField, then processing continues as
    described below. The reason for using the last byte of the packet to
    indicate the type is that the length of the SRTP part is not known
    until the decryption has occurred. At this point in the processing,
    there is no easy way to know where the EKTField would start.
    However, the whole SRTP packet has been received, so instead of
    starting at the front of the packet, the parsing works backwards at
    the end of the packet, and thus the type is placed at the very end
    of the packet.[¶](#section-4.3.2-2.1){.pilcrow}]{#section-4.3.2-2.1}

2.  [The Security Parameter Index (SPI) field is used to find the right
    EKT parameter set to be used for processing the packet. If there is
    no matching SPI, then the verification function [MUST]{.bcp14}
    return an indication of authentication failure, and the steps
    described below are not performed. The EKT parameter set contains
    the EKTKey, the EKTCipher, and the SRTP master
    salt.[¶](#section-4.3.2-2.2){.pilcrow}]{#section-4.3.2-2.2}

3.  [The EKTCiphertext is authenticated and decrypted, as described in
    [Section 4.4](#cipher){.xref}, using the EKTKey and EKTCipher found
    in the previous step. If the EKT decryption operation returns an
    authentication failure, then EKT processing [MUST]{.bcp14} be
    aborted. The receiver [SHOULD]{.bcp14} discard the whole SRTP
    packet.[¶](#section-4.3.2-2.3){.pilcrow}]{#section-4.3.2-2.3}

4.  [The resulting EKTPlaintext is parsed as described in [Section
    4.1](#EKT){.xref}, to recover the SRTP master key, SSRC, and ROC
    fields. The SRTP master salt that is associated with the EKTKey is
    also retrieved. If the value of the srtp_master_salt (see [Section
    5.2.2](#ekt_key){.xref}) sent as part of the EKTKey is longer than
    needed by SRTP, then it is truncated by taking the first N bytes
    from the srtp_master_salt
    field.[¶](#section-4.3.2-2.4){.pilcrow}]{#section-4.3.2-2.4}

5.  [If the SSRC in the EKTPlaintext does not match the SSRC of the SRTP
    packet received, then this FullEKTField [MUST]{.bcp14} be discarded
    and the subsequent steps in this list skipped. After stripping the
    FullEKTField, the remainder of the SRTP packet [MAY]{.bcp14} be
    processed as
    normal.[¶](#section-4.3.2-2.5){.pilcrow}]{#section-4.3.2-2.5}

6.  ::: {#section-4.3.2-2.6}
    The SRTP master key, ROC, and SRTP master salt from the previous
    steps are saved in a map indexed by the SSRC found in the
    EKTPlaintext and can be used for any future crypto operations on the
    inbound packets with that SSRC.[¶](#section-4.3.2-2.6.1){.pilcrow}

    -   [Unless the transform specifies other acceptable key lengths,
        the length of the SRTP master key [MUST]{.bcp14} be the same as
        the master key length for the SRTP transform in use. If this is
        not the case, then the receiver [MUST]{.bcp14} abort EKT
        processing and [SHOULD]{.bcp14} discard the whole SRTP
        packet.[¶](#section-4.3.2-2.6.2.1){.pilcrow}]{#section-4.3.2-2.6.2.1}
    -   [If the length of the SRTP master key is less than the master
        key length for the SRTP transform in use and the transform
        specifies that this length is acceptable, then the SRTP master
        key value is used to replace the first bytes in the existing
        master key. The other bytes remain the same as in the old key.
        For example, the double GCM transform
        \[[RFC8723](#RFC8723){.xref}\] allows replacement of the first
        (\"end-to-end\") half of the master
        key.[¶](#section-4.3.2-2.6.2.2){.pilcrow}]{#section-4.3.2-2.6.2.2}
    :::

7.  [At this point, EKT processing has successfully completed, and the
    normal SRTP processing takes
    place.[¶](#section-4.3.2-2.7){.pilcrow}]{#section-4.3.2-2.7}

The value of the EKTCiphertext field is identical in successive packets
protected by the same EKT parameter set, SRTP master key, and ROC. SRTP
senders and receivers [MAY]{.bcp14} cache an EKTCiphertext value to
optimize processing in cases where the master key hasn\'t changed.
Instead of encrypting and decrypting, senders can simply copy the
precomputed value and receivers can compare a received EKTCiphertext to
the known value.[¶](#section-4.3.2-3){.pilcrow}

[Section 4.3.1](#outbound-processing){.xref} recommends that SRTP
senders continue using an old key for some time after sending a new key
in an EKT Tag. Receivers that wish to avoid packet loss due to
decryption failures [MAY]{.bcp14} perform trial decryption with both the
old key and the new key, keeping the result of whichever decryption
succeeds. Note that this approach is only compatible with SRTP
transforms that include integrity
protection.[¶](#section-4.3.2-4){.pilcrow}

When receiving a new EKTKey, implementations need to use the ekt_ttl
field (see [Section 5.2.2](#ekt_key){.xref}) to create a time after
which this key cannot be used, and they also need to create a counter
that keeps track of how many times the key has been used to encrypt
data, to ensure that it does not exceed the T value for that cipher (see
[Section 4.4](#cipher){.xref}). If either of these limits is exceeded,
the key can no longer be used for encryption. At this point,
implementations need to either use call signaling to renegotiate a new
session or terminate the existing session. Terminating the session is a
reasonable implementation choice because these limits should not be
exceeded, except under an attack or error
condition.[¶](#section-4.3.2-5){.pilcrow}
:::
:::
:::
:::

::: {#cipher}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Ciphers](#name-ciphers){.section-name .selfRef} {#name-ciphers}

EKT uses an authenticated cipher to encrypt and authenticate the
EKTPlaintext. This specification defines the interface to the cipher, in
order to abstract the interface away from the details of that function.
This specification also defines the default cipher that is used in EKT.
The default cipher described in [Section 4.4.1](#DefaultCipher){.xref}
[MUST]{.bcp14} be implemented, but another cipher that conforms to this
interface [MAY]{.bcp14} be used. The cipher used for a given
EKTCiphertext value is negotiated using the supported_ekt_ciphers
extension (see [Section 5.2](#dtls-srtp-extensions){.xref}) and
indicated with the SPI value in the
FullEKTField.[¶](#section-4.4-1){.pilcrow}

An EKTCipher consists of an encryption function and a decryption
function. The encryption function E(K, P) takes the following
inputs:[¶](#section-4.4-2){.pilcrow}

-   [a secret key K with a length of L bytes,
    and[¶](#section-4.4-3.1){.pilcrow}]{#section-4.4-3.1}
-   [a plaintext value P with a length of M
    bytes.[¶](#section-4.4-3.2){.pilcrow}]{#section-4.4-3.2}

The encryption function returns a ciphertext value C whose length is N
bytes, where N may be larger than M. The decryption function D(K, C)
takes the following inputs:[¶](#section-4.4-4){.pilcrow}

-   [a secret key K with a length of L bytes,
    and[¶](#section-4.4-5.1){.pilcrow}]{#section-4.4-5.1}
-   [a ciphertext value C with a length of N
    bytes.[¶](#section-4.4-5.2){.pilcrow}]{#section-4.4-5.2}

The decryption function returns a plaintext value P that is M bytes
long, or it returns an indication that the decryption operation failed
because the ciphertext was invalid (i.e., it was not generated by the
encryption of plaintext with the key K).[¶](#section-4.4-6){.pilcrow}

These functions have the property that D(K, E(K, P)) = P for all values
of K and P. Each cipher also has a limit T on the number of times that
it can be used with any fixed key value. The EKTKey [MUST NOT]{.bcp14}
be used for encryption more than T times. Note that if the same
FullEKTField is retransmitted three times, that only counts as one
encryption.[¶](#section-4.4-7){.pilcrow}

Security requirements for EKT Ciphers are discussed in [Section
6](#sec){.xref}.[¶](#section-4.4-8){.pilcrow}

::: {#DefaultCipher}
::: {#section-4.4.1 .section}
#### [4.4.1.](#section-4.4.1){.section-number .selfRef} [AES Key Wrap](#name-aes-key-wrap){.section-name .selfRef} {#name-aes-key-wrap}

The default EKT Cipher is the Advanced Encryption Standard (AES) Key
Wrap with Padding algorithm \[[RFC5649](#RFC5649){.xref}\]. It requires
a plaintext length M that is at least one octet, and it returns a
ciphertext with a length of N = M + (M mod 8) + 8 octets. It can be used
with key sizes of L = 16 octets or L = 32 octets, and its use with those
key sizes is indicated as AESKW128 or AESKW256, respectively. The key
size determines the length of the AES key used by the Key Wrap
algorithm. With this cipher, T=2^48^.[¶](#section-4.4.1-1){.pilcrow}

[]{#name-ekt-ciphers}

::: {#CipherTable}
  Cipher     L    T
  ---------- ---- -------
  AESKW128   16   2^48^
  AESKW256   32   2^48^

  : [Table 1](#table-1){.selfRef}: [EKT
  Ciphers](#name-ekt-ciphers){.selfRef}
:::

As AES-128 is the mandatory-to-implement transform in SRTP, AESKW128
[MUST]{.bcp14} be implemented for EKT. AESKW256 [MAY]{.bcp14} be
implemented.[¶](#section-4.4.1-3){.pilcrow}
:::
:::

::: {#defining-new-ekt-ciphers}
::: {#section-4.4.2 .section}
#### [4.4.2.](#section-4.4.2){.section-number .selfRef} [Defining New EKT Ciphers](#name-defining-new-ekt-ciphers){.section-name .selfRef} {#name-defining-new-ekt-ciphers}

Other specifications may extend this document by defining other
EKTCiphers, as described in [Section 7](#iana){.xref}. This section
defines how those ciphers interact with this
specification.[¶](#section-4.4.2-1){.pilcrow}

An EKTCipher determines how the EKTCiphertext field is written and how
it is processed when it is read. This field is opaque to the other
aspects of EKT processing. EKT Ciphers are free to use this field in any
way, but they [SHOULD NOT]{.bcp14} use other EKT or SRTP fields as an
input. The values of the parameters L and T [MUST]{.bcp14} be defined by
each EKTCipher. The cipher [MUST]{.bcp14} provide integrity
protection.[¶](#section-4.4.2-2){.pilcrow}
:::
:::
:::
:::

::: {#SynchronizingOperation}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [Synchronizing Operation](#name-synchronizing-operation){.section-name .selfRef} {#name-synchronizing-operation}

If a source has its EKTKey changed by key management, it [MUST]{.bcp14}
also change its SRTP master key, which will cause it to send out a new
FullEKTField and eventually begin encrypting with it, as described in
[Section 4.3.1](#outbound-processing){.xref}. This ensures that if key
management thought the EKTKey needs changing (due to a participant
leaving or joining) and communicated that to a source, the source will
also change its SRTP master key, so that traffic can be decrypted only
by those who know the current EKTKey.[¶](#section-4.5-1){.pilcrow}
:::
:::

::: {#timing}
::: {#section-4.6 .section}
### [4.6.](#section-4.6){.section-number .selfRef} [Timing and Reliability Considerations](#name-timing-and-reliability-cons){.section-name .selfRef} {#name-timing-and-reliability-cons}

A system using EKT learns the SRTP master keys distributed with the
FullEKTField sent with SRTP, rather than with call signaling. A receiver
can immediately decrypt an SRTP packet, provided the SRTP packet
contains a FullEKTField.[¶](#section-4.6-1){.pilcrow}

This section describes how to reliably and expediently deliver new SRTP
master keys to receivers.[¶](#section-4.6-2){.pilcrow}

There are three cases to consider. In the first case, a new sender joins
a session and needs to communicate its SRTP master key to all the
receivers. In the second case, a sender changes its SRTP master key,
which needs to be communicated to all the receivers. In the third case,
a new receiver joins a session already in progress and needs to know the
sender\'s SRTP master key.[¶](#section-4.6-3){.pilcrow}

The three cases are as follows:[¶](#section-4.6-4){.pilcrow}

[]{.break}

New sender:
:   A new sender [SHOULD]{.bcp14} send a packet containing the
    FullEKTField as soon as possible, ideally in its initial SRTP
    packet. To accommodate packet loss, it is [RECOMMENDED]{.bcp14} that
    the FullEKTField be transmitted in three consecutive packets. If the
    sender does not send a FullEKTField in its initial packets and
    receivers have not otherwise been provisioned with a decryption key,
    then decryption will fail and SRTP packets will be dropped until the
    receiver receives a FullEKTField from the
    sender.[¶](#section-4.6-5.2){.pilcrow}
:   

Rekey:
:   By sending an EKT Tag over SRTP, the rekeying event shares fate with
    the SRTP packets protected with that new SRTP master key. To
    accommodate packet loss, it is [RECOMMENDED]{.bcp14} that three
    consecutive packets containing the FullEKTField be
    transmitted.[¶](#section-4.6-5.4){.pilcrow}
:   

New receiver:
:   When a new receiver joins a session, it does not need to communicate
    its sending SRTP master key (because it is a receiver). Also, when a
    new receiver joins a session, the sender is generally unaware of the
    receiver joining the session; thus, senders [SHOULD]{.bcp14}
    periodically transmit the FullEKTField. That interval depends on how
    frequently new receivers join the session, the acceptable delay
    before those receivers can start processing SRTP packets, and the
    acceptable overhead of sending the FullEKTField. If sending audio
    and video, the [RECOMMENDED]{.bcp14} frequency is the same as the
    rate of intra-coded video frames. If only sending audio, the
    [RECOMMENDED]{.bcp14} frequency is every
    100 ms.[¶](#section-4.6-5.6){.pilcrow}
:   

If none of the above three cases apply, a ShortEKTField [SHOULD]{.bcp14}
be sent.[¶](#section-4.6-6){.pilcrow}

In general, sending FullEKTField tags less frequently will consume less
bandwidth but will increase the time it takes for a join or rekey to
take effect. Applications should schedule the sending of FullEKTField
tags in a way that makes sense for their bandwidth and latency
requirements.[¶](#section-4.6-7){.pilcrow}
:::
:::
:::
:::

::: {#dtls-srtp-kt}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Use of EKT with DTLS-SRTP](#name-use-of-ekt-with-dtls-srtp){.section-name .selfRef} {#name-use-of-ekt-with-dtls-srtp}

This document defines an extension to DTLS-SRTP called \"SRTP EKTKey
Transport\", which enables secure transport of EKT keying material from
the DTLS-SRTP peer in the server role to the client. This allows such a
peer to process EKT keying material in SRTP and retrieve the embedded
SRTP keying material. This combination of protocols is valuable because
it combines the advantages of DTLS, which has strong authentication of
the endpoint and flexibility, along with allowing secure multi-party RTP
with loose coordination and efficient communication of per-source
keys.[¶](#section-5-1){.pilcrow}

In cases where the DTLS termination point is more trusted than the media
relay, the protection that DTLS affords to EKT keying material can allow
EKT Keys to be tunneled through an untrusted relay such as a centralized
conference bridge. For more details, see
\[[RFC8871](#RFC8871){.xref}\].[¶](#section-5-2){.pilcrow}

::: {#dtlssrtp-recap}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [DTLS-SRTP Recap](#name-dtls-srtp-recap){.section-name .selfRef} {#name-dtls-srtp-recap}

DTLS-SRTP \[[RFC5764](#RFC5764){.xref}\] uses an extended DTLS exchange
between two peers to exchange keying material, algorithms, and
parameters for SRTP. The SRTP flow operates over the same transport as
the DTLS-SRTP exchange (i.e., the same 5-tuple). DTLS-SRTP combines the
performance and encryption flexibility benefits of SRTP with the
flexibility and convenience of DTLS-integrated key and association
management. DTLS-SRTP can be viewed in two equivalent ways: as a new key
management method for SRTP and as a new RTP-specific data format for
DTLS.[¶](#section-5.1-1){.pilcrow}
:::
:::

::: {#dtls-srtp-extensions}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [SRTP EKT Key Transport Extensions to DTLS-SRTP](#name-srtp-ekt-key-transport-exte){.section-name .selfRef} {#name-srtp-ekt-key-transport-exte}

This document defines a new TLS negotiated extension called
\"supported_ekt_ciphers\" and a new TLS handshake message type called
\"ekt_key\". The extension negotiates the cipher to be used in
encrypting and decrypting EKTCiphertext values, and the handshake
message carries the corresponding key.[¶](#section-5.2-1){.pilcrow}

[Figure 4](#dtls-srtp-flow){.xref} shows a message flow between a DTLS
1.3 client and server using EKT configured using the DTLS extensions
described in this section. (The initial cookie exchange and other normal
DTLS messages are omitted.) To be clear, EKT can be used with versions
of DTLS prior to 1.3. The only difference is that in pre-1.3 TLS, stacks
will not have built-in support for generating and processing ACK
messages.[¶](#section-5.2-2){.pilcrow}

[]{#name-dtls-13-message-flow}

::: {#dtls-srtp-flow}
::: {#section-5.2-3.1 .artwork .art-text .alignCenter}
    Client                                             Server

    ClientHello
     + use_srtp
     + supported_ekt_ciphers
                            -------->

                                                   ServerHello
                                         {EncryptedExtensions}
                                                    + use_srtp
                                       + supported_ekt_ciphers
                                                {... Finished}
                            <--------

    {... Finished}          -------->

                                                         [ACK]
                            <--------                 [EKTKey]

    [ACK]                   -------->

    |SRTP packets|          <------->           |SRTP packets|
    + <EKT Tags>                                  + <EKT Tags>


    {} Messages protected using DTLS handshake keys

    [] Messages protected using DTLS application traffic keys

    <> Messages protected using the EKTKey and EKT Cipher

    || Messages protected using the SRTP master key sent in
       a Full EKT Tag
:::

[Figure 4](#figure-4){.selfRef}: [DTLS 1.3 Message
Flow](#name-dtls-13-message-flow){.selfRef}
:::

In the context of a multi-party SRTP session in which each endpoint
performs a DTLS handshake as a client with a central DTLS server, the
extensions defined in this document allow the DTLS server to set a
common EKTKey for all participants. Each endpoint can then use EKT Tags
encrypted with that common key to inform other endpoints of the keys it
uses to protect SRTP packets. This avoids the need for many individual
DTLS handshakes among the endpoints, at the cost of preventing endpoints
from directly authenticating one another.[¶](#section-5.2-4){.pilcrow}

::: {#section-5.2-5 .artwork .art-text .alignCenter}
    Client A                 Server                 Client B

        <----DTLS Handshake---->
        <--------EKTKey---------
                                <----DTLS Handshake---->
                                ---------EKTKey-------->

        -------------SRTP Packet + EKT Tag------------->
        <------------SRTP Packet + EKT Tag--------------

[¶](#section-5.2-5){.pilcrow}
:::

::: {#negotiating-an-ektcipher}
::: {#section-5.2.1 .section}
#### [5.2.1.](#section-5.2.1){.section-number .selfRef} [Negotiating an EKTCipher](#name-negotiating-an-ektcipher){.section-name .selfRef} {#name-negotiating-an-ektcipher}

To indicate its support for EKT, a DTLS-SRTP client includes in its
ClientHello an extension of type supported_ekt_ciphers listing the
ciphers used for EKT by the client, in preference order, with the most
preferred version first. If the server agrees to use EKT, then it
includes a supported_ekt_ciphers extension in its EncryptedExtensions
(or ServerHello for DTLS 1.2) containing a cipher selected from among
those advertised by the client.[¶](#section-5.2.1-1){.pilcrow}

The extension_data field of this extension contains an \"EKTCipher\"
value, encoded using the syntax defined in
\[[RFC8446](#RFC8446){.xref}\]:[¶](#section-5.2.1-2){.pilcrow}

::: {#section-5.2.1-3}
``` {.sourcecode .lang-tls-presentation}
        enum {
          reserved(0),
          aeskw_128(1),
          aeskw_256(2),
        } EKTCipherType;

        struct {
            select (Handshake.msg_type) {
                case client_hello:
                    EKTCipherType supported_ciphers<1..255>;

                case server_hello:
                    EKTCipherType selected_cipher;

                case encrypted_extensions:
                    EKTCipherType selected_cipher;

            };
        } EKTCipher;
```

[¶](#section-5.2.1-3){.pilcrow}
:::
:::
:::

::: {#ekt_key}
::: {#section-5.2.2 .section}
#### [5.2.2.](#section-5.2.2){.section-number .selfRef} [Establishing an EKT Key](#name-establishing-an-ekt-key){.section-name .selfRef} {#name-establishing-an-ekt-key}

Once a client and server have concluded a handshake that negotiated an
EKTCipher, the server [MUST]{.bcp14} provide to the client a key to be
used when encrypting and decrypting EKTCiphertext values. EKTKeys are
sent in encrypted handshake records, using handshake type ekt_key(26).
The body of the handshake message contains an EKTKey structure as
follows:[¶](#section-5.2.2-1){.pilcrow}

::: {#section-5.2.2-2 .artwork .art-text .alignCenter}
    struct {
      opaque ekt_key_value<1..256>;
      opaque srtp_master_salt<1..256>;
      uint16 ekt_spi;
      uint24 ekt_ttl;
    } EKTKey;

[¶](#section-5.2.2-2){.pilcrow}
:::

The contents of the fields in this message are as
follows:[¶](#section-5.2.2-3){.pilcrow}

[]{.break}

ekt_key_value
:   The EKTKey that the recipient should use when generating
    EKTCiphertext values[¶](#section-5.2.2-4.2){.pilcrow}
:   

srtp_master_salt
:   The SRTP master salt to be used with any master key encrypted with
    this EKT Key[¶](#section-5.2.2-4.4){.pilcrow}
:   

ekt_spi
:   The SPI value to be used to reference this EKTKey and SRTP master
    salt in EKT Tags (along with the EKT Cipher negotiated in the
    handshake)[¶](#section-5.2.2-4.6){.pilcrow}
:   

ekt_ttl
:   The maximum amount of time, in seconds, that this EKTKey can be
    used. The ekt_key_value in this message [MUST NOT]{.bcp14} be used
    for encrypting or decrypting information after the TTL
    expires.[¶](#section-5.2.2-4.8){.pilcrow}
:   

If the server did not provide a supported_ekt_ciphers extension in its
EncryptedExtensions (or ServerHello for DTLS 1.2), then EKTKey messages
[MUST NOT]{.bcp14} be sent by the client or the
server.[¶](#section-5.2.2-5){.pilcrow}

When an EKTKey is received and processed successfully, the recipient
[MUST]{.bcp14} respond with an ACK message as described in [Section
7](https://tools.ietf.org/html/draft-ietf-tls-dtls13-39#section-7){.relref}
of \[[TLS-DTLS13](#I-D.ietf-tls-dtls13){.xref}\]. The EKTKey message and
ACK [MUST]{.bcp14} be retransmitted following the rules of the
negotiated version of DTLS.[¶](#section-5.2.2-6){.pilcrow}

EKT [MAY]{.bcp14} be used with versions of DTLS prior to 1.3. In such
cases, to provide reliability, the ACK message is still used. Thus, DTLS
implementations supporting EKT with pre-1.3 versions of DTLS will need
to have explicit affordances for sending the ACK message in response to
an EKTKey message and for verifying that an ACK message was received.
The retransmission rules for both sides are otherwise defined by the
negotiated version of DTLS.[¶](#section-5.2.2-7){.pilcrow}

If an EKTKey message is received that cannot be processed, then the
recipient [MUST]{.bcp14} respond with an appropriate DTLS
alert.[¶](#section-5.2.2-8){.pilcrow}
:::
:::
:::
:::

::: {#offeranswer-considerations}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Offer/Answer Considerations](#name-offer-answer-considerations){.section-name .selfRef} {#name-offer-answer-considerations}

When using EKT with DTLS-SRTP, the negotiation to use EKT is done at the
DTLS handshake level and does not change the SDP Offer⁠/Answer messaging
\[[RFC3264](#RFC3264){.xref}\].[¶](#section-5.3-1){.pilcrow}
:::
:::

::: {#sending-the-dtls-ektkey-reliably}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [Sending the DTLS EKTKey Reliably](#name-sending-the-dtls-ektkey-rel){.section-name .selfRef} {#name-sending-the-dtls-ektkey-rel}

The DTLS EKTKey message is sent using the retransmissions specified in
[Section
4.2.4](https://www.rfc-editor.org/rfc/rfc6347#section-4.2.4){.relref} of
DTLS \[[RFC6347](#RFC6347){.xref}\]. Retransmission is finished with an
ACK message, or an alert is received.[¶](#section-5.4-1){.pilcrow}
:::
:::
:::
:::

::: {#sec}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

EKT inherits the security properties of the key management protocol that
is used to establish the EKTKey, e.g., the DTLS-SRTP extension defined
in this document.[¶](#section-6-1){.pilcrow}

With EKT, each SRTP sender and receiver [MUST]{.bcp14} generate distinct
SRTP master keys. This property avoids any security concerns over the
reuse of keys, by empowering the SRTP layer to create keys on demand.
Note that the inputs of EKT are the same as for SRTP with key-sharing: a
single key is provided to protect an entire SRTP session. However, EKT
remains secure even when SSRC values collide.[¶](#section-6-2){.pilcrow}

SRTP master keys [MUST]{.bcp14} be randomly generated, and
\[[RFC4086](#RFC4086){.xref}\] offers some guidance about random number
generation. SRTP master keys [MUST NOT]{.bcp14} be reused for any other
purpose, and SRTP master keys [MUST NOT]{.bcp14} be derived from other
SRTP master keys.[¶](#section-6-3){.pilcrow}

The EKT Cipher includes its own authentication/integrity
check.[¶](#section-6-4){.pilcrow}

The presence of the SSRC in the EKTPlaintext ensures that an attacker
cannot substitute an EKTCiphertext from one SRTP stream into another
SRTP stream. This mitigates the impact of cut-and-paste attacks that
arise due to the lack of a cryptographic binding between the EKT Tag and
the rest of the SRTP packet. SRTP tags can only be cut-and-pasted within
the stream of packets sent by a given RTP endpoint; an attacker cannot
\"cross the streams\" and use an EKT Tag from one SSRC to reset the key
for another SSRC. The Epoch field in the FullEKTField also prevents an
attacker from rolling back to a previous key.[¶](#section-6-5){.pilcrow}

An attacker could send packets containing a FullEKTField, in an attempt
to consume additional CPU resources of the receiving system by causing
the receiving system to decrypt the EKT ciphertext and detect an
authentication failure. In some cases, caching the previous values of
the ciphertext as described in [Section
4.3.2](#inbound-processing){.xref} helps mitigate this
issue.[¶](#section-6-6){.pilcrow}

In a similar vein, EKT has no replay protection, so an attacker could
implant improper keys in receivers by capturing EKTCiphertext values
encrypted with a given EKTKey and replaying them in a different context,
e.g., from a different sender. When the underlying SRTP transform
provides integrity protection, this attack will just result in packet
loss. If it does not, then it will result in random data being fed to
RTP payload processing. An attacker that is in a position to mount these
attacks, however, could achieve the same effects more easily without
attacking EKT.[¶](#section-6-7){.pilcrow}

The key encryption keys distributed with EKTKey messages are group
shared symmetric keys, which means they do not provide protection within
the group. Group members can impersonate each other; for example, any
group member can generate an EKT Tag for any SSRC. The entity that
distributes EKTKeys can decrypt any keys distributed using EKT and thus
any media protected with those keys.[¶](#section-6-8){.pilcrow}

Each EKT Cipher specifies a value T that is the maximum number of times
a given key can be used. An endpoint [MUST NOT]{.bcp14} encrypt more
than T different FullEKTField values using the same EKTKey. In addition,
the EKTKey [MUST NOT]{.bcp14} be used beyond the lifetime provided by
the TTL described in [Section
5.2](#dtls-srtp-extensions){.xref}.[¶](#section-6-9){.pilcrow}

The key length of the EKT Cipher [MUST]{.bcp14} be at least as long as
the SRTP cipher and at least as long as the DTLS-SRTP
ciphers.[¶](#section-6-10){.pilcrow}

Part of the EKTPlaintext is known or is easily guessable to an attacker.
Thus, the EKT Cipher [MUST]{.bcp14} resist known plaintext attacks. In
practice, this requirement does not impose any restrictions on our
choices, since the ciphers in use provide high security even when much
plaintext is known.[¶](#section-6-11){.pilcrow}

An EKT Cipher [MUST]{.bcp14} resist attacks in which both ciphertexts
and plaintexts can be adaptively chosen by an attacker querying both the
encryption and decryption functions.[¶](#section-6-12){.pilcrow}

In some systems, when a member of a conference leaves the conference,
that conference is rekeyed so that the member who left the conference no
longer has the key. When changing to a new EKTKey, it is possible that
the attacker could block the EKTKey message getting to a particular
endpoint and that endpoint would keep sending media encrypted using the
old key. To mitigate that risk, the lifetime of the EKTKey
[MUST]{.bcp14} be limited by using the
ekt_ttl.[¶](#section-6-13){.pilcrow}
:::
:::

::: {#iana}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

::: {#iana-ekt-msg-types}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [EKT Message Types](#name-ekt-message-types){.section-name .selfRef} {#name-ekt-message-types}

IANA has created a new table for \"EKT Message Types\" in the
\"Real-Time Transport Protocol (RTP) Parameters\" registry. The initial
values in this registry are as follows:[¶](#section-7.1-1){.pilcrow}

[]{#name-ekt-message-types-2}

::: {#EKTMsgTypeTable}
  Message Type   Value   Specification
  -------------- ------- ---------------
  Short          0       RFC 8870
  Unassigned     1       
  Full           2       RFC 8870
  Unassigned     3-254   
  Reserved       255     RFC 8870

  : [Table 2](#table-2){.selfRef}: [EKT Message
  Types](#name-ekt-message-types-2){.selfRef}
:::

New entries in this table can be added via \"Specification Required\" as
defined in \[[RFC8126](#RFC8126){.xref}\]. To avoid conflicts with
pre-standard versions of EKT that have been deployed, IANA
[SHOULD]{.bcp14} give preference to the allocation of even values over
odd values until the even code points are consumed. Allocated values
[MUST]{.bcp14} be in the range of 0 to 254.[¶](#section-7.1-3){.pilcrow}

All new EKT messages [MUST]{.bcp14} be defined to include a length
parameter, as specified in [Section
4.1](#EKT){.xref}.[¶](#section-7.1-4){.pilcrow}
:::
:::

::: {#iana-ciphers}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [EKT Ciphers](#name-ekt-ciphers-2){.section-name .selfRef} {#name-ekt-ciphers-2}

IANA has created a new table for \"EKT Ciphers\" in the \"Real-Time
Transport Protocol (RTP) Parameters\" registry. The initial values in
this registry are as follows:[¶](#section-7.2-1){.pilcrow}

[]{#name-ekt-cipher-types}

::: {#EKTCipherTable}
  Name         Value   Specification
  ------------ ------- ---------------
  AESKW128     0       RFC 8870
  AESKW256     1       RFC 8870
  Unassigned   2-254   
  Reserved     255     RFC 8870

  : [Table 3](#table-3){.selfRef}: [EKT Cipher
  Types](#name-ekt-cipher-types){.selfRef}
:::

New entries in this table can be added via \"Specification Required\" as
defined in \[[RFC8126](#RFC8126){.xref}\]. The expert [SHOULD]{.bcp14}
ensure that the specification defines the values for L and T as required
in [Section 4.4](#cipher){.xref} of this document. Allocated values
[MUST]{.bcp14} be in the range of 0 to 254.[¶](#section-7.2-3){.pilcrow}
:::
:::

::: {#tls-extensions}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [TLS Extensions](#name-tls-extensions){.section-name .selfRef} {#name-tls-extensions}

IANA has added supported_ekt_ciphers as a new extension name to the
\"TLS ExtensionType Values\" table of the \"Transport Layer Security
(TLS) Extensions\" registry:[¶](#section-7.3-1){.pilcrow}

[]{.break}

Value:
:   39[¶](#section-7.3-2.2){.pilcrow}
:   

Extension Name:
:   supported_ekt_ciphers[¶](#section-7.3-2.4){.pilcrow}
:   

TLS 1.3:
:   CH, EE[¶](#section-7.3-2.6){.pilcrow}
:   

Recommended:
:   Y[¶](#section-7.3-2.8){.pilcrow}
:   

Reference:
:   RFC 8870[¶](#section-7.3-2.10){.pilcrow}
:   
:::
:::

::: {#tls-handshake-type}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [TLS Handshake Type](#name-tls-handshake-type){.section-name .selfRef} {#name-tls-handshake-type}

IANA has added ekt_key as a new entry in the \"TLS HandshakeType\" table
of the \"Transport Layer Security (TLS) Parameters\"
registry:[¶](#section-7.4-1){.pilcrow}

[]{.break}

Value:
:   26[¶](#section-7.4-2.2){.pilcrow}
:   

Description:
:   ekt_key[¶](#section-7.4-2.4){.pilcrow}
:   

DTLS-OK:
:   Y[¶](#section-7.4-2.6){.pilcrow}
:   

Reference:
:   RFC 8870[¶](#section-7.4-2.8){.pilcrow}
:   

Comment:

:   

:   
:::
:::
:::
:::

::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC3264\]
:   [Rosenberg, J.]{.refAuthor}[ and H. Schulzrinne]{.refAuthor}, [\"An
    Offer/Answer Model with Session Description Protocol
    (SDP)\"]{.refTitle}, [RFC 3264]{.seriesInfo}, [DOI
    10.17487/RFC3264]{.seriesInfo}, June 2002,
    \<<https://www.rfc-editor.org/info/rfc3264>\>.
:   

\[RFC3711\]
:   [Baugher, M.]{.refAuthor}[, McGrew, D.]{.refAuthor}[,
    Naslund, M.]{.refAuthor}[, Carrara, E.]{.refAuthor}[, and K.
    Norrman]{.refAuthor}, [\"The Secure Real-time Transport Protocol
    (SRTP)\"]{.refTitle}, [RFC 3711]{.seriesInfo}, [DOI
    10.17487/RFC3711]{.seriesInfo}, March 2004,
    \<<https://www.rfc-editor.org/info/rfc3711>\>.
:   

\[RFC5234\]
:   [Crocker, D., Ed.]{.refAuthor}[ and P. Overell]{.refAuthor},
    [\"Augmented BNF for Syntax Specifications: ABNF\"]{.refTitle}, [STD
    68]{.seriesInfo}, [RFC 5234]{.seriesInfo}, [DOI
    10.17487/RFC5234]{.seriesInfo}, January 2008,
    \<<https://www.rfc-editor.org/info/rfc5234>\>.
:   

\[RFC5649\]
:   [Housley, R.]{.refAuthor}[ and M. Dworkin]{.refAuthor}, [\"Advanced
    Encryption Standard (AES) Key Wrap with Padding
    Algorithm\"]{.refTitle}, [RFC 5649]{.seriesInfo}, [DOI
    10.17487/RFC5649]{.seriesInfo}, September 2009,
    \<<https://www.rfc-editor.org/info/rfc5649>\>.
:   

\[RFC5764\]
:   [McGrew, D.]{.refAuthor}[ and E. Rescorla]{.refAuthor}, [\"Datagram
    Transport Layer Security (DTLS) Extension to Establish Keys for the
    Secure Real-time Transport Protocol (SRTP)\"]{.refTitle}, [RFC
    5764]{.seriesInfo}, [DOI 10.17487/RFC5764]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5764>\>.
:   

\[RFC6347\]
:   [Rescorla, E.]{.refAuthor}[ and N. Modadugu]{.refAuthor},
    [\"Datagram Transport Layer Security Version 1.2\"]{.refTitle}, [RFC
    6347]{.seriesInfo}, [DOI 10.17487/RFC6347]{.seriesInfo}, January
    2012, \<<https://www.rfc-editor.org/info/rfc6347>\>.
:   

\[RFC8126\]
:   [Cotton, M.]{.refAuthor}[, Leiba, B.]{.refAuthor}[, and T.
    Narten]{.refAuthor}, [\"Guidelines for Writing an IANA
    Considerations Section in RFCs\"]{.refTitle}, [BCP 26]{.seriesInfo},
    [RFC 8126]{.seriesInfo}, [DOI 10.17487/RFC8126]{.seriesInfo}, June
    2017, \<<https://www.rfc-editor.org/info/rfc8126>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8446\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   
:::

::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[RFC4086\]
:   [Eastlake 3rd, D.]{.refAuthor}[, Schiller, J.]{.refAuthor}[, and S.
    Crocker]{.refAuthor}, [\"Randomness Requirements for
    Security\"]{.refTitle}, [BCP 106]{.seriesInfo}, [RFC
    4086]{.seriesInfo}, [DOI 10.17487/RFC4086]{.seriesInfo}, June 2005,
    \<<https://www.rfc-editor.org/info/rfc4086>\>.
:   

\[RFC8723\]
:   [Jennings, C.]{.refAuthor}[, Jones, P.]{.refAuthor}[,
    Barnes, R.]{.refAuthor}[, and A.B. Roach]{.refAuthor}, [\"Double
    Encryption Procedures for the Secure Real-Time Transport Protocol
    (SRTP)\"]{.refTitle}, [RFC 8723]{.seriesInfo}, [DOI
    10.17487/RFC8723]{.seriesInfo}, April 2020,
    \<<https://www.rfc-editor.org/info/rfc8723>\>.
:   

\[RFC8871\]
:   [Jones, P.]{.refAuthor}[, Benham, D.]{.refAuthor}[, and C.
    Groves]{.refAuthor}, [\"A Solution Framework for Private Media in
    Privacy-Enhanced RTP Conferencing (PERC)\"]{.refTitle}, [RFC
    8871]{.seriesInfo}, [DOI 10.17487/RFC8871]{.seriesInfo}, January
    2021, \<<https://www.rfc-editor.org/info/rfc8871>\>.
:   

\[TLS-DTLS13\]
:   [Rescorla, E.]{.refAuthor}[, Tschofenig, H.]{.refAuthor}[, and N.
    Modadugu]{.refAuthor}, [\"The Datagram Transport Layer Security
    (DTLS) Protocol Version 1.3\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-tls-dtls13-39]{.seriesInfo}, 2 November 2020,
    \<<https://tools.ietf.org/html/draft-ietf-tls-dtls13-39>\>.
:   
:::
:::

::: {#acknowledgements}
::: {#section-appendix.a .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

Thank you to [Russ Housley]{.contact-name}, who provided a detailed
review and significant help with crafting text for this document. Thanks
to [David Benham]{.contact-name}, [Yi Cheng]{.contact-name},
[Lakshminath Dondeti]{.contact-name}, [Kai Fischer]{.contact-name},
[Nermeen Ismail]{.contact-name}, [Paul Jones]{.contact-name}, [Eddy
Lem]{.contact-name}, [Jonathan Lennox]{.contact-name}, [Michael
Peck]{.contact-name}, [Rob Raymond]{.contact-name}, [Sean
Turner]{.contact-name}, [Magnus Westerlund]{.contact-name}, and [Felix
Wyss]{.contact-name} for fruitful discussions, comments, and
contributions to this document.[¶](#section-appendix.a-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.b .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Cullen Jennings]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Cisco Systems]{.org}
:::

::: email
Email: <fluffy@iii.ca>
:::

::: {.left dir="auto"}
[John Mattsson]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Ericsson AB]{.org}
:::

::: email
Email: <john.mattsson@ericsson.com>
:::

::: {.left dir="auto"}
[David A. McGrew]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Cisco Systems]{.org}
:::

::: email
Email: <mcgrew@cisco.com>
:::

::: {.left dir="auto"}
[Dan Wing]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Citrix Systems, Inc.]{.org}
:::

::: email
Email: <dwing-ietf@fuggles.com>
:::

::: {.left dir="auto"}
[Flemming Andreasen]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Cisco Systems]{.org}
:::

::: email
Email: <fandreas@cisco.com>
:::
:::
:::
