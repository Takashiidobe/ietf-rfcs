  RFC 9147           DTLS 1.3          April 2022
  ------------------ ----------------- ------------
  Rescorla, et al.   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9147](https://www.rfc-editor.org/rfc/rfc9147){.eref}

Obsoletes:
:   [6347](https://www.rfc-editor.org/rfc/rfc6347){.eref}

Category:
:   Standards Track

Published:
:   April 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    E. Rescorla
    :::

    ::: org
    Mozilla
    :::
    :::

    ::: author
    ::: author-name
    H. Tschofenig
    :::

    ::: org
    Arm Limited
    :::
    :::

    ::: author
    ::: author-name
    N. Modadugu
    :::

    ::: org
    Google, Inc.
    :::
    :::
:::

# RFC 9147 {#rfcnum}

# The Datagram Transport Layer Security (DTLS) Protocol Version 1.3 {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document specifies version 1.3 of the Datagram Transport Layer
Security (DTLS) protocol. DTLS 1.3 allows client/server applications to
communicate over the Internet in a way that is designed to prevent
eavesdropping, tampering, and message
forgery.[¶](#section-abstract-1){.pilcrow}

The DTLS 1.3 protocol is based on the Transport Layer Security (TLS) 1.3
protocol and provides equivalent security guarantees with the exception
of order protection / non-replayability. Datagram semantics of the
underlying transport are preserved by the DTLS
protocol.[¶](#section-abstract-2){.pilcrow}

This document obsoletes RFC 6347.[¶](#section-abstract-3){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9147>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}

This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November 10,
2008. The person(s) controlling the copyright in some of this material
may not have granted the IETF Trust the right to allow modifications of
such material outside the IETF Standards Process. Without obtaining an
adequate license from the person(s) controlling the copyright in such
materials, this document may not be modified outside the IETF Standards
Process, and derivative works of it may not be created outside the IETF
Standards Process, except to format it for publication as an RFC or to
translate it into languages other than
English.[¶](#section-boilerplate.2-3){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Conventions and
    Terminology](#name-conventions-and-terminology){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [DTLS Design Rationale and
    Overview](#name-dtls-design-rationale-and-o){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Packet
        Loss](#name-packet-loss){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Reordering](#name-reordering){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Fragmentation](#name-fragmentation){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [Replay
        Detection](#name-replay-detection){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [The DTLS Record
    Layer](#name-the-dtls-record-layer){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Demultiplexing DTLS
        Records](#name-demultiplexing-dtls-records){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Sequence Number and
        Epoch](#name-sequence-number-and-epoch){.xref}

        -   ::: {#section-toc.1-1.4.2.2.2.1}
            [4.2.1](#section-4.2.1){.xref}.  [Processing
            Guidelines](#name-processing-guidelines){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.2}
            [4.2.2](#section-4.2.2){.xref}.  [Reconstructing the
            Sequence Number and
            Epoch](#name-reconstructing-the-sequence){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.3}
            [4.2.3](#section-4.2.3){.xref}.  [Record Number
            Encryption](#name-record-number-encryption){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Transport Layer
        Mapping](#name-transport-layer-mapping){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [PMTU
        Issues](#name-pmtu-issues){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [Record Payload
        Protection](#name-record-payload-protection){.xref}

        -   ::: {#section-toc.1-1.4.2.5.2.1}
            [4.5.1](#section-4.5.1){.xref}.  [Anti-Replay](#name-anti-replay){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.2}
            [4.5.2](#section-4.5.2){.xref}.  [Handling Invalid
            Records](#name-handling-invalid-records){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.3}
            [4.5.3](#section-4.5.3){.xref}.  [AEAD
            Limits](#name-aead-limits){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [The DTLS Handshake
    Protocol](#name-the-dtls-handshake-protocol){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Denial-of-Service
        Countermeasures](#name-denial-of-service-counterme){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [DTLS Handshake Message
        Format](#name-dtls-handshake-message-form){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [ClientHello
        Message](#name-clienthello-message){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [ServerHello
        Message](#name-serverhello-message){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [Handshake Message Fragmentation
        and Reassembly](#name-handshake-message-fragmenta){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.6}
        [5.6](#section-5.6){.xref}.  [EndOfEarlyData
        Message](#name-endofearlydata-message){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.7}
        [5.7](#section-5.7){.xref}.  [DTLS Handshake
        Flights](#name-dtls-handshake-flights){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.8}
        [5.8](#section-5.8){.xref}.  [Timeout and
        Retransmission](#name-timeout-and-retransmission){.xref}

        -   ::: {#section-toc.1-1.5.2.8.2.1}
            [5.8.1](#section-5.8.1){.xref}.  [State
            Machine](#name-state-machine){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.8.2.2}
            [5.8.2](#section-5.8.2){.xref}.  [Timer
            Values](#name-timer-values){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.8.2.3}
            [5.8.3](#section-5.8.3){.xref}.  [Large Flight
            Sizes](#name-large-flight-sizes){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.8.2.4}
            [5.8.4](#section-5.8.4){.xref}.  [State Machine Duplication
            for Post-Handshake
            Messages](#name-state-machine-duplication-f){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.9}
        [5.9](#section-5.9){.xref}.  [Cryptographic Label
        Prefix](#name-cryptographic-label-prefix){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.10}
        [5.10](#section-5.10){.xref}. [Alert
        Messages](#name-alert-messages){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.11}
        [5.11](#section-5.11){.xref}. [Establishing New Associations
        with Existing
        Parameters](#name-establishing-new-associatio){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Example of Handshake with Timeout and
    Retransmission](#name-example-of-handshake-with-t){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Epoch Values and
        Rekeying](#name-epoch-values-and-rekeying){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [ACK Message](#name-ack-message){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Sending
        ACKs](#name-sending-acks){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Receiving
        ACKs](#name-receiving-acks){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Design
        Rationale](#name-design-rationale){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Key Updates](#name-key-updates){.xref}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Connection ID
    Updates](#name-connection-id-updates){.xref}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Connection ID
        Example](#name-connection-id-example){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Application Data
    Protocol](#name-application-data-protocol){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [Security
    Considerations](#name-security-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [Changes since DTLS
    1.2](#name-changes-since-dtls-12){.xref}
    :::

-   ::: {#section-toc.1-1.13}
    [13](#section-13){.xref}. [Updates Affecting DTLS
    1.2](#name-updates-affecting-dtls-12){.xref}
    :::

-   ::: {#section-toc.1-1.14}
    [14](#section-14){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.15}
    [15](#section-15){.xref}. [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.15.2.1}
        [15.1](#section-15.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.15.2.2}
        [15.2](#section-15.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.16}
    [Appendix A](#appendix-A){.xref}.  [Protocol Data Structures and
    Constant Values](#name-protocol-data-structures-an){.xref}

    -   ::: {#section-toc.1-1.16.2.1}
        [A.1](#appendix-A.1){.xref}.  [Record
        Layer](#name-record-layer){.xref}
        :::

    -   ::: {#section-toc.1-1.16.2.2}
        [A.2](#appendix-A.2){.xref}.  [Handshake
        Protocol](#name-handshake-protocol){.xref}
        :::

    -   ::: {#section-toc.1-1.16.2.3}
        [A.3](#appendix-A.3){.xref}.  [ACKs](#name-acks){.xref}
        :::

    -   ::: {#section-toc.1-1.16.2.4}
        [A.4](#appendix-A.4){.xref}.  [Connection ID
        Management](#name-connection-id-management){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.17}
    [Appendix B](#appendix-B){.xref}.  [Analysis of Limits on CCM
    Usage](#name-analysis-of-limits-on-ccm-u){.xref}

    -   ::: {#section-toc.1-1.17.2.1}
        [B.1](#appendix-B.1){.xref}.  [Confidentiality
        Limits](#name-confidentiality-limits){.xref}
        :::

    -   ::: {#section-toc.1-1.17.2.2}
        [B.2](#appendix-B.2){.xref}.  [Integrity
        Limits](#name-integrity-limits){.xref}
        :::

    -   ::: {#section-toc.1-1.17.2.3}
        [B.3](#appendix-B.3){.xref}.  [Limits for
        AEAD_AES_128_CCM_8](#name-limits-for-aead_aes_128_ccm){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.18}
    [Appendix C](#appendix-C){.xref}.  [Implementation
    Pitfalls](#name-implementation-pitfalls){.xref}
    :::

-   ::: {#section-toc.1-1.19}
    [](#appendix-D){.xref}[Contributors](#name-contributors){.xref}
    :::

-   ::: {#section-toc.1-1.20}
    [](#appendix-E){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The primary goal of the TLS protocol is to establish an authenticated,
confidentiality- and integrity-protected channel between two
communicating peers. The TLS protocol is composed of two layers: the TLS
record protocol and the TLS handshake protocol. However, TLS must run
over a reliable transport channel \-- typically TCP
\[[RFC0793](#RFC0793){.xref}\].[¶](#section-1-1){.pilcrow}

There are applications that use UDP \[[RFC0768](#RFC0768){.xref}\] as a
transport and the Datagram Transport Layer Security (DTLS) protocol has
been developed to offer communication security protection for those
applications. DTLS is deliberately designed to be as similar to TLS as
possible, both to minimize new security invention and to maximize the
amount of code and infrastructure reuse.[¶](#section-1-2){.pilcrow}

DTLS 1.0 \[[RFC4347](#RFC4347){.xref}\] was originally defined as a
delta from TLS 1.1 \[[RFC4346](#RFC4346){.xref}\], and DTLS 1.2
\[[RFC6347](#RFC6347){.xref}\] was defined as a series of deltas to TLS
1.2 \[[RFC5246](#RFC5246){.xref}\]. There is no DTLS 1.1; that version
number was skipped in order to harmonize version numbers with TLS. This
specification describes the most current version of the DTLS protocol as
a delta from TLS 1.3 \[[TLS13](#RFC8446){.xref}\]. It obsoletes DTLS
1.2.[¶](#section-1-3){.pilcrow}

Implementations that speak both DTLS 1.2 and DTLS 1.3 can interoperate
with those that speak only DTLS 1.2 (using DTLS 1.2 of course), just as
TLS 1.3 implementations can interoperate with TLS 1.2 (see [Appendix
D](https://www.rfc-editor.org/rfc/rfc8446#appendix-D){.relref} of
\[[TLS13](#RFC8446){.xref}\] for details). While backwards compatibility
with DTLS 1.0 is possible, the use of DTLS 1.0 is not recommended, as
explained in [Section
3.1.2](https://www.rfc-editor.org/rfc/rfc7525#section-3.1.2){.relref} of
\[[RFC7525](#RFC7525){.xref}\]. \[[DEPRECATE](#RFC8996){.xref}\] forbids
the use of DTLS 1.0.[¶](#section-1-4){.pilcrow}
:::
:::

::: {#conventions-and-terminology}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Conventions and Terminology](#name-conventions-and-terminology){.section-name .selfRef} {#name-conventions-and-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}

The following terms are used:[¶](#section-2-2){.pilcrow}

[]{.break}

client:
:   The endpoint initiating the DTLS
    connection.[¶](#section-2-3.2){.pilcrow}
:   

association:
:   Shared state between two endpoints established with a DTLS
    handshake.[¶](#section-2-3.4){.pilcrow}
:   

connection:
:   Synonym for association.[¶](#section-2-3.6){.pilcrow}
:   

endpoint:
:   Either the client or server of the
    connection.[¶](#section-2-3.8){.pilcrow}
:   

epoch:
:   One set of cryptographic keys used for encryption and
    decryption.[¶](#section-2-3.10){.pilcrow}
:   

handshake:
:   An initial negotiation between client and server that establishes
    the parameters of the connection.[¶](#section-2-3.12){.pilcrow}
:   

peer:
:   An endpoint. When discussing a particular endpoint, \"peer\" refers
    to the endpoint that is remote to the primary subject of
    discussion.[¶](#section-2-3.14){.pilcrow}
:   

receiver:
:   An endpoint that is receiving records.[¶](#section-2-3.16){.pilcrow}
:   

sender:
:   An endpoint that is transmitting
    records.[¶](#section-2-3.18){.pilcrow}
:   

server:
:   The endpoint that did not initiate the DTLS
    connection.[¶](#section-2-3.20){.pilcrow}
:   

CID:
:   Connection ID.[¶](#section-2-3.22){.pilcrow}
:   

MSL:
:   Maximum Segment Lifetime.[¶](#section-2-3.24){.pilcrow}
:   

The reader is assumed to be familiar with \[[TLS13](#RFC8446){.xref}\].
As in TLS 1.3, the HelloRetryRequest has the same format as a
ServerHello message, but for convenience we use the term
HelloRetryRequest throughout this document as if it were a distinct
message.[¶](#section-2-4){.pilcrow}

DTLS 1.3 uses network byte order (big-endian) format for encoding
messages based on the encoding format defined in
\[[TLS13](#RFC8446){.xref}\] and earlier (D)TLS
specifications.[¶](#section-2-5){.pilcrow}

The reader is also assumed to be familiar with
\[[RFC9146](#RFC9146){.xref}\], as this document applies the CID
functionality to DTLS 1.3.[¶](#section-2-6){.pilcrow}

Figures in this document illustrate various combinations of the DTLS
protocol exchanges, and the symbols have the following
meaning:[¶](#section-2-7){.pilcrow}

[]{.break}

\'+\'
:   indicates noteworthy extensions sent in the previously noted
    message.[¶](#section-2-8.2){.pilcrow}
:   

\'\*\'
:   indicates optional or situation-dependent messages/extensions that
    are not always sent.[¶](#section-2-8.4){.pilcrow}
:   

\'{}\'
:   indicates messages protected using keys derived from a
    \[sender\]\_handshake_traffic_secret.[¶](#section-2-8.6){.pilcrow}
:   

\'\[\]\'
:   indicates messages protected using keys derived from
    traffic_secret_N.[¶](#section-2-8.8){.pilcrow}
:   
:::
:::

::: {#dtls-rational}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [DTLS Design Rationale and Overview](#name-dtls-design-rationale-and-o){.section-name .selfRef} {#name-dtls-design-rationale-and-o}

The basic design philosophy of DTLS is to construct \"TLS over datagram
transport\". Datagram transport neither requires nor provides reliable
or in-order delivery of data. The DTLS protocol preserves this property
for application data. Applications such as media streaming, Internet
telephony, and online gaming use datagram transport for communication
due to the delay-sensitive nature of transported data. The behavior of
such applications is unchanged when the DTLS protocol is used to secure
communication, since the DTLS protocol does not compensate for lost or
reordered data traffic. Note that while low-latency streaming and gaming
use DTLS to protect data (e.g., for protection of a WebRTC data
channel), telephony utilizes DTLS for key establishment and the Secure
Real-time Transport Protocol (SRTP) for protection of data
\[[RFC5763](#RFC5763){.xref}\].[¶](#section-3-1){.pilcrow}

TLS cannot be used directly over datagram transports for the following
four reasons:[¶](#section-3-2){.pilcrow}

1.  [TLS relies on an implicit sequence number on records. If a record
    is not received, then the recipient will use the wrong sequence
    number when attempting to remove record protection from subsequent
    records. DTLS solves this problem by adding sequence numbers to
    records.[¶](#section-3-3.1){.pilcrow}]{#section-3-3.1}
2.  [The TLS handshake is a lock-step cryptographic protocol. Messages
    must be transmitted and received in a defined order; any other order
    is an error. The DTLS handshake includes message sequence numbers to
    enable fragmented message reassembly and in-order delivery in case
    datagrams are lost or
    reordered.[¶](#section-3-3.2){.pilcrow}]{#section-3-3.2}
3.  [Handshake messages are potentially larger than can be contained in
    a single datagram. DTLS adds fields to handshake messages to support
    fragmentation and
    reassembly.[¶](#section-3-3.3){.pilcrow}]{#section-3-3.3}
4.  [Datagram transport protocols are susceptible to abusive behavior
    effecting denial-of-service (DoS) attacks against nonparticipants.
    DTLS adds a return-routability check and DTLS 1.3 uses the TLS 1.3
    HelloRetryRequest message (see [Section 5.1](#dos){.xref} for
    details).[¶](#section-3-3.4){.pilcrow}]{#section-3-3.4}

::: {#packet-loss}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Packet Loss](#name-packet-loss){.section-name .selfRef} {#name-packet-loss}

DTLS uses a simple retransmission timer to handle packet loss. [Figure
1](#dtls-retransmission){.xref} demonstrates the basic concept, using
the first phase of the DTLS handshake:[¶](#section-3.1-1){.pilcrow}

[]{#name-dtls-retransmission-example}

::: {#dtls-retransmission}
::: {#section-3.1-2.1 .alignLeft .art-text .artwork}
             Client                                   Server
             ------                                   ------
             ClientHello           ------>

                                     X<-- HelloRetryRequest
                                                      (lost)

             [Timer Expires]

             ClientHello           ------>
             (retransmit)
:::

[Figure 1](#figure-1){.selfRef}: [DTLS Retransmission
Example](#name-dtls-retransmission-example){.selfRef}
:::

Once the client has transmitted the ClientHello message, it expects to
see a HelloRetryRequest or a ServerHello from the server. However, if
the timer expires, the client knows that either the ClientHello or the
response from the server has been lost, which causes the client to
retransmit the ClientHello. When the server receives the retransmission,
it knows to retransmit its HelloRetryRequest or
ServerHello.[¶](#section-3.1-3){.pilcrow}

The server also maintains a retransmission timer for messages it sends
(other than HelloRetryRequest) and retransmits when that timer expires.
Not applying retransmissions to the HelloRetryRequest avoids the need to
create state on the server. The HelloRetryRequest is designed to be
small enough that it will not itself be fragmented, thus avoiding
concerns about interleaving multiple
HelloRetryRequests.[¶](#section-3.1-4){.pilcrow}

For more detail on timeouts and retransmission, see [Section
5.8](#timeout-retransmissions){.xref}.[¶](#section-3.1-5){.pilcrow}
:::
:::

::: {#reordering}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Reordering](#name-reordering){.section-name .selfRef} {#name-reordering}

In DTLS, each handshake message is assigned a specific sequence number.
When a peer receives a handshake message, it can quickly determine
whether that message is the next message it expects. If it is, then it
processes it. If not, it queues it for future handling once all previous
messages have been received.[¶](#section-3.2-1){.pilcrow}
:::
:::

::: {#fragmentation}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Fragmentation](#name-fragmentation){.section-name .selfRef} {#name-fragmentation}

TLS and DTLS handshake messages can be quite large (in theory up to
2\^24-1 bytes, in practice many kilobytes). By contrast, UDP datagrams
are often limited to less than 1500 bytes if IP fragmentation is not
desired. In order to compensate for this limitation, each DTLS handshake
message may be fragmented over several DTLS records, each of which is
intended to fit in a single UDP datagram (see [Section
4.4](#pmtu-issues){.xref} for guidance). Each DTLS handshake message
contains both a fragment offset and a fragment length. Thus, a recipient
in possession of all bytes of a handshake message can reassemble the
original unfragmented message.[¶](#section-3.3-1){.pilcrow}
:::
:::

::: {#replay-detection}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [Replay Detection](#name-replay-detection){.section-name .selfRef} {#name-replay-detection}

DTLS optionally supports record replay detection. The technique used is
the same as in IPsec AH/ESP, by maintaining a bitmap window of received
records. Records that are too old to fit in the window and records that
have previously been received are silently discarded. The replay
detection feature is optional, since packet duplication is not always
malicious but can also occur due to routing errors. Applications may
conceivably detect duplicate packets and accordingly modify their data
transmission strategy.[¶](#section-3.4-1){.pilcrow}
:::
:::
:::
:::

::: {#the-dtls-record-layer}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [The DTLS Record Layer](#name-the-dtls-record-layer){.section-name .selfRef} {#name-the-dtls-record-layer}

The DTLS 1.3 record layer is different from the TLS 1.3 record layer and
also different from the DTLS 1.2 record
layer.[¶](#section-4-1){.pilcrow}

1.  [The DTLSCiphertext structure omits the superfluous version number
    and type fields.[¶](#section-4-2.1){.pilcrow}]{#section-4-2.1}
2.  [DTLS adds an epoch and sequence number to the TLS record header.
    This sequence number allows the recipient to correctly decrypt and
    verify DTLS records. However, the number of bits used for the epoch
    and sequence number fields in the DTLSCiphertext structure has been
    reduced from those in previous
    versions.[¶](#section-4-2.2){.pilcrow}]{#section-4-2.2}
3.  [The DTLS epoch serialized in DTLSPlaintext is 2 octets long for
    compatibility with DTLS 1.2. However, this value is set as the least
    significant 2 octets of the connection epoch, which is an 8 octet
    counter incremented on every KeyUpdate. See [Section
    4.2](#sequence-number-and-epoch){.xref} for details. The sequence
    number is set to be the low order 48 bits of the 64 bit sequence
    number. Plaintext records [MUST NOT]{.bcp14} be sent with sequence
    numbers that would exceed 2\^48-1, so the upper 16 bits will always
    be 0.[¶](#section-4-2.3){.pilcrow}]{#section-4-2.3}
4.  [The DTLSCiphertext structure has a variable-length
    header.[¶](#section-4-2.4){.pilcrow}]{#section-4-2.4}

DTLSPlaintext records are used to send unprotected records and
DTLSCiphertext records are used to send protected
records.[¶](#section-4-3){.pilcrow}

The DTLS record formats are shown below. Unless explicitly stated the
meaning of the fields is unchanged from previous TLS/DTLS
versions.[¶](#section-4-4){.pilcrow}

[]{#name-dtls-13-record-formats}

::: {#dtls-record}
::: {#section-4-5.1}
``` {.lang-tls-presentation .sourcecode}
    struct {
        ContentType type;
        ProtocolVersion legacy_record_version;
        uint16 epoch = 0
        uint48 sequence_number;
        uint16 length;
        opaque fragment[DTLSPlaintext.length];
    } DTLSPlaintext;

    struct {
         opaque content[DTLSPlaintext.length];
         ContentType type;
         uint8 zeros[length_of_padding];
    } DTLSInnerPlaintext;

    struct {
        opaque unified_hdr[variable];
        opaque encrypted_record[length];
    } DTLSCiphertext;
```
:::

[Figure 2](#figure-2){.selfRef}: [DTLS 1.3 Record
Formats](#name-dtls-13-record-formats){.selfRef}
:::

[]{.break}

legacy_record_version:
:   This value [MUST]{.bcp14} be set to {254, 253} for all records other
    than the initial ClientHello (i.e., one not generated after a
    HelloRetryRequest), where it may also be {254, 255} for
    compatibility purposes. It [MUST]{.bcp14} be ignored for all
    purposes. See \[[TLS13](#RFC8446){.xref}\], [Appendix
    D.1](https://www.rfc-editor.org/rfc/rfc8446#appendix-D.1){.relref}
    for the rationale for this.[¶](#section-4-6.2){.pilcrow}
:   

epoch:
:   The least significant 2 bytes of the connection epoch
    value.[¶](#section-4-6.4){.pilcrow}
:   

unified_hdr:
:   The unified header (unified_hdr) is a structure of variable length,
    shown in [Figure 3](#cid_hdr){.xref}.[¶](#section-4-6.6){.pilcrow}
:   

encrypted_record:
:   The encrypted form of the serialized DTLSInnerPlaintext
    structure.[¶](#section-4-6.8){.pilcrow}
:   

[]{#name-dtls-13-unified-header}

::: {#cid_hdr}
::: {#section-4-7.1 .alignLeft .art-text .artwork}
        0 1 2 3 4 5 6 7
        +-+-+-+-+-+-+-+-+
        |0|0|1|C|S|L|E E|
        +-+-+-+-+-+-+-+-+
        | Connection ID |   Legend:
        | (if any,      |
        /  length as    /   C   - Connection ID (CID) present
        |  negotiated)  |   S   - Sequence number length
        +-+-+-+-+-+-+-+-+   L   - Length present
        |  8 or 16 bit  |   E   - Epoch
        |Sequence Number|
        +-+-+-+-+-+-+-+-+
        | 16 bit Length |
        | (if present)  |
        +-+-+-+-+-+-+-+-+
:::

[Figure 3](#figure-3){.selfRef}: [DTLS 1.3 Unified
Header](#name-dtls-13-unified-header){.selfRef}
:::

[]{.break}

Fixed Bits:
:   The three high bits of the first byte of the unified header are set
    to 001. This ensures that the value will fit within the DTLS region
    when multiplexing is performed as described in
    \[[RFC7983](#RFC7983){.xref}\]. It also ensures that distinguishing
    encrypted DTLS 1.3 records from encrypted DTLS 1.2 records is
    possible when they are carried on the same host/port quartet; such
    multiplexing is only possible when CIDs
    \[[RFC9146](#RFC9146){.xref}\] are in use, in which case DTLS 1.2
    records will have the content type tls12_cid
    (25).[¶](#section-4-8.2){.pilcrow}
:   

C:
:   The C bit (0x10) is set if the Connection ID is
    present.[¶](#section-4-8.4){.pilcrow}
:   

S:
:   The S bit (0x08) indicates the size of the sequence number. 0 means
    an 8-bit sequence number, 1 means 16-bit. Implementations
    [MAY]{.bcp14} mix sequence numbers of different lengths on the same
    connection.[¶](#section-4-8.6){.pilcrow}
:   

L:
:   The L bit (0x04) is set if the length is
    present.[¶](#section-4-8.8){.pilcrow}
:   

E:
:   The two low bits (0x03) include the low-order two bits of the
    epoch.[¶](#section-4-8.10){.pilcrow}
:   

Connection ID:
:   Variable-length CID. The CID functionality is described in
    \[[RFC9146](#RFC9146){.xref}\]. An example can be found in [Section
    9.1](#connection-id-example){.xref}.[¶](#section-4-8.12){.pilcrow}
:   

Sequence Number:
:   The low-order 8 or 16 bits of the record sequence number. This value
    is 16 bits if the S bit is set to 1, and 8 bits if the S bit is
    0.[¶](#section-4-8.14){.pilcrow}
:   

Length:
:   Identical to the length field in a TLS 1.3
    record.[¶](#section-4-8.16){.pilcrow}
:   

As with previous versions of DTLS, multiple DTLSPlaintext and
DTLSCiphertext records can be included in the same underlying transport
datagram.[¶](#section-4-9){.pilcrow}

[Figure 4](#hdr_examples){.xref} illustrates different record
headers.[¶](#section-4-10){.pilcrow}

[]{#name-dtls-13-header-examples}

::: {#hdr_examples}
::: {#section-4-11.1 .alignLeft .art-text .artwork}
     0 1 2 3 4 5 6 7       0 1 2 3 4 5 6 7       0 1 2 3 4 5 6 7
    +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+
    | Content Type  |     |0|0|1|1|1|1|E E|     |0|0|1|0|0|0|E E|
    +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+
    |   16 bit      |     |               |     |8 bit Seq. No. |
    |   Version     |     / Connection ID /     +-+-+-+-+-+-+-+-+
    +-+-+-+-+-+-+-+-+     |               |     |               |
    |   16 bit      |     +-+-+-+-+-+-+-+-+     |   Encrypted   |
    |    Epoch      |     |    16 bit     |     /   Record      /
    +-+-+-+-+-+-+-+-+     |Sequence Number|     |               |
    |               |     +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+
    |               |     |   16 bit      |
    |   48 bit      |     |   Length      |       DTLSCiphertext
    |Sequence Number|     +-+-+-+-+-+-+-+-+         Structure
    |               |     |               |         (minimal)
    |               |     |  Encrypted    |
    +-+-+-+-+-+-+-+-+     /  Record       /
    |    16 bit     |     |               |
    |    Length     |     +-+-+-+-+-+-+-+-+
    +-+-+-+-+-+-+-+-+
    |               |      DTLSCiphertext
    |               |        Structure
    /   Fragment    /          (full)
    |               |
    +-+-+-+-+-+-+-+-+

     DTLSPlaintext
       Structure
:::

[Figure 4](#figure-4){.selfRef}: [DTLS 1.3 Header
Examples](#name-dtls-13-header-examples){.selfRef}
:::

The length field [MAY]{.bcp14} be omitted by clearing the L bit, which
means that the record consumes the entire rest of the datagram in the
lower level transport. In this case, it is not possible to have multiple
DTLSCiphertext format records without length fields in the same
datagram. Omitting the length field [MUST]{.bcp14} only be used for the
last record in a datagram. Implementations [MAY]{.bcp14} mix records
with and without length fields on the same
connection.[¶](#section-4-12){.pilcrow}

If a Connection ID is negotiated, then it [MUST]{.bcp14} be contained in
all datagrams. Sending implementations [MUST NOT]{.bcp14} mix records
from multiple DTLS associations in the same datagram. If the second or
later record has a connection ID which does not correspond to the same
association used for previous records, the rest of the datagram
[MUST]{.bcp14} be discarded.[¶](#section-4-13){.pilcrow}

When expanded, the epoch and sequence number can be combined into an
unpacked RecordNumber structure, as shown
below:[¶](#section-4-14){.pilcrow}

::: {#section-4-15}
``` {.lang-tls-presentation .sourcecode}
    struct {
        uint64 epoch;
        uint64 sequence_number;
    } RecordNumber;
```

[¶](#section-4-15){.pilcrow}
:::

This 128-bit value is used in the ACK message as well as in the
\"record_sequence_number\" input to the Authenticated Encryption with
Associated Data (AEAD) function. The entire header value shown in
[Figure 4](#hdr_examples){.xref} (but prior to record number encryption;
see [Section 4.2.3](#rne){.xref}) is used as the additional data value
for the AEAD function. For instance, if the minimal variant is used, the
Associated Data (AD) is 2 octets long. Note that this design is
different from the additional data calculation for DTLS 1.2 and for DTLS
1.2 with Connection IDs. In DTLS 1.3 the 64-bit sequence_number is used
as the sequence number for the AEAD computation; unlike DTLS 1.2, the
epoch is not included.[¶](#section-4-16){.pilcrow}

::: {#demultiplexing-dtls-records}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Demultiplexing DTLS Records](#name-demultiplexing-dtls-records){.section-name .selfRef} {#name-demultiplexing-dtls-records}

DTLS 1.3\'s header format is more complicated to demux than DTLS 1.2,
which always carried the content type as the first byte. As described in
[Figure 5](#demux){.xref}, the first byte determines how an incoming
DTLS record is demultiplexed. The first 3 bits of the first byte
distinguish a DTLS 1.3 encrypted record from record types used in
previous DTLS versions and plaintext DTLS 1.3 record types. Hence, the
range 32 (0b0010 0000) to 63 (0b0011 1111) needs to be excluded from
future allocations by IANA to avoid problems while demultiplexing; see
[Section 14](#iana-considerations){.xref}. Implementations can
demultiplex DTLS 1.3 records by examining the first byte as
follows:[¶](#section-4.1-1){.pilcrow}

-   [If the first byte is alert(21), handshake(22), or ack(proposed,
    26), the record [MUST]{.bcp14} be interpreted as a DTLSPlaintext
    record.[¶](#section-4.1-2.1){.pilcrow}]{#section-4.1-2.1}
-   [If the first byte is any other value, then receivers [MUST]{.bcp14}
    check to see if the leading bits of the first byte are 001. If so,
    the implementation [MUST]{.bcp14} process the record as
    DTLSCiphertext; the true content type will be inside the protected
    portion.[¶](#section-4.1-2.2){.pilcrow}]{#section-4.1-2.2}
-   [Otherwise, the record [MUST]{.bcp14} be rejected as if it had
    failed deprotection, as described in [Section
    4.5.2](#handling-invalid-records){.xref}.[¶](#section-4.1-2.3){.pilcrow}]{#section-4.1-2.3}

[Figure 5](#demux){.xref} shows this demultiplexing procedure
graphically, taking DTLS 1.3 and earlier versions of DTLS into
account.[¶](#section-4.1-3){.pilcrow}

[]{#name-demultiplexing-dtls-12-and-}

::: {#demux}
::: {#section-4.1-4.1 .alignLeft .art-text .artwork}
                 +----------------+
                 | Outer Content  |
                 |   Type (OCT)   |
                 |                |
                 |   OCT == 20   -+--> ChangeCipherSpec (DTLS <1.3)
                 |   OCT == 21   -+--> Alert (Plaintext)
                 |   OCT == 22   -+--> DTLSHandshake (Plaintext)
                 |   OCT == 23   -+--> Application Data (DTLS <1.3)
                 |   OCT == 24   -+--> Heartbeat (DTLS <1.3)
    packet  -->  |   OCT == 25   -+--> DTLSCiphertext with CID (DTLS 1.2)
                 |   OCT == 26   -+--> ACK (DTLS 1.3, Plaintext)
                 |                |
                 |                |   /+----------------+\
                 | 31 < OCT < 64 -+--> |DTLSCiphertext  |
                 |                |    |(header bits    |
                 |      else      |    | start with 001)|
                 |       |        |   /+-------+--------+\
                 +-------+--------+            |
                         |                     |
                         v          Decryption |
                   +---------+          +------+
                   |  Reject |          |
                   +---------+          v
                                +----------------+
                                | Decrypted      |
                                | Content Type   |
                                | (DCT)          |
                                |                |
                                |     DCT == 21 -+--> Alert
                                |     DCT == 22 -+--> DTLSHandshake
                                |     DCT == 23 -+--> Application Data
                                |     DCT == 24 -+--> Heartbeat
                                |     DCT == 26 -+--> ACK
                                |     else ------+--> Error
                                +----------------+
:::

[Figure 5](#figure-5){.selfRef}: [Demultiplexing DTLS 1.2 and DTLS 1.3
Records](#name-demultiplexing-dtls-12-and-){.selfRef}
:::
:::
:::

::: {#sequence-number-and-epoch}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Sequence Number and Epoch](#name-sequence-number-and-epoch){.section-name .selfRef} {#name-sequence-number-and-epoch}

DTLS uses an explicit or partly explicit sequence number, rather than an
implicit one, carried in the sequence_number field of the record.
Sequence numbers are maintained separately for each epoch, with each
sequence_number initially being 0 for each
epoch.[¶](#section-4.2-1){.pilcrow}

The epoch number is initially zero and is incremented each time keying
material changes and a sender aims to rekey. More details are provided
in [Section 6.1](#dtls-epoch){.xref}.[¶](#section-4.2-2){.pilcrow}

::: {#processing-guidelines}
::: {#section-4.2.1 .section}
#### [4.2.1.](#section-4.2.1){.section-number .selfRef} [Processing Guidelines](#name-processing-guidelines){.section-name .selfRef} {#name-processing-guidelines}

Because DTLS records could be reordered, a record from epoch M may be
received after epoch N (where N \> M) has begun. Implementations
[SHOULD]{.bcp14} discard records from earlier epochs but [MAY]{.bcp14}
choose to retain keying material from previous epochs for up to the
default MSL specified for TCP \[[RFC0793](#RFC0793){.xref}\] to allow
for packet reordering. (Note that the intention here is that
implementers use the current guidance from the IETF for MSL, as
specified in \[[RFC0793](#RFC0793){.xref}\] or successors, not that they
attempt to interrogate the MSL that the system TCP stack is
using.)[¶](#section-4.2.1-1){.pilcrow}

Conversely, it is possible for records that are protected with the new
epoch to be received prior to the completion of a handshake. For
instance, the server may send its Finished message and then start
transmitting data. Implementations [MAY]{.bcp14} either buffer or
discard such records, though when DTLS is used over reliable transports
(e.g., SCTP \[[RFC4960](#RFC4960){.xref}\]), they [SHOULD]{.bcp14} be
buffered and processed once the handshake completes. Note that TLS\'s
restrictions on when records may be sent still apply, and the receiver
treats the records as if they were sent in the right
order.[¶](#section-4.2.1-2){.pilcrow}

Implementations [MUST]{.bcp14} send retransmissions of lost messages
using the same epoch and keying material as the original
transmission.[¶](#section-4.2.1-3){.pilcrow}

Implementations [MUST]{.bcp14} either abandon an association or rekey
prior to allowing the sequence number to
wrap.[¶](#section-4.2.1-4){.pilcrow}

Implementations [MUST NOT]{.bcp14} allow the epoch to wrap, but instead
[MUST]{.bcp14} establish a new association, terminating the old
association.[¶](#section-4.2.1-5){.pilcrow}
:::
:::

::: {#reconstructing}
::: {#section-4.2.2 .section}
#### [4.2.2.](#section-4.2.2){.section-number .selfRef} [Reconstructing the Sequence Number and Epoch](#name-reconstructing-the-sequence){.section-name .selfRef} {#name-reconstructing-the-sequence}

When receiving protected DTLS records, the recipient does not have a
full epoch or sequence number value in the record and so there is some
opportunity for ambiguity. Because the full sequence number is used to
compute the per-record nonce and the epoch determines the keys, failure
to reconstruct these values leads to failure to deprotect the record,
and so implementations [MAY]{.bcp14} use a mechanism of their choice to
determine the full values. This section provides an algorithm which is
comparatively simple and which implementations are [RECOMMENDED]{.bcp14}
to follow.[¶](#section-4.2.2-1){.pilcrow}

If the epoch bits match those of the current epoch, then implementations
[SHOULD]{.bcp14} reconstruct the sequence number by computing the full
sequence number which is numerically closest to one plus the sequence
number of the highest successfully deprotected record in the current
epoch.[¶](#section-4.2.2-2){.pilcrow}

During the handshake phase, the epoch bits unambiguously indicate the
correct key to use. After the handshake is complete, if the epoch bits
do not match those from the current epoch, implementations
[SHOULD]{.bcp14} use the most recent past epoch which has matching bits,
and then reconstruct the sequence number for that epoch as described
above.[¶](#section-4.2.2-3){.pilcrow}
:::
:::

::: {#rne}
::: {#section-4.2.3 .section}
#### [4.2.3.](#section-4.2.3){.section-number .selfRef} [Record Number Encryption](#name-record-number-encryption){.section-name .selfRef} {#name-record-number-encryption}

In DTLS 1.3, when records are encrypted, record sequence numbers are
also encrypted. The basic pattern is that the underlying encryption
algorithm used with the AEAD algorithm is used to generate a mask which
is then XORed with the sequence number.[¶](#section-4.2.3-1){.pilcrow}

When the AEAD is based on AES, then the mask is generated by computing
AES-ECB on the first 16 bytes of the
ciphertext:[¶](#section-4.2.3-2){.pilcrow}

::: {#section-4.2.3-3 .alignLeft .art-text .artwork}
      Mask = AES-ECB(sn_key, Ciphertext[0..15])

[¶](#section-4.2.3-3){.pilcrow}
:::

When the AEAD is based on ChaCha20, then the mask is generated by
treating the first 4 bytes of the ciphertext as the block counter and
the next 12 bytes as the nonce, passing them to the ChaCha20 block
function ([Section
2.3](https://www.rfc-editor.org/rfc/rfc8439#section-2.3){.relref} of
\[[CHACHA](#RFC8439){.xref}\]):[¶](#section-4.2.3-4){.pilcrow}

::: {#section-4.2.3-5 .alignLeft .art-text .artwork}
      Mask = ChaCha20(sn_key, Ciphertext[0..3], Ciphertext[4..15])

[¶](#section-4.2.3-5){.pilcrow}
:::

The sn_key is computed as follows:[¶](#section-4.2.3-6){.pilcrow}

::: {#section-4.2.3-7 .alignLeft .art-text .artwork}
      [sender]_sn_key = HKDF-Expand-Label(Secret, "sn", "", key_length)

[¶](#section-4.2.3-7){.pilcrow}
:::

\[sender\] denotes the sending side. The per-epoch Secret value to be
used is described in [Section
7.3](https://www.rfc-editor.org/rfc/rfc8446#section-7.3){.relref} of
\[[TLS13](#RFC8446){.xref}\]. Note that a new key is used for each
epoch: because the epoch is sent in the clear, this does not result in
ambiguity.[¶](#section-4.2.3-8){.pilcrow}

The encrypted sequence number is computed by XORing the leading bytes of
the mask with the on-the-wire representation of the sequence number.
Decryption is accomplished by the same
process.[¶](#section-4.2.3-9){.pilcrow}

This procedure requires the ciphertext length to be at least 16 bytes.
Receivers [MUST]{.bcp14} reject shorter records as if they had failed
deprotection, as described in [Section
4.5.2](#handling-invalid-records){.xref}. Senders [MUST]{.bcp14} pad
short plaintexts out (using the conventional record padding mechanism)
in order to make a suitable-length ciphertext. Note that most of the
DTLS AEAD algorithms have a 16 byte authentication tag and need no
padding. However, some algorithms, such as TLS_AES_128_CCM_8\_SHA256,
have a shorter authentication tag and may require padding for short
inputs.[¶](#section-4.2.3-10){.pilcrow}

Future cipher suites, which are not based on AES or ChaCha20,
[MUST]{.bcp14} define their own record sequence number encryption in
order to be used with DTLS.[¶](#section-4.2.3-11){.pilcrow}

Note that sequence number encryption is only applied to the
DTLSCiphertext structure and not to the DTLSPlaintext structure, even
though it also contains a sequence
number.[¶](#section-4.2.3-12){.pilcrow}
:::
:::
:::
:::

::: {#transport-layer-mapping}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Transport Layer Mapping](#name-transport-layer-mapping){.section-name .selfRef} {#name-transport-layer-mapping}

DTLS messages [MAY]{.bcp14} be fragmented into multiple DTLS records.
Each DTLS record [MUST]{.bcp14} fit within a single datagram. In order
to avoid IP fragmentation, clients of the DTLS record layer
[SHOULD]{.bcp14} attempt to size records so that they fit within any
Path MTU (PMTU) estimates obtained from the record layer. For more
information about PMTU issues, see [Section
4.4](#pmtu-issues){.xref}.[¶](#section-4.3-1){.pilcrow}

Multiple DTLS records [MAY]{.bcp14} be placed in a single datagram.
Records are encoded consecutively. The length field from DTLS records
containing that field can be used to determine the boundaries between
records. The final record in a datagram can omit the length field. The
first byte of the datagram payload [MUST]{.bcp14} be the beginning of a
record. Records [MUST NOT]{.bcp14} span
datagrams.[¶](#section-4.3-2){.pilcrow}

DTLS records without CIDs do not contain any association identifiers,
and applications must arrange to multiplex between associations. With
UDP, the host/port number is used to look up the appropriate security
association for incoming records without
CIDs.[¶](#section-4.3-3){.pilcrow}

Some transports, such as DCCP \[[RFC4340](#RFC4340){.xref}\], provide
their own sequence numbers. When carried over those transports, both the
DTLS and the transport sequence numbers will be present. Although this
introduces a small amount of inefficiency, the transport layer and DTLS
sequence numbers serve different purposes; therefore, for conceptual
simplicity, it is superior to use both sequence
numbers.[¶](#section-4.3-4){.pilcrow}

Some transports provide congestion control for traffic carried over
them. If the congestion window is sufficiently narrow, DTLS handshake
retransmissions may be held rather than transmitted immediately,
potentially leading to timeouts and spurious retransmission. When DTLS
is used over such transports, care should be taken not to overrun the
likely congestion window. \[[RFC5238](#RFC5238){.xref}\] defines a
mapping of DTLS to DCCP that takes these issues into
account.[¶](#section-4.3-5){.pilcrow}
:::
:::

::: {#pmtu-issues}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [PMTU Issues](#name-pmtu-issues){.section-name .selfRef} {#name-pmtu-issues}

In general, DTLS\'s philosophy is to leave PMTU discovery to the
application. However, DTLS cannot completely ignore the PMTU for three
reasons:[¶](#section-4.4-1){.pilcrow}

-   [The DTLS record framing expands the datagram size, thus lowering
    the effective PMTU from the application\'s
    perspective.[¶](#section-4.4-2.1){.pilcrow}]{#section-4.4-2.1}
-   [In some implementations, the application may not directly talk to
    the network, in which case the DTLS stack may absorb ICMP \"Datagram
    Too Big\" indications \[[RFC1191](#RFC1191){.xref}\] or ICMPv6
    \"Packet Too Big\" indications
    \[[RFC4443](#RFC4443){.xref}\].[¶](#section-4.4-2.2){.pilcrow}]{#section-4.4-2.2}
-   [The DTLS handshake messages can exceed the
    PMTU.[¶](#section-4.4-2.3){.pilcrow}]{#section-4.4-2.3}

In order to deal with the first two issues, the DTLS record layer
[SHOULD]{.bcp14} behave as described below.[¶](#section-4.4-3){.pilcrow}

If PMTU estimates are available from the underlying transport protocol,
they should be made available to upper layer protocols. In
particular:[¶](#section-4.4-4){.pilcrow}

-   [For DTLS over UDP, the upper layer protocol [SHOULD]{.bcp14} be
    allowed to obtain the PMTU estimate maintained in the IP
    layer.[¶](#section-4.4-5.1){.pilcrow}]{#section-4.4-5.1}
-   [For DTLS over DCCP, the upper layer protocol [SHOULD]{.bcp14} be
    allowed to obtain the current estimate of the
    PMTU.[¶](#section-4.4-5.2){.pilcrow}]{#section-4.4-5.2}
-   [For DTLS over TCP or SCTP, which automatically fragment and
    reassemble datagrams, there is no PMTU limitation. However, the
    upper layer protocol [MUST NOT]{.bcp14} write any record that
    exceeds the maximum record size of 2\^14
    bytes.[¶](#section-4.4-5.3){.pilcrow}]{#section-4.4-5.3}

The DTLS record layer [SHOULD]{.bcp14} also allow the upper layer
protocol to discover the amount of record expansion expected by the DTLS
processing; alternately, it [MAY]{.bcp14} report PMTU estimates minus
the estimated expansion from the transport layer and DTLS record
framing.[¶](#section-4.4-6){.pilcrow}

Note that DTLS does not defend against spoofed ICMP messages;
implementations [SHOULD]{.bcp14} ignore any such messages that indicate
PMTUs below the IPv4 and IPv6 minimums of 576 and 1280 bytes,
respectively.[¶](#section-4.4-7){.pilcrow}

If there is a transport protocol indication that the PMTU was exceeded
(either via ICMP or via a refusal to send the datagram as in [Section
14](https://www.rfc-editor.org/rfc/rfc4340#section-14){.relref} of
\[[RFC4340](#RFC4340){.xref}\]), then the DTLS record layer
[MUST]{.bcp14} inform the upper layer protocol of the
error.[¶](#section-4.4-8){.pilcrow}

The DTLS record layer [SHOULD NOT]{.bcp14} interfere with upper layer
protocols performing PMTU discovery, whether via
\[[RFC1191](#RFC1191){.xref}\] and \[[RFC4821](#RFC4821){.xref}\] for
IPv4 or via \[[RFC8201](#RFC8201){.xref}\] for IPv6. In
particular:[¶](#section-4.4-9){.pilcrow}

-   [Where allowed by the underlying transport protocol, the upper layer
    protocol [SHOULD]{.bcp14} be allowed to set the state of the Don\'t
    Fragment (DF) bit (in IPv4) or prohibit local fragmentation (in
    IPv6).[¶](#section-4.4-10.1){.pilcrow}]{#section-4.4-10.1}
-   [If the underlying transport protocol allows the application to
    request PMTU probing (e.g., DCCP), the DTLS record layer
    [SHOULD]{.bcp14} honor this
    request.[¶](#section-4.4-10.2){.pilcrow}]{#section-4.4-10.2}

The final issue is the DTLS handshake protocol. From the perspective of
the DTLS record layer, this is merely another upper layer protocol.
However, DTLS handshakes occur infrequently and involve only a few round
trips; therefore, the handshake protocol PMTU handling places a premium
on rapid completion over accurate PMTU discovery. In order to allow
connections under these circumstances, DTLS implementations
[SHOULD]{.bcp14} follow the following
rules:[¶](#section-4.4-11){.pilcrow}

-   [If the DTLS record layer informs the DTLS handshake layer that a
    message is too big, the handshake layer [SHOULD]{.bcp14} immediately
    attempt to fragment the message, using any existing information
    about the PMTU.[¶](#section-4.4-12.1){.pilcrow}]{#section-4.4-12.1}
-   [If repeated retransmissions do not result in a response, and the
    PMTU is unknown, subsequent retransmissions [SHOULD]{.bcp14} back
    off to a smaller record size, fragmenting the handshake message as
    appropriate. This specification does not specify an exact number of
    retransmits to attempt before backing off, but 2-3 seems
    appropriate.[¶](#section-4.4-12.2){.pilcrow}]{#section-4.4-12.2}
:::
:::

::: {#record-payload-protection}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [Record Payload Protection](#name-record-payload-protection){.section-name .selfRef} {#name-record-payload-protection}

Like TLS, DTLS transmits data as a series of protected records. The rest
of this section describes the details of that
format.[¶](#section-4.5-1){.pilcrow}

::: {#anti-replay}
::: {#section-4.5.1 .section}
#### [4.5.1.](#section-4.5.1){.section-number .selfRef} [Anti-Replay](#name-anti-replay){.section-name .selfRef} {#name-anti-replay}

Each DTLS record contains a sequence number to provide replay
protection. Sequence number verification [SHOULD]{.bcp14} be performed
using the following sliding window procedure, borrowed from [Section
3.4.3](https://www.rfc-editor.org/rfc/rfc4303#section-3.4.3){.relref} of
\[[RFC4303](#RFC4303){.xref}\]. Because each epoch resets the sequence
number space, a separate sliding window is needed for each
epoch.[¶](#section-4.5.1-1){.pilcrow}

The received record counter for an epoch [MUST]{.bcp14} be initialized
to zero when that epoch is first used. For each received record, the
receiver [MUST]{.bcp14} verify that the record contains a sequence
number that does not duplicate the sequence number of any other record
received in that epoch during the lifetime of the association. This
check [SHOULD]{.bcp14} happen after deprotecting the record; otherwise,
the record discard might itself serve as a timing channel for the record
number. Note that computing the full record number from the partial is
still a potential timing channel for the record number, though a less
powerful one than whether the record was
deprotected.[¶](#section-4.5.1-2){.pilcrow}

Duplicates are rejected through the use of a sliding receive window.
(How the window is implemented is a local matter, but the following text
describes the functionality that the implementation must exhibit.) The
receiver [SHOULD]{.bcp14} pick a window large enough to handle any
plausible reordering, which depends on the data rate. (The receiver does
not notify the sender of the window
size.)[¶](#section-4.5.1-3){.pilcrow}

The \"right\" edge of the window represents the highest validated
sequence number value received in the epoch. Records that contain
sequence numbers lower than the \"left\" edge of the window are
rejected. Records falling within the window are checked against a list
of received records within the window. An efficient means for performing
this check, based on the use of a bit mask, is described in [Section
3.4.3](https://www.rfc-editor.org/rfc/rfc4303#section-3.4.3){.relref} of
\[[RFC4303](#RFC4303){.xref}\]. If the received record falls within the
window and is new, or if the record is to the right of the window, then
the record is new.[¶](#section-4.5.1-4){.pilcrow}

The window [MUST NOT]{.bcp14} be updated due to a received record until
that record has been deprotected
successfully.[¶](#section-4.5.1-5){.pilcrow}
:::
:::

::: {#handling-invalid-records}
::: {#section-4.5.2 .section}
#### [4.5.2.](#section-4.5.2){.section-number .selfRef} [Handling Invalid Records](#name-handling-invalid-records){.section-name .selfRef} {#name-handling-invalid-records}

Unlike TLS, DTLS is resilient in the face of invalid records (e.g.,
invalid formatting, length, MAC, etc.). In general, invalid records
[SHOULD]{.bcp14} be silently discarded, thus preserving the association;
however, an error [MAY]{.bcp14} be logged for diagnostic purposes.
Implementations which choose to generate an alert instead [MUST]{.bcp14}
generate fatal alerts to avoid attacks where the attacker repeatedly
probes the implementation to see how it responds to various types of
error. Note that if DTLS is run over UDP, then any implementation which
does this will be extremely susceptible to DoS attacks because UDP
forgery is so easy. Thus, generating fatal alerts is [NOT
RECOMMENDED]{.bcp14} for such transports, both to increase the
reliability of DTLS service and to avoid the risk of spoofing attacks
sending traffic to unrelated third
parties.[¶](#section-4.5.2-1){.pilcrow}

If DTLS is being carried over a transport that is resistant to forgery
(e.g., SCTP with SCTP-AUTH), then it is safer to send alerts because an
attacker will have difficulty forging a datagram that will not be
rejected by the transport layer.[¶](#section-4.5.2-2){.pilcrow}

Note that because invalid records are rejected at a layer lower than the
handshake state machine, they do not affect pending retransmission
timers.[¶](#section-4.5.2-3){.pilcrow}
:::
:::

::: {#aead-limits}
::: {#section-4.5.3 .section}
#### [4.5.3.](#section-4.5.3){.section-number .selfRef} [AEAD Limits](#name-aead-limits){.section-name .selfRef} {#name-aead-limits}

[Section
5.5](https://www.rfc-editor.org/rfc/rfc8446#section-5.5){.relref} of
\[[TLS13](#RFC8446){.xref}\] defines limits on the number of records
that can be protected using the same keys. These limits are specific to
an AEAD algorithm and apply equally to DTLS. Implementations [SHOULD
NOT]{.bcp14} protect more records than allowed by the limit specified
for the negotiated AEAD. Implementations [SHOULD]{.bcp14} initiate a key
update before reaching this limit.[¶](#section-4.5.3-1){.pilcrow}

\[[TLS13](#RFC8446){.xref}\] does not specify a limit for
AEAD_AES_128_CCM, but the analysis in [Appendix B](#ccm-bounds){.xref}
shows that a limit of 2\^23 packets can be used to obtain the same
confidentiality protection as the limits specified in
TLS.[¶](#section-4.5.3-2){.pilcrow}

The usage limits defined in TLS 1.3 exist for protection against attacks
on confidentiality and apply to successful applications of AEAD
protection. The integrity protections in authenticated encryption also
depend on limiting the number of attempts to forge packets. TLS achieves
this by closing connections after any record fails an authentication
check. In comparison, DTLS ignores any packet that cannot be
authenticated, allowing multiple forgery
attempts.[¶](#section-4.5.3-3){.pilcrow}

Implementations [MUST]{.bcp14} count the number of received packets that
fail authentication with each key. If the number of packets that fail
authentication exceeds a limit that is specific to the AEAD in use, an
implementation [SHOULD]{.bcp14} immediately close the connection.
Implementations [SHOULD]{.bcp14} initiate a key update with
update_requested before reaching this limit. Once a key update has been
initiated, the previous keys can be dropped when the limit is reached
rather than closing the connection. Applying a limit reduces the
probability that an attacker is able to successfully forge a packet; see
\[[AEBounds](#AEBounds){.xref}\] and
\[[ROBUST](#ROBUST){.xref}\].[¶](#section-4.5.3-4){.pilcrow}

For AEAD_AES_128_GCM, AEAD_AES_256_GCM, and AEAD_CHACHA20_POLY1305, the
limit on the number of records that fail authentication is 2\^36. Note
that the analysis in \[[AEBounds](#AEBounds){.xref}\] supports a higher
limit for AEAD_AES_128_GCM and AEAD_AES_256_GCM, but this specification
recommends a lower limit. For AEAD_AES_128_CCM, the limit on the number
of records that fail authentication is 2\^23.5; see [Appendix
B](#ccm-bounds){.xref}.[¶](#section-4.5.3-5){.pilcrow}

The AEAD_AES_128_CCM_8 AEAD, as used in TLS_AES_128_CCM_8\_SHA256, does
not have a limit on the number of records that fail authentication that
both limits the probability of forgery by the same amount and does not
expose implementations to the risk of denial of service; see [Appendix
B.3](#ccm-short){.xref}. Therefore, TLS_AES_128_CCM_8\_SHA256 [MUST
NOT]{.bcp14} be used in DTLS without additional safeguards against
forgery. Implementations [MUST]{.bcp14} set usage limits for
AEAD_AES_128_CCM_8 based on an understanding of any additional forgery
protections that are used.[¶](#section-4.5.3-6){.pilcrow}

Any TLS cipher suite that is specified for use with DTLS [MUST]{.bcp14}
define limits on the use of the associated AEAD function that preserves
margins for both confidentiality and integrity. That is, limits
[MUST]{.bcp14} be specified for the number of packets that can be
authenticated and for the number of packets that can fail authentication
before a key update is required. Providing a reference to any analysis
upon which values are based \-- and any assumptions used in that
analysis \-- allows limits to be adapted to varying usage
conditions.[¶](#section-4.5.3-7){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#dtls}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [The DTLS Handshake Protocol](#name-the-dtls-handshake-protocol){.section-name .selfRef} {#name-the-dtls-handshake-protocol}

DTLS 1.3 reuses the TLS 1.3 handshake messages and flows, with the
following changes:[¶](#section-5-1){.pilcrow}

1.  [To handle message loss, reordering, and fragmentation,
    modifications to the handshake header are
    necessary.[¶](#section-5-2.1){.pilcrow}]{#section-5-2.1}
2.  [Retransmission timers are introduced to handle message
    loss.[¶](#section-5-2.2){.pilcrow}]{#section-5-2.2}
3.  [A new ACK content type has been added for reliable message delivery
    of handshake messages.[¶](#section-5-2.3){.pilcrow}]{#section-5-2.3}

In addition, DTLS reuses TLS 1.3\'s \"cookie\" extension to provide a
return-routability check as part of connection establishment. This is an
important DoS prevention mechanism for UDP-based protocols, unlike
TCP-based protocols, for which TCP establishes return-routability as
part of the connection establishment.[¶](#section-5-3){.pilcrow}

DTLS implementations do not use the TLS 1.3 \"compatibility mode\"
described in [Appendix
D.4](https://www.rfc-editor.org/rfc/rfc8446#appendix-D.4){.relref} of
\[[TLS13](#RFC8446){.xref}\]. DTLS servers [MUST NOT]{.bcp14} echo the
\"legacy_session_id\" value from the client and endpoints [MUST
NOT]{.bcp14} send ChangeCipherSpec messages.[¶](#section-5-4){.pilcrow}

With these exceptions, the DTLS message formats, flows, and logic are
the same as those of TLS 1.3.[¶](#section-5-5){.pilcrow}

::: {#dos}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Denial-of-Service Countermeasures](#name-denial-of-service-counterme){.section-name .selfRef} {#name-denial-of-service-counterme}

Datagram security protocols are extremely susceptible to a variety of
DoS attacks. Two attacks are of particular
concern:[¶](#section-5.1-1){.pilcrow}

1.  [An attacker can consume excessive resources on the server by
    transmitting a series of handshake initiation requests, causing the
    server to allocate state and potentially to perform expensive
    cryptographic
    operations.[¶](#section-5.1-2.1){.pilcrow}]{#section-5.1-2.1}
2.  [An attacker can use the server as an amplifier by sending
    connection initiation messages with a forged source address that
    belongs to a victim. The server then sends its response to the
    victim machine, thus flooding it. Depending on the selected
    parameters, this response message can be quite large, as is the case
    for a Certificate
    message.[¶](#section-5.1-2.2){.pilcrow}]{#section-5.1-2.2}

In order to counter both of these attacks, DTLS borrows the stateless
cookie technique used by Photuris \[[RFC2522](#RFC2522){.xref}\] and IKE
\[[RFC7296](#RFC7296){.xref}\]. When the client sends its ClientHello
message to the server, the server [MAY]{.bcp14} respond with a
HelloRetryRequest message. The HelloRetryRequest message, as well as the
\"cookie\" extension, is defined in TLS 1.3. The HelloRetryRequest
message contains a stateless cookie (see \[[TLS13](#RFC8446){.xref}\],
[Section
4.2.2](https://www.rfc-editor.org/rfc/rfc8446#section-4.2.2){.relref}).
The client [MUST]{.bcp14} send a new ClientHello with the cookie added
as an extension. The server then verifies the cookie and proceeds with
the handshake only if it is valid. This mechanism forces the
attacker/client to be able to receive the cookie, which makes DoS
attacks with spoofed IP addresses difficult. This mechanism does not
provide any defense against DoS attacks mounted from valid IP
addresses.[¶](#section-5.1-3){.pilcrow}

The DTLS 1.3 specification changes how cookies are exchanged compared to
DTLS 1.2. DTLS 1.3 reuses the HelloRetryRequest message and conveys the
cookie to the client via an extension. The client receiving the cookie
uses the same extension to place the cookie subsequently into a
ClientHello message. DTLS 1.2, on the other hand, used a separate
message, namely the HelloVerifyRequest, to pass a cookie to the client
and did not utilize the extension mechanism. For backwards compatibility
reasons, the cookie field in the ClientHello is present in DTLS 1.3 but
is ignored by a DTLS 1.3-compliant server
implementation.[¶](#section-5.1-4){.pilcrow}

The exchange is shown in [Figure 6](#dtls-cookie-exchange){.xref}. Note
that the figure focuses on the cookie exchange; all other extensions are
omitted.[¶](#section-5.1-5){.pilcrow}

[]{#name-dtls-exchange-with-helloret}

::: {#dtls-cookie-exchange}
::: {#section-5.1-6.1 .alignLeft .art-text .artwork}
          Client                                   Server
          ------                                   ------
          ClientHello           ------>

                                <----- HelloRetryRequest
                                        + cookie

          ClientHello           ------>
           + cookie

          [Rest of handshake]
:::

[Figure 6](#figure-6){.selfRef}: [DTLS Exchange with HelloRetryRequest
Containing the \"cookie\"
Extension](#name-dtls-exchange-with-helloret){.selfRef}
:::

The \"cookie\" extension is defined in [Section
4.2.2](https://www.rfc-editor.org/rfc/rfc8446#section-4.2.2){.relref} of
\[[TLS13](#RFC8446){.xref}\]. When sending the initial ClientHello, the
client does not have a cookie yet. In this case, the \"cookie\"
extension is omitted and the legacy_cookie field in the ClientHello
message [MUST]{.bcp14} be set to a zero-length vector (i.e., a
zero-valued single byte length field).[¶](#section-5.1-7){.pilcrow}

When responding to a HelloRetryRequest, the client [MUST]{.bcp14} create
a new ClientHello message following the description in [Section
4.1.2](https://www.rfc-editor.org/rfc/rfc8446#section-4.1.2){.relref} of
\[[TLS13](#RFC8446){.xref}\].[¶](#section-5.1-8){.pilcrow}

If the HelloRetryRequest message is used, the initial ClientHello and
the HelloRetryRequest are included in the calculation of the transcript
hash. The computation of the message hash for the HelloRetryRequest is
done according to the description in [Section
4.4.1](https://www.rfc-editor.org/rfc/rfc8446#section-4.4.1){.relref} of
\[[TLS13](#RFC8446){.xref}\].[¶](#section-5.1-9){.pilcrow}

The handshake transcript is not reset with the second ClientHello, and a
stateless server-cookie implementation requires the content or hash of
the initial ClientHello (and HelloRetryRequest) to be stored in the
cookie. The initial ClientHello is included in the handshake transcript
as a synthetic \"message_hash\" message, so only the hash value is
needed for the handshake to complete, though the complete
HelloRetryRequest contents are needed.[¶](#section-5.1-10){.pilcrow}

When the second ClientHello is received, the server can verify that the
cookie is valid and that the client can receive packets at the given IP
address. If the client\'s apparent IP address is embedded in the cookie,
this prevents an attacker from generating an acceptable ClientHello
apparently from another user.[¶](#section-5.1-11){.pilcrow}

One potential attack on this scheme is for the attacker to collect a
number of cookies from different addresses where it controls endpoints
and then reuse them to attack the server. The server can defend against
this attack by changing the secret value frequently, thus invalidating
those cookies. If the server wishes to allow legitimate clients to
handshake through the transition (e.g., a client received a cookie with
Secret 1 and then sent the second ClientHello after the server has
changed to Secret 2), the server can have a limited window during which
it accepts both secrets. \[[RFC7296](#RFC7296){.xref}\] suggests adding
a key identifier to cookies to detect this case. An alternative approach
is simply to try verifying with both secrets. It is
[RECOMMENDED]{.bcp14} that servers implement a key rotation scheme that
allows the server to manage keys with overlapping
lifetimes.[¶](#section-5.1-12){.pilcrow}

Alternatively, the server can store timestamps in the cookie and reject
cookies that were generated outside a certain interval of
time.[¶](#section-5.1-13){.pilcrow}

DTLS servers [SHOULD]{.bcp14} perform a cookie exchange whenever a new
handshake is being performed. If the server is being operated in an
environment where amplification is not a problem, e.g., where ICE
\[[RFC8445](#RFC8445){.xref}\] has been used to establish bidirectional
connectivity, the server [MAY]{.bcp14} be configured not to perform a
cookie exchange. The default [SHOULD]{.bcp14} be that the exchange is
performed, however. In addition, the server [MAY]{.bcp14} choose not to
do a cookie exchange when a session is resumed or, more generically,
when the DTLS handshake uses a PSK-based key exchange and the IP address
matches one associated with the PSK. Servers which process 0-RTT
requests and send 0.5-RTT responses without a cookie exchange risk being
used in an amplification attack if the size of outgoing messages greatly
exceeds the size of those that are received. A server [SHOULD]{.bcp14}
limit the amount of data it sends toward a client address to three times
the amount of data sent by the client before it verifies that the client
is able to receive data at that address. A client address is valid after
a cookie exchange or handshake completion. Clients [MUST]{.bcp14} be
prepared to do a cookie exchange with every handshake. Note that cookies
are only valid for the existing handshake and cannot be stored for
future handshakes.[¶](#section-5.1-14){.pilcrow}

If a server receives a ClientHello with an invalid cookie, it
[MUST]{.bcp14} terminate the handshake with an \"illegal_parameter\"
alert. This allows the client to restart the connection from scratch
without a cookie.[¶](#section-5.1-15){.pilcrow}

As described in [Section
4.1.4](https://www.rfc-editor.org/rfc/rfc8446#section-4.1.4){.relref} of
\[[TLS13](#RFC8446){.xref}\], clients [MUST]{.bcp14} abort the handshake
with an \"unexpected_message\" alert in response to any second
HelloRetryRequest which was sent in the same connection (i.e., where the
ClientHello was itself in response to a
HelloRetryRequest).[¶](#section-5.1-16){.pilcrow}

DTLS clients which do not want to receive a Connection ID
[SHOULD]{.bcp14} still offer the \"connection_id\" extension
\[[RFC9146](#RFC9146){.xref}\] unless there is an application profile to
the contrary. This permits a server which wants to receive a CID to
negotiate one.[¶](#section-5.1-17){.pilcrow}
:::
:::

::: {#dtls-handshake-message-format}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [DTLS Handshake Message Format](#name-dtls-handshake-message-form){.section-name .selfRef} {#name-dtls-handshake-message-form}

DTLS uses the same Handshake messages as TLS 1.3. However, prior to
transmission they are converted to DTLSHandshake messages, which contain
extra data needed to support message loss, reordering, and message
fragmentation.[¶](#section-5.2-1){.pilcrow}

::: {#section-5.2-2}
``` {.lang-tls-presentation .sourcecode}
    enum {
        client_hello(1),
        server_hello(2),
        new_session_ticket(4),
        end_of_early_data(5),
        encrypted_extensions(8),
        request_connection_id(9),           /* New */
        new_connection_id(10),              /* New */
        certificate(11),
        certificate_request(13),
        certificate_verify(15),
        finished(20),
        key_update(24),
        message_hash(254),
        (255)
    } HandshakeType;
```

[¶](#section-5.2-2){.pilcrow}
:::

::: {#section-5.2-3}
``` {.lang-tls-presentation .sourcecode}
    struct {
        HandshakeType msg_type;    /* handshake type */
        uint24 length;             /* bytes in message */
        uint16 message_seq;        /* DTLS-required field */
        uint24 fragment_offset;    /* DTLS-required field */
        uint24 fragment_length;    /* DTLS-required field */
        select (msg_type) {
            case client_hello:          ClientHello;
            case server_hello:          ServerHello;
            case end_of_early_data:     EndOfEarlyData;
            case encrypted_extensions:  EncryptedExtensions;
            case certificate_request:   CertificateRequest;
            case certificate:           Certificate;
            case certificate_verify:    CertificateVerify;
            case finished:              Finished;
            case new_session_ticket:    NewSessionTicket;
            case key_update:            KeyUpdate;
            case request_connection_id: RequestConnectionId;
            case new_connection_id:     NewConnectionId;
        } body;
    } DTLSHandshake;
```

[¶](#section-5.2-3){.pilcrow}
:::

In DTLS 1.3, the message transcript is computed over the original TLS
1.3-style Handshake messages without the message_seq, fragment_offset,
and fragment_length values. Note that this is a change from DTLS 1.2
where those values were included in the
transcript.[¶](#section-5.2-4){.pilcrow}

The first message each side transmits in each association always has
message_seq = 0. Whenever a new message is generated, the message_seq
value is incremented by one. When a message is retransmitted, the old
message_seq value is reused, i.e., not incremented. From the perspective
of the DTLS record layer, the retransmission is a new record. This
record will have a new DTLSPlaintext.sequence_number
value.[¶](#section-5.2-5){.pilcrow}

Note: In DTLS 1.2, the message_seq was reset to zero in case of a
rehandshake (i.e., renegotiation). On the surface, a rehandshake in DTLS
1.2 shares similarities with a post-handshake message exchange in DTLS
1.3. However, in DTLS 1.3 the message_seq is not reset, to allow
distinguishing a retransmission from a previously sent post-handshake
message from a newly sent post-handshake
message.[¶](#section-5.2-6){.pilcrow}

DTLS implementations maintain (at least notionally) a next_receive_seq
counter. This counter is initially set to zero. When a handshake message
is received, if its message_seq value matches next_receive_seq,
next_receive_seq is incremented and the message is processed. If the
sequence number is less than next_receive_seq, the message
[MUST]{.bcp14} be discarded. If the sequence number is greater than
next_receive_seq, the implementation [SHOULD]{.bcp14} queue the message
but [MAY]{.bcp14} discard it. (This is a simple space/bandwidth
trade-off).[¶](#section-5.2-7){.pilcrow}

In addition to the handshake messages that are deprecated by the TLS 1.3
specification, DTLS 1.3 furthermore deprecates the HelloVerifyRequest
message originally defined in DTLS 1.0. DTLS 1.3-compliant
implementations [MUST NOT]{.bcp14} use the HelloVerifyRequest to execute
a return-routability check. A dual-stack DTLS 1.2 / DTLS 1.3 client
[MUST]{.bcp14}, however, be prepared to interact with a DTLS 1.2
server.[¶](#section-5.2-8){.pilcrow}
:::
:::

::: {#clienthello-message}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [ClientHello Message](#name-clienthello-message){.section-name .selfRef} {#name-clienthello-message}

The format of the ClientHello used by a DTLS 1.3 client differs from the
TLS 1.3 ClientHello format, as shown below.[¶](#section-5.3-1){.pilcrow}

::: {#section-5.3-2}
``` {.lang-tls-presentation .sourcecode}
    uint16 ProtocolVersion;
    opaque Random[32];

    uint8 CipherSuite[2];    /* Cryptographic suite selector */

    struct {
        ProtocolVersion legacy_version = { 254,253 }; // DTLSv1.2
        Random random;
        opaque legacy_session_id<0..32>;
        opaque legacy_cookie<0..2^8-1>;                  // DTLS
        CipherSuite cipher_suites<2..2^16-2>;
        opaque legacy_compression_methods<1..2^8-1>;
        Extension extensions<8..2^16-1>;
    } ClientHello;
```

[¶](#section-5.3-2){.pilcrow}
:::

[]{.break}

legacy_version:
:   In previous versions of DTLS, this field was used for version
    negotiation and represented the highest version number supported by
    the client. Experience has shown that many servers do not properly
    implement version negotiation, leading to \"version intolerance\" in
    which the server rejects an otherwise acceptable ClientHello with a
    version number higher than it supports. In DTLS 1.3, the client
    indicates its version preferences in the \"supported_versions\"
    extension (see [Section
    4.2.1](https://www.rfc-editor.org/rfc/rfc8446#section-4.2.1){.relref}
    of \[[TLS13](#RFC8446){.xref}\]) and the legacy_version field
    [MUST]{.bcp14} be set to {254, 253}, which was the version number
    for DTLS 1.2. The supported_versions entries for DTLS 1.0 and DTLS
    1.2 are 0xfeff and 0xfefd (to match the wire versions). The value
    0xfefc is used to indicate DTLS 1.3.[¶](#section-5.3-3.2){.pilcrow}
:   

random:
:   Same as for TLS 1.3, except that the downgrade sentinels described
    in [Section
    4.1.3](https://www.rfc-editor.org/rfc/rfc8446#section-4.1.3){.relref}
    of \[[TLS13](#RFC8446){.xref}\] when TLS 1.2 and TLS 1.1 and below
    are negotiated apply to DTLS 1.2 and DTLS 1.0,
    respectively.[¶](#section-5.3-3.4){.pilcrow}
:   

legacy_session_id:
:   Versions of TLS and DTLS before version 1.3 supported a \"session
    resumption\" feature, which has been merged with pre-shared keys
    (PSK) in version 1.3. A client which has a cached session ID set by
    a pre-DTLS 1.3 server [SHOULD]{.bcp14} set this field to that value.
    Otherwise, it [MUST]{.bcp14} be set as a zero-length vector (i.e., a
    zero-valued single byte length
    field).[¶](#section-5.3-3.6){.pilcrow}
:   

legacy_cookie:
:   A DTLS 1.3-only client [MUST]{.bcp14} set the legacy_cookie field to
    zero length. If a DTLS 1.3 ClientHello is received with any other
    value in this field, the server [MUST]{.bcp14} abort the handshake
    with an \"illegal_parameter\" alert.[¶](#section-5.3-3.8){.pilcrow}
:   

cipher_suites:
:   Same as for TLS 1.3; only suites with DTLS-OK=Y may be
    used.[¶](#section-5.3-3.10){.pilcrow}
:   

legacy_compression_methods:
:   Same as for TLS 1.3.[¶](#section-5.3-3.12){.pilcrow}
:   

extensions:
:   Same as for TLS 1.3.[¶](#section-5.3-3.14){.pilcrow}
:   
:::
:::

::: {#serverhello-message}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [ServerHello Message](#name-serverhello-message){.section-name .selfRef} {#name-serverhello-message}

The DTLS 1.3 ServerHello message is the same as the TLS 1.3 ServerHello
message, except that the legacy_version field is set to 0xfefd,
indicating DTLS 1.2.[¶](#section-5.4-1){.pilcrow}
:::
:::

::: {#handshake-message-fragmentation-and-reassembly}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [Handshake Message Fragmentation and Reassembly](#name-handshake-message-fragmenta){.section-name .selfRef} {#name-handshake-message-fragmenta}

As described in [Section 4.3](#transport-layer-mapping){.xref}, one or
more handshake messages may be carried in a single datagram. However,
handshake messages are potentially bigger than the size allowed by the
underlying datagram transport. DTLS provides a mechanism for fragmenting
a handshake message over a number of records, each of which can be
transmitted in separate datagrams, thus avoiding IP
fragmentation.[¶](#section-5.5-1){.pilcrow}

When transmitting the handshake message, the sender divides the message
into a series of N contiguous data ranges. The ranges [MUST NOT]{.bcp14}
overlap. The sender then creates N DTLSHandshake messages, all with the
same message_seq value as the original DTLSHandshake message. Each new
message is labeled with the fragment_offset (the number of bytes
contained in previous fragments) and the fragment_length (the length of
this fragment). The length field in all messages is the same as the
length field of the original message. An unfragmented message is a
degenerate case with fragment_offset=0 and fragment_length=length. Each
handshake message fragment that is placed into a record [MUST]{.bcp14}
be delivered in a single UDP datagram.[¶](#section-5.5-2){.pilcrow}

When a DTLS implementation receives a handshake message fragment
corresponding to the next expected handshake message sequence number, it
[MUST]{.bcp14} process it, either by buffering it until it has the
entire handshake message or by processing any in-order portions of the
message. The transcript consists of complete TLS Handshake messages
(reassembled as necessary). Note that this requires removing the
message_seq, fragment_offset, and fragment_length fields to create the
Handshake structure.[¶](#section-5.5-3){.pilcrow}

DTLS implementations [MUST]{.bcp14} be able to handle overlapping
fragment ranges. This allows senders to retransmit handshake messages
with smaller fragment sizes if the PMTU estimate changes. Senders [MUST
NOT]{.bcp14} change handshake message bytes upon retransmission.
Receivers [MAY]{.bcp14} check that retransmitted bytes are identical and
[SHOULD]{.bcp14} abort the handshake with an \"illegal_parameter\" alert
if the value of a byte changes.[¶](#section-5.5-4){.pilcrow}

Note that as with TLS, multiple handshake messages may be placed in the
same DTLS record, provided that there is room and that they are part of
the same flight. Thus, there are two acceptable ways to pack two DTLS
handshake messages into the same datagram: in the same record or in
separate records.[¶](#section-5.5-5){.pilcrow}
:::
:::

::: {#end-of-early-data}
::: {#section-5.6 .section}
### [5.6.](#section-5.6){.section-number .selfRef} [EndOfEarlyData Message](#name-endofearlydata-message){.section-name .selfRef} {#name-endofearlydata-message}

The DTLS 1.3 handshake has one important difference from the TLS 1.3
handshake: the EndOfEarlyData message is omitted both from the wire and
the handshake transcript. Because DTLS records have epochs,
EndOfEarlyData is not necessary to determine when the early data is
complete, and because DTLS is lossy, attackers can trivially mount the
deletion attacks that EndOfEarlyData prevents in TLS. Servers [SHOULD
NOT]{.bcp14} accept records from epoch 1 indefinitely once they are able
to process records from epoch 3. Though reordering of IP packets can
result in records from epoch 1 arriving after records from epoch 3, this
is not likely to persist for very long relative to the round trip time.
Servers could discard epoch 1 keys after the first epoch 3 data arrives,
or retain keys for processing epoch 1 data for a short period. (See
[Section 6.1](#dtls-epoch){.xref} for the definitions of each
epoch.)[¶](#section-5.6-1){.pilcrow}
:::
:::

::: {#dtls-handshake-flights}
::: {#section-5.7 .section}
### [5.7.](#section-5.7){.section-number .selfRef} [DTLS Handshake Flights](#name-dtls-handshake-flights){.section-name .selfRef} {#name-dtls-handshake-flights}

DTLS handshake messages are grouped into a series of message flights. A
flight starts with the handshake message transmission of one peer and
ends with the expected response from the other peer. [Table
1](#tab-flights){.xref} contains a complete list of message combinations
that constitute flights.[¶](#section-5.7-1){.pilcrow}

[]{#name-flight-handshake-message-co}

::: {#tab-flights}
  Note   Client   Server   Handshake Messages
  ------ -------- -------- ------------------------------------------------------------------------------------------------
         x                 ClientHello
                  x        HelloRetryRequest
                  x        ServerHello, EncryptedExtensions, CertificateRequest, Certificate, CertificateVerify, Finished
  1      x                 Certificate, CertificateVerify, Finished
  1               x        NewSessionTicket

  : [Table 1](#table-1){.selfRef}: [Flight Handshake Message
  Combinations](#name-flight-handshake-message-co){.selfRef}
:::

Remarks:[¶](#section-5.7-3){.pilcrow}

-   [[Table 1](#tab-flights){.xref} does not highlight any of the
    optional messages.[¶](#section-5.7-4.1){.pilcrow}]{#section-5.7-4.1}
-   [Regarding note (1): When a handshake flight is sent without any
    expected response, as is the case with the client\'s final flight or
    with the NewSessionTicket message, the flight must be acknowledged
    with an ACK
    message.[¶](#section-5.7-4.2){.pilcrow}]{#section-5.7-4.2}

Below are several example message exchanges illustrating the flight
concept. The notational conventions from \[[TLS13](#RFC8446){.xref}\]
are used.[¶](#section-5.7-5){.pilcrow}

[]{#name-message-flights-for-a-full-}

::: {#dtls-full}
::: {#section-5.7-6.1 .alignLeft .art-text .artwork}
    Client                                            Server

                                                               +--------+
     ClientHello                                               | Flight |
                           -------->                           +--------+

                                                               +--------+
                           <--------        HelloRetryRequest  | Flight |
                                             + cookie          +--------+


                                                               +--------+
    ClientHello                                                | Flight |
     + cookie              -------->                           +--------+



                                                  ServerHello
                                        {EncryptedExtensions}  +--------+
                                        {CertificateRequest*}  | Flight |
                                               {Certificate*}  +--------+
                                         {CertificateVerify*}
                                                   {Finished}
                           <--------      [Application Data*]



     {Certificate*}                                            +--------+
     {CertificateVerify*}                                      | Flight |
     {Finished}            -------->                           +--------+
     [Application Data]
                                                               +--------+
                           <--------                    [ACK]  | Flight |
                                          [Application Data*]  +--------+

     [Application Data]    <------->      [Application Data]
:::

[Figure 7](#figure-7){.selfRef}: [Message Flights for a Full DTLS
Handshake (with Cookie
Exchange)](#name-message-flights-for-a-full-){.selfRef}
:::

[]{#name-message-flights-for-resumpt}

::: {#dtls-psk}
::: {#section-5.7-7.1 .alignLeft .art-text .artwork}
     ClientHello                                              +--------+
      + pre_shared_key                                        | Flight |
      + psk_key_exchange_modes                                +--------+
      + key_share*         -------->


                                                 ServerHello
                                            + pre_shared_key  +--------+
                                                + key_share*  | Flight |
                                       {EncryptedExtensions}  +--------+
                           <--------              {Finished}
                                         [Application Data*]
                                                              +--------+
     {Finished}            -------->                          | Flight |
     [Application Data*]                                      +--------+

                                                              +--------+
                           <--------                   [ACK]  | Flight |
                                         [Application Data*]  +--------+

     [Application Data]    <------->      [Application Data]
:::

[Figure 8](#figure-8){.selfRef}: [Message Flights for Resumption and PSK
Handshake (without Cookie
Exchange)](#name-message-flights-for-resumpt){.selfRef}
:::

[]{#name-message-flights-for-the-zer}

::: {#dtls-zero-rtt}
::: {#section-5.7-8.1 .alignLeft .art-text .artwork}
    Client                                            Server

     ClientHello
      + early_data
      + psk_key_exchange_modes                                +--------+
      + key_share*                                            | Flight |
      + pre_shared_key                                        +--------+
     (Application Data*)     -------->

                                                 ServerHello
                                            + pre_shared_key
                                                + key_share*  +--------+
                                       {EncryptedExtensions}  | Flight |
                                                  {Finished}  +--------+
                           <--------     [Application Data*]


                                                              +--------+
     {Finished}            -------->                          | Flight |
     [Application Data*]                                      +--------+

                                                              +--------+
                           <--------                   [ACK]  | Flight |
                                         [Application Data*]  +--------+

     [Application Data]    <------->      [Application Data]
:::

[Figure 9](#figure-9){.selfRef}: [Message Flights for the Zero-RTT
Handshake](#name-message-flights-for-the-zer){.selfRef}
:::

[]{#name-message-flights-for-the-new}

::: {#dtls-post-handshake-ticket}
::: {#section-5.7-9.1 .alignLeft .art-text .artwork}
    Client                                            Server

                                                              +--------+
                           <--------       [NewSessionTicket] | Flight |
                                                              +--------+

                                                              +--------+
    [ACK]                  -------->                          | Flight |
                                                              +--------+
:::

[Figure 10](#figure-10){.selfRef}: [Message Flights for the
NewSessionTicket Message](#name-message-flights-for-the-new){.selfRef}
:::

KeyUpdate, NewConnectionId, and RequestConnectionId follow a similar
pattern to NewSessionTicket: a single message sent by one side followed
by an ACK by the other.[¶](#section-5.7-10){.pilcrow}
:::
:::

::: {#timeout-retransmissions}
::: {#section-5.8 .section}
### [5.8.](#section-5.8){.section-number .selfRef} [Timeout and Retransmission](#name-timeout-and-retransmission){.section-name .selfRef} {#name-timeout-and-retransmission}

::: {#state-machine}
::: {#section-5.8.1 .section}
#### [5.8.1.](#section-5.8.1){.section-number .selfRef} [State Machine](#name-state-machine){.section-name .selfRef} {#name-state-machine}

DTLS uses a simple timeout and retransmission scheme with the state
machine shown in [Figure
11](#dtls-timeout-state-machine){.xref}.[¶](#section-5.8.1-1){.pilcrow}

[]{#name-dtls-timeout-and-retransmis}

::: {#dtls-timeout-state-machine}
::: {#section-5.8.1-2.1 .alignLeft .art-text .artwork}
                                 +-----------+
                                 | PREPARING |
                    +----------> |           |
                    |            |           |
                    |            +-----------+
                    |                  |
                    |                  | Buffer next flight
                    |                  |
                    |                 \|/
                    |            +-----------+
                    |            |           |
                    |            |  SENDING  |<------------------+
                    |            |           |                   |
                    |            +-----------+                   |
            Receive |                  |                         |
               next |                  | Send flight or partial  |
             flight |                  | flight                  |
                    |                  |                         |
                    |                  | Set retransmit timer    |
                    |                 \|/                        |
                    |            +-----------+                   |
                    |            |           |                   |
                    +------------|  WAITING  |-------------------+
                    |     +----->|           |   Timer expires   |
                    |     |      +-----------+                   |
                    |     |          |  |   |                    |
                    |     |          |  |   |                    |
                    |     +----------+  |   +--------------------+
                    |    Receive record |   Read retransmit or ACK
            Receive |  (Maybe Send ACK) |
               last |                   |
             flight |                   | Receive ACK
                    |                   | for last flight
                   \|/                  |
                                        |
                +-----------+           |
                |           | <---------+
                | FINISHED  |
                |           |
                +-----------+
                    |  /|\
                    |   |
                    |   |
                    +---+

              Server read retransmit
                  Retransmit ACK
:::

[Figure 11](#figure-11){.selfRef}: [DTLS Timeout and Retransmission
State Machine](#name-dtls-timeout-and-retransmis){.selfRef}
:::

The state machine has four basic states: PREPARING, SENDING, WAITING,
and FINISHED.[¶](#section-5.8.1-3){.pilcrow}

In the PREPARING state, the implementation does whatever computations
are necessary to prepare the next flight of messages. It then buffers
them up for transmission (emptying the transmission buffer first) and
enters the SENDING state.[¶](#section-5.8.1-4){.pilcrow}

In the SENDING state, the implementation transmits the buffered flight
of messages. If the implementation has received one or more ACKs (see
[Section 7](#ack-msg){.xref}) from the peer, then it [SHOULD]{.bcp14}
omit any messages or message fragments which have already been
acknowledged. Once the messages have been sent, the implementation then
sets a retransmit timer and enters the WAITING
state.[¶](#section-5.8.1-5){.pilcrow}

There are four ways to exit the WAITING
state:[¶](#section-5.8.1-6){.pilcrow}

1.  [The retransmit timer expires: the implementation transitions to the
    SENDING state, where it retransmits the flight, adjusts and re-arms
    the retransmit timer (see [Section 5.8.2](#timer-values){.xref}),
    and returns to the WAITING
    state.[¶](#section-5.8.1-7.1){.pilcrow}]{#section-5.8.1-7.1}
2.  [The implementation reads an ACK from the peer: upon receiving an
    ACK for a partial flight (as mentioned in [Section
    7.1](#sending-acks){.xref}), the implementation transitions to the
    SENDING state, where it retransmits the unacknowledged portion of
    the flight, adjusts and re-arms the retransmit timer, and returns to
    the WAITING state. Upon receiving an ACK for a complete flight, the
    implementation cancels all retransmissions and either remains in
    WAITING, or, if the ACK was for the final flight, transitions to
    FINISHED.[¶](#section-5.8.1-7.2){.pilcrow}]{#section-5.8.1-7.2}
3.  [The implementation reads a retransmitted flight from the peer when
    none of the messages that it sent in response to that flight have
    been acknowledged: the implementation transitions to the SENDING
    state, where it retransmits the flight, adjusts and re-arms the
    retransmit timer, and returns to the WAITING state. The rationale
    here is that the receipt of a duplicate message is the likely result
    of timer expiry on the peer and therefore suggests that part of
    one\'s previous flight was
    lost.[¶](#section-5.8.1-7.3){.pilcrow}]{#section-5.8.1-7.3}
4.  [The implementation receives some or all of the next flight of
    messages: if this is the final flight of messages, the
    implementation transitions to FINISHED. If the implementation needs
    to send a new flight, it transitions to the PREPARING state. Partial
    reads (whether partial messages or only some of the messages in the
    flight) may also trigger the implementation to send an ACK, as
    described in [Section
    7.1](#sending-acks){.xref}.[¶](#section-5.8.1-7.4){.pilcrow}]{#section-5.8.1-7.4}

Because DTLS clients send the first message (ClientHello), they start in
the PREPARING state. DTLS servers start in the WAITING state, but with
empty buffers and no retransmit timer.[¶](#section-5.8.1-8){.pilcrow}

In addition, for at least twice the default MSL defined for
\[[RFC0793](#RFC0793){.xref}\], when in the FINISHED state, the server
[MUST]{.bcp14} respond to retransmission of the client\'s final flight
with a retransmit of its ACK.[¶](#section-5.8.1-9){.pilcrow}

Note that because of packet loss, it is possible for one side to be
sending application data even though the other side has not received the
first side\'s Finished message. Implementations [MUST]{.bcp14} either
discard or buffer all application data records for epoch 3 and above
until they have received the Finished message from the peer.
Implementations [MAY]{.bcp14} treat receipt of application data with a
new epoch prior to receipt of the corresponding Finished message as
evidence of reordering or packet loss and retransmit their final flight
immediately, shortcutting the retransmission
timer.[¶](#section-5.8.1-10){.pilcrow}
:::
:::

::: {#timer-values}
::: {#section-5.8.2 .section}
#### [5.8.2.](#section-5.8.2){.section-number .selfRef} [Timer Values](#name-timer-values){.section-name .selfRef} {#name-timer-values}

The configuration of timer settings varies with implementations, and
certain deployment environments require timer value adjustments.
Mishandling of the timer can lead to serious congestion problems \-- for
example, if many instances of a DTLS time out early and retransmit too
quickly on a congested link.[¶](#section-5.8.2-1){.pilcrow}

Unless implementations have deployment-specific and/or external
information about the round trip time, implementations [SHOULD]{.bcp14}
use an initial timer value of 1000 ms and double the value at each
retransmission, up to no less than 60 seconds (the maximum as specified
in RFC 6298 \[[RFC6298](#RFC6298){.xref}\]). Application-specific
profiles [MAY]{.bcp14} recommend shorter or longer timer values. For
instance:[¶](#section-5.8.2-2){.pilcrow}

-   [Profiles for specific deployment environments, such as in
    low-power, multi-hop mesh scenarios as used in some Internet of
    Things (IoT) networks, [MAY]{.bcp14} specify longer timeouts. See
    \[[IOT-PROFILE](#I-D.ietf-uta-tls13-iot-profile){.xref}\] for more
    information about one such DTLS 1.3 IoT
    profile.[¶](#section-5.8.2-3.1){.pilcrow}]{#section-5.8.2-3.1}
-   [Real-time protocols [MAY]{.bcp14} specify shorter timeouts. It is
    [RECOMMENDED]{.bcp14} that for DTLS-SRTP
    \[[RFC5764](#RFC5764){.xref}\], a default timeout of 400 ms be used;
    because customer experience degrades with one-way latencies of
    greater than 200 ms, real-time deployments are less likely to have
    long
    latencies.[¶](#section-5.8.2-3.2){.pilcrow}]{#section-5.8.2-3.2}

In settings where there is external information (for instance, from an
ICE \[[RFC8445](#RFC8445){.xref}\] handshake, or from previous
connections to the same server) about the RTT, implementations
[SHOULD]{.bcp14} use 1.5 times that RTT estimate as the retransmit
timer.[¶](#section-5.8.2-4){.pilcrow}

Implementations [SHOULD]{.bcp14} retain the current timer value until a
message is transmitted and acknowledged without having to be
retransmitted, at which time the value [SHOULD]{.bcp14} be adjusted to
1.5 times the measured round trip time for that message. After a long
period of idleness, no less than 10 times the current timer value,
implementations [MAY]{.bcp14} reset the timer to the initial
value.[¶](#section-5.8.2-5){.pilcrow}

Note that because retransmission is for the handshake and not dataflow,
the effect on congestion of shorter timeouts is smaller than in generic
protocols such as TCP or QUIC. Experience with DTLS 1.2, which uses a
simpler \"retransmit everything on timeout\" approach, has not shown
serious congestion problems in practice.[¶](#section-5.8.2-6){.pilcrow}
:::
:::

::: {#large-flight-sizes}
::: {#section-5.8.3 .section}
#### [5.8.3.](#section-5.8.3){.section-number .selfRef} [Large Flight Sizes](#name-large-flight-sizes){.section-name .selfRef} {#name-large-flight-sizes}

DTLS does not have any built-in congestion control or rate control; in
general, this is not an issue because messages tend to be small.
However, in principle, some messages \-- especially Certificate \-- can
be quite large. If all the messages in a large flight are sent at once,
this can result in network congestion. A better strategy is to send out
only part of the flight, sending more when messages are acknowledged.
Several extensions have been standardized to reduce the size of the
Certificate message \-- for example, the \"cached_info\" extension
\[[RFC7924](#RFC7924){.xref}\]; certificate compression
\[[RFC8879](#RFC8879){.xref}\]; and \[[RFC6066](#RFC6066){.xref}\],
which defines the \"client_certificate_url\" extension allowing DTLS
clients to send a sequence of Uniform Resource Locators (URLs) instead
of the client certificate.[¶](#section-5.8.3-1){.pilcrow}

DTLS stacks [SHOULD NOT]{.bcp14} send more than 10 records in a single
transmission.[¶](#section-5.8.3-2){.pilcrow}
:::
:::

::: {#state-machine-duplication}
::: {#section-5.8.4 .section}
#### [5.8.4.](#section-5.8.4){.section-number .selfRef} [State Machine Duplication for Post-Handshake Messages](#name-state-machine-duplication-f){.section-name .selfRef} {#name-state-machine-duplication-f}

DTLS 1.3 makes use of the following categories of post-handshake
messages:[¶](#section-5.8.4-1){.pilcrow}

1.  [NewSessionTicket[¶](#section-5.8.4-2.1){.pilcrow}]{#section-5.8.4-2.1}
2.  [KeyUpdate[¶](#section-5.8.4-2.2){.pilcrow}]{#section-5.8.4-2.2}
3.  [NewConnectionId[¶](#section-5.8.4-2.3){.pilcrow}]{#section-5.8.4-2.3}
4.  [RequestConnectionId[¶](#section-5.8.4-2.4){.pilcrow}]{#section-5.8.4-2.4}
5.  [Post-handshake client
    authentication[¶](#section-5.8.4-2.5){.pilcrow}]{#section-5.8.4-2.5}

Messages of each category can be sent independently, and reliability is
established via independent state machines, each of which behaves as
described in [Section 5.8.1](#state-machine){.xref}. For example, if a
server sends a NewSessionTicket and a CertificateRequest message, two
independent state machines will be
created.[¶](#section-5.8.4-3){.pilcrow}

Sending multiple instances of messages of a given category without
having completed earlier transmissions is allowed for some categories,
but not for others. Specifically, a server [MAY]{.bcp14} send multiple
NewSessionTicket messages at once without awaiting ACKs for earlier
NewSessionTicket messages first. Likewise, a server [MAY]{.bcp14} send
multiple CertificateRequest messages at once without having completed
earlier client authentication requests before. In contrast,
implementations [MUST NOT]{.bcp14} send KeyUpdate, NewConnectionId, or
RequestConnectionId messages if an earlier message of the same type has
not yet been acknowledged.[¶](#section-5.8.4-4){.pilcrow}

Note: Except for post-handshake client authentication, which involves
handshake messages in both directions, post-handshake messages are
single-flight, and their respective state machines on the sender side
reduce to waiting for an ACK and retransmitting the original message. In
particular, note that a RequestConnectionId message does not force the
receiver to send a NewConnectionId message in reply, and both messages
are therefore treated independently.[¶](#section-5.8.4-5){.pilcrow}

Creating and correctly updating multiple state machines requires
feedback from the handshake logic to the state machine layer, indicating
which message belongs to which state machine. For example, if a server
sends multiple CertificateRequest messages and receives a Certificate
message in response, the corresponding state machine can only be
determined after inspecting the certificate_request_context field.
Similarly, a server sending a single CertificateRequest and receiving a
NewConnectionId message in response can only decide that the
NewConnectionId message should be treated through an independent state
machine after inspecting the handshake message
type.[¶](#section-5.8.4-6){.pilcrow}
:::
:::
:::
:::

::: {#cryptographic-label-prefix}
::: {#section-5.9 .section}
### [5.9.](#section-5.9){.section-number .selfRef} [Cryptographic Label Prefix](#name-cryptographic-label-prefix){.section-name .selfRef} {#name-cryptographic-label-prefix}

[Section
7.1](https://www.rfc-editor.org/rfc/rfc8446#section-7.1){.relref} of
\[[TLS13](#RFC8446){.xref}\] specifies that HKDF-Expand-Label uses a
label prefix of \"tls13 \". For DTLS 1.3, that label [SHALL]{.bcp14} be
\"dtls13\". This ensures key separation between DTLS 1.3 and TLS 1.3.
Note that there is no trailing space; this is necessary in order to keep
the overall label size inside of one hash iteration because \"DTLS\" is
one letter longer than \"TLS\".[¶](#section-5.9-1){.pilcrow}
:::
:::

::: {#alert-messages}
::: {#section-5.10 .section}
### [5.10.](#section-5.10){.section-number .selfRef} [Alert Messages](#name-alert-messages){.section-name .selfRef} {#name-alert-messages}

Note that alert messages are not retransmitted at all, even when they
occur in the context of a handshake. However, a DTLS implementation
which would ordinarily issue an alert [SHOULD]{.bcp14} generate a new
alert message if the offending record is received again (e.g., as a
retransmitted handshake message). Implementations [SHOULD]{.bcp14}
detect when a peer is persistently sending bad messages and terminate
the local connection state after such misbehavior is detected. Note that
alerts are not reliably transmitted; implementations [SHOULD
NOT]{.bcp14} depend on receiving alerts in order to signal errors or
connection closure.[¶](#section-5.10-1){.pilcrow}

Any data received with an epoch/sequence number pair after that of a
valid received closure alert [MUST]{.bcp14} be ignored. Note: this is a
change from TLS 1.3 which depends on the order of receipt rather than
the epoch and sequence number.[¶](#section-5.10-2){.pilcrow}
:::
:::

::: {#establishing-new-associations-with-existing-parameters}
::: {#section-5.11 .section}
### [5.11.](#section-5.11){.section-number .selfRef} [Establishing New Associations with Existing Parameters](#name-establishing-new-associatio){.section-name .selfRef} {#name-establishing-new-associatio}

If a DTLS client-server pair is configured in such a way that repeated
connections happen on the same host/port quartet, then it is possible
that a client will silently abandon one connection and then initiate
another with the same parameters (e.g., after a reboot). This will
appear to the server as a new handshake with epoch=0. In cases where a
server believes it has an existing association on a given host/port
quartet and it receives an epoch=0 ClientHello, it [SHOULD]{.bcp14}
proceed with a new handshake but [MUST NOT]{.bcp14} destroy the existing
association until the client has demonstrated reachability either by
completing a cookie exchange or by completing a complete handshake
including delivering a verifiable Finished message. After a correct
Finished message is received, the server [MUST]{.bcp14} abandon the
previous association to avoid confusion between two valid associations
with overlapping epochs. The reachability requirement prevents
off-path/blind attackers from destroying associations merely by sending
forged ClientHellos.[¶](#section-5.11-1){.pilcrow}

Note: It is not always possible to distinguish which association a given
record is from. For instance, if the client performs a handshake,
abandons the connection, and then immediately starts a new handshake, it
may not be possible to tell which connection a given protected record is
for. In these cases, trial decryption may be necessary, though
implementations could use CIDs to avoid the 5-tuple-based
ambiguity.[¶](#section-5.11-2){.pilcrow}
:::
:::
:::
:::

::: {#example-of-handshake-with-timeout-and-retransmission}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Example of Handshake with Timeout and Retransmission](#name-example-of-handshake-with-t){.section-name .selfRef} {#name-example-of-handshake-with-t}

The following is an example of a handshake with lost packets and
retransmissions. Note that the client sends an empty ACK message because
it can only acknowledge Record 2 sent by the server once it has
processed messages in Record 0 needed to establish epoch 2 keys, which
are needed to encrypt or decrypt messages found in Record 2. [Section
7](#ack-msg){.xref} provides the necessary background details for this
interaction. Note: For simplicity, we are not resetting record numbers
in this diagram, so \"Record 1\" is really \"Epoch 2, Record 0\",
etc.[¶](#section-6-1){.pilcrow}

[]{#name-example-dtls-exchange-illus}

::: {#dtls-msg-loss}
::: {#section-6-2.1 .alignLeft .art-text .artwork}
    Client                                                Server
    ------                                                ------

     Record 0                  -------->
     ClientHello
     (message_seq=0)

                                 X<-----                 Record 0
                                 (lost)               ServerHello
                                                  (message_seq=0)
                                                         Record 1
                                              EncryptedExtensions
                                                  (message_seq=1)
                                                      Certificate
                                                  (message_seq=2)


                               <--------                 Record 2
                                                CertificateVerify
                                                  (message_seq=3)
                                                         Finished
                                                  (message_seq=4)

     Record 1                  -------->
     ACK []


                               <--------                 Record 3
                                                      ServerHello
                                                  (message_seq=0)
                                              EncryptedExtensions
                                                  (message_seq=1)
                                                      Certificate
                                                  (message_seq=2)

                               <--------                 Record 4
                                                CertificateVerify
                                                  (message_seq=3)
                                                         Finished
                                                  (message_seq=4)


     Record 2                  -------->
     Certificate
     (message_seq=1)
     CertificateVerify
     (message_seq=2)
     Finished
     (message_seq=3)

                               <--------               Record 5
                                                        ACK [2]
:::

[Figure 12](#figure-12){.selfRef}: [Example DTLS Exchange Illustrating
Message Loss](#name-example-dtls-exchange-illus){.selfRef}
:::

::: {#dtls-epoch}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Epoch Values and Rekeying](#name-epoch-values-and-rekeying){.section-name .selfRef} {#name-epoch-values-and-rekeying}

A recipient of a DTLS message needs to select the correct keying
material in order to process an incoming message. With the possibility
of message loss and reordering, an identifier is needed to determine
which cipher state has been used to protect the record payload. The
epoch value fulfills this role in DTLS. In addition to the TLS
1.3-defined key derivation steps (see [Section
7](https://www.rfc-editor.org/rfc/rfc8446#section-7){.relref} of
\[[TLS13](#RFC8446){.xref}\]), a sender may want to rekey at any time
during the lifetime of the connection. It therefore needs to indicate
that it is updating its sending cryptographic
keys.[¶](#section-6.1-1){.pilcrow}

This version of DTLS assigns dedicated epoch values to messages in the
protocol exchange to allow identification of the correct cipher
state:[¶](#section-6.1-2){.pilcrow}

-   [Epoch value (0) is used with unencrypted messages. There are three
    unencrypted messages in DTLS, namely ClientHello, ServerHello, and
    HelloRetryRequest.[¶](#section-6.1-3.1){.pilcrow}]{#section-6.1-3.1}
-   [Epoch value (1) is used for messages protected using keys derived
    from client_early_traffic_secret. Note that this epoch is skipped if
    the client does not offer early
    data.[¶](#section-6.1-3.2){.pilcrow}]{#section-6.1-3.2}
-   [Epoch value (2) is used for messages protected using keys derived
    from \[sender\]\_handshake_traffic_secret. Messages transmitted
    during the initial handshake, such as EncryptedExtensions,
    CertificateRequest, Certificate, CertificateVerify, and Finished,
    belong to this category. Note, however, that post-handshake messages
    are protected under the appropriate application traffic key and are
    not included in this
    category.[¶](#section-6.1-3.3){.pilcrow}]{#section-6.1-3.3}
-   [Epoch value (3) is used for payloads protected using keys derived
    from the initial \[sender\]\_application_traffic_secret_0. This may
    include handshake messages, such as post-handshake messages (e.g., a
    NewSessionTicket
    message).[¶](#section-6.1-3.4){.pilcrow}]{#section-6.1-3.4}
-   [Epoch values (4 to 2\^64-1) are used for payloads protected using
    keys from the \[sender\]\_application_traffic_secret_N
    (N>0).[¶](#section-6.1-3.5){.pilcrow}]{#section-6.1-3.5}

Using these reserved epoch values, a receiver knows what cipher state
has been used to encrypt and integrity protect a message.
Implementations that receive a record with an epoch value for which no
corresponding cipher state can be determined [SHOULD]{.bcp14} handle it
as a record which fails deprotection.[¶](#section-6.1-4){.pilcrow}

Note that epoch values do not wrap. If a DTLS implementation would need
to wrap the epoch value, it [MUST]{.bcp14} terminate the
connection.[¶](#section-6.1-5){.pilcrow}

The traffic key calculation is described in [Section
7.3](https://www.rfc-editor.org/rfc/rfc8446#section-7.3){.relref} of
\[[TLS13](#RFC8446){.xref}\].[¶](#section-6.1-6){.pilcrow}

[Figure 13](#dtls-msg-epoch){.xref} illustrates the epoch values in an
example DTLS handshake.[¶](#section-6.1-7){.pilcrow}

[]{#name-example-dtls-exchange-with-}

::: {#dtls-msg-epoch}
::: {#section-6.1-8.1 .alignLeft .art-text .artwork}
    Client                                             Server
    ------                                             ------

     Record 0
     ClientHello
     (epoch=0)
                                -------->
                                                         Record 0
                                <--------       HelloRetryRequest
                                                        (epoch=0)
     Record 1
     ClientHello                -------->
     (epoch=0)
                                                         Record 1
                                <--------             ServerHello
                                                        (epoch=0)
                                            {EncryptedExtensions}
                                                        (epoch=2)
                                                    {Certificate}
                                                        (epoch=2)
                                              {CertificateVerify}
                                                        (epoch=2)
                                                       {Finished}
                                                        (epoch=2)
     Record 2
     {Certificate}              -------->
     (epoch=2)
     {CertificateVerify}
     (epoch=2)
     {Finished}
     (epoch=2)
                                                         Record 2
                                <--------                   [ACK]
                                                        (epoch=3)
     Record 3
     [Application Data]         -------->
     (epoch=3)
                                                         Record 3
                                <--------      [Application Data]
                                                        (epoch=3)

                             Some time later ...
                     (Post-Handshake Message Exchange)
                                                         Record 4
                                <--------      [NewSessionTicket]
                                                        (epoch=3)
     Record 4
     [ACK]                      -------->
     (epoch=3)

                             Some time later ...
                               (Rekeying)
                                                         Record 5
                                <--------      [Application Data]
                                                        (epoch=4)
     Record 5
     [Application Data]         -------->
     (epoch=4)
:::

[Figure 13](#figure-13){.selfRef}: [Example DTLS Exchange with Epoch
Information](#name-example-dtls-exchange-with-){.selfRef}
:::
:::
:::
:::
:::

::: {#ack-msg}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [ACK Message](#name-ack-message){.section-name .selfRef} {#name-ack-message}

The ACK message is used by an endpoint to indicate which handshake
records it has received and processed from the other side. ACK is not a
handshake message but is rather a separate content type, with code point
26. This avoids having ACK being added to the handshake transcript. Note
that ACKs can still be sent in the same UDP datagram as handshake
records.[¶](#section-7-1){.pilcrow}

::: {#section-7-2}
``` {.lang-tls-presentation .sourcecode}
    struct {
        RecordNumber record_numbers<0..2^16-1>;
    } ACK;
```

[¶](#section-7-2){.pilcrow}
:::

[]{.break}

record_numbers:
:   A list of the records containing handshake messages in the current
    flight which the endpoint has received and either processed or
    buffered, in numerically increasing
    order.[¶](#section-7-3.2){.pilcrow}
:   

Implementations [MUST NOT]{.bcp14} acknowledge records containing
handshake messages or fragments which have not been processed or
buffered. Otherwise, deadlock can ensue. As an example, implementations
[MUST NOT]{.bcp14} send ACKs for handshake messages which they discard
because they are not the next expected
message.[¶](#section-7-4){.pilcrow}

During the handshake, ACKs only cover the current outstanding flight
(this is possible because DTLS is generally a lock-step protocol). In
particular, receiving a message from a handshake flight implicitly
acknowledges all messages from the previous flight(s). Accordingly, an
ACK from the server would not cover both the ClientHello and the
client\'s Certificate message, because the ClientHello and client
Certificate are in different flights. Implementations can accomplish
this by clearing their ACK list upon receiving the start of the next
flight.[¶](#section-7-5){.pilcrow}

For post-handshake messages, ACKs [SHOULD]{.bcp14} be sent once for each
received and processed handshake record (potentially subject to some
delay) and [MAY]{.bcp14} cover more than one flight. This includes
records containing messages which are discarded because a previous copy
has been received.[¶](#section-7-6){.pilcrow}

During the handshake, ACK records [MUST]{.bcp14} be sent with an epoch
which is equal to or higher than the record which is being acknowledged.
Note that some care is required when processing flights spanning
multiple epochs. For instance, if the client receives only the
ServerHello and Certificate and wishes to ACK them in a single record,
it must do so in epoch 2, as it is required to use an epoch greater than
or equal to 2 and cannot yet send with any greater epoch.
Implementations [SHOULD]{.bcp14} simply use the highest current sending
epoch, which will generally be the highest available. After the
handshake, implementations [MUST]{.bcp14} use the highest available
sending epoch.[¶](#section-7-7){.pilcrow}

::: {#sending-acks}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Sending ACKs](#name-sending-acks){.section-name .selfRef} {#name-sending-acks}

When an implementation detects a disruption in the receipt of the
current incoming flight, it [SHOULD]{.bcp14} generate an ACK that covers
the messages from that flight which it has received and processed so
far. Implementations have some discretion about which events to treat as
signs of disruption, but it is [RECOMMENDED]{.bcp14} that they generate
ACKs under two circumstances:[¶](#section-7.1-1){.pilcrow}

-   [When they receive a message or fragment which is out of order,
    either because it is not the next expected message or because it is
    not the next piece of the current
    message.[¶](#section-7.1-2.1){.pilcrow}]{#section-7.1-2.1}
-   [When they have received part of a flight and do not immediately
    receive the rest of the flight (which may be in the same UDP
    datagram). \"Immediately\" is hard to define. One approach is to set
    a timer for 1/4 the current retransmit timer value when the first
    record in the flight is received and then send an ACK when that
    timer expires. Note: The 1/4 value here is somewhat arbitrary. Given
    that the round trip estimates in the DTLS handshake are generally
    very rough (or the default), any value will be an approximation, and
    there is an inherent compromise due to competition between
    retransmission due to over-aggressive ACKing and over-aggressive
    timeout-based retransmission. As a comparison point, QUIC\'s
    loss-based recovery algorithms (\[[RFC9002](#RFC9002){.xref}\],
    [Section
    6.1.2](https://www.rfc-editor.org/rfc/rfc9002#section-6.1.2){.relref})
    work out to a delay of about 1/3 of the retransmit
    timer.[¶](#section-7.1-2.2){.pilcrow}]{#section-7.1-2.2}

In general, flights [MUST]{.bcp14} be ACKed unless they are implicitly
acknowledged. In the present specification, the following flights are
implicitly acknowledged by the receipt of the next flight, which
generally immediately follows the flight:[¶](#section-7.1-3){.pilcrow}

1.  [Handshake flights other than the client\'s final flight of the main
    handshake.[¶](#section-7.1-4.1){.pilcrow}]{#section-7.1-4.1}
2.  [The server\'s post-handshake
    CertificateRequest.[¶](#section-7.1-4.2){.pilcrow}]{#section-7.1-4.2}

ACKs [SHOULD NOT]{.bcp14} be sent for these flights unless the
responding flight cannot be generated immediately. All other flights
[MUST]{.bcp14} be ACKed. In this case, implementations [MAY]{.bcp14}
send explicit ACKs for the complete received flight even though it will
eventually also be implicitly acknowledged through the responding
flight. A notable example for this is the case of client authentication
in constrained environments, where generating the CertificateVerify
message can take considerable time on the client. Implementations
[MAY]{.bcp14} acknowledge the records corresponding to each transmission
of each flight or simply acknowledge the most recent one. In general,
implementations [SHOULD]{.bcp14} ACK as many received packets as can fit
into the ACK record, as this provides the most complete information and
thus reduces the chance of spurious retransmission; if space is limited,
implementations [SHOULD]{.bcp14} favor including records which have not
yet been acknowledged.[¶](#section-7.1-5){.pilcrow}

Note: While some post-handshake messages follow a request/response
pattern, this does not necessarily imply receipt. For example, a
KeyUpdate sent in response to a KeyUpdate with request_update set to
\"update_requested\" does not implicitly acknowledge the earlier
KeyUpdate message because the two KeyUpdate messages might have crossed
in flight.[¶](#section-7.1-6){.pilcrow}

ACKs [MUST NOT]{.bcp14} be sent for records of any content type other
than handshake or for records which cannot be
deprotected.[¶](#section-7.1-7){.pilcrow}

Note that in some cases it may be necessary to send an ACK which does
not contain any record numbers. For instance, a client might receive an
EncryptedExtensions message prior to receiving a ServerHello. Because it
cannot decrypt the EncryptedExtensions, it cannot safely acknowledge it
(as it might be damaged). If the client does not send an ACK, the server
will eventually retransmit its first flight, but this might take far
longer than the actual round trip time between client and server. Having
the client send an empty ACK shortcuts this
process.[¶](#section-7.1-8){.pilcrow}
:::
:::

::: {#receiving-acks}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Receiving ACKs](#name-receiving-acks){.section-name .selfRef} {#name-receiving-acks}

When an implementation receives an ACK, it [SHOULD]{.bcp14} record that
the messages or message fragments sent in the records being ACKed were
received and omit them from any future retransmissions. Upon receipt of
an ACK that leaves it with only some messages from a flight having been
acknowledged, an implementation [SHOULD]{.bcp14} retransmit the
unacknowledged messages or fragments. Note that this requires
implementations to track which messages appear in which records. Once
all the messages in a flight have been acknowledged, the implementation
[MUST]{.bcp14} cancel all retransmissions of that flight.
Implementations [MUST]{.bcp14} treat a record as having been
acknowledged if it appears in any ACK; this prevents spurious
retransmission in cases where a flight is very large and the receiver is
forced to elide acknowledgements for records which have already been
ACKed. As noted above, the receipt of any record responding to a given
flight [MUST]{.bcp14} be taken as an implicit acknowledgement for the
entire flight to which it is responding.[¶](#section-7.2-1){.pilcrow}
:::
:::

::: {#design-rationale}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Design Rationale](#name-design-rationale){.section-name .selfRef} {#name-design-rationale}

ACK messages are used in two circumstances,
namely:[¶](#section-7.3-1){.pilcrow}

-   [On sign of disruption, or lack of progress;
    and[¶](#section-7.3-2.1){.pilcrow}]{#section-7.3-2.1}
-   [To indicate complete receipt of the last flight in a
    handshake.[¶](#section-7.3-2.2){.pilcrow}]{#section-7.3-2.2}

In the first case, the use of the ACK message is optional, because the
peer will retransmit in any case and therefore the ACK just allows for
selective or early retransmission, as opposed to the timeout-based whole
flight retransmission in previous versions of DTLS. When DTLS 1.3 is
used in deployments with lossy networks, such as low-power, long-range
radio networks as well as low-power mesh networks, the use of ACKs is
recommended.[¶](#section-7.3-3){.pilcrow}

The use of the ACK for the second case is mandatory for the proper
functioning of the protocol. For instance, the ACK message sent by the
client in [Figure 13](#dtls-msg-epoch){.xref} acknowledges receipt and
processing of Record 4 (containing the NewSessionTicket message), and if
it is not sent, the server will continue retransmission of the
NewSessionTicket indefinitely until its maximum retransmission count is
reached.[¶](#section-7.3-4){.pilcrow}
:::
:::
:::
:::

::: {#key-updates}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Key Updates](#name-key-updates){.section-name .selfRef} {#name-key-updates}

As with TLS 1.3, DTLS 1.3 implementations send a KeyUpdate message to
indicate that they are updating their sending keys. As with other
handshake messages with no built-in response, KeyUpdates [MUST]{.bcp14}
be acknowledged. In order to facilitate epoch reconstruction ([Section
4.2.2](#reconstructing){.xref}), implementations [MUST NOT]{.bcp14} send
records with the new keys or send a new KeyUpdate until the previous
KeyUpdate has been acknowledged (this avoids having too many epochs in
active use).[¶](#section-8-1){.pilcrow}

Due to loss and/or reordering, DTLS 1.3 implementations may receive a
record with an older epoch than the current one (the requirements above
preclude receiving a newer record). They [SHOULD]{.bcp14} attempt to
process those records with that epoch (see [Section
4.2.2](#reconstructing){.xref} for information on determining the
correct epoch) but [MAY]{.bcp14} opt to discard such out-of-epoch
records.[¶](#section-8-2){.pilcrow}

Due to the possibility of an ACK message for a KeyUpdate being lost and
thereby preventing the sender of the KeyUpdate from updating its keying
material, receivers [MUST]{.bcp14} retain the pre-update keying material
until receipt and successful decryption of a message using the new
keys.[¶](#section-8-3){.pilcrow}

[Figure 14](#dtls-key-update){.xref} shows an example exchange
illustrating that successful ACK processing updates the keys of the
KeyUpdate message sender, which is reflected in the change of epoch
values.[¶](#section-8-4){.pilcrow}

[]{#name-example-dtls-key-update}

::: {#dtls-key-update}
::: {#section-8-5.1 .alignLeft .art-text .artwork}
    Client                                             Server

          /-------------------------------------------\
         |                                             |
         |             Initial Handshake               |
          \-------------------------------------------/


     [Application Data]         -------->
     (epoch=3)

                                <--------      [Application Data]
                                                        (epoch=3)

          /-------------------------------------------\
         |                                             |
         |              Some time later ...            |
          \-------------------------------------------/


     [Application Data]         -------->
     (epoch=3)


     [KeyUpdate]
     (+ update_requested        -------->
     (epoch 3)


                                <--------      [Application Data]
                                                        (epoch=3)


                                                            [ACK]
                                <--------               (epoch=3)


     [Application Data]
     (epoch=4)                  -------->



                                <--------             [KeyUpdate]
                                                        (epoch=3)


     [ACK]                      -------->
     (epoch=4)


                                <--------      [Application Data]
                                                        (epoch=4)
:::

[Figure 14](#figure-14){.selfRef}: [Example DTLS Key
Update](#name-example-dtls-key-update){.selfRef}
:::

With a 128-bit key as in AES-128, rekeying 2\^64 times has a high
probability of key reuse within a given connection. Note that even if
the key repeats, the IV is also independently generated. In order to
provide an extra margin of security, sending implementations [MUST
NOT]{.bcp14} allow the epoch to exceed 2\^48-1. In order to allow this
value to be changed later, receiving implementations [MUST NOT]{.bcp14}
enforce this rule. If a sending implementation receives a KeyUpdate with
request_update set to \"update_requested\", it [MUST NOT]{.bcp14} send
its own KeyUpdate if that would cause it to exceed these limits and
[SHOULD]{.bcp14} instead ignore the \"update_requested\" flag. Note:
this overrides the requirement in TLS 1.3 to always send a KeyUpdate in
response to \"update_requested\".[¶](#section-8-6){.pilcrow}
:::
:::

::: {#connection-id-updates}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Connection ID Updates](#name-connection-id-updates){.section-name .selfRef} {#name-connection-id-updates}

If the client and server have negotiated the \"connection_id\" extension
\[[RFC9146](#RFC9146){.xref}\], either side can send a new CID that it
wishes the other side to use in a NewConnectionId
message.[¶](#section-9-1){.pilcrow}

::: {#section-9-2}
``` {.lang-tls-presentation .sourcecode}
    enum {
        cid_immediate(0), cid_spare(1), (255)
    } ConnectionIdUsage;

    opaque ConnectionId<0..2^8-1>;

    struct {
        ConnectionId cids<0..2^16-1>;
        ConnectionIdUsage usage;
    } NewConnectionId;
```

[¶](#section-9-2){.pilcrow}
:::

[]{.break}

cids:
:   Indicates the set of CIDs that the sender wishes the peer to
    use.[¶](#section-9-3.2){.pilcrow}
:   

usage:
:   Indicates whether the new CIDs should be used immediately or are
    spare. If usage is set to \"cid_immediate\", then one of the new
    CIDs [MUST]{.bcp14} be used immediately for all future records. If
    it is set to \"cid_spare\", then either an existing or new CID
    [MAY]{.bcp14} be used.[¶](#section-9-3.4){.pilcrow}
:   

Endpoints [SHOULD]{.bcp14} use receiver-provided CIDs in the order they
were provided. Implementations which receive more spare CIDs than they
wish to maintain [MAY]{.bcp14} simply discard any extra CIDs. Endpoints
[MUST NOT]{.bcp14} have more than one NewConnectionId message
outstanding.[¶](#section-9-4){.pilcrow}

Implementations which either did not negotiate the \"connection_id\"
extension or which have negotiated receiving an empty CID [MUST
NOT]{.bcp14} send NewConnectionId. Implementations [MUST NOT]{.bcp14}
send RequestConnectionId when sending an empty Connection ID.
Implementations which detect a violation of these rules [MUST]{.bcp14}
terminate the connection with an \"unexpected_message\"
alert.[¶](#section-9-5){.pilcrow}

Implementations [SHOULD]{.bcp14} use a new CID whenever sending on a new
path and [SHOULD]{.bcp14} request new CIDs for this purpose if path
changes are anticipated.[¶](#section-9-6){.pilcrow}

::: {#section-9-7}
``` {.lang-tls-presentation .sourcecode}
    struct {
      uint8 num_cids;
    } RequestConnectionId;
```

[¶](#section-9-7){.pilcrow}
:::

[]{.break}

num_cids:
:   The number of CIDs desired.[¶](#section-9-8.2){.pilcrow}
:   

Endpoints [SHOULD]{.bcp14} respond to RequestConnectionId by sending a
NewConnectionId with usage \"cid_spare\" containing num_cids CIDs as
soon as possible. Endpoints [MUST NOT]{.bcp14} send a
RequestConnectionId message when an existing request is still
unfulfilled; this implies that endpoints need to request new CIDs well
in advance. An endpoint [MAY]{.bcp14} handle requests which it considers
excessive by responding with a NewConnectionId message containing fewer
than num_cids CIDs, including no CIDs at all. Endpoints [MAY]{.bcp14}
handle an excessive number of RequestConnectionId messages by
terminating the connection using a \"too_many_cids_requested\" (alert
number 52) alert.[¶](#section-9-9){.pilcrow}

Endpoints [MUST NOT]{.bcp14} send either of these messages if they did
not negotiate a CID. If an implementation receives these messages when
CIDs were not negotiated, it [MUST]{.bcp14} abort the connection with an
\"unexpected_message\" alert.[¶](#section-9-10){.pilcrow}

::: {#connection-id-example}
::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Connection ID Example](#name-connection-id-example){.section-name .selfRef} {#name-connection-id-example}

Below is an example exchange for DTLS 1.3 using a single CID in each
direction.[¶](#section-9.1-1){.pilcrow}

Note: The \"connection_id\" extension, which is used in ClientHello and
ServerHello messages, is defined in
\[[RFC9146](#RFC9146){.xref}\].[¶](#section-9.1-2){.pilcrow}

[]{#name-example-dtls-13-exchange-wi}

::: {#dtls-example}
::: {#section-9.1-3.1 .alignLeft .art-text .artwork}
    Client                                             Server
    ------                                             ------

    ClientHello
    (connection_id=5)
                                -------->


                                <--------       HelloRetryRequest
                                                         (cookie)

    ClientHello                 -------->
    (connection_id=5)
      + cookie

                                <--------             ServerHello
                                              (connection_id=100)
                                              EncryptedExtensions
                                                          (cid=5)
                                                      Certificate
                                                          (cid=5)
                                                CertificateVerify
                                                          (cid=5)
                                                         Finished
                                                          (cid=5)

    Certificate                -------->
    (cid=100)
    CertificateVerify
    (cid=100)
    Finished
    (cid=100)
                               <--------                      ACK
                                                          (cid=5)

    Application Data           ========>
    (cid=100)
                               <========         Application Data
                                                          (cid=5)
:::

[Figure 15](#figure-15){.selfRef}: [Example DTLS 1.3 Exchange with
CIDs](#name-example-dtls-13-exchange-wi){.selfRef}
:::

If no CID is negotiated, then the receiver [MUST]{.bcp14} reject any
records it receives that contain a CID.[¶](#section-9.1-4){.pilcrow}
:::
:::
:::
:::

::: {#application-data-protocol}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Application Data Protocol](#name-application-data-protocol){.section-name .selfRef} {#name-application-data-protocol}

Application data messages are carried by the record layer and are split
into records and encrypted based on the current connection state. The
messages are treated as transparent data to the record
layer.[¶](#section-10-1){.pilcrow}
:::
:::

::: {#security-considerations}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

Security issues are discussed primarily in
\[[TLS13](#RFC8446){.xref}\].[¶](#section-11-1){.pilcrow}

The primary additional security consideration raised by DTLS is that of
denial of service by excessive resource consumption. DTLS includes a
cookie exchange designed to protect against denial of service. However,
implementations that do not use this cookie exchange are still
vulnerable to DoS. In particular, DTLS servers that do not use the
cookie exchange may be used as attack amplifiers even if they themselves
are not experiencing DoS. Therefore, DTLS servers [SHOULD]{.bcp14} use
the cookie exchange unless there is good reason to believe that
amplification is not a threat in their environment. Clients
[MUST]{.bcp14} be prepared to do a cookie exchange with every
handshake.[¶](#section-11-2){.pilcrow}

Some key properties required of the cookie for the cookie-exchange
mechanism to be functional are described in [Section
3.3](https://www.rfc-editor.org/rfc/rfc2522#section-3.3){.relref} of
\[[RFC2522](#RFC2522){.xref}\]:[¶](#section-11-3){.pilcrow}

-   [The cookie [MUST]{.bcp14} depend on the client\'s
    address.[¶](#section-11-4.1){.pilcrow}]{#section-11-4.1}
-   [It [MUST NOT]{.bcp14} be possible for anyone other than the issuing
    entity to generate cookies that are accepted as valid by that
    entity. This typically entails an integrity check based on a secret
    key.[¶](#section-11-4.2){.pilcrow}]{#section-11-4.2}
-   [Cookie generation and verification are triggered by unauthenticated
    parties, and as such their resource consumption needs to be
    restrained in order to avoid having the cookie-exchange mechanism
    itself serve as a DoS
    vector.[¶](#section-11-4.3){.pilcrow}]{#section-11-4.3}

Although the cookie must allow the server to produce the right handshake
transcript, it [SHOULD]{.bcp14} be constructed so that knowledge of the
cookie is insufficient to reproduce the ClientHello contents. Otherwise,
this may create problems with future extensions such as Encrypted Client
Hello \[[TLS-ECH](#TLS-ECH){.xref}\].[¶](#section-11-5){.pilcrow}

When cookies are generated using a keyed authentication mechanism, it
should be possible to rotate the associated secret key, so that
temporary compromise of the key does not permanently compromise the
integrity of the cookie-exchange mechanism. Though this secret is not as
high-value as, e.g., a session-ticket-encryption key, rotating the
cookie-generation key on a similar timescale would ensure that the key
rotation functionality is exercised regularly and thus in working
order.[¶](#section-11-6){.pilcrow}

The cookie exchange provides address validation during the initial
handshake. DTLS with Connection IDs allows for endpoint addresses to
change during the association; any such updated addresses are not
covered by the cookie exchange during the handshake. DTLS
implementations [MUST NOT]{.bcp14} update the address they send to in
response to packets from a different address unless they first perform
some reachability test; no such test is defined in this specification
and a future specification would need to specify a complete procedure
for how and when to update addresses. Even with such a test, an active
on-path adversary can also black-hole traffic or create a reflection
attack against third parties because a DTLS peer has no means to
distinguish a genuine address update event (for example, due to a NAT
rebinding) from one that is malicious. This attack is of concern when
there is a large asymmetry of request/response message
sizes.[¶](#section-11-7){.pilcrow}

With the exception of order protection and non-replayability, the
security guarantees for DTLS 1.3 are the same as TLS 1.3. While TLS
always provides order protection and non-replayability, DTLS does not
provide order protection and may not provide replay
protection.[¶](#section-11-8){.pilcrow}

Unlike TLS implementations, DTLS implementations [SHOULD NOT]{.bcp14}
respond to invalid records by terminating the
connection.[¶](#section-11-9){.pilcrow}

TLS 1.3 requires replay protection for 0-RTT data (or rather, for
connections that use 0-RTT data; see [Section
8](https://www.rfc-editor.org/rfc/rfc8446#section-8){.relref} of
\[[TLS13](#RFC8446){.xref}\]). DTLS provides an optional per-record
replay-protection mechanism, since datagram protocols are inherently
subject to message reordering and replay. These two replay-protection
mechanisms are orthogonal, and neither mechanism meets the requirements
for the other.[¶](#section-11-10){.pilcrow}

DTLS 1.3\'s handshake transcript does not include the new DTLS fields,
which makes it have the same format as TLS 1.3. However, the DTLS 1.3
and TLS 1.3 transcripts are disjoint because they use different version
numbers. Additionally, the DTLS 1.3 key schedule uses a different label
and so will produce different keys for the same
transcript.[¶](#section-11-11){.pilcrow}

The security and privacy properties of the CID for DTLS 1.3 build on top
of what is described for DTLS 1.2 in \[[RFC9146](#RFC9146){.xref}\].
There are, however, several differences:[¶](#section-11-12){.pilcrow}

-   [In both versions of DTLS, extension negotiation is used to agree on
    the use of the CID feature and the CID values. In both versions, the
    CID is carried in the DTLS record header (if negotiated). However,
    the way the CID is included in the record header differs between the
    two versions.[¶](#section-11-13.1){.pilcrow}]{#section-11-13.1}
-   [The use of the post-handshake message allows the client and the
    server to update their CIDs, and those values are exchanged with
    confidentiality
    protection.[¶](#section-11-13.2){.pilcrow}]{#section-11-13.2}
-   [The ability to use multiple CIDs allows for improved privacy
    properties in multihomed scenarios. When only a single CID is in use
    on multiple paths from such a host, an adversary can correlate the
    communication interaction across paths, which adds further privacy
    concerns. In order to prevent this, implementations [SHOULD]{.bcp14}
    attempt to use fresh CIDs whenever they change local addresses or
    ports (though this is not always possible to detect). The
    RequestConnectionId message can be used by a peer to ask for new
    CIDs to ensure that a pool of suitable CIDs is
    available.[¶](#section-11-13.3){.pilcrow}]{#section-11-13.3}
-   [The mechanism for encrypting sequence numbers ([Section
    4.2.3](#rne){.xref}) prevents trivial tracking by on-path
    adversaries that attempt to correlate the pattern of sequence
    numbers received on different paths; such tracking could occur even
    when different CIDs are used on each path, in the absence of
    sequence number encryption. Switching CIDs based on certain events,
    or even regularly, helps against tracking by on-path adversaries.
    Note that sequence number encryption is used for all encrypted DTLS
    1.3 records irrespective of whether a CID is used or not. Unlike the
    sequence number, the epoch is not encrypted because it acts as a key
    identifier, which may improve correlation of packets from a single
    connection across different network
    paths.[¶](#section-11-13.4){.pilcrow}]{#section-11-13.4}
-   [DTLS 1.3 encrypts handshake messages much earlier than in previous
    DTLS versions. Therefore, less information identifying the DTLS
    client, such as the client certificate, is available to an on-path
    adversary.[¶](#section-11-13.5){.pilcrow}]{#section-11-13.5}
:::
:::

::: {#changes-since-dtls-12}
::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [Changes since DTLS 1.2](#name-changes-since-dtls-12){.section-name .selfRef} {#name-changes-since-dtls-12}

Since TLS 1.3 introduces a large number of changes with respect to TLS
1.2, the list of changes from DTLS 1.2 to DTLS 1.3 is equally large. For
this reason, this section focuses on the most important changes
only.[¶](#section-12-1){.pilcrow}

-   [New handshake pattern, which leads to a shorter message
    exchange.[¶](#section-12-2.1){.pilcrow}]{#section-12-2.1}
-   [Only AEAD ciphers are supported. Additional data calculation has
    been simplified.[¶](#section-12-2.2){.pilcrow}]{#section-12-2.2}
-   [Removed support for weaker and older cryptographic
    algorithms.[¶](#section-12-2.3){.pilcrow}]{#section-12-2.3}
-   [HelloRetryRequest of TLS 1.3 used instead of
    HelloVerifyRequest.[¶](#section-12-2.4){.pilcrow}]{#section-12-2.4}
-   [More flexible cipher suite
    negotiation.[¶](#section-12-2.5){.pilcrow}]{#section-12-2.5}
-   [New session resumption
    mechanism.[¶](#section-12-2.6){.pilcrow}]{#section-12-2.6}
-   [PSK authentication
    redefined.[¶](#section-12-2.7){.pilcrow}]{#section-12-2.7}
-   [New key derivation hierarchy utilizing a new key derivation
    construct.[¶](#section-12-2.8){.pilcrow}]{#section-12-2.8}
-   [Improved version
    negotiation.[¶](#section-12-2.9){.pilcrow}]{#section-12-2.9}
-   [Optimized record layer encoding and thereby its
    size.[¶](#section-12-2.10){.pilcrow}]{#section-12-2.10}
-   [Added CID
    functionality.[¶](#section-12-2.11){.pilcrow}]{#section-12-2.11}
-   [Sequence numbers are
    encrypted.[¶](#section-12-2.12){.pilcrow}]{#section-12-2.12}
:::
:::

::: {#updates-affecting-dtls-12}
::: {#section-13 .section}
## [13.](#section-13){.section-number .selfRef} [Updates Affecting DTLS 1.2](#name-updates-affecting-dtls-12){.section-name .selfRef} {#name-updates-affecting-dtls-12}

This document defines several changes that optionally affect
implementations of DTLS 1.2, including those which do not also support
DTLS 1.3.[¶](#section-13-1){.pilcrow}

-   [A version downgrade protection mechanism as described in
    \[[TLS13](#RFC8446){.xref}\], [Section
    4.1.3](https://www.rfc-editor.org/rfc/rfc8446#section-4.1.3){.relref}
    and applying to DTLS as described in [Section
    5.3](#clienthello-message){.xref}.[¶](#section-13-2.1){.pilcrow}]{#section-13-2.1}
-   [The updates described in \[[TLS13](#RFC8446){.xref}\], [Section
    1.3](https://www.rfc-editor.org/rfc/rfc8446#section-1.3){.relref}.[¶](#section-13-2.2){.pilcrow}]{#section-13-2.2}
-   [The new compliance requirements described in
    \[[TLS13](#RFC8446){.xref}\], [Section
    9.3](https://www.rfc-editor.org/rfc/rfc8446#section-9.3){.relref}.[¶](#section-13-2.3){.pilcrow}]{#section-13-2.3}
:::
:::

::: {#iana-considerations}
::: {#section-14 .section}
## [14.](#section-14){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

IANA has allocated the content type value 26 in the \"TLS ContentType\"
registry for the ACK message, defined in [Section 7](#ack-msg){.xref}.
The value for the \"DTLS-OK\" column is \"Y\". IANA has reserved the
content type range 32-63 so that content types in this range are not
allocated.[¶](#section-14-1){.pilcrow}

IANA has allocated value 52 for the \"too_many_cids_requested\" alert in
the \"TLS Alerts\" registry. The value for the \"DTLS-OK\" column is
\"Y\".[¶](#section-14-2){.pilcrow}

IANA has allocated two values in the \"TLS HandshakeType\" registry,
defined in \[[TLS13](#RFC8446){.xref}\], for request_connection_id (9)
and new_connection_id (10), as defined in this document. The value for
the \"DTLS-OK\" column is \"Y\".[¶](#section-14-3){.pilcrow}

IANA has added this RFC as a reference to the \"TLS Cipher Suites\"
registry along with the following Note:[¶](#section-14-4){.pilcrow}

> Any TLS cipher suite that is specified for use with DTLS
> [MUST]{.bcp14} define limits on the use of the associated AEAD
> function that preserves margins for both confidentiality and
> integrity, as specified in [Section 4.5.3](#aead-limits){.xref} of RFC
> 9147.[¶](#section-14-5){.pilcrow}
:::
:::

::: {#section-15 .section}
## [15.](#section-15){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-15.1 .section}
### [15.1.](#section-15.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[CHACHA\]
:   [Nir, Y.]{.refAuthor} and [A. Langley]{.refAuthor}, [\"ChaCha20 and
    Poly1305 for IETF Protocols\"]{.refTitle}, [RFC 8439]{.seriesInfo},
    [DOI 10.17487/RFC8439]{.seriesInfo}, June 2018,
    \<<https://www.rfc-editor.org/info/rfc8439>\>.
:   

\[RFC0768\]
:   [Postel, J.]{.refAuthor}, [\"User Datagram Protocol\"]{.refTitle},
    [STD 6]{.seriesInfo}, [RFC 768]{.seriesInfo}, [DOI
    10.17487/RFC0768]{.seriesInfo}, August 1980,
    \<<https://www.rfc-editor.org/info/rfc768>\>.
:   

\[RFC0793\]
:   [Postel, J.]{.refAuthor}, [\"Transmission Control
    Protocol\"]{.refTitle}, [STD 7]{.seriesInfo}, [RFC
    793]{.seriesInfo}, [DOI 10.17487/RFC0793]{.seriesInfo}, September
    1981, \<<https://www.rfc-editor.org/info/rfc793>\>.
:   

\[RFC1191\]
:   [Mogul, J.]{.refAuthor} and [S. Deering]{.refAuthor}, [\"Path MTU
    discovery\"]{.refTitle}, [RFC 1191]{.seriesInfo}, [DOI
    10.17487/RFC1191]{.seriesInfo}, November 1990,
    \<<https://www.rfc-editor.org/info/rfc1191>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC4443\]
:   [Conta, A.]{.refAuthor}, [Deering, S.]{.refAuthor}, and [M. Gupta,
    Ed.]{.refAuthor}, [\"Internet Control Message Protocol (ICMPv6) for
    the Internet Protocol Version 6 (IPv6) Specification\"]{.refTitle},
    [STD 89]{.seriesInfo}, [RFC 4443]{.seriesInfo}, [DOI
    10.17487/RFC4443]{.seriesInfo}, March 2006,
    \<<https://www.rfc-editor.org/info/rfc4443>\>.
:   

\[RFC4821\]
:   [Mathis, M.]{.refAuthor} and [J. Heffner]{.refAuthor},
    [\"Packetization Layer Path MTU Discovery\"]{.refTitle}, [RFC
    4821]{.seriesInfo}, [DOI 10.17487/RFC4821]{.seriesInfo}, March 2007,
    \<<https://www.rfc-editor.org/info/rfc4821>\>.
:   

\[RFC6298\]
:   [Paxson, V.]{.refAuthor}, [Allman, M.]{.refAuthor},
    [Chu, J.]{.refAuthor}, and [M. Sargent]{.refAuthor}, [\"Computing
    TCP\'s Retransmission Timer\"]{.refTitle}, [RFC 6298]{.seriesInfo},
    [DOI 10.17487/RFC6298]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6298>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC9146\]
:   [Rescorla, E., Ed.]{.refAuthor}, [Tschofenig, H., Ed.]{.refAuthor},
    [Fossati, T.]{.refAuthor}, and [A. Kraus]{.refAuthor}, [\"Connection
    Identifier for DTLS 1.2\"]{.refTitle}, [RFC 9146]{.seriesInfo}, [DOI
    10.17487/RFC9146]{.seriesInfo}, March 2022,
    \<<https://www.rfc-editor.org/info/rfc9146>\>.
:   

\[TLS13\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   
:::

::: {#section-15.2 .section}
### [15.2.](#section-15.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[AEAD-LIMITS\]
:   [Günther, F.]{.refAuthor}, [Thomson, M.]{.refAuthor}, and [C. A.
    Wood]{.refAuthor}, [\"Usage Limits on AEAD Algorithms\"]{.refTitle},
    [Work in Progress]{.refContent}, [Internet-Draft,
    draft-irtf-cfrg-aead-limits-04]{.seriesInfo}, 7 March 2022,
    \<<https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-aead-limits-04>\>.
:   

\[AEBounds\]
:   [Luykx, A.]{.refAuthor} and [K. Paterson]{.refAuthor}, [\"Limits on
    Authenticated Encryption Use in TLS\"]{.refTitle}, 28 August 2017,
    \<<https://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>\>.
:   

\[CCM-ANALYSIS\]
:   [Jonsson, J.]{.refAuthor}, [\"On the Security of CTR +
    CBC-MAC\"]{.refTitle}, [Selected Areas in Cryptography pp.
    76-93]{.refContent}, [DOI 10.1007/3-540-36492-7_7]{.seriesInfo},
    February 2003, \<<https://doi.org/10.1007/3-540-36492-7_7>\>.
:   

\[DEPRECATE\]
:   [Moriarty, K.]{.refAuthor} and [S. Farrell]{.refAuthor},
    [\"Deprecating TLS 1.0 and TLS 1.1\"]{.refTitle}, [BCP
    195]{.seriesInfo}, [RFC 8996]{.seriesInfo}, [DOI
    10.17487/RFC8996]{.seriesInfo}, March 2021,
    \<<https://www.rfc-editor.org/info/rfc8996>\>.
:   

\[IOT-PROFILE\]
:   [Tschofenig, H.]{.refAuthor} and [T. Fossati]{.refAuthor},
    [\"TLS/DTLS 1.3 Profiles for the Internet of Things\"]{.refTitle},
    [Work in Progress]{.refContent}, [Internet-Draft,
    draft-ietf-uta-tls13-iot-profile-04]{.seriesInfo}, 7 March 2022,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-uta-tls13-iot-profile-04>\>.
:   

\[RFC2522\]
:   [Karn, P.]{.refAuthor} and [W. Simpson]{.refAuthor}, [\"Photuris:
    Session-Key Management Protocol\"]{.refTitle}, [RFC
    2522]{.seriesInfo}, [DOI 10.17487/RFC2522]{.seriesInfo}, March 1999,
    \<<https://www.rfc-editor.org/info/rfc2522>\>.
:   

\[RFC4303\]
:   [Kent, S.]{.refAuthor}, [\"IP Encapsulating Security Payload
    (ESP)\"]{.refTitle}, [RFC 4303]{.seriesInfo}, [DOI
    10.17487/RFC4303]{.seriesInfo}, December 2005,
    \<<https://www.rfc-editor.org/info/rfc4303>\>.
:   

\[RFC4340\]
:   [Kohler, E.]{.refAuthor}, [Handley, M.]{.refAuthor}, and [S.
    Floyd]{.refAuthor}, [\"Datagram Congestion Control Protocol
    (DCCP)\"]{.refTitle}, [RFC 4340]{.seriesInfo}, [DOI
    10.17487/RFC4340]{.seriesInfo}, March 2006,
    \<<https://www.rfc-editor.org/info/rfc4340>\>.
:   

\[RFC4346\]
:   [Dierks, T.]{.refAuthor} and [E. Rescorla]{.refAuthor}, [\"The
    Transport Layer Security (TLS) Protocol Version 1.1\"]{.refTitle},
    [RFC 4346]{.seriesInfo}, [DOI 10.17487/RFC4346]{.seriesInfo}, April
    2006, \<<https://www.rfc-editor.org/info/rfc4346>\>.
:   

\[RFC4347\]
:   [Rescorla, E.]{.refAuthor} and [N. Modadugu]{.refAuthor},
    [\"Datagram Transport Layer Security\"]{.refTitle}, [RFC
    4347]{.seriesInfo}, [DOI 10.17487/RFC4347]{.seriesInfo}, April 2006,
    \<<https://www.rfc-editor.org/info/rfc4347>\>.
:   

\[RFC4960\]
:   [Stewart, R., Ed.]{.refAuthor}, [\"Stream Control Transmission
    Protocol\"]{.refTitle}, [RFC 4960]{.seriesInfo}, [DOI
    10.17487/RFC4960]{.seriesInfo}, September 2007,
    \<<https://www.rfc-editor.org/info/rfc4960>\>.
:   

\[RFC5238\]
:   [Phelan, T.]{.refAuthor}, [\"Datagram Transport Layer Security
    (DTLS) over the Datagram Congestion Control Protocol
    (DCCP)\"]{.refTitle}, [RFC 5238]{.seriesInfo}, [DOI
    10.17487/RFC5238]{.seriesInfo}, May 2008,
    \<<https://www.rfc-editor.org/info/rfc5238>\>.
:   

\[RFC5246\]
:   [Dierks, T.]{.refAuthor} and [E. Rescorla]{.refAuthor}, [\"The
    Transport Layer Security (TLS) Protocol Version 1.2\"]{.refTitle},
    [RFC 5246]{.seriesInfo}, [DOI 10.17487/RFC5246]{.seriesInfo}, August
    2008, \<<https://www.rfc-editor.org/info/rfc5246>\>.
:   

\[RFC5763\]
:   [Fischl, J.]{.refAuthor}, [Tschofenig, H.]{.refAuthor}, and [E.
    Rescorla]{.refAuthor}, [\"Framework for Establishing a Secure
    Real-time Transport Protocol (SRTP) Security Context Using Datagram
    Transport Layer Security (DTLS)\"]{.refTitle}, [RFC
    5763]{.seriesInfo}, [DOI 10.17487/RFC5763]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5763>\>.
:   

\[RFC5764\]
:   [McGrew, D.]{.refAuthor} and [E. Rescorla]{.refAuthor}, [\"Datagram
    Transport Layer Security (DTLS) Extension to Establish Keys for the
    Secure Real-time Transport Protocol (SRTP)\"]{.refTitle}, [RFC
    5764]{.seriesInfo}, [DOI 10.17487/RFC5764]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5764>\>.
:   

\[RFC6066\]
:   [Eastlake 3rd, D.]{.refAuthor}, [\"Transport Layer Security (TLS)
    Extensions: Extension Definitions\"]{.refTitle}, [RFC
    6066]{.seriesInfo}, [DOI 10.17487/RFC6066]{.seriesInfo}, January
    2011, \<<https://www.rfc-editor.org/info/rfc6066>\>.
:   

\[RFC6347\]
:   [Rescorla, E.]{.refAuthor} and [N. Modadugu]{.refAuthor},
    [\"Datagram Transport Layer Security Version 1.2\"]{.refTitle}, [RFC
    6347]{.seriesInfo}, [DOI 10.17487/RFC6347]{.seriesInfo}, January
    2012, \<<https://www.rfc-editor.org/info/rfc6347>\>.
:   

\[RFC7296\]
:   [Kaufman, C.]{.refAuthor}, [Hoffman, P.]{.refAuthor},
    [Nir, Y.]{.refAuthor}, [Eronen, P.]{.refAuthor}, and [T.
    Kivinen]{.refAuthor}, [\"Internet Key Exchange Protocol Version 2
    (IKEv2)\"]{.refTitle}, [STD 79]{.seriesInfo}, [RFC
    7296]{.seriesInfo}, [DOI 10.17487/RFC7296]{.seriesInfo}, October
    2014, \<<https://www.rfc-editor.org/info/rfc7296>\>.
:   

\[RFC7525\]
:   [Sheffer, Y.]{.refAuthor}, [Holz, R.]{.refAuthor}, and [P.
    Saint-Andre]{.refAuthor}, [\"Recommendations for Secure Use of
    Transport Layer Security (TLS) and Datagram Transport Layer Security
    (DTLS)\"]{.refTitle}, [BCP 195]{.seriesInfo}, [RFC
    7525]{.seriesInfo}, [DOI 10.17487/RFC7525]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7525>\>.
:   

\[RFC7924\]
:   [Santesson, S.]{.refAuthor} and [H. Tschofenig]{.refAuthor},
    [\"Transport Layer Security (TLS) Cached Information
    Extension\"]{.refTitle}, [RFC 7924]{.seriesInfo}, [DOI
    10.17487/RFC7924]{.seriesInfo}, July 2016,
    \<<https://www.rfc-editor.org/info/rfc7924>\>.
:   

\[RFC7983\]
:   [Petit-Huguenin, M.]{.refAuthor} and [G. Salgueiro]{.refAuthor},
    [\"Multiplexing Scheme Updates for Secure Real-time Transport
    Protocol (SRTP) Extension for Datagram Transport Layer Security
    (DTLS)\"]{.refTitle}, [RFC 7983]{.seriesInfo}, [DOI
    10.17487/RFC7983]{.seriesInfo}, September 2016,
    \<<https://www.rfc-editor.org/info/rfc7983>\>.
:   

\[RFC8201\]
:   [McCann, J.]{.refAuthor}, [Deering, S.]{.refAuthor},
    [Mogul, J.]{.refAuthor}, and [R. Hinden, Ed.]{.refAuthor}, [\"Path
    MTU Discovery for IP version 6\"]{.refTitle}, [STD 87]{.seriesInfo},
    [RFC 8201]{.seriesInfo}, [DOI 10.17487/RFC8201]{.seriesInfo}, July
    2017, \<<https://www.rfc-editor.org/info/rfc8201>\>.
:   

\[RFC8445\]
:   [Keranen, A.]{.refAuthor}, [Holmberg, C.]{.refAuthor}, and [J.
    Rosenberg]{.refAuthor}, [\"Interactive Connectivity Establishment
    (ICE): A Protocol for Network Address Translator (NAT)
    Traversal\"]{.refTitle}, [RFC 8445]{.seriesInfo}, [DOI
    10.17487/RFC8445]{.seriesInfo}, July 2018,
    \<<https://www.rfc-editor.org/info/rfc8445>\>.
:   

\[RFC8879\]
:   [Ghedini, A.]{.refAuthor} and [V. Vasiliev]{.refAuthor}, [\"TLS
    Certificate Compression\"]{.refTitle}, [RFC 8879]{.seriesInfo}, [DOI
    10.17487/RFC8879]{.seriesInfo}, December 2020,
    \<<https://www.rfc-editor.org/info/rfc8879>\>.
:   

\[RFC9000\]
:   [Iyengar, J., Ed.]{.refAuthor} and [M. Thomson, Ed.]{.refAuthor},
    [\"QUIC: A UDP-Based Multiplexed and Secure Transport\"]{.refTitle},
    [RFC 9000]{.seriesInfo}, [DOI 10.17487/RFC9000]{.seriesInfo}, May
    2021, \<<https://www.rfc-editor.org/info/rfc9000>\>.
:   

\[RFC9002\]
:   [Iyengar, J., Ed.]{.refAuthor} and [I. Swett, Ed.]{.refAuthor},
    [\"QUIC Loss Detection and Congestion Control\"]{.refTitle}, [RFC
    9002]{.seriesInfo}, [DOI 10.17487/RFC9002]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc9002>\>.
:   

\[ROBUST\]
:   [Fischlin, M.]{.refAuthor}, [Günther, F.]{.refAuthor}, and [C.
    Janson]{.refAuthor}, [\"Robust Channels: Handling Unreliable
    Networks in the Record Layers of QUIC and DTLS 1.3\"]{.refTitle},
    [received 15 June 2020, last revised 22 February 2021]{.refContent},
    \<<https://eprint.iacr.org/2020/718>\>.
:   

\[TLS-ECH\]
:   [Rescorla, E.]{.refAuthor}, [Oku, K.]{.refAuthor},
    [Sullivan, N.]{.refAuthor}, and [C.A. Wood]{.refAuthor}, [\"TLS
    Encrypted Client Hello\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-tls-esni-14]{.seriesInfo}, 13 February 2022,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-14>\>.
:   
:::
:::

::: {#protocol-data-structures-and-constant-values}
::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [Protocol Data Structures and Constant Values](#name-protocol-data-structures-an){.section-name .selfRef} {#name-protocol-data-structures-an}

This section provides the normative protocol types and constants
definitions.[¶](#appendix-A-1){.pilcrow}

::: {#record-layer}
::: {#appendix-A.1 .section}
### [A.1.](#appendix-A.1){.section-number .selfRef} [Record Layer](#name-record-layer){.section-name .selfRef} {#name-record-layer}

::: {#appendix-A.1-1 .alignLeft .art-text .artwork}
        struct {
            ContentType type;
            ProtocolVersion legacy_record_version;
            uint16 epoch = 0
            uint48 sequence_number;
            uint16 length;
            opaque fragment[DTLSPlaintext.length];
        } DTLSPlaintext;

        struct {
             opaque content[DTLSPlaintext.length];
             ContentType type;
             uint8 zeros[length_of_padding];
        } DTLSInnerPlaintext;

        struct {
            opaque unified_hdr[variable];
            opaque encrypted_record[length];
        } DTLSCiphertext;

        0 1 2 3 4 5 6 7
        +-+-+-+-+-+-+-+-+
        |0|0|1|C|S|L|E E|
        +-+-+-+-+-+-+-+-+
        | Connection ID |   Legend:
        | (if any,      |
        /  length as    /   C   - Connection ID (CID) present
        |  negotiated)  |   S   - Sequence number length
        +-+-+-+-+-+-+-+-+   L   - Length present
        |  8 or 16 bit  |   E   - Epoch
        |Sequence Number|
        +-+-+-+-+-+-+-+-+
        | 16 bit Length |
        | (if present)  |
        +-+-+-+-+-+-+-+-+

        struct {
            uint64 epoch;
            uint64 sequence_number;
        } RecordNumber;

[¶](#appendix-A.1-1){.pilcrow}
:::
:::
:::

::: {#handshake-protocol}
::: {#appendix-A.2 .section}
### [A.2.](#appendix-A.2){.section-number .selfRef} [Handshake Protocol](#name-handshake-protocol){.section-name .selfRef} {#name-handshake-protocol}

::: {#appendix-A.2-1}
``` {.lang-tls-presentation .sourcecode}
    enum {
        hello_request_RESERVED(0),
        client_hello(1),
        server_hello(2),
        hello_verify_request_RESERVED(3),
        new_session_ticket(4),
        end_of_early_data(5),
        hello_retry_request_RESERVED(6),
        encrypted_extensions(8),
        request_connection_id(9),           /* New */
        new_connection_id(10),              /* New */
        certificate(11),
        server_key_exchange_RESERVED(12),
        certificate_request(13),
        server_hello_done_RESERVED(14),
        certificate_verify(15),
        client_key_exchange_RESERVED(16),
        finished(20),
        certificate_url_RESERVED(21),
        certificate_status_RESERVED(22),
        supplemental_data_RESERVED(23),
        key_update(24),
        message_hash(254),
        (255)
    } HandshakeType;

    struct {
        HandshakeType msg_type;    /* handshake type */
        uint24 length;             /* bytes in message */
        uint16 message_seq;        /* DTLS-required field */
        uint24 fragment_offset;    /* DTLS-required field */
        uint24 fragment_length;    /* DTLS-required field */
        select (msg_type) {
            case client_hello:          ClientHello;
            case server_hello:          ServerHello;
            case end_of_early_data:     EndOfEarlyData;
            case encrypted_extensions:  EncryptedExtensions;
            case certificate_request:   CertificateRequest;
            case certificate:           Certificate;
            case certificate_verify:    CertificateVerify;
            case finished:              Finished;
            case new_session_ticket:    NewSessionTicket;
            case key_update:            KeyUpdate;
            case request_connection_id: RequestConnectionId;
            case new_connection_id:     NewConnectionId;
        } body;
    } Handshake;

    uint16 ProtocolVersion;
    opaque Random[32];

    uint8 CipherSuite[2];    /* Cryptographic suite selector */

    struct {
        ProtocolVersion legacy_version = { 254,253 }; // DTLSv1.2
        Random random;
        opaque legacy_session_id<0..32>;
        opaque legacy_cookie<0..2^8-1>;                  // DTLS
        CipherSuite cipher_suites<2..2^16-2>;
        opaque legacy_compression_methods<1..2^8-1>;
        Extension extensions<8..2^16-1>;
    } ClientHello;
```

[¶](#appendix-A.2-1){.pilcrow}
:::
:::
:::

::: {#acks}
::: {#appendix-A.3 .section}
### [A.3.](#appendix-A.3){.section-number .selfRef} [ACKs](#name-acks){.section-name .selfRef} {#name-acks}

::: {#appendix-A.3-1}
``` {.lang-tls-presentation .sourcecode}
    struct {
        RecordNumber record_numbers<0..2^16-1>;
    } ACK;
```

[¶](#appendix-A.3-1){.pilcrow}
:::
:::
:::

::: {#connection-id-management}
::: {#appendix-A.4 .section}
### [A.4.](#appendix-A.4){.section-number .selfRef} [Connection ID Management](#name-connection-id-management){.section-name .selfRef} {#name-connection-id-management}

::: {#appendix-A.4-1}
``` {.lang-tls-presentation .sourcecode}
    enum {
        cid_immediate(0), cid_spare(1), (255)
    } ConnectionIdUsage;

    opaque ConnectionId<0..2^8-1>;

    struct {
        ConnectionId cids<0..2^16-1>;
        ConnectionIdUsage usage;
    } NewConnectionId;

    struct {
      uint8 num_cids;
    } RequestConnectionId;
```

[¶](#appendix-A.4-1){.pilcrow}
:::
:::
:::
:::
:::

::: {#ccm-bounds}
::: {#appendix-B .section}
## [Appendix B.](#appendix-B){.section-number .selfRef} [Analysis of Limits on CCM Usage](#name-analysis-of-limits-on-ccm-u){.section-name .selfRef} {#name-analysis-of-limits-on-ccm-u}

TLS \[[TLS13](#RFC8446){.xref}\] and \[[AEBounds](#AEBounds){.xref}\] do
not specify limits on key usage for AEAD_AES_128_CCM. However, any AEAD
that is used with DTLS requires limits on use that ensure that both
confidentiality and integrity are preserved. This section documents that
analysis for AEAD_AES_128_CCM.[¶](#appendix-B-1){.pilcrow}

\[[CCM-ANALYSIS](#CCM-ANALYSIS){.xref}\] is used as the basis of this
analysis. The results of that analysis are used to derive usage limits
that are based on those chosen in
\[[TLS13](#RFC8446){.xref}\].[¶](#appendix-B-2){.pilcrow}

This analysis uses symbols for multiplication (\*), division (/), and
exponentiation (\^), plus parentheses for establishing precedence. The
following symbols are also used:[¶](#appendix-B-3){.pilcrow}

[]{.break}

t:
:   The size of the authentication tag in bits. For this cipher, t is
    128.[¶](#appendix-B-4.2){.pilcrow}
:   

n:
:   The size of the block function in bits. For this cipher, n is
    128.[¶](#appendix-B-4.4){.pilcrow}
:   

l:
:   The number of blocks in each packet (see
    below).[¶](#appendix-B-4.6){.pilcrow}
:   

q:
:   The number of genuine packets created and protected by endpoints.
    This value is the bound on the number of packets that can be
    protected before updating keys.[¶](#appendix-B-4.8){.pilcrow}
:   

v:
:   The number of forged packets that endpoints will accept. This value
    is the bound on the number of forged packets that an endpoint can
    reject before updating keys.[¶](#appendix-B-4.10){.pilcrow}
:   

The analysis of AEAD_AES_128_CCM relies on a count of the number of
block operations involved in producing each message. For simplicity, and
to match the analysis of other AEAD functions in
\[[AEBounds](#AEBounds){.xref}\], this analysis assumes a packet length
of 2\^10 blocks and a packet size limit of 2\^14
bytes.[¶](#appendix-B-5){.pilcrow}

For AEAD_AES_128_CCM, the total number of block cipher operations is the
sum of: the length of the associated data in blocks, the length of the
ciphertext in blocks, and the length of the plaintext in blocks, plus 1.
In this analysis, this is simplified to a value of twice the maximum
length of a record in blocks (that is, `2l = 2^11`). This simplification
is based on the associated data being limited to one
block.[¶](#appendix-B-6){.pilcrow}

::: {#ccm-confidentiality}
::: {#appendix-B.1 .section}
### [B.1.](#appendix-B.1){.section-number .selfRef} [Confidentiality Limits](#name-confidentiality-limits){.section-name .selfRef} {#name-confidentiality-limits}

For confidentiality, Theorem 2 in
\[[CCM-ANALYSIS](#CCM-ANALYSIS){.xref}\] establishes that an attacker
gains a distinguishing advantage over an ideal pseudorandom permutation
(PRP) of no more than:[¶](#appendix-B.1-1){.pilcrow}

::: {#appendix-B.1-2 .alignLeft .art-text .artwork}
    (2l * q)^2 / 2^n

[¶](#appendix-B.1-2){.pilcrow}
:::

For a target advantage in a single-key setting of 2\^-60, which matches
that used by TLS 1.3, as summarized in
\[[AEAD-LIMITS](#AEAD-LIMITS){.xref}\], this results in the
relation:[¶](#appendix-B.1-3){.pilcrow}

::: {#appendix-B.1-4 .alignLeft .art-text .artwork}
    q <= 2^23

[¶](#appendix-B.1-4){.pilcrow}
:::

That is, endpoints cannot protect more than 2\^23 packets with the same
set of keys without causing an attacker to gain a larger advantage than
the target of 2\^-60.[¶](#appendix-B.1-5){.pilcrow}
:::
:::

::: {#ccm-integrity}
::: {#appendix-B.2 .section}
### [B.2.](#appendix-B.2){.section-number .selfRef} [Integrity Limits](#name-integrity-limits){.section-name .selfRef} {#name-integrity-limits}

For integrity, Theorem 1 in \[[CCM-ANALYSIS](#CCM-ANALYSIS){.xref}\]
establishes that an attacker gains an advantage over an ideal PRP of no
more than:[¶](#appendix-B.2-1){.pilcrow}

::: {#appendix-B.2-2 .alignLeft .art-text .artwork}
    v / 2^t + (2l * (v + q))^2 / 2^n

[¶](#appendix-B.2-2){.pilcrow}
:::

The goal is to limit this advantage to 2\^-57, to match the target in
TLS 1.3, as summarized in \[[AEAD-LIMITS](#AEAD-LIMITS){.xref}\]. As `t`
and `n` are both 128, the first term is negligible relative to the
second, so that term can be removed without a significant effect on the
result. This produces the relation:[¶](#appendix-B.2-3){.pilcrow}

::: {#appendix-B.2-4 .alignLeft .art-text .artwork}
    v + q <= 2^24.5

[¶](#appendix-B.2-4){.pilcrow}
:::

Using the previously established value of 2\^23 for `q` and rounding,
this leads to an upper limit on `v` of 2\^23.5. That is, endpoints
cannot attempt to authenticate more than 2\^23.5 packets with the same
set of keys without causing an attacker to gain a larger advantage than
the target of 2\^-57.[¶](#appendix-B.2-5){.pilcrow}
:::
:::

::: {#ccm-short}
::: {#appendix-B.3 .section}
### [B.3.](#appendix-B.3){.section-number .selfRef} [Limits for AEAD_AES_128_CCM_8](#name-limits-for-aead_aes_128_ccm){.section-name .selfRef} {#name-limits-for-aead_aes_128_ccm}

The TLS_AES_128_CCM_8\_SHA256 cipher suite uses the AEAD_AES_128_CCM_8
function, which uses a short authentication tag (that is,
t=64).[¶](#appendix-B.3-1){.pilcrow}

The confidentiality limits of AEAD_AES_128_CCM_8 are the same as those
for AEAD_AES_128_CCM, as this does not depend on the tag length; see
[Appendix
B.1](#ccm-confidentiality){.xref}.[¶](#appendix-B.3-2){.pilcrow}

The shorter tag length of 64 bits means that the simplification used in
[Appendix B.2](#ccm-integrity){.xref} does not apply to
AEAD_AES_128_CCM_8. If the goal is to preserve the same margins as other
cipher suites, then the limit on forgeries is largely dictated by the
first term of the advantage formula:[¶](#appendix-B.3-3){.pilcrow}

::: {#appendix-B.3-4 .alignLeft .art-text .artwork}
    v <= 2^7

[¶](#appendix-B.3-4){.pilcrow}
:::

As this represents attempts that fail authentication, applying this
limit might be feasible in some environments. However, applying this
limit in an implementation intended for general use exposes connections
to an inexpensive denial-of-service
attack.[¶](#appendix-B.3-5){.pilcrow}

This analysis supports the view that TLS_AES_128_CCM_8\_SHA256 is not
suitable for general use. Specifically, TLS_AES_128_CCM_8\_SHA256 cannot
be used without additional measures to prevent forgery of records, or to
mitigate the effect of forgeries. This might require understanding the
constraints that exist in a particular deployment or application. For
instance, it might be possible to set a different target for the
advantage an attacker gains based on an understanding of the constraints
imposed on a specific usage of DTLS.[¶](#appendix-B.3-6){.pilcrow}
:::
:::
:::
:::

::: {#implementation-pitfalls}
::: {#appendix-C .section}
## [Appendix C.](#appendix-C){.section-number .selfRef} [Implementation Pitfalls](#name-implementation-pitfalls){.section-name .selfRef} {#name-implementation-pitfalls}

In addition to the aspects of TLS that have been a source of
interoperability and security problems ([Appendix
C.3](https://www.rfc-editor.org/rfc/rfc8446#appendix-C.3){.relref} of
\[[TLS13](#RFC8446){.xref}\]), DTLS presents a few new potential sources
of issues, noted here.[¶](#appendix-C-1){.pilcrow}

-   [Do you correctly handle messages received from multiple epochs
    during a key transition? This includes locating the correct key as
    well as performing replay detection, if
    enabled.[¶](#appendix-C-2.1){.pilcrow}]{#appendix-C-2.1}
-   [Do you retransmit handshake messages that are not (implicitly or
    explicitly) acknowledged ([Section
    5.8](#timeout-retransmissions){.xref})?[¶](#appendix-C-2.2){.pilcrow}]{#appendix-C-2.2}
-   [Do you correctly handle handshake message fragments received,
    including when they are out of
    order?[¶](#appendix-C-2.3){.pilcrow}]{#appendix-C-2.3}
-   [Do you correctly handle handshake messages received out of order?
    This may include either buffering or discarding
    them.[¶](#appendix-C-2.4){.pilcrow}]{#appendix-C-2.4}
-   [Do you limit how much data you send to a peer before its address is
    validated?[¶](#appendix-C-2.5){.pilcrow}]{#appendix-C-2.5}
-   [Do you verify that the explicit record length is contained within
    the datagram in which it is
    contained?[¶](#appendix-C-2.6){.pilcrow}]{#appendix-C-2.6}
:::
:::

::: {#contributors}
::: {#appendix-D .section}
## [Contributors](#name-contributors){.section-name .selfRef} {#name-contributors}

Many people have contributed to previous DTLS versions, and they are
acknowledged in prior versions of DTLS specifications or in the
referenced specifications.[¶](#appendix-D-1){.pilcrow}

::: {.left dir="auto"}
[Hanno Becker]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Arm Limited]{.org}
:::

::: email
Email: <Hanno.Becker@arm.com>
:::

::: {.left dir="auto"}
[David Benjamin]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google]{.org}
:::

::: email
Email: <davidben@google.com>
:::

::: {.left dir="auto"}
[Thomas Fossati]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Arm Limited]{.org}
:::

::: email
Email: <thomas.fossati@arm.com>
:::

::: {.left dir="auto"}
[Tobias Gondrom]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Huawei]{.org}
:::

::: email
Email: <tobias.gondrom@gondrom.org>
:::

::: {.left dir="auto"}
[Felix Günther]{.fn .nameRole}
:::

::: {.left dir="auto"}
[ETH Zurich]{.org}
:::

::: email
Email: <mail@felixguenther.info>
:::

::: {.left dir="auto"}
[Benjamin Kaduk]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Akamai Technologies]{.org}
:::

::: email
Email: <kaduk@mit.edu>
:::

::: {.left dir="auto"}
[Ilari Liusvaara]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Independent]{.org}
:::

::: email
Email: <ilariliusvaara@welho.com>
:::

::: {.left dir="auto"}
[Martin Thomson]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Mozilla]{.org}
:::

::: email
Email: <martin.thomson@gmail.com>
:::

::: {.left dir="auto"}
[Christopher A. Wood]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Cloudflare]{.org}
:::

::: email
Email: <caw@heapingbits.net>
:::

::: {.left dir="auto"}
[Yin Xinxing]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Huawei]{.org}
:::

::: email
Email: <yinxinxing@huawei.com>
:::

The sequence number encryption concept is taken from QUIC
\[[RFC9000](#RFC9000){.xref}\]. We would like to thank the authors of
RFC 9000 for their work. [Felix Günther]{.contact-name} and [Martin
Thomson]{.contact-name} contributed the analysis in [Appendix
B](#ccm-bounds){.xref}. We would like to thank [Jonathan
Hammell]{.contact-name}, [Bernard Aboba]{.contact-name}, and [Andy
Cunningham]{.contact-name} for their review
comments.[¶](#appendix-D-2){.pilcrow}

Additionally, we would like to thank the IESG members for their review
comments: [Martin Duke]{.contact-name}, [Erik Kline]{.contact-name},
[Francesca Palombini]{.contact-name}, [Lars Eggert]{.contact-name},
[Zaheduzzaman Sarker]{.contact-name}, [John Scudder]{.contact-name},
[Éric Vyncke]{.contact-name}, [Robert Wilton]{.contact-name}, [Roman
Danyliw]{.contact-name}, [Benjamin Kaduk]{.contact-name}, [Murray
Kucherawy]{.contact-name}, [Martin Vigoureux]{.contact-name}, and
[Alvaro Retana]{.contact-name}.[¶](#appendix-D-3){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-E .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Eric Rescorla]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Mozilla]{.org}
:::

::: email
Email: <ekr@rtfm.com>
:::

::: {.left dir="auto"}
[Hannes Tschofenig]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Arm Limited]{.org}
:::

::: email
Email: <hannes.tschofenig@arm.com>
:::

::: {.left dir="auto"}
[Nagendra Modadugu]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google, Inc.]{.org}
:::

::: email
Email: <nagendra@cs.stanford.edu>
:::
:::
:::
