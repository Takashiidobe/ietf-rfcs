  RFC 8967     MAC Authentication for Babel   January 2021
  ------------ ------------------------------ --------------
  Dô, et al.   Standards Track                \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8967](https://www.rfc-editor.org/rfc/rfc8967){.eref}

Obsoletes:
:   [7298](https://www.rfc-editor.org/rfc/rfc7298){.eref}

Category:
:   Standards Track

Published:
:   January 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    C. Dô
    :::

    ::: org
    IRIF, University of Paris-Diderot
    :::
    :::

    ::: author
    ::: author-name
    W. Kolodziejak
    :::

    ::: org
    IRIF, University of Paris-Diderot
    :::
    :::

    ::: author
    ::: author-name
    J. Chroboczek
    :::

    ::: org
    IRIF, University of Paris-Diderot
    :::
    :::
:::

# RFC 8967 {#rfcnum}

# MAC Authentication for the Babel Routing Protocol {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes a cryptographic authentication mechanism for the
Babel routing protocol that has provisions for replay avoidance. This
document obsoletes RFC 7298.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8967>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Applicability](#name-applicability){.xref}[¶](#section-toc.1-1.1.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.1.2.2}
        [1.2](#section-1.2){.xref}.  [Assumptions and Security
        Properties](#name-assumptions-and-security-pr){.xref}[¶](#section-toc.1-1.1.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.1.2.3}
        [1.3](#section-1.3){.xref}.  [Specification of
        Requirements](#name-specification-of-requiremen){.xref}[¶](#section-toc.1-1.1.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Conceptual Overview of the
    Protocol](#name-conceptual-overview-of-the-){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Data
    Structures](#name-data-structures){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [The Interface
        Table](#name-the-interface-table){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [The Neighbour
        Table](#name-the-neighbour-table){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Protocol
    Operation](#name-protocol-operation){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [MAC
        Computation](#name-mac-computation){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Packet
        Transmission](#name-packet-transmission){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Packet
        Reception](#name-packet-reception){.xref}[¶](#section-toc.1-1.4.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Expiring Per-Neighbour
        State](#name-expiring-per-neighbour-stat){.xref}[¶](#section-toc.1-1.4.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Incremental Deployment and Key
    Rotation](#name-incremental-deployment-and-){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Packet
    Format](#name-packet-format){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [MAC
        TLV](#name-mac-tlv){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [PC
        TLV](#name-pc-tlv){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Challenge Request
        TLV](#name-challenge-request-tlv){.xref}[¶](#section-toc.1-1.6.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [Challenge Reply
        TLV](#name-challenge-reply-tlv){.xref}[¶](#section-toc.1-1.6.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [References](#name-references){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.9.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Informational
        References](#name-informational-references){.xref}[¶](#section-toc.1-1.9.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [](#section-appendix.a){.xref}[Acknowledgments](#name-acknowledgments){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [](#section-appendix.b){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::
:::
:::

::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

By default, the Babel routing protocol \[[RFC8966](#RFC8966){.xref}\]
trusts the information contained in every UDP datagram that it receives
on the Babel port. An attacker can redirect traffic to itself or to a
different node in the network, causing a variety of potential issues. In
particular, an attacker might:[¶](#section-1-1){.pilcrow}

-   [spoof a Babel packet and redirect traffic by announcing a route
    with a smaller metric, a larger sequence number, or a longer
    prefix;[¶](#section-1-2.1){.pilcrow}]{#section-1-2.1}
-   [spoof a malformed packet, which could cause an insufficiently
    robust implementation to crash or interfere with the rest of the
    network;[¶](#section-1-2.2){.pilcrow}]{#section-1-2.2}
-   [replay a previously captured Babel packet, which could cause
    traffic to be redirected or otherwise interfere with the
    network.[¶](#section-1-2.3){.pilcrow}]{#section-1-2.3}

Protecting a Babel network is challenging due to the fact that the Babel
protocol uses both unicast and multicast communication. One possible
approach, used notably by the Babel over Datagram Transport Layer
Security (DTLS) protocol \[[RFC8968](#RFC8968){.xref}\], is to use
unicast communication for all semantically significant communication,
and then use a standard unicast security protocol to protect the Babel
traffic. In this document, we take the opposite approach: we define a
cryptographic extension to the Babel protocol that is able to protect
both unicast and multicast traffic and thus requires very few changes to
the core protocol. This document obsoletes
\[[RFC7298](#RFC7298){.xref}\].[¶](#section-1-3){.pilcrow}

::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Applicability](#name-applicability){.section-name .selfRef} {#name-applicability}

The protocol defined in this document assumes that all interfaces on a
given link are equally trusted and share a small set of symmetric keys
(usually just one, and two during key rotation). The protocol is
inapplicable in situations where asymmetric keying is required, where
the trust relationship is partial, or where large numbers of trusted
keys are provisioned on a single link at the same
time.[¶](#section-1.1-1){.pilcrow}

This protocol supports incremental deployment (where an insecure Babel
network is made secure with no service interruption), and it supports
graceful key rotation (where the set of keys is changed with no service
interruption).[¶](#section-1.1-2){.pilcrow}

This protocol does not require synchronised clocks, it does not require
persistently monotonic clocks, and it does not require persistent
storage except for what might be required for storing cryptographic
keys.[¶](#section-1.1-3){.pilcrow}
:::

::: {#security-properties}
::: {#section-1.2 .section}
### [1.2.](#section-1.2){.section-number .selfRef} [Assumptions and Security Properties](#name-assumptions-and-security-pr){.section-name .selfRef} {#name-assumptions-and-security-pr}

The correctness of the protocol relies on the following
assumptions:[¶](#section-1.2-1){.pilcrow}

-   [that the Message Authentication Code (MAC) being used is
    invulnerable to forgery, i.e., that an attacker is unable to
    generate a packet with a correct MAC without access to the secret
    key;[¶](#section-1.2-2.1){.pilcrow}]{#section-1.2-2.1}
-   [that a node never generates the same index or nonce twice over the
    lifetime of a key.[¶](#section-1.2-2.2){.pilcrow}]{#section-1.2-2.2}

The first assumption is a property of the MAC being used. The second
assumption can be met either by using a robust random number generator
\[[RFC4086](#RFC4086){.xref}\] and sufficiently large indices and
nonces, by using a reliable hardware clock, or by rekeying often enough
that collisions are unlikely.[¶](#section-1.2-3){.pilcrow}

If the assumptions above are met, the protocol described in this
document has the following properties:[¶](#section-1.2-4){.pilcrow}

-   [it is invulnerable to spoofing: any Babel packet accepted as
    authentic is the exact copy of a packet originally sent by an
    authorised node;[¶](#section-1.2-5.1){.pilcrow}]{#section-1.2-5.1}
-   [locally to a single node, it is invulnerable to replay: if a node
    has previously accepted a given packet, then it will never again
    accept a copy of this packet or an earlier packet from the same
    sender;[¶](#section-1.2-5.2){.pilcrow}]{#section-1.2-5.2}
-   [among different nodes, it is only vulnerable to immediate replay:
    if a node A has accepted an authentic packet from C, then a node B
    will only accept a copy of that packet if B has accepted an older
    packet from C, and B has received no later packet from
    C.[¶](#section-1.2-5.3){.pilcrow}]{#section-1.2-5.3}

While this protocol makes efforts to mitigate the effects of a denial of
service attack, it does not fully protect against such
attacks.[¶](#section-1.2-6){.pilcrow}
:::
:::

::: {#section-1.3 .section}
### [1.3.](#section-1.3){.section-number .selfRef} [Specification of Requirements](#name-specification-of-requiremen){.section-name .selfRef} {#name-specification-of-requiremen}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.3-1){.pilcrow}
:::
:::

::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Conceptual Overview of the Protocol](#name-conceptual-overview-of-the-){.section-name .selfRef} {#name-conceptual-overview-of-the-}

When a node B sends out a Babel packet through an interface that is
configured for MAC cryptographic protection, it computes one or more
MACs (one per key) that it appends to the packet. When a node A receives
a packet over an interface that requires MAC cryptographic protection,
it independently computes a set of MACs and compares them to the MACs
appended to the packet; if there is no match, the packet is
discarded.[¶](#section-2-1){.pilcrow}

In order to protect against replay, B maintains a per-interface 32-bit
integer known as the \"packet counter\" (PC). Whenever B sends a packet
through the interface, it embeds the current value of the PC within the
region of the packet that is protected by the MACs and increases the PC
by at least one. When A receives the packet, it compares the value of
the PC with the one contained in the previous packet received from B,
and unless it is strictly greater, the packet is
discarded.[¶](#section-2-2){.pilcrow}

By itself, the PC mechanism is not sufficient to protect against replay.
Consider a peer A that has no information about a peer B (e.g., because
it has recently rebooted). Suppose that A receives a packet ostensibly
from B carrying a given PC; since A has no information about B, it has
no way to determine whether the packet is freshly generated or a replay
of a previously sent packet.[¶](#section-2-3){.pilcrow}

In this situation, peer A discards the packet and challenges B to prove
that it knows the MAC key. It sends a \"Challenge Request\", a TLV
containing a unique nonce, a value that has never been used before and
will never be used again. Peer B replies to the Challenge Request with a
\"Challenge Reply\", a TLV containing a copy of the nonce chosen by A,
in a packet protected by MAC and containing the new value of B\'s PC.
Since the nonce has never been used before, B\'s reply proves B\'s
knowledge of the MAC key and the freshness of the
PC.[¶](#section-2-4){.pilcrow}

By itself, this mechanism is safe against replay if B never resets its
PC. In practice, however, this is difficult to ensure, as persistent
storage is prone to failure, and hardware clocks, even when available,
are occasionally reset. Suppose that B resets its PC to an earlier value
and sends a packet with a previously used PC n. Peer A challenges B, B
successfully responds to the challenge, and A accepts the PC equal to n
+ 1. At this point, an attacker C may send a replayed packet with PC
equal to n + 2, which will be accepted by A.[¶](#section-2-5){.pilcrow}

Another mechanism is needed to protect against this attack. In this
protocol, every PC is tagged with an \"index\", an arbitrary string of
octets. Whenever B resets its PC, or whenever B doesn\'t know whether
its PC has been reset, it picks an index that it has never used before
(either by drawing it randomly or by using a reliable hardware clock)
and starts sending PCs with that index. Whenever A detects that B has
changed its index, it challenges B again.[¶](#section-2-6){.pilcrow}

With this additional mechanism, this protocol is invulnerable to replay
attacks (see [Section
1.2](#security-properties){.xref}).[¶](#section-2-7){.pilcrow}
:::

::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Data Structures](#name-data-structures){.section-name .selfRef} {#name-data-structures}

Every Babel node maintains a set of conceptual data structures described
in [Section
3.2](https://www.rfc-editor.org/rfc/rfc8966#section-3.2){.relref} of
\[[RFC8966](#RFC8966){.xref}\]. This protocol extends these data
structures as follows.[¶](#section-3-1){.pilcrow}

::: {#interface-table}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [The Interface Table](#name-the-interface-table){.section-name .selfRef} {#name-the-interface-table}

Every Babel node maintains an interface table, as described in [Section
3.2.3](https://www.rfc-editor.org/rfc/rfc8966#section-3.2.3){.relref} of
\[[RFC8966](#RFC8966){.xref}\]. Implementations of this protocol
[MUST]{.bcp14} allow each interface to be provisioned with a set of one
or more MAC keys and the associated MAC algorithms (see [Section
4.1](#mac-computation){.xref} for suggested algorithms and [Section
7](#security-considerations){.xref} for suggested methods for key
generation). In order to allow incremental deployment of this protocol
(see [Section 5](#incremental-deployment){.xref}), implementations
[SHOULD]{.bcp14} allow an interface to be configured in a mode in which
it participates in the MAC authentication protocol but accepts packets
that are not authenticated.[¶](#section-3.1-1){.pilcrow}

This protocol extends each table entry associated with an interface on
which MAC authentication has been configured with two new pieces of
data:[¶](#section-3.1-2){.pilcrow}

-   [a set of one or more MAC keys, each associated with a given MAC
    algorithm;[¶](#section-3.1-3.1){.pilcrow}]{#section-3.1-3.1}
-   [a pair (Index, PC), where Index is an arbitrary string of 0 to 32
    octets, and PC is a 32-bit (4-octet)
    integer.[¶](#section-3.1-3.2){.pilcrow}]{#section-3.1-3.2}

We say that an index is fresh when it has never been used before with
any of the keys currently configured on the interface. The Index field
is initialised to a fresh index, for example, by drawing a random string
of sufficient length (see [Section 7](#security-considerations){.xref}
for suggested sizes), and the PC is initialised to an arbitrary value
(typically 0).[¶](#section-3.1-4){.pilcrow}
:::
:::

::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [The Neighbour Table](#name-the-neighbour-table){.section-name .selfRef} {#name-the-neighbour-table}

Every Babel node maintains a neighbour table, as described in [Section
3.2.4](https://www.rfc-editor.org/rfc/rfc8966#section-3.2.4){.relref} of
\[[RFC8966](#RFC8966){.xref}\]. This protocol extends each entry in this
table with two new pieces of data:[¶](#section-3.2-1){.pilcrow}

-   [a pair (Index, PC), where Index is a string of 0 to 32 octets, and
    PC is a 32-bit (4-octet)
    integer;[¶](#section-3.2-2.1){.pilcrow}]{#section-3.2-2.1}
-   [a Nonce, which is an arbitrary string of 0 to 192 octets, and an
    associated challenge expiry
    timer.[¶](#section-3.2-2.2){.pilcrow}]{#section-3.2-2.2}

The Index and PC are initially undefined, and they are managed as
described in [Section 4.3](#packet-reception){.xref}. The Nonce and
challenge expiry timer are initially undefined, and they are used as
described in [Section
4.3.1.1](#sending-challenges){.xref}.[¶](#section-3.2-3){.pilcrow}
:::
:::

::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Protocol Operation](#name-protocol-operation){.section-name .selfRef} {#name-protocol-operation}

::: {#mac-computation}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [MAC Computation](#name-mac-computation){.section-name .selfRef} {#name-mac-computation}

A Babel node computes the MAC of a Babel packet as
follows.[¶](#section-4.1-1){.pilcrow}

First, the node builds a pseudo-header that will participate in MAC
computation but will not be sent. If the packet is carried over IPv6,
the pseudo-header has the following format:[¶](#section-4.1-2){.pilcrow}

::: {#section-4.1-3 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    |                                                               |
    +                          Src address                          +
    |                                                               |
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           Src port            |                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
    |                                                               |
    +                                                               +
    |                         Dest address                          |
    +                                                               +
    |                                                               |
    +                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                               |           Dest port           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-4.1-3){.pilcrow}
:::

If the packet is carried over IPv4, the pseudo-header has the following
format:[¶](#section-4.1-4){.pilcrow}

::: {#section-4.1-5 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                          Src address                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           Src port            |        Dest address           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                               |           Dest port           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

[¶](#section-4.1-5){.pilcrow}
:::

Fields:[¶](#section-4.1-6){.pilcrow}

[]{.break}

Src address
:   The source IP address of the packet.[¶](#section-4.1-7.2){.pilcrow}
:   

Src port
:   The source UDP port number of the
    packet.[¶](#section-4.1-7.4){.pilcrow}
:   

Dest address
:   The destination IP address of the
    packet.[¶](#section-4.1-7.6){.pilcrow}
:   

Src port
:   The destination UDP port number of the
    packet.[¶](#section-4.1-7.8){.pilcrow}
:   

The node takes the concatenation of the pseudo-header and the Babel
packet including the packet header but excluding the packet trailer
(from octet 0 inclusive up to (Body Length + 4) exclusive) and computes
a MAC with one of the implemented algorithms. Every implementation
[MUST]{.bcp14} implement HMAC-SHA256 as defined in
\[[RFC6234](#RFC6234){.xref}\] and [Section
2](https://www.rfc-editor.org/rfc/rfc2104#section-2){.relref} of
\[[RFC2104](#RFC2104){.xref}\], [SHOULD]{.bcp14} implement keyed BLAKE2s
\[[RFC7693](#RFC7693){.xref}\] with 128-bit (16-octet) digests, and
[MAY]{.bcp14} implement other MAC
algorithms.[¶](#section-4.1-8){.pilcrow}
:::
:::

::: {#packet-transmission}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Packet Transmission](#name-packet-transmission){.section-name .selfRef} {#name-packet-transmission}

A Babel node might delay actually sending TLVs by a small amount, in
order to aggregate multiple TLVs in a single packet up to the interface
MTU ([Section
4](https://www.rfc-editor.org/rfc/rfc8966#section-4){.relref} of
\[[RFC8966](#RFC8966){.xref}\]). For an interface on which MAC
protection is configured, the TLV aggregation logic [MUST]{.bcp14} take
into account the overhead due to PC TLVs (one in each packet) and MAC
TLVs (one per configured key).[¶](#section-4.2-1){.pilcrow}

Before sending a packet, the following actions are
performed:[¶](#section-4.2-2){.pilcrow}

-   ::: {#section-4.2-3.1}
    a PC TLV containing the PC and Index associated with the outgoing
    interface [MUST]{.bcp14} be appended to the packet
    body;[¶](#section-4.2-3.1.1){.pilcrow}

    -   [the PC [MUST]{.bcp14} be incremented by a strictly positive
        amount (typically just
        1);[¶](#section-4.2-3.1.2.1){.pilcrow}]{#section-4.2-3.1.2.1}
    -   [if the PC overflows, a fresh index [MUST]{.bcp14} be generated
        (as defined in [Section
        3.1](#interface-table){.xref});[¶](#section-4.2-3.1.2.2){.pilcrow}]{#section-4.2-3.1.2.2}

    a node [MUST NOT]{.bcp14} include multiple PC TLVs in a single
    packet;[¶](#section-4.2-3.1.3){.pilcrow}
    :::

-   [for each key configured on the interface, a MAC is computed as
    specified in [Section 4.1](#mac-computation){.xref} and stored in a
    MAC TLV that [MUST]{.bcp14} be appended to the packet trailer (see
    [Section
    4.2](https://www.rfc-editor.org/rfc/rfc8966#section-4.2){.relref} of
    \[[RFC8966](#RFC8966){.xref}\]).[¶](#section-4.2-3.2){.pilcrow}]{#section-4.2-3.2}
:::
:::

::: {#packet-reception}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Packet Reception](#name-packet-reception){.section-name .selfRef} {#name-packet-reception}

When a packet is received on an interface that is configured for MAC
protection, the following steps are performed before the packet is
passed to normal processing:[¶](#section-4.3-1){.pilcrow}

-   [First, the receiver checks whether the trailer of the received
    packet carries at least one MAC TLV; if not, the packet
    [MUST]{.bcp14} be immediately dropped and processing stops. Then,
    for each key configured on the receiving interface, the receiver
    computes the MAC of the packet. It then compares every generated MAC
    against every MAC included in the packet; if there is at least one
    match, the packet passes the MAC test; if there is none, the packet
    [MUST]{.bcp14} be silently dropped and processing stops at this
    point. In order to avoid memory exhaustion attacks, an entry in the
    neighbour table [MUST NOT]{.bcp14} be created before the MAC test
    has passed successfully. The MAC of the packet [MUST NOT]{.bcp14} be
    computed for each MAC TLV contained in the packet, but only once for
    each configured
    key.[¶](#section-4.3-2.1){.pilcrow}]{#section-4.3-2.1}
-   [If an entry for the sender does not exist in the neighbour table,
    it [MAY]{.bcp14} be created at this point (or, alternatively, its
    creation can be delayed until a challenge needs to be sent, see
    below).[¶](#section-4.3-2.2){.pilcrow}]{#section-4.3-2.2}
-   [The packet body is then parsed a first time. During this
    \"preparse\" phase, the packet body is traversed and all TLVs are
    ignored except PC, Challenge Request, and Challenge Reply TLVs. When
    a PC TLV is encountered, the enclosed PC and Index are saved for
    later processing. If multiple PCs are found (which should not
    happen, see [Section 4.2](#packet-transmission){.xref}), only the
    first one is processed, the remaining ones [MUST]{.bcp14} be
    silently ignored. If a Challenge Request is encountered, a Challenge
    Reply [MUST]{.bcp14} be scheduled, as described in [Section
    4.3.1.2](#replying-challenges){.xref}. If a Challenge Reply is
    encountered, it is tested for validity as described in [Section
    4.3.1.3](#receiving-challenges){.xref}, and a note is made of the
    result of the
    test.[¶](#section-4.3-2.3){.pilcrow}]{#section-4.3-2.3}
-   [The preparse phase above yields two pieces of data: the PC and
    Index from the first PC TLV, and a bit indicating whether the packet
    contains a successful Challenge Reply. If the packet does not
    contain a PC TLV, the packet [MUST]{.bcp14} be dropped, and
    processing stops at this point. If the packet contains a successful
    Challenge Reply, then the PC and Index contained in the PC TLV
    [MUST]{.bcp14} be stored in the neighbour table entry corresponding
    to the sender (which already exists in this case), and the packet is
    accepted.[¶](#section-4.3-2.4){.pilcrow}]{#section-4.3-2.4}
-   [Otherwise, if there is no entry in the neighbour table
    corresponding to the sender, or if such an entry exists but contains
    no Index, or if the Index it contains is different from the Index
    contained in the PC TLV, then a challenge [MUST]{.bcp14} be sent as
    described in [Section 4.3.1.1](#sending-challenges){.xref}, the
    packet [MUST]{.bcp14} be dropped, and processing stops at this
    stage.[¶](#section-4.3-2.5){.pilcrow}]{#section-4.3-2.5}
-   [At this stage, the packet contains no successful Challenge Reply,
    and the Index contained in the PC TLV is equal to the Index in the
    neighbour table entry corresponding to the sender. The receiver
    compares the received PC with the PC contained in the neighbour
    table; if the received PC is smaller or equal than the PC contained
    in the neighbour table, the packet [MUST]{.bcp14} be dropped and
    processing stops (no challenge is sent in this case, since the
    mismatch might be caused by harmless packet reordering on the link).
    Otherwise, the PC contained in the neighbour table entry is set to
    the received PC, and the packet is
    accepted.[¶](#section-4.3-2.6){.pilcrow}]{#section-4.3-2.6}

In the algorithm described above, Challenge Requests are processed and
challenges are sent before the (Index, PC) pair is verified against the
neighbour table. This simplifies the implementation somewhat (the node
may simply schedule outgoing requests as it walks the packet during the
preparse phase) but relies on the rate limiting described in [Section
4.3.1.1](#sending-challenges){.xref} to avoid sending too many
challenges in response to replayed packets. As an optimisation, a node
[MAY]{.bcp14} ignore all Challenge Requests contained in a packet except
the last one, and it [MAY]{.bcp14} ignore a Challenge Request in the
case where it is contained in a packet with an Index that matches the
one in the neighbour table and a PC that is smaller or equal to the one
contained in the neighbour table. Since it is still possible to replay a
packet with an obsolete Index, the rate limiting described in [Section
4.3.1.1](#sending-challenges){.xref} is required even if this
optimisation is implemented.[¶](#section-4.3-3){.pilcrow}

The same is true of Challenge Replies. However, since validating a
Challenge Reply has minimal additional cost (it is just a bitwise
comparison of two strings of octets), a similar optimisation for
Challenge Replies is not worthwhile.[¶](#section-4.3-4){.pilcrow}

After the packet has been accepted, it is processed as normal, except
that any PC, Challenge Request, and Challenge Reply TLVs that it
contains are silently ignored.[¶](#section-4.3-5){.pilcrow}

::: {#section-4.3.1 .section}
#### [4.3.1.](#section-4.3.1){.section-number .selfRef} [Challenge Requests and Replies](#name-challenge-requests-and-repl){.section-name .selfRef} {#name-challenge-requests-and-repl}

During the preparse stage, the receiver might encounter a mismatched
Index, to which it will react by scheduling a Challenge Request. It
might encounter a Challenge Request TLV, to which it will reply with a
Challenge Reply TLV. Finally, it might encounter a Challenge Reply TLV,
which it will attempt to match with a previously sent Challenge Request
TLV in order to update the neighbour table entry corresponding to the
sender of the packet.[¶](#section-4.3.1-1){.pilcrow}

::: {#sending-challenges}
::: {#section-4.3.1.1 .section}
##### [4.3.1.1.](#section-4.3.1.1){.section-number .selfRef} [Sending Challenges](#name-sending-challenges){.section-name .selfRef} {#name-sending-challenges}

When it encounters a mismatched Index during the preparse phase, a node
picks a nonce that it has never used with any of the keys currently
configured on the relevant interface, for example, by drawing a
sufficiently large random string of bytes or by consulting a strictly
monotonic hardware clock. It [MUST]{.bcp14} then store the nonce in the
entry of the neighbour table associated to the neighbour (the entry
might need to be created at this stage), initialise the neighbour\'s
challenge expiry timer to 30 seconds, and send a Challenge Request TLV
to the unicast address corresponding to the
neighbour.[¶](#section-4.3.1.1-1){.pilcrow}

A node [MAY]{.bcp14} aggregate a Challenge Request with other TLVs; in
other words, if it has already buffered TLVs to be sent to the unicast
address of the neighbour, it [MAY]{.bcp14} send the buffered TLVs in the
same packet as the Challenge Request. However, it [MUST]{.bcp14} arrange
for the Challenge Request to be sent in a timely manner, as any packets
received from that neighbour will be silently ignored until the
challenge completes.[¶](#section-4.3.1.1-2){.pilcrow}

A node [MUST]{.bcp14} impose a rate limitation to the challenges it
sends; the limit [SHOULD]{.bcp14} default to one Challenge Request every
300 ms and [MAY]{.bcp14} be configurable. This rate limiting serves two
purposes. First, since a challenge may be sent in response to a packet
replayed by an attacker, it limits the number of challenges that an
attacker can cause a node to send. Second, it limits the number of
challenges sent when there are multiple packets in flight from a single
neighbour.[¶](#section-4.3.1.1-3){.pilcrow}
:::
:::

::: {#replying-challenges}
::: {#section-4.3.1.2 .section}
##### [4.3.1.2.](#section-4.3.1.2){.section-number .selfRef} [Replying to Challenges](#name-replying-to-challenges){.section-name .selfRef} {#name-replying-to-challenges}

When it encounters a Challenge Request during the preparse phase, a node
constructs a Challenge Reply TLV by copying the Nonce from the Challenge
Request into the Challenge Reply. It [MUST]{.bcp14} then send the
Challenge Reply to the unicast address from which the Challenge Request
was sent. A challenge sent to a multicast address [MUST]{.bcp14} be
silently ignored.[¶](#section-4.3.1.2-1){.pilcrow}

A node [MAY]{.bcp14} aggregate a Challenge Reply with other TLVs; in
other words, if it has already buffered TLVs to be sent to the unicast
address of the sender of the Challenge Request, it [MAY]{.bcp14} send
the buffered TLVs in the same packet as the Challenge Reply. However, it
[MUST]{.bcp14} arrange for the Challenge Reply to be sent in a timely
manner (within a few seconds) and [SHOULD NOT]{.bcp14} send any other
packets over the same interface before sending the Challenge Reply, as
those would be dropped by the
challenger.[¶](#section-4.3.1.2-2){.pilcrow}

Since a Challenge Reply might be caused by a replayed Challenge Request,
a node [MUST]{.bcp14} impose a rate limitation to the Challenge Replies
it sends; the limit [SHOULD]{.bcp14} default to one Challenge Reply for
each peer every 300 ms and [MAY]{.bcp14} be
configurable.[¶](#section-4.3.1.2-3){.pilcrow}
:::
:::

::: {#receiving-challenges}
::: {#section-4.3.1.3 .section}
##### [4.3.1.3.](#section-4.3.1.3){.section-number .selfRef} [Receiving Challenge Replies](#name-receiving-challenge-replies){.section-name .selfRef} {#name-receiving-challenge-replies}

When it encounters a Challenge Reply during the preparse phase, a node
consults the neighbour table entry corresponding to the neighbour that
sent the Challenge Reply. If no challenge is in progress, i.e., if there
is no Nonce stored in the neighbour table entry or the challenge timer
has expired, the Challenge Reply [MUST]{.bcp14} be silently ignored, and
the challenge has failed.[¶](#section-4.3.1.3-1){.pilcrow}

Otherwise, the node compares the Nonce contained in the Challenge Reply
with the Nonce contained in the neighbour table entry. If the two are
equal (they have the same length and content), then the challenge has
succeeded and the nonce stored in the neighbour table for this neighbour
[SHOULD]{.bcp14} be discarded; otherwise, the challenge has failed (and
the nonce is not discarded).[¶](#section-4.3.1.3-2){.pilcrow}
:::
:::
:::
:::
:::

::: {#expire}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Expiring Per-Neighbour State](#name-expiring-per-neighbour-stat){.section-name .selfRef} {#name-expiring-per-neighbour-stat}

The per-neighbour (Index, PC) pair is maintained in the neighbour table,
and is normally discarded when the neighbour table entry expires.
Implementations [MUST]{.bcp14} ensure that an (Index, PC) pair is
discarded within a finite time since the last time a packet has been
accepted. In particular, unsuccessful challenges [MUST NOT]{.bcp14}
prevent an (Index, PC) pair from being discarded for unbounded periods
of time.[¶](#section-4.4-1){.pilcrow}

A possible implementation strategy for implementations that use a Hello
history (Appendix A of \[[RFC8966](#RFC8966){.xref}\]) is to discard the
(Index, PC) pair whenever the Hello history becomes empty. Another
implementation strategy is to use a timer that is reset whenever a
packet is accepted and to discard the (Index, PC) pair whenever the
timer expires. If the latter strategy is used, the timer
[SHOULD]{.bcp14} default to a value of 5 minutes and [MAY]{.bcp14} be
configurable.[¶](#section-4.4-2){.pilcrow}
:::
:::
:::

::: {#incremental-deployment}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Incremental Deployment and Key Rotation](#name-incremental-deployment-and-){.section-name .selfRef} {#name-incremental-deployment-and-}

In order to perform incremental deployment, the nodes in the network are
first configured in a mode where packets are sent with authentication
but not checked on reception. Once all the nodes in the network are
configured to send authenticated packets, nodes are reconfigured to
reject unauthenticated packets.[¶](#section-5-1){.pilcrow}

In order to perform key rotation, the new key is added to all the nodes.
Once this is done, both the old and the new key are sent in all packets,
and packets are accepted if they are properly signed by either of the
keys. At that point, the old key is removed.[¶](#section-5-2){.pilcrow}

In order to support the procedures described above, implementations of
this protocol [SHOULD]{.bcp14} support an interface configuration in
which packets are sent authenticated but received packets are accepted
without verification, and they [SHOULD]{.bcp14} allow changing the set
of keys associated with an interface without a
restart.[¶](#section-5-3){.pilcrow}
:::
:::

::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Packet Format](#name-packet-format){.section-name .selfRef} {#name-packet-format}

::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [MAC TLV](#name-mac-tlv){.section-name .selfRef} {#name-mac-tlv}

::: {#section-6.1-1 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 16   |    Length     |     MAC...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

[¶](#section-6.1-1){.pilcrow}
:::

Fields:[¶](#section-6.1-2){.pilcrow}

[]{.break}

Type
:   Set to 16 to indicate a MAC TLV.[¶](#section-6.1-3.2){.pilcrow}
:   

Length
:   The length of the body, in octets, exclusive of the Type and Length
    fields. The length depends on the MAC algorithm being
    used.[¶](#section-6.1-3.4){.pilcrow}
:   

MAC
:   The body contains the MAC of the packet, computed as described in
    [Section
    4.1](#mac-computation){.xref}.[¶](#section-6.1-3.6){.pilcrow}
:   

This TLV is allowed in the packet trailer (see [Section
4.2](https://www.rfc-editor.org/rfc/rfc8966#section-4.2){.relref} of
\[[RFC8966](#RFC8966){.xref}\]) and [MUST]{.bcp14} be ignored if it is
found in the packet body.[¶](#section-6.1-4){.pilcrow}
:::

::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [PC TLV](#name-pc-tlv){.section-name .selfRef} {#name-pc-tlv}

::: {#section-6.2-1 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 17   |    Length     |             PC                |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                               |            Index...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

[¶](#section-6.2-1){.pilcrow}
:::

Fields:[¶](#section-6.2-2){.pilcrow}

[]{.break}

Type
:   Set to 17 to indicate a PC TLV.[¶](#section-6.2-3.2){.pilcrow}
:   

Length
:   The length of the body, in octets, exclusive of the Type and Length
    fields.[¶](#section-6.2-3.4){.pilcrow}
:   

PC
:   The Packet Counter (PC), a 32-bit (4-octet) unsigned integer that is
    increased with every packet sent over this interface. A fresh index
    (as defined in [Section 3.1](#interface-table){.xref})
    [MUST]{.bcp14} be generated whenever the PC
    overflows.[¶](#section-6.2-3.6){.pilcrow}
:   

Index
:   The sender\'s Index, an opaque string of 0 to 32
    octets.[¶](#section-6.2-3.8){.pilcrow}
:   

Indices are limited to a size of 32 octets: a node [MUST NOT]{.bcp14}
send a TLV with an index of size strictly larger than 32 octets, and a
node [MAY]{.bcp14} ignore a PC TLV with an index of length strictly
larger than 32 octets. Indices of length 0 are valid: if a node has
reliable stable storage and the packet counter never overflows, then
only one index is necessary, and the value of length 0 is the canonical
choice.[¶](#section-6.2-4){.pilcrow}
:::

::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Challenge Request TLV](#name-challenge-request-tlv){.section-name .selfRef} {#name-challenge-request-tlv}

::: {#section-6.3-1 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 18   |    Length     |     Nonce...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

[¶](#section-6.3-1){.pilcrow}
:::

Fields:[¶](#section-6.3-2){.pilcrow}

[]{.break}

Type
:   Set to 18 to indicate a Challenge Request
    TLV.[¶](#section-6.3-3.2){.pilcrow}
:   

Length
:   The length of the body, in octets, exclusive of the Type and Length
    fields.[¶](#section-6.3-3.4){.pilcrow}
:   

Nonce
:   The nonce uniquely identifying the challenge, an opaque string of 0
    to 192 octets.[¶](#section-6.3-3.6){.pilcrow}
:   

Nonces are limited to a size of 192 octets: a node [MUST NOT]{.bcp14}
send a Challenge Request TLV with a nonce of size strictly larger than
192 octets, and a node [MAY]{.bcp14} ignore a nonce that is of size
strictly larger than 192 octets. Nonces of length 0 are valid: if a node
has reliable stable storage, then it may use a sequential counter for
generating nonces that get encoded in the minimum number of octets
required; the value 0 is then encoded as the string of length
0.[¶](#section-6.3-4){.pilcrow}
:::

::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [Challenge Reply TLV](#name-challenge-reply-tlv){.section-name .selfRef} {#name-challenge-reply-tlv}

::: {#section-6.4-1 .artwork .art-text .alignLeft}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 19   |    Length     |     Nonce...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

[¶](#section-6.4-1){.pilcrow}
:::

Fields:[¶](#section-6.4-2){.pilcrow}

[]{.break}

Type
:   Set to 19 to indicate a Challenge Reply
    TLV.[¶](#section-6.4-3.2){.pilcrow}
:   

Length
:   The length of the body, in octets, exclusive of the Type and Length
    fields.[¶](#section-6.4-3.4){.pilcrow}
:   

Nonce
:   A copy of the nonce contained in the corresponding Challenge
    Request.[¶](#section-6.4-3.6){.pilcrow}
:   
:::
:::

::: {#security-considerations}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

This document defines a mechanism that provides basic security
properties for the Babel routing protocol. The scope of this protocol is
strictly limited: it only provides authentication (we assume that
routing information is not confidential), it only supports symmetric
keying, and it only allows for the use of a small number of symmetric
keys on every link. Deployments that need more features, e.g.,
confidentiality or asymmetric keying, should use a more feature-rich
security mechanism such as the one described in
\[[RFC8968](#RFC8968){.xref}\].[¶](#section-7-1){.pilcrow}

This mechanism relies on two assumptions, as described in [Section
1.2](#security-properties){.xref}. First, it assumes that the MAC being
used is invulnerable to forgery ([Section
1.1](https://www.rfc-editor.org/rfc/rfc6039#section-1.1){.relref} of
\[[RFC6039](#RFC6039){.xref}\]); at the time of writing, HMAC-SHA256,
which is mandatory to implement ([Section
4.1](#mac-computation){.xref}), is believed to be safe against practical
attacks.[¶](#section-7-2){.pilcrow}

Second, it assumes that indices and nonces are generated uniquely over
the lifetime of a key used for MAC computation (more precisely, indices
must be unique for a given (key, source) pair, and nonces must be unique
for a given (key, source, destination) triple). This property can be
satisfied either by using a cryptographically secure random number
generator to generate indices and nonces that contain enough entropy
(64-bit values are believed to be large enough for all practical
applications) or by using a reliably monotonic hardware clock. If
uniqueness cannot be guaranteed (e.g., because a hardware clock has been
reset), then rekeying is necessary.[¶](#section-7-3){.pilcrow}

The expiry mechanism mandated in [Section 4.4](#expire){.xref} is
required to prevent an attacker from delaying an authentic packet by an
unbounded amount of time. If an attacker is able to delay the delivery
of a packet (e.g., because it is located at a Layer 2 switch), then the
packet will be accepted as long as the corresponding (Index, PC) pair is
present at the receiver. If the attacker is able to cause the (Index,
PC) pair to persist for arbitrary amounts of time (e.g., by repeatedly
causing failed challenges), then it is able to delay the packet by
arbitrary amounts of time, even after the sender has left the network,
which could allow it to redirect or blackhole traffic to destinations
previously advertised by the sender.[¶](#section-7-4){.pilcrow}

This protocol exposes large numbers of packets and their MACs to an
attacker that is able to capture packets; it is therefore vulnerable to
brute-force attacks. Keys must be chosen in a manner that makes them
difficult to guess. Ideally, they should have a length of 32 octets
(both for HMAC-SHA256 and BLAKE2s), and be chosen randomly. If, for some
reason, it is necessary to derive keys from a human-readable passphrase,
it is recommended to use a key derivation function that hampers
dictionary attacks, such as PBKDF2 \[[RFC8018](#RFC8018){.xref}\],
bcrypt \[[BCRYPT](#BCRYPT){.xref}\], or scrypt
\[[RFC7914](#RFC7914){.xref}\]. In that case, only the derived keys
should be communicated to the routers; the original passphrase itself
should be kept on the host used to perform the key generation (e.g., an
administrator\'s secure laptop computer).[¶](#section-7-5){.pilcrow}

While it is probably not possible to be immune against denial of service
(DoS) attacks in general, this protocol includes a number of mechanisms
designed to mitigate such attacks. In particular, reception of a packet
with no correct MAC creates no local Babel state ([Section
4.3](#packet-reception){.xref}). Reception of a replayed packet with
correct MAC, on the other hand, causes a challenge to be sent; this is
mitigated somewhat by requiring that challenges be rate limited
([Section
4.3.1.1](#sending-challenges){.xref}).[¶](#section-7-6){.pilcrow}

Receiving a replayed packet with an obsolete index causes an entry to be
created in the neighbour table, which, at first sight, makes the
protocol susceptible to resource exhaustion attacks (similarly to the
familiar \"TCP SYN Flooding\" attack \[[RFC4987](#RFC4987){.xref}\]).
However, the MAC computation includes the sender address ([Section
4.1](#mac-computation){.xref}), and thus the amount of storage that an
attacker can force a node to consume is limited by the number of
distinct source addresses used with a single MAC key (see also [Section
4](https://www.rfc-editor.org/rfc/rfc8966#section-4){.relref} of
\[[RFC8966](#RFC8966){.xref}\], which mandates that the source address
is a link-local IPv6 address or a local IPv4
address).[¶](#section-7-7){.pilcrow}

In order to make this kind of resource exhaustion attacks less
effective, implementations may use a separate table of uncompleted
challenges that is separate from the neighbour table used by the core
protocol (the data structures described in [Section
3.2](https://www.rfc-editor.org/rfc/rfc8966#section-3.2){.relref} of
\[[RFC8966](#RFC8966){.xref}\] are conceptual, and any data structure
that yields the same result may be used). Implementers might also
consider using the fact that the nonces included in Challenge Requests
and Replies can be fairly large (up to 192 octets), which should in
principle allow encoding the per-challenge state as a secure \"cookie\"
within the nonce itself; note, however, that any such scheme will need
to prevent cookie replay.[¶](#section-7-8){.pilcrow}
:::
:::

::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

IANA has allocated the following values in the Babel TLV Types
registry:[¶](#section-8-1){.pilcrow}

  Type   Name                Reference
  ------ ------------------- -----------
  16     MAC                 RFC 8967
  17     PC                  RFC 8967
  18     Challenge Request   RFC 8967
  19     Challenge Reply     RFC 8967

  : [Table 1](#table-1){.selfRef}
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2104\]
:   [Krawczyk, H.]{.refAuthor}[, Bellare, M.]{.refAuthor}[, and R.
    Canetti]{.refAuthor}, [\"HMAC: Keyed-Hashing for Message
    Authentication\"]{.refTitle}, [RFC 2104]{.seriesInfo}, [DOI
    10.17487/RFC2104]{.seriesInfo}, February 1997,
    \<<https://www.rfc-editor.org/info/rfc2104>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC6234\]
:   [Eastlake 3rd, D.]{.refAuthor}[ and T. Hansen]{.refAuthor}, [\"US
    Secure Hash Algorithms (SHA and SHA-based HMAC and
    HKDF)\"]{.refTitle}, [RFC 6234]{.seriesInfo}, [DOI
    10.17487/RFC6234]{.seriesInfo}, May 2011,
    \<<https://www.rfc-editor.org/info/rfc6234>\>.
:   

\[RFC7693\]
:   [Saarinen, M-J., Ed.]{.refAuthor}[ and J-P. Aumasson]{.refAuthor},
    [\"The BLAKE2 Cryptographic Hash and Message Authentication Code
    (MAC)\"]{.refTitle}, [RFC 7693]{.seriesInfo}, [DOI
    10.17487/RFC7693]{.seriesInfo}, November 2015,
    \<<https://www.rfc-editor.org/info/rfc7693>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8966\]
:   [Chroboczek, J.]{.refAuthor}[ and D. Schinazi]{.refAuthor}, [\"The
    Babel Routing Protocol\"]{.refTitle}, [RFC 8966]{.seriesInfo}, [DOI
    10.17487/RFC8966]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8966>\>.
:   
:::

::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Informational References](#name-informational-references){.section-name .selfRef} {#name-informational-references}

\[BCRYPT\]
:   [Niels, P.]{.refAuthor}[ and D. Mazières]{.refAuthor}, [\"A
    Future-Adaptable Password Scheme\"]{.refTitle}, [Proceedings of the
    FREENIX Track: 1999 USENIX Annual Technical
    Conference]{.refContent}, June 1999.
:   

\[RFC4086\]
:   [Eastlake 3rd, D.]{.refAuthor}[, Schiller, J.]{.refAuthor}[, and S.
    Crocker]{.refAuthor}, [\"Randomness Requirements for
    Security\"]{.refTitle}, [BCP 106]{.seriesInfo}, [RFC
    4086]{.seriesInfo}, [DOI 10.17487/RFC4086]{.seriesInfo}, June 2005,
    \<<https://www.rfc-editor.org/info/rfc4086>\>.
:   

\[RFC4987\]
:   [Eddy, W.]{.refAuthor}, [\"TCP SYN Flooding Attacks and Common
    Mitigations\"]{.refTitle}, [RFC 4987]{.seriesInfo}, [DOI
    10.17487/RFC4987]{.seriesInfo}, August 2007,
    \<<https://www.rfc-editor.org/info/rfc4987>\>.
:   

\[RFC6039\]
:   [Manral, V.]{.refAuthor}[, Bhatia, M.]{.refAuthor}[,
    Jaeggli, J.]{.refAuthor}[, and R. White]{.refAuthor}, [\"Issues with
    Existing Cryptographic Protection Methods for Routing
    Protocols\"]{.refTitle}, [RFC 6039]{.seriesInfo}, [DOI
    10.17487/RFC6039]{.seriesInfo}, October 2010,
    \<<https://www.rfc-editor.org/info/rfc6039>\>.
:   

\[RFC7298\]
:   [Ovsienko, D.]{.refAuthor}, [\"Babel Hashed Message Authentication
    Code (HMAC) Cryptographic Authentication\"]{.refTitle}, [RFC
    7298]{.seriesInfo}, [DOI 10.17487/RFC7298]{.seriesInfo}, July 2014,
    \<<https://www.rfc-editor.org/info/rfc7298>\>.
:   

\[RFC7914\]
:   [Percival, C.]{.refAuthor}[ and S. Josefsson]{.refAuthor}, [\"The
    scrypt Password-Based Key Derivation Function\"]{.refTitle}, [RFC
    7914]{.seriesInfo}, [DOI 10.17487/RFC7914]{.seriesInfo}, August
    2016, \<<https://www.rfc-editor.org/info/rfc7914>\>.
:   

\[RFC8018\]
:   [Moriarty, K., Ed.]{.refAuthor}[, Kaliski, B.]{.refAuthor}[, and A.
    Rusch]{.refAuthor}, [\"PKCS #5: Password-Based Cryptography
    Specification Version 2.1\"]{.refTitle}, [RFC 8018]{.seriesInfo},
    [DOI 10.17487/RFC8018]{.seriesInfo}, January 2017,
    \<<https://www.rfc-editor.org/info/rfc8018>\>.
:   

\[RFC8968\]
:   [Décimo, A.]{.refAuthor}[, Schinazi, D.]{.refAuthor}[, and J.
    Chroboczek]{.refAuthor}, [\"Babel Routing Protocol over Datagram
    Transport Layer Security\"]{.refTitle}, [RFC 8968]{.seriesInfo},
    [DOI 10.17487/RFC8968]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8968>\>.
:   
:::
:::

::: {#section-appendix.a .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

The protocol described in this document is based on the original HMAC
protocol defined by [Denis Ovsienko]{.contact-name}
\[[RFC7298](#RFC7298){.xref}\]. The use of a pseudo-header was suggested
by [David Schinazi]{.contact-name}. The use of an index to avoid replay
was suggested by [Markus Stenberg]{.contact-name}. The authors are also
indebted to [Antonin Décimo]{.contact-name}, [Donald
Eastlake]{.contact-name}, [Toke Høiland-Jørgensen]{.contact-name},
[Florian Horn]{.contact-name}, [Benjamin Kaduk]{.contact-name}, [Dave
Taht]{.contact-name}, and [Martin
Vigoureux]{.contact-name}.[¶](#section-appendix.a-1){.pilcrow}
:::

::: {#authors-addresses}
::: {#section-appendix.b .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Clara Dô]{.fn .nameRole}
:::

::: {.left dir="auto"}
[IRIF, University of Paris-Diderot]{.org}
:::

::: {.left dir="auto"}
[75205]{.postal-code} [Paris CEDEX 13]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <clarado_perso@yahoo.fr>
:::

::: {.left dir="auto"}
[Weronika Kolodziejak]{.fn .nameRole}
:::

::: {.left dir="auto"}
[IRIF, University of Paris-Diderot]{.org}
:::

::: {.left dir="auto"}
[75205]{.postal-code} [Paris CEDEX 13]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <weronika.kolodziejak@gmail.com>
:::

::: {.left dir="auto"}
[Juliusz Chroboczek]{.fn .nameRole}
:::

::: {.left dir="auto"}
[IRIF, University of Paris-Diderot]{.org}
:::

::: {.left dir="auto"}
[Case 7014]{.street-address}
:::

::: {.left dir="auto"}
[75205]{.postal-code} [Paris CEDEX 13]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <jch@irif.fr>
:::
:::
:::
