  RFC 8785           JSON Canonicalization Scheme   June 2020
  ------------------ ------------------------------ -----------
  Rundgren, et al.   Informational                  \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Independent Submission

RFC:
:   [8785](https://www.rfc-editor.org/rfc/rfc8785){.eref}

Category:
:   Informational

Published:
:   June 2020

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    A. Rundgren
    :::

    ::: org
    Independent
    :::
    :::

    ::: author
    ::: author-name
    B. Jordan
    :::

    ::: org
    Broadcom
    :::
    :::

    ::: author
    ::: author-name
    S. Erdtman
    :::

    ::: org
    Spotify AB
    :::
    :::
:::

# RFC 8785 {#rfcnum}

# JSON Canonicalization Scheme (JCS) {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

Cryptographic operations like hashing and signing need the data to be
expressed in an invariant format so that the operations are reliably
repeatable. One way to address this is to create a canonical
representation of the data. Canonicalization also permits data to be
exchanged in its original form on the \"wire\" while cryptographic
operations performed on the canonicalized counterpart of the data in the
producer and consumer endpoints generate consistent
results.[¶](#section-abstract-1){.pilcrow}

This document describes the JSON Canonicalization Scheme (JCS). This
specification defines how to create a canonical representation of JSON
data by building on the strict serialization methods for JSON primitives
defined by ECMAScript, constraining JSON data to the Internet JSON
(I-JSON) subset, and by using deterministic property
sorting.[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for informational
purposes.[¶](#section-boilerplate.1-1){.pilcrow}

This is a contribution to the RFC Series, independently of any other RFC
stream. The RFC Editor has chosen to publish this document at its
discretion and makes no statement about its value for implementation or
deployment. Documents approved for publication by the RFC Editor are not
candidates for any level of Internet Standard; see Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8785>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Detailed
    Operation](#name-detailed-operation){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Creation of Input
        Data](#name-creation-of-input-data){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Generation of Canonical JSON
        Data](#name-generation-of-canonical-jso){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.3.2.2.2.1}
            [3.2.1](#section-3.2.1){.xref}.  [Whitespace](#name-whitespace){.xref}[¶](#section-toc.1-1.3.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.2}
            [3.2.2](#section-3.2.2){.xref}.  [Serialization of Primitive
            Data
            Types](#name-serialization-of-primitive-){.xref}[¶](#section-toc.1-1.3.2.2.2.2.1){.pilcrow}

            -   ::: {#section-toc.1-1.3.2.2.2.2.2.1}
                [3.2.2.1](#section-3.2.2.1){.xref}.  [Serialization of
                Literals](#name-serialization-of-literals){.xref}[¶](#section-toc.1-1.3.2.2.2.2.2.1.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.3.2.2.2.2.2.2}
                [3.2.2.2](#section-3.2.2.2){.xref}.  [Serialization of
                Strings](#name-serialization-of-strings){.xref}[¶](#section-toc.1-1.3.2.2.2.2.2.2.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.3.2.2.2.2.2.3}
                [3.2.2.3](#section-3.2.2.3){.xref}.  [Serialization of
                Numbers](#name-serialization-of-numbers){.xref}[¶](#section-toc.1-1.3.2.2.2.2.2.3.1){.pilcrow}
                :::
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.3}
            [3.2.3](#section-3.2.3){.xref}.  [Sorting of Object
            Properties](#name-sorting-of-object-propertie){.xref}[¶](#section-toc.1-1.3.2.2.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.4}
            [3.2.4](#section-3.2.4){.xref}.  [UTF-8
            Generation](#name-utf-8-generation){.xref}[¶](#section-toc.1-1.3.2.2.2.4.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [References](#name-references){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [Appendix A](#section-appendix.a){.xref}.  [ECMAScript Sample
    Canonicalizer](#name-ecmascript-sample-canonical){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.8}
    [Appendix B](#section-appendix.b){.xref}.  [Number Serialization
    Samples](#name-number-serialization-sample){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [Appendix C](#section-appendix.c){.xref}.  [Canonicalized JSON as
    \"Wire
    Format\"](#name-canonicalized-json-as-wire-){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [Appendix D](#section-appendix.d){.xref}.  [Dealing with Big
    Numbers](#name-dealing-with-big-numbers){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [Appendix E](#section-appendix.e){.xref}.  [String Subtype
    Handling](#name-string-subtype-handling){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}

    -   ::: {#section-toc.1-1.11.2.1}
        [E.1](#section-e.1){.xref}.  [Subtypes in
        Arrays](#name-subtypes-in-arrays){.xref}[¶](#section-toc.1-1.11.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [Appendix F](#section-appendix.f){.xref}.  [Implementation
    Guidelines](#name-implementation-guidelines){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.13}
    [Appendix G](#section-appendix.g){.xref}.  [Open-Source
    Implementations](#name-open-source-implementations){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.14}
    [Appendix H](#section-appendix.h){.xref}.  [Other JSON
    Canonicalization
    Efforts](#name-other-json-canonicalization){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.15}
    [Appendix I](#section-appendix.i){.xref}.  [Development
    Portal](#name-development-portal){.xref}[¶](#section-toc.1-1.15.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.16}
    [](#section-appendix.j){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.16.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.17}
    [](#section-appendix.k){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.17.1){.pilcrow}
    :::
:::
:::

::: {#Introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

This document describes the JSON Canonicalization Scheme (JCS). This
specification defines how to create a canonical representation of JSON
\[[RFC8259](#RFC8259){.xref}\] data by building on the strict
serialization methods for JSON primitives defined by ECMAScript
\[[ECMA-262](#ECMA-262){.xref}\], constraining JSON data to the I-JSON
\[[RFC7493](#RFC7493){.xref}\] subset, and by using deterministic
property sorting. The output from JCS is a \"hashable\" representation
of JSON data that can be used by cryptographic methods. The subsequent
paragraphs outline the primary design
considerations.[¶](#section-1-1){.pilcrow}

Cryptographic operations like hashing and signing need the data to be
expressed in an invariant format so that the operations are reliably
repeatable. One way to accomplish this is to convert the data into a
format that has a simple and fixed representation, like base64url
\[[RFC4648](#RFC4648){.xref}\]. This is how JSON Web Signature (JWS)
\[[RFC7515](#RFC7515){.xref}\] addressed this issue. Another solution is
to create a canonical version of the data, similar to what was done for
the XML signature \[[XMLDSIG](#XMLDSIG){.xref}\]
standard.[¶](#section-1-2){.pilcrow}

The primary advantage with a canonicalizing scheme is that data can be
kept in its original form. This is the core rationale behind JCS. Put
another way, using canonicalization enables a JSON object to remain a
JSON object even after being signed. This can simplify system design,
documentation, and logging.[¶](#section-1-3){.pilcrow}

To avoid \"reinventing the wheel\", JCS relies on the serialization of
JSON primitives (strings, numbers, and literals), as defined by
ECMAScript (aka JavaScript) \[[ECMA-262](#ECMA-262){.xref}\] beginning
with version 6.[¶](#section-1-4){.pilcrow}

Seasoned XML developers may recall difficulties getting XML signatures
to validate. This was usually due to different interpretations of the
quite intricate XML canonicalization rules as well as of the equally
complex Web Services security standards. The reasons why JCS should not
suffer from similar issues are:[¶](#section-1-5){.pilcrow}

-   [JSON does not have a namespace concept and default
    values.[¶](#section-1-6.1){.pilcrow}]{#section-1-6.1}
-   [Data is constrained to the I‑JSON \[[RFC7493](#RFC7493){.xref}\]
    subset. This eliminates the need for specific parsers for dealing
    with canonicalization.[¶](#section-1-6.2){.pilcrow}]{#section-1-6.2}
-   [JCS-compatible serialization of JSON primitives is currently
    supported by most web browsers as well as by Node.js
    \[[NODEJS](#NODEJS){.xref}\].[¶](#section-1-6.3){.pilcrow}]{#section-1-6.3}
-   [The full JCS specification is currently supported by multiple
    open-source implementations (see [Appendix G](#open.source){.xref}).
    See also [Appendix F](#impl.guidelines){.xref} for implementation
    guidelines.[¶](#section-1-6.4){.pilcrow}]{#section-1-6.4}

JCS is compatible with some existing systems relying on JSON
canonicalization such as JSON Web Key (JWK) Thumbprint
\[[RFC7638](#RFC7638){.xref}\] and Keybase
\[[KEYBASE](#KEYBASE){.xref}\].[¶](#section-1-7){.pilcrow}

For potential uses outside of cryptography, see
\[[JSONCOMP](#I-D.rundgren-comparable-json){.xref}\].[¶](#section-1-8){.pilcrow}

The intended audiences of this document are JSON tool vendors as well as
designers of JSON-based cryptographic solutions. The reader is assumed
to be knowledgeable in ECMAScript, including the \"JSON\"
object.[¶](#section-1-9){.pilcrow}
:::
:::

::: {#Terminology}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

Note that this document is not on the IETF standards track. However, a
conformant implementation is supposed to adhere to the specified
behavior for security and interoperability reasons. This text uses BCP
14 to describe that necessary behavior.[¶](#section-2-1){.pilcrow}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-2){.pilcrow}
:::
:::

::: {#Operation}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Detailed Operation](#name-detailed-operation){.section-name .selfRef} {#name-detailed-operation}

This section describes the details related to creating a canonical JSON
representation and how they are addressed by
JCS.[¶](#section-3-1){.pilcrow}

[Appendix F](#impl.guidelines){.xref} describes the
[RECOMMENDED]{.bcp14} way of adding JCS support to existing JSON
tools.[¶](#section-3-2){.pilcrow}

::: {#json.datacreation}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Creation of Input Data](#name-creation-of-input-data){.section-name .selfRef} {#name-creation-of-input-data}

Data to be canonically serialized is usually created
by:[¶](#section-3.1-1){.pilcrow}

-   [Parsing previously generated JSON
    data.[¶](#section-3.1-2.1){.pilcrow}]{#section-3.1-2.1}
-   [Programmatically creating
    data.[¶](#section-3.1-2.2){.pilcrow}]{#section-3.1-2.2}

Irrespective of the method used, the data to be serialized
[MUST]{.bcp14} be adapted for I‑JSON \[[RFC7493](#RFC7493){.xref}\]
formatting, which implies the following:[¶](#section-3.1-3){.pilcrow}

-   [JSON objects [MUST NOT]{.bcp14} exhibit duplicate property
    names.[¶](#section-3.1-4.1){.pilcrow}]{#section-3.1-4.1}
-   [JSON string data [MUST]{.bcp14} be expressible as Unicode
    \[[UNICODE](#UNICODE){.xref}\].[¶](#section-3.1-4.2){.pilcrow}]{#section-3.1-4.2}
-   [JSON number data [MUST]{.bcp14} be expressible as IEEE 754
    \[[IEEE754](#IEEE754){.xref}\] double-precision values. For
    applications needing higher precision or longer integers than
    offered by IEEE 754 double precision, it is [RECOMMENDED]{.bcp14} to
    represent such numbers as JSON strings; see [Appendix
    D](#json.bignumbers){.xref} for details on how this can be performed
    in an interoperable and extensible
    way.[¶](#section-3.1-4.3){.pilcrow}]{#section-3.1-4.3}

An additional constraint is that parsed JSON string data [MUST
NOT]{.bcp14} be altered during subsequent serializations. For more
information, see [Appendix
E](#string.subtypes){.xref}.[¶](#section-3.1-5){.pilcrow}

Note: Although the Unicode standard offers the possibility of
rearranging certain character sequences, referred to as \"Unicode
Normalization\" \[[UCNORM](#UCNORM){.xref}\], JCS-compliant string
processing does not take this into consideration. That is, all
components involved in a scheme depending on JCS [MUST]{.bcp14} preserve
Unicode string data \"as is\".[¶](#section-3.1-6){.pilcrow}
:::
:::

::: {#json.canonicalization}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Generation of Canonical JSON Data](#name-generation-of-canonical-jso){.section-name .selfRef} {#name-generation-of-canonical-jso}

The following subsections describe the steps required to create a
canonical JSON representation of the data elaborated on in the previous
section.[¶](#section-3.2-1){.pilcrow}

[Appendix A](#canonicalize.js){.xref} shows sample code for an
ECMAScript-based canonicalizer, matching the JCS
specification.[¶](#section-3.2-2){.pilcrow}

::: {#json.whitespace}
::: {#section-3.2.1 .section}
#### [3.2.1.](#section-3.2.1){.section-number .selfRef} [Whitespace](#name-whitespace){.section-name .selfRef} {#name-whitespace}

Whitespace between JSON tokens [MUST NOT]{.bcp14} be
emitted.[¶](#section-3.2.1-1){.pilcrow}
:::
:::

::: {#json.serialization.data}
::: {#section-3.2.2 .section}
#### [3.2.2.](#section-3.2.2){.section-number .selfRef} [Serialization of Primitive Data Types](#name-serialization-of-primitive-){.section-name .selfRef} {#name-serialization-of-primitive-}

Assume the following JSON object is
parsed:[¶](#section-3.2.2-1){.pilcrow}

::: {#section-3.2.2-2}
``` {.sourcecode .lang-json}
  {
    "numbers": [333333333.33333329, 1E30, 4.50,
                2e-3, 0.000000000000000000000000001],
    "string": "\u20ac$\u000F\u000aA'\u0042\u0022\u005c\\\"\/",
    "literals": [null, true, false]
  }
```

[¶](#section-3.2.2-2){.pilcrow}
:::

If the parsed data is subsequently serialized using a serializer
compliant with ECMAScript\'s \"JSON.stringify()\", the result would
(with a line wrap added for display purposes only) be rather divergent
with respect to the original data:[¶](#section-3.2.2-3){.pilcrow}

::: {#section-3.2.2-4}
``` {.sourcecode .lang-json}
  {"numbers":[333333333.3333333,1e+30,4.5,0.002,1e-27],"string":
  "€$\u000f\nA'B\"\\\\\"/","literals":[null,true,false]}
```

[¶](#section-3.2.2-4){.pilcrow}
:::

The reason for the difference between the parsed data and its serialized
counterpart is due to a wide tolerance on input data (as defined by JSON
\[[RFC8259](#RFC8259){.xref}\]), while output data (as defined by
ECMAScript) has a fixed representation. As can be seen in the example,
numbers are subject to rounding as well.[¶](#section-3.2.2-5){.pilcrow}

The following subsections describe the serialization of primitive JSON
data types according to JCS. This part is identical to that of
ECMAScript. In the (unlikely) event that a future version of ECMAScript
would invalidate any of the following serialization methods, it will be
up to the developer community to either stick to this specification or
create a new specification.[¶](#section-3.2.2-6){.pilcrow}

::: {#json.ser.literals}
::: {#section-3.2.2.1 .section}
##### [3.2.2.1.](#section-3.2.2.1){.section-number .selfRef} [Serialization of Literals](#name-serialization-of-literals){.section-name .selfRef} {#name-serialization-of-literals}

In accordance with JSON \[[RFC8259](#RFC8259){.xref}\], the literals
\"null\", \"true\", and \"false\" [MUST]{.bcp14} be serialized as null,
true, and false, respectively.[¶](#section-3.2.2.1-1){.pilcrow}
:::
:::

::: {#json.ser.string}
::: {#section-3.2.2.2 .section}
##### [3.2.2.2.](#section-3.2.2.2){.section-number .selfRef} [Serialization of Strings](#name-serialization-of-strings){.section-name .selfRef} {#name-serialization-of-strings}

For JSON string data (which includes JSON object property names as
well), each Unicode code point [MUST]{.bcp14} be serialized as described
below (see Section 24.3.2.2 of
\[[ECMA-262](#ECMA-262){.xref}\]):[¶](#section-3.2.2.2-1){.pilcrow}

-   [If the Unicode value falls within the traditional ASCII control
    character range (U+0000 through U+001F), it [MUST]{.bcp14} be
    serialized using lowercase hexadecimal Unicode notation (\\uhhhh)
    unless it is in the set of predefined JSON control characters
    U+0008, U+0009, U+000A, U+000C, or U+000D, which [MUST]{.bcp14} be
    serialized as \\b, \\t, \\n, \\f, and \\r,
    respectively.[¶](#section-3.2.2.2-2.1){.pilcrow}]{#section-3.2.2.2-2.1}
-   [If the Unicode value is outside of the ASCII control character
    range, it [MUST]{.bcp14} be serialized \"as is\" unless it is
    equivalent to U+005C (\\) or U+0022 (\"), which [MUST]{.bcp14} be
    serialized as \\\\ and \\\",
    respectively.[¶](#section-3.2.2.2-2.2){.pilcrow}]{#section-3.2.2.2-2.2}

Finally, the resulting sequence of Unicode code points [MUST]{.bcp14} be
enclosed in double quotes (\").[¶](#section-3.2.2.2-3){.pilcrow}

Note: Since invalid Unicode data like \"lone surrogates\" (e.g., U+DEAD)
may lead to interoperability issues including broken signatures,
occurrences of such data [MUST]{.bcp14} cause a compliant JCS
implementation to terminate with an appropriate
error.[¶](#section-3.2.2.2-4){.pilcrow}
:::
:::

::: {#json.ser.number}
::: {#section-3.2.2.3 .section}
##### [3.2.2.3.](#section-3.2.2.3){.section-number .selfRef} [Serialization of Numbers](#name-serialization-of-numbers){.section-name .selfRef} {#name-serialization-of-numbers}

ECMAScript builds on the IEEE 754 \[[IEEE754](#IEEE754){.xref}\]
double-precision standard for representing JSON number data. Such data
[MUST]{.bcp14} be serialized according to Section 7.1.12.1 of
\[[ECMA-262](#ECMA-262){.xref}\], including the \"Note 2\"
enhancement.[¶](#section-3.2.2.3-1){.pilcrow}

Due to the relative complexity of this part, the algorithm itself is not
included in this document. For implementers of JCS-compliant number
serialization, Google\'s implementation in V8 \[[V8](#V8){.xref}\] may
serve as a reference. Another compatible number serialization reference
implementation is Ryu \[[RYU](#RYU){.xref}\], which is used by the JCS
open-source Java implementation mentioned in [Appendix
G](#open.source){.xref}. [Appendix B](#json.ieee754.test){.xref} holds a
set of IEEE 754 sample values and their corresponding JSON
serialization.[¶](#section-3.2.2.3-2){.pilcrow}

Note: Since Not a Number (NaN) and Infinity are not permitted in JSON,
occurrences of NaN or Infinity [MUST]{.bcp14} cause a compliant JCS
implementation to terminate with an appropriate
error.[¶](#section-3.2.2.3-3){.pilcrow}
:::
:::
:::
:::

::: {#json.sorting.properties}
::: {#section-3.2.3 .section}
#### [3.2.3.](#section-3.2.3){.section-number .selfRef} [Sorting of Object Properties](#name-sorting-of-object-propertie){.section-name .selfRef} {#name-sorting-of-object-propertie}

Although the previous step normalized the representation of primitive
JSON data types, the result would not yet qualify as \"canonical\" since
JSON object properties are not in lexicographic (alphabetical)
order.[¶](#section-3.2.3-1){.pilcrow}

Applied to the sample in [Section
3.2.2](#json.serialization.data){.xref}, a properly canonicalized
version should (with a line wrap added for display purposes only) read
as:[¶](#section-3.2.3-2){.pilcrow}

::: {#section-3.2.3-3}
``` {.sourcecode .lang-json}
  {"literals":[null,true,false],"numbers":[333333333.3333333,
  1e+30,4.5,0.002,1e-27],"string":"€$\u000f\nA'B\"\\\\\"/"}
```

[¶](#section-3.2.3-3){.pilcrow}
:::

The rules for lexicographic sorting of JSON object properties according
to JCS are as follows:[¶](#section-3.2.3-4){.pilcrow}

-   [JSON object properties [MUST]{.bcp14} be sorted recursively, which
    means that JSON child Objects [MUST]{.bcp14} have their properties
    sorted as
    well.[¶](#section-3.2.3-5.1){.pilcrow}]{#section-3.2.3-5.1}
-   [JSON array data [MUST]{.bcp14} also be scanned for the presence of
    JSON objects (if an object is found, then its properties
    [MUST]{.bcp14} be sorted), but array element order [MUST
    NOT]{.bcp14} be
    changed.[¶](#section-3.2.3-5.2){.pilcrow}]{#section-3.2.3-5.2}

When a JSON object is about to have its properties sorted, the following
measures [MUST]{.bcp14} be adhered to:[¶](#section-3.2.3-6){.pilcrow}

-   [The sorting process is applied to property name strings in their
    \"raw\" (unescaped) form. That is, a newline character is treated as
    U+000A.[¶](#section-3.2.3-7.1){.pilcrow}]{#section-3.2.3-7.1}

-   [Property name strings to be sorted are formatted as arrays of
    UTF-16 \[[UNICODE](#UNICODE){.xref}\] code units. The sorting is
    based on pure value comparisons, where code units are treated as
    unsigned integers, independent of locale
    settings.[¶](#section-3.2.3-7.2){.pilcrow}]{#section-3.2.3-7.2}

-   ::: {#section-3.2.3-7.3}
    Property name strings either have different values at some index
    that is a valid index for both strings, or their lengths are
    different, or both. If they have different values at one or more
    index positions, let k be the smallest such index; then, the string
    whose value at position k has the smaller value, as determined by
    using the \"\<\" operator, lexicographically precedes the other
    string. If there is no index position at which they differ, then the
    shorter string lexicographically precedes the longer
    string.[¶](#section-3.2.3-7.3.1){.pilcrow}

    In plain English, this means that property names are sorted in
    ascending order like the
    following:[¶](#section-3.2.3-7.3.2){.pilcrow}

    ::: {#section-3.2.3-7.3.3 .artwork .art-text .alignLeft .art-ascii-art}
                ""
                "a"
                "aa"
                "ab"

    [¶](#section-3.2.3-7.3.3){.pilcrow}
    :::
    :::

The rationale for basing the sorting algorithm on UTF-16 code units is
that it maps directly to the string type in ECMAScript (featured in web
browsers and Node.js), Java, and .NET. In addition, JSON only supports
escape sequences expressed as UTF-16 code units, making knowledge and
handling of such data a necessity anyway. Systems using another internal
representation of string data will need to convert JSON property name
strings into arrays of UTF-16 code units before sorting. The conversion
from UTF-8 or UTF-32 to UTF-16 is defined by the Unicode
\[[UNICODE](#UNICODE){.xref}\] standard.[¶](#section-3.2.3-8){.pilcrow}

The following JSON test data can be used for verifying the correctness
of the sorting scheme in a JCS
implementation:[¶](#section-3.2.3-9){.pilcrow}

::: {#section-3.2.3-10}
``` {.sourcecode .lang-json}
  {
    "\u20ac": "Euro Sign",
    "\r": "Carriage Return",
    "\ufb33": "Hebrew Letter Dalet With Dagesh",
    "1": "One",
    "\ud83d\ude00": "Emoji: Grinning Face",
    "\u0080": "Control",
    "\u00f6": "Latin Small Letter O With Diaeresis"
  }
```

[¶](#section-3.2.3-10){.pilcrow}
:::

Expected argument order after sorting property
strings:[¶](#section-3.2.3-11){.pilcrow}

::: {#section-3.2.3-12 .artwork .art-text .alignLeft .art-ascii-art}
      "Carriage Return"
      "One"
      "Control"
      "Latin Small Letter O With Diaeresis"
      "Euro Sign"
      "Emoji: Grinning Face"
      "Hebrew Letter Dalet With Dagesh"

[¶](#section-3.2.3-12){.pilcrow}
:::

Note: For the purpose of obtaining a deterministic property order,
sorting of data encoded in UTF-8 or UTF-32 would also work, but the
outcome for JSON data like above would differ and thus be incompatible
with this specification. However, in practice, property names are rarely
defined outside of 7-bit ASCII, making it possible to sort string data
in UTF-8 or UTF-32 format without conversion to UTF-16 and still be
compatible with JCS. Whether or not this is a viable option depends on
the environment JCS is used in.[¶](#section-3.2.3-13){.pilcrow}
:::
:::

::: {#json.utf8}
::: {#section-3.2.4 .section}
#### [3.2.4.](#section-3.2.4){.section-number .selfRef} [UTF-8 Generation](#name-utf-8-generation){.section-name .selfRef} {#name-utf-8-generation}

Finally, in order to create a platform-independent representation, the
result of the preceding step [MUST]{.bcp14} be encoded in
UTF-8.[¶](#section-3.2.4-1){.pilcrow}

Applied to the sample in [Section
3.2.3](#json.sorting.properties){.xref}, this should yield the following
bytes, here shown in hexadecimal
notation:[¶](#section-3.2.4-2){.pilcrow}

::: {#section-3.2.4-3 .artwork .art-text .alignLeft .art-ascii-art}
      7b 22 6c 69 74 65 72 61 6c 73 22 3a 5b 6e 75 6c 6c 2c 74 72
      75 65 2c 66 61 6c 73 65 5d 2c 22 6e 75 6d 62 65 72 73 22 3a
      5b 33 33 33 33 33 33 33 33 33 2e 33 33 33 33 33 33 33 2c 31
      65 2b 33 30 2c 34 2e 35 2c 30 2e 30 30 32 2c 31 65 2d 32 37
      5d 2c 22 73 74 72 69 6e 67 22 3a 22 e2 82 ac 24 5c 75 30 30
      30 66 5c 6e 41 27 42 5c 22 5c 5c 5c 5c 5c 22 2f 22 7d

[¶](#section-3.2.4-3){.pilcrow}
:::

This data is intended to be usable as input to cryptographic
methods.[¶](#section-3.2.4-4){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#IANA}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-4-1){.pilcrow}
:::
:::

::: {#Security}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

It is crucial to perform sanity checks on input data to avoid
overflowing buffers and similar things that could affect the integrity
of the system.[¶](#section-5-1){.pilcrow}

When JCS is applied to signature schemes like the one described in
[Appendix F](#impl.guidelines){.xref}, applications [MUST]{.bcp14}
perform the following operations before acting upon received
data:[¶](#section-5-2){.pilcrow}

1.  [Parse the JSON data and verify that it adheres to
    I-JSON.[¶](#section-5-3.1){.pilcrow}]{#section-5-3.1}
2.  [Verify the data for correctness according to the conventions
    defined by the ecosystem where it is to be used. This also includes
    locating the property holding the signature
    data.[¶](#section-5-3.2){.pilcrow}]{#section-5-3.2}
3.  [Verify the signature.[¶](#section-5-3.3){.pilcrow}]{#section-5-3.3}

If any of these steps fail, the operation in progress [MUST]{.bcp14} be
aborted.[¶](#section-5-4){.pilcrow}
:::
:::

::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[ECMA-262\]
:   [ECMA International]{.refAuthor}, [\"ECMAScript 2019 Language
    Specification\"]{.refTitle}, [Standard ECMA-262 10th
    Edition]{.refContent}, June 2019,
    \<<https://www.ecma-international.org/ecma-262/10.0/index.html>\>.
:   

\[IEEE754\]
:   [IEEE]{.refAuthor}, [\"IEEE Standard for Floating-Point
    Arithmetic\"]{.refTitle}, [IEEE 754-2019]{.refContent}, [DOI
    10.1109/IEEESTD.2019.8766229]{.seriesInfo},
    \<<https://ieeexplore.ieee.org/document/8766229>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC7493\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The I-JSON Message
    Format\"]{.refTitle}, [RFC 7493]{.seriesInfo}, [DOI
    10.17487/RFC7493]{.seriesInfo}, March 2015,
    \<<https://www.rfc-editor.org/info/rfc7493>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8259\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The JavaScript Object Notation
    (JSON) Data Interchange Format\"]{.refTitle}, [STD 90]{.seriesInfo},
    [RFC 8259]{.seriesInfo}, [DOI 10.17487/RFC8259]{.seriesInfo},
    December 2017, \<<https://www.rfc-editor.org/info/rfc8259>\>.
:   

\[UCNORM\]
:   [The Unicode Consortium]{.refAuthor}, [\"Unicode Normalization
    Forms\"]{.refTitle}, \<<https://www.unicode.org/reports/tr15/>\>.
:   

\[UNICODE\]
:   [The Unicode Consortium]{.refAuthor}, [\"The Unicode
    Standard\"]{.refTitle},
    \<<https://www.unicode.org/versions/latest/>\>.
:   
:::

::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[JSONCOMP\]
:   [Rundgren, A.]{.refAuthor}, [\"\"Comparable\" JSON
    (JSONCOMP)\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-rundgren-comparable-json-04]{.seriesInfo}, 13
    February 2019,
    \<<https://tools.ietf.org/html/draft-rundgren-comparable-json-04>\>.
:   

\[KEYBASE\]
:   [Keybase]{.refAuthor}, [\"Canonical Packings for JSON and
    Msgpack\"]{.refTitle},
    \<<https://keybase.io/docs/api/1.0/canonical_packings>\>.
:   

\[NODEJS\]
:   [OpenJS Foundation]{.refAuthor}, [\"Node.js\"]{.refTitle},
    \<<https://nodejs.org>\>.
:   

\[OPENAPI\]
:   [OpenAPI Initiative]{.refAuthor}, [\"The OpenAPI Specification: a
    broadly adopted industry standard for describing modern
    APIs\"]{.refTitle}, \<<https://www.openapis.org/>\>.
:   

\[RFC4648\]
:   [Josefsson, S.]{.refAuthor}, [\"The Base16, Base32, and Base64 Data
    Encodings\"]{.refTitle}, [RFC 4648]{.seriesInfo}, [DOI
    10.17487/RFC4648]{.seriesInfo}, October 2006,
    \<<https://www.rfc-editor.org/info/rfc4648>\>.
:   

\[RFC7515\]
:   [Jones, M.]{.refAuthor}[, Bradley, J.]{.refAuthor}[, and N.
    Sakimura]{.refAuthor}, [\"JSON Web Signature (JWS)\"]{.refTitle},
    [RFC 7515]{.seriesInfo}, [DOI 10.17487/RFC7515]{.seriesInfo}, May
    2015, \<<https://www.rfc-editor.org/info/rfc7515>\>.
:   

\[RFC7638\]
:   [Jones, M.]{.refAuthor}[ and N. Sakimura]{.refAuthor}, [\"JSON Web
    Key (JWK) Thumbprint\"]{.refTitle}, [RFC 7638]{.seriesInfo}, [DOI
    10.17487/RFC7638]{.seriesInfo}, September 2015,
    \<<https://www.rfc-editor.org/info/rfc7638>\>.
:   

\[RYU\]
:   [\"Ryu floating point number serializing algorithm\"]{.refTitle},
    [commit 27d3c55]{.refContent}, May 2020,
    \<<https://github.com/ulfjack/ryu>\>.
:   

\[V8\]
:   [Google LLC]{.refAuthor}, [\"What is V8?\"]{.refTitle},
    \<<https://v8.dev/>\>.
:   

\[XMLDSIG\]
:   [W3C]{.refAuthor}, [\"XML Signature Syntax and Processing Version
    1.1\"]{.refTitle}, [W3C Recommendation]{.refContent}, April 2013,
    \<<https://www.w3.org/TR/xmldsig-core1/>\>.
:   
:::
:::

::: {#canonicalize.js}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [ECMAScript Sample Canonicalizer](#name-ecmascript-sample-canonical){.section-name .selfRef} {#name-ecmascript-sample-canonical}

Below is an example of a JCS canonicalizer for usage with
ECMAScript-based systems:[¶](#section-appendix.a-1){.pilcrow}

::: {#section-appendix.a-2}
``` {.sourcecode .lang-javascript}
  ////////////////////////////////////////////////////////////
  // Since the primary purpose of this code is highlighting //
  // the core of the JCS algorithm, error handling and      //
  // UTF-8 generation were not implemented.                 //
  ////////////////////////////////////////////////////////////
  var canonicalize = function(object) {

      var buffer = '';
      serialize(object);
      return buffer;

      function serialize(object) {
          if (object === null || typeof object !== 'object' ||
              object.toJSON != null) {
              /////////////////////////////////////////////////
              // Primitive type or toJSON, use "JSON"        //
              /////////////////////////////////////////////////
              buffer += JSON.stringify(object);

          } else if (Array.isArray(object)) {
              /////////////////////////////////////////////////
              // Array - Maintain element order              //
              /////////////////////////////////////////////////
              buffer += '[';
              let next = false;
              object.forEach((element) => {
                  if (next) {
                      buffer += ',';
                  }
                  next = true;
                  /////////////////////////////////////////
                  // Array element - Recursive expansion //
                  /////////////////////////////////////////
                  serialize(element);
              });
              buffer += ']';

          } else {
              /////////////////////////////////////////////////
              // Object - Sort properties before serializing //
              /////////////////////////////////////////////////
              buffer += '{';
              let next = false;
              Object.keys(object).sort().forEach((property) => {
                  if (next) {
                      buffer += ',';
                  }
                  next = true;
                  /////////////////////////////////////////////
                  // Property names are strings, use "JSON"  //
                  /////////////////////////////////////////////
                  buffer += JSON.stringify(property);
                  buffer += ':';
                  //////////////////////////////////////////
                  // Property value - Recursive expansion //
                  //////////////////////////////////////////
                  serialize(object[property]);
              });
              buffer += '}';
          }
      }
  };
```

[¶](#section-appendix.a-2){.pilcrow}
:::
:::
:::

::: {#json.ieee754.test}
::: {#section-appendix.b .section}
## [Appendix B.](#section-appendix.b){.section-number .selfRef} [Number Serialization Samples](#name-number-serialization-sample){.section-name .selfRef} {#name-number-serialization-sample}

The following table holds a set of ECMAScript-compatible number
serialization samples, including some edge cases. The column \"IEEE
754\" refers to the internal ECMAScript representation of the \"Number\"
data type, which is based on the IEEE 754 \[[IEEE754](#IEEE754){.xref}\]
standard using 64-bit (double-precision) values, here expressed in
hexadecimal.[¶](#section-appendix.b-1){.pilcrow}

[]{#name-ecmascript-compatible-json-}

::: {#ECMAScript-TABLE}
  IEEE 754             JSON Representation           Comment
  -------------------- ----------------------------- ----------------------
  `0000000000000000`   `0`                           `Zero`
  `8000000000000000`   `0`                           `Minus zero`
  `0000000000000001`   `5e-324`                      `Min pos number`
  `8000000000000001`   `-5e-324`                     `Min neg number`
  `7fefffffffffffff`   `1.7976931348623157e+308`     `Max pos number`
  `ffefffffffffffff`   `-1.7976931348623157e+308`    `Max neg number`
  `4340000000000000`   `9007199254740992`            `Max pos int    (1)`
  `c340000000000000`   `-9007199254740992`           `Max neg int    (1)`
  `4430000000000000`   `295147905179352830000`       `~2**68         (2)`
  `7fffffffffffffff`                                 `NaN            (3)`
  `7ff0000000000000`                                 `Infinity       (3)`
  `44b52d02c7e14af5`   `9.999999999999997e+22`       
  `44b52d02c7e14af6`   `1e+23`                       
  `44b52d02c7e14af7`   `1.0000000000000001e+23`      
  `444b1ae4d6e2ef4e`   `999999999999999700000`       
  `444b1ae4d6e2ef4f`   `999999999999999900000`       
  `444b1ae4d6e2ef50`   `1e+21`                       
  `3eb0c6f7a0b5ed8c`   `9.999999999999997e-7`        
  `3eb0c6f7a0b5ed8d`   `0.000001`                    
  `41b3de4355555553`   `333333333.3333332`           
  `41b3de4355555554`   `333333333.33333325`          
  `41b3de4355555555`   `333333333.3333333`           
  `41b3de4355555556`   `333333333.3333334`           
  `41b3de4355555557`   `333333333.33333343`          
  `becbf647612f3696`   `-0.0000033333333333333333`   
  `43143ff3c1cb0959`   `1424953923781206.2`          `Round to even  (4)`

  : [Table 1](#table-1){.selfRef}: [ECMAScript-Compatible JSON Number
  Serialization Samples](#name-ecmascript-compatible-json-){.selfRef}
:::

Notes:[¶](#section-appendix.b-3){.pilcrow}

[]{.break}

\(1\)
:   For maximum compliance with the ECMAScript \"JSON\" object, values
    that are to be interpreted as true integers [SHOULD]{.bcp14} be in
    the range -9007199254740991 to 9007199254740991. However, how
    numbers are used in applications does not affect the JCS
    algorithm.[¶](#section-appendix.b-4.1){.pilcrow}
:   

\(2\)
:   Although a set of specific integers like 2\*\*68 could be regarded
    as having extended precision, the JCS/ECMAScript number
    serialization algorithm does not take this into
    consideration.[¶](#section-appendix.b-4.2){.pilcrow}
:   

\(3\)
:   Values out of range are not permitted in JSON. See [Section
    3.2.2.3](#json.ser.number){.xref}.[¶](#section-appendix.b-4.3){.pilcrow}
:   

\(4\)
:   This number is exactly 1424953923781206.25 but will, after the
    \"Note 2\" rule mentioned in [Section
    3.2.2.3](#json.ser.number){.xref}, be truncated and rounded to the
    closest even value.[¶](#section-appendix.b-4.4){.pilcrow}
:   

For a more exhaustive validation of a JCS number serializer, you may
test against a file (currently) available in the development portal (see
[Appendix I](#json.development){.xref}) containing a large set of sample
values. Another option is running V8 \[[V8](#V8){.xref}\] as a live
reference together with a program generating a substantial amount of
random IEEE 754 values.[¶](#section-appendix.b-5){.pilcrow}
:::
:::

::: {#json.wireformat}
::: {#section-appendix.c .section}
## [Appendix C.](#section-appendix.c){.section-number .selfRef} [Canonicalized JSON as \"Wire Format\"](#name-canonicalized-json-as-wire-){.section-name .selfRef} {#name-canonicalized-json-as-wire-}

Since the result from the canonicalization process (see [Section
3.2.4](#json.utf8){.xref}) is fully valid JSON, it can also be used as
\"Wire Format\". However, this is just an option since cryptographic
schemes based on JCS, in most cases, would not depend on that externally
supplied JSON data already being
canonicalized.[¶](#section-appendix.c-1){.pilcrow}

In fact, the ECMAScript standard way of serializing objects using
\"JSON.stringify()\" produces a more \"logical\" format, where
properties are kept in the order they were created or received. The
example below shows an address record that could benefit from ECMAScript
standard serialization:[¶](#section-appendix.c-2){.pilcrow}

::: {#section-appendix.c-3}
``` {.sourcecode .lang-json}
  {
    "name": "John Doe",
    "address": "2000 Sunset Boulevard",
    "city": "Los Angeles",
    "zip": "90001",
    "state": "CA"
  }
```

[¶](#section-appendix.c-3){.pilcrow}
:::

Using canonicalization, the properties above would be output in the
order \"address\", \"city\", \"name\", \"state\", and \"zip\", which
adds fuzziness to the data from a human (developer or technical support)
perspective. Canonicalization also converts JSON data into a single line
of text, which may be less than ideal for debugging and
logging.[¶](#section-appendix.c-4){.pilcrow}
:::
:::

::: {#json.bignumbers}
::: {#section-appendix.d .section}
## [Appendix D.](#section-appendix.d){.section-number .selfRef} [Dealing with Big Numbers](#name-dealing-with-big-numbers){.section-name .selfRef} {#name-dealing-with-big-numbers}

There are several issues associated with the JSON number type, here
illustrated by the following sample
object:[¶](#section-appendix.d-1){.pilcrow}

::: {#section-appendix.d-2}
``` {.sourcecode .lang-json}
  {
    "giantNumber": 1.4e+9999,
    "payMeThis": 26000.33,
    "int64Max": 9223372036854775807
  }
```

[¶](#section-appendix.d-2){.pilcrow}
:::

Although the sample above conforms to JSON
\[[RFC8259](#RFC8259){.xref}\], applications would normally use
different native data types for storing \"giantNumber\" and
\"int64Max\". In addition, monetary data like \"payMeThis\" would
presumably not rely on floating-point data types due to rounding issues
with respect to decimal arithmetic.[¶](#section-appendix.d-3){.pilcrow}

The established way of handling this kind of \"overloading\" of the JSON
number type (at least in an extensible manner) is through mapping
mechanisms, instructing parsers what to do with different properties
based on their name. However, this greatly limits the value of using the
JSON number type outside of its original, somewhat constrained
JavaScript context. The ECMAScript \"JSON\" object does not support
mappings to the JSON number type
either.[¶](#section-appendix.d-4){.pilcrow}

Due to the above, numbers that do not have a natural place in the
current JSON ecosystem [MUST]{.bcp14} be wrapped using the JSON string
type. This is close to a de facto standard for open systems. This is
also applicable for other data types that do not have direct support in
JSON, like \"DateTime\" objects as described in [Appendix
E](#string.subtypes){.xref}.[¶](#section-appendix.d-5){.pilcrow}

Aided by a system using the JSON string type, be it programmatic
like[¶](#section-appendix.d-6){.pilcrow}

::: {#section-appendix.d-7}
``` sourcecode
  var obj = JSON.parse('{"giantNumber": "1.4e+9999"}');
  var biggie = new BigNumber(obj.giantNumber);
```

[¶](#section-appendix.d-7){.pilcrow}
:::

or declarative schemes like OpenAPI \[[OPENAPI](#OPENAPI){.xref}\], JCS
imposes no limits on applications, including when using
ECMAScript.[¶](#section-appendix.d-8){.pilcrow}
:::
:::

::: {#string.subtypes}
::: {#section-appendix.e .section}
## [Appendix E.](#section-appendix.e){.section-number .selfRef} [String Subtype Handling](#name-string-subtype-handling){.section-name .selfRef} {#name-string-subtype-handling}

Due to the limited set of data types featured in JSON, the JSON string
type is commonly used for holding subtypes. This can, depending on JSON
parsing method, lead to interoperability problems, which [MUST]{.bcp14}
be dealt with by JCS-compliant applications targeting a wider
audience.[¶](#section-appendix.e-1){.pilcrow}

Assume you want to parse a JSON object where the schema designer
assigned the property \"big\" for holding a \"BigInt\" subtype and
\"time\" for holding a \"DateTime\" subtype, while \"val\" is supposed
to be a JSON number compliant with JCS. The following example shows such
an object:[¶](#section-appendix.e-2){.pilcrow}

::: {#section-appendix.e-3}
``` {.sourcecode .lang-json}
  {
    "time": "2019-01-28T07:45:10Z",
    "big": "055",
    "val": 3.5
  }
```

[¶](#section-appendix.e-3){.pilcrow}
:::

Parsing of this object can be accomplished by the following ECMAScript
statement:[¶](#section-appendix.e-4){.pilcrow}

::: {#section-appendix.e-5}
``` sourcecode
  var object = JSON.parse(JSON_object_featured_as_a_string);
```

[¶](#section-appendix.e-5){.pilcrow}
:::

After parsing, the actual data can be extracted, which for subtypes,
also involves a conversion step using the result of the parsing process
(an ECMAScript object) as input:[¶](#section-appendix.e-6){.pilcrow}

::: {#section-appendix.e-7}
``` sourcecode
  ... = new Date(object.time); // Date object
  ... = BigInt(object.big);    // Big integer
  ... = object.val;            // JSON/JS number
```

[¶](#section-appendix.e-7){.pilcrow}
:::

Note that the \"BigInt\" data type is currently only natively supported
by V8 \[[V8](#V8){.xref}\].[¶](#section-appendix.e-8){.pilcrow}

Canonicalization of \"object\" using the sample code in [Appendix
A](#canonicalize.js){.xref} would return the following
string:[¶](#section-appendix.e-9){.pilcrow}

::: {#section-appendix.e-10}
``` {.sourcecode .lang-json}
  {"big":"055","time":"2019-01-28T07:45:10Z","val":3.5}
```

[¶](#section-appendix.e-10){.pilcrow}
:::

Although this is (with respect to JCS) technically correct, there is
another way of parsing JSON data, which also can be used with ECMAScript
as shown below:[¶](#section-appendix.e-11){.pilcrow}

::: {#section-appendix.e-12}
``` sourcecode
  // "BigInt" requires the following code to become JSON serializable
  BigInt.prototype.toJSON = function() {
      return this.toString();
  };

  // JSON parsing using a "stream"-based method
  var object = JSON.parse(JSON_object_featured_as_a_string,
      (k,v) => k == 'time' ? new Date(v) : k == 'big' ? BigInt(v) : v
  );
```

[¶](#section-appendix.e-12){.pilcrow}
:::

If you now apply the canonicalizer in [Appendix
A](#canonicalize.js){.xref} to \"object\", the following string would be
generated:[¶](#section-appendix.e-13){.pilcrow}

::: {#section-appendix.e-14}
``` {.sourcecode .lang-json}
  {"big":"55","time":"2019-01-28T07:45:10.000Z","val":3.5}
```

[¶](#section-appendix.e-14){.pilcrow}
:::

In this case, the string arguments for \"big\" and \"time\" have changed
with respect to the original, presumably making an application depending
on JCS fail.[¶](#section-appendix.e-15){.pilcrow}

The reason for the deviation is that in stream- and schema-based JSON
parsers, the original string argument is typically replaced on the fly
by the native subtype that, when serialized, may exhibit a different and
platform-dependent pattern.[¶](#section-appendix.e-16){.pilcrow}

That is, stream- and schema-based parsing [MUST]{.bcp14} treat subtypes
as \"pure\" (immutable) JSON string types and perform the actual
conversion to the designated native type in a subsequent step. In modern
programming platforms like Go, Java, and C#, this can be achieved with
moderate efforts by combining annotations, getters, and setters. Below
is an example in C#/Json.NET showing a part of a class that is
serializable as a JSON object:[¶](#section-appendix.e-17){.pilcrow}

::: {#section-appendix.e-18}
``` sourcecode
  // The "pure" string solution uses a local
  // string variable for JSON serialization while
  // exposing another type to the application
  [JsonProperty("amount")]
  private string _amount;

  [JsonIgnore]
  public decimal Amount {
      get { return decimal.Parse(_amount); }
      set { _amount = value.ToString(); }
  }
```

[¶](#section-appendix.e-18){.pilcrow}
:::

In an application, \"Amount\" can be accessed as any other property
while it is actually represented by a quoted string in JSON
contexts.[¶](#section-appendix.e-19){.pilcrow}

Note: The example above also addresses the constraints on numeric data
implied by I-JSON (the C# \"decimal\" data type has quite different
characteristics compared to IEEE 754 double
precision).[¶](#section-appendix.e-20){.pilcrow}

::: {#string.subtypes.arrays}
::: {#section-e.1 .section}
## [E.1.](#section-e.1){.section-number .selfRef} [Subtypes in Arrays](#name-subtypes-in-arrays){.section-name .selfRef} {#name-subtypes-in-arrays}

Since the JSON array construct permits mixing arbitrary JSON data types,
custom parsing and serialization code may be required to cope with
subtypes anyway.[¶](#section-e.1-1){.pilcrow}
:::
:::
:::
:::

::: {#impl.guidelines}
::: {#section-appendix.f .section}
## [Appendix F.](#section-appendix.f){.section-number .selfRef} [Implementation Guidelines](#name-implementation-guidelines){.section-name .selfRef} {#name-implementation-guidelines}

The optimal solution is integrating support for JCS directly in JSON
serializers (parsers need no changes). That is, canonicalization would
just be an additional \"mode\" for a JSON serializer. However, this is
currently not the case. Fortunately, JCS support can be introduced
through externally supplied canonicalizer software acting as a post
processor to existing JSON serializers. This arrangement also relieves
the JCS implementer from having to deal with how underlying data is to
be represented in JSON.[¶](#section-appendix.f-1){.pilcrow}

The post processor concept enables signature creation schemes like the
following:[¶](#section-appendix.f-2){.pilcrow}

1.  [Create the data to be
    signed.[¶](#section-appendix.f-3.1){.pilcrow}]{#section-appendix.f-3.1}
2.  [Serialize the data using existing JSON
    tools.[¶](#section-appendix.f-3.2){.pilcrow}]{#section-appendix.f-3.2}
3.  [Let the external canonicalizer process the serialized data and
    return canonicalized result
    data.[¶](#section-appendix.f-3.3){.pilcrow}]{#section-appendix.f-3.3}
4.  [Sign the canonicalized
    data.[¶](#section-appendix.f-3.4){.pilcrow}]{#section-appendix.f-3.4}
5.  [Add the resulting signature value to the original JSON data through
    a designated signature
    property.[¶](#section-appendix.f-3.5){.pilcrow}]{#section-appendix.f-3.5}
6.  [Serialize the completed (now signed) JSON object using existing
    JSON
    tools.[¶](#section-appendix.f-3.6){.pilcrow}]{#section-appendix.f-3.6}

A compatible signature verification scheme would then be as
follows:[¶](#section-appendix.f-4){.pilcrow}

1.  [Parse the signed JSON data using existing JSON
    tools.[¶](#section-appendix.f-5.1){.pilcrow}]{#section-appendix.f-5.1}
2.  [Read and save the signature value from the designated signature
    property.[¶](#section-appendix.f-5.2){.pilcrow}]{#section-appendix.f-5.2}
3.  [Remove the signature property from the parsed JSON
    object.[¶](#section-appendix.f-5.3){.pilcrow}]{#section-appendix.f-5.3}
4.  [Serialize the remaining JSON data using existing JSON
    tools.[¶](#section-appendix.f-5.4){.pilcrow}]{#section-appendix.f-5.4}
5.  [Let the external canonicalizer process the serialized data and
    return canonicalized result
    data.[¶](#section-appendix.f-5.5){.pilcrow}]{#section-appendix.f-5.5}
6.  [Verify that the canonicalized data matches the saved signature
    value using the algorithm and key used for creating the
    signature.[¶](#section-appendix.f-5.6){.pilcrow}]{#section-appendix.f-5.6}

A canonicalizer like above is effectively only a \"filter\", potentially
usable with a multitude of quite different cryptographic
schemes.[¶](#section-appendix.f-6){.pilcrow}

Using a JSON serializer with integrated JCS support, the serialization
performed before the canonicalization step could be eliminated for both
processes.[¶](#section-appendix.f-7){.pilcrow}
:::
:::

::: {#open.source}
::: {#section-appendix.g .section}
## [Appendix G.](#section-appendix.g){.section-number .selfRef} [Open-Source Implementations](#name-open-source-implementations){.section-name .selfRef} {#name-open-source-implementations}

The following open-source implementations have been verified to be
compatible with JCS:[¶](#section-appendix.g-1){.pilcrow}

-   [JavaScript:
    \<<https://www.npmjs.com/package/canonicalize>\>[¶](#section-appendix.g-2.1){.pilcrow}]{#section-appendix.g-2.1}
-   [Java:
    \<<https://github.com/erdtman/java-json-canonicalization>\>[¶](#section-appendix.g-2.2){.pilcrow}]{#section-appendix.g-2.2}
-   [Go:
    \<<https://github.com/cyberphone/json-canonicalization/tree/master/go>\>[¶](#section-appendix.g-2.3){.pilcrow}]{#section-appendix.g-2.3}
-   [.NET/C#:
    \<<https://github.com/cyberphone/json-canonicalization/tree/master/dotnet>\>[¶](#section-appendix.g-2.4){.pilcrow}]{#section-appendix.g-2.4}
-   [Python:
    \<<https://github.com/cyberphone/json-canonicalization/tree/master/python3>\>[¶](#section-appendix.g-2.5){.pilcrow}]{#section-appendix.g-2.5}
:::
:::

::: {#json.otherefforts}
::: {#section-appendix.h .section}
## [Appendix H.](#section-appendix.h){.section-number .selfRef} [Other JSON Canonicalization Efforts](#name-other-json-canonicalization){.section-name .selfRef} {#name-other-json-canonicalization}

There are (and have been) other efforts creating \"Canonical JSON\".
Below is a list of URLs to some of
them:[¶](#section-appendix.h-1){.pilcrow}

-   [\<<https://tools.ietf.org/html/draft-staykov-hu-json-canonical-form-00>\>[¶](#section-appendix.h-2.1){.pilcrow}]{#section-appendix.h-2.1}
-   [\<<https://gibson042.github.io/canonicaljson-spec/>\>[¶](#section-appendix.h-2.2){.pilcrow}]{#section-appendix.h-2.2}
-   [\<<http://wiki.laptop.org/go/Canonical_JSON>\>[¶](#section-appendix.h-2.3){.pilcrow}]{#section-appendix.h-2.3}

The listed efforts all build on text-level JSON-to-JSON transformations.
The primary feature of text-level canonicalization is that it can be
made neutral to the flavor of JSON used. However, such schemes also
imply major changes to the JSON parsing process, which is a likely
hurdle for adoption. Albeit at the expense of certain JSON and
application constraints, JCS was designed to be compatible with existing
JSON tools.[¶](#section-appendix.h-3){.pilcrow}
:::
:::

::: {#json.development}
::: {#section-appendix.i .section}
## [Appendix I.](#section-appendix.i){.section-number .selfRef} [Development Portal](#name-development-portal){.section-name .selfRef} {#name-development-portal}

The JCS specification is currently developed at:
\<<https://github.com/cyberphone/ietf-json-canon>\>.[¶](#section-appendix.i-1){.pilcrow}

JCS source code and extensive test data is available at:
\<<https://github.com/cyberphone/json-canonicalization>\>.[¶](#section-appendix.i-2){.pilcrow}
:::
:::

::: {#Acknowledgements}
::: {#section-appendix.j .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

Building on ECMAScript number serialization was originally proposed by
[James Manger]{.contact-name}. This ultimately led to the adoption of
the entire ECMAScript serialization scheme for JSON
primitives.[¶](#section-appendix.j-1){.pilcrow}

Other people who have contributed with valuable input to this
specification include [Scott Ananian]{.contact-name}, [Tim
Bray]{.contact-name}, [Ben Campbell]{.contact-name}, [Adrian
Farell]{.contact-name}, [Richard Gibson]{.contact-name}, [Bron
Gondwana]{.contact-name}, [John-Mark Gurney]{.contact-name}, [Mike
Jones,]{.contact-name} [John Levine]{.contact-name}, [Mark
Miller]{.contact-name}, [Matthew Miller]{.contact-name}, [Mark
Nottingham]{.contact-name}, [Mike Samuel]{.contact-name}, [Jim
Schaad]{.contact-name}, [Robert Tupelo-Schneck]{.contact-name}, and
[Michal Wadas]{.contact-name}.[¶](#section-appendix.j-2){.pilcrow}

For carrying out real-world concept verification, the software and
support for number serialization provided by [Ulf Adams]{.contact-name},
[Tanner Gooding]{.contact-name}, and [Remy Oudompheng]{.contact-name}
was very helpful.[¶](#section-appendix.j-3){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.k .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Anders Rundgren]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Independent]{.org}
:::

::: {.left dir="auto"}
[Montpellier]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <anders.rundgren.net@gmail.com>
:::

::: url
URI: <https://www.linkedin.com/in/andersrundgren/>
:::

::: {.left dir="auto"}
[Bret Jordan]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Broadcom]{.org}
:::

::: {.left dir="auto"}
[1320 Ridder Park Drive]{.street-address}
:::

::: {.left dir="auto"}
[San Jose]{.locality}, [CA]{.region} [95131]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <bret.jordan@broadcom.com>
:::

::: {.left dir="auto"}
[Samuel Erdtman]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Spotify AB]{.org}
:::

::: {.left dir="auto"}
[Birger Jarlsgatan 61, 4tr]{.street-address}
:::

::: {.left dir="auto"}
SE-[113 56]{.postal-code} [Stockholm]{.locality}
:::

::: {.left dir="auto"}
[Sweden]{.country-name}
:::

::: email
Email: <erdtman@spotify.com>
:::
:::
:::
