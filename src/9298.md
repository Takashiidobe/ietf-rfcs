  RFC 9298   Proxying UDP in HTTP   August 2022
  ---------- ---------------------- -------------
  Schinazi   Standards Track        \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9298](https://www.rfc-editor.org/rfc/rfc9298){.eref}

Category:
:   Standards Track

Published:
:   August 2022

ISSN:
:   2070-1721

Author:

:   ::: author
    ::: author-name
    D. Schinazi
    :::

    ::: org
    Google LLC
    :::
    :::
:::

# RFC 9298 {#rfcnum}

# Proxying UDP in HTTP {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes how to proxy UDP in HTTP, similar to how the
HTTP CONNECT method allows proxying TCP in HTTP. More specifically, this
document defines a protocol that allows an HTTP client to create a
tunnel for UDP communications through an HTTP server that acts as a
proxy.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9298>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Conventions and
        Definitions](#name-conventions-and-definitions){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Client
    Configuration](#name-client-configuration){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Tunneling UDP over
    HTTP](#name-tunneling-udp-over-http){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [UDP Proxy
        Handling](#name-udp-proxy-handling){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [HTTP/1.1
        Request](#name-http-11-request){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [HTTP/1.1
        Response](#name-http-11-response){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [HTTP/2 and HTTP/3
        Requests](#name-http-2-and-http-3-requests){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.5}
        [3.5](#section-3.5){.xref}.  [HTTP/2 and HTTP/3
        Responses](#name-http-2-and-http-3-responses){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Context
    Identifiers](#name-context-identifiers){.xref}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [HTTP Datagram Payload
    Format](#name-http-datagram-payload-forma){.xref}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Performance
    Considerations](#name-performance-considerations){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [MTU
        Considerations](#name-mtu-considerations){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Tunneling of ECN
        Marks](#name-tunneling-of-ecn-marks){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [HTTP Upgrade
        Token](#name-http-upgrade-token){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Well-Known
        URI](#name-well-known-uri){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [](#appendix-A){.xref}[Acknowledgments](#name-acknowledgments){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [](#appendix-B){.xref}[Author\'s
    Address](#name-authors-address){.xref}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

While HTTP provides the CONNECT method (see [Section
9.3.6](https://www.rfc-editor.org/rfc/rfc9110#section-9.3.6){.relref} of
\[[HTTP](#RFC9110){.xref}\]) for creating a TCP
\[[TCP](#RFC9293){.xref}\] tunnel to a proxy, it lacked a method for
doing so for UDP \[[UDP](#RFC0768){.xref}\] traffic prior to this
specification.[¶](#section-1-1){.pilcrow}

This document describes a protocol for tunneling UDP to a server acting
as a UDP-specific proxy over HTTP. UDP tunnels are commonly used to
create an end-to-end virtual connection, which can then be secured using
QUIC \[[QUIC](#RFC9000){.xref}\] or another protocol running over UDP.
Unlike the HTTP CONNECT method, the UDP proxy itself is identified with
an absolute URL containing the traffic\'s destination. Clients generate
those URLs using a URI Template \[[TEMPLATE](#RFC6570){.xref}\], as
described in [Section
2](#client-config){.xref}.[¶](#section-1-2){.pilcrow}

This protocol supports all existing versions of HTTP by using HTTP
Datagrams \[[HTTP-DGRAM](#RFC9297){.xref}\]. When using HTTP/2
\[[HTTP/2](#RFC9113){.xref}\] or HTTP/3 \[[HTTP/3](#RFC9114){.xref}\],
it uses HTTP Extended CONNECT as described in
\[[EXT-CONNECT2](#RFC8441){.xref}\] and
\[[EXT-CONNECT3](#RFC9220){.xref}\]. When using HTTP/1.x
\[[HTTP/1.1](#RFC9112){.xref}\], it uses HTTP Upgrade as defined in
[Section
7.8](https://www.rfc-editor.org/rfc/rfc9110#section-7.8){.relref} of
\[[HTTP](#RFC9110){.xref}\].[¶](#section-1-3){.pilcrow}

::: {#conventions}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Conventions and Definitions](#name-conventions-and-definitions){.section-name .selfRef} {#name-conventions-and-definitions}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-1){.pilcrow}

In this document, we use the term \"UDP proxy\" to refer to the HTTP
server that acts upon the client\'s UDP tunneling request to open a UDP
socket to a target server and that generates the response to this
request. If there are HTTP intermediaries (as defined in [Section
3.7](https://www.rfc-editor.org/rfc/rfc9110#section-3.7){.relref} of
\[[HTTP](#RFC9110){.xref}\]) between the client and the UDP proxy, those
are referred to as \"intermediaries\" in this
document.[¶](#section-1.1-2){.pilcrow}

Note that, when the HTTP version in use does not support multiplexing
streams (such as HTTP/1.1), any reference to \"stream\" in this document
represents the entire connection.[¶](#section-1.1-3){.pilcrow}
:::
:::
:::
:::

::: {#client-config}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Client Configuration](#name-client-configuration){.section-name .selfRef} {#name-client-configuration}

HTTP clients are configured to use a UDP proxy with a URI Template
\[[TEMPLATE](#RFC6570){.xref}\] that has the variables \"target_host\"
and \"target_port\". Examples are shown
below:[¶](#section-2-1){.pilcrow}

[]{#name-uri-template-examples}

::: {#fig-template-examples}
::: {#section-2-2.1 .alignLeft .art-ascii-art .art-text .artwork}
    https://example.org/.well-known/masque/udp/{target_host}/{target_port}/
    https://proxy.example.org:4443/masque?h={target_host}&p={target_port}
    https://proxy.example.org:4443/masque{?target_host,target_port}
:::

[Figure 1](#figure-1){.selfRef}: [URI Template
Examples](#name-uri-template-examples){.selfRef}
:::

The following requirements apply to the URI
Template:[¶](#section-2-3){.pilcrow}

-   [The URI Template [MUST]{.bcp14} be a level 3 template or
    lower.[¶](#section-2-4.1){.pilcrow}]{#section-2-4.1}
-   [The URI Template [MUST]{.bcp14} be in absolute form and
    [MUST]{.bcp14} include non-empty scheme, authority, and path
    components.[¶](#section-2-4.2){.pilcrow}]{#section-2-4.2}
-   [The path component of the URI Template [MUST]{.bcp14} start with a
    slash (\"/\").[¶](#section-2-4.3){.pilcrow}]{#section-2-4.3}
-   [All template variables [MUST]{.bcp14} be within the path or query
    components of the URI.[¶](#section-2-4.4){.pilcrow}]{#section-2-4.4}
-   [The URI Template [MUST]{.bcp14} contain the two variables
    \"target_host\" and \"target_port\" and [MAY]{.bcp14} contain other
    variables.[¶](#section-2-4.5){.pilcrow}]{#section-2-4.5}
-   [The URI Template [MUST NOT]{.bcp14} contain any non-ASCII Unicode
    characters and [MUST]{.bcp14} only contain ASCII characters in the
    range 0x21-0x7E inclusive (note that percent-encoding is allowed;
    see [Section
    2.1](https://www.rfc-editor.org/rfc/rfc3986#section-2.1){.relref} of
    \[[URI](#RFC3986){.xref}\]).[¶](#section-2-4.6){.pilcrow}]{#section-2-4.6}
-   [The URI Template [MUST NOT]{.bcp14} use Reserved Expansion (\"+\"
    operator), Fragment Expansion (\"#\" operator), Label Expansion with
    Dot-Prefix, Path Segment Expansion with Slash-Prefix, nor Path-Style
    Parameter Expansion with
    Semicolon-Prefix.[¶](#section-2-4.7){.pilcrow}]{#section-2-4.7}

Clients [SHOULD]{.bcp14} validate the requirements above; however,
clients [MAY]{.bcp14} use a general-purpose URI Template implementation
that lacks this specific validation. If a client detects that any of the
requirements above are not met by a URI Template, the client
[MUST]{.bcp14} reject its configuration and abort the request without
sending it to the UDP proxy.[¶](#section-2-5){.pilcrow}

The original HTTP CONNECT method allowed for the conveyance of the
target host and port, but not the scheme, proxy authority, path, or
query. Thus, clients with proxy configuration interfaces that only allow
the user to configure the proxy host and the proxy port exist. Client
implementations of this specification that are constrained by such
limitations [MAY]{.bcp14} attempt to access UDP proxying capabilities
using the default template, which is defined as
\"https://\$PROXY_HOST:\$PROXY_PORT/.well-known/masque/udp/{target_host}/{target_port}/\",
where \$PROXY_HOST and \$PROXY_PORT are the configured host and port of
the UDP proxy, respectively. UDP proxy deployments [SHOULD]{.bcp14}
offer service at this location if they need to interoperate with such
clients.[¶](#section-2-6){.pilcrow}
:::
:::

::: {#tunneling-udp-over-http}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Tunneling UDP over HTTP](#name-tunneling-udp-over-http){.section-name .selfRef} {#name-tunneling-udp-over-http}

To allow negotiation of a tunnel for UDP over HTTP, this document
defines the \"connect-udp\" HTTP upgrade token. The resulting UDP
tunnels use the Capsule Protocol (see [Section
3.2](https://www.rfc-editor.org/rfc/rfc9297#section-3.2){.relref} of
\[[HTTP-DGRAM](#RFC9297){.xref}\]) with HTTP Datagrams in the format
defined in [Section 5](#format){.xref}.[¶](#section-3-1){.pilcrow}

To initiate a UDP tunnel associated with a single HTTP stream, a client
issues a request containing the \"connect-udp\" upgrade token. The
target of the tunnel is indicated by the client to the UDP proxy via the
\"target_host\" and \"target_port\" variables of the URI Template; see
[Section 2](#client-config){.xref}.[¶](#section-3-2){.pilcrow}

\"target_host\" supports using DNS names, IPv6 literals and IPv4
literals. Note that IPv6 scoped addressing zone identifiers are not
supported. Using the terms IPv6address, IPv4address, reg-name, and port
from \[[URI](#RFC3986){.xref}\], the \"target_host\" and \"target_port\"
variables [MUST]{.bcp14} adhere to the format in [Figure
2](#target-format){.xref}, using notation from
\[[ABNF](#RFC2234){.xref}\]. Additionally:[¶](#section-3-3){.pilcrow}

-   [both the \"target_host\" and \"target_port\" variables [MUST
    NOT]{.bcp14} be empty.[¶](#section-3-4.1){.pilcrow}]{#section-3-4.1}
-   [if \"target_host\" contains an IPv6 literal, the colons (\":\")
    [MUST]{.bcp14} be percent-encoded. For example, if the target host
    is \"2001:db8::42\", it will be encoded in the URI as
    \"2001%3Adb8%3A%3A42\".[¶](#section-3-4.2){.pilcrow}]{#section-3-4.2}
-   [\"target_port\" [MUST]{.bcp14} represent an integer between 1 and
    65535 inclusive.[¶](#section-3-4.3){.pilcrow}]{#section-3-4.3}

[]{#name-uri-template-variable-forma}

::: {#target-format}
::: {#section-3-5.1 .alignLeft .art-ascii-art .art-text .artwork}
    target_host = IPv6address / IPv4address / reg-name
    target_port = port
:::

[Figure 2](#figure-2){.selfRef}: [URI Template Variable
Format](#name-uri-template-variable-forma){.selfRef}
:::

When sending its UDP proxying request, the client [SHALL]{.bcp14}
perform URI Template expansion to determine the path and query of its
request.[¶](#section-3-6){.pilcrow}

If the request is successful, the UDP proxy commits to converting
received HTTP Datagrams into UDP packets, and vice versa, until the
tunnel is closed.[¶](#section-3-7){.pilcrow}

By virtue of the definition of the Capsule Protocol (see [Section
3.2](https://www.rfc-editor.org/rfc/rfc9297#section-3.2){.relref} of
\[[HTTP-DGRAM](#RFC9297){.xref}\]), UDP proxying requests do not carry
any message content. Similarly, successful UDP proxying responses also
do not carry any message content.[¶](#section-3-8){.pilcrow}

::: {#handling}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [UDP Proxy Handling](#name-udp-proxy-handling){.section-name .selfRef} {#name-udp-proxy-handling}

Upon receiving a UDP proxying request:[¶](#section-3.1-1){.pilcrow}

-   [if the recipient is configured to use another HTTP proxy, it will
    act as an intermediary by forwarding the request to another HTTP
    server. Note that such intermediaries may need to re-encode the
    request if they forward it using a version of HTTP that is different
    from the one used to receive it, as the request encoding differs by
    version (see
    below).[¶](#section-3.1-2.1){.pilcrow}]{#section-3.1-2.1}
-   [otherwise, the recipient will act as a UDP proxy. It extracts the
    \"target_host\" and \"target_port\" variables from the URI it has
    reconstructed from the request headers, decodes their
    percent-encoding, and establishes a tunnel by directly opening a UDP
    socket to the requested
    target.[¶](#section-3.1-2.2){.pilcrow}]{#section-3.1-2.2}

Unlike TCP, UDP is connectionless. The UDP proxy that opens the UDP
socket has no way of knowing whether the destination is reachable.
Therefore, it needs to respond to the request without waiting for a
packet from the target. However, if the \"target_host\" is a DNS name,
the UDP proxy [MUST]{.bcp14} perform DNS resolution before replying to
the HTTP request. If errors occur during this process, the UDP proxy
[MUST]{.bcp14} reject the request and [SHOULD]{.bcp14} send details
using an appropriate Proxy-Status header field
\[[PROXY-STATUS](#RFC9209){.xref}\]. For example, if DNS resolution
returns an error, the proxy can use the dns_error Proxy Error Type from
[Section
2.3.2](https://www.rfc-editor.org/rfc/rfc9209#section-2.3.2){.relref} of
\[[PROXY-STATUS](#RFC9209){.xref}\].[¶](#section-3.1-3){.pilcrow}

UDP proxies can use connected UDP sockets if their operating system
supports them, as that allows the UDP proxy to rely on the kernel to
only send it UDP packets that match the correct 5-tuple. If the UDP
proxy uses a non-connected socket, it [MUST]{.bcp14} validate the IP
source address and UDP source port on received packets to ensure they
match the client\'s request. Packets that do not match [MUST]{.bcp14} be
discarded by the UDP proxy.[¶](#section-3.1-4){.pilcrow}

The lifetime of the socket is tied to the request stream. The UDP proxy
[MUST]{.bcp14} keep the socket open while the request stream is open. If
a UDP proxy is notified by its operating system that its socket is no
longer usable, it [MUST]{.bcp14} close the request stream. For example,
this can happen when an ICMP Destination Unreachable message is
received; see [Section
3.1](https://www.rfc-editor.org/rfc/rfc4443#section-3.1){.relref} of
\[[ICMP6](#RFC4443){.xref}\]. UDP proxies [MAY]{.bcp14} choose to close
sockets due to a period of inactivity, but they [MUST]{.bcp14} close the
request stream when closing the socket. UDP proxies that close sockets
after a period of inactivity [SHOULD NOT]{.bcp14} use a period lower
than two minutes; see [Section
4.3](https://www.rfc-editor.org/rfc/rfc4787#section-4.3){.relref} of
\[[BEHAVE](#RFC4787){.xref}\].[¶](#section-3.1-5){.pilcrow}

A successful response (as defined in Sections [3.3](#resp1){.xref} and
[3.5](#resp23){.xref}) indicates that the UDP proxy has opened a socket
to the requested target and is willing to proxy UDP payloads. Any
response other than a successful response indicates that the request has
failed; thus, the client [MUST]{.bcp14} abort the
request.[¶](#section-3.1-6){.pilcrow}

UDP proxies [MUST NOT]{.bcp14} introduce fragmentation at the IP layer
when forwarding HTTP Datagrams onto a UDP socket; overly large datagrams
are silently dropped. In IPv4, the Don\'t Fragment (DF) bit
[MUST]{.bcp14} be set, if possible, to prevent fragmentation on the
path. Future extensions [MAY]{.bcp14} remove these
requirements.[¶](#section-3.1-7){.pilcrow}

Implementers of UDP proxies will benefit from reading the guidance in
\[[UDP-USAGE](#RFC8085){.xref}\].[¶](#section-3.1-8){.pilcrow}
:::
:::

::: {#req1}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [HTTP/1.1 Request](#name-http-11-request){.section-name .selfRef} {#name-http-11-request}

When using HTTP/1.1 \[[HTTP/1.1](#RFC9112){.xref}\], a UDP proxying
request will meet the following
requirements:[¶](#section-3.2-1){.pilcrow}

-   [the method [SHALL]{.bcp14} be
    \"GET\".[¶](#section-3.2-2.1){.pilcrow}]{#section-3.2-2.1}
-   [the request [SHALL]{.bcp14} include a single Host header field
    containing the origin of the UDP
    proxy.[¶](#section-3.2-2.2){.pilcrow}]{#section-3.2-2.2}
-   [the request [SHALL]{.bcp14} include a Connection header field with
    value \"Upgrade\" (note that this requirement is case-insensitive as
    per [Section
    7.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1){.relref}
    of
    \[[HTTP](#RFC9110){.xref}\]).[¶](#section-3.2-2.3){.pilcrow}]{#section-3.2-2.3}
-   [the request [SHALL]{.bcp14} include an Upgrade header field with
    value
    \"connect-udp\".[¶](#section-3.2-2.4){.pilcrow}]{#section-3.2-2.4}

A UDP proxying request that does not conform to these restrictions is
malformed. The recipient of such a malformed request [MUST]{.bcp14}
respond with an error and [SHOULD]{.bcp14} use the 400 (Bad Request)
status code.[¶](#section-3.2-3){.pilcrow}

For example, if the client is configured with URI Template
\"https://example.org/.well-known/masque/udp/{target_host}/{target_port}/\"
and wishes to open a UDP proxying tunnel to target 192.0.2.6:443, it
could send the following request:[¶](#section-3.2-4){.pilcrow}

[]{#name-example-http-11-request}

::: {#fig-req-h1}
::: {#section-3.2-5.1 .alignLeft .art-text .artwork}
    GET https://example.org/.well-known/masque/udp/192.0.2.6/443/ HTTP/1.1
    Host: example.org
    Connection: Upgrade
    Upgrade: connect-udp
    Capsule-Protocol: ?1
:::

[Figure 3](#figure-3){.selfRef}: [Example HTTP/1.1
Request](#name-example-http-11-request){.selfRef}
:::

In HTTP/1.1, this protocol uses the GET method to mimic the design of
the WebSocket Protocol
\[[WEBSOCKET](#RFC6455){.xref}\].[¶](#section-3.2-6){.pilcrow}
:::
:::

::: {#resp1}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [HTTP/1.1 Response](#name-http-11-response){.section-name .selfRef} {#name-http-11-response}

The UDP proxy [SHALL]{.bcp14} indicate a successful response by replying
with the following requirements:[¶](#section-3.3-1){.pilcrow}

-   [the HTTP status code on the response [SHALL]{.bcp14} be 101
    (Switching
    Protocols).[¶](#section-3.3-2.1){.pilcrow}]{#section-3.3-2.1}
-   [the response [SHALL]{.bcp14} include a Connection header field with
    value \"Upgrade\" (note that this requirement is case-insensitive as
    per [Section
    7.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1){.relref}
    of
    \[[HTTP](#RFC9110){.xref}\]).[¶](#section-3.3-2.2){.pilcrow}]{#section-3.3-2.2}
-   [the response [SHALL]{.bcp14} include a single Upgrade header field
    with value
    \"connect-udp\".[¶](#section-3.3-2.3){.pilcrow}]{#section-3.3-2.3}
-   [the response [SHALL]{.bcp14} meet the requirements of HTTP
    responses that start the Capsule Protocol; see [Section
    3.2](https://www.rfc-editor.org/rfc/rfc9297#section-3.2){.relref} of
    \[[HTTP-DGRAM](#RFC9297){.xref}\].[¶](#section-3.3-2.4){.pilcrow}]{#section-3.3-2.4}

If any of these requirements are not met, the client [MUST]{.bcp14}
treat this proxying attempt as failed and abort the
connection.[¶](#section-3.3-3){.pilcrow}

For example, the UDP proxy could respond
with:[¶](#section-3.3-4){.pilcrow}

[]{#name-example-http-11-response}

::: {#fig-resp-h1}
::: {#section-3.3-5.1}
``` {.lang-http-message .sourcecode}
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: connect-udp
Capsule-Protocol: ?1
```
:::

[Figure 4](#figure-4){.selfRef}: [Example HTTP/1.1
Response](#name-example-http-11-response){.selfRef}
:::
:::
:::

::: {#req23}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [HTTP/2 and HTTP/3 Requests](#name-http-2-and-http-3-requests){.section-name .selfRef} {#name-http-2-and-http-3-requests}

When using HTTP/2 \[[HTTP/2](#RFC9113){.xref}\] or HTTP/3
\[[HTTP/3](#RFC9114){.xref}\], UDP proxying requests use HTTP Extended
CONNECT. This requires that servers send an HTTP Setting as specified in
\[[EXT-CONNECT2](#RFC8441){.xref}\] and
\[[EXT-CONNECT3](#RFC9220){.xref}\] and that requests use HTTP
pseudo-header fields with the following
requirements:[¶](#section-3.4-1){.pilcrow}

-   [The :method pseudo-header field [SHALL]{.bcp14} be
    \"CONNECT\".[¶](#section-3.4-2.1){.pilcrow}]{#section-3.4-2.1}
-   [The :protocol pseudo-header field [SHALL]{.bcp14} be
    \"connect-udp\".[¶](#section-3.4-2.2){.pilcrow}]{#section-3.4-2.2}
-   [The :authority pseudo-header field [SHALL]{.bcp14} contain the
    authority of the UDP
    proxy.[¶](#section-3.4-2.3){.pilcrow}]{#section-3.4-2.3}
-   [The :path and :scheme pseudo-header fields [SHALL NOT]{.bcp14} be
    empty. Their values [SHALL]{.bcp14} contain the scheme and path from
    the URI Template after the URI Template expansion process has been
    completed.[¶](#section-3.4-2.4){.pilcrow}]{#section-3.4-2.4}

A UDP proxying request that does not conform to these restrictions is
malformed (see [Section
8.1.1](https://www.rfc-editor.org/rfc/rfc9113#section-8.1.1){.relref} of
\[[HTTP/2](#RFC9113){.xref}\] and [Section
4.1.2](https://www.rfc-editor.org/rfc/rfc9114#section-4.1.2){.relref} of
\[[HTTP/3](#RFC9114){.xref}\]).[¶](#section-3.4-3){.pilcrow}

For example, if the client is configured with URI Template
\"https://example.org/.well-known/masque/udp/{target_host}/{target_port}/\"
and wishes to open a UDP proxying tunnel to target 192.0.2.6:443, it
could send the following request:[¶](#section-3.4-4){.pilcrow}

[]{#name-example-http-2-request}

::: {#fig-req-h2}
::: {#section-3.4-5.1}
``` {.lang-http-message .sourcecode}
HEADERS
:method = CONNECT
:protocol = connect-udp
:scheme = https
:path = /.well-known/masque/udp/192.0.2.6/443/
:authority = example.org
capsule-protocol = ?1
```
:::

[Figure 5](#figure-5){.selfRef}: [Example HTTP/2
Request](#name-example-http-2-request){.selfRef}
:::
:::
:::

::: {#resp23}
::: {#section-3.5 .section}
### [3.5.](#section-3.5){.section-number .selfRef} [HTTP/2 and HTTP/3 Responses](#name-http-2-and-http-3-responses){.section-name .selfRef} {#name-http-2-and-http-3-responses}

The UDP proxy [SHALL]{.bcp14} indicate a successful response by replying
with the following requirements:[¶](#section-3.5-1){.pilcrow}

-   [the HTTP status code on the response [SHALL]{.bcp14} be in the 2xx
    (Successful)
    range.[¶](#section-3.5-2.1){.pilcrow}]{#section-3.5-2.1}
-   [the response [SHALL]{.bcp14} meet the requirements of HTTP
    responses that start the Capsule Protocol; see [Section
    3.2](https://www.rfc-editor.org/rfc/rfc9297#section-3.2){.relref} of
    \[[HTTP-DGRAM](#RFC9297){.xref}\].[¶](#section-3.5-2.2){.pilcrow}]{#section-3.5-2.2}

If any of these requirements are not met, the client [MUST]{.bcp14}
treat this proxying attempt as failed and abort the
request.[¶](#section-3.5-3){.pilcrow}

For example, the UDP proxy could respond
with:[¶](#section-3.5-4){.pilcrow}

[]{#name-example-http-2-response}

::: {#fig-resp-h2}
::: {#section-3.5-5.1}
``` {.lang-http-message .sourcecode}
HEADERS
:status = 200
capsule-protocol = ?1
```
:::

[Figure 6](#figure-6){.selfRef}: [Example HTTP/2
Response](#name-example-http-2-response){.selfRef}
:::
:::
:::
:::
:::

::: {#context-id}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Context Identifiers](#name-context-identifiers){.section-name .selfRef} {#name-context-identifiers}

The mechanism for proxying UDP in HTTP defined in this document allows
future extensions to exchange HTTP Datagrams that carry different
semantics from UDP payloads. Some of these extensions can augment UDP
payloads with additional data, while others can exchange data that is
completely separate from UDP payloads. In order to accomplish this, all
HTTP Datagrams associated with UDP Proxying request streams start with a
Context ID field; see [Section
5](#format){.xref}.[¶](#section-4-1){.pilcrow}

Context IDs are 62-bit integers (0 to 2^62^-1). Context IDs are encoded
as variable-length integers; see [Section
16](https://www.rfc-editor.org/rfc/rfc9000#section-16){.relref} of
\[[QUIC](#RFC9000){.xref}\]. The Context ID value of 0 is reserved for
UDP payloads, while non-zero values are dynamically allocated. Non-zero
even-numbered Context IDs are client-allocated, and odd-numbered Context
IDs are proxy-allocated. The Context ID namespace is tied to a given
HTTP request; it is possible for a Context ID with the same numeric
value to be simultaneously allocated in distinct requests, potentially
with different semantics. Context IDs [MUST NOT]{.bcp14} be re-allocated
within a given HTTP namespace but [MAY]{.bcp14} be allocated in any
order. The Context ID allocation restrictions to the use of
even-numbered and odd-numbered Context IDs exist in order to avoid the
need for synchronization between endpoints. However, once a Context ID
has been allocated, those restrictions do not apply to the use of the
Context ID; it can be used by any client or UDP proxy, independent of
which endpoint initially allocated it.[¶](#section-4-2){.pilcrow}

Registration is the action by which an endpoint informs its peer of the
semantics and format of a given Context ID. This document does not
define how registration occurs. Future extensions [MAY]{.bcp14} use HTTP
header fields or capsules to register Context IDs. Depending on the
method being used, it is possible for datagrams to be received with
Context IDs that have not yet been registered. For instance, this can be
due to reordering of the packet containing the datagram and the packet
containing the registration message during
transmission.[¶](#section-4-3){.pilcrow}
:::
:::

::: {#format}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [HTTP Datagram Payload Format](#name-http-datagram-payload-forma){.section-name .selfRef} {#name-http-datagram-payload-forma}

When HTTP Datagrams (see [Section
2](https://www.rfc-editor.org/rfc/rfc9297#section-2){.relref} of
\[[HTTP-DGRAM](#RFC9297){.xref}\]) are associated with UDP Proxying
request streams, the HTTP Datagram Payload field has the format defined
in [Figure 7](#dgram-format){.xref}, using notation from [Section
1.3](https://www.rfc-editor.org/rfc/rfc9000#section-1.3){.relref} of
\[[QUIC](#RFC9000){.xref}\]. Note that when HTTP Datagrams are encoded
using QUIC DATAGRAM frames \[[QUIC-DGRAM](#RFC9221){.xref}\], the
Context ID field defined below directly follows the Quarter Stream ID
field, which is at the start of the QUIC DATAGRAM frame payload; see
[Section
2.1](https://www.rfc-editor.org/rfc/rfc9297#section-2.1){.relref} of
\[[HTTP-DGRAM](#RFC9297){.xref}\].[¶](#section-5-1){.pilcrow}

[]{#name-udp-proxying-http-datagram-}

::: {#dgram-format}
::: {#section-5-2.1 .alignLeft .art-ascii-art .art-text .artwork}
    UDP Proxying HTTP Datagram Payload {
      Context ID (i),
      UDP Proxying Payload (..),
    }
:::

[Figure 7](#figure-7){.selfRef}: [UDP Proxying HTTP Datagram
Format](#name-udp-proxying-http-datagram-){.selfRef}
:::

[]{.break}

Context ID:

:   A variable-length integer (see [Section
    16](https://www.rfc-editor.org/rfc/rfc9000#section-16){.relref} of
    \[[QUIC](#RFC9000){.xref}\]) that contains the value of the Context
    ID. If an HTTP/3 Datagram that carries an unknown Context ID is
    received, the receiver [SHALL]{.bcp14} either drop that datagram
    silently or buffer it temporarily (on the order of a round trip)
    while awaiting the registration of the corresponding Context
    ID.[¶](#section-5-3.2.1){.pilcrow}

:   

UDP Proxying Payload:

:   The payload of the datagram, whose semantics depend on the value of
    the previous field. Note that this field can be
    empty.[¶](#section-5-3.4.1){.pilcrow}

:   

UDP packets are encoded using HTTP Datagrams with the Context ID field
set to zero. When the Context ID field is set to zero, the UDP Proxying
Payload field contains the unmodified payload of a UDP packet (referred
to as data octets in
\[[UDP](#RFC0768){.xref}\]).[¶](#section-5-4){.pilcrow}

By virtue of the definition of the UDP header
\[[UDP](#RFC0768){.xref}\], it is not possible to encode UDP payloads
longer than 65527 bytes. Therefore, endpoints [MUST NOT]{.bcp14} send
HTTP Datagrams with a UDP Proxying Payload field longer than 65527 using
Context ID zero. An endpoint that receives an HTTP Datagram using
Context ID zero whose UDP Proxying Payload field is longer than 65527
[MUST]{.bcp14} abort the corresponding stream. If a UDP proxy knows it
can only send out UDP packets of a certain length due to its underlying
link MTU, it has no choice but to discard incoming HTTP Datagrams using
Context ID zero whose UDP Proxying Payload field is longer than that
limit. If the discarded HTTP Datagram was transported by a DATAGRAM
capsule, the receiver [SHOULD]{.bcp14} discard that capsule without
buffering the capsule contents.[¶](#section-5-5){.pilcrow}

If a UDP proxy receives an HTTP Datagram before it has received the
corresponding request, it [SHALL]{.bcp14} either drop that HTTP Datagram
silently or buffer it temporarily (on the order of a round trip) while
awaiting the corresponding request.[¶](#section-5-6){.pilcrow}

Note that buffering datagrams (either because the request was not yet
received or because the Context ID is not yet known) consumes resources.
Receivers that buffer datagrams [SHOULD]{.bcp14} apply buffering limits
in order to reduce the risk of resource exhaustion occurring. For
example, receivers can limit the total number of buffered datagrams or
the cumulative size of buffered datagrams on a per-stream, per-context,
or per-connection basis.[¶](#section-5-7){.pilcrow}

A client [MAY]{.bcp14} optimistically start sending UDP packets in HTTP
Datagrams before receiving the response to its UDP proxying request.
However, implementers should note that such proxied packets may not be
processed by the UDP proxy if it responds to the request with a failure
or if the proxied packets are received by the UDP proxy before the
request and the UDP proxy chooses to not buffer
them.[¶](#section-5-8){.pilcrow}
:::
:::

::: {#performance}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Performance Considerations](#name-performance-considerations){.section-name .selfRef} {#name-performance-considerations}

Bursty traffic can often lead to temporally correlated packet losses; in
turn, this can lead to suboptimal responses from congestion controllers
in protocols running over UDP. To avoid this, UDP proxies
[SHOULD]{.bcp14} strive to avoid increasing burstiness of UDP traffic;
they [SHOULD NOT]{.bcp14} queue packets in order to increase
batching.[¶](#section-6-1){.pilcrow}

When the protocol running over UDP that is being proxied uses congestion
control (e.g., \[[QUIC](#RFC9000){.xref}\]), the proxied traffic will
incur at least two nested congestion controllers. The underlying HTTP
connection [MUST NOT]{.bcp14} disable congestion control unless it has
an out-of-band way of knowing with absolute certainty that the inner
traffic is congestion-controlled.[¶](#section-6-2){.pilcrow}

If a client or UDP proxy with a connection containing a UDP Proxying
request stream disables congestion control, it [MUST NOT]{.bcp14} signal
Explicit Congestion Notification (ECN) \[[ECN](#RFC3168){.xref}\]
support on that connection. That is, it [MUST]{.bcp14} mark all IP
headers with the Not-ECT codepoint. It [MAY]{.bcp14} continue to report
ECN feedback via QUIC ACK_ECN frames or the TCP ECE bit, as the peer may
not have disabled congestion control.[¶](#section-6-3){.pilcrow}

When the protocol running over UDP that is being proxied uses loss
recovery (e.g., \[[QUIC](#RFC9000){.xref}\]), and the underlying HTTP
connection runs over TCP, the proxied traffic will incur at least two
nested loss recovery mechanisms. This can reduce performance as both can
sometimes independently retransmit the same data. To avoid this, UDP
proxying [SHOULD]{.bcp14} be performed over HTTP/3 to allow leveraging
the QUIC DATAGRAM frame.[¶](#section-6-4){.pilcrow}

::: {#mtu-considerations}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [MTU Considerations](#name-mtu-considerations){.section-name .selfRef} {#name-mtu-considerations}

When using HTTP/3 with the QUIC Datagram extension
\[[QUIC-DGRAM](#RFC9221){.xref}\], UDP payloads are transmitted in QUIC
DATAGRAM frames. Since those cannot be fragmented, they can only carry
payloads up to a given length determined by the QUIC connection
configuration and the Path MTU (PMTU). If a UDP proxy is using QUIC
DATAGRAM frames and it receives a UDP payload from the target that will
not fit inside a QUIC DATAGRAM frame, the UDP proxy [SHOULD NOT]{.bcp14}
send the UDP payload in a DATAGRAM capsule, as that defeats the
end-to-end unreliability characteristic that methods such as Datagram
Packetization Layer PMTU Discovery (DPLPMTUD) depend on
\[[DPLPMTUD](#RFC8899){.xref}\]. In this scenario, the UDP proxy
[SHOULD]{.bcp14} drop the UDP payload and send an ICMP Packet Too Big
message to the target; see [Section
3.2](https://www.rfc-editor.org/rfc/rfc4443#section-3.2){.relref} of
\[[ICMP6](#RFC4443){.xref}\].[¶](#section-6.1-1){.pilcrow}
:::
:::

::: {#tunneling-of-ecn-marks}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Tunneling of ECN Marks](#name-tunneling-of-ecn-marks){.section-name .selfRef} {#name-tunneling-of-ecn-marks}

UDP proxying does not create an IP-in-IP tunnel, so the guidance in
\[[ECN-TUNNEL](#RFC6040){.xref}\] about transferring ECN marks between
inner and outer IP headers does not apply. There is no inner IP header
in UDP proxying tunnels.[¶](#section-6.2-1){.pilcrow}

In this specification, note that UDP proxying clients do not have the
ability to control the ECN codepoints on UDP packets the UDP proxy sends
to the target, nor can UDP proxies communicate the markings of each UDP
packet from target to UDP proxy.[¶](#section-6.2-2){.pilcrow}

A UDP proxy [MUST]{.bcp14} ignore ECN bits in the IP header of UDP
packets received from the target, and it [MUST]{.bcp14} set the ECN bits
to Not-ECT on UDP packets it sends to the target. These do not relate to
the ECN markings of packets sent between client and UDP proxy in any
way.[¶](#section-6.2-3){.pilcrow}
:::
:::
:::
:::

::: {#security}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

There are significant risks in allowing arbitrary clients to establish a
tunnel to arbitrary targets, as that could allow bad actors to send
traffic and have it attributed to the UDP proxy. HTTP servers that
support UDP proxying ought to restrict its use to authenticated
users.[¶](#section-7-1){.pilcrow}

There exist software and network deployments that perform access control
checks based on the source IP address of incoming requests. For example,
some software allows unauthenticated configuration changes if they
originated from 127.0.0.1. Such software could be running on the same
host as the UDP proxy or in the same broadcast domain. Proxied UDP
traffic would then be received with a source IP address belonging to the
UDP proxy. If this source address is used for access control, UDP
proxying clients could use the UDP proxy to escalate their access
privileges beyond those they might otherwise have. This could lead to
unauthorized access by UDP proxying clients unless the UDP proxy
disallows UDP proxying requests to vulnerable targets, such as the UDP
proxy\'s own addresses and localhost, link-local, multicast, and
broadcast addresses. UDP proxies can use the destination_ip_prohibited
Proxy Error Type from [Section
2.3.5](https://www.rfc-editor.org/rfc/rfc9209#section-2.3.5){.relref} of
\[[PROXY-STATUS](#RFC9209){.xref}\] when rejecting such
requests.[¶](#section-7-2){.pilcrow}

UDP proxies share many similarities with TCP CONNECT proxies when
considering them as infrastructure for abuse to enable denial-of-service
(DoS) attacks. Both can obfuscate the attacker\'s source address from
the attack target. In the case of a stateless volumetric attack (e.g., a
TCP SYN flood or a UDP flood), both types of proxies pass the traffic to
the target host. With stateful volumetric attacks (e.g., HTTP flooding)
being sent over a TCP CONNECT proxy, the proxy will only send data if
the target has indicated its willingness to accept data by responding
with a TCP SYN-ACK. Once the path to the target is flooded, the TCP
CONNECT proxy will no longer receive replies from the target and will
stop sending data. Since UDP does not establish shared state between the
UDP proxy and the target, the UDP proxy could continue sending data to
the target in such a situation. While a UDP proxy could potentially
limit the number of UDP packets it is willing to forward until it has
observed a response from the target, that provides limited protection
against DoS attacks when attacks target open UDP ports where the
protocol running over UDP would respond and that would be interpreted as
willingness to accept UDP by the UDP proxy. Such a packet limit could
also cause issues for valid traffic.[¶](#section-7-3){.pilcrow}

The security considerations described in [Section
4](https://www.rfc-editor.org/rfc/rfc9297#section-4){.relref} of
\[[HTTP-DGRAM](#RFC9297){.xref}\] also apply here. Since it is possible
to tunnel IP packets over UDP, the guidance in
\[[TUNNEL-SECURITY](#RFC6169){.xref}\] can
apply.[¶](#section-7-4){.pilcrow}
:::
:::

::: {#iana}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

::: {#iana-upgrade}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [HTTP Upgrade Token](#name-http-upgrade-token){.section-name .selfRef} {#name-http-upgrade-token}

IANA has registered \"connect-udp\" in the \"HTTP Upgrade Tokens\"
registry maintained at
\<<https://www.iana.org/assignments/http-upgrade-tokens>\>.[¶](#section-8.1-1){.pilcrow}

[]{.break}

Value:

:   connect-udp[¶](#section-8.1-2.2.1){.pilcrow}

:   

Description:

:   Proxying of UDP Payloads[¶](#section-8.1-2.4.1){.pilcrow}

:   

Expected Version Tokens:

:   None[¶](#section-8.1-2.6.1){.pilcrow}

:   

Reference:

:   RFC 9298[¶](#section-8.1-2.8.1){.pilcrow}

:   
:::
:::

::: {#iana-uri}
::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Well-Known URI](#name-well-known-uri){.section-name .selfRef} {#name-well-known-uri}

IANA has registered \"masque\" in the \"Well-Known URIs\" registry
maintained at
\<<https://www.iana.org/assignments/well-known-uris>\>.[¶](#section-8.2-1){.pilcrow}

[]{.break}

URI Suffix:

:   masque[¶](#section-8.2-2.2.1){.pilcrow}

:   

Change Controller:

:   IETF[¶](#section-8.2-2.4.1){.pilcrow}

:   

Reference:

:   RFC 9298[¶](#section-8.2-2.6.1){.pilcrow}

:   

Status:

:   permanent[¶](#section-8.2-2.8.1){.pilcrow}

:   

Related Information:

:   Includes all resources identified with the path prefix
    \"/.well-known/masque/udp/\"[¶](#section-8.2-2.10.1){.pilcrow}

:   
:::
:::
:::
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[ABNF\]
:   [Crocker, D., Ed.]{.refAuthor} and [P. Overell]{.refAuthor},
    [\"Augmented BNF for Syntax Specifications: ABNF\"]{.refTitle}, [RFC
    2234]{.seriesInfo}, [DOI 10.17487/RFC2234]{.seriesInfo}, November
    1997, \<<https://www.rfc-editor.org/info/rfc2234>\>.
:   

\[ECN\]
:   [Ramakrishnan, K.]{.refAuthor}, [Floyd, S.]{.refAuthor}, and [D.
    Black]{.refAuthor}, [\"The Addition of Explicit Congestion
    Notification (ECN) to IP\"]{.refTitle}, [RFC 3168]{.seriesInfo},
    [DOI 10.17487/RFC3168]{.seriesInfo}, September 2001,
    \<<https://www.rfc-editor.org/info/rfc3168>\>.
:   

\[EXT-CONNECT2\]
:   [McManus, P.]{.refAuthor}, [\"Bootstrapping WebSockets with
    HTTP/2\"]{.refTitle}, [RFC 8441]{.seriesInfo}, [DOI
    10.17487/RFC8441]{.seriesInfo}, September 2018,
    \<<https://www.rfc-editor.org/info/rfc8441>\>.
:   

\[EXT-CONNECT3\]
:   [Hamilton, R.]{.refAuthor}, [\"Bootstrapping WebSockets with
    HTTP/3\"]{.refTitle}, [RFC 9220]{.seriesInfo}, [DOI
    10.17487/RFC9220]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9220>\>.
:   

\[HTTP\]
:   [Fielding, R., Ed.]{.refAuthor}, [Nottingham, M., Ed.]{.refAuthor},
    and [J. Reschke, Ed.]{.refAuthor}, [\"HTTP Semantics\"]{.refTitle},
    [STD 97]{.seriesInfo}, [RFC 9110]{.seriesInfo}, [DOI
    10.17487/RFC9110]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9110>\>.
:   

\[HTTP-DGRAM\]
:   [Schinazi, D.]{.refAuthor} and [L. Pardue]{.refAuthor}, [\"HTTP
    Datagrams and the Capsule Protocol\"]{.refTitle}, [RFC
    9297]{.seriesInfo}, [DOI 10.17487/RFC9297]{.seriesInfo}, August
    2022, \<<https://www.rfc-editor.org/info/rfc9297>\>.
:   

\[HTTP/1.1\]
:   [Fielding, R., Ed.]{.refAuthor}, [Nottingham, M., Ed.]{.refAuthor},
    and [J. Reschke, Ed.]{.refAuthor}, [\"HTTP/1.1\"]{.refTitle}, [STD
    99]{.seriesInfo}, [RFC 9112]{.seriesInfo}, [DOI
    10.17487/RFC9112]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9112>\>.
:   

\[HTTP/2\]
:   [Thomson, M., Ed.]{.refAuthor} and [C. Benfield, Ed.]{.refAuthor},
    [\"HTTP/2\"]{.refTitle}, [RFC 9113]{.seriesInfo}, [DOI
    10.17487/RFC9113]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9113>\>.
:   

\[HTTP/3\]
:   [Bishop, M., Ed.]{.refAuthor}, [\"HTTP/3\"]{.refTitle}, [RFC
    9114]{.seriesInfo}, [DOI 10.17487/RFC9114]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9114>\>.
:   

\[PROXY-STATUS\]
:   [Nottingham, M.]{.refAuthor} and [P. Sikora]{.refAuthor}, [\"The
    Proxy-Status HTTP Response Header Field\"]{.refTitle}, [RFC
    9209]{.seriesInfo}, [DOI 10.17487/RFC9209]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9209>\>.
:   

\[QUIC\]
:   [Iyengar, J., Ed.]{.refAuthor} and [M. Thomson, Ed.]{.refAuthor},
    [\"QUIC: A UDP-Based Multiplexed and Secure Transport\"]{.refTitle},
    [RFC 9000]{.seriesInfo}, [DOI 10.17487/RFC9000]{.seriesInfo}, May
    2021, \<<https://www.rfc-editor.org/info/rfc9000>\>.
:   

\[QUIC-DGRAM\]
:   [Pauly, T.]{.refAuthor}, [Kinnear, E.]{.refAuthor}, and [D.
    Schinazi]{.refAuthor}, [\"An Unreliable Datagram Extension to
    QUIC\"]{.refTitle}, [RFC 9221]{.seriesInfo}, [DOI
    10.17487/RFC9221]{.seriesInfo}, March 2022,
    \<<https://www.rfc-editor.org/info/rfc9221>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[TCP\]
:   [Eddy, W., Ed.]{.refAuthor}, [\"Transmission Control Protocol
    (TCP)\"]{.refTitle}, [STD 7]{.seriesInfo}, [RFC 9293]{.seriesInfo},
    [DOI 10.17487/RFC9293]{.seriesInfo}, August 2022,
    \<<https://www.rfc-editor.org/info/rfc9293>\>.
:   

\[TEMPLATE\]
:   [Gregorio, J.]{.refAuthor}, [Fielding, R.]{.refAuthor},
    [Hadley, M.]{.refAuthor}, [Nottingham, M.]{.refAuthor}, and [D.
    Orchard]{.refAuthor}, [\"URI Template\"]{.refTitle}, [RFC
    6570]{.seriesInfo}, [DOI 10.17487/RFC6570]{.seriesInfo}, March 2012,
    \<<https://www.rfc-editor.org/info/rfc6570>\>.
:   

\[UDP\]
:   [Postel, J.]{.refAuthor}, [\"User Datagram Protocol\"]{.refTitle},
    [STD 6]{.seriesInfo}, [RFC 768]{.seriesInfo}, [DOI
    10.17487/RFC0768]{.seriesInfo}, August 1980,
    \<<https://www.rfc-editor.org/info/rfc768>\>.
:   

\[URI\]
:   [Berners-Lee, T.]{.refAuthor}, [Fielding, R.]{.refAuthor}, and [L.
    Masinter]{.refAuthor}, [\"Uniform Resource Identifier (URI): Generic
    Syntax\"]{.refTitle}, [STD 66]{.seriesInfo}, [RFC
    3986]{.seriesInfo}, [DOI 10.17487/RFC3986]{.seriesInfo}, January
    2005, \<<https://www.rfc-editor.org/info/rfc3986>\>.
:   
:::

::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[BEHAVE\]
:   [Audet, F., Ed.]{.refAuthor} and [C. Jennings]{.refAuthor},
    [\"Network Address Translation (NAT) Behavioral Requirements for
    Unicast UDP\"]{.refTitle}, [BCP 127]{.seriesInfo}, [RFC
    4787]{.seriesInfo}, [DOI 10.17487/RFC4787]{.seriesInfo}, January
    2007, \<<https://www.rfc-editor.org/info/rfc4787>\>.
:   

\[DPLPMTUD\]
:   [Fairhurst, G.]{.refAuthor}, [Jones, T.]{.refAuthor},
    [Tüxen, M.]{.refAuthor}, [Rüngeler, I.]{.refAuthor}, and [T.
    Völker]{.refAuthor}, [\"Packetization Layer Path MTU Discovery for
    Datagram Transports\"]{.refTitle}, [RFC 8899]{.seriesInfo}, [DOI
    10.17487/RFC8899]{.seriesInfo}, September 2020,
    \<<https://www.rfc-editor.org/info/rfc8899>\>.
:   

\[ECN-TUNNEL\]
:   [Briscoe, B.]{.refAuthor}, [\"Tunnelling of Explicit Congestion
    Notification\"]{.refTitle}, [RFC 6040]{.seriesInfo}, [DOI
    10.17487/RFC6040]{.seriesInfo}, November 2010,
    \<<https://www.rfc-editor.org/info/rfc6040>\>.
:   

\[HELIUM\]
:   [Schwartz, B. M.]{.refAuthor}, [\"Hybrid Encapsulation Layer for IP
    and UDP Messages (HELIUM)\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-schwartz-httpbis-helium-00]{.seriesInfo}, 25 June 2018,
    \<<https://datatracker.ietf.org/doc/html/draft-schwartz-httpbis-helium-00>\>.
:   

\[HiNT\]
:   [Pardue, L.]{.refAuthor}, [\"HTTP-initiated Network Tunnelling
    (HiNT)\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft,
    draft-pardue-httpbis-http-network-tunnelling-00]{.seriesInfo}, 2
    July 2018,
    \<<https://datatracker.ietf.org/doc/html/draft-pardue-httpbis-http-network-tunnelling-00>\>.
:   

\[ICMP6\]
:   [Conta, A.]{.refAuthor}, [Deering, S.]{.refAuthor}, and [M. Gupta,
    Ed.]{.refAuthor}, [\"Internet Control Message Protocol (ICMPv6) for
    the Internet Protocol Version 6 (IPv6) Specification\"]{.refTitle},
    [STD 89]{.seriesInfo}, [RFC 4443]{.seriesInfo}, [DOI
    10.17487/RFC4443]{.seriesInfo}, March 2006,
    \<<https://www.rfc-editor.org/info/rfc4443>\>.
:   

\[MASQUE-ORIGINAL\]
:   [Schinazi, D.]{.refAuthor}, [\"The MASQUE Protocol\"]{.refTitle},
    [Work in Progress]{.refContent}, [Internet-Draft,
    draft-schinazi-masque-00]{.seriesInfo}, 28 February 2019,
    \<<https://datatracker.ietf.org/doc/html/draft-schinazi-masque-00>\>.
:   

\[TUNNEL-SECURITY\]
:   [Krishnan, S.]{.refAuthor}, [Thaler, D.]{.refAuthor}, and [J.
    Hoagland]{.refAuthor}, [\"Security Concerns with IP
    Tunneling\"]{.refTitle}, [RFC 6169]{.seriesInfo}, [DOI
    10.17487/RFC6169]{.seriesInfo}, April 2011,
    \<<https://www.rfc-editor.org/info/rfc6169>\>.
:   

\[UDP-USAGE\]
:   [Eggert, L.]{.refAuthor}, [Fairhurst, G.]{.refAuthor}, and [G.
    Shepherd]{.refAuthor}, [\"UDP Usage Guidelines\"]{.refTitle}, [BCP
    145]{.seriesInfo}, [RFC 8085]{.seriesInfo}, [DOI
    10.17487/RFC8085]{.seriesInfo}, March 2017,
    \<<https://www.rfc-editor.org/info/rfc8085>\>.
:   

\[WEBSOCKET\]
:   [Fette, I.]{.refAuthor} and [A. Melnikov]{.refAuthor}, [\"The
    WebSocket Protocol\"]{.refTitle}, [RFC 6455]{.seriesInfo}, [DOI
    10.17487/RFC6455]{.seriesInfo}, December 2011,
    \<<https://www.rfc-editor.org/info/rfc6455>\>.
:   
:::
:::

::: {#acknowledgments}
::: {#appendix-A .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

This document is a product of the MASQUE Working Group, and the author
thanks all MASQUE enthusiasts for their contributions. This proposal was
inspired directly or indirectly by prior work from many people, in
particular \[[HELIUM](#I-D.schwartz-httpbis-helium){.xref}\] by [Ben
Schwartz]{.contact-name},
\[[HiNT](#I-D.pardue-httpbis-http-network-tunnelling){.xref}\] by [Lucas
Pardue]{.contact-name}, and the original MASQUE Protocol
\[[MASQUE-ORIGINAL](#I-D.schinazi-masque){.xref}\] by the author of this
document.[¶](#appendix-A-1){.pilcrow}

The author would like to thank [Eric Rescorla]{.contact-name} for
suggesting the use of an HTTP method to proxy UDP. The author is
indebted to [Mark Nottingham]{.contact-name} and [Lucas
Pardue]{.contact-name} for the many improvements they contributed to
this document. The extensibility design in this document came out of the
HTTP Datagrams Design Team, whose members were [Alan
Frindell]{.contact-name}, [Alex Chernyakhovsky]{.contact-name}, [Ben
Schwartz]{.contact-name}, [Eric Rescorla]{.contact-name}, [Lucas
Pardue]{.contact-name}, [Marcus Ihlar]{.contact-name}, [Martin
Thomson]{.contact-name}, [Mike Bishop]{.contact-name}, [Tommy
Pauly]{.contact-name}, [Victor Vasiliev]{.contact-name}, and the author
of this document.[¶](#appendix-A-2){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-B .section}
## [Author\'s Address](#name-authors-address){.section-name .selfRef} {#name-authors-address}

::: {.left dir="auto"}
[David Schinazi]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google LLC]{.org}
:::

::: {.left dir="auto"}
[1600 Amphitheatre Parkway]{.street-address}
:::

::: {.left dir="auto"}
[Mountain View]{.locality}, [CA]{.region} [94043]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <dschinazi.ietf@gmail.com>
:::
:::
:::
