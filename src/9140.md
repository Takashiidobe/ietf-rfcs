  RFC 9140       EAP-NOOB          December 2021
  -------------- ----------------- ---------------
  Aura, et al.   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9140](https://www.rfc-editor.org/rfc/rfc9140){.eref}

Category:
:   Standards Track

Published:
:   December 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    T. Aura
    :::

    ::: org
    Aalto University
    :::
    :::

    ::: author
    ::: author-name
    M. Sethi
    :::

    ::: org
    Ericsson
    :::
    :::

    ::: author
    ::: author-name
    A. Peltonen
    :::

    ::: org
    Aalto University
    :::
    :::
:::

# RFC 9140 {#rfcnum}

# Nimble Out-of-Band Authentication for EAP (EAP‑NOOB) {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

The Extensible Authentication Protocol (EAP) provides support for
multiple authentication methods. This document defines the EAP-NOOB
authentication method for nimble out-of-band (OOB) authentication and
key derivation. The EAP method is intended for bootstrapping all kinds
of Internet-of-Things (IoT) devices that have no preconfigured
authentication credentials. The method makes use of a user-assisted,
one-directional, out-of-band (OOB) message between the peer device and
authentication server to authenticate the in-band key exchange. The
device must have a nonnetwork input or output interface, such as a
display, microphone, speaker, or blinking light, that can send or
receive dynamically generated messages of tens of bytes in
length.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9140>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [EAP-NOOB
    Method](#name-eap-noob-method){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Protocol
        Overview](#name-protocol-overview){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Protocol Messages and
        Sequences](#name-protocol-messages-and-seque){.xref}

        -   ::: {#section-toc.1-1.3.2.2.2.1}
            [3.2.1](#section-3.2.1){.xref}.  [Common Handshake in All
            EAP-NOOB
            Exchanges](#name-common-handshake-in-all-eap){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.2}
            [3.2.2](#section-3.2.2){.xref}.  [Initial
            Exchange](#name-initial-exchange){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.3}
            [3.2.3](#section-3.2.3){.xref}.  [OOB
            Step](#name-oob-step){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.4}
            [3.2.4](#section-3.2.4){.xref}.  [Completion
            Exchange](#name-completion-exchange){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.5}
            [3.2.5](#section-3.2.5){.xref}.  [Waiting
            Exchange](#name-waiting-exchange){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Protocol Data
        Fields](#name-protocol-data-fields){.xref}

        -   ::: {#section-toc.1-1.3.2.3.2.1}
            [3.3.1](#section-3.3.1){.xref}.  [Peer Identifier and
            NAI](#name-peer-identifier-and-nai){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.2}
            [3.3.2](#section-3.3.2){.xref}.  [Message Data
            Fields](#name-message-data-fields){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [Fast Reconnect and
        Rekeying](#name-fast-reconnect-and-rekeying){.xref}

        -   ::: {#section-toc.1-1.3.2.4.2.1}
            [3.4.1](#section-3.4.1){.xref}.  [Persistent EAP-NOOB
            Association](#name-persistent-eap-noob-associa){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.4.2.2}
            [3.4.2](#section-3.4.2){.xref}.  [Reconnect
            Exchange](#name-reconnect-exchange){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.4.2.3}
            [3.4.3](#section-3.4.3){.xref}.  [User
            Reset](#name-user-reset){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.5}
        [3.5](#section-3.5){.xref}.  [Key
        Derivation](#name-key-derivation){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.6}
        [3.6](#section-3.6){.xref}.  [Error
        Handling](#name-error-handling){.xref}

        -   ::: {#section-toc.1-1.3.2.6.2.1}
            [3.6.1](#section-3.6.1){.xref}.  [Invalid
            Messages](#name-invalid-messages){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.6.2.2}
            [3.6.2](#section-3.6.2){.xref}.  [Unwanted
            Peer](#name-unwanted-peer){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.6.2.3}
            [3.6.3](#section-3.6.3){.xref}.  [State
            Mismatch](#name-state-mismatch){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.6.2.4}
            [3.6.4](#section-3.6.4){.xref}.  [Negotiation
            Failure](#name-negotiation-failure){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.6.2.5}
            [3.6.5](#section-3.6.5){.xref}.  [Cryptographic Verification
            Failure](#name-cryptographic-verification-){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.6.2.6}
            [3.6.6](#section-3.6.6){.xref}.  [Application-Specific
            Failure](#name-application-specific-failur){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [ServerInfo and PeerInfo
    Contents](#name-serverinfo-and-peerinfo-con){.xref}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Cryptosuites](#name-cryptosuites){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Message
        Types](#name-message-types){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Error
        Codes](#name-error-codes){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [ServerInfo Data
        Fields](#name-serverinfo-data-fields-2){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [PeerInfo Data
        Fields](#name-peerinfo-data-fields-2){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.6}
        [5.6](#section-5.6){.xref}.  [Domain Name
        Reservation](#name-domain-name-reservation){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.7}
        [5.7](#section-5.7){.xref}.  [Guidance for Designated
        Experts](#name-guidance-for-designated-exp){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Authentication
        Principle](#name-authentication-principle){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Identifying Correct
        Endpoints](#name-identifying-correct-endpoin){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Trusted Path Issues and Misbinding
        Attacks](#name-trusted-path-issues-and-mis){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [Peer Identifiers and
        Attributes](#name-peer-identifiers-and-attrib){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.5}
        [6.5](#section-6.5){.xref}.  [Downgrading
        Threats](#name-downgrading-threats){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.6}
        [6.6](#section-6.6){.xref}.  [Protected Success and Failure
        Indications](#name-protected-success-and-failu){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.7}
        [6.7](#section-6.7){.xref}.  [Channel
        Binding](#name-channel-binding){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.8}
        [6.8](#section-6.8){.xref}.  [Denial of
        Service](#name-denial-of-service){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.9}
        [6.9](#section-6.9){.xref}.  [Recovery from Loss of Last
        Message](#name-recovery-from-loss-of-last-){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.10}
        [6.10](#section-6.10){.xref}. [Privacy
        Considerations](#name-privacy-considerations){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.11}
        [6.11](#section-6.11){.xref}. [EAP Security
        Claims](#name-eap-security-claims){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [Appendix A](#appendix-A){.xref}.  [Exchanges and Events per
    State](#name-exchanges-and-events-per-st){.xref}
    :::

-   ::: {#section-toc.1-1.9}
    [Appendix B](#appendix-B){.xref}.  [Application-Specific
    Parameters](#name-application-specific-parame){.xref}
    :::

-   ::: {#section-toc.1-1.10}
    [Appendix C](#appendix-C){.xref}.  [EAP-NOOB
    Roaming](#name-eap-noob-roaming){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [Appendix D](#appendix-D){.xref}.  [OOB Message as a
    URL](#name-oob-message-as-a-url){.xref}
    :::

-   ::: {#section-toc.1-1.12}
    [](#appendix-E){.xref}[Acknowledgments](#name-acknowledgments){.xref}
    :::

-   ::: {#section-toc.1-1.13}
    [](#appendix-F){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

This document describes a method for registration, authentication, and
key derivation for network-connected smart devices, such as consumer and
enterprise appliances that are part of the Internet of Things (IoT).
These devices may be off-the-shelf hardware that is sold and distributed
without any prior registration or credential-provisioning process, or
they may be recycled devices after a hard reset. Thus, the device
registration in a server database, ownership of the device, and the
authentication credentials for both network access and application-level
security must all be established at the time of the device deployment.
Furthermore, many such devices have only limited user interfaces that
could be used for their configuration. Often, the user interfaces are
limited to either only input (e.g., a camera) or output (e.g., a display
screen). The device configuration is made more challenging by the fact
that the devices may exist in large numbers and may have to be deployed
or reconfigured nimbly based on user needs.[¶](#section-1-1){.pilcrow}

To summarize, devices may have the following
characteristics:[¶](#section-1-2){.pilcrow}

-   [no preestablished relation with the intended server or
    user,[¶](#section-1-3.1){.pilcrow}]{#section-1-3.1}
-   [no preprovisioned device identifier or authentication credentials,
    or[¶](#section-1-3.2){.pilcrow}]{#section-1-3.2}
-   [an input or output interface that may be capable of only
    one-directional out-of-band
    communication.[¶](#section-1-3.3){.pilcrow}]{#section-1-3.3}

Many proprietary out-of-band (OOB) configuration methods exist for
specific IoT devices. The goal of this specification is to provide an
open standard and a generic protocol for bootstrapping the security of
network-connected appliances, such as displays, printers, speakers, and
cameras. The security bootstrapping in this specification makes use of a
user-assisted OOB channel. The device authentication relies on a user
having physical access to the device, and the key exchange security is
based on the assumption that attackers are not able to observe or modify
the messages conveyed through the OOB channel. We follow the common
approach taken in pairing protocols: performing a Diffie-Hellman key
exchange over the insecure network and authenticating the established
key with the help of the OOB channel in order to prevent impersonation
attacks.[¶](#section-1-4){.pilcrow}

The solution presented here is intended for devices that have either a
nonnetwork input or output interface, such as a camera, microphone,
display screen, speaker, or blinking Light Emitting Diode (LED) light,
that is able to send or receive dynamically generated messages of tens
of bytes in length. Naturally, this solution may not be appropriate for
very small sensors or actuators that have no user interface at all or
for devices that are inaccessible to the user. We also assume that the
OOB channel is at least partly automated (e.g., a camera scanning a bar
code); thus, there is no need to absolutely minimize the length of the
data transferred through the OOB channel. This differs, for example,
from Bluetooth pairing \[[Bluetooth](#Bluetooth){.xref}\], where it is
essential to minimize the length of the manually transferred or compared
codes. The OOB messages in this specification are dynamically generated.
Thus, we do not support static printed registration codes. One reason
for requiring dynamic OOB messages is that the receipt of the OOB
message authorizes the server to take ownership of the device. Dynamic
OOB messages are more secure than static printed codes, which could be
leaked and later misused.[¶](#section-1-5){.pilcrow}
:::
:::

::: {#terminology}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}

In addition, this document frequently uses the following terms as they
have been defined in
\[[RFC5216](#RFC5216){.xref}\]:[¶](#section-2-2){.pilcrow}

[]{.break}

authenticator
:   The entity initiating EAP
    authentication.[¶](#section-2-3.2){.pilcrow}
:   

peer
:   The entity that responds to the authenticator. In
    \[[IEEE-802.1X](#IEEE-802.1X){.xref}\], this entity is known as the
    supplicant. (We use the terms peer, device, and peer device
    interchangeably.)[¶](#section-2-3.4){.pilcrow}
:   

server
:   The entity that terminates the EAP authentication method with the
    peer. In the case where no backend authentication server is used,
    the EAP server is part of the authenticator. In the case where the
    authenticator operates in pass-through mode, the EAP server is
    located on the backend authentication
    server.[¶](#section-2-3.6){.pilcrow}
:   
:::
:::

::: {#eap-noob}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [EAP-NOOB Method](#name-eap-noob-method){.section-name .selfRef} {#name-eap-noob-method}

This section defines the EAP-NOOB method. The protocol is a generalized
version of the original idea presented by [Sethi et
al.](#Sethi14){.xref}
\[[Sethi14](#Sethi14){.xref}\].[¶](#section-3-1){.pilcrow}

::: {#overview}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Protocol Overview](#name-protocol-overview){.section-name .selfRef} {#name-protocol-overview}

One EAP-NOOB method execution spans two or more EAP conversations,
called Exchanges in this specification. Each Exchange consists of
several EAP request-response pairs. At least two separate EAP
conversations are needed to give the human user time to deliver the OOB
message between them.[¶](#section-3.1-1){.pilcrow}

The overall protocol starts with the Initial Exchange, which comprises
four EAP request-response pairs. In the Initial Exchange, the server
allocates an identifier to the peer, and the server and peer negotiate
the protocol version and cryptosuite (i.e., cryptographic algorithm
suite), exchange nonces, and perform an Ephemeral Elliptic Curve
Diffie-Hellman (ECDHE) key exchange. The user-assisted OOB Step then
takes place. This step requires only one out-of-band message, either
from the peer to the server or from the server to the peer. While
waiting for the OOB Step action, the peer [MAY]{.bcp14} probe the server
by reconnecting to it with EAP-NOOB. If the OOB Step has already taken
place, the probe leads to the Completion Exchange, which completes the
mutual authentication and key confirmation. On the other hand, if the
OOB Step has not yet taken place, the probe leads to the Waiting
Exchange, and the peer will perform another probe after a server-defined
minimum waiting time. The Initial Exchange and Waiting Exchange always
end in EAP-Failure, while the Completion Exchange may result in
EAP-Success. Once the peer and server have performed a successful
Completion Exchange, both endpoints store the created association in
persistent storage, and the OOB Step is not repeated. Thereafter,
creation of new temporal keys, ECDHE rekeying, and updates of
cryptographic algorithms can be achieved with the Reconnect
Exchange.[¶](#section-3.1-2){.pilcrow}

[]{#name-eap-noob-server-peer-associ}

::: {#fig-statemachine}
::: {#section-3.1-3.1 .alignLeft .art-text .artwork}
                                        OOB Output/Initial Exchange/
                                                   Waiting Exchange
                                                     .-----.
                                                     |     v
         .------------------.   Initial       .------------------.
         |                  |   Exchange      |                  |
      .->| Unregistered (0) |---------------->|Waiting for OOB(1)|
      |  |   (ephemeral)    |                 |   (ephemeral)    |
      |  |                  |                 |                  |
      |  '------------------'                 '------------------'
      |                                         |      |      ^
     User Reset                 Completion      |      |      |
      |                         Exchange        |     OOB   OOB
      |<-------.      .-------------------------'    Input  Reject/
      |        |      |                                |    Initial
      |        |      |                                |    Exchange
      |        |      v                                v      |
      |  .------------------.   Completion    .------------------.
      |  |                  |   Exchange      |                  |
      |  |  Registered (4)  |<----------------| OOB Received (2) |
      |  |   (persistent)   |                 |   (ephemeral)    |
      |  |                  |                 |                  |
      |  '------------------'                 '------------------'
      |        |      ^
      |  Mobility/    |
      |  Timeout/   Reconnect
      |  Failure    Exchange
      |        |      |
      |        v      |
      |  .------------------.
      |  |                  |
      '--| Reconnecting (3) |
         |   (persistent)   |
         |                  |
         '------------------'
:::

[Figure 1](#figure-1){.selfRef}: [EAP-NOOB Server-Peer Association State
Machine](#name-eap-noob-server-peer-associ){.selfRef}
:::

[Figure 1](#fig-statemachine){.xref} shows the association state
machine, which is the same for the server and for the peer. (For
readability, only the main state transitions are shown. The complete
table of transitions can be found in [Appendix
A](#exchangeappendix){.xref}.) When the peer initiates the EAP-NOOB
method, the server chooses the ensuing message exchange based on the
combination of the server and peer states. The EAP server and peer are
initially in the Unregistered (0) state, in which no state information
needs to be stored. Before a successful Completion Exchange, the
server-peer association state is ephemeral in both the server and peer
(ephemeral states 0..2), and a timeout or error may cause one or both
endpoints to go back to the Unregistered (0) state so that the Initial
Exchange is repeated. After the Completion Exchange has resulted in
EAP-Success, the association state becomes persistent (persistent states
3..4). Only user reset or memory failure can cause the return of the
server or the peer from the persistent states to the ephemeral states
and to the Initial Exchange.[¶](#section-3.1-4){.pilcrow}

The server [MUST NOT]{.bcp14} repeat a successful OOB Step with the same
peer except if the association with the peer is explicitly reset by the
user or lost due to failure of the persistent storage in the server.
More specifically, once the association has entered the Registered (4)
state, the server [MUST NOT]{.bcp14} delete the association or go back
to the ephemeral states 0..2 without explicit user approval. Similarly,
the peer [MUST NOT]{.bcp14} repeat the OOB Step unless the user
explicitly deletes the association with the server from the peer or
resets the peer to the Unregistered (0) state. The server and peer
[MAY]{.bcp14} implement user reset of the association by deleting the
state data from that endpoint. If an endpoint continues to store data
about the association after the user reset, its behavior [MUST]{.bcp14}
be equivalent to having deleted the association
data.[¶](#section-3.1-5){.pilcrow}

It can happen that the peer accidentally (or through user reset) loses
its persistent state and reconnects to the server without a previously
allocated peer identifier. In that case, the server [MUST]{.bcp14} treat
the peer as a new peer. The server [MAY]{.bcp14} use auxiliary
information, such as the PeerInfo field received in the Initial
Exchange, to detect multiple associations with the same peer. However,
it [MUST NOT]{.bcp14} delete or merge redundant associations without
user or application approval because EAP-NOOB internally has no secure
way of verifying that the two peers are the same physical device.
Similarly, the server might lose the association state because of a
memory failure or user reset. In that case, the only way to recover is
that the user also resets the peer.[¶](#section-3.1-6){.pilcrow}

A special feature of the EAP-NOOB method is that the server is not
assumed to have any a priori knowledge of the peer. Therefore, the peer
initially uses the generic identity string \"noob\@eap-noob.arpa\" as
its Network Access Identifier (NAI). The server then allocates a
server-specific identifier to the peer. The generic NAI serves two
purposes: firstly, it tells the server that the peer supports and
expects the EAP-NOOB method; secondly, it allows routing of the EAP-NOOB
sessions to a specific authentication server in an Authentication,
Authorization, and Accounting (AAA)
architecture.[¶](#section-3.1-7){.pilcrow}

EAP-NOOB is an unusual EAP method in that the peer has to have multiple
EAP conversations with the server before it can receive EAP-Success. The
reason is that, while EAP allows delays between the request-response
pairs, e.g., for repeated password entry, the user delays in OOB
authentication can be much longer than in password trials. Moreover,
EAP-NOOB supports peers with no input capability in the user interface
(e.g., LED light bulbs). Since users cannot initiate the protocol in
these devices, the devices have to perform the Initial Exchange
opportunistically and hope for the OOB Step to take place within a
timeout period (NoobTimeout), which is why the timeout needs to be
several minutes rather than seconds. To support such high-latency OOB
channels, the peer and server perform the Initial Exchange in one EAP
conversation, then allow time for the OOB message to be delivered, and
later perform the Waiting Exchange and Completion Exchange in different
EAP conversations.[¶](#section-3.1-8){.pilcrow}
:::
:::

::: {#protocol}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Protocol Messages and Sequences](#name-protocol-messages-and-seque){.section-name .selfRef} {#name-protocol-messages-and-seque}

This section defines the EAP-NOOB exchanges, which correspond to EAP
conversations. The exchanges start with a common handshake, which
determines the type of the following exchange. The common handshake
messages and the subsequent messages for each exchange type are listed
in the diagrams below. The diagrams also specify the data fields present
in each message. Each exchange comprises multiple EAP request-response
pairs and ends in either EAP-Failure, indicating that authentication is
not (yet) successful, or in EAP-Success.[¶](#section-3.2-1){.pilcrow}

::: {#commonhandshake}
::: {#section-3.2.1 .section}
#### [3.2.1.](#section-3.2.1){.section-number .selfRef} [Common Handshake in All EAP-NOOB Exchanges](#name-common-handshake-in-all-eap){.section-name .selfRef} {#name-common-handshake-in-all-eap}

All EAP-NOOB exchanges start with common handshake messages. The
handshake begins with the identity request and response that are common
to all EAP methods. Their purpose is to enable the AAA architecture to
route the EAP conversation to the EAP server and to enable the EAP
server to select the EAP method. The handshake then continues with one
EAP-NOOB request-response pair in which the server discovers the peer
identifier used in EAP-NOOB and the peer
state.[¶](#section-3.2.1-1){.pilcrow}

In more detail, each EAP-NOOB exchange begins with the authenticator
sending an EAP-Request/Identity packet to the peer. From this point on,
the EAP conversation occurs between the server and the peer, and the
authenticator acts as a pass-through device. The peer responds to the
authenticator with an EAP-Response/Identity packet, which contains the
Network Access Identifier (NAI). The authenticator, acting as a
pass-through device, forwards this response and the following EAP
conversation between the peer and the AAA architecture. The AAA
architecture routes the conversation to a specific AAA server (called
\"EAP server\" or simply \"server\" in this specification) based on the
realm part of the NAI. The server selects the EAP-NOOB method based on
the user part of the NAI, as defined in [Section
3.3.1](#nai){.xref}.[¶](#section-3.2.1-2){.pilcrow}

After receiving the EAP-Response/Identity message, the server sends the
first EAP-NOOB request (Type=1) to the peer, which responds with the
peer identifier (PeerId) and state (PeerState) in the range 0..3.
However, the peer [SHOULD]{.bcp14} omit the PeerId from the response
(Type=1) when PeerState=0. The server then chooses the EAP-NOOB
exchange, i.e., the ensuing message sequence, as explained below. The
peer recognizes the exchange based on the message type field (Type) of
the next EAP-NOOB request received from the
server.[¶](#section-3.2.1-3){.pilcrow}

The server [MUST]{.bcp14} determine the exchange type based on the
combination of the peer and server states as follows (also summarized in
[Table 14](#tab-exchanges){.xref}). If either the peer or server is in
the Unregistered (0) state and the other is in one of the ephemeral
states (0..2), the server chooses the Initial Exchange. If either the
peer or server is in the OOB Received (2) state and the other is either
in the Waiting for OOB (1) or OOB Received (2) state, the OOB Step has
taken place and the server chooses the Completion Exchange. If both the
server and peer are in the Waiting for OOB (1) state, the server chooses
the Waiting Exchange. If the peer is in the Reconnecting (3) state and
the server is in the Registered (4) or Reconnecting (3) state, the
server chooses the Reconnect Exchange. All other state combinations are
error situations where user action is required, and the server
[SHOULD]{.bcp14} indicate such errors to the peer with the error code
2002 (see [Section 3.6.3](#statemismatch){.xref}). Note also that the
peer [MUST NOT]{.bcp14} initiate EAP-NOOB when the peer is in the
Registered (4) state.[¶](#section-3.2.1-4){.pilcrow}

[]{#name-common-handshake-in-all-eap-}

::: {#fig-commonhandshake}
::: {#section-3.2.1-5.1 .alignCenter .art-text .artwork}
    EAP Peer                      Authenticator    EAP Server
      |                                   |              |
      |<----------- EAP-Request/Identity -|              |
      |                                                  |
      |                                                  |
      |------------ EAP-Response/Identity -------------->|
      |      (NAI=noob@eap-noob.arpa)                    |
      |                                                  |
      |                                                  |
      |<----------- EAP-Request/EAP-NOOB ----------------|
      |      (Type=1)                                    |
      |                                                  |
      |                                                  |
      |------------ EAP-Response/EAP-NOOB -------------->|
      |      (Type=1,[PeerId],PeerState=1)               |
      |                                                  |
      |  continuing with exchange-specific messages...   |
:::

[Figure 2](#figure-2){.selfRef}: [Common Handshake in All EAP-NOOB
Exchanges](#name-common-handshake-in-all-eap-){.selfRef}
:::
:::
:::

::: {#initialexchange}
::: {#section-3.2.2 .section}
#### [3.2.2.](#section-3.2.2){.section-number .selfRef} [Initial Exchange](#name-initial-exchange){.section-name .selfRef} {#name-initial-exchange}

The Initial Exchange comprises the common handshake and two further
EAP-NOOB request-response pairs: one for version, cryptosuite, and
parameter negotiation and the other for the ECDHE key exchange. The
first EAP-NOOB request (Type=2) from the server contains a newly
allocated PeerId for the peer and an optional NewNAI for assigning a new
NAI to the peer. The server allocates a new PeerId in the Initial
Exchange regardless of any old PeerId received in the previous response
(Type=1). The server also sends in the request a list of the protocol
versions (Vers) and cryptosuites (Cryptosuites) it supports, an
indicator of the OOB channel directions it supports (Dirs), and a
ServerInfo object. The peer chooses one of the versions and
cryptosuites. The peer sends a response (Type=2) with the selected
protocol version (Verp), the received PeerId, the selected cryptosuite
(Cryptosuitep), an indicator of the OOB channel direction(s) selected by
the peer (Dirp), and a PeerInfo object. In the second EAP-NOOB request
and response (Type=3), the server and peer exchange the public
components of their ECDHE keys and nonces (PKs, Ns, PKp, and Np). The
ECDHE keys [MUST]{.bcp14} be based on the negotiated cryptosuite, i.e.,
Cryptosuitep. The Initial Exchange always ends with EAP-Failure from the
server because the authentication cannot yet be
completed.[¶](#section-3.2.2-1){.pilcrow}

[]{#name-initial-exchange-2}

::: {#fig-initial}
::: {#section-3.2.2-2.1 .alignCenter .art-text .artwork}
    EAP Peer                                        EAP Server
      |       ...continuing from common handshake        |
      |                                                  |
      |<----------- EAP-Request/EAP-NOOB ----------------|
      |      (Type=2,Vers,PeerId,[NewNAI],               |
      |       Cryptosuites,Dirs,ServerInfo)              |
      |                                                  |
      |                                                  |
      |------------ EAP-Response/EAP-NOOB -------------->|
      |      (Type=2,Verp,PeerId,Cryptosuitep,           |
      |        Dirp,PeerInfo)                            |
      |                                                  |
      |                                                  |
      |<----------- EAP-Request/EAP-NOOB ----------------|
      |      (Type=3,PeerId,PKs,Ns,[SleepTime])          |
      |                                                  |
      |                                                  |
      |------------ EAP-Response/EAP-NOOB -------------->|
      |      (Type=3,PeerId,PKp,Np)                      |
      |                                                  |
      |                                                  |
      |<----------- EAP-Failure -------------------------|
      |                                                  |
:::

[Figure 3](#figure-3){.selfRef}: [Initial
Exchange](#name-initial-exchange-2){.selfRef}
:::

At the conclusion of the Initial Exchange, both the server and the peer
move to the Waiting for OOB (1) state.[¶](#section-3.2.2-3){.pilcrow}
:::
:::

::: {#oobstep}
::: {#section-3.2.3 .section}
#### [3.2.3.](#section-3.2.3){.section-number .selfRef} [OOB Step](#name-oob-step){.section-name .selfRef} {#name-oob-step}

The OOB Step, labeled as OOB Output and OOB Input in [Figure
1](#fig-statemachine){.xref}, takes place after the Initial Exchange.
Depending on the negotiated OOB channel direction, the peer or the
server outputs the OOB message as shown in Figures [4](#fig-oob1){.xref}
or [5](#fig-oob2){.xref}, respectively. The data fields are the PeerId,
the secret nonce Noob, and the cryptographic fingerprint Hoob. The
contents of the data fields are defined in [Section
3.3.2](#messagedatafields){.xref}. The OOB message is delivered to the
other endpoint via a user-assisted OOB
channel.[¶](#section-3.2.3-1){.pilcrow}

For brevity, we will use the terms OOB sender and OOB receiver in
addition to the already familiar EAP server and EAP peer. If the OOB
message is sent in the server-to-peer direction, the OOB sender is the
server and the OOB receiver is the peer. On the other hand, if the OOB
message is sent in the peer-to-server direction, the OOB sender is the
peer and the OOB receiver is the server.[¶](#section-3.2.3-2){.pilcrow}

[]{#name-oob-step-from-peer-to-eap-s}

::: {#fig-oob1}
::: {#section-3.2.3-3.1 .alignCenter .art-text .artwork}
    EAP Peer                                        EAP Server
      |                                                  |
      |=================OOB=============================>|
      |             (PeerId,Noob,Hoob)                   |
      |                                                  |
:::

[Figure 4](#figure-4){.selfRef}: [OOB Step, from Peer to EAP
Server](#name-oob-step-from-peer-to-eap-s){.selfRef}
:::

[]{#name-oob-step-from-eap-server-to}

::: {#fig-oob2}
::: {#section-3.2.3-4.1 .alignCenter .art-text .artwork}
    EAP Peer                                        EAP Server
      |                                                  |
      |<================OOB==============================|
      |             (PeerId,Noob,Hoob)                   |
      |                                                  |
:::

[Figure 5](#figure-5){.selfRef}: [OOB Step, from EAP Server to
Peer](#name-oob-step-from-eap-server-to){.selfRef}
:::

The OOB receiver [MUST]{.bcp14} compare the received value of the
fingerprint Hoob (see [Section 3.3.2](#messagedatafields){.xref}) with a
value that it computed locally for the PeerID received. This integrity
check ensures that the endpoints agree on contents of the Initial
Exchange. If the values are equal, the receiver moves to the OOB
Received (2) state. Otherwise, the receiver [MUST]{.bcp14} reject the
OOB message. For usability reasons, the OOB receiver [SHOULD]{.bcp14}
indicate the acceptance or rejection of the OOB message to the user. The
receiver [SHOULD]{.bcp14} reject invalid OOB messages without changing
its state in the association state machine until an application-specific
number of invalid messages (OobRetries) has been reached; after which,
the receiver [SHOULD]{.bcp14} consider it an error and go back to the
Unregistered (0) state.[¶](#section-3.2.3-5){.pilcrow}

The server or peer [MAY]{.bcp14} send multiple OOB messages with
different Noob values while in the Waiting for OOB (1) state. The OOB
sender [SHOULD]{.bcp14} remember the Noob values until they expire and
accept any one of them in the following Completion Exchange. The Noob
values sent by the server expire after an application-dependent timeout
(NoobTimeout), and the server [MUST NOT]{.bcp14} accept Noob values
older than that in the Completion Exchange. The [RECOMMENDED]{.bcp14}
value for NoobTimeout is 3600 seconds if there are no
application-specific reasons for making it shorter or longer. The Noob
values sent by the peer expire, as defined in [Section
3.2.5](#waitingexchange){.xref}.[¶](#section-3.2.3-6){.pilcrow}

The OOB receiver does not accept further OOB messages after it has
accepted one and moved to the OOB Received (2) state. However, the
receiver [MAY]{.bcp14} buffer redundant OOB messages in case an OOB
message expiry or similar error detected in the Completion Exchange
causes it to return to the Waiting for OOB (1) state. It is
[RECOMMENDED]{.bcp14} that the OOB receiver notifies the user about
redundant OOB messages, but it [MAY]{.bcp14} instead discard them
silently.[¶](#section-3.2.3-7){.pilcrow}

The sender will typically generate a new Noob, and therefore a new OOB
message, at constant time intervals (NoobInterval). The
[RECOMMENDED]{.bcp14} interval is[¶](#section-3.2.3-8){.pilcrow}

NoobInterval = NoobTimeout / 2[¶](#section-3.2.3-9){.pilcrow}

in which case, the receiver of the OOB will at any given time accept
either of the two latest Noob values. However, the timing of the Noob
generation may also be based on user interaction or on implementation
considerations.[¶](#section-3.2.3-10){.pilcrow}

Even though not recommended (see [Section 3.3](#datafields){.xref}),
this specification allows both directions to be negotiated (Dirp=3) for
the OOB channel. In that case, both sides [SHOULD]{.bcp14} output the
OOB message, and it is up to the user to deliver at least one of
them.[¶](#section-3.2.3-11){.pilcrow}

The details of the OOB channel implementation including the message
encoding are defined by the application. [Appendix D](#urloob){.xref}
gives an example of how the OOB message can be encoded as a URL that may
be embedded in a dynamic QR code or NFC (Near Field Communication)
tag.[¶](#section-3.2.3-12){.pilcrow}
:::
:::

::: {#completionexchange}
::: {#section-3.2.4 .section}
#### [3.2.4.](#section-3.2.4){.section-number .selfRef} [Completion Exchange](#name-completion-exchange){.section-name .selfRef} {#name-completion-exchange}

After the Initial Exchange, if the OOB channel directions selected by
the peer include the peer-to-server direction, the peer [SHOULD]{.bcp14}
initiate the EAP-NOOB method again after an applications-specific
waiting time in order to probe for completion of the OOB Step. If the
OOB channel directions selected by the peer include the server-to-peer
direction and the peer receives the OOB message, it [SHOULD]{.bcp14}
initiate the EAP-NOOB method immediately. Depending on the combination
of the peer and server states, the server continues with the Completion
Exchange or Waiting Exchange (see [Section
3.2.1](#commonhandshake){.xref} on how the server makes this
decision).[¶](#section-3.2.4-1){.pilcrow}

The Completion Exchange comprises the common handshake and one or two
further EAP-NOOB request-response pairs. If the peer is in the Waiting
for OOB (1) state, the OOB message has been sent in the peer-to-server
direction. In that case, only one request-response pair (Type=6) takes
place. In the request, the server sends the NoobId value (see [Section
3.3.2](#messagedatafields){.xref}), which the peer uses to identify the
exact OOB message received by the server. On the other hand, if the peer
is in the OOB Received (2) state, the direction of the OOB message is
from server to peer. In this case, two request-response pairs (Type=5
and Type=6) are needed. The purpose of the first request-response pair
(Type=5) is that it enables the server to discover NoobId, which
identifies the exact OOB message received by the peer. The server
returns the same NoobId to the peer in the latter
request.[¶](#section-3.2.4-2){.pilcrow}

In the last request-response pair (Type=6) of the Completion Exchange,
the server and peer exchange message authentication codes. Both sides
[MUST]{.bcp14} compute the keys Kms and Kmp, as defined in [Section
3.5](#keyderivation){.xref}, and the message authentication codes MACs
and MACp, as defined in [Section 3.3.2](#messagedatafields){.xref}. Both
sides [MUST]{.bcp14} compare the received message authentication code
with a locally computed value. If the peer finds that it has received
the correct value of MACs and the server finds that it has received the
correct value of MACp, the Completion Exchange ends in EAP-Success.
Otherwise, the endpoint where the comparison fails indicates this with
an error message (error code 4001, see [Section
3.6.5](#cryptofailure){.xref}), and the Completion Exchange ends in
EAP-Failure.[¶](#section-3.2.4-3){.pilcrow}

After the successful Completion Exchange, both the server and the peer
move to the Registered (4) state. They also derive the output keying
material and store the persistent EAP-NOOB association state, as defined
in Sections [3.4](#fastreconnect){.xref} and
[3.5](#keyderivation){.xref}.[¶](#section-3.2.4-4){.pilcrow}

It is possible that the OOB message expires before it is received. In
that case, the sender of the OOB message no longer recognizes the NoobId
that it receives in the Completion Exchange. Another reason why the OOB
sender might not recognize the NoobId is if the received OOB message was
spoofed and contained an attacker-generated Noob value. The recipient of
an unrecognized NoobId indicates this with an error message (error code
2003, see [Section 3.6.1](#invalidmessages){.xref}), and the Completion
Exchange ends in EAP-Failure. The recipient of the error message 2003
moves back to the Waiting for OOB (1) state. This state transition is
called OOB Reject in [Figure 1](#fig-statemachine){.xref} (even though
it really is a specific type of failed Completion Exchange). On the
other hand, the sender of the error message stays in its previous
state.[¶](#section-3.2.4-5){.pilcrow}

Although it is not expected to occur in practice, poor user interface
design could lead to two OOB messages delivered simultaneously, one from
the peer to the server and the other from the server to the peer. The
server detects this event in the beginning of the Completion Exchange by
observing that both the server and peer are in the OOB Received (2)
state. In that case, as a tiebreaker, the server [MUST]{.bcp14} behave
as if only the server-to-peer message had been
delivered.[¶](#section-3.2.4-6){.pilcrow}

[]{#name-completion-exchange-2}

::: {#fig-completion}
::: {#section-3.2.4-7.1 .alignCenter .art-text .artwork}
    EAP Peer                                        EAP Server
      |       ...continuing from common handshake        |
      |                                                  |
      |<----------- [ EAP-Request/EAP-NOOB ] ------------|
      |      (Type=5,PeerId)                             |
      |                                                  |
      |                                                  |
      |------------ [ EAP-Response/EAP-NOOB ] ---------->|
      |      (Type=5,PeerId,NoobId)                      |
      |                                                  |
      |                                                  |
      |<----------- EAP-Request/EAP-NOOB ----------------|
      |      (Type=6,PeerId,NoobId,MACs)                 |
      |                                                  |
      |                                                  |
      |------------ EAP-Response/EAP-NOOB -------------->|
      |      (Type=6,PeerId,MACp)                        |
      |                                                  |
      |                                                  |
      |<----------- EAP-Success -------------------------|
      |                                                  |
:::

[Figure 6](#figure-6){.selfRef}: [Completion
Exchange](#name-completion-exchange-2){.selfRef}
:::
:::
:::

::: {#waitingexchange}
::: {#section-3.2.5 .section}
#### [3.2.5.](#section-3.2.5){.section-number .selfRef} [Waiting Exchange](#name-waiting-exchange){.section-name .selfRef} {#name-waiting-exchange}

As explained in [Section 3.2.4](#completionexchange){.xref}, the peer
[SHOULD]{.bcp14} probe the server for completion of the OOB Step. When
the combination of the peer and server states indicates that the OOB
message has not yet been delivered, the server chooses the Waiting
Exchange (see [Section 3.2.1](#commonhandshake){.xref} on how the server
makes this decision). The Waiting Exchange comprises the common
handshake and one further request-response pair, and it always ends in
EAP-Failure.[¶](#section-3.2.5-1){.pilcrow}

In order to limit the rate at which peers probe the server, the server
[MAY]{.bcp14} send to the peer either in the Initial Exchange or in the
Waiting Exchange a minimum time to wait before probing the server again.
A peer that has not received an OOB message [SHOULD]{.bcp14} wait at
least the server-specified minimum waiting time in seconds (SleepTime)
before initiating EAP again with the same server. The peer uses the
latest SleepTime value that it has received in or after the Initial
Exchange. If the server has not sent any SleepTime value, the peer
[MUST]{.bcp14} wait for an application-specified minimum time
(SleepTimeDefault).[¶](#section-3.2.5-2){.pilcrow}

After the Waiting Exchange, the peer [MUST]{.bcp14} discard (from its
local ephemeral storage) Noob values that it has sent to the server in
OOB messages that are older than the application-defined timeout
NoobTimeout (see [Section 3.2.3](#oobstep){.xref}). The peer
[SHOULD]{.bcp14} discard such expired Noob values even if the probing
failed because of, e.g., failure to connect to the EAP server or an
incorrect message authentication code. The timeout of peer-generated
Noob values is defined like this in order to allow the peer to probe the
server once after it has waited for the server-specified
SleepTime.[¶](#section-3.2.5-3){.pilcrow}

If the server and peer have negotiated to use only the server-to-peer
direction for the OOB channel (Dirp=2), the peer [SHOULD]{.bcp14}
nevertheless probe the server. The purpose of this is to keep the server
informed about the peers that are still waiting for OOB messages. The
server [MAY]{.bcp14} set SleepTime to a high number (e.g., 3600) to
prevent the peer from probing the server
frequently.[¶](#section-3.2.5-4){.pilcrow}

[]{#name-waiting-exchange-2}

::: {#fig-waiting}
::: {#section-3.2.5-5.1 .alignCenter .art-text .artwork}
    EAP Peer                                        EAP Server
      |       ...continuing from common handshake        |
      |                                                  |
      |<----------- EAP-Request/EAP-NOOB ----------------|
      |      (Type=4,PeerId,[SleepTime])                 |
      |                                                  |
      |                                                  |
      |------------ EAP-Response/EAP-NOOB -------------->|
      |      (Type=4,PeerId)                             |
      |                                                  |
      |                                                  |
      |<----------- EAP-Failure -------------------------|
      |                                                  |
:::

[Figure 7](#figure-7){.selfRef}: [Waiting
Exchange](#name-waiting-exchange-2){.selfRef}
:::
:::
:::
:::
:::

::: {#datafields}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Protocol Data Fields](#name-protocol-data-fields){.section-name .selfRef} {#name-protocol-data-fields}

This section defines the various identifiers and data fields used in the
EAP-NOOB method.[¶](#section-3.3-1){.pilcrow}

::: {#nai}
::: {#section-3.3.1 .section}
#### [3.3.1.](#section-3.3.1){.section-number .selfRef} [Peer Identifier and NAI](#name-peer-identifier-and-nai){.section-name .selfRef} {#name-peer-identifier-and-nai}

The server allocates a new peer identifier (PeerId) for the peer in the
Initial Exchange. The peer identifier [MUST]{.bcp14} follow the syntax
of the utf8-username specified in \[[RFC7542](#RFC7542){.xref}\]. The
server [MUST]{.bcp14} generate the identifiers in such a way that they
do not repeat and cannot be guessed by the peer or third parties before
the server sends them to the peer in the Initial Exchange. One way to
generate the identifiers is to choose a random 16-byte identifier and to
base64url encode it without padding \[[RFC4648](#RFC4648){.xref}\] into
a 22-character ASCII string. Another way to generate the identifiers is
to choose a random 22-character alphanumeric ASCII string. It is
[RECOMMENDED]{.bcp14} to not use identifiers longer than this because
they result in longer OOB messages.[¶](#section-3.3.1-1){.pilcrow}

The peer uses the allocated PeerId to identify itself to the server in
the subsequent exchanges. The peer [MUST]{.bcp14} copy the PeerId byte
by byte from the message where it was allocated, and the server
[MUST]{.bcp14} perform a byte-by-byte comparison between the received
and the previously allocated PeerID. The peer sets the PeerId value in
response type 1 as follows. As stated in [Section
3.2.1](#commonhandshake){.xref}, when the peer is in the Unregistered
(0) state, it [SHOULD]{.bcp14} omit the PeerId from response type 1.
When the peer is in one of the states 1..2, it [MUST]{.bcp14} use the
PeerId that the server assigned to it in the latest Initial Exchange.
When the peer is in one of the persistent states 3..4, it [MUST]{.bcp14}
use the PeerId from its persistent EAP-NOOB association. (The PeerId is
written to the association when the peer moves to the Registered (4)
state after a Completion Exchange.)[¶](#section-3.3.1-2){.pilcrow}

The default NAI for the peer is \"noob\@eap-noob.arpa\". The peer
implementation [MAY]{.bcp14} allow the user or application to configure
a different NAI, which overrides the default NAI. Furthermore, the
server [MAY]{.bcp14} assign a new NAI to the peer in the Initial
Exchange or Reconnect Exchange in the NewNAI field of request types 2
and 7 to override any previous NAI value. When the peer is in the
Unregistered (0) state, or when the peer is in one of the states 1..2
and the server did not send a NewNAI in the latest Initial Exchange, the
peer [MUST]{.bcp14} use the configured NAI or, if it does not exist, the
default NAI. When the peer is in one of the states 1..2 and the server
sent a NewNAI in the latest Initial Exchange, the peer [MUST]{.bcp14}
use this server-assigned NAI. When the peer moves to the Registered (4)
state after the Completion Exchange, it writes to the persistent
EAP-NOOB association the same NAI value that it used in the Completion
Exchange. When the peer is in the Reconnecting (3) or Registered (4)
state, it [MUST]{.bcp14} use the NAI from its persistent EAP-NOOB
association. When the server sends NewNAI in the Reconnect Exchange, the
peer writes its value to the persistent EAP-NOOB association when it
moves from the Reconnecting (3) state to the Registered (4) state. All
the NAI values [MUST]{.bcp14} follow the syntax specified in
\[[RFC7542](#RFC7542){.xref}\].[¶](#section-3.3.1-3){.pilcrow}

The purpose of the server-assigned NAI is to enable more flexible
routing of the EAP sessions over the AAA infrastructure, including
roaming scenarios (see [Appendix C](#roaming){.xref}). Moreover, some
authenticators or AAA servers use the realm part of the assigned NAI to
determine peer-specific connection parameters, such as isolating the
peer to a specific VLAN. On the other hand, the user- or
application-configured NAI enables registration of new devices while
roaming. It also enables manufacturers to set up their own AAA servers
for bootstrapping of new peer devices.[¶](#section-3.3.1-4){.pilcrow}

The peer\'s PeerId and server-assigned NAI are ephemeral until a
successful Completion Exchange takes place. Thereafter, the values
become parts of the persistent EAP-NOOB association until the user
resets the peer and server or until a new NAI is assigned in the
Reconnect Exchange.[¶](#section-3.3.1-5){.pilcrow}
:::
:::

::: {#messagedatafields}
::: {#section-3.3.2 .section}
#### [3.3.2.](#section-3.3.2){.section-number .selfRef} [Message Data Fields](#name-message-data-fields){.section-name .selfRef} {#name-message-data-fields}

[Table 1](#tab-datafields){.xref} defines the data fields in the
protocol messages. The in-band messages are formatted as JSON objects
\[[RFC8259](#RFC8259){.xref}\] in UTF-8 encoding. The JSON member names
are in the left-hand column of the table.[¶](#section-3.3.2-1){.pilcrow}

[]{#name-message-data-fields-2}

::: {#tab-datafields}
  Data Field                   Description
  ---------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Vers, Verp                   EAP-NOOB protocol versions supported by the EAP server and the protocol version chosen by the peer. Vers is a JSON array of unsigned integers, and Verp is an unsigned integer. Example values are \"\[1\]\" and \"1\", respectively.
  PeerId                       Peer identifier, as defined in [Section 3.3.1](#nai){.xref}.
  NAI, NewNAI                  Peer NAI and server-assigned new peer NAI, as defined in [Section 3.3.1](#nai){.xref}.
  Type                         EAP-NOOB message type. The type is an integer in the range 0..9. EAP-NOOB requests and the corresponding responses share the same type value.
  PeerState                    Peer state is an integer in the range 0..4 (see [Figure 1](#fig-statemachine){.xref}). However, only values 0..3 are ever sent in the protocol messages.
  PKs, PKp                     The public components of the ECDHE keys of the server and peer. PKs and PKp are sent in the JSON Web Key (JWK) format \[[RFC7517](#RFC7517){.xref}\]. The detailed format of the JWK object is defined by the cryptosuite.
  Cryptosuites, Cryptosuitep   The identifiers of cryptosuites supported by the server and of the cryptosuite selected by the peer. The server-supported cryptosuites in Cryptosuites are formatted as a JSON array of the identifier integers. The server [MUST]{.bcp14} send a nonempty array with no repeating elements, ordered by decreasing priority. The peer [MUST]{.bcp14} respond with exactly one suite in the Cryptosuitep value, formatted as an identifier integer. Mandatory-to-implement cryptosuites and the registration procedure for new cryptosuites are specified in [Section 5.1](#cryptosuites){.xref}. Example values are \"\[1\]\" and \"1\", respectively.
  Dirs, Dirp                   An integer indicating the OOB channel directions supported by the server and the directions selected by the peer. The possible values are 1=peer-to-server, 2=server-to-peer, and 3=both directions.
  Dir                          The actual direction of the OOB message (1=peer-to-server, 2=server-to-peer). This value is not sent over any communication channel, but it is included in the computation of the cryptographic fingerprint Hoob.
  Ns, Np                       32-byte nonces for the Initial Exchange.
  ServerInfo                   This field contains information about the server to be passed from the EAP method to the application layer in the peer. The information is specific to the application or to the OOB channel, and it is encoded as a JSON object of at most 500 bytes. It could include, for example, the access-network name and server name, a Uniform Resource Locator (URL) \[[RFC3986](#RFC3986){.xref}\], or some other information that helps the user deliver the OOB message to the server through the out-of-band channel.
  PeerInfo                     This field contains information about the peer to be passed from the EAP method to the application layer in the server. The information is specific to the application or to the OOB channel, and it is encoded as a JSON object of at most 500 bytes. It could include, for example, the peer brand, model, and serial number, which help the user distinguish between devices and deliver the OOB message to the correct peer through the out-of-band channel.
  SleepTime                    The number of seconds for which the peer [MUST NOT]{.bcp14} start a new execution of the EAP-NOOB method with the authenticator, unless the peer receives the OOB message or the sending is triggered by an application-specific user action. The server can use this field to limit the rate at which peers probe it. SleepTime is an unsigned integer in the range 0..3600.
  Noob                         16-byte secret nonce sent through the OOB channel and used for the session key derivation. The endpoint that received the OOB message uses this secret in the Completion Exchange to authenticate the exchanged key to the endpoint that sent the OOB message.
  Hoob                         16-byte cryptographic fingerprint (i.e., hash value) computed from all the parameters exchanged in the Initial Exchange and in the OOB message. Receiving this fingerprint over the OOB channel guarantees the integrity of the key exchange and parameter negotiation. Hence, it authenticates the exchanged key to the endpoint that receives the OOB message.
  NoobId                       16-byte identifier for the OOB message, computed with a one-way function from the nonce Noob in the message.
  MACs, MACp                   Message authentication codes (HMAC) for mutual authentication, key confirmation, and integrity check on the exchanged information. The input to the HMAC is defined below, and the key for the HMAC is defined in [Section 3.5](#keyderivation){.xref}.
  Ns2, Np2                     32-byte nonces for the Reconnect Exchange.
  KeyingMode                   Integer indicating the key derivation method. 0 in the Completion Exchange, and 1..3 in the Reconnect Exchange.
  PKs2, PKp2                   The public components of the ECDHE keys of the server and peer for the Reconnect Exchange. PKp2 and PKs2 are sent in the JSON Web Key (JWK) format \[[RFC7517](#RFC7517){.xref}\]. The detailed format of the JWK object is defined by the cryptosuite.
  MACs2, MACp2                 Message authentication codes (HMAC) for mutual authentication, key confirmation, and integrity check on the Reconnect Exchange. The input to the HMAC is defined below, and the key for the HMAC is defined in [Section 3.5](#keyderivation){.xref}.
  ErrorCode                    Integer indicating an error condition. Defined in [Section 5.3](#errorcodes){.xref}.
  ErrorInfo                    Textual error message for logging and debugging purposes. A UTF-8 string of at most 500 bytes.

  : [Table 1](#table-1){.selfRef}: [Message Data
  Fields](#name-message-data-fields-2){.selfRef}
:::

It is [RECOMMENDED]{.bcp14} for servers to support both OOB channel
directions (Dirs=3) unless the type of the OOB channel limits them to
one direction (Dirs=1 or Dirs=2). On the other hand, it is
[RECOMMENDED]{.bcp14} that the peer selects only one direction (Dirp=1
or Dirp=2) even when both directions (Dirp=3) would be technically
possible. The reason is that, if value 3 is negotiated, the user may be
presented with two OOB messages, one for each direction, even though
only one of them needs to be delivered. This can be confusing to the
user. Nevertheless, the EAP-NOOB protocol is designed to also cope with
the value 3; in which case, it uses the first delivered OOB message. In
the unlikely case of simultaneously delivered OOB messages, the protocol
prioritizes the server-to-peer direction.[¶](#section-3.3.2-3){.pilcrow}

The nonces in the in-band messages (Ns, Np, Ns2, Np2) are 32-byte fresh
random byte strings, and the secret nonce Noob is a 16-byte fresh random
byte string. All the nonces are generated by the endpoint that sends the
message.[¶](#section-3.3.2-4){.pilcrow}

The fingerprint Hoob and the identifier NoobId are computed with the
cryptographic hash function H, which is specified in the negotiated
cryptosuite and truncated to the 16 leftmost bytes of the output. The
message authentication codes (MACs, MACp, MACs2, MACp2) are computed
with the function HMAC, which is the hashed message authentication code
\[[RFC2104](#RFC2104){.xref}\] based on the cryptographic hash function
H and truncated to the 32 leftmost bytes of the
output.[¶](#section-3.3.2-5){.pilcrow}

The inputs to the hash function for computing the fingerprint Hoob and
to the HMAC for computing MACs, MACp, MACs2, and MACp2 are JSON arrays
containing a fixed number (17) of elements. The array elements
[MUST]{.bcp14} be copied to the array verbatim from the sent and
received in-band messages. When the element is a JSON object, its
members [MUST NOT]{.bcp14} be reordered or reencoded. White space [MUST
NOT]{.bcp14} be added anywhere in the JSON structure. Implementers
should check that their JSON library copies the elements as UTF-8
strings, does not modify them in any way, and does not add white space
to the HMAC input.[¶](#section-3.3.2-6){.pilcrow}

The inputs for computing the fingerprint and message authentication
codes are the following:[¶](#section-3.3.2-7){.pilcrow}

::: {#section-3.3.2-8}
``` {.lang-pseudocode .sourcecode}
Hoob = H(Dir,Vers,Verp,PeerId,Cryptosuites,Dirs,ServerInfo,
Cryptosuitep,Dirp,NAI,PeerInfo,0,PKs,Ns,PKp,Np,Noob).

NoobId = H("NoobId",Noob).

MACs = HMAC(Kms; 2,Vers,Verp,PeerId,Cryptosuites,Dirs,ServerInfo,
Cryptosuitep,Dirp,NAI,PeerInfo,0,PKs,Ns,PKp,Np,Noob).

MACp = HMAC(Kmp; 1,Vers,Verp,PeerId,Cryptosuites,Dirs,ServerInfo,
Cryptosuitep,Dirp,NAI,PeerInfo,0,PKs,Ns,PKp,Np,Noob).

MACs2 = HMAC(Kms2; 2,Vers,Verp,PeerId,Cryptosuites,"",[ServerInfo],
Cryptosuitep,"",NAI,[PeerInfo],KeyingMode,[PKs2],Ns2,[PKp2],Np2,"")

MACp2 = HMAC(Kmp2; 1,Vers,Verp,PeerId,Cryptosuites,"",[ServerInfo],
Cryptosuitep,"",NAI,[PeerInfo],KeyingMode,[PKs2],Ns2,[PKp2],Np2,"")
```

[¶](#section-3.3.2-8){.pilcrow}
:::

The inputs denoted with \"\" above are not present, and the values in
brackets \[\] are optional. Both kinds of missing input values are
represented by empty strings \"\" in the HMAC input (JSON array). The
NAI included in the inputs is the NAI value that will be in the
persistent EAP-NOOB association if the Completion Exchange or Reconnect
Exchange succeeds. In the Completion Exchange, the NAI is the NewNAI
value assigned by the server in the preceding Initial Exchange or, if no
NewNAI was sent, the NAI used by the client in the Initial Exchange. In
the Reconnect Exchange, the NAI is the NewNAI value assigned by the
server in the same Reconnect Exchange or, if no NewNAI was sent, the
unchanged NAI from the persistent EAP-NOOB association. Each of the
values in brackets for the computation of Macs2 and Macp2 [MUST]{.bcp14}
be included if it was sent or received in the same Reconnect Exchange;
otherwise, the value is replaced by an empty string
\"\".[¶](#section-3.3.2-9){.pilcrow}

The parameter Dir indicates the direction in which the OOB message
containing the Noob value is being sent (1=peer-to-server,
2=server-to-peer). This field is included in the Hoob input to prevent
the user from accidentally delivering the OOB message back to its
originator in the rare cases where both OOB directions have been
negotiated. The keys (Kms, Kmp, Kms2, and Kmp2) for the HMACs are
defined in [Section
3.5](#keyderivation){.xref}.[¶](#section-3.3.2-10){.pilcrow}

The nonces (Ns, Np, Ns2, Np2, and Noob) and the hash value (NoobId)
[MUST]{.bcp14} be base64url encoded \[[RFC4648](#RFC4648){.xref}\] when
they are used as input to the cryptographic functions H or HMAC. These
values and the message authentication codes (MACs, MACp, MACs2, and
MACp2) [MUST]{.bcp14} also be base64url encoded when they are sent as
JSON strings in the in-band messages. The values Noob and Hoob in the
OOB channel [MAY]{.bcp14} be base64url encoded if that is appropriate
for the application and the OOB channel. All base64url encoding is done
without padding. The base64url-encoded values will naturally consume
more space than the number of bytes specified above (e.g., a
22-character string for a 16-byte nonce and a 43-character string for a
32-byte nonce or message authentication code). In the key derivation in
[Section 3.5](#keyderivation){.xref}, on the other hand, the unencoded
nonces (raw bytes) are used as input to the key derivation
function.[¶](#section-3.3.2-11){.pilcrow}

The ServerInfo and PeerInfo are JSON objects with UTF-8 encoding. The
length of either encoded object as a byte array [MUST NOT]{.bcp14}
exceed 500 bytes. The format and semantics of these objects
[MUST]{.bcp14} be defined by the application that uses the EAP-NOOB
method.[¶](#section-3.3.2-12){.pilcrow}
:::
:::
:::
:::

::: {#fastreconnect}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [Fast Reconnect and Rekeying](#name-fast-reconnect-and-rekeying){.section-name .selfRef} {#name-fast-reconnect-and-rekeying}

EAP-NOOB implements fast reconnect (\[[RFC3748](#RFC3748){.xref}\],
[Section
7.2.1](https://www.rfc-editor.org/rfc/rfc3748#section-7.2.1){.relref}),
which avoids repeated use of the user-assisted OOB
channel.[¶](#section-3.4-1){.pilcrow}

The rekeying and the Reconnect Exchange may be needed for several
reasons. New EAP output values Main Session Key (MSK) and Extended Main
Session Key (EMSK) may be needed because of mobility or timeout of
session keys. Software or hardware failure or user action may also cause
the authenticator, EAP server, or peer to lose its nonpersistent state
data. The failure would typically be detected by the peer or
authenticator when session keys are no longer accepted by the other
endpoint. Changes in the supported cryptosuites in the EAP server or
peer may also cause the need for a new key exchange. When the EAP server
or peer detects any one of these events, it [MUST]{.bcp14} change from
the Registered (4) state to the Reconnecting (3) state. These state
transitions are labeled Mobility/Timeout/Failure in [Figure
1](#fig-statemachine){.xref}. The EAP-NOOB method will then perform the
Reconnect Exchange the next time when EAP is
triggered.[¶](#section-3.4-2){.pilcrow}

::: {#persistentassociation}
::: {#section-3.4.1 .section}
#### [3.4.1.](#section-3.4.1){.section-number .selfRef} [Persistent EAP-NOOB Association](#name-persistent-eap-noob-associa){.section-name .selfRef} {#name-persistent-eap-noob-associa}

To enable rekeying, the EAP server and peer store the session state in
persistent memory after a successful Completion Exchange. This state
data, called \"persistent EAP-NOOB association\", [MUST]{.bcp14} include
at least the data fields shown in [Table 2](#tab-persistent){.xref}.
They are used for identifying and authenticating the peer in the
Reconnect Exchange. When a persistent EAP-NOOB association exists, the
EAP server and peer are in the Registered (4) state or Reconnecting (3)
state, as shown in [Figure
1](#fig-statemachine){.xref}.[¶](#section-3.4.1-1){.pilcrow}

[]{#name-persistent-eap-noob-associat}

::: {#tab-persistent}
  Data Field                        Value                                                                                             Type
  --------------------------------- ------------------------------------------------------------------------------------------------- ----------------------------------------------
  PeerId                            Peer identifier allocated by server                                                               UTF-8 string (typically 22 ASCII characters)
  Verp                              Negotiated protocol version                                                                       integer
  Cryptosuitep                      Negotiated cryptosuite                                                                            integer
  CryptosuitepPrev (at peer only)   Previous cryptosuite                                                                              integer
  NAI                               NAI assigned by the server or configured by the user or the default NAI \"noob\@eap-noob.arpa\"   UTF-8 string
  Kz                                Persistent key material                                                                           32 bytes
  KzPrev (at peer only)             Previous Kz value                                                                                 32 bytes

  : [Table 2](#table-2){.selfRef}: [Persistent EAP-NOOB
  Association](#name-persistent-eap-noob-associat){.selfRef}
:::
:::
:::

::: {#reconnectexchange}
::: {#section-3.4.2 .section}
#### [3.4.2.](#section-3.4.2){.section-number .selfRef} [Reconnect Exchange](#name-reconnect-exchange){.section-name .selfRef} {#name-reconnect-exchange}

The server chooses the Reconnect Exchange when both the peer and the
server are in a persistent state and fast reconnection is needed (see
[Section 3.2.1](#commonhandshake){.xref} for
details).[¶](#section-3.4.2-1){.pilcrow}

The Reconnect Exchange comprises the common handshake and three further
EAP-NOOB request-response pairs: one for cryptosuite and parameter
negotiation, another for the nonce and ECDHE key exchange, and the last
one for exchanging message authentication codes. In the first request
and response (Type=7), the server and peer negotiate a protocol version
and cryptosuite in the same way as in the Initial Exchange. The server
[SHOULD NOT]{.bcp14} offer and the peer [MUST NOT]{.bcp14} accept
protocol versions or cryptosuites that it knows to be weaker than the
one currently in the Cryptosuitep field of the persistent EAP-NOOB
association. The server [SHOULD NOT]{.bcp14} needlessly change the
cryptosuites it offers to the same peer because peer devices may have
limited ability to update their persistent storage. However, if the peer
has different values in the Cryptosuitep and CryptosuitepPrev fields, it
[SHOULD]{.bcp14} also accept offers that are not weaker than
CryptosuitepPrev. Note that Cryptosuitep and CryptosuitePrev from the
persistent EAP-NOOB association are only used to support the negotiation
as described above; all actual cryptographic operations use the newly
negotiated cryptosuite. The request and response (Type=7) [MAY]{.bcp14}
additionally contain PeerInfo and ServerInfo
objects.[¶](#section-3.4.2-2){.pilcrow}

The server then determines the KeyingMode (defined in [Section
3.5](#keyderivation){.xref}) based on changes in the negotiated
cryptosuite and whether it desires to achieve forward secrecy or not.
The server [SHOULD]{.bcp14} only select KeyingMode 3 when the negotiated
cryptosuite differs from the Cryptosuitep in the server\'s persistent
EAP-NOOB association, although it is technically possible to select this
value without changing the cryptosuite. In the second request and
response (Type=8), the server informs the peer about the KeyingMode and
the server and peer exchange nonces (Ns2, Np2). When KeyingMode is 2 or
3 (rekeying with ECDHE), they also exchange public components of ECDHE
keys (PKs2, PKp2). The server ECDHE key [MUST]{.bcp14} be fresh, i.e.,
not previously used with the same peer, and the peer ECDHE key
[SHOULD]{.bcp14} be fresh, i.e., not previously
used.[¶](#section-3.4.2-3){.pilcrow}

In the third and final request and response (Type=9), the server and
peer exchange message authentication codes. Both sides [MUST]{.bcp14}
compute the keys Kms2 and Kmp2, as defined in [Section
3.5](#keyderivation){.xref}, and the message authentication codes MACs2
and MACp2, as defined in [Section 3.3.2](#messagedatafields){.xref}.
Both sides [MUST]{.bcp14} compare the received message authentication
code with a locally computed value.[¶](#section-3.4.2-4){.pilcrow}

The rules by which the peer compares the received MACs2 are nontrivial
because, in addition to authenticating the current exchange, MACs2 may
confirm the success or failure of a recent cryptosuite upgrade. The peer
processes the final request (Type=9) as
follows:[¶](#section-3.4.2-5){.pilcrow}

1.  [The peer first compares the received MACs2 value with one it
    computed using the Kz stored in the persistent EAP-NOOB association.
    If the received and computed values match, the peer deletes any data
    stored in the CryptosuitepPrev and KzPrev fields of the persistent
    EAP-NOOB association. It does this because the received MACs2
    confirms that the peer and server share the same Cryptosuitep and
    Kz, and any previous values must no longer be
    accepted.[¶](#section-3.4.2-6.1){.pilcrow}]{#section-3.4.2-6.1}
2.  [On the other hand, if the peer finds that the received MACs2 value
    does not match the one it computed locally with Kz, the peer checks
    whether the KzPrev field in the persistent EAP-NOOB association
    stores a key. If it does, the peer repeats the key derivation
    ([Section 3.5](#keyderivation){.xref}) and local MACs2 computation
    ([Section 3.3.2](#messagedatafields){.xref}) using KzPrev in place
    of Kz. If this second computed MACs2 matches the received value, the
    match indicates synchronization failure caused by the loss of the
    last response (Type=9) in a previously attempted cryptosuite
    upgrade. In this case, the peer rolls back that upgrade by
    overwriting Cryptosuitep with CryptosuitepPrev and Kz with KzPrev in
    the persistent EAP-NOOB association. It also clears the
    CryptosuitepPrev and KzPrev
    fields.[¶](#section-3.4.2-6.2){.pilcrow}]{#section-3.4.2-6.2}
3.  [If the received MACs2 matched one of the locally computed values,
    the peer proceeds to send the final response (Type=9). The peer also
    moves to the Registered (4) state. When KeyingMode is 1 or 2, the
    peer stops here. When KeyingMode is 3, the peer also updates the
    persistent EAP-NOOB association with the negotiated Cryptosuitep and
    the newly derived Kz value. To prepare for possible synchronization
    failure caused by the loss of the final response (Type=9) during
    cryptosuite upgrade, the peer copies the old Cryptosuitep and Kz
    values in the persistent EAP-NOOB association to the
    CryptosuitepPrev and KzPrev
    fields.[¶](#section-3.4.2-6.3){.pilcrow}]{#section-3.4.2-6.3}
4.  [Finally, if the peer finds that the received MACs2 does not match
    either of the two values that it computed locally (or one value if
    no KzPrev was stored), the peer sends an error message (error code
    4001, see [Section 3.6.5](#cryptofailure){.xref}), which causes the
    Reconnect Exchange to end in
    EAP-Failure.[¶](#section-3.4.2-6.4){.pilcrow}]{#section-3.4.2-6.4}

The server rules for processing the final message are simpler than the
peer rules because the server does not store previous keys and it never
rolls back a cryptosuite upgrade. Upon receiving the final response
(Type=9), the server compares the received value of MACp2 with one it
computes locally. If the values match, the Reconnect Exchange ends in
EAP-Success. When KeyingMode is 3, the server also updates Cryptosuitep
and Kz in the persistent EAP-NOOB association. On the other hand, if the
server finds that the values do not match, it sends an error message
(error code 4001), and the Reconnect Exchange ends in
EAP-Failure.[¶](#section-3.4.2-7){.pilcrow}

The endpoints [MAY]{.bcp14} send updated NewNAI, ServerInfo, and
PeerInfo objects in the Reconnect Exchange. When there is no update to
the values, they [SHOULD]{.bcp14} omit this information from the
messages. If the NewNAI was sent, each side updates NAI in the
persistent EAP-NOOB association when moving to the Registered (4)
state.[¶](#section-3.4.2-8){.pilcrow}

[]{#name-reconnect-exchange-2}

::: {#fig-reconnect}
::: {#section-3.4.2-9.1 .alignCenter .art-text .artwork}
    EAP Peer                                        EAP Server
      |       ...continuing from common handshake        |
      |                                                  |
      |<----------- EAP-Request/EAP-NOOB ----------------|
      |      (Type=7,Vers,PeerId,Cryptosuites,           |
      |       [NewNAI],[ServerInfo])                     |
      |                                                  |
      |                                                  |
      |------------ EAP-Response/EAP-NOOB -------------->|
      |      (Type=7,Verp,PeerId,Cryptosuitep,[PeerInfo])|
      |                                                  |
      |                                                  |
      |<----------- EAP-Request/EAP-NOOB ----------------|
      |      (Type=8,PeerId,KeyingMode,[PKs2],Ns2)       |
      |                                                  |
      |                                                  |
      |------------ EAP-Response/EAP-NOOB -------------->|
      |      (Type=8,PeerId,[PKp2],Np2)                  |
      |                                                  |
      |                                                  |
      |<----------- EAP-Request/EAP-NOOB ----------------|
      |      (Type=9,PeerId,MACs2)                       |
      |                                                  |
      |                                                  |
      |------------ EAP-Response/EAP-NOOB -------------->|
      |      (Type=9,PeerId,MACp2)                       |
      |                                                  |
      |                                                  |
      |<----------- EAP-Success -------------------------|
      |                                                  |
:::

[Figure 8](#figure-8){.selfRef}: [Reconnect
Exchange](#name-reconnect-exchange-2){.selfRef}
:::
:::
:::

::: {#userreset}
::: {#section-3.4.3 .section}
#### [3.4.3.](#section-3.4.3){.section-number .selfRef} [User Reset](#name-user-reset){.section-name .selfRef} {#name-user-reset}

As shown in the association state machine in [Figure
1](#fig-statemachine){.xref}, the only specified way for the association
to return from the Registered (4) state to the Unregistered (0) state is
through user-initiated reset. After the reset, a new OOB message will be
needed to establish a new association between the EAP server and peer.
Typical situations in which the user reset is required are when the
other side has accidentally lost the persistent EAP-NOOB association
data or when the peer device is
decommissioned.[¶](#section-3.4.3-1){.pilcrow}

The server could detect that the peer is in the Registered or
Reconnecting state, but the server itself is in one of the ephemeral
states 0..2 (including situations where the server does not recognize
the PeerId). In this case, effort should be made to recover the
persistent server state, for example, from a backup storage \--
especially if many peer devices are similarly affected. If that is not
possible, the EAP server [SHOULD]{.bcp14} log the error or notify an
administrator. The only way to continue from such a situation is by
having the user reset the peer device.[¶](#section-3.4.3-2){.pilcrow}

On the other hand, if the peer is in any of the ephemeral states 0..2,
including the Unregistered state, the server will treat the peer as a
new peer device and allocate a new PeerId to it. The PeerInfo can be
used by the user as a clue to which physical device has lost its state.
However, there is no secure way of matching the \"new\" peer with the
old PeerId without repeating the OOB Step. This situation will be
resolved when the user performs the OOB Step and thus identifies the
physical peer device. The server user interface [MAY]{.bcp14} support
situations where the \"new\" peer is actually a previously registered
peer that has been reset by a user or otherwise lost its persistent
data. In those cases, the user could choose to merge the new peer
identity with the old one in the server. The alternative is to treat the
device just like a new peer.[¶](#section-3.4.3-3){.pilcrow}
:::
:::
:::
:::

::: {#keyderivation}
::: {#section-3.5 .section}
### [3.5.](#section-3.5){.section-number .selfRef} [Key Derivation](#name-key-derivation){.section-name .selfRef} {#name-key-derivation}

EAP-NOOB derives the EAP output values MSK and EMSK and other secret
keying material from the output of an Ephemeral Elliptic Curve
Diffie-Hellman (ECDHE) algorithm following the NIST specification
\[[NIST-DH](#NIST-DH){.xref}\]. In NIST terminology, we use a C(2e, 0s,
ECC CDH) scheme, i.e., two ephemeral keys and no static keys. In the
Initial Exchange and Reconnect Exchange, the server and peer compute the
ECDHE shared secret Z, as defined in Section 6.1.2 of the NIST
specification \[[NIST-DH](#NIST-DH){.xref}\]. In the Completion Exchange
and Reconnect Exchange, the server and peer compute the secret keying
material from Z with the one-step key derivation function (KDF) defined
in Section 5.8.2.1 of the NIST specification. The auxiliary function H
is a hash function, and it is taken from the negotiated
cryptosuite.[¶](#section-3.5-1){.pilcrow}

[]{#name-keying-modes}

::: {#keyingmodes}
  KeyingMode   Description
  ------------ ---------------------------------------------------------------------
  0            Completion Exchange (always with ECDHE)
  1            Reconnect Exchange, rekeying without ECDHE
  2            Reconnect Exchange, rekeying with ECHDE, no change in cryptosuite
  3            Reconnect Exchange, rekeying with ECDHE, new cryptosuite negotiated

  : [Table 3](#table-3){.selfRef}: [Keying
  Modes](#name-keying-modes){.selfRef}
:::

The key derivation has four different modes (KeyingMode), which are
specified in [Table 3](#keyingmodes){.xref}. [Table
4](#tab-keyderivationinput){.xref} defines the inputs to KDF in each
KeyingMode.[¶](#section-3.5-3){.pilcrow}

In the Completion Exchange (KeyingMode=0), the input Z comes from the
preceding Initial exchange. The KDF takes some additional inputs
(FixedInfo), for which we use the concatenation format defined in
Section 5.8.2.1.1 of the NIST specification
\[[NIST-DH](#NIST-DH){.xref}\]. FixedInfo consists of the AlgorithmId,
PartyUInfo, PartyVInfo, and SuppPrivInfo fields. The first three fields
are fixed-length bit strings, and SuppPrivInfo is a variable-length
string with a one-byte Datalength counter. AlgorithmId is the
fixed-length, 8-byte ASCII string \"EAP-NOOB\". The other input values
are the server and peer nonces. In the Completion Exchange, the inputs
also include the secret nonce Noob from the OOB
message.[¶](#section-3.5-4){.pilcrow}

In the simplest form of the Reconnect Exchange (KeyingMode=1), fresh
nonces are exchanged, but no ECDHE keys are sent. In this case, input Z
to the KDF is replaced with the shared key Kz from the persistent
EAP-NOOB association. The result is rekeying without the computational
cost of the ECDHE exchange but also without forward
secrecy.[¶](#section-3.5-5){.pilcrow}

When forward secrecy is desired in the Reconnect Exchange (KeyingMode=2
or KeyingMode=3), both nonces and ECDHE keys are exchanged. Input Z is
the fresh shared secret from the ECDHE exchange with PKs2 and PKp2. The
inputs also include the shared secret Kz from the persistent EAP-NOOB
association. This binds the rekeying output to the previously
authenticated keys.[¶](#section-3.5-6){.pilcrow}

[]{#name-key-derivation-input}

::: {#tab-keyderivationinput}
  KeyingMode                                                        KDF input field   Value                                    Length (bytes)
  ----------------------------------------------------------------- ----------------- ---------------------------------------- ----------------
  0 Completion                                                      Z                 ECDHE shared secret from PKs and PKp     variable
                                                                    AlgorithmId       \"EAP-NOOB\"                             8
                                                                    PartyUInfo        Np                                       32
                                                                    PartyVInfo        Ns                                       32
                                                                    SuppPubInfo       (not allowed)                            
                                                                    SuppPrivInfo      Noob                                     16
  1 Reconnect, rekeying without ECDHE                               Z                 Kz                                       32
                                                                    AlgorithmId       \"EAP-NOOB\"                             8
                                                                    PartyUInfo        Np2                                      32
                                                                    PartyVInfo        Ns2                                      32
                                                                    SuppPubInfo       (not allowed)                            
                                                                    SuppPrivInfo      (null)                                   0
  2 or 3 Reconnect, rekeying, with ECDHE, same or new cryptosuite   Z                 ECDHE shared secret from PKs2 and PKp2   variable
                                                                    AlgorithmId       \"EAP-NOOB\"                             8
                                                                    PartyUInfo        Np2                                      32
                                                                    PartyVInfo        Ns2                                      32
                                                                    SuppPubInfo       (not allowed)                            
                                                                    SuppPrivInfo      Kz                                       32

  : [Table 4](#table-4){.selfRef}: [Key Derivation
  Input](#name-key-derivation-input){.selfRef}
:::

[Table 5](#tab-keyderivationoutput){.xref} defines how the output bytes
of the KDF are used. In addition to the EAP output values MSK and EMSK,
the server and peer derive another shared secret key AMSK (Application
Main Session Key), which [MAY]{.bcp14} be used for application-layer
security. Further output bytes are used internally by EAP-NOOB for the
message authentication keys (Kms, Kmp, Kms2, and
Kmp2).[¶](#section-3.5-8){.pilcrow}

The Completion Exchange (KeyingMode=0) produces the shared secret Kz,
which the server and peer store in the persistent EAP-NOOB association.
When a new cryptosuite is negotiated in the Reconnect Exchange
(KeyingMode=3), it similarly produces a new Kz. In that case, the server
and peer update both the cryptosuite and Kz in the persistent EAP-NOOB
association. Additionally, the peer stores the previous Cryptosuitep and
Kz values in the CryptosuitepPrev and KzPrev fields of the persistent
EAP-NOOB association.[¶](#section-3.5-9){.pilcrow}

[]{#name-key-derivation-output}

::: {#tab-keyderivationoutput}
  KeyingMode                                                                          KDF output bytes   Used as    Length (bytes)
  ----------------------------------------------------------------------------------- ------------------ ---------- ----------------
  0 Completion                                                                        0..63              MSK        64
                                                                                      64..127            EMSK       64
                                                                                      128..191           AMSK       64
                                                                                      192..223           MethodId   32
                                                                                      224..255           Kms        32
                                                                                      256..287           Kmp        32
                                                                                      288..319           Kz         32
  1 or 2 Reconnect, rekeying without ECDHE, or with ECDHE and unchanged cryptosuite   0..63              MSK        64
                                                                                      64..127            EMSK       64
                                                                                      128..191           AMSK       64
                                                                                      192..223           MethodId   32
                                                                                      224..255           Kms2       32
                                                                                      256..287           Kmp2       32
  3 Reconnect, rekeying with ECDHE, new cryptosuite                                   0..63              MSK        64
                                                                                      64..127            EMSK       64
                                                                                      128..191           AMSK       64
                                                                                      192..223           MethodId   32
                                                                                      224..255           Kms2       32
                                                                                      256..287           Kmp2       32
                                                                                      288..319           Kz         32

  : [Table 5](#table-5){.selfRef}: [Key Derivation
  Output](#name-key-derivation-output){.selfRef}
:::

Finally, every EAP method must export a Server-Id, Peer-Id, and
Session-Id \[[RFC5247](#RFC5247){.xref}\]. In EAP-NOOB, the exported
Peer-Id is the PeerId that the server has assigned to the peer. The
exported Server-Id is a zero-length string (i.e., null string) because
EAP-NOOB neither knows nor assigns any server identifier. The exported
Session-Id is created by concatenating the one-byte Type-Code 0x38
(decimal value 56) with the MethodId, which is obtained from the KDF
output, as shown in [Table
5](#tab-keyderivationoutput){.xref}.[¶](#section-3.5-11){.pilcrow}
:::
:::

::: {#failure}
::: {#section-3.6 .section}
### [3.6.](#section-3.6){.section-number .selfRef} [Error Handling](#name-error-handling){.section-name .selfRef} {#name-error-handling}

Various error conditions in EAP-NOOB are handled by sending an error
notification message (Type=0) instead of a next EAP request or response
message. Both the EAP server and the peer may send the error
notification, as shown in Figures [9](#fig-servererror){.xref} and
[10](#fig-peererror){.xref}. After sending or receiving an error
notification, the server [MUST]{.bcp14} send an EAP-Failure (as required
by \[[RFC3748](#RFC3748){.xref}\], [Section
4.2](https://www.rfc-editor.org/rfc/rfc3748#section-4.2){.relref}). The
notification [MAY]{.bcp14} contain an ErrorInfo field, which is a
UTF-8-encoded text string with a maximum length of 500 bytes. It is used
for sending descriptive information about the error for logging and
debugging purposes.[¶](#section-3.6-1){.pilcrow}

[]{#name-error-notification-from-ser}

::: {#fig-servererror}
::: {#section-3.6-2.1 .alignCenter .art-text .artwork}
    EAP Peer                                        EAP Server
      ...                                                ...
      |                                                  |
      |<----------- EAP-Request/EAP-NOOB ----------------|
      |        (Type=0,[PeerId],ErrorCode,[ErrorInfo])   |
      |                                                  |
      |                                                  |
      |<----------- EAP-Failure -------------------------|
      |                                                  |
:::

[Figure 9](#figure-9){.selfRef}: [Error Notification from Server to
Peer](#name-error-notification-from-ser){.selfRef}
:::

[]{#name-error-notification-from-pee}

::: {#fig-peererror}
::: {#section-3.6-3.1 .alignCenter .art-text .artwork}
    EAP Peer                                        EAP Server
      ...                                                ...
      |                                                  |
      |------------ EAP-Response/EAP-NOOB -------------->|
      |        (Type=0,[PeerId],ErrorCode,[ErrorInfo])   |
      |                                                  |
      |                                                  |
      |<----------- EAP-Failure -------------------------|
      |                                                  |
:::

[Figure 10](#figure-10){.selfRef}: [Error Notification from Peer to
Server](#name-error-notification-from-pee){.selfRef}
:::

After the exchange fails due to an error notification, the server and
peer set the association state as follows. In the Initial Exchange, both
the sender and recipient of the error notification [MUST]{.bcp14} set
the association state to the Unregistered (0) state. In the Waiting
Exchange and Completion Exchange, each side [MUST]{.bcp14} remain in its
old state as if the failed exchange had not taken place, with the
exception that the recipient of error code 2003 processes it as
specified in [Section 3.2.4](#completionexchange){.xref}. In the
Reconnect Exchange, both sides [MUST]{.bcp14} set the association state
to the Reconnecting (3) state.[¶](#section-3.6-4){.pilcrow}

Errors that occur in the OOB channel are not explicitly notified
in-band.[¶](#section-3.6-5){.pilcrow}

::: {#invalidmessages}
::: {#section-3.6.1 .section}
#### [3.6.1.](#section-3.6.1){.section-number .selfRef} [Invalid Messages](#name-invalid-messages){.section-name .selfRef} {#name-invalid-messages}

If the NAI structure is invalid, the server [SHOULD]{.bcp14} send the
error code 1001 to the peer. The recipient of an EAP-NOOB request or
response [SHOULD]{.bcp14} send the following error codes back to the
sender: 1002 if it cannot parse the message as a JSON object or the
top-level JSON object has missing or unrecognized members; 1003 if a
data field has an invalid value, such as an integer out of range, and
there is no more specific error code available; 1004 if the received
message type was unexpected in the current state; 2004 if the PeerId has
an unexpected value; 2003 if the NoobId is not recognized; and 1005 if
the ECDHE key is invalid.[¶](#section-3.6.1-1){.pilcrow}
:::
:::

::: {#unwantedpeer}
::: {#section-3.6.2 .section}
#### [3.6.2.](#section-3.6.2){.section-number .selfRef} [Unwanted Peer](#name-unwanted-peer){.section-name .selfRef} {#name-unwanted-peer}

The preferred way for the EAP server to rate limit EAP-NOOB connections
from a peer is to use the SleepTime parameter in the Waiting Exchange.
However, if the EAP server receives repeated EAP-NOOB connections from a
peer that apparently should not connect to this server, the server
[MAY]{.bcp14} indicate that the connections are unwanted by sending the
error code 2001. After receiving this error message, the peer
[MAY]{.bcp14} refrain from reconnecting to the same EAP server, and, if
possible, both the EAP server and peer [SHOULD]{.bcp14} indicate this
error condition to the user or server administrator. However, in order
to avoid persistent denial of service, peer devices that are unable to
alert a user [SHOULD]{.bcp14} continue to try to reconnect infrequently
(e.g., approximately every 3600 seconds).[¶](#section-3.6.2-1){.pilcrow}
:::
:::

::: {#statemismatch}
::: {#section-3.6.3 .section}
#### [3.6.3.](#section-3.6.3){.section-number .selfRef} [State Mismatch](#name-state-mismatch){.section-name .selfRef} {#name-state-mismatch}

In the states indicated by \"-\" in [Table 14](#tab-exchanges){.xref} in
[Appendix A](#exchangeappendix){.xref}, user action is required to reset
the association state or to recover it, for example, from backup
storage. In those cases, the server sends the error code 2002 to the
peer. If possible, both the EAP server and peer [SHOULD]{.bcp14}
indicate this error condition to the user or server
administrator.[¶](#section-3.6.3-1){.pilcrow}
:::
:::

::: {#negotiationfailure}
::: {#section-3.6.4 .section}
#### [3.6.4.](#section-3.6.4){.section-number .selfRef} [Negotiation Failure](#name-negotiation-failure){.section-name .selfRef} {#name-negotiation-failure}

If there is no matching protocol version, the peer sends the error code
3001 to the server. If there is no matching cryptosuite, the peer sends
the error code 3002 to the server. If there is no matching OOB
direction, the peer sends the error code 3003 to the
server.[¶](#section-3.6.4-1){.pilcrow}

In practice, there is no way of recovering from these errors without
software or hardware changes. If possible, both the EAP server and peer
[SHOULD]{.bcp14} indicate these error conditions to the
user.[¶](#section-3.6.4-2){.pilcrow}
:::
:::

::: {#cryptofailure}
::: {#section-3.6.5 .section}
#### [3.6.5.](#section-3.6.5){.section-number .selfRef} [Cryptographic Verification Failure](#name-cryptographic-verification-){.section-name .selfRef} {#name-cryptographic-verification-}

If the receiver of the OOB message detects an unrecognized PeerId or
incorrect fingerprint (Hoob) in the OOB message, the receiver
[MUST]{.bcp14} remain in the Waiting for OOB (1) state as if no OOB
message was received. The receiver [SHOULD]{.bcp14} indicate the failure
to accept the OOB message to the user. No in-band error message is
sent.[¶](#section-3.6.5-1){.pilcrow}

Note that if the OOB message was delivered from the server to the peer
and the peer does not recognize the PeerId, the likely cause is that the
user has unintentionally delivered the OOB message to the wrong peer
device. If possible, the peer [SHOULD]{.bcp14} indicate this to the
user; however, the peer device may not have the capability for many
different error indications to the user, and it [MAY]{.bcp14} use the
same indication as in the case of an incorrect
fingerprint.[¶](#section-3.6.5-2){.pilcrow}

The rationale for the above is that the invalid OOB message could have
been presented to the receiver by mistake or intentionally by a
malicious party; thus, it should be ignored in the hope that the honest
user will soon deliver a correct OOB
message.[¶](#section-3.6.5-3){.pilcrow}

If the EAP server or peer detects an incorrect message authentication
code (MACs, MACp, MACs2, or MACp2), it sends the error code 4001 to the
other side. As specified in the beginning of [Section
3.6](#failure){.xref}, the failed Completion Exchange will not result in
server or peer state changes, while an error in the Reconnect Exchange
will put both sides to the Reconnecting (3) state and thus lead to
another reconnect attempt.[¶](#section-3.6.5-4){.pilcrow}

The rationale for this is that the invalid cryptographic message may
have been spoofed by a malicious party; thus, it should be ignored. In
particular, a spoofed message on the in-band channel should not force
the honest user to perform the OOB Step again. In practice, however, the
error may be caused by other failures, such as a software bug. For this
reason, the EAP server [MAY]{.bcp14} limit the rate of peer connections
with SleepTime after the above error. Also, there [SHOULD]{.bcp14} be a
way for the user to reset the peer to the Unregistered (0) state so that
the OOB Step can be repeated as the last
resort.[¶](#section-3.6.5-5){.pilcrow}
:::
:::

::: {#appfailure}
::: {#section-3.6.6 .section}
#### [3.6.6.](#section-3.6.6){.section-number .selfRef} [Application-Specific Failure](#name-application-specific-failur){.section-name .selfRef} {#name-application-specific-failur}

Applications [MAY]{.bcp14} define new error messages for failures that
are specific to the application or to one type of OOB channel. They
[MAY]{.bcp14} also use the generic application-specific error code 5001
or the error codes 5002 and 5004, which have been reserved for
indicating invalid data in the ServerInfo and PeerInfo fields,
respectively. Additionally, anticipating OOB channels that make use of a
URL, the error code 5003 has been reserved for indicating an invalid
server URL.[¶](#section-3.6.6-1){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#serverinfo-peerinfo-meaning}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [ServerInfo and PeerInfo Contents](#name-serverinfo-and-peerinfo-con){.section-name .selfRef} {#name-serverinfo-and-peerinfo-con}

The ServerInfo and PeerInfo fields in the Initial Exchange and Reconnect
Exchange enable the server and peer, respectively, to send information
about themselves to the other endpoint. They contain JSON objects whose
structure may be specified separately for each application and each type
of OOB channel. ServerInfo and PeerInfo [MAY]{.bcp14} contain auxiliary
data needed for the OOB channel messaging and for EAP channel binding
(see [Section 6.7](#channel-binding){.xref}). This section describes the
optional initial data fields for ServerInfo and PeerInfo registered by
this specification. Further specifications may request new
application-specific ServerInfo and PeerInfo data fields from IANA (see
Sections [5.4](#serverinfo-data-fields){.xref} and
[5.5](#peerinfo-data-fields){.xref}).[¶](#section-4-1){.pilcrow}

[]{#name-serverinfo-data-fields}

::: {#tab-serverinfo-meaning}
  Data Field       Description
  ---------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Type             Type-tag string that can be used by the peer as a hint for how to interpret the ServerInfo contents.
  ServerName       String that may be used to aid human identification of the server.
  ServerURL        Prefix string when the OOB message is formatted as a URL, as suggested in [Appendix D](#urloob){.xref}.
  SSIDList         List of IEEE 802.11 wireless network service set identifier (SSID) strings used for roaming support, as suggested in [Appendix C](#roaming){.xref}. JSON array of ASCII-encoded SSID strings.
  Base64SSIDList   List of IEEE 802.11 wireless network identifier (SSID) strings used for roaming support, as suggested in [Appendix C](#roaming){.xref}. JSON array of SSIDs, each of which is base64url-encoded without padding. Peers [SHOULD]{.bcp14} send at most one of the fields SSIDList and Base64SSIDList in PeerInfo, and the server [SHOULD]{.bcp14} ignore SSIDList if Base64SSIDList is included.

  : [Table 6](#table-6){.selfRef}: [ServerInfo Data
  Fields](#name-serverinfo-data-fields){.selfRef}
:::

[]{#name-peerinfo-data-fields}

::: {#tab-peerinfo-meaning}
  Data Field     Description
  -------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Type           Type-tag string that can be used by the server as a hint for how to interpret the PeerInfo contents.
  PeerName       String that may be used to aid human identification of the peer.
  Manufacturer   Manufacturer or brand string.
  Model          Manufacturer-specified model string.
  SerialNumber   Manufacturer-assigned serial number.
  MACAddress     Peer link-layer 48-bit extended unique identifier (EUI-48) in the 12-digit base-16 form \[[EUI-48](#EUI-48){.xref}\]. The string [MAY]{.bcp14} be in upper or lower case and [MAY]{.bcp14} include additional colon \':\' or dash \'-\' characters that [MUST]{.bcp14} be ignored by the server.
  SSID           IEEE 802.11 network SSID for channel binding. The SSID is an ASCII string.
  Base64SSID     IEEE 802.11 network SSID for channel binding. The SSID is base64url encoded. Peer [SHOULD]{.bcp14} send at most one of the fields SSID and Base64SSID in PeerInfo, and the server [SHOULD]{.bcp14} ignore SSID if Base64SSID is included.
  BSSID          Wireless network basic service set identifier (BSSID) (EUI-48) in the 12-digit base-16 form \[[EUI-48](#EUI-48){.xref}\] for channel binding. The string [MAY]{.bcp14} be in upper or lower case and [MAY]{.bcp14} include additional colon \':\' or dash \'-\' characters that [MUST]{.bcp14} be ignored by the server.

  : [Table 7](#table-7){.selfRef}: [PeerInfo Data
  Fields](#name-peerinfo-data-fields){.selfRef}
:::
:::
:::

::: {#iana}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This section provides information regarding registration of values
related to the EAP-NOOB method, in accordance with
\[[RFC8126](#RFC8126){.xref}\].[¶](#section-5-1){.pilcrow}

The EAP Method Type for EAP-NOOB (value 56) has been assigned in the
\"Method Types\" subregistry of the \"Extensible Authentication Protocol
(EAP) Registry\".[¶](#section-5-2){.pilcrow}

Per this memo, IANA has created and will maintain a new registry
entitled \"Nimble Out-of-Band Authentication for EAP Parameters
(EAP-NOOB)\" in the Extensible Authentication Protocol (EAP) category.
Also, IANA has created and will maintain the subregistries defined in
the following subsections.[¶](#section-5-3){.pilcrow}

::: {#cryptosuites}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Cryptosuites](#name-cryptosuites){.section-name .selfRef} {#name-cryptosuites}

IANA has created and will maintain a new subregistry entitled \"EAP-NOOB
Cryptosuites\" in the \"Nimble Out-of-Band Authentication for EAP
Parameters (EAP-NOOB)\" registry. Cryptosuites are identified by an
integer. Each cryptosuite [MUST]{.bcp14} specify an ECDHE curve for the
key exchange, encoding of the ECDHE public key as a JWK object, and a
cryptographic hash function for the fingerprint and HMAC computation and
key derivation. The hash value output by the cryptographic hash function
[MUST]{.bcp14} be at least 32 bytes in length. The initial values for
this registry are:[¶](#section-5.1-1){.pilcrow}

[]{#name-eap-noob-cryptosuites}

::: {#tab-cryptosuites}
  Cryptosuite   Algorithms
  ------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  0             Reserved
  1             ECDHE curve Curve25519 \[[RFC7748](#RFC7748){.xref}\], public-key format \[[RFC7517](#RFC7517){.xref}\], hash function SHA-256 \[[RFC6234](#RFC6234){.xref}\]. The JWK encoding of Curve25519 public key is defined in \[[RFC8037](#RFC8037){.xref}\]. For clarity, the \"crv\" parameter is \"X25519\", the \"kty\" parameter is \"OKP\", and the public-key encoding contains only an x-coordinate.
  2             ECDHE curve NIST P-256 \[[FIPS186-4](#FIPS186-4){.xref}\], public-key format \[[RFC7517](#RFC7517){.xref}\], hash function SHA-256 \[[RFC6234](#RFC6234){.xref}\]. The JWK encoding of NIST P-256 public key is defined in \[[RFC7518](#RFC7518){.xref}\]. For clarity, the \"crv\" parameter is \"P-256\", the \"kty\" parameter is \"EC\", and the public-key encoding has both an x and y coordinate, as defined in [Section 6.2.1](https://www.rfc-editor.org/rfc/rfc7518#section-6.2.1){.relref} of \[[RFC7518](#RFC7518){.xref}\].

  : [Table 8](#table-8){.selfRef}: [EAP-NOOB
  Cryptosuites](#name-eap-noob-cryptosuites){.selfRef}
:::

EAP-NOOB implementations [MUST]{.bcp14} support Cryptosuite 1. Support
for Cryptosuite 2 is [RECOMMENDED]{.bcp14}. An example of a Cryptosuite
1 public-key encoded as a JWK object is given below. (Line breaks are
for readability only.)[¶](#section-5.1-3){.pilcrow}

::: {#section-5.1-4}
``` {.lang-json .sourcecode}
"jwk":{"kty":"OKP","crv":"X25519","x":"3p7bfXt9wbTTW2HC7OQ1Nz-
DQ8hbeGdNrfx-FG-IK08"}
```

[¶](#section-5.1-4){.pilcrow}
:::

Assignment of new values for new cryptosuites [MUST]{.bcp14} be done
through IANA with \"Specification Required\", as defined in
\[[RFC8126](#RFC8126){.xref}\].[¶](#section-5.1-5){.pilcrow}
:::
:::

::: {#messagetypes}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Message Types](#name-message-types){.section-name .selfRef} {#name-message-types}

IANA has created and will maintain a new subregistry entitled \"EAP-NOOB
Message Types\" in the \"Nimble Out-of-Band Authentication for EAP
Parameters (EAP-NOOB)\" registry. EAP-NOOB request and response pairs
are identified by an integer Message Type. The initial values for this
registry are:[¶](#section-5.2-1){.pilcrow}

[]{#name-eap-noob-message-types}

::: {#tab-messagetypes}
  Message Type   Used in Exchange   Purpose
  -------------- ------------------ ----------------------------------------------------------------------------
  0              Error              Error notification
  1              All exchanges      PeerId and PeerState discovery
  2              Initial            Version, cryptosuite, and parameter negotiation
  3              Initial            Exchange of ECDHE keys and nonces
  4              Waiting            Indication to the peer that the server has not yet received an OOB message
  5              Completion         NoobId discovery
  6              Completion         Authentication and key confirmation with HMAC
  7              Reconnect          Version, cryptosuite, and parameter negotiation
  8              Reconnect          Exchange of ECDHE keys and nonces
  9              Reconnect          Authentication and key confirmation with HMAC

  : [Table 9](#table-9){.selfRef}: [EAP-NOOB Message
  Types](#name-eap-noob-message-types){.selfRef}
:::

Assignment of new values for new Message Types [MUST]{.bcp14} be done
through IANA with \"Specification Required\", as defined in
\[[RFC8126](#RFC8126){.xref}\].[¶](#section-5.2-3){.pilcrow}
:::
:::

::: {#errorcodes}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Error Codes](#name-error-codes){.section-name .selfRef} {#name-error-codes}

IANA has created and will maintain a new subregistry entitled \"EAP-NOOB
Error codes\" in the \"Nimble Out-of-Band Authentication for EAP
Parameters (EAP-NOOB)\" registry. Cryptosuites are identified by an
integer. The initial values for this registry
are:[¶](#section-5.3-1){.pilcrow}

[]{#name-eap-noob-error-codes}

::: {#tab-errors}
  Error code   Purpose
  ------------ -------------------------------------------
  1001         Invalid NAI
  1002         Invalid message structure
  1003         Invalid data
  1004         Unexpected message type
  1005         Invalid ECDHE key
  2001         Unwanted peer
  2002         State mismatch, user action required
  2003         Unrecognized OOB message identifier
  2004         Unexpected peer identifier
  3001         No mutually supported protocol version
  3002         No mutually supported cryptosuite
  3003         No mutually supported OOB direction
  4001         HMAC verification failure
  5001         Application-specific error
  5002         Invalid server info
  5003         Invalid server URL
  5004         Invalid peer info
  6001-6999    Reserved for Private and Experimental Use

  : [Table 10](#table-10){.selfRef}: [EAP-NOOB Error
  Codes](#name-eap-noob-error-codes){.selfRef}
:::

Assignment of new error codes [MUST]{.bcp14} be done through IANA with
\"Specification Required\", as defined in
\[[RFC8126](#RFC8126){.xref}\], except for the range 6001-6999. This
range is reserved for \"Private Use\" and \"Experimental Use\", both
locally and on the open Internet.[¶](#section-5.3-3){.pilcrow}
:::
:::

::: {#serverinfo-data-fields}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [ServerInfo Data Fields](#name-serverinfo-data-fields-2){.section-name .selfRef} {#name-serverinfo-data-fields-2}

IANA has created and will maintain a new subregistry entitled \"EAP-NOOB
ServerInfo Data Fields\" in the \"Nimble Out-of-Band Authentication for
EAP Parameters (EAP-NOOB)\" registry. The initial values for this
registry are:[¶](#section-5.4-1){.pilcrow}

[]{#name-serverinfo-data-fields-3}

::: {#tab-serverinfo-data-fields}
  Data Field       Specification
  ---------------- ------------------------------------------------------------
  Type             RFC 9140, [Section 4](#serverinfo-peerinfo-meaning){.xref}
  ServerName       RFC 9140, [Section 4](#serverinfo-peerinfo-meaning){.xref}
  ServerURL        RFC 9140, [Section 4](#serverinfo-peerinfo-meaning){.xref}
  SSIDList         RFC 9140, [Section 4](#serverinfo-peerinfo-meaning){.xref}
  Base64SSIDList   RFC 9140, [Section 4](#serverinfo-peerinfo-meaning){.xref}

  : [Table 11](#table-11){.selfRef}: [ServerInfo Data
  Fields](#name-serverinfo-data-fields-3){.selfRef}
:::

Assignment of new values for new ServerInfo data fields [MUST]{.bcp14}
be done through IANA with \"Specification Required\", as defined in
\[[RFC8126](#RFC8126){.xref}\].[¶](#section-5.4-3){.pilcrow}
:::
:::

::: {#peerinfo-data-fields}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [PeerInfo Data Fields](#name-peerinfo-data-fields-2){.section-name .selfRef} {#name-peerinfo-data-fields-2}

IANA is requested to create and maintain a new subregistry entitled
\"EAP-NOOB PeerInfo Data Fields\" in the \"Nimble Out-of-Band
Authentication for EAP Parameters (EAP-NOOB)\" registry. The initial
values for this registry are:[¶](#section-5.5-1){.pilcrow}

[]{#name-peerinfo-data-fields-3}

::: {#peerinfo-data-fields-table}
  Data Field     Specification
  -------------- ------------------------------------------------------------
  Type           RFC 9140, [Section 4](#serverinfo-peerinfo-meaning){.xref}
  PeerName       RFC 9140, [Section 4](#serverinfo-peerinfo-meaning){.xref}
  Manufacturer   RFC 9140, [Section 4](#serverinfo-peerinfo-meaning){.xref}
  Model          RFC 9140, [Section 4](#serverinfo-peerinfo-meaning){.xref}
  SerialNumber   RFC 9140, [Section 4](#serverinfo-peerinfo-meaning){.xref}
  MACAddress     RFC 9140, [Section 4](#serverinfo-peerinfo-meaning){.xref}
  SSID           RFC 9140, [Section 4](#serverinfo-peerinfo-meaning){.xref}
  Base64SSID     RFC 9140, [Section 4](#serverinfo-peerinfo-meaning){.xref}
  BSSID          RFC 9140, [Section 4](#serverinfo-peerinfo-meaning){.xref}

  : [Table 12](#table-12){.selfRef}: [PeerInfo Data
  Fields](#name-peerinfo-data-fields-3){.selfRef}
:::

Assignment of new values for new PeerInfo data fields [MUST]{.bcp14} be
done through IANA with \"Specification Required\", as defined in
\[[RFC8126](#RFC8126){.xref}\].[¶](#section-5.5-3){.pilcrow}
:::
:::

::: {#specialdomainname}
::: {#section-5.6 .section}
### [5.6.](#section-5.6){.section-number .selfRef} [Domain Name Reservation](#name-domain-name-reservation){.section-name .selfRef} {#name-domain-name-reservation}

The special-use domain \"eap-noob.arpa\" has been registered in the
.arpa registry (<https://www.iana.org/domains/arpa>) and the
\"Special-Use Domain Names\" registry
(<https://www.iana.org/assignments/special-use-domain-names>).[¶](#section-5.6-1){.pilcrow}
:::
:::

::: {#expertguidance}
::: {#section-5.7 .section}
### [5.7.](#section-5.7){.section-number .selfRef} [Guidance for Designated Experts](#name-guidance-for-designated-exp){.section-name .selfRef} {#name-guidance-for-designated-exp}

Experts [SHOULD]{.bcp14} be conservative in the allocation of new
Cryptosuites. Experts [MUST]{.bcp14} ascertain that the requested values
match the current Crypto Forum Research Group (CFRG) guidance on
cryptographic algorithm security. Experts [MUST]{.bcp14} ensure that any
new Cryptosuites fully specify the encoding of the ECDHE public key and
should include details, such as the value of the \"kty\" (key type)
parameter when JWK \[[RFC7517](#RFC7517){.xref}\] encoding is
used.[¶](#section-5.7-1){.pilcrow}

Experts [SHOULD]{.bcp14} be conservative in the allocation of new
Message Types. Experts [SHOULD]{.bcp14} ascertain that a well-defined
specification for the new Message Type is permanently and publicly
available.[¶](#section-5.7-2){.pilcrow}

Experts [SHOULD]{.bcp14} be conservative in the allocation of new Error
codes, since the 6001-6999 range is already reserved for private and
experimental use.[¶](#section-5.7-3){.pilcrow}

Experts [MAY]{.bcp14} be liberal in the allocation of new ServerInfo and
PeerInfo data fields. Experts [MUST]{.bcp14} ensure that the data field
requested has a unique name that is not easily confused with existing
registrations. For example, requests for a new PeerInfo data field
\"ssid\" should be rejected even though it is unique because it can be
confused with the existing registration of \"SSID\". Experts
[MUST]{.bcp14} ensure that a suitable Description for the data field is
available.[¶](#section-5.7-4){.pilcrow}
:::
:::
:::
:::

::: {#securityconsiderations}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

EAP-NOOB is an authentication and key derivation protocol; thus,
security considerations can be found in most sections of this
specification. In the following, we explain the protocol design and
highlight some other special considerations.[¶](#section-6-1){.pilcrow}

::: {#authenticationprinciple}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Authentication Principle](#name-authentication-principle){.section-name .selfRef} {#name-authentication-principle}

EAP-NOOB establishes a shared secret with an authenticated ECDHE key
exchange. The mutual authentication in EAP-NOOB is based on two separate
features, both conveyed in the OOB message. The first authentication
feature is the secret nonce Noob. The peer and server use this secret in
the Completion Exchange to mutually authenticate the session key
previously created with ECDHE. The message authentication codes computed
with the secret nonce Noob are alone sufficient for authenticating the
key exchange. The second authentication feature is the
integrity-protecting fingerprint Hoob. Its purpose is to prevent
impersonation attacks even in situations where the attacker is able to
eavesdrop on the OOB channel and the nonce Noob is compromised. In some
human-assisted OOB channels, such as human-perceptible audio or a
user-typed URL, it may be easier to detect tampering than disclosure of
the OOB message, and such applications benefit from the second
authentication feature.[¶](#section-6.1-1){.pilcrow}

The additional security provided by the cryptographic fingerprint Hoob
is somewhat intricate to understand. The endpoint that receives the OOB
message uses Hoob to verify the integrity of the ECDHE exchange. Thus,
the OOB receiver can detect impersonation attacks that may have happened
on the in-band channel. The other endpoint, however, is not equally
protected because the OOB message and fingerprint are sent only in one
direction. Some protection to the OOB sender is afforded by the fact
that the user may notice the failure of the association at the OOB
receiver and therefore reset the OOB sender. Other device-pairing
protocols have solved similar situations by requiring the user to
confirm to the OOB sender that the association was accepted by the OOB
receiver, e.g., with a button press on the sender side. Applications
[MAY]{.bcp14} implement EAP-NOOB in this way. Nevertheless, since
EAP-NOOB was designed to work with strictly one-directional OOB
communication and the fingerprint is only the second authentication
feature, the EAP-NOOB specification does not mandate such explicit
confirmation to the OOB sender.[¶](#section-6.1-2){.pilcrow}

To summarize, EAP-NOOB uses the combined protection of the secret nonce
Noob and the cryptographic fingerprint Hoob, both conveyed in the OOB
message. The secret nonce Noob alone is sufficient for mutual
authentication unless the attacker can eavesdrop on it from the OOB
channel. Even if an attacker is able to eavesdrop on the secret nonce
Noob, it nevertheless cannot perform a full impersonation attack on the
in-band channel because a mismatching fingerprint would alert the OOB
receiver, which would reject the OOB message. The attacker that
eavesdropped on the secret nonce can impersonate the OOB receiver to the
OOB sender. If it does, the association will appear to be complete only
on the OOB sender side, and such situations have to be resolved by the
user by resetting the OOB sender to the initial
state.[¶](#section-6.1-3){.pilcrow}

The expected use cases for EAP-NOOB are ones where it replaces a
user-entered access credential in IoT appliances. In wireless network
access without EAP, the user-entered credential is often a passphrase
that is shared by all the network stations. The advantage of an
EAP-based solution, including EAP-NOOB, is that it establishes a
different shared secret for each peer device, which makes the system
more resilient against device compromise. Another advantage is that it
is possible to revoke the security association for an individual device
on the server side.[¶](#section-6.1-4){.pilcrow}

Forward secrecy during fast reconnect in EAP-NOOB is optional. The
Reconnect Exchange in EAP-NOOB provides forward secrecy only if both the
server and peer send their fresh ECDHE keys. This allows both the server
and peer to limit the frequency of the costly computation that is
required for forward secrecy. The server [MAY]{.bcp14} adjust the
frequency of its attempts at ECDHE rekeying based on what it knows about
the peer\'s computational capabilities.[¶](#section-6.1-5){.pilcrow}

Another way in which some servers may control their computational load
is to reuse the same ECDHE key for all peers over a short
server-specific time window. In that case, forward secrecy will be
achieved only after the server updates its ECDHE key, which may be a
reasonable trade-off between security and performance. However, the
server [MUST NOT]{.bcp14} reuse the same ECDHE key with the same peer
when rekeying with ECDHE (KeyingMode=2 or KeyingMode=3). Instead, it can
simply not send an ECDHE key
(KeyingMode=1).[¶](#section-6.1-6){.pilcrow}

The users delivering the OOB messages will often authenticate themselves
to the EAP server, e.g., by logging into a secure web page or API. In
this case, the server can associate the peer device with the user
account. Applications that make use of EAP-NOOB can use this information
for configuring the initial owner of the freshly registered
device.[¶](#section-6.1-7){.pilcrow}
:::
:::

::: {#deviceidentification}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Identifying Correct Endpoints](#name-identifying-correct-endpoin){.section-name .selfRef} {#name-identifying-correct-endpoin}

Potential weaknesses in EAP-NOOB arise from the fact that the user must
physically identify the correct peer device. If the user mistakenly
delivers the OOB message from the wrong peer device to the server, the
server may create an association with the wrong peer. The reliance on
the user in identifying the correct endpoints is an inherent property of
user-assisted, out-of-band authentication. To understand the potential
consequences of the user mistake, we need to consider a few different
scenarios. In the first scenario, there is no malicious party, and the
user makes an accidental mistake between two out-of-the-box devices that
are both ready to be registered to a server. If the user delivers the
OOB message from the wrong device to the server, confusion may arise but
usually no security issues. In the second scenario, an attacker
intentionally tricks the user, for example, by substituting the original
peer device with a compromised one. This is essentially a supply chain
attack where the user accepts a compromised physical
device.[¶](#section-6.2-1){.pilcrow}

There is also a third scenario, in which an opportunistic attacker tries
to take advantage of the user\'s accidental mistake. For example, the
user could play an audio or a blinking LED message to a device that is
not expecting to receive it. In simple security bootstrapping solutions
that transfer a primary key to the device via the OOB channel, the
device could misuse or leak the accidentally received primary key.
EAP-NOOB is not vulnerable to such opportunistic attackers because the
OOB message has no value to anyone who did not take part in the
corresponding Initial Exchange.[¶](#section-6.2-2){.pilcrow}

One mechanism that can mitigate user mistakes is certification of peer
devices. A certificate or an attestation token (e.g.,
\[[TLS-CWT](#I-D.tschofenig-tls-cwt){.xref}\] and
\[[RATS-EAT](#I-D.ietf-rats-eat){.xref}\]) can convey to the server
authentic identifiers and attributes, such as model and serial number,
of the peer device. Compared to a fully certificate-based
authentication, however, EAP-NOOB can be used without trusted third
parties and does not require the user to know any identifier of the peer
device; physical access to the device is sufficient for bootstrapping
with EAP-NOOB.[¶](#section-6.2-3){.pilcrow}

Similarly, the attacker can try to trick the user into delivering the
OOB message to the wrong server so that the peer device becomes
associated with the wrong server. If the EAP server is accessed through
a web user interface, the attack is akin to phishing attacks where the
user is tricked into accessing the wrong URL and wrong web page. OOB
implementation with a dedicated app on a mobile device, which
communicates with a server API at a preconfigured URL, can protect
against such attacks.[¶](#section-6.2-4){.pilcrow}

After the device registration, an attacker could clone the device
identity by copying the keys from the persistent EAP-NOOB association
into another device. The attacker can be an outsider who gains access to
the keys or the device owner who wants to have two devices matching the
same registration. The cloning threats can be mitigated by creating the
cryptographic keys and storing the persistent EAP-NOOB association on
the peer device in a secure hardware component such as a trusted
execution environment (TEE). Furthermore, remote attestation on the
application level could provide assurance to the server that the device
has not been cloned. Reconnect Exchange with a new cryptosuite
(KeyingMode=3) will also disconnect all but the first clone that
performs the update.[¶](#section-6.2-5){.pilcrow}
:::
:::

::: {#trustedpath}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Trusted Path Issues and Misbinding Attacks](#name-trusted-path-issues-and-mis){.section-name .selfRef} {#name-trusted-path-issues-and-mis}

Another potential threat is spoofed user input or output on the peer
device. When the user is delivering the OOB message to or from the
correct peer device, a trusted path between the user and the peer device
is needed. That is, the user must communicate directly with an authentic
operating system and EAP-NOOB implementation in the peer device and not
with a spoofed user interface. Otherwise, a registered device that is
under the control of the attacker could emulate the behavior of an
unregistered device. The secure path can be implemented, for example, by
having the user press a reset button to return the device to the
Unregistered (0) state and to invoke a trusted UI. The problem with such
trusted paths is that they are not standardized across
devices.[¶](#section-6.3-1){.pilcrow}

Another potential consequence of a spoofed UI is the misbinding attack
where the user tries to register a correct but compromised device, which
tricks the user into registering another (uncompromised) device instead.
For example, the compromised device might have a malicious, full-screen
app running, which presents to the user QR codes copied, in real time,
from another device\'s screen. If the unwitting user scans the QR code
and delivers the OOB message in it to the server, the wrong device may
become registered in the server. Such misbinding vulnerabilities arise
because the user does not have any secure way of verifying that the
in-band cryptographic handshake and the out-of-band physical access are
terminated at the same physical device. Sethi et al.
\[[Sethi19](#Sethi19){.xref}\] analyze the misbinding threat against
device-pairing protocols and also EAP-NOOB. Essentially, all protocols
where the authentication relies on the user\'s physical access to the
device are vulnerable to misbinding, including
EAP-NOOB.[¶](#section-6.3-2){.pilcrow}

A standardized trusted path for communicating directly with the trusted
computing base in a physical device would mitigate the misbinding
threat, but such paths rarely exist in practice. Careful asset tracking
on the server side can also prevent most misbinding attacks if the peer
device sends its identifiers or attributes in the PeerInfo field and the
server compares them with the expected values. The wrong but
uncompromised device\'s PeerInfo will not match the expected values.
Device certification by the manufacturer can further strengthen the
asset tracking.[¶](#section-6.3-3){.pilcrow}
:::
:::

::: {#peeridentifiers}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [Peer Identifiers and Attributes](#name-peer-identifiers-and-attrib){.section-name .selfRef} {#name-peer-identifiers-and-attrib}

The PeerId value in the protocol is a server-allocated identifier for
its association with the peer and [SHOULD NOT]{.bcp14} be shown to the
user because its value is initially ephemeral. Since the PeerId is
allocated by the server and the scope of the identifier is the single
server, the so-called identifier squatting attacks, where a malicious
peer could reserve another peer\'s identifier, are not possible in
EAP-NOOB. The server [SHOULD]{.bcp14} assign a random or pseudorandom
PeerId to each new peer. It [SHOULD NOT]{.bcp14} select the PeerId based
on any peer characteristics that it may know, such as the peer\'s
link-layer network address.[¶](#section-6.4-1){.pilcrow}

User reset or failure in the OOB Step can cause the peer to perform many
Initial Exchanges with the server, which allocates many PeerId values
and stores the ephemeral protocol state for them. The peer will
typically only remember the latest ones. EAP-NOOB leaves it to the
implementation to decide when to delete these ephemeral associations.
There is no security reason to delete them early, and the server does
not have any way to verify that the peers are actually the same one.
Thus, it is safest to store the ephemeral states on the server for at
least one day. If the OOB messages are sent only in the server-to-peer
direction, the server [SHOULD NOT]{.bcp14} delete the ephemeral state
before all the related Noob values have
expired.[¶](#section-6.4-2){.pilcrow}

After completion of EAP-NOOB, the server may store the PeerInfo data,
and the user may use it to identify the peer and its attributes, such as
the make and model or serial number. A compromised peer could lie in the
PeerInfo that it sends to the server. If the server stores any
information about the peer, it is important that this information is
approved by the user during or after the OOB Step. Without verification
by the user or authentication on the application level, the PeerInfo is
not authenticated information and should not be relied on. One possible
use for the PeerInfo field is EAP channel binding (see [Section
6.7](#channel-binding){.xref}).[¶](#section-6.4-3){.pilcrow}
:::
:::

::: {#downgrading}
::: {#section-6.5 .section}
### [6.5.](#section-6.5){.section-number .selfRef} [Downgrading Threats](#name-downgrading-threats){.section-name .selfRef} {#name-downgrading-threats}

The fingerprint Hoob protects all the information exchanged in the
Initial Exchange, including the cryptosuite negotiation. The message
authentication codes MACs and MACp also protect the same information.
The message authentication codes MACs2 and MACp2 protect information
exchanged during key renegotiation in the Reconnect Exchange. This
prevents downgrading attacks to weaker cryptosuites, as long as the
possible attacks take more time than the maximum time allowed for the
EAP-NOOB completion. This is typically the case for recently discovered
cryptanalytic attacks.[¶](#section-6.5-1){.pilcrow}

As an additional precaution, the EAP server and peer [MUST]{.bcp14}
check for downgrading attacks in the Reconnect Exchange as follows. As
long as the server or peer saves any information about the other
endpoint, it [MUST]{.bcp14} also remember the previously negotiated
cryptosuite and [MUST NOT]{.bcp14} accept renegotiation of any
cryptosuite that is known to be weaker than the previous one, such as a
deprecated cryptosuite. Determining the relative strength of the
cryptosuites is out of scope of this specification and may be managed by
implementations or by local policies at the peer and
server.[¶](#section-6.5-2){.pilcrow}

Integrity of the direction negotiation cannot be verified in the same
way as the integrity of the cryptosuite negotiation. That is, if the OOB
channel used in an application is critically insecure in one direction,
an on-path attacker could modify the negotiation messages and thereby
cause that direction to be used. Applications that support OOB messages
in both directions [SHOULD]{.bcp14}, therefore, ensure that the OOB
channel has sufficiently strong security in both directions. While this
is a theoretical vulnerability, it could arise in practice if EAP-NOOB
is deployed in new applications. Currently, we expect most peer devices
to support only one OOB direction; in which case, interfering with the
direction negotiation can only prevent the completion of the
protocol.[¶](#section-6.5-3){.pilcrow}

The long-term shared key material Kz in the persistent EAP-NOOB
association is established with an ECDHE key exchange when the peer and
server are first associated. It is a weaker secret than a manually
configured random shared key because advances in cryptanalysis against
the used ECDHE curve could eventually enable the attacker to recover Kz.
EAP-NOOB protects against such attacks by allowing cryptosuite upgrades
in the Reconnect Exchange and by updating the shared key material Kz
whenever the cryptosuite is upgraded. We do not expect the cryptosuite
upgrades to be frequent, but, if an upgrade becomes necessary, it can be
done without manual reset and reassociation of the peer
devices.[¶](#section-6.5-4){.pilcrow}
:::
:::

::: {#indicators}
::: {#section-6.6 .section}
### [6.6.](#section-6.6){.section-number .selfRef} [Protected Success and Failure Indications](#name-protected-success-and-failu){.section-name .selfRef} {#name-protected-success-and-failu}

[Section
7.16](https://www.rfc-editor.org/rfc/rfc3748#section-7.16){.relref} of
\[[RFC3748](#RFC3748){.xref}\] allows EAP methods to specify protected
result indications because EAP-Success and EAP-Failure packets are
neither acknowledged nor integrity protected.
\[[RFC3748](#RFC3748){.xref}\] notes that these indications may be
explicit or implicit.[¶](#section-6.6-1){.pilcrow}

EAP-NOOB relies on implicit, protected success indicators in the
Completion Exchange and Reconnect Exchange. Successful verification of
MACs and MACs2 in the EAP-Request message from the server (message type
6 and message type 9, respectively) acts as an implicit, protected
success indication to the peer. Similarly, successful verification of
MACp and MACp2 in the EAP-Response message from the peer (message type 6
and message type 9, respectively) act as an implicit, protected success
indication to the server.[¶](#section-6.6-2){.pilcrow}

EAP-NOOB failure messages are not protected. Protected failure result
indications would not significantly improve availability since EAP-NOOB
reacts to most malformed data by ending the current EAP conversation in
EAP-Failure. However, since EAP-NOOB spans multiple conversations,
failure in one conversation usually means no state change on the level
of the EAP-NOOB state machine.[¶](#section-6.6-3){.pilcrow}
:::
:::

::: {#channel-binding}
::: {#section-6.7 .section}
### [6.7.](#section-6.7){.section-number .selfRef} [Channel Binding](#name-channel-binding){.section-name .selfRef} {#name-channel-binding}

EAP channel binding, defined in \[[RFC6677](#RFC6677){.xref}\], means
that the endpoints compare their perceptions of network properties, such
as lower-layer identifiers, over the secure channel established by EAP
authentication. [Section
4.1](https://www.rfc-editor.org/rfc/rfc6677#section-4.1){.relref} of
\[[RFC6677](#RFC6677){.xref}\] defines two approaches to channel
binding. EAP-NOOB follows the first approach, in which the peer and
server exchange plaintext information about the network over a channel
that is integrity protected with keys derived during the EAP execution.
More specifically, channel information is exchanged in the plaintext
PeerInfo and ServerInfo objects and is later verified with message
authentication codes (MACp, MACs, MACp2, and MACs2). This allows
policy-based comparison with locally perceived network properties on
either side, as well as logging for debugging purposes. The peer
[MAY]{.bcp14} include in PeerInfo any data items that it wants to bind
to the EAP-NOOB association and to the exported keys. These can be
properties of the authenticator or the access link, such as the SSID and
BSSID of the wireless network (see [Table
6](#tab-serverinfo-meaning){.xref}). As noted in [Section
4.3](https://www.rfc-editor.org/rfc/rfc6677#section-4.3){.relref} of
\[[RFC6677](#RFC6677){.xref}\], the scope of the channel binding varies
between deployments. For example, the server may have less link-layer
information available from roaming networks than from a local enterprise
network, and it may be unable to verify all the network properties
received in PeerInfo. There are also privacy considerations related to
exchanging the ServerInfo and PeerInfo while roaming (see [Section
6.10](#privacyconsiderations){.xref}).[¶](#section-6.7-1){.pilcrow}

Channel binding to secure channels, defined in
\[[RFC5056](#RFC5056){.xref}\], binds authentication at a higher
protocol layer to a secure channel at a lower layer. Like most EAP
methods, EAP-NOOB exports the session keys MSK and EMSK, and an outer
tunnel or a higher-layer protocol can bind its authentication to these
keys. Additionally, EAP-NOOB exports the key AMSK, which may be used to
bind application-layer authentication to the secure channel created by
EAP-NOOB and to the session keys MSK and
EMSK.[¶](#section-6.7-2){.pilcrow}
:::
:::

::: {#dos}
::: {#section-6.8 .section}
### [6.8.](#section-6.8){.section-number .selfRef} [Denial of Service](#name-denial-of-service){.section-name .selfRef} {#name-denial-of-service}

While denial-of-service (DoS) attacks by on-link attackers cannot be
fully prevented, the design goal in EAP-NOOB is to void long-lasting
failure caused by an attacker who is present only temporarily or
intermittently. The main defense mechanism is the persistent EAP-NOOB
association, which is never deleted automatically due to in-band
messages or error indications. Thus, the endpoints can always use the
persistent association for reconnecting after the DoS attacker leaves
the network. In this sense, the persistent association serves the same
function in EAP-NOOB as a permanent primary key or certificate in other
authentication protocols. We discuss logical attacks against the updates
of the persistent association in [Section
6.9](#completion-loss){.xref}.[¶](#section-6.8-1){.pilcrow}

In addition to logical DoS attacks, it is necessary to consider resource
exhaustion attacks against the EAP server. The number of persistent
EAP-NOOB associations created in the server is limited by the need for a
user to assist in delivering the OOB message. The users can be
authenticated for the input or output of the OOB message at the EAP
server, and any users who create excessive numbers of persistent
associations can be held accountable and their associations can be
deleted by the server administrator. What the attacker can do without
user authentication is to perform the Initial Exchange repeatedly and
create a large number of ephemeral associations (server in Waiting for
OOB (1) state) without ever delivering the OOB message. In [Section
6.4](#peeridentifiers){.xref}, it was suggested that the server should
store the ephemeral states for at least a day. This may require
off-loading the state storage from memory to disk during a DoS attack.
However, if the server implementation is unable to keep up with a rate
of Initial Exchanges performed by a DoS attacker and needs to drop some
ephemeral states, no damage is caused to already-created persistent
associations, and the honest users can resume registering new peers when
the DoS attacker leaves the network.[¶](#section-6.8-2){.pilcrow}

There are some trade-offs in the protocol design between politely
backing off and giving way to DoS attackers. An on-link DoS attacker
could spoof the SleepTime value in the Initial Exchange or Waiting
Exchange to cause denial of service against a specific peer device.
There is an upper limit on the SleepTime (3600 seconds) to mitigate the
spoofing threat. This means that, in the presence of an on-link DoS
attacker who spoofs the SleepTime, it could take up to one hour after
the delivery of the OOB message before the device performs the
Completion Exchange and becomes functional. Similarly, the Unwanted peer
error (error code 2001) could cause the peer to stop connecting to the
network. If the peer device is able to alert the user about the error
condition, it can safely stop connecting to the server and wait for the
user to trigger a reconnection attempt, e.g., by resetting the device.
As mentioned in [Section 3.6.2](#unwantedpeer){.xref}, peer devices that
are unable to alert the user should continue to retry the Initial
Exchange infrequently to avoid a permanent DoS condition. We believe a
maximum backoff time of 3600 seconds is reasonable for a new protocol
because malfunctioning or misconfigured peer implementations are at
least as great a concern as DoS attacks, and politely backing off within
some reasonable limits will increase the acceptance of the protocol. The
maximum backoff times could be updated to be shorter as the protocol
implementations mature.[¶](#section-6.8-3){.pilcrow}
:::
:::

::: {#completion-loss}
::: {#section-6.9 .section}
### [6.9.](#section-6.9){.section-number .selfRef} [Recovery from Loss of Last Message](#name-recovery-from-loss-of-last-){.section-name .selfRef} {#name-recovery-from-loss-of-last-}

The EAP-NOOB Completion Exchange, as well as the Reconnect Exchange with
cryptosuite update, results in a persistent state change that should
take place either on both endpoints or on neither; otherwise, the result
is a state mismatch that requires user action to resolve. The state
mismatch can occur if the final EAP response of the exchanges is lost.
In the Completion Exchange, the loss of the final response (Type=6)
results in the peer moving to the Registered (4) state and creating a
persistent EAP-NOOB association while the server stays in an ephemeral
state (1 or 2). In the Reconnect Exchange, the loss of the final
response (Type=9) results in the peer moving to the Registered (4) state
and updating its persistent key material Kz while the server stays in
the Reconnecting (3) state and keeps the old key
material.[¶](#section-6.9-1){.pilcrow}

The state mismatch is an example of an unavoidable problem in
distributed systems: it is theoretically impossible to guarantee
synchronous state changes in endpoints that communicate asynchronously.
The protocol will always have one critical message that may get lost, so
that one side commits to the state change and the other side does not.
In EAP, the critical message is the final response from the peer to the
server. While the final response is normally followed by EAP-Success,
\[[RFC3748](#RFC3748){.xref}\], [Section
4.2](https://www.rfc-editor.org/rfc/rfc3748#section-4.2){.relref} states
that the peer [MAY]{.bcp14} assume that the EAP-Success was lost and the
authentication was successful. Furthermore, EAP method implementations
in the peer do not receive notification of the EAP-Success message from
the parent EAP state machine \[[RFC4137](#RFC4137){.xref}\]. For these
reasons, EAP-NOOB on the peer side commits to a state change already
when it sends the final response.[¶](#section-6.9-2){.pilcrow}

The best available solution to the loss of the critical message is to
keep trying. EAP retransmission behavior defined in [Section
4.3](https://www.rfc-editor.org/rfc/rfc3748#section-4.3){.relref} of
\[[RFC3748](#RFC3748){.xref}\] suggests 3-5 retransmissions. In the
absence of an attacker, this would be sufficient to reduce the
probability of failure to an acceptable level. However, a determined
attacker on the in-band channel can drop the final EAP-Response message
and all subsequent retransmissions. In the Completion Exchange
(KeyingMode=0) and Reconnect Exchange with cryptosuite upgrade
(KeyingMode=3), this could result in a state mismatch and persistent
denial of service until the user resets the peer
state.[¶](#section-6.9-3){.pilcrow}

EAP-NOOB implements its own recovery mechanism that allows unlimited
retries of the Reconnect Exchange. When the DoS attacker eventually
stops dropping packets on the in-band channel, the protocol will
recover. The logic for this recovery mechanism is specified in [Section
3.4.2](#reconnectexchange){.xref}.[¶](#section-6.9-4){.pilcrow}

EAP-NOOB does not implement the same kind of retry mechanism in the
Completion Exchange. The reason is that there is always a user involved
in the initial association process, and the user can repeat the OOB Step
to complete the association after the DoS attacker has left. On the
other hand, Reconnect Exchange needs to work without user
involvement.[¶](#section-6.9-5){.pilcrow}
:::
:::

::: {#privacyconsiderations}
::: {#section-6.10 .section}
### [6.10.](#section-6.10){.section-number .selfRef} [Privacy Considerations](#name-privacy-considerations){.section-name .selfRef} {#name-privacy-considerations}

There are privacy considerations related to performing the Reconnect
Exchange while roaming. The peer and server may send updated PeerInfo
and ServerInfo fields in the Reconnect Exchange. This data is sent
unencrypted between the peer and the EAP authenticator, such as a
wireless access point. Thus, it can be observed by both outsiders and
the access network. The PeerInfo field contains identifiers and other
information about the peer device (see [Table
6](#tab-serverinfo-meaning){.xref}). While the information refers to the
peer device and not directly to the user, it can leak information about
the user to the access network and to outside observers. The ServerInfo,
on the other hand, can leak information about the peer\'s affiliation
with the home network. For this reason, the optional PeerInfo and
ServerInfo in the Reconnect Exchange [SHOULD]{.bcp14} be omitted unless
some critical data has changed and it cannot be updated on the
application layer.[¶](#section-6.10-1){.pilcrow}

Peer devices that randomize their Layer 2 address to prevent tracking
can do this whenever the user resets the EAP-NOOB association. During
the lifetime of the association, the PeerId is a unique identifier that
can be used to track the peer in the access network. Later versions of
this specification may consider updating the PeerId at each Reconnect
Exchange. In that case, it is necessary to consider how the
authenticator and access-network administrators can recognize and add
misbehaving peer devices to a deny list, as well as how to avoid loss of
synchronization between the server and the peer if messages are lost
during the identifier update.[¶](#section-6.10-2){.pilcrow}

To enable stronger identity protection in later versions of EAP-NOOB,
the optional server-assigned NAI (NewNAI) [SHOULD]{.bcp14} have a
constant username part. The [RECOMMENDED]{.bcp14} username is \"noob\".
The server [MAY]{.bcp14}, however, send a different username in NewNAI
to avoid username collisions within its realm or to conform to a local
policy on usernames.[¶](#section-6.10-3){.pilcrow}
:::
:::

::: {#securityclaims}
::: {#section-6.11 .section}
### [6.11.](#section-6.11){.section-number .selfRef} [EAP Security Claims](#name-eap-security-claims){.section-name .selfRef} {#name-eap-security-claims}

EAP security claims are defined in [Section
7.2.1](https://www.rfc-editor.org/rfc/rfc3748#section-7.2.1){.relref} of
\[[RFC3748](#RFC3748){.xref}\]. The security claims for EAP-NOOB are
listed in [Table
13](#tab-securityclaims){.xref}.[¶](#section-6.11-1){.pilcrow}

[]{#name-eap-security-claims-2}

::: {#tab-securityclaims}
  Security Property                   EAP-NOOB Claim
  ----------------------------------- -------------------------------------------------------------------------------------------------------------------------------------------
  Authentication mechanism            ECDHE key exchange with out-of-band authentication
  Protected cryptosuite negotiation   yes
  Mutual authentication               yes
  Integrity protection                yes
  Replay protection                   yes
  Confidentiality                     no
  Key derivation                      yes
  Key strength                        The specified cryptosuites provide key strength of at least 128 bits.
  Dictionary attack protection        yes
  Fast reconnect                      yes
  Cryptographic binding               not applicable
  Session independence                yes
  Fragmentation                       no
  Channel binding                     yes (The ServerInfo and PeerInfo can be used to convey integrity-protected channel properties, such as network SSID or peer MAC address.)

  : [Table 13](#table-13){.selfRef}: [EAP Security
  Claims](#name-eap-security-claims-2){.selfRef}
:::
:::
:::
:::
:::

::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[EUI-48\]
:   [IEEE]{.refAuthor}, [\"IEEE Standard for Local and Metropolitan Area
    Networks: Overview and Architecture\"]{.refTitle}, [DOI
    10.1109/IEEESTD.2014.6847097]{.seriesInfo}, [IEEE Standard
    802-2014]{.seriesInfo}, June 2014,
    \<<https://doi.org/10.1109/IEEESTD.2014.6847097>\>.
:   

\[FIPS186-4\]
:   [National Institute of Standards and Technology (NIST)]{.refAuthor},
    [\"Digital Signature Standard (DSS)\"]{.refTitle}, [DOI
    10.6028/NIST.FIPS.186-4]{.seriesInfo}, [FIPS 186-4]{.seriesInfo},
    July 2013, \<<https://doi.org/10.6028/NIST.FIPS.186-4>\>.
:   

\[NIST-DH\]
:   [Barker, E.]{.refAuthor}, [Chen, L.]{.refAuthor},
    [Roginsky, A.]{.refAuthor}, [Vassilev, A.]{.refAuthor}, and [R.
    Davis]{.refAuthor}, [\"Recommendation for Pair-Wise
    Key-Establishment Schemes Using Discrete Logarithm
    Cryptography\"]{.refTitle}, [DOI
    10.6028/NIST.SP.800-56Ar3]{.seriesInfo}, [NIST Special Publication
    800-56A Revision 3]{.seriesInfo}, April 2018,
    \<<https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf>\>.
:   

\[RFC2104\]
:   [Krawczyk, H.]{.refAuthor}, [Bellare, M.]{.refAuthor}, and [R.
    Canetti]{.refAuthor}, [\"HMAC: Keyed-Hashing for Message
    Authentication\"]{.refTitle}, [RFC 2104]{.seriesInfo}, [DOI
    10.17487/RFC2104]{.seriesInfo}, February 1997,
    \<<https://www.rfc-editor.org/info/rfc2104>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC3748\]
:   [Aboba, B.]{.refAuthor}, [Blunk, L.]{.refAuthor},
    [Vollbrecht, J.]{.refAuthor}, [Carlson, J.]{.refAuthor}, and [H.
    Levkowetz, Ed.]{.refAuthor}, [\"Extensible Authentication Protocol
    (EAP)\"]{.refTitle}, [RFC 3748]{.seriesInfo}, [DOI
    10.17487/RFC3748]{.seriesInfo}, June 2004,
    \<<https://www.rfc-editor.org/info/rfc3748>\>.
:   

\[RFC4648\]
:   [Josefsson, S.]{.refAuthor}, [\"The Base16, Base32, and Base64 Data
    Encodings\"]{.refTitle}, [RFC 4648]{.seriesInfo}, [DOI
    10.17487/RFC4648]{.seriesInfo}, October 2006,
    \<<https://www.rfc-editor.org/info/rfc4648>\>.
:   

\[RFC5247\]
:   [Aboba, B.]{.refAuthor}, [Simon, D.]{.refAuthor}, and [P.
    Eronen]{.refAuthor}, [\"Extensible Authentication Protocol (EAP) Key
    Management Framework\"]{.refTitle}, [RFC 5247]{.seriesInfo}, [DOI
    10.17487/RFC5247]{.seriesInfo}, August 2008,
    \<<https://www.rfc-editor.org/info/rfc5247>\>.
:   

\[RFC6234\]
:   [Eastlake 3rd, D.]{.refAuthor} and [T. Hansen]{.refAuthor}, [\"US
    Secure Hash Algorithms (SHA and SHA-based HMAC and
    HKDF)\"]{.refTitle}, [RFC 6234]{.seriesInfo}, [DOI
    10.17487/RFC6234]{.seriesInfo}, May 2011,
    \<<https://www.rfc-editor.org/info/rfc6234>\>.
:   

\[RFC7517\]
:   [Jones, M.]{.refAuthor}, [\"JSON Web Key (JWK)\"]{.refTitle}, [RFC
    7517]{.seriesInfo}, [DOI 10.17487/RFC7517]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7517>\>.
:   

\[RFC7518\]
:   [Jones, M.]{.refAuthor}, [\"JSON Web Algorithms (JWA)\"]{.refTitle},
    [RFC 7518]{.seriesInfo}, [DOI 10.17487/RFC7518]{.seriesInfo}, May
    2015, \<<https://www.rfc-editor.org/info/rfc7518>\>.
:   

\[RFC7542\]
:   [DeKok, A.]{.refAuthor}, [\"The Network Access
    Identifier\"]{.refTitle}, [RFC 7542]{.seriesInfo}, [DOI
    10.17487/RFC7542]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7542>\>.
:   

\[RFC7748\]
:   [Langley, A.]{.refAuthor}, [Hamburg, M.]{.refAuthor}, and [S.
    Turner]{.refAuthor}, [\"Elliptic Curves for Security\"]{.refTitle},
    [RFC 7748]{.seriesInfo}, [DOI 10.17487/RFC7748]{.seriesInfo},
    January 2016, \<<https://www.rfc-editor.org/info/rfc7748>\>.
:   

\[RFC8037\]
:   [Liusvaara, I.]{.refAuthor}, [\"CFRG Elliptic Curve Diffie-Hellman
    (ECDH) and Signatures in JSON Object Signing and Encryption
    (JOSE)\"]{.refTitle}, [RFC 8037]{.seriesInfo}, [DOI
    10.17487/RFC8037]{.seriesInfo}, January 2017,
    \<<https://www.rfc-editor.org/info/rfc8037>\>.
:   

\[RFC8126\]
:   [Cotton, M.]{.refAuthor}, [Leiba, B.]{.refAuthor}, and [T.
    Narten]{.refAuthor}, [\"Guidelines for Writing an IANA
    Considerations Section in RFCs\"]{.refTitle}, [BCP 26]{.seriesInfo},
    [RFC 8126]{.seriesInfo}, [DOI 10.17487/RFC8126]{.seriesInfo}, June
    2017, \<<https://www.rfc-editor.org/info/rfc8126>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8259\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The JavaScript Object Notation
    (JSON) Data Interchange Format\"]{.refTitle}, [STD 90]{.seriesInfo},
    [RFC 8259]{.seriesInfo}, [DOI 10.17487/RFC8259]{.seriesInfo},
    December 2017, \<<https://www.rfc-editor.org/info/rfc8259>\>.
:   
:::

::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[Bluetooth\]
:   [Bluetooth Special Interest Group]{.refAuthor}, [\"Bluetooth Core
    Specification Version 5.3\"]{.refTitle}, July 2021,
    \<<https://www.bluetooth.com/specifications/bluetooth-core-specification>\>.
:   

\[IEEE-802.1X\]
:   [IEEE]{.refAuthor}, [\"IEEE Standard for Local and Metropolitan Area
    Networks\--Port-Based Network Access Control\"]{.refTitle}, [IEEE
    Standard 802.1X-2020]{.seriesInfo}, February 2020.
:   

\[RATS-EAT\]
:   [Lundblade, L.]{.refAuthor}, [Mandyam, G.]{.refAuthor}, and [J.
    O\'Donoghue]{.refAuthor}, [\"The Entity Attestation Token
    (EAT)\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-rats-eat-11]{.seriesInfo}, 24 October
    2021,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-rats-eat-11>\>.
:   

\[RFC2904\]
:   [Vollbrecht, J.]{.refAuthor}, [Calhoun, P.]{.refAuthor},
    [Farrell, S.]{.refAuthor}, [Gommans, L.]{.refAuthor},
    [Gross, G.]{.refAuthor}, [de Bruijn, B.]{.refAuthor}, [de
    Laat, C.]{.refAuthor}, [Holdrege, M.]{.refAuthor}, and [D.
    Spence]{.refAuthor}, [\"AAA Authorization Framework\"]{.refTitle},
    [RFC 2904]{.seriesInfo}, [DOI 10.17487/RFC2904]{.seriesInfo}, August
    2000, \<<https://www.rfc-editor.org/info/rfc2904>\>.
:   

\[RFC3986\]
:   [Berners-Lee, T.]{.refAuthor}, [Fielding, R.]{.refAuthor}, and [L.
    Masinter]{.refAuthor}, [\"Uniform Resource Identifier (URI): Generic
    Syntax\"]{.refTitle}, [STD 66]{.seriesInfo}, [RFC
    3986]{.seriesInfo}, [DOI 10.17487/RFC3986]{.seriesInfo}, January
    2005, \<<https://www.rfc-editor.org/info/rfc3986>\>.
:   

\[RFC4137\]
:   [Vollbrecht, J.]{.refAuthor}, [Eronen, P.]{.refAuthor},
    [Petroni, N.]{.refAuthor}, and [Y. Ohba]{.refAuthor}, [\"State
    Machines for Extensible Authentication Protocol (EAP) Peer and
    Authenticator\"]{.refTitle}, [RFC 4137]{.seriesInfo}, [DOI
    10.17487/RFC4137]{.seriesInfo}, August 2005,
    \<<https://www.rfc-editor.org/info/rfc4137>\>.
:   

\[RFC5056\]
:   [Williams, N.]{.refAuthor}, [\"On the Use of Channel Bindings to
    Secure Channels\"]{.refTitle}, [RFC 5056]{.seriesInfo}, [DOI
    10.17487/RFC5056]{.seriesInfo}, November 2007,
    \<<https://www.rfc-editor.org/info/rfc5056>\>.
:   

\[RFC5216\]
:   [Simon, D.]{.refAuthor}, [Aboba, B.]{.refAuthor}, and [R.
    Hurst]{.refAuthor}, [\"The EAP-TLS Authentication
    Protocol\"]{.refTitle}, [RFC 5216]{.seriesInfo}, [DOI
    10.17487/RFC5216]{.seriesInfo}, March 2008,
    \<<https://www.rfc-editor.org/info/rfc5216>\>.
:   

\[RFC6677\]
:   [Hartman, S., Ed.]{.refAuthor}, [Clancy, T.]{.refAuthor}, and [K.
    Hoeper]{.refAuthor}, [\"Channel-Binding Support for Extensible
    Authentication Protocol (EAP) Methods\"]{.refTitle}, [RFC
    6677]{.seriesInfo}, [DOI 10.17487/RFC6677]{.seriesInfo}, July 2012,
    \<<https://www.rfc-editor.org/info/rfc6677>\>.
:   

\[Sethi14\]
:   [Sethi, M.]{.refAuthor}, [Oat, E.]{.refAuthor}, [Di
    Francesco, M.]{.refAuthor}, and [T. Aura]{.refAuthor}, [\"Secure
    bootstrapping of cloud-managed ubiquitous displays\"]{.refTitle},
    [Proceedings of ACM International Joint Conference on Pervasive and
    Ubiquitous Computing (UbiComp 2014), pp. 739-750, Seattle,
    USA]{.refContent}, [DOI 10.1145/2632048.2632049]{.seriesInfo},
    September 2014,
    \<[http://dx.doi.org/10.1145/2632048.2632049](https://dx.doi.org/10.1145/2632048.2632049)\>.
:   

\[Sethi19\]
:   [Sethi, M.]{.refAuthor}, [Peltonen, A.]{.refAuthor}, and [T.
    Aura]{.refAuthor}, [\"Misbinding Attacks on Secure Device Pairing
    and Bootstrapping\"]{.refTitle}, [DOI
    10.1145/3321705.3329813]{.seriesInfo}, February 2019,
    \<<https://arxiv.org/abs/1902.07550>\>.
:   

\[TLS-CWT\]
:   [Tschofenig, H.]{.refAuthor} and [M. Brossard]{.refAuthor}, [\"Using
    CBOR Web Tokens (CWTs) in Transport Layer Security (TLS) and
    Datagram Transport Layer Security (DTLS)\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-tschofenig-tls-cwt-02]{.seriesInfo}, 13 July 2020,
    \<<https://datatracker.ietf.org/doc/html/draft-tschofenig-tls-cwt-02>\>.
:   
:::
:::

::: {#exchangeappendix}
::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [Exchanges and Events per State](#name-exchanges-and-events-per-st){.section-name .selfRef} {#name-exchanges-and-events-per-st}

[Table 14](#tab-exchanges){.xref} shows how the EAP server chooses the
exchange type depending on the server and peer states. In the state
combinations marked with hyphen \"-\", there is no possible exchange and
user action is required to make progress. Note that peer state 4 is
omitted from the table because the peer never connects to the server
when the peer is in that state. The table also shows the handling of
errors in each exchange. A notable detail is that the recipient of error
code 2003 moves to state 1.[¶](#appendix-A-1){.pilcrow}

[]{#name-how-the-server-chooses-the-}

::: {#tab-exchanges}
  Peer States                                        Exchange Chosen by the Server   Next Peer and Server States
  -------------------------------------------------- ------------------------------- -----------------------------
  Server State: Unregistered (0)                                                     
  0..2                                               Initial Exchange                both 1 (0 on error)
  3                                                  \-                              no change, notify user
  Server State: Waiting for OOB (1)                                                  
  0                                                  Initial Exchange                both 1 (0 on error)
  1                                                  Waiting Exchange                both 1 (no change on error)
  2                                                  Completion Exchange             both 4 (A)
  3                                                  \-                              no change, notify user
  Server State: OOB Received (2)                                                     
  0                                                  Initial Exchange                both 1 (0 on error)
  1                                                  Completion Exchange             both 4 (B)
  2                                                  Completion Exchange             both 4 (A)
  3                                                  \-                              no change, notify user
  Server State: Reconnecting (3) or Registered (4)                                   
  0..2                                               \-                              no change, notify user
  3                                                  Reconnect Exchange              both 4 (3 on error)

  : [Table 14](#table-14){.selfRef}: [How the Server Chooses the
  Exchange Type](#name-how-the-server-chooses-the-){.selfRef}
:::

[]{.break}

\(A\)
:   peer to 1 on error 2003; no other changes on
    error[¶](#appendix-A-3.2){.pilcrow}
:   

\(B\)
:   server to 1 on error 2003; no other changes on
    error[¶](#appendix-A-3.4){.pilcrow}
:   

[Table 15](#tab-localevents){.xref} lists the local events that can take
place in the server or peer. Both the server and peer output and accept
OOB messages in association state 1, leading the receiver to state 2.
Communication errors and timeouts in states 0..2 lead back to state 0,
while similar errors in states 3..4 lead to state 3. An application
request for rekeying (e.g., to refresh session keys or to upgrade
cryptosuite) also takes the association from state 3..4 to state 3. The
user can always reset the association state to 0. Recovering association
data, e.g., from a backup, leads to state 3.[¶](#appendix-A-4){.pilcrow}

[]{#name-local-events-in-the-server-}

::: {#tab-localevents}
  Server/Peer State   Possible Local Events in the Server and Peer   Next State
  ------------------- ---------------------------------------------- ----------------
  1                   OOB Output                                     1
  1                   OOB Input                                      2 (1 on error)
  0..2                Mobility/timeout/network failure               0
  3..4                Mobility/timeout/network failure               3
  3..4                Rekeying request                               3
  0..4                User resets association                        0
  0..4                Association state recovery                     3

  : [Table 15](#table-15){.selfRef}: [Local Events in the Server and
  Peer](#name-local-events-in-the-server-){.selfRef}
:::
:::
:::

::: {#oobchannelappendix}
::: {#appendix-B .section}
## [Appendix B.](#appendix-B){.section-number .selfRef} [Application-Specific Parameters](#name-application-specific-parame){.section-name .selfRef} {#name-application-specific-parame}

[Table 16](#tab-oobchannel){.xref} lists OOB channel parameters that
need to be specified in each application that makes use of EAP-NOOB. The
list is not exhaustive and is included for the convenience of
implementers only.[¶](#appendix-B-1){.pilcrow}

[]{#name-oob-channel-characteristics}

::: {#tab-oobchannel}
  Parameter            Description
  -------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  OobDirs              Allowed directions of the OOB channel.
  OobMessageEncoding   How the OOB message data fields are encoded for the OOB channel.
  SleepTimeDefault     Default minimum time in seconds that the peer should sleep before the next Waiting Exchange.
  OobRetries           Number of received OOB messages with invalid Hoob, after which the receiver moves to Unregistered (0) state. When the OOB channel has error detection or correction, the [RECOMMENDED]{.bcp14} value is 5.
  NoobTimeout          How many seconds the sender of the OOB message remembers the sent Noob value. The [RECOMMENDED]{.bcp14} value is 3600 seconds.
  ServerInfoType       The value of the Type field and the other required fields in ServerInfo.
  PeerInfoType         The value of the Type field and the other required fields in PeerInfo.

  : [Table 16](#table-16){.selfRef}: [OOB Channel
  Characteristics](#name-oob-channel-characteristics){.selfRef}
:::
:::
:::

::: {#roaming}
::: {#appendix-C .section}
## [Appendix C.](#appendix-C){.section-number .selfRef} [EAP-NOOB Roaming](#name-eap-noob-roaming){.section-name .selfRef} {#name-eap-noob-roaming}

AAA architectures \[[RFC2904](#RFC2904){.xref}\] allow for roaming of
network-connected appliances that are authenticated over EAP. While the
peer is roaming in a visited network, authentication still takes place
between the peer and an authentication server at its home network.
EAP-NOOB supports such roaming by allowing the server to assign a NAI to
the peer. After the NAI has been assigned, it enables the visited
network to route the EAP session to the peer\'s home AAA
server.[¶](#appendix-C-1){.pilcrow}

A peer device that is new or has gone through a hard reset should be
connected first to the home network and establish an EAP-NOOB
association with its home AAA server before it is able to roam. After
that, it can perform the Reconnect Exchange from the visited
network.[¶](#appendix-C-2){.pilcrow}

Alternatively, the device may provide some method for the user to
configure the NAI of the home network. This is the user or
application-configured NAI mentioned in [Section 3.3.1](#nai){.xref}. In
that case, the EAP-NOOB association can be created while roaming. The
configured NAI enables the EAP messages to be routed correctly to the
home AAA server.[¶](#appendix-C-3){.pilcrow}

While roaming, the device needs to identify the networks where the
EAP-NOOB association can be used to gain network access. For 802.11
access networks, the server [MAY]{.bcp14} send a list of SSID strings in
the ServerInfo field, called either SSIDList or Base64SSIDList. The list
is formatted as explained in [Table 6](#tab-serverinfo-meaning){.xref}.
If present, the peer [MAY]{.bcp14} use this list as a hint to determine
the networks where the EAP-NOOB association can be used for access
authorization, in addition to the access network where the Initial
Exchange took place.[¶](#appendix-C-4){.pilcrow}
:::
:::

::: {#urloob}
::: {#appendix-D .section}
## [Appendix D.](#appendix-D){.section-number .selfRef} [OOB Message as a URL](#name-oob-message-as-a-url){.section-name .selfRef} {#name-oob-message-as-a-url}

While EAP-NOOB does not mandate any particular OOB communication
channel, typical OOB channels include graphical displays and emulated
NFC tags. In the peer-to-server direction, it may be convenient to
encode the OOB message as a URL, which is then encoded as a QR code for
displays and printers or as an NFC Data Exchange Format (NDEF) record
for dynamic NFC tags. A user can then simply scan the QR code or NFC tag
and open the URL, which causes the OOB message to be delivered to the
authentication server. The URL [MUST]{.bcp14} specify https or another
server-authenticated scheme so that there is a secure connection to the
server and the on-path attacker cannot read or modify the OOB
message.[¶](#appendix-D-1){.pilcrow}

The ServerInfo in this case includes a field called ServerURL of the
following format with a [RECOMMENDED]{.bcp14} length of at most 60
characters:[¶](#appendix-D-2){.pilcrow}

`https://<host>[:<port>]/[<path>]`[¶](#appendix-D-3){.pilcrow}

To this, the peer appends the OOB message fields (PeerId, Noob, and
Hoob) as a query string. PeerId is provided to the peer by the server
and might be a 22-character ASCII string. The peer base64url encodes,
without padding, the 16-byte values Noob and Hoob into 22-character
ASCII strings. The query parameters [MAY]{.bcp14} be in any order. The
resulting URL is of the following format:[¶](#appendix-D-4){.pilcrow}

`https://<host>[:<port>]/[<path>]?P=<PeerId>&N=<Noob>&H=<Hoob>`[¶](#appendix-D-5){.pilcrow}

The following is an example of a well-formed URL encoding the OOB
message (without line breaks):[¶](#appendix-D-6){.pilcrow}

`https://aaa.example.com/eapnoob?P=mcm5BSCDZ45cYPlAr1ghNw&N=rMinS0-F4EfCU8D9ljxX_A&H=QvnMp4UGxuQVFaXPW_14UW`[¶](#appendix-D-7){.pilcrow}
:::
:::

::: {#acks}
::: {#appendix-E .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

[Max Crone]{.contact-name}, [Shiva Prasad TP]{.contact-name}, and
[Raghavendra MS]{.contact-name} implemented parts of this protocol with
wpa_supplicant and hostapd. [Eduardo Inglés]{.contact-name} and [Dan
Garcia-Carrillo]{.contact-name} were involved in the implementation of
this protocol on Contiki. Their inputs helped us in improving the
specification.[¶](#appendix-E-1){.pilcrow}

The authors would like to thank [Rhys Smith]{.contact-name} and [Josh
Howlett]{.contact-name} for providing valuable feedback, as well as new
use cases and requirements for the protocol. Thanks to [Eric
Rescorla]{.contact-name}, [Alan Dekok]{.contact-name}, [Darshak
Thakore]{.contact-name}, [Stefan Winter]{.contact-name}, [Hannes
Tschofenig]{.contact-name}, [Daniel Migault]{.contact-name}, [Roman
Danyliw]{.contact-name}, [Benjamin Kaduk]{.contact-name}, [Francesca
Palombini]{.contact-name}, [Steve Hanna]{.contact-name}, [Lars
Eggert]{.contact-name}, and [Éric Vyncke]{.contact-name} for their
comments and reviews.[¶](#appendix-E-2){.pilcrow}

We would also like to express our sincere gratitude to [Dave
Thaler]{.contact-name} for his thorough review of the
document.[¶](#appendix-E-3){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-F .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Tuomas Aura]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Aalto University]{.org}
:::

::: {.left dir="auto"}
FI-[00076]{.postal-code} [Aalto]{.locality}
:::

::: {.left dir="auto"}
[Finland]{.country-name}
:::

::: email
Email: <tuomas.aura@aalto.fi>
:::

::: {.left dir="auto"}
[Mohit Sethi]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Ericsson]{.org}
:::

::: {.left dir="auto"}
FI-[02420]{.postal-code} [Jorvas]{.locality}
:::

::: {.left dir="auto"}
[Finland]{.country-name}
:::

::: email
Email: <mohit@iki.fi>
:::

::: {.left dir="auto"}
[Aleksi Peltonen]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Aalto University]{.org}
:::

::: {.left dir="auto"}
FI-[00076]{.postal-code} [Aalto]{.locality}
:::

::: {.left dir="auto"}
[Finland]{.country-name}
:::

::: email
Email: <aleksi.peltonen@aalto.fi>
:::
:::
:::
