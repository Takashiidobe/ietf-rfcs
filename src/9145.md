  RFC 9145            Integrity Protection for the NSH   December 2021
  ------------------- ---------------------------------- ---------------
  Boucadair, et al.   Standards Track                    \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9145](https://www.rfc-editor.org/rfc/rfc9145){.eref}

Category:
:   Standards Track

Published:
:   December 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    M. Boucadair
    :::

    ::: org
    Orange
    :::
    :::

    ::: author
    ::: author-name
    T. Reddy.K
    :::

    ::: org
    Akamai
    :::
    :::

    ::: author
    ::: author-name
    D. Wing
    :::

    ::: org
    Citrix
    :::
    :::
:::

# RFC 9145 {#rfcnum}

# Integrity Protection for the Network Service Header (NSH) and Encryption of Sensitive Context Headers {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This specification presents an optional method to add integrity
protection directly to the Network Service Header (NSH) used for Service
Function Chaining (SFC). Also, this specification allows for the
encryption of sensitive metadata (MD) that is carried in the
NSH.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9145>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Assumptions and Basic
    Requirements](#name-assumptions-and-basic-requi){.xref}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Design
    Overview](#name-design-overview){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Supported Security
        Services](#name-supported-security-services){.xref}

        -   ::: {#section-toc.1-1.4.2.1.2.1}
            [4.1.1](#section-4.1.1){.xref}.  [Encrypt All or a Subset of
            Context Headers](#name-encrypt-all-or-a-subset-of-){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.2}
            [4.1.2](#section-4.1.2){.xref}.  [Integrity
            Protection](#name-integrity-protection){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [One Secret Key, Two Security
        Services](#name-one-secret-key-two-security){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Mandatory-to-Implement
        Authenticated Encryption and HMAC
        Algorithms](#name-mandatory-to-implement-auth){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Key
        Management](#name-key-management){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [New NSH Variable-Length Context
        Headers](#name-new-nsh-variable-length-con){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.6}
        [4.6](#section-4.6){.xref}.  [Encapsulation of NSH within
        NSH](#name-encapsulation-of-nsh-within){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [New NSH Variable-Length Context
    Headers](#name-new-nsh-variable-length-cont){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [MAC#1 Context
        Header](#name-mac1-context-header){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [MAC#2 Context
        Header](#name-mac2-context-header){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Timestamp
    Format](#name-timestamp-format){.xref}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Processing
    Rules](#name-processing-rules){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Generic
        Behavior](#name-generic-behavior){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [MAC NSH Data
        Generation](#name-mac-nsh-data-generation){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Encrypted NSH Metadata
        Generation](#name-encrypted-nsh-metadata-gene){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [Timestamp for Replay Attack
        Prevention](#name-timestamp-for-replay-attack){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.5}
        [7.5](#section-7.5){.xref}.  [NSH Data
        Validation](#name-nsh-data-validation){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.6}
        [7.6](#section-7.6){.xref}.  [Decryption of NSH
        Metadata](#name-decryption-of-nsh-metadata){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [MTU
    Considerations](#name-mtu-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [MAC#1](#name-mac1){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [MAC#2](#name-mac2){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.3}
        [9.3](#section-9.3){.xref}.  [Time
        Synchronization](#name-time-synchronization){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.11.2.1}
        [11.1](#section-11.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [11.2](#section-11.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [](#appendix-A){.xref}[Acknowledgements](#name-acknowledgements){.xref}
    :::

-   ::: {#section-toc.1-1.13}
    [](#appendix-B){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Many advanced Service Functions (SFs) are enabled for the delivery of
value-added services. Typically, SFs are used to meet various service
objectives such as IP address sharing, avoiding covert channels,
detecting Denial-of-Service (DoS) attacks and protecting network
infrastructures against them, network slicing, etc. Because of the
proliferation of such advanced SFs together with complex service
deployment constraints that demand more agile service delivery
procedures, operators need to rationalize their service delivery logic
and control its complexity while optimizing service activation time
cycles. The overall problem space is described in
\[[RFC7498](#RFC7498){.xref}\].[¶](#section-1-1){.pilcrow}

\[[RFC7665](#RFC7665){.xref}\] presents a data plane architecture
addressing the problematic aspects of existing service deployments,
including topological dependence and configuration complexity. It also
describes an architecture for the specification, creation, and
maintenance of Service Function Chains (SFCs) within a network, that is,
how to define an ordered set of SFs and ordering constraints that must
be applied to packets/flows selected as a result of traffic
classification. \[[RFC8300](#RFC8300){.xref}\] specifies the SFC
encapsulation: Network Service Header (NSH).[¶](#section-1-2){.pilcrow}

The NSH data is unauthenticated and unencrypted, forcing a service
topology that requires security and privacy to use a transport
encapsulation that supports such features ([Section
8.2](https://www.rfc-editor.org/rfc/rfc8300#section-8.2){.relref} of
\[[RFC8300](#RFC8300){.xref}\]).[¶](#section-1-3){.pilcrow}

Note that some transport encapsulations (e.g., IPsec) only provide
hop-by-hop security between two SFC data plane elements (e.g., two
Service Function Forwarders (SFFs), SFF to SF) and do not provide
SF-to-SF security of NSH metadata. For example, if IPsec is used, SFFs
or SFs within a Service Function Path (SFP) that are not authorized to
access the sensitive metadata (e.g., privacy-sensitive information) will
have access to the metadata. As a reminder, the metadata referred to is
information that is inserted by Classifiers or intermediate SFs and
shared with downstream SFs; such information is not visible to the
communication endpoints ([Section
4.9](https://www.rfc-editor.org/rfc/rfc7665#section-4.9){.relref} of
\[[RFC7665](#RFC7665){.xref}\]).[¶](#section-1-4){.pilcrow}

The lack of such capability was reported during the development of
\[[RFC8300](#RFC8300){.xref}\] and \[[RFC8459](#RFC8459){.xref}\]. The
reader may refer to [Section
3.2.1](https://datatracker.ietf.org/doc/html/draft-arkko-farrell-arch-model-t-04#section-3.2.1){.relref}
of \[[INTERNET-THREAT-MODEL](#I-D.arkko-farrell-arch-model-t){.xref}\]
for a discussion on the need for more awareness about attacks from
within closed domains.[¶](#section-1-5){.pilcrow}

This specification fills that gap for SFC (that is, it defines the \"NSH
Variable Header-Based Integrity\" option mentioned in [Section
8.2.1](https://www.rfc-editor.org/rfc/rfc8300#section-8.2.1){.relref} of
\[[RFC8300](#RFC8300){.xref}\]). Concretely, this document adds
integrity protection and optional encryption of sensitive metadata
directly to the NSH ([Section 4](#overview){.xref}). The integrity
protection covers the packet payload and provides replay protection
([Section 7.4](#time){.xref}). Thus, the NSH does not have to rely upon
an underlying transport encapsulation for
security.[¶](#section-1-6){.pilcrow}

This specification introduces new Variable-Length Context Headers to
carry fields necessary for integrity-protected NSH headers and encrypted
Context Headers ([Section 5](#new){.xref}). This specification is only
applicable to NSH MD Type 0x02 ([Section
2.5](https://www.rfc-editor.org/rfc/rfc8300#section-2.5){.relref} of
\[[RFC8300](#RFC8300){.xref}\]). MTU considerations are discussed in
[Section 8](#MTU){.xref}. This specification is not applicable to NSH MD
Type 0x01 ([Section
2.4](https://www.rfc-editor.org/rfc/rfc8300#section-2.4){.relref} of
\[[RFC8300](#RFC8300){.xref}\]) because that MD Type only allows a
Fixed-Length Context Header whose size is 16 bytes; that is not
sufficient to accommodate both the metadata and message integrity of the
NSH data.[¶](#section-1-7){.pilcrow}

This specification limits access to NSH-supplied information along an
SFP to entities that have a need to interpret
it.[¶](#section-1-8){.pilcrow}

The mechanism specified in this document does not preclude the use of
transport security. Such considerations are deployment
specific.[¶](#section-1-9){.pilcrow}

It is out of the scope of this document to specify an NSH-aware control
plane solution.[¶](#section-1-10){.pilcrow}
:::

::: {#notation}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}

This document makes use of the terms defined in
\[[RFC7665](#RFC7665){.xref}\] and \[[RFC8300](#RFC8300){.xref}\]. The
term \"transport encapsulation\" used in this document refers to the
outer encapsulation (e.g., Generic Routing Encapsulation (GRE), IPsec,
and Generic Protocol Extension for Virtual eXtensible Local Area Network
(VXLAN-GPE)) that is used to carry NSH-encapsulated packets as per
[Section 4](https://www.rfc-editor.org/rfc/rfc8300#section-4){.relref}
of \[[RFC8300](#RFC8300){.xref}\].[¶](#section-2-2){.pilcrow}

The document defines the following terms:[¶](#section-2-3){.pilcrow}

[]{.break}

SFC data plane element:
:   Refers to NSH-aware SF, SFF, the SFC Proxy, or the Classifier as
    defined in the SFC data plane architecture
    \[[RFC7665](#RFC7665){.xref}\] and further refined in
    \[[RFC8300](#RFC8300){.xref}\].[¶](#section-2-4.2){.pilcrow}
:   

SFC control element:
:   Is a logical entity that instructs one or more SFC data plane
    elements on how to process NSH packets within an SFC-enabled
    domain.[¶](#section-2-4.4){.pilcrow}
:   

Key Identifier:
:   Is used to identify keys to authorized entities. See, for example,
    \"kid\" usage in
    \[[RFC7635](#RFC7635){.xref}\].[¶](#section-2-4.6){.pilcrow}
:   

NSH data:
:   The NSH is composed of a Base Header, a Service Path Header, and
    optional Context Headers. NSH data refers to all the above headers
    and the packet or frame on which the NSH is imposed to realize an
    SFP.[¶](#section-2-4.8){.pilcrow}
:   

NSH imposer:
:   Refers to an SFC data plane element that is entitled to impose the
    NSH with the Context Headers defined in this
    document.[¶](#section-2-4.10){.pilcrow}
:   
:::
:::

::: {#req}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Assumptions and Basic Requirements](#name-assumptions-and-basic-requi){.section-name .selfRef} {#name-assumptions-and-basic-requi}

[Section 2](https://www.rfc-editor.org/rfc/rfc8300#section-2){.relref}
of \[[RFC8300](#RFC8300){.xref}\] specifies that the NSH data can be
spread over three headers:[¶](#section-3-1){.pilcrow}

[]{.break}

Base Header:
:   Provides information about the service header and the payload
    protocol.[¶](#section-3-2.2){.pilcrow}
:   

Service Path Header:
:   Provides path identification and location within an
    SFP.[¶](#section-3-2.4){.pilcrow}
:   

Context Header(s):
:   Carries metadata (i.e., context data) along a service
    path.[¶](#section-3-2.6){.pilcrow}
:   

The NSH allows sharing context information (a.k.a. metadata) with
downstream NSH-aware data plane elements on a per-SFC/SFP basis. To that
aim:[¶](#section-3-3){.pilcrow}

-   [The Classifier is instructed by an SFC control element about the
    set of context information to be supplied for a given service
    function chain.[¶](#section-3-4.1){.pilcrow}]{#section-3-4.1}
-   [An NSH-aware SF is instructed by an SFC control element about any
    metadata it needs to attach to packets for a given service function
    chain. This instruction may occur any time during the validity
    lifetime of an SFC/SFP. For a given service function chain, the
    NSH-aware SF is also provided with an order for consuming a set of
    contexts supplied in a
    packet.[¶](#section-3-4.2){.pilcrow}]{#section-3-4.2}
-   [An NSH-aware SF can also be instructed by an SFC control element
    about the behavior it should adopt after consuming context
    information that was supplied in the NSH. For example, the context
    information can be maintained, updated, or
    stripped.[¶](#section-3-4.3){.pilcrow}]{#section-3-4.3}
-   [An SFC Proxy may be instructed by an SFC control element about the
    behavior it should adopt to process the context information that was
    supplied in the NSH on behalf of an NSH-unaware SF (e.g., the
    context information can be maintained or stripped). The SFC Proxy
    may also be instructed to add some new context information into the
    NSH on behalf of an NSH-unaware
    SF.[¶](#section-3-4.4){.pilcrow}]{#section-3-4.4}

In reference to [Table 1](#NSH){.xref}:[¶](#section-3-5){.pilcrow}

-   [Classifiers, NSH-aware SFs, and SFC proxies are entitled to update
    the Context Header(s).[¶](#section-3-6.1){.pilcrow}]{#section-3-6.1}
-   [Only NSH-aware SFs and SFC proxies are entitled to update the
    Service Path Header.[¶](#section-3-6.2){.pilcrow}]{#section-3-6.2}
-   [SFFs are entitled to modify the Base Header (TTL value, for
    example). Nevertheless, SFFs are not supposed to act on the Context
    Headers or look into the content of the Context Headers ([Section
    4.3](https://www.rfc-editor.org/rfc/rfc7665#section-4.3){.relref} of
    \[[RFC7665](#RFC7665){.xref}\]).[¶](#section-3-6.3){.pilcrow}]{#section-3-6.3}

Thus, the following requirements:[¶](#section-3-7){.pilcrow}

-   [Only Classifiers, NSH-aware SFs, and SFC proxies must be able to
    encrypt and decrypt a given Context
    Header.[¶](#section-3-8.1){.pilcrow}]{#section-3-8.1}
-   [Both encrypted and unencrypted Context Headers may be included in
    the same NSH.[¶](#section-3-8.2){.pilcrow}]{#section-3-8.2}
-   [The solution must provide integrity protection for the Service Path
    Header.[¶](#section-3-8.3){.pilcrow}]{#section-3-8.3}
-   [The solution must provide optional integrity protection for the
    Base Header. The implications of disabling such checks are discussed
    in [Section
    9.1](#mac1){.xref}.[¶](#section-3-8.4){.pilcrow}]{#section-3-8.4}

[]{#name-summary-of-nsh-actions}

::: {#NSH}
  SFC Data Plane Element                  Insert, remove, or replace the NSH                      Update the NSH            
  --------------------------------------- ------------------------------------ -------- --------- ------------------------- --------------------------
                                          Insert                               Remove   Replace   Decrement Service Index   Update Context Header(s)
  Classifier                              \+                                            \+                                  \+
  Service Function Forwarder (SFF)                                             \+                                           
  Service Function (SF)                                                                           \+                        \+
  Service Function Chaining (SFC) Proxy   \+                                   \+                 \+                        \+

  : [Table 1](#table-1){.selfRef}: [Summary of NSH
  Actions](#name-summary-of-nsh-actions){.selfRef}
:::
:::
:::

::: {#overview}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Design Overview](#name-design-overview){.section-name .selfRef} {#name-design-overview}

::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Supported Security Services](#name-supported-security-services){.section-name .selfRef} {#name-supported-security-services}

This specification provides the functions described in the following
subsections.[¶](#section-4.1-1){.pilcrow}

::: {#section-4.1.1 .section}
#### [4.1.1.](#section-4.1.1){.section-number .selfRef} [Encrypt All or a Subset of Context Headers](#name-encrypt-all-or-a-subset-of-){.section-name .selfRef} {#name-encrypt-all-or-a-subset-of-}

The solution allows encrypting all or a subset of NSH Context Headers by
Classifiers, NSH-aware SFs, and SFC
proxies.[¶](#section-4.1.1-1){.pilcrow}

As depicted in [Table 2](#encryption){.xref}, SFFs are not involved in
data encryption.[¶](#section-4.1.1-2){.pilcrow}

[]{#name-encryption-function-support}

::: {#encryption}
  Data Plane Element   Base and Service Path Headers Encryption   Context Header Encryption
  -------------------- ------------------------------------------ ---------------------------
  Classifier           No                                         Yes
  SFF                  No                                         No
  NSH-aware SF         No                                         Yes
  SFC Proxy            No                                         Yes
  NSH-unaware SF       No                                         No

  : [Table 2](#table-2){.selfRef}: [Encryption Function Supported by SFC
  Data Plane Elements](#name-encryption-function-support){.selfRef}
:::

Classifier(s), NSH-aware SFs, and SFC proxies are instructed with the
set of Context Headers (privacy-sensitive metadata, typically) that must
be encrypted. Encryption keying material is only provided to these SFC
data plane elements.[¶](#section-4.1.1-4){.pilcrow}

The control plane may indicate the set of SFC data plane elements that
are entitled to supply a given Context Header (e.g., in reference to
their identifiers as assigned within the SFC-enabled domain). It is out
of the scope of this document to elaborate on how such instructions are
provided to the appropriate SFC data plane elements nor to detail the
structure used to store the instructions.[¶](#section-4.1.1-5){.pilcrow}

The Service Path Header ([Section
2](https://www.rfc-editor.org/rfc/rfc8300#section-2){.relref} of
\[[RFC8300](#RFC8300){.xref}\]) is not encrypted because SFFs use the
Service Index (SI) in conjunction with the Service Path Identifier (SPI)
for determining the next SF in the path.[¶](#section-4.1.1-6){.pilcrow}
:::

::: {#section-4.1.2 .section}
#### [4.1.2.](#section-4.1.2){.section-number .selfRef} [Integrity Protection](#name-integrity-protection){.section-name .selfRef} {#name-integrity-protection}

The solution provides integrity protection for the NSH data. Two levels
of assurance (LoAs) are supported.[¶](#section-4.1.2-1){.pilcrow}

The first level of assurance is where all NSH data except the Base
Header are integrity protected ([Figure 1](#first){.xref}). In this
case, the NSH imposer may be a Classifier, an NSH-aware SF, or an SFC
Proxy. SFFs are not provided with authentication material. Further
details are discussed in [Section
5.1](#enc1){.xref}.[¶](#section-4.1.2-2){.pilcrow}

[]{#name-first-level-of-assurance}

::: {#first}
::: {#section-4.1.2-3.1 .alignCenter .art-text .artwork}
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                Transport Encapsulation                |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
       |                Base Header                            |  |
    +->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  N
    |  |                Service Path Header                    |  S
    |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  H
    |  |                Context Header(s)                      |  |
    |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
    |  |                Original Packet                        |
    +->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |
    +------Scope of integrity-protected data
:::

[Figure 1](#figure-1){.selfRef}: [First Level of
Assurance](#name-first-level-of-assurance){.selfRef}
:::

The second level of assurance is where all NSH data, including the Base
Header, are integrity protected ([Figure 2](#sec){.xref}). In this case,
the NSH imposer may be a Classifier, an NSH-aware SF, an SFF, or an SFC
Proxy. Further details are provided in [Section
5.2](#enc2){.xref}.[¶](#section-4.1.2-4){.pilcrow}

[]{#name-second-level-of-assurance}

::: {#sec}
::: {#section-4.1.2-5.1 .alignCenter .art-text .artwork}
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                Transport Encapsulation                |
    +->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
    |  |                Base Header                            |  |
    |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  N
    |  |                Service Path Header                    |  S
    |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  H
    |  |                Context Header(s)                      |  |
    |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
    |  |                Original Packet                        |
    +->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |
    +----Scope of integrity-protected data
:::

[Figure 2](#figure-2){.selfRef}: [Second Level of
Assurance](#name-second-level-of-assurance){.selfRef}
:::

The integrity-protection scope is explicitly signaled to NSH-aware SFs,
SFFs, and SFC proxies in the NSH by means of a dedicated MD Type
([Section 5](#new){.xref}).[¶](#section-4.1.2-6){.pilcrow}

In both levels of assurance, the Context Headers and the packet on which
the NSH is imposed are subject to integrity
protection.[¶](#section-4.1.2-7){.pilcrow}

[Table 3](#integrity){.xref} classifies the data plane elements as being
involved or not involved in providing integrity protection for the
NSH.[¶](#section-4.1.2-8){.pilcrow}

[]{#name-integrity-protection-suppor}

::: {#integrity}
  Data Plane Element   Integrity Protection
  -------------------- ----------------------------------
  Classifier           Yes
  SFF                  No (first LoA); Yes (second LoA)
  NSH-aware SF         Yes
  SFC Proxy            Yes
  NSH-unaware SF       No

  : [Table 3](#table-3){.selfRef}: [Integrity Protection Supported by
  SFC Data Plane Elements](#name-integrity-protection-suppor){.selfRef}
:::
:::
:::

::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [One Secret Key, Two Security Services](#name-one-secret-key-two-security){.section-name .selfRef} {#name-one-secret-key-two-security}

The Authenticated Encryption with Associated Data (AEAD) interface
defined in [Section
5](https://www.rfc-editor.org/rfc/rfc5116#section-5){.relref} of
\[[RFC5116](#RFC5116){.xref}\] is used to encrypt the Context Headers
that carry sensitive metadata and to provide integrity protection for
the encrypted Context Headers.[¶](#section-4.2-1){.pilcrow}

The secondary keys \"MAC_KEY\" and \"ENC_KEY\" are generated from the
input secret key (K) as follows; each of these two keys is an octet
string:[¶](#section-4.2-2){.pilcrow}

[]{.break}

MAC_KEY:
:   Consists of the initial MAC_KEY_LEN octets of K, in order. The
    MAC_KEY is used for calculating the message integrity of the NSH
    data. In other words, the integrity protection provided by the
    cryptographic mechanism is extended to also provide protection for
    the unencrypted Context Headers and the packet on which the NSH is
    imposed.[¶](#section-4.2-3.2){.pilcrow}
:   

ENC_KEY:
:   Consists of the final ENC_KEY_LEN octets of K, in order. The ENC_KEY
    is used as the symmetric encryption key for encrypting the Context
    Headers.[¶](#section-4.2-3.4){.pilcrow}
:   

The Hashed Message Authentication Code (HMAC) algorithm discussed in
\[[RFC4868](#RFC4868){.xref}\] is used to protect the integrity of the
NSH data. The algorithm for implementing and validating HMACs is
provided in \[[RFC2104](#RFC2104){.xref}\].[¶](#section-4.2-4){.pilcrow}

The advantage of using both AEAD and HMAC algorithms (instead of just
AEAD) is that NSH-aware SFs and SFC proxies only need to recompute the
message integrity of the NSH data after decrementing the SI and do not
have to recompute the ciphertext. The other advantage is that SFFs do
not have access to the ENC_KEY and cannot act on the encrypted Context
Headers, and (in the case of the second level of assurance) SFFs do have
access to the MAC_KEY. Similarly, an NSH-aware SF or SFC Proxy not
allowed to decrypt the Context Headers will not have access to the
ENC_KEY.[¶](#section-4.2-5){.pilcrow}

The authenticated encryption algorithm or HMAC algorithm to be used by
SFC data plane elements is typically controlled using the SFC control
plane. Mandatory-to-implement authenticated encryption and HMAC
algorithms are listed in [Section
4.3](#mti){.xref}.[¶](#section-4.2-6){.pilcrow}

The authenticated encryption process takes four inputs, each of which is
an octet string: a secret key (ENC_KEY, referred to as \"K\" in
\[[RFC5116](#RFC5116){.xref}\]), a plaintext (P), associated data (A)
(which contains the data to be authenticated but not encrypted), and a
nonce (N). A ciphertext (C) is generated as an output as discussed in
[Section
2.1](https://www.rfc-editor.org/rfc/rfc5116#section-2.1){.relref} of
\[[RFC5116](#RFC5116){.xref}\].[¶](#section-4.2-7){.pilcrow}

In order to decrypt and verify, the cipher takes ENC_KEY, N, A, and C as
input. The output is either the plaintext or an error indicating that
the decryption failed as described in [Section
2.2](https://www.rfc-editor.org/rfc/rfc5116#section-2.2){.relref} of
\[[RFC5116](#RFC5116){.xref}\].[¶](#section-4.2-8){.pilcrow}
:::

::: {#mti}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Mandatory-to-Implement Authenticated Encryption and HMAC Algorithms](#name-mandatory-to-implement-auth){.section-name .selfRef} {#name-mandatory-to-implement-auth}

Classifiers, NSH-aware SFs, and SFC proxies [MUST]{.bcp14} implement the
AES_128_GCM \[[GCM](#GCM){.xref}\]\[[RFC5116](#RFC5116){.xref}\]
algorithm and [SHOULD]{.bcp14} implement the AES_192_GCM and AES_256_GCM
algorithms.[¶](#section-4.3-1){.pilcrow}

Classifiers, NSH-aware SFs, and SFC proxies [MUST]{.bcp14} implement the
HMAC-SHA-256-128 algorithm and [SHOULD]{.bcp14} implement the
HMAC-SHA-384-192 and HMAC-SHA-512-256
algorithms.[¶](#section-4.3-2){.pilcrow}

SFFs [MAY]{.bcp14} implement the aforementioned cipher suites and HMAC
algorithms.[¶](#section-4.3-3){.pilcrow}

Note: The use of the AES_128_CBC_HMAC_SHA_256 algorithm would have
avoided the need for a second 128-bit authentication tag, but due to the
nature of how Cipher Block Chaining (CBC) mode operates,
AES_128_CBC_HMAC_SHA_256 allows for the malleability of plaintexts. This
malleability allows for attackers that know the Message Authentication
Code (MAC) key but not the encryption key to make changes in the
ciphertext and, if parts of the plaintext are known, create arbitrary
blocks of plaintext. This specification mandates the use of separate
AEAD and MAC protections to prevent this type of
attack.[¶](#section-4.3-4){.pilcrow}
:::
:::

::: {#kms}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Key Management](#name-key-management){.section-name .selfRef} {#name-key-management}

The procedure for the allocation/provisioning of secret keys (K) and the
authenticated encryption algorithm or MAC_KEY and HMAC algorithm is
outside the scope of this specification. As such, this specification
does not mandate the support of any specific
mechanism.[¶](#section-4.4-1){.pilcrow}

The document does not assume nor preclude the
following:[¶](#section-4.4-2){.pilcrow}

-   [The same keying material is used for all the service functions used
    within an SFC-enabled
    domain.[¶](#section-4.4-3.1){.pilcrow}]{#section-4.4-3.1}
-   [Distinct keying material is used per SFP by all involved SFC data
    path elements.[¶](#section-4.4-3.2){.pilcrow}]{#section-4.4-3.2}
-   [Per-tenant keys are
    used.[¶](#section-4.4-3.3){.pilcrow}]{#section-4.4-3.3}

In order to accommodate deployments relying upon keying material per
SFC/SFP and also the need to update keys after encrypting NSH data for a
certain amount of time, this document uses key identifiers to
unambiguously identify the appropriate keying material and associated
algorithms for MAC and encryption. This use of in-band identifiers
addresses the problem of the synchronization of keying
material.[¶](#section-4.4-4){.pilcrow}

Additional information on manual vs. automated key management and when
one should be used over the other can be found in
\[[RFC4107](#RFC4107){.xref}\].[¶](#section-4.4-5){.pilcrow}

The risk involved in using a group-shared symmetric key increases with
the size of the group to which it is shared. Additional security issues
are discussed in [Section
9](#Security){.xref}.[¶](#section-4.4-6){.pilcrow}
:::
:::

::: {#newch}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [New NSH Variable-Length Context Headers](#name-new-nsh-variable-length-con){.section-name .selfRef} {#name-new-nsh-variable-length-con}

New NSH Variable-Length Context Headers are defined in [Section
5](#new){.xref} for NSH data integrity protection and, optionally,
encryption of Context Headers carrying sensitive metadata. Concretely,
an NSH imposer includes (1) the key identifier to identify the keying
material, (2) the timestamp to protect against replay attacks ([Section
7.4](#time){.xref}), and (3) MAC for the target NSH data (depending on
the integrity-protection scope) calculated using MAC_KEY and,
optionally, Context Headers encrypted using
ENC_KEY.[¶](#section-4.5-1){.pilcrow}

An SFC data plane element that needs to check the integrity of the NSH
data uses the MAC_KEY and HMAC algorithm for the key identifier being
carried in the NSH.[¶](#section-4.5-2){.pilcrow}

An NSH-aware SF or SFC Proxy that needs to decrypt some Context Headers
uses ENC_KEY and the decryption algorithm for the key identifier being
carried in the NSH.[¶](#section-4.5-3){.pilcrow}

[Section 7](#prorules){.xref} specifies the detailed
procedure.[¶](#section-4.5-4){.pilcrow}
:::
:::

::: {#nsh-in-nsh}
::: {#section-4.6 .section}
### [4.6.](#section-4.6){.section-number .selfRef} [Encapsulation of NSH within NSH](#name-encapsulation-of-nsh-within){.section-name .selfRef} {#name-encapsulation-of-nsh-within}

As discussed in [Section
3](https://www.rfc-editor.org/rfc/rfc8459#section-3){.relref} of
\[[RFC8459](#RFC8459){.xref}\], an SFC-enabled domain (called an
upper-level domain) may be decomposed into many sub-domains (called
lower-level domains). In order to avoid maintaining state to restore
upper-level NSH information at the boundaries of lower-level domains,
two NSH levels are used: an Upper-NSH that is imposed at the boundaries
of the upper-level domain and a Lower-NSH that is pushed by the
Classifier of a lower-level domain in front of the original NSH ([Figure
3](#nest){.xref}). As such, the Upper-NSH information is carried along
the lower-level chain without modification. The packet is forwarded in
the top-level domain according to the Upper-NSH, while it is forwarded
according to the Lower-NSH in a lower-level
domain.[¶](#section-4.6-1){.pilcrow}

[]{#name-encapsulation-of-nsh-within-}

::: {#nest}
::: {#section-4.6-2.1 .alignCenter .art-text .artwork}
       +---------------------------------+
       |     Transport Encapsulation     |
    +->+---------------------------------+
    |  |        Lower-NSH Header         |
    |  +---------------------------------+
    |  |        Upper-NSH Header         |
    |  +---------------------------------+
    |  |          Original Packet        |
    +->+---------------------------------+
    |
    |
    +----Scope of NSH security protection
         provided by a lower-level domain
:::

[Figure 3](#figure-3){.selfRef}: [Encapsulation of NSH within
NSH](#name-encapsulation-of-nsh-within-){.selfRef}
:::

SFC data plane elements of a lower-level domain include the Upper-NSH
when computing the MAC.[¶](#section-4.6-3){.pilcrow}

Keying material used at the upper-level domain [SHOULD NOT]{.bcp14} be
the same as the one used by a lower-level
domain.[¶](#section-4.6-4){.pilcrow}
:::
:::
:::
:::

::: {#new}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [New NSH Variable-Length Context Headers](#name-new-nsh-variable-length-cont){.section-name .selfRef} {#name-new-nsh-variable-length-cont}

This section specifies the format of new Variable-Length Context Headers
that are used for NSH integrity protection and, optionally, Context
Header encryption.[¶](#section-5-1){.pilcrow}

In particular, this section defines two \"MAC and Encrypted Metadata\"
Context Headers, each having specific deployment constraints. Unlike
[Section 5.1](#enc1){.xref}, the level of assurance provided in [Section
5.2](#enc2){.xref} requires sharing MAC_KEY with SFFs. Both Context
Headers have the same format as shown in [Figure
4](#mac){.xref}.[¶](#section-5-2){.pilcrow}

[]{#name-mac-and-encrypted-metadata-}

::: {#mac}
::: {#section-5-3.1 .alignCenter .art-text .artwork}
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Metadata Class       |      Type     |U|    Length   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       | Key Id Len  |         Key Identifier (Variable)               ~
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       ~                      Timestamp (8 bytes)                      ~
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       | Nonce Length  |           Nonce  (Variable)                   ~
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |     Message Authentication Code and optional Encrypted        |
       ~                  Context Headers (Variable)                   ~
       |                                                               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 4](#figure-4){.selfRef}: [MAC and Encrypted Metadata Context
Header](#name-mac-and-encrypted-metadata-){.selfRef}
:::

The \"MAC and Encrypted Metadata\" Context Headers are padded out to a
multiple of 4 bytes as per [Section
2.2](https://www.rfc-editor.org/rfc/rfc8300#section-2.2){.relref} of
\[[RFC8300](#RFC8300){.xref}\]. The \"MAC and Encrypted Metadata\"
Context Header, if included, [MUST]{.bcp14} always be the last Context
Header.[¶](#section-5-4){.pilcrow}

::: {#enc1}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [MAC#1 Context Header](#name-mac1-context-header){.section-name .selfRef} {#name-mac1-context-header}

The MAC#1 Context Header is a Variable-Length Context Header that
carries MAC for the Service Path Header, Context Headers, and the inner
packet on which NSH is imposed, calculated using MAC_KEY and,
optionally, Context Headers encrypted using ENC_KEY. The scope of the
integrity protection provided by this Context Header is depicted in
[Figure 5](#scope1){.xref}.[¶](#section-5.1-1){.pilcrow}

This MAC scheme does not require sharing MAC_KEY with SFFs. It does not
require recomputing the MAC by each SFF because of TTL processing.
[Section 9.1](#mac1){.xref} discusses the possible threat associated
with this level of assurance.[¶](#section-5.1-2){.pilcrow}

[]{#name-scope-of-mac1}

::: {#scope1}
::: {#section-5.1-3.1 .alignCenter .art-text .artwork}
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<--+
       |          Service Path Identifier              | Service Index |   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
       ~       Variable-Length Unencrypted Context Headers  (opt.)     ~   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
       |          Metadata Class       |      Type     |U|    Length   |   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
       | Key Id Len  |         Key Identifier (Variable)               ~   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
       ~                      Timestamp (8 bytes)                      ~   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
       | Nonce Length  |           Nonce  (Variable)                   ~   |
    +->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
    |  ~                Encrypted Context Headers (opt.)               ~   |
    +->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
    |  ~                 Message Authentication Code                   ~   |
    |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
    |  |                                                               |   |
    |  ~               Inner Packet on which NSH is imposed            ~   |
    |  |                                                               |   |
    |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<--|
    |                                                                      |
    |                                       Integrity-Protection Scope ----+
    +----Encrypted Data
:::

[Figure 5](#figure-5){.selfRef}: [Scope of
MAC#1](#name-scope-of-mac1){.selfRef}
:::

In reference to [Figure 4](#mac){.xref}, the description of the fields
is as follows:[¶](#section-5.1-4){.pilcrow}

[]{.break}

Metadata Class:
:   [MUST]{.bcp14} be set to 0x0 ([Section
    2.2](https://www.rfc-editor.org/rfc/rfc8300#section-2.2){.relref} of
    \[[RFC8300](#RFC8300){.xref}\]).[¶](#section-5.1-5.2){.pilcrow}
:   

Type:
:   0x02 (see [Section
    10](#IANA){.xref}).[¶](#section-5.1-5.4){.pilcrow}
:   

U:
:   Unassigned bit ([Section
    2.5.1](https://www.rfc-editor.org/rfc/rfc8300#section-2.5.1){.relref}
    of \[[RFC8300](#RFC8300){.xref}\]).[¶](#section-5.1-5.6){.pilcrow}
:   

Length:
:   Indicates the length of the variable-length metadata in bytes.
    Padding considerations are discussed in [Section
    2.5.1](https://www.rfc-editor.org/rfc/rfc8300#section-2.5.1){.relref}
    of \[[RFC8300](#RFC8300){.xref}\].[¶](#section-5.1-5.8){.pilcrow}
:   

Key Id Len:
:   Variable. Carries the length of the key identifier in
    octets.[¶](#section-5.1-5.10){.pilcrow}
:   

Key Identifier:
:   Carries a variable-length Key Identifier object used to identify and
    deliver keys to SFC data plane elements. This identifier is helpful
    for accommodating deployments relying upon keying material per
    SFC/SFP. The key identifier helps to resolve the problem of
    synchronization of keying material. A single key identifier is used
    to look up both the ENC_KEY and the MAC_KEY associated with a key,
    and the corresponding encryption and MAC algorithms used with those
    keys.[¶](#section-5.1-5.12){.pilcrow}
:   

Timestamp:
:   Refer to [Section 6](#timef){.xref} for more details about the
    structure of this field.[¶](#section-5.1-5.14){.pilcrow}
:   

Nonce Length:
:   Carries the length of the Nonce. If the Context Headers are only
    integrity protected, \"Nonce Length\" is set to zero (that is, no
    \"Nonce\" is included).[¶](#section-5.1-5.16){.pilcrow}
:   

Nonce:
:   Carries the Nonce for the authenticated encryption operation
    ([Section
    3.1](https://www.rfc-editor.org/rfc/rfc5116#section-3.1){.relref} of
    \[[RFC5116](#RFC5116){.xref}\]).[¶](#section-5.1-5.18){.pilcrow}
:   

Encrypted Context Headers:
:   Carries the optional encrypted Context
    Headers.[¶](#section-5.1-5.20){.pilcrow}
:   

Message Authentication Code:
:   Covers the entire NSH data, excluding the Base
    Header.[¶](#section-5.1-5.22){.pilcrow}
:   
:::
:::

::: {#enc2}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [MAC#2 Context Header](#name-mac2-context-header){.section-name .selfRef} {#name-mac2-context-header}

The MAC#2 Context Header is a Variable-Length Context Header that
carries the MAC for the entire NSH data calculated using MAC_KEY and,
optionally, Context Headers encrypted using ENC_KEY. The scope of the
integrity protection provided by this Context Header is depicted in
[Figure 6](#scope2){.xref}.[¶](#section-5.2-1){.pilcrow}

[]{#name-scope-of-mac2}

::: {#scope2}
::: {#section-5.2-2.1 .alignCenter .art-text .artwork}
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<--+
       |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
       |          Service Path Identifier              | Service Index |   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
       ~       Variable-Length Unencrypted Context Headers  (opt.)     ~   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
       |          Metadata Class       |      Type     |U|    Length   |   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
       | Key Id Len  |         Key Identifier (Variable)               ~   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
       ~                      Timestamp (8 bytes)                      ~   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
       | Nonce Length  |           Nonce  (Variable)                   ~   |
    +->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
    |  ~                Encrypted Context Headers (opt.)               ~   |
    +->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
    |  ~                 Message Authentication Code                   ~   |
    |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
    |  |                                                               |   |
    |  ~               Inner Packet on which NSH is imposed            ~   |
    |  |                                                               |   |
    |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<--|
    |                                                                      |
    |                                       Integrity-Protection Scope ----+
    +----Encrypted Data
:::

[Figure 6](#figure-6){.selfRef}: [Scope of
MAC#2](#name-scope-of-mac2){.selfRef}
:::

In reference to [Figure 4](#mac){.xref}, the description of the fields
is as follows:[¶](#section-5.2-3){.pilcrow}

[]{.break}

Metadata Class:
:   [MUST]{.bcp14} be set to 0x0 ([Section
    2.2](https://www.rfc-editor.org/rfc/rfc8300#section-2.2){.relref} of
    \[[RFC8300](#RFC8300){.xref}\]).[¶](#section-5.2-4.2){.pilcrow}
:   

Type:
:   0x03 (see [Section
    10](#IANA){.xref}).[¶](#section-5.2-4.4){.pilcrow}
:   

U:
:   Unassigned bit ([Section
    2.5.1](https://www.rfc-editor.org/rfc/rfc8300#section-2.5.1){.relref}
    of \[[RFC8300](#RFC8300){.xref}\]).[¶](#section-5.2-4.6){.pilcrow}
:   

Length:
:   Indicates the length of the variable-length metadata in bytes.
    Padding considerations are discussed in [Section
    2.5.1](https://www.rfc-editor.org/rfc/rfc8300#section-2.5.1){.relref}
    of \[[RFC8300](#RFC8300){.xref}\].[¶](#section-5.2-4.8){.pilcrow}
:   

Key Id Len:
:   See [Section 5.1](#enc1){.xref}.[¶](#section-5.2-4.10){.pilcrow}
:   

Key Identifier:
:   See [Section 5.1](#enc1){.xref}.[¶](#section-5.2-4.12){.pilcrow}
:   

Timestamp:
:   See [Section 6](#timef){.xref}.[¶](#section-5.2-4.14){.pilcrow}
:   

Nonce Length:
:   See [Section 5.1](#enc1){.xref}.[¶](#section-5.2-4.16){.pilcrow}
:   

Nonce:
:   See [Section 5.1](#enc1){.xref}.[¶](#section-5.2-4.18){.pilcrow}
:   

Encrypted Context Headers:
:   Carries the optional encrypted Context
    Headers.[¶](#section-5.2-4.20){.pilcrow}
:   

Message Authentication Code:
:   Covers the entire NSH data.[¶](#section-5.2-4.22){.pilcrow}
:   
:::
:::
:::
:::

::: {#timef}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Timestamp Format](#name-timestamp-format){.section-name .selfRef} {#name-timestamp-format}

This section follows the template provided in [Section
3](https://www.rfc-editor.org/rfc/rfc8877#section-3){.relref} of
\[[RFC8877](#RFC8877){.xref}\].[¶](#section-6-1){.pilcrow}

The format of the Timestamp field introduced in [Section 5](#new){.xref}
is depicted in [Figure 7](#tf){.xref}.[¶](#section-6-2){.pilcrow}

[]{#name-timestamp-field-format}

::: {#tf}
::: {#section-6-3.1 .alignCenter .art-text .artwork}
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                            Seconds                            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           Fraction                            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 7](#figure-7){.selfRef}: [Timestamp Field
Format](#name-timestamp-field-format){.selfRef}
:::

[]{.break}

Timestamp field format:
:   []{.break}

    Seconds:
    :   Specifies the integer portion of the number of seconds since the
        epoch.[¶](#section-6-4.2.1.2){.pilcrow}
    :   

    \+ Size:
    :   32 bits[¶](#section-6-4.2.1.4){.pilcrow}
    :   

    \+ Units:
    :   Seconds[¶](#section-6-4.2.1.6){.pilcrow}
    :   

    Fraction:
    :   Specifies the fractional portion of the number of seconds since
        the epoch.[¶](#section-6-4.2.1.8){.pilcrow}
    :   

    \+ Size:
    :   32 bits[¶](#section-6-4.2.1.10){.pilcrow}
    :   

    \+ Units:
    :   The unit is 2^(-32)^ seconds, which is roughly equal to 233
        picoseconds.[¶](#section-6-4.2.1.12){.pilcrow}
    :   
:   

[]{.break}

Epoch:
:   The epoch is 1970-01-01T00:00 in UTC time. Note that this epoch
    value is different from the one used in [Section
    6](https://www.rfc-editor.org/rfc/rfc5905#section-6){.relref} of
    \[[RFC5905](#RFC5905){.xref}\] (which will wrap around in
    2036).[¶](#section-6-5.2){.pilcrow}
:   

Leap seconds:
:   This timestamp format is affected by leap seconds. The timestamp
    represents the number of seconds elapsed since the epoch minus the
    number of leap seconds.[¶](#section-6-5.4){.pilcrow}
:   

Resolution:
:   The resolution is 2^(-32)^ seconds.[¶](#section-6-5.6){.pilcrow}
:   

Wraparound:
:   This time format wraps around every 2^32^ seconds, which is roughly
    136 years. The next wraparound will occur in the year
    2106.[¶](#section-6-5.8){.pilcrow}
:   

Synchronization aspects:
:   It is assumed that SFC data plane elements are synchronized to UTC
    using a synchronization mechanism that is outside the scope of this
    document. In typical deployments, SFC data plane elements use NTP
    \[[RFC5905](#RFC5905){.xref}\] for synchronization. Thus, the
    timestamp may be derived from the NTP-synchronized clock, allowing
    the timestamp to be measured with respect to the clock of an NTP
    server. Since this time format is specified in terms of UTC, it is
    affected by leap seconds (in a manner analogous to the NTP time
    format, which is similar). Therefore, the value of a timestamp
    during or slightly after a leap second may be temporarily
    inaccurate.[¶](#section-6-5.10){.pilcrow}
:   
:::
:::

::: {#prorules}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Processing Rules](#name-processing-rules){.section-name .selfRef} {#name-processing-rules}

The following subsections describe the processing rules for
integrity-protected NSH and, optionally, encrypted Context
Headers.[¶](#section-7-1){.pilcrow}

::: {#gen}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Generic Behavior](#name-generic-behavior){.section-name .selfRef} {#name-generic-behavior}

This document adheres to the recommendations in [Section
8.1](https://www.rfc-editor.org/rfc/rfc8300#section-8.1){.relref} of
\[[RFC8300](#RFC8300){.xref}\] for handling the Context Headers at both
ingress and egress SFC boundary nodes (i.e., to strip the entire NSH,
including Context Headers).[¶](#section-7.1-1){.pilcrow}

Failures of a Classifier to inject the Context Headers defined in this
document [SHOULD]{.bcp14} be logged locally while a notification alarm
[MAY]{.bcp14} be sent to an SFC control element. Failures of an
NSH-aware node to validate the integrity of the NSH data [MUST]{.bcp14}
cause that packet to be discarded while a notification alarm
[MAY]{.bcp14} be sent to an SFC control element. The details of sending
notification alarms (i.e., the parameters that affect the transmission
of the notification alarms depending on the information in the Context
Header such as frequency, thresholds, and content in the alarm)
[SHOULD]{.bcp14} be configurable.[¶](#section-7.1-2){.pilcrow}

NSH-aware SFs and SFC proxies [MAY]{.bcp14} be instructed to strip some
encrypted Context Headers from the packet or to pass the data to the
next SF in the service function chain after processing the content of
the Context Headers. If no instruction is provided, the default behavior
for intermediary NSH-aware nodes is to maintain such Context Headers so
that the information can be passed to the next NSH-aware hops. NSH-aware
SFs and SFC proxies [MUST]{.bcp14} reapply the integrity protection if
any modification is made to the Context Headers (e.g., strip a Context
Header, update the content of an existing Context Header, insert a new
Context Header).[¶](#section-7.1-3){.pilcrow}

An NSH-aware SF or SFC Proxy that is not allowed to decrypt any Context
Headers [MUST NOT]{.bcp14} be given access to the
ENC_KEY.[¶](#section-7.1-4){.pilcrow}

Otherwise, an NSH-aware SF or SFC Proxy that receives encrypted Context
Headers, for which it is not allowed to consume a specific Context
Header it decrypts (but consumes others), [MUST]{.bcp14} keep that
Context Header unaltered when forwarding the packet
upstream.[¶](#section-7.1-5){.pilcrow}

Only one instance of a \"MAC and Encrypted Metadata\" Context Header
([Section 5](#new){.xref}) is allowed in an NSH level. If multiple
instances of a \"MAC and Encrypted Metadata\" Context Header are
included in an NSH level, the SFC data plane element [MUST]{.bcp14}
process the first instance and ignore subsequent instances and
[MAY]{.bcp14} log or increase a counter for this event as per [Section
2.5.1](https://www.rfc-editor.org/rfc/rfc8300#section-2.5.1){.relref} of
\[[RFC8300](#RFC8300){.xref}\]. If NSH within NSH is used ([Section
4.6](#nsh-in-nsh){.xref}), distinct LoAs may be used for each NSH
level.[¶](#section-7.1-6){.pilcrow}

MTU and fragmentation considerations are discussed in [Section
8](#MTU){.xref}.[¶](#section-7.1-7){.pilcrow}
:::
:::

::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [MAC NSH Data Generation](#name-mac-nsh-data-generation){.section-name .selfRef} {#name-mac-nsh-data-generation}

After performing any Context Header encryption, the HMAC algorithm
discussed in \[[RFC4868](#RFC4868){.xref}\] is used to integrity protect
the target NSH data. An NSH imposer inserts a \"MAC and Encrypted
Metadata\" Context Header for integrity protection ([Section
5](#new){.xref}).[¶](#section-7.2-1){.pilcrow}

The NSH imposer sets the MAC field to zero and then computes the message
integrity for the target NSH data (depending on the integrity-protection
scope discussed in [Section 5](#new){.xref}) using the MAC_KEY and HMAC
algorithm. It inserts the computed digest in the MAC field of the \"MAC
and Encrypted Metadata\" Context Header. The length of the MAC is
decided by the HMAC algorithm adopted for the particular key
identifier.[¶](#section-7.2-2){.pilcrow}

The Message Authentication Code (T) computation process for the target
NSH data with HMAC-SHA-256-128() can be illustrated as
follows:[¶](#section-7.2-3){.pilcrow}

::: {#section-7.2-4 .alignLeft .art-text .artwork}
          T = HMAC-SHA-256-128(MAC_KEY, target NSH data)

[¶](#section-7.2-4){.pilcrow}
:::

An entity in the SFP that updates the NSH [MUST]{.bcp14} follow the
above behavior to maintain message integrity of the NSH for subsequent
validations.[¶](#section-7.2-5){.pilcrow}
:::

::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Encrypted NSH Metadata Generation](#name-encrypted-nsh-metadata-gene){.section-name .selfRef} {#name-encrypted-nsh-metadata-gene}

An NSH imposer can encrypt Context Headers carrying sensitive metadata,
i.e., encrypted and unencrypted metadata may be carried simultaneously
in the same NSH packet (Sections [5](#scope1){.xref} and
[6](#scope2){.xref}).[¶](#section-7.3-1){.pilcrow}

In order to prevent pervasive monitoring \[[RFC7258](#RFC7258){.xref}\],
it is [RECOMMENDED]{.bcp14} to encrypt all Context Headers. All Context
Headers carrying privacy-sensitive metadata [MUST]{.bcp14} be encrypted;
by doing so, privacy-sensitive metadata is not revealed to attackers.
Privacy-specific threats are discussed in [Section
5.2](https://www.rfc-editor.org/rfc/rfc6973#section-5.2){.relref} of
\[[RFC6973](#RFC6973){.xref}\].[¶](#section-7.3-2){.pilcrow}

Using the secret key (ENC_KEY) and authenticated encryption algorithm,
the NSH imposer encrypts the Context Headers (as set, for example, in
[Section 3](#req){.xref}) and inserts the resulting payload in the \"MAC
and Encrypted Metadata\" Context Header ([Section 5](#new){.xref}). The
additional authenticated data input to the AEAD function is a
zero-length byte string. The entire Context Header carrying sensitive
metadata is encrypted (that is, including the MD Class, Type, Length,
and associated metadata of each Context
Header).[¶](#section-7.3-3){.pilcrow}

More details about the exact encryption procedure are provided in
[Section
2.1](https://www.rfc-editor.org/rfc/rfc5116#section-2.1){.relref} of
\[[RFC5116](#RFC5116){.xref}\]. In this case, the associated data (A)
input is zero length for AES Galois/Counter Mode
(AES-GCM).[¶](#section-7.3-4){.pilcrow}

An authorized entity in the SFP that updates the content of an encrypted
Context Header or needs to add a new encrypted Context Header
[MUST]{.bcp14} also follow the aforementioned
behavior.[¶](#section-7.3-5){.pilcrow}
:::

::: {#time}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [Timestamp for Replay Attack Prevention](#name-timestamp-for-replay-attack){.section-name .selfRef} {#name-timestamp-for-replay-attack}

The Timestamp imposed by an initial Classifier is left untouched along
an SFP. However, it can be updated when reclassification occurs
([Section
4.8](https://www.rfc-editor.org/rfc/rfc7665#section-4.8){.relref} of
\[[RFC7665](#RFC7665){.xref}\]). The same considerations for setting the
Timestamp are followed in both initial classification and
reclassification ([Section
6](#timef){.xref}).[¶](#section-7.4-1){.pilcrow}

The received NSH is accepted by an NSH-aware node if the Timestamp (TS)
in the NSH is recent enough to the reception time of the NSH (TSrt). The
following formula is used for this check:[¶](#section-7.4-2){.pilcrow}

::: {#section-7.4-3 .alignLeft .art-text .artwork}
          -Delta < (TSrt - TS) < +Delta

[¶](#section-7.4-3){.pilcrow}
:::

The Delta interval is a configurable parameter. The default value for
the allowed Delta is 2 seconds. Special care should be taken when
setting very low Delta values as this may lead to dropping legitimate
traffic. If the timestamp is not within the boundaries, then the SFC
data plane element receiving such packets [MUST]{.bcp14} discard the NSH
message.[¶](#section-7.4-4){.pilcrow}

Replay attacks within the Delta window may be detected by an NSH-aware
node by recording a unique value derived from the packet, such as a
unique value from the MAC field value. Such an NSH-aware node will
detect and reject duplicates. If for legitimate service reasons some
flows have to be duplicated but still share a portion of an SFP with the
original flow, legitimate duplicate packets will be tagged by NSH-aware
nodes involved in that segment as replay packets unless sufficient
entropy is added to the duplicate packet. How such an entropy is added
is implementation specific.[¶](#section-7.4-5){.pilcrow}

Note: Within the timestamp Delta window, defining a sequence number to
protect against replay attacks may be considered. In such a mode,
NSH-aware nodes must discard packets with duplicate sequence numbers
within the timestamp Delta window. However, in deployments with several
instances of the same SF (e.g., cluster or load-balanced SFs), a
mechanism to coordinate among those instances to discard duplicate
sequence numbers is required. Because the coordination mechanism to
comply with this requirement is service specific, this document does not
include this protection.[¶](#section-7.4-6){.pilcrow}

All SFC data plane elements must be synchronized among themselves. These
elements may be synchronized to a global reference
time.[¶](#section-7.4-7){.pilcrow}
:::
:::

::: {#section-7.5 .section}
### [7.5.](#section-7.5){.section-number .selfRef} [NSH Data Validation](#name-nsh-data-validation){.section-name .selfRef} {#name-nsh-data-validation}

When an SFC data plane element that conforms to this specification needs
to check the validity of the NSH data, it [MUST]{.bcp14} ensure that a
\"MAC and Encrypted Metadata\" Context Header is included in a received
NSH packet. The imposer [MUST]{.bcp14} silently discard the packet and
[MUST]{.bcp14} log an error at least once per the SPI if at least one of
the following is observed:[¶](#section-7.5-1){.pilcrow}

-   [the \"MAC and Encrypted Metadata\" Context Header is
    missing,[¶](#section-7.5-2.1){.pilcrow}]{#section-7.5-2.1}
-   [the enclosed key identifier is unknown or invalid (e.g., the
    corresponding key expired),
    or[¶](#section-7.5-2.2){.pilcrow}]{#section-7.5-2.2}
-   [the timestamp is invalid ([Section
    7.4](#time){.xref}).[¶](#section-7.5-2.3){.pilcrow}]{#section-7.5-2.3}

If the timestamp check is successfully passed, the SFC data plane
element proceeds with NSH data integrity validation. After storing the
value of the MAC field in the \"MAC and Encrypted Metadata\" Context
Header, the SFC data plane element fills the MAC field with zeros. Then,
the SFC data plane element generates the message integrity for the
target NSH data (depending on the integrity-protection scope discussed
in [Section 5](#new){.xref}) using the MAC_KEY and HMAC algorithm. If
the value of the newly generated digest is identical to the stored one,
the SFC data plane element is certain that the NSH data has not been
tampered with and validation is therefore successful. Otherwise, the NSH
packet [MUST]{.bcp14} be discarded. The comparison of the computed HMAC
value to the stored value [MUST]{.bcp14} be done in a constant-time
manner to thwart timing attacks.[¶](#section-7.5-3){.pilcrow}
:::

::: {#section-7.6 .section}
### [7.6.](#section-7.6){.section-number .selfRef} [Decryption of NSH Metadata](#name-decryption-of-nsh-metadata){.section-name .selfRef} {#name-decryption-of-nsh-metadata}

If entitled to consume a supplied encrypted Context Header, an NSH-aware
SF or SFC Proxy decrypts metadata using (K) and a decryption algorithm
for the key identifier in the NSH.[¶](#section-7.6-1){.pilcrow}

The authenticated encryption algorithm has only a single output, either
a plaintext or a special symbol (FAIL) that indicates that the inputs
are not authentic ([Section
2.2](https://www.rfc-editor.org/rfc/rfc5116#section-2.2){.relref} of
\[[RFC5116](#RFC5116){.xref}\]).[¶](#section-7.6-2){.pilcrow}
:::
:::
:::

::: {#MTU}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [MTU Considerations](#name-mtu-considerations){.section-name .selfRef} {#name-mtu-considerations}

The SFC architecture prescribes that additional information be added to
packets to:[¶](#section-8-1){.pilcrow}

-   [Identify SFPs: this is typically the NSH Base Header and Service
    Path Header.[¶](#section-8-2.1){.pilcrow}]{#section-8-2.1}
-   [Carry metadata such as that defined in [Section
    5](#new){.xref}.[¶](#section-8-2.2){.pilcrow}]{#section-8-2.2}
-   [Steer the traffic along the SFPs: This is realized by means of
    transport
    encapsulation.[¶](#section-8-2.3){.pilcrow}]{#section-8-2.3}

This added information increases the size of the packet to be carried
along an SFP.[¶](#section-8-3){.pilcrow}

Aligned with [Section
5](https://www.rfc-editor.org/rfc/rfc8300#section-5){.relref} of
\[[RFC8300](#RFC8300){.xref}\], it is [RECOMMENDED]{.bcp14} that network
operators increase the underlying MTU so that NSH traffic is forwarded
within an SFC-enabled domain without fragmentation. The available
underlying MTU should be taken into account by network operators when
providing SFs with the required Context Headers to be injected per SFP
and the size of the data to be carried in these Context
Headers.[¶](#section-8-4){.pilcrow}

If the underlying MTU cannot be increased to accommodate the NSH
overhead, network operators may rely upon a transport encapsulation
protocol with the required fragmentation handling. The impact of
activating such features on SFFs should be carefully assessed by network
operators ([Section
5.6](https://www.rfc-editor.org/rfc/rfc7665#section-5.6){.relref} of
\[[RFC7665](#RFC7665){.xref}\]).[¶](#section-8-5){.pilcrow}

When dealing with MTU issues, network operators should consider the
limitations of various tunnel mechanisms such as those discussed in
\[[INTERNET-IP-TUNNELS](#I-D.ietf-intarea-tunnels){.xref}\].[¶](#section-8-6){.pilcrow}
:::
:::

::: {#Security}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

Data plane SFC-related security considerations, including privacy, are
discussed in [Section
6](https://www.rfc-editor.org/rfc/rfc7665#section-6){.relref} of
\[[RFC7665](#RFC7665){.xref}\] and [Section
8](https://www.rfc-editor.org/rfc/rfc8300#section-8){.relref} of
\[[RFC8300](#RFC8300){.xref}\]. In particular, [Section
8.2.2](https://www.rfc-editor.org/rfc/rfc8300#section-8.2.2){.relref} of
\[[RFC8300](#RFC8300){.xref}\] states that attached metadata (i.e.,
Context Headers) should be limited to that which is necessary for
correct operation of the SFP. Also, that section indicates that
\[[RFC8165](#RFC8165){.xref}\] discusses metadata considerations that
operators can take into account when using
NSH.[¶](#section-9-1){.pilcrow}

The guidelines for cryptographic key management are discussed in
\[[RFC4107](#RFC4107){.xref}\]. The group key management
protocol-related security considerations discussed in [Section
8](https://www.rfc-editor.org/rfc/rfc4046#section-8){.relref} of
\[[RFC4046](#RFC4046){.xref}\] need to be taken into
consideration.[¶](#section-9-2){.pilcrow}

The interaction between the SFC data plane elements and a key management
system [MUST NOT]{.bcp14} be transmitted unencrypted since this would
completely destroy the security benefits of the integrity-protection
solution defined in this document.[¶](#section-9-3){.pilcrow}

The secret key (K) must have an expiration time assigned as the latest
point in time before which the key may be used for integrity protection
of NSH data and encryption of Context Headers. Prior to the expiration
of the secret key, all participating NSH-aware nodes [SHOULD]{.bcp14}
have the control plane distribute a new key identifier and associated
keying material so that when the secret key is expired, those nodes are
prepared with the new secret key. This allows the NSH imposer to switch
to the new key identifier as soon as necessary. It is
[RECOMMENDED]{.bcp14} that the next key identifier and associated keying
material be distributed by the control plane well prior to the secret
key expiration time. Additional guidance for users of AEAD functions
about rekeying can be found in
\[[AEAD-LIMITS](#I-D.irtf-cfrg-aead-limits){.xref}\].[¶](#section-9-4){.pilcrow}

The security and integrity of the key-distribution mechanism is vital to
the security of the SFC system as a whole.[¶](#section-9-5){.pilcrow}

NSH data is exposed to several threats:[¶](#section-9-6){.pilcrow}

-   [An on-path attacker modifying the NSH
    data.[¶](#section-9-7.1){.pilcrow}]{#section-9-7.1}
-   [An attacker spoofing the NSH
    data.[¶](#section-9-7.2){.pilcrow}]{#section-9-7.2}
-   [An attacker capturing and replaying the NSH
    data.[¶](#section-9-7.3){.pilcrow}]{#section-9-7.3}
-   [Data carried in Context Headers revealing privacy-sensitive
    information to
    attackers.[¶](#section-9-7.4){.pilcrow}]{#section-9-7.4}
-   [An attacker replacing the packet on which the NSH is imposed with a
    modified or bogus
    packet.[¶](#section-9-7.5){.pilcrow}]{#section-9-7.5}

In an SFC-enabled domain where the above attacks are possible, (1) NSH
data [MUST]{.bcp14} be integrity protected and replay protected, and (2)
privacy-sensitive NSH metadata [MUST]{.bcp14} be encrypted for
confidentiality preservation purposes. The Base and Service Path Headers
are not encrypted.[¶](#section-9-8){.pilcrow}

MACs with two levels of assurance are defined in [Section
5](#new){.xref}. Considerations specific to each level of assurance are
discussed in Sections [9.1](#mac1){.xref} and
[9.2](#mac2){.xref}.[¶](#section-9-9){.pilcrow}

The attacks discussed in
\[[ARCH-SFC-THREATS](#I-D.nguyen-sfc-security-architecture){.xref}\] are
handled based on the solution specified in this document, with the
exception of attacks dropping packets. Such attacks can be detected by
relying upon statistical analysis; such analysis is out of the scope of
this document. Also, if SFFs are not involved in the integrity checks, a
misbehaving SFF that decrements SI while this should be done by an SF
(SF bypass attack) will be detected by an upstream SF because the
integrity check will fail.[¶](#section-9-10){.pilcrow}

Some events are logged locally with notification alerts sent by
NSH-aware nodes to a Control Element. These events [SHOULD]{.bcp14} be
rate limited.[¶](#section-9-11){.pilcrow}

The solution specified in this document does not provide data origin
authentication.[¶](#section-9-12){.pilcrow}

In order to detect compromised nodes, it is assumed that appropriate
mechanisms to monitor and audit an SFC-enabled domain to detect
misbehavior and to deter misuse are in place. Compromised nodes can thus
be withdrawn from active service function chains using appropriate
control plane mechanisms.[¶](#section-9-13){.pilcrow}

::: {#mac1}
::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [MAC#1](#name-mac1){.section-name .selfRef} {#name-mac1}

An active attacker can potentially modify the Base Header (e.g.,
decrement the TTL so the next SFF in the SFP discards the NSH packet).
An active attacker can typically also drop NSH packets. As such, this
attack is not considered an attack against the security mechanism
specified in the document.[¶](#section-9.1-1){.pilcrow}

It is expected that specific devices in the SFC-enabled domain will be
configured such that no device other than the Classifiers (when
reclassification is enabled), NSH-aware SFs, and SFC proxies will be
able to update the integrity-protected NSH data ([Section
7.1](#gen){.xref}), and no device other than the NSH-aware SFs and SFC
proxies will be able to decrypt and update the Context Headers carrying
sensitive metadata ([Section 7.1](#gen){.xref}). In other words, it is
expected that the NSH-aware SFs and SFC proxies in the SFC-enabled
domain are considered fully trusted to act on the NSH data. Only these
elements can have access to sensitive NSH metadata and the keying
material used to integrity protect NSH data and encrypt Context
Headers.[¶](#section-9.1-2){.pilcrow}
:::
:::

::: {#mac2}
::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [MAC#2](#name-mac2){.section-name .selfRef} {#name-mac2}

SFFs can detect whether an illegitimate node has altered the content of
the Base Header. Such messages must be discarded with appropriate logs
and alarms generated (see [Section
7.1](#gen){.xref}).[¶](#section-9.2-1){.pilcrow}

Similar to [Section 9.1](#mac1){.xref}, no device other than the
NSH-aware SFs and SFC proxies in the SFC-enabled domain should be able
to decrypt and update the Context Headers carrying sensitive
metadata.[¶](#section-9.2-2){.pilcrow}
:::
:::

::: {#section-9.3 .section}
### [9.3.](#section-9.3){.section-number .selfRef} [Time Synchronization](#name-time-synchronization){.section-name .selfRef} {#name-time-synchronization}

\[[RFC8633](#RFC8633){.xref}\] describes best current practices to be
considered in deployments where SFC data plane elements use NTP for
time-synchronization purposes.[¶](#section-9.3-1){.pilcrow}

Also, a mechanism to provide cryptographic security for NTP is specified
in \[[RFC8915](#RFC8915){.xref}\].[¶](#section-9.3-2){.pilcrow}
:::
:::
:::

::: {#IANA}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

IANA has added the following types to the \"NSH IETF-Assigned Optional
Variable-Length Metadata Types\" registry (0x0000 IETF Base NSH MD
Class) at
\<<https://www.iana.org/assignments/nsh>\>.[¶](#section-10-1){.pilcrow}

[]{#name-additions-to-the-nsh-ietf-a}

  Value   Description                     Reference
  ------- ------------------------------- -----------
  0x02    MAC and Encrypted Metadata #1   RFC 9145
  0x03    MAC and Encrypted Metadata #2   RFC 9145

  : [Table 4](#table-4){.selfRef}: [Additions to the NSH IETF-Assigned
  Optional Variable-Length Metadata Types
  Registry](#name-additions-to-the-nsh-ietf-a){.selfRef}
:::
:::

::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-11.1 .section}
### [11.1.](#section-11.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[GCM\]
:   [Dworkin, M.]{.refAuthor}, [\"Recommendation for Block Cipher Modes
    of Operation: Galois/Counter Mode (GCM) and GMAC\"]{.refTitle},
    [NIST Special Publication 800-38D]{.seriesInfo}, [DOI
    10.6028/NIST.SP.800-38D]{.seriesInfo}, November 2007,
    \<<https://doi.org/10.6028/NIST.SP.800-38D>\>.
:   

\[RFC2104\]
:   [Krawczyk, H.]{.refAuthor}, [Bellare, M.]{.refAuthor}, and [R.
    Canetti]{.refAuthor}, [\"HMAC: Keyed-Hashing for Message
    Authentication\"]{.refTitle}, [RFC 2104]{.seriesInfo}, [DOI
    10.17487/RFC2104]{.seriesInfo}, February 1997,
    \<<https://www.rfc-editor.org/info/rfc2104>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC4107\]
:   [Bellovin, S.]{.refAuthor} and [R. Housley]{.refAuthor},
    [\"Guidelines for Cryptographic Key Management\"]{.refTitle}, [BCP
    107]{.seriesInfo}, [RFC 4107]{.seriesInfo}, [DOI
    10.17487/RFC4107]{.seriesInfo}, June 2005,
    \<<https://www.rfc-editor.org/info/rfc4107>\>.
:   

\[RFC4868\]
:   [Kelly, S.]{.refAuthor} and [S. Frankel]{.refAuthor}, [\"Using
    HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512 with
    IPsec\"]{.refTitle}, [RFC 4868]{.seriesInfo}, [DOI
    10.17487/RFC4868]{.seriesInfo}, May 2007,
    \<<https://www.rfc-editor.org/info/rfc4868>\>.
:   

\[RFC5116\]
:   [McGrew, D.]{.refAuthor}, [\"An Interface and Algorithms for
    Authenticated Encryption\"]{.refTitle}, [RFC 5116]{.seriesInfo},
    [DOI 10.17487/RFC5116]{.seriesInfo}, January 2008,
    \<<https://www.rfc-editor.org/info/rfc5116>\>.
:   

\[RFC7665\]
:   [Halpern, J., Ed.]{.refAuthor} and [C. Pignataro, Ed.]{.refAuthor},
    [\"Service Function Chaining (SFC) Architecture\"]{.refTitle}, [RFC
    7665]{.seriesInfo}, [DOI 10.17487/RFC7665]{.seriesInfo}, October
    2015, \<<https://www.rfc-editor.org/info/rfc7665>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8300\]
:   [Quinn, P., Ed.]{.refAuthor}, [Elzur, U., Ed.]{.refAuthor}, and [C.
    Pignataro, Ed.]{.refAuthor}, [\"Network Service Header
    (NSH)\"]{.refTitle}, [RFC 8300]{.seriesInfo}, [DOI
    10.17487/RFC8300]{.seriesInfo}, January 2018,
    \<<https://www.rfc-editor.org/info/rfc8300>\>.
:   
:::

::: {#section-11.2 .section}
### [11.2.](#section-11.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[AEAD-LIMITS\]
:   [Günther, F.]{.refAuthor}, [Thomson, M.]{.refAuthor}, and [C. A.
    Wood]{.refAuthor}, [\"Usage Limits on AEAD Algorithms\"]{.refTitle},
    [Work in Progress]{.refContent}, [Internet-Draft,
    draft-irtf-cfrg-aead-limits-03]{.seriesInfo}, 12 July 2021,
    \<<https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-aead-limits-03>\>.
:   

\[ARCH-SFC-THREATS\]
:   [THANG, N. C.]{.refAuthor} and [M. Park]{.refAuthor}, [\"A Security
    Architecture Against Service Function Chaining
    Threats\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft,
    draft-nguyen-sfc-security-architecture-00]{.seriesInfo}, 24 November
    2019,
    \<<https://datatracker.ietf.org/doc/html/draft-nguyen-sfc-security-architecture-00>\>.
:   

\[INTERNET-IP-TUNNELS\]
:   [Touch, J.]{.refAuthor} and [M. Townsley]{.refAuthor}, [\"IP Tunnels
    in the Internet Architecture\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-intarea-tunnels-10]{.seriesInfo}, 12 September 2019,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-intarea-tunnels-10>\>.
:   

\[INTERNET-THREAT-MODEL\]
:   [Arkko, J.]{.refAuthor} and [S. Farrell]{.refAuthor}, [\"Challenges
    and Changes in the Internet Threat Model\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-arkko-farrell-arch-model-t-04]{.seriesInfo}, 13 July 2020,
    \<<https://datatracker.ietf.org/doc/html/draft-arkko-farrell-arch-model-t-04>\>.
:   

\[RFC4046\]
:   [Baugher, M.]{.refAuthor}, [Canetti, R.]{.refAuthor},
    [Dondeti, L.]{.refAuthor}, and [F. Lindholm]{.refAuthor},
    [\"Multicast Security (MSEC) Group Key Management
    Architecture\"]{.refTitle}, [RFC 4046]{.seriesInfo}, [DOI
    10.17487/RFC4046]{.seriesInfo}, April 2005,
    \<<https://www.rfc-editor.org/info/rfc4046>\>.
:   

\[RFC5905\]
:   [Mills, D.]{.refAuthor}, [Martin, J., Ed.]{.refAuthor},
    [Burbank, J.]{.refAuthor}, and [W. Kasch]{.refAuthor}, [\"Network
    Time Protocol Version 4: Protocol and Algorithms
    Specification\"]{.refTitle}, [RFC 5905]{.seriesInfo}, [DOI
    10.17487/RFC5905]{.seriesInfo}, June 2010,
    \<<https://www.rfc-editor.org/info/rfc5905>\>.
:   

\[RFC6973\]
:   [Cooper, A.]{.refAuthor}, [Tschofenig, H.]{.refAuthor},
    [Aboba, B.]{.refAuthor}, [Peterson, J.]{.refAuthor},
    [Morris, J.]{.refAuthor}, [Hansen, M.]{.refAuthor}, and [R.
    Smith]{.refAuthor}, [\"Privacy Considerations for Internet
    Protocols\"]{.refTitle}, [RFC 6973]{.seriesInfo}, [DOI
    10.17487/RFC6973]{.seriesInfo}, July 2013,
    \<<https://www.rfc-editor.org/info/rfc6973>\>.
:   

\[RFC7258\]
:   [Farrell, S.]{.refAuthor} and [H. Tschofenig]{.refAuthor},
    [\"Pervasive Monitoring Is an Attack\"]{.refTitle}, [BCP
    188]{.seriesInfo}, [RFC 7258]{.seriesInfo}, [DOI
    10.17487/RFC7258]{.seriesInfo}, May 2014,
    \<<https://www.rfc-editor.org/info/rfc7258>\>.
:   

\[RFC7498\]
:   [Quinn, P., Ed.]{.refAuthor} and [T. Nadeau, Ed.]{.refAuthor},
    [\"Problem Statement for Service Function Chaining\"]{.refTitle},
    [RFC 7498]{.seriesInfo}, [DOI 10.17487/RFC7498]{.seriesInfo}, April
    2015, \<<https://www.rfc-editor.org/info/rfc7498>\>.
:   

\[RFC7635\]
:   [Reddy, T.]{.refAuthor}, [Patil, P.]{.refAuthor},
    [Ravindranath, R.]{.refAuthor}, and [J. Uberti]{.refAuthor},
    [\"Session Traversal Utilities for NAT (STUN) Extension for
    Third-Party Authorization\"]{.refTitle}, [RFC 7635]{.seriesInfo},
    [DOI 10.17487/RFC7635]{.seriesInfo}, August 2015,
    \<<https://www.rfc-editor.org/info/rfc7635>\>.
:   

\[RFC8165\]
:   [Hardie, T.]{.refAuthor}, [\"Design Considerations for Metadata
    Insertion\"]{.refTitle}, [RFC 8165]{.seriesInfo}, [DOI
    10.17487/RFC8165]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8165>\>.
:   

\[RFC8459\]
:   [Dolson, D.]{.refAuthor}, [Homma, S.]{.refAuthor},
    [Lopez, D.]{.refAuthor}, and [M. Boucadair]{.refAuthor},
    [\"Hierarchical Service Function Chaining (hSFC)\"]{.refTitle}, [RFC
    8459]{.seriesInfo}, [DOI 10.17487/RFC8459]{.seriesInfo}, September
    2018, \<<https://www.rfc-editor.org/info/rfc8459>\>.
:   

\[RFC8633\]
:   [Reilly, D.]{.refAuthor}, [Stenn, H.]{.refAuthor}, and [D.
    Sibold]{.refAuthor}, [\"Network Time Protocol Best Current
    Practices\"]{.refTitle}, [BCP 223]{.seriesInfo}, [RFC
    8633]{.seriesInfo}, [DOI 10.17487/RFC8633]{.seriesInfo}, July 2019,
    \<<https://www.rfc-editor.org/info/rfc8633>\>.
:   

\[RFC8877\]
:   [Mizrahi, T.]{.refAuthor}, [Fabini, J.]{.refAuthor}, and [A.
    Morton]{.refAuthor}, [\"Guidelines for Defining Packet
    Timestamps\"]{.refTitle}, [RFC 8877]{.seriesInfo}, [DOI
    10.17487/RFC8877]{.seriesInfo}, September 2020,
    \<<https://www.rfc-editor.org/info/rfc8877>\>.
:   

\[RFC8915\]
:   [Franke, D.]{.refAuthor}, [Sibold, D.]{.refAuthor},
    [Teichel, K.]{.refAuthor}, [Dansarie, M.]{.refAuthor}, and [R.
    Sundblad]{.refAuthor}, [\"Network Time Security for the Network Time
    Protocol\"]{.refTitle}, [RFC 8915]{.seriesInfo}, [DOI
    10.17487/RFC8915]{.seriesInfo}, September 2020,
    \<<https://www.rfc-editor.org/info/rfc8915>\>.
:   
:::
:::

::: {#appendix-A .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

This document was created as a follow-up to the discussion in IETF 104:
\<<https://datatracker.ietf.org/meeting/104/materials/slides-104-sfc-sfc-chair-slides-01>\>
(slide 7).[¶](#appendix-A-1){.pilcrow}

Thanks to [Joel Halpern]{.contact-name}, [Christian
Jacquenet]{.contact-name}, [Dirk von Hugo]{.contact-name}, [Tal
Mizrahi]{.contact-name}, [Daniel Migault]{.contact-name}, [Diego
Lopez]{.contact-name}, [Greg Mirsky]{.contact-name}, and [Dhruv
Dhody]{.contact-name} for the comments.[¶](#appendix-A-2){.pilcrow}

Many thanks to [Steve Hanna]{.contact-name} for the valuable secdir
review and [Juergen Schoenwaelder]{.contact-name} for the opsdir
review.[¶](#appendix-A-3){.pilcrow}

Thanks to [Greg Mirsky]{.contact-name} for the [Shepherd
review]{.contact-name}.[¶](#appendix-A-4){.pilcrow}

Thanks to [Alvaro Retana]{.contact-name}, [Lars Eggert]{.contact-name},
[Martin Duke]{.contact-name}, [Erik Kline]{.contact-name}, [Zaheduzzaman
Sarker]{.contact-name}, [Éric Vyncke]{.contact-name}, [Roman
Danyliw]{.contact-name}, [Murray Kucherawy]{.contact-name}, [John
Scudder]{.contact-name}, and [Benjamin Kaduk]{.contact-name} for the
IESG review.[¶](#appendix-A-5){.pilcrow}
:::

::: {#authors-addresses}
::: {#appendix-B .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Mohamed Boucadair]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Orange]{.org}
:::

::: {.left dir="auto"}
[35000]{.postal-code} [Rennes]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <mohamed.boucadair@orange.com>
:::

::: {.left dir="auto"}
[Tirumaleswar Reddy.K]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Akamai]{.org}
:::

::: {.left dir="auto"}
[Embassy Golf Link Business Park]{.street-address}
:::

::: {.left dir="auto"}
[Bangalore]{.locality} [560071]{.postal-code}
:::

::: {.left dir="auto"}
[Karnataka]{.region}
:::

::: {.left dir="auto"}
[India]{.country-name}
:::

::: email
Email: <kondtir@gmail.com>
:::

::: {.left dir="auto"}
[Dan Wing]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Citrix Systems, Inc.]{.org}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <dwing-ietf@fuggles.com>
:::
:::
:::
