  RFC 9146           DTLS 1.2 Connection ID   March 2022
  ------------------ ------------------------ ------------
  Rescorla, et al.   Standards Track          \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9146](https://www.rfc-editor.org/rfc/rfc9146){.eref}

Updates:
:   [6347](https://www.rfc-editor.org/rfc/rfc6347){.eref}

Category:
:   Standards Track

Published:
:   March 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    E. Rescorla, [Ed.]{.editor}
    :::

    ::: org
    Mozilla
    :::
    :::

    ::: author
    ::: author-name
    H. Tschofenig, [Ed.]{.editor}
    :::

    ::: org
    Arm Limited
    :::
    :::

    ::: author
    ::: author-name
    T. Fossati
    :::

    ::: org
    Arm Limited
    :::
    :::

    ::: author
    ::: author-name
    A. Kraus
    :::

    ::: org
    Bosch.IO GmbH
    :::
    :::
:::

# RFC 9146 {#rfcnum}

# Connection Identifier for DTLS 1.2 {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document specifies the Connection ID (CID) construct for the
Datagram Transport Layer Security (DTLS) protocol version
1.2.[¶](#section-abstract-1){.pilcrow}

A CID is an identifier carried in the record layer header that gives the
recipient additional information for selecting the appropriate security
association. In \"classical\" DTLS, selecting a security association of
an incoming DTLS record is accomplished with the help of the 5-tuple. If
the source IP address and/or source port changes during the lifetime of
an ongoing DTLS session, then the receiver will be unable to locate the
correct security context.[¶](#section-abstract-2){.pilcrow}

The new ciphertext record format with the CID also provides content type
encryption and record layer padding.[¶](#section-abstract-3){.pilcrow}

This document updates RFC 6347.[¶](#section-abstract-4){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9146>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}

This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November 10,
2008. The person(s) controlling the copyright in some of this material
may not have granted the IETF Trust the right to allow modifications of
such material outside the IETF Standards Process. Without obtaining an
adequate license from the person(s) controlling the copyright in such
materials, this document may not be modified outside the IETF Standards
Process, and derivative works of it may not be created outside the IETF
Standards Process, except to format it for publication as an RFC or to
translate it into languages other than
English.[¶](#section-boilerplate.2-3){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Conventions and
    Terminology](#name-conventions-and-terminology){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [The \"connection_id\"
    Extension](#name-the-connection_id-extension){.xref}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Record Layer
    Extensions](#name-record-layer-extensions){.xref}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Record Payload
    Protection](#name-record-payload-protection){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Block
        Ciphers](#name-block-ciphers){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Block Ciphers with
        Encrypt-then-MAC
        Processing](#name-block-ciphers-with-encrypt-){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [AEAD
        Ciphers](#name-aead-ciphers){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Peer Address
    Update](#name-peer-address-update){.xref}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Example](#name-example){.xref}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Privacy
    Considerations](#name-privacy-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}

    -   ::: {#section-toc.1-1.10.2.1}
        [10.1](#section-10.1){.xref}.  [Extra Column Added to the TLS
        ExtensionType Values
        Registry](#name-extra-column-added-to-the-t){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [10.2](#section-10.2){.xref}.  [New Entry in the TLS
        ExtensionType Values
        Registry](#name-new-entry-in-the-tls-extens){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.3}
        [10.3](#section-10.3){.xref}.  [New Entry in the TLS ContentType
        Registry](#name-new-entry-in-the-tls-conten){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.11.2.1}
        [11.1](#section-11.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [11.2](#section-11.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [](#appendix-A){.xref}[Acknowledgements](#name-acknowledgements){.xref}
    :::

-   ::: {#section-toc.1-1.13}
    [](#appendix-B){.xref}[Contributors](#name-contributors){.xref}
    :::

-   ::: {#section-toc.1-1.14}
    [](#appendix-C){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The Datagram Transport Layer Security (DTLS) protocol
\[[RFC6347](#RFC6347){.xref}\] was designed for securing data sent over
datagram transports (e.g., UDP). DTLS, like TLS, starts with a
handshake, which can be computationally demanding (particularly when
public key cryptography is used). After a successful handshake,
symmetric key cryptography is used to apply data origin authentication,
integrity, and confidentiality protection. This two-step approach allows
endpoints to amortize the cost of the initial handshake across
subsequent application data protection. Ideally, the second phase where
application data is protected lasts over a long period of time, since
the established keys will only need to be updated once the key lifetime
expires.[¶](#section-1-1){.pilcrow}

In DTLS as specified in RFC 6347, the IP address and port of the peer
are used to identify the DTLS association. Unfortunately, in some cases,
such as NAT rebinding, these values are insufficient. This is a
particular issue in the Internet of Things when devices enter extended
sleep periods to increase their battery lifetime. The NAT rebinding
leads to connection failure, with the resulting cost of a new
handshake.[¶](#section-1-2){.pilcrow}

This document defines an extension to DTLS 1.2 to add a Connection ID
(CID) to the DTLS record layer. The presence of the CID is negotiated
via a DTLS extension.[¶](#section-1-3){.pilcrow}

Adding a CID to the ciphertext record format presents an opportunity to
make other changes to the record format. In keeping with the best
practices established by TLS 1.3, the type of the record is encrypted,
and a mechanism is provided for adding padding to obfuscate the
plaintext length.[¶](#section-1-4){.pilcrow}
:::
:::

::: {#conventions-and-terminology}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Conventions and Terminology](#name-conventions-and-terminology){.section-name .selfRef} {#name-conventions-and-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}

This document assumes familiarity with DTLS 1.2
\[[RFC6347](#RFC6347){.xref}\]. The presentation language used in this
document is described in [Section
3](https://www.rfc-editor.org/rfc/rfc8446#section-3){.relref} of
\[[RFC8446](#RFC8446){.xref}\].[¶](#section-2-2){.pilcrow}
:::
:::

::: {#the-connectionid-extension}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [The \"connection_id\" Extension](#name-the-connection_id-extension){.section-name .selfRef} {#name-the-connection_id-extension}

This document defines the \"connection_id\" extension, which is used in
ClientHello and ServerHello messages.[¶](#section-3-1){.pilcrow}

The extension type is specified as follows.[¶](#section-3-2){.pilcrow}

::: {#section-3-3}
``` {.lang-tls-presentation .sourcecode}
  enum {
     connection_id(54), (65535)
  } ExtensionType;
```

[¶](#section-3-3){.pilcrow}
:::

The extension_data field of this extension, when included in the
ClientHello, [MUST]{.bcp14} contain the ConnectionId structure. This
structure contains the CID value the client wishes the server to use
when sending messages to the client. A zero-length CID value indicates
that the client is prepared to send using a CID but does not wish the
server to use one when sending.[¶](#section-3-4){.pilcrow}

::: {#section-3-5}
``` {.lang-tls-presentation .sourcecode}
  struct {
      opaque cid<0..2^8-1>;
  } ConnectionId;
```

[¶](#section-3-5){.pilcrow}
:::

A server willing to use CIDs will respond with a \"connection_id\"
extension in the ServerHello, containing the CID it wishes the client to
use when sending messages towards it. A zero-length value indicates that
the server will send using the client\'s CID but does not wish the
client to include a CID when sending.[¶](#section-3-6){.pilcrow}

Because each party sends the value in the \"connection_id\" extension it
wants to receive as a CID in encrypted records, it is possible for an
endpoint to use a deployment-specific constant length for such
connection identifiers. This can in turn ease parsing and connection
lookup \-- for example, by having the length in question be a
compile-time constant. Such implementations [MUST]{.bcp14} still be able
to send CIDs of different lengths to other parties. Since the CID length
information is not included in the record itself, implementations that
want to use variable-length CIDs are responsible for constructing the
CID in such a way that its length can be determined on
reception.[¶](#section-3-7){.pilcrow}

In DTLS 1.2, CIDs are exchanged at the beginning of the DTLS session
only. There is no dedicated \"CID update\" message that allows new CIDs
to be established mid-session, because DTLS 1.2 in general does not
allow TLS 1.3-style post-handshake messages that do not themselves begin
other handshakes. When a DTLS session is resumed or renegotiated, the
\"connection_id\" extension is negotiated
afresh.[¶](#section-3-8){.pilcrow}

If DTLS peers have not negotiated the use of CIDs, or a zero-length CID
has been advertised for a given direction, then the record format and
content type defined in RFC 6347 [MUST]{.bcp14} be used to send in the
indicated direction(s).[¶](#section-3-9){.pilcrow}

If DTLS peers have negotiated the use of a non-zero-length CID for a
given direction, then once encryption is enabled, they [MUST]{.bcp14}
send with the record format defined in [Figure
3](#dtls-ciphertext){.xref} (see [Section
4](#record-layer-extensions){.xref}) with the new Message Authentication
Code (MAC) computation defined in [Section 5](#mac){.xref} and the
content type tls12_cid. Plaintext payloads never use the new record
format or the CID content type.[¶](#section-3-10){.pilcrow}

When receiving, if the tls12_cid content type is set, then the CID is
used to look up the connection and the security association. If the
tls12_cid content type is not set, then the connection and the security
association are looked up by the 5-tuple and a check [MUST]{.bcp14} be
made to determine whether a non-zero-length CID is expected. If a
non-zero-length CID is expected for the retrieved association, then the
datagram [MUST]{.bcp14} be treated as invalid, as described in [Section
4.1.2.1](https://www.rfc-editor.org/rfc/rfc6347#section-4.1.2.1){.relref}
of \[[RFC6347](#RFC6347){.xref}\].[¶](#section-3-11){.pilcrow}

When receiving a datagram with the tls12_cid content type, the new MAC
computation defined in [Section 5](#mac){.xref} [MUST]{.bcp14} be used.
When receiving a datagram with the record format defined in RFC 6347,
the MAC calculation defined in [Section
4.1.2](https://www.rfc-editor.org/rfc/rfc6347#section-4.1.2){.relref} of
\[[RFC6347](#RFC6347){.xref}\] [MUST]{.bcp14} be
used.[¶](#section-3-12){.pilcrow}
:::
:::

::: {#record-layer-extensions}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Record Layer Extensions](#name-record-layer-extensions){.section-name .selfRef} {#name-record-layer-extensions}

This specification defines the CID-enhanced record layer format for DTLS
1.2, and \[[DTLS13](#I-D.ietf-tls-dtls13){.xref}\] specifies how to
carry the CID in DTLS 1.3.[¶](#section-4-1){.pilcrow}

To allow a receiver to determine whether a record has a CID or not,
connections that have negotiated this extension use a distinguished
record type tls12_cid(25). The use of this content type has the
following three implications:[¶](#section-4-2){.pilcrow}

-   [The CID field is present and contains one or more
    bytes.[¶](#section-4-3.1){.pilcrow}]{#section-4-3.1}
-   [The MAC calculation follows the process described in [Section
    5](#mac){.xref}.[¶](#section-4-3.2){.pilcrow}]{#section-4-3.2}
-   [The real content type is inside the encryption envelope, as
    described below.[¶](#section-4-3.3){.pilcrow}]{#section-4-3.3}

Plaintext records are not impacted by this extension. Hence, the format
of the DTLSPlaintext structure is left unchanged, as shown in [Figure
1](#dtls-plaintext){.xref}.[¶](#section-4-4){.pilcrow}

[]{#name-dtls-12-plaintext-record-pa}

::: {#dtls-plaintext}
::: {#section-4-5.1}
``` {.lang-tls-presentation .sourcecode}
     struct {
         ContentType type;
         ProtocolVersion version;
         uint16 epoch;
         uint48 sequence_number;
         uint16 length;
         opaque fragment[DTLSPlaintext.length];
     } DTLSPlaintext;
```
:::

[Figure 1](#figure-1){.selfRef}: [DTLS 1.2 Plaintext Record
Payload](#name-dtls-12-plaintext-record-pa){.selfRef}
:::

When CIDs are being used, the content to be sent is first wrapped along
with its content type and optional padding into a DTLSInnerPlaintext
structure. This newly introduced structure is shown in [Figure
2](#dtls-innerplaintext){.xref}.[¶](#section-4-6){.pilcrow}

[]{#name-new-dtlsinnerplaintext-payl}

::: {#dtls-innerplaintext}
::: {#section-4-7.1}
``` {.lang-tls-presentation .sourcecode}
     struct {
         opaque content[length];
         ContentType real_type;
         uint8 zeros[length_of_padding];
     } DTLSInnerPlaintext;
```
:::

[Figure 2](#figure-2){.selfRef}: [New DTLSInnerPlaintext Payload
Structure](#name-new-dtlsinnerplaintext-payl){.selfRef}
:::

[]{.break}

content:

:   Corresponds to the fragment of a given
    length.[¶](#section-4-8.2.1){.pilcrow}

:   

real_type:

:   The content type describing the cleartext
    payload.[¶](#section-4-8.4.1){.pilcrow}

:   

zeros:

:   An arbitrary-length run of zero-valued bytes may appear in the
    cleartext after the type field. This provides an opportunity for
    senders to pad any DTLS record by a chosen amount as long as the
    total stays within record size limits. See [Section
    5.4](https://www.rfc-editor.org/rfc/rfc8446#section-5.4){.relref} of
    \[[RFC8446](#RFC8446){.xref}\] for more details. (Note that the term
    TLSInnerPlaintext in RFC 8446 refers to DTLSInnerPlaintext in this
    specification.)[¶](#section-4-8.6.1){.pilcrow}

:   

The DTLSInnerPlaintext byte sequence is then encrypted. To create the
DTLSCiphertext structure shown in [Figure 3](#dtls-ciphertext){.xref},
the CID is added.[¶](#section-4-9){.pilcrow}

[]{#name-dtls-12-cid-enhanced-cipher}

::: {#dtls-ciphertext}
::: {#section-4-10.1}
``` {.lang-tls-presentation .sourcecode}
     struct {
         ContentType outer_type = tls12_cid;
         ProtocolVersion version;
         uint16 epoch;
         uint48 sequence_number;
         opaque cid[cid_length];               // New field
         uint16 length;
         opaque enc_content[DTLSCiphertext.length];
     } DTLSCiphertext;
```
:::

[Figure 3](#figure-3){.selfRef}: [DTLS 1.2 CID-Enhanced Ciphertext
Record](#name-dtls-12-cid-enhanced-cipher){.selfRef}
:::

[]{.break}

outer_type:

:   The outer content type of a DTLSCiphertext record carrying a CID is
    always set to tls12_cid(25). The real content type of the record is
    found in DTLSInnerPlaintext.real_type after
    decryption.[¶](#section-4-11.2.1){.pilcrow}

:   

cid:

:   The CID value, cid_length bytes long, as agreed at the time the
    extension has been negotiated. Recall that each peer chooses the CID
    value it will receive and use to identify the connection, so an
    implementation can choose to always receive CIDs of a fixed length.
    If, however, an implementation chooses to receive CIDs of different
    lengths, the assigned CID values must be self-delineating, since
    there is no other mechanism available to determine what connection
    (and thus, what CID length) is in
    use.[¶](#section-4-11.4.1){.pilcrow}

:   

enc_content:

:   The encrypted form of the serialized DTLSInnerPlaintext
    structure.[¶](#section-4-11.6.1){.pilcrow}

:   

All other fields are as defined in RFC 6347.[¶](#section-4-12){.pilcrow}
:::
:::

::: {#mac}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Record Payload Protection](#name-record-payload-protection){.section-name .selfRef} {#name-record-payload-protection}

Several types of ciphers have been defined for use with TLS and DTLS,
and the MAC calculations for those ciphers differ
slightly.[¶](#section-5-1){.pilcrow}

This specification modifies the MAC calculation as defined in
\[[RFC6347](#RFC6347){.xref}\] and \[[RFC7366](#RFC7366){.xref}\], as
well as the definition of the additional data used with Authenticated
Encryption with Associated Data (AEAD) ciphers provided in
\[[RFC6347](#RFC6347){.xref}\], for records with content type tls12_cid.
The modified algorithm [MUST NOT]{.bcp14} be applied to records that do
not carry a CID, i.e., records with content type other than
tls12_cid.[¶](#section-5-2){.pilcrow}

The following fields are defined in this document; all other fields are
as defined in the cited documents.[¶](#section-5-3){.pilcrow}

[]{.break}

cid:

:   Value of the negotiated CID (variable
    length).[¶](#section-5-4.2.1){.pilcrow}

:   

cid_length:

:   The length (in bytes) of the negotiated CID (one-byte
    integer).[¶](#section-5-4.4.1){.pilcrow}

:   

length_of_DTLSInnerPlaintext:

:   The length (in bytes) of the serialized DTLSInnerPlaintext (two-byte
    integer). The length [MUST NOT]{.bcp14} exceed
    2\^14.[¶](#section-5-4.6.1){.pilcrow}

:   

seq_num_placeholder:

:   8 bytes of 0xff.[¶](#section-5-4.8.1){.pilcrow}

:   

Note that \"+\" denotes concatenation.[¶](#section-5-5){.pilcrow}

::: {#block-ciphers}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Block Ciphers](#name-block-ciphers){.section-name .selfRef} {#name-block-ciphers}

The following MAC algorithm applies to block ciphers that do not use the
Encrypt-then-MAC processing described in
\[[RFC7366](#RFC7366){.xref}\].[¶](#section-5.1-1){.pilcrow}

::: {#section-5.1-2}
``` {.lang-tls-presentation .sourcecode}
    MAC(MAC_write_key,
        seq_num_placeholder +
        tls12_cid +
        cid_length +
        tls12_cid +
        DTLSCiphertext.version +
        epoch +
        sequence_number +
        cid +
        length_of_DTLSInnerPlaintext +
        DTLSInnerPlaintext.content +
        DTLSInnerPlaintext.real_type +
        DTLSInnerPlaintext.zeros
    );
```

[¶](#section-5.1-2){.pilcrow}
:::

The rationale behind this construction is to separate the MAC input for
DTLS without the connection ID from the MAC input with the connection
ID. The former always consists of a sequence number followed by some
content type other than tls12_cid; the latter always consists of the
seq_num_placeholder followed by tls12_cid. Although 2\^64-1 is
potentially a valid sequence number, tls12_cid will never be a valid
content type when the connection ID is not in use. In addition, the
epoch and sequence_number are now fed into the MAC in the same order as
they appear on the wire.[¶](#section-5.1-3){.pilcrow}
:::
:::

::: {#block-ciphers-with-encrypt-then-mac-processing}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Block Ciphers with Encrypt-then-MAC Processing](#name-block-ciphers-with-encrypt-){.section-name .selfRef} {#name-block-ciphers-with-encrypt-}

The following MAC algorithm applies to block ciphers that use the
Encrypt-then-MAC processing described in
\[[RFC7366](#RFC7366){.xref}\].[¶](#section-5.2-1){.pilcrow}

::: {#section-5.2-2}
``` {.lang-tls-presentation .sourcecode}
    MAC(MAC_write_key,
        seq_num_placeholder +
        tls12_cid +
        cid_length +
        tls12_cid +
        DTLSCiphertext.version +
        epoch +
        sequence_number +
        cid +
        DTLSCiphertext.length +
        IV +
        ENC(content + padding + padding_length)
    );
```

[¶](#section-5.2-2){.pilcrow}
:::
:::
:::

::: {#aead-ciphers}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [AEAD Ciphers](#name-aead-ciphers){.section-name .selfRef} {#name-aead-ciphers}

For ciphers utilizing AEAD, the following modification is made to the
additional data calculation.[¶](#section-5.3-1){.pilcrow}

::: {#section-5.3-2}
``` {.lang-tls-presentation .sourcecode}
    additional_data = seq_num_placeholder +
                      tls12_cid +
                      cid_length +
                      tls12_cid +
                      DTLSCiphertext.version +
                      epoch +
                      sequence_number +
                      cid +
                      length_of_DTLSInnerPlaintext;
```

[¶](#section-5.3-2){.pilcrow}
:::
:::
:::
:::
:::

::: {#peer-address-update}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Peer Address Update](#name-peer-address-update){.section-name .selfRef} {#name-peer-address-update}

When a record with a CID is received that has a source address different
from the one currently associated with the DTLS connection, the receiver
[MUST NOT]{.bcp14} replace the address it uses for sending records to
its peer with the source address specified in the received datagram,
unless the following three conditions are
met:[¶](#section-6-1){.pilcrow}

-   [The received datagram has been cryptographically verified using the
    DTLS record layer processing
    procedures.[¶](#section-6-2.1){.pilcrow}]{#section-6-2.1}
-   [The received datagram is \"newer\" (in terms of both epoch and
    sequence number) than the newest datagram received. Reordered
    datagrams that are sent prior to a change in a peer address might
    otherwise cause a valid address change to be reverted. This also
    limits the ability of an attacker to use replayed datagrams to force
    a spurious address change, which could result in denial of service.
    An attacker might be able to succeed in changing a peer address if
    they are able to rewrite source addresses and if replayed packets
    are able to arrive before any
    original.[¶](#section-6-2.2){.pilcrow}]{#section-6-2.2}
-   [There is a strategy for ensuring that the new peer address is able
    to receive and process DTLS records. No strategy is mandated by this
    specification, but see note (\*)
    below.[¶](#section-6-2.3){.pilcrow}]{#section-6-2.3}

The conditions above are necessary to protect against attacks that use
datagrams with spoofed addresses or replayed datagrams to trigger
attacks. Note that there is no requirement for the use of the
anti-replay window mechanism defined in [Section
4.1.2.6](https://www.rfc-editor.org/rfc/rfc6347#section-4.1.2.6){.relref}
of \[[RFC6347](#RFC6347){.xref}\]. Both solutions, the \"anti-replay
window\" or \"newer\" algorithm, will prevent address updates from
replay attacks while the latter will only apply to peer address updates
and the former applies to any application layer
traffic.[¶](#section-6-3){.pilcrow}

Note that datagrams that pass the DTLS cryptographic verification
procedures but do not trigger a change of peer address are still valid
DTLS records and are still to be passed to the
application.[¶](#section-6-4){.pilcrow}

(\*) Note: Application protocols that implement protection against
spoofed addresses depend on being aware of changes in peer addresses so
that they can engage the necessary mechanisms. When delivered such an
event, an address validation mechanism specific to the application layer
can be triggered \-- for example, one that is based on successful
exchange of a minimal amount of ping-pong traffic with the peer.
Alternatively, a DTLS-specific mechanism may be used, as described in
\[[DTLS-RRC](#DTLS-RRC){.xref}\].[¶](#section-6-5){.pilcrow}

DTLS implementations [MUST]{.bcp14} silently discard records with bad
MACs or that are otherwise invalid.[¶](#section-6-6){.pilcrow}
:::
:::

::: {#examples}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Example](#name-example){.section-name .selfRef} {#name-example}

[Figure 4](#dtls-example2){.xref} shows an example exchange where a CID
is used unidirectionally from the client to the server. To indicate that
a zero-length CID is present in the \"connection_id\" extension, we use
the notation \'connection_id=empty\'.[¶](#section-7-1){.pilcrow}

[]{#name-example-dtls-12-exchange-wi}

::: {#dtls-example2}
::: {#section-7-2.1 .alignLeft .art-text .artwork}
    Client                                             Server
    ------                                             ------

    ClientHello                 -------->
    (connection_id=empty)


                                <--------      HelloVerifyRequest
                                                         (cookie)

    ClientHello                 -------->
    (connection_id=empty)
    (cookie)

                                                      ServerHello
                                              (connection_id=100)
                                                      Certificate
                                                ServerKeyExchange
                                               CertificateRequest
                                <--------         ServerHelloDone

    Certificate
    ClientKeyExchange
    CertificateVerify
    [ChangeCipherSpec]
    Finished                    -------->
    <CID=100>

                                               [ChangeCipherSpec]
                                <--------                Finished


    Application Data            ========>
    <CID=100>

                                <========        Application Data

    Legend:

    <...> indicates that a connection ID is used in the record layer
    (...) indicates an extension
    [...] indicates a payload other than a handshake message
:::

[Figure 4](#figure-4){.selfRef}: [Example DTLS 1.2 Exchange with
CID](#name-example-dtls-12-exchange-wi){.selfRef}
:::

Note: In the example exchange, the CID is included in the record layer
once encryption is enabled. In DTLS 1.2, only one handshake message is
encrypted, namely the Finished message. Since the example shows how to
use the CID for payloads sent from the client to the server, only the
record layer payloads containing the Finished message or application
data include a CID.[¶](#section-7-3){.pilcrow}
:::
:::

::: {#priv-cons}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Privacy Considerations](#name-privacy-considerations){.section-name .selfRef} {#name-privacy-considerations}

The CID replaces the previously used 5-tuple and, as such, introduces an
identifier that remains persistent during the lifetime of a DTLS
connection. Every identifier introduces the risk of linkability, as
explained in \[[RFC6973](#RFC6973){.xref}\].[¶](#section-8-1){.pilcrow}

An on-path adversary observing the DTLS protocol exchanges between the
DTLS client and the DTLS server is able to link the observed payloads to
all subsequent payloads carrying the same ID pair (for bidirectional
communication). Without multihoming or mobility, the use of the CID
exposes the same information as the 5-tuple.[¶](#section-8-2){.pilcrow}

With multihoming, a passive attacker is able to correlate the
communication interaction over the two paths. The lack of a CID update
mechanism in DTLS 1.2 makes this extension unsuitable for mobility
scenarios where correlation must be considered. Deployments that use
DTLS in multihoming environments and are concerned about these aspects
[SHOULD]{.bcp14} refuse to use CIDs in DTLS 1.2 and switch to DTLS 1.3
where a CID update mechanism is provided and sequence number encryption
is available.[¶](#section-8-3){.pilcrow}

This specification introduces record padding for the CID-enhanced record
layer, which is a privacy feature not available with the original DTLS
1.2 specification. Padding allows the size of the ciphertext to be
inflated, making traffic analysis more difficult. More details about
record padding can be found in
Section [5.4](https://www.rfc-editor.org/rfc/rfc8446#section-5.4){.relref}
and
Appendix [E.3](https://www.rfc-editor.org/rfc/rfc8446#appendix-E.3){.relref}
of \[[RFC8446](#RFC8446){.xref}\].[¶](#section-8-4){.pilcrow}

Finally, endpoints can use the CID to attach arbitrary per-connection
metadata to each record they receive on a given connection. This may be
used as a mechanism to communicate per-connection information to on-path
observers. There is no straightforward way to address this concern with
CIDs that contain arbitrary values. Implementations concerned about this
aspect [SHOULD]{.bcp14} refuse to use CIDs.[¶](#section-8-5){.pilcrow}
:::
:::

::: {#sec-cons}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

An on-path adversary can create reflection attacks against third parties
because a DTLS peer has no means to distinguish a genuine address update
event (for example, due to a NAT rebinding) from one that is malicious.
This attack is of particular concern when the request is small and the
response large. See [Section 6](#peer-address-update){.xref} for more on
address updates.[¶](#section-9-1){.pilcrow}

Additionally, an attacker able to observe the data traffic exchanged
between two DTLS peers is able to replay datagrams with modified IP
addresses / port numbers.[¶](#section-9-2){.pilcrow}

The topic of peer address updates is discussed in [Section
6](#peer-address-update){.xref}.[¶](#section-9-3){.pilcrow}
:::
:::

::: {#iana-considerations}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document implements three IANA updates.[¶](#section-10-1){.pilcrow}

::: {#extra-column-to-tls-extensiontype-values-registry}
::: {#section-10.1 .section}
### [10.1.](#section-10.1){.section-number .selfRef} [Extra Column Added to the TLS ExtensionType Values Registry](#name-extra-column-added-to-the-t){.section-name .selfRef} {#name-extra-column-added-to-the-t}

IANA has added an extra column named \"DTLS-Only\" to the \"TLS
ExtensionType Values\" registry to indicate whether an extension is only
applicable to DTLS and to include this document as an additional
reference for the registry.[¶](#section-10.1-1){.pilcrow}
:::
:::

::: {#entry-to-the-tls-extensiontype-values-registry}
::: {#section-10.2 .section}
### [10.2.](#section-10.2){.section-number .selfRef} [New Entry in the TLS ExtensionType Values Registry](#name-new-entry-in-the-tls-extens){.section-name .selfRef} {#name-new-entry-in-the-tls-extens}

IANA has allocated an entry in the existing \"TLS ExtensionType Values\"
registry for connection_id(54), as described in the table below.
Although the value 53 had been allocated by early allocation for a
previous version of this document, it is incompatible with this
document. Therefore, the early allocation has been deprecated in favor
of this assignment.[¶](#section-10.2-1){.pilcrow}

::: {#iana-tls-ext-entry}
  Value   Extension Name   TLS 1.3   DTLS-Only   Recommended   Reference
  ------- ---------------- --------- ----------- ------------- -----------
  54      connection_id    CH, SH    Y           N             RFC 9146

  : [Table 1](#table-1){.selfRef}
:::

A new column, \"DTLS-Only\", has been added to the registry. The valid
entries are \"Y\" if the extension is only applicable to DTLS, \"N\"
otherwise. All the pre-existing entries are given the value
\"N\".[¶](#section-10.2-3){.pilcrow}

Note: The value \"N\" in the \"Recommended\" column is set because this
extension is intended only for specific use cases. This document
describes the behavior of this extension for DTLS 1.2 only; it is not
applicable to TLS, and its usage for DTLS 1.3 is described in
\[[DTLS13](#I-D.ietf-tls-dtls13){.xref}\].[¶](#section-10.2-4){.pilcrow}
:::
:::

::: {#entry-to-the-tls-contenttype-registry}
::: {#section-10.3 .section}
### [10.3.](#section-10.3){.section-number .selfRef} [New Entry in the TLS ContentType Registry](#name-new-entry-in-the-tls-conten){.section-name .selfRef} {#name-new-entry-in-the-tls-conten}

IANA has allocated tls12_cid(25) in the \"TLS ContentType\" registry.
The tls12_cid content type is only applicable to DTLS
1.2.[¶](#section-10.3-1){.pilcrow}
:::
:::
:::
:::

::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-11.1 .section}
### [11.1.](#section-11.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC6347\]
:   [Rescorla, E.]{.refAuthor} and [N. Modadugu]{.refAuthor},
    [\"Datagram Transport Layer Security Version 1.2\"]{.refTitle}, [RFC
    6347]{.seriesInfo}, [DOI 10.17487/RFC6347]{.seriesInfo}, January
    2012, \<<https://www.rfc-editor.org/info/rfc6347>\>.
:   

\[RFC7366\]
:   [Gutmann, P.]{.refAuthor}, [\"Encrypt-then-MAC for Transport Layer
    Security (TLS) and Datagram Transport Layer Security
    (DTLS)\"]{.refTitle}, [RFC 7366]{.seriesInfo}, [DOI
    10.17487/RFC7366]{.seriesInfo}, September 2014,
    \<<https://www.rfc-editor.org/info/rfc7366>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8446\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   
:::

::: {#section-11.2 .section}
### [11.2.](#section-11.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[DTLS-RRC\]
:   [Tschofenig, H., Ed.]{.refAuthor} and [T. Fossati]{.refAuthor},
    [\"Return Routability Check for DTLS 1.2 and DTLS 1.3\"]{.refTitle},
    [Work in Progress]{.refContent}, [Internet-Draft,
    draft-ietf-tls-dtls-rrc-05]{.seriesInfo}, 7 March 2022,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-tls-dtls-rrc-05>\>.
:   

\[DTLS13\]
:   [Rescorla, E.]{.refAuthor}, [Tschofenig, H.]{.refAuthor}, and [N.
    Modadugu]{.refAuthor}, [\"The Datagram Transport Layer Security
    (DTLS) Protocol Version 1.3\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-tls-dtls13-43]{.seriesInfo}, 30 April 2021,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-tls-dtls13-43>\>.
:   

\[RFC6973\]
:   [Cooper, A.]{.refAuthor}, [Tschofenig, H.]{.refAuthor},
    [Aboba, B.]{.refAuthor}, [Peterson, J.]{.refAuthor},
    [Morris, J.]{.refAuthor}, [Hansen, M.]{.refAuthor}, and [R.
    Smith]{.refAuthor}, [\"Privacy Considerations for Internet
    Protocols\"]{.refTitle}, [RFC 6973]{.seriesInfo}, [DOI
    10.17487/RFC6973]{.seriesInfo}, July 2013,
    \<<https://www.rfc-editor.org/info/rfc6973>\>.
:   
:::
:::

::: {#acknowledgements}
::: {#appendix-A .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

We would like to thank [Hanno Becker]{.contact-name}, [Martin
Duke]{.contact-name}, [Lars Eggert]{.contact-name}, [Ben
Kaduk]{.contact-name}, [Warren Kumari]{.contact-name}, [Francesca
Palombini]{.contact-name}, [Tom Petch]{.contact-name}, [John
Scudder]{.contact-name}, [Sean Turner]{.contact-name}, [Éric
Vyncke]{.contact-name}, and [Robert Wilton]{.contact-name} for their
review comments.[¶](#appendix-A-1){.pilcrow}

Finally, we want to thank the IETF TLS Working Group chairs, [Chris
Wood]{.contact-name}, [Joseph Salowey]{.contact-name}, and [Sean
Turner]{.contact-name}, for their patience, support, and
feedback.[¶](#appendix-A-2){.pilcrow}
:::
:::

::: {#contributors}
::: {#appendix-B .section}
## [Contributors](#name-contributors){.section-name .selfRef} {#name-contributors}

Many people have contributed to this specification, and we would like to
thank the following individuals for their
contributions:[¶](#appendix-B-1){.pilcrow}

::: {.left dir="auto"}
[Yin Xinxing]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Huawei]{.org}
:::

::: email
Email: <yinxinxing@huawei.com>
:::

::: {.left dir="auto"}
[Nikos Mavrogiannopoulos]{.fn .nameRole}
:::

::: {.left dir="auto"}
[RedHat]{.org}
:::

::: email
Email: <nmav@redhat.com>
:::

::: {.left dir="auto"}
[Tobias Gondrom]{.fn .nameRole}
:::

::: email
Email: <tobias.gondrom@gondrom.org>
:::

Additionally, we would like to thank the Connection ID task force team
members:[¶](#appendix-B-2){.pilcrow}

-   ::: {#appendix-B-3.1}
    [Martin Thomson]{.contact-name}
    (Mozilla)[¶](#appendix-B-3.1.1){.pilcrow}
    :::

-   ::: {#appendix-B-3.2}
    [Christian Huitema]{.contact-name} (Private Octopus
    Inc.)[¶](#appendix-B-3.2.1){.pilcrow}
    :::

-   ::: {#appendix-B-3.3}
    [Jana Iyengar]{.contact-name}
    (Google)[¶](#appendix-B-3.3.1){.pilcrow}
    :::

-   ::: {#appendix-B-3.4}
    [Daniel Kahn Gillmor]{.contact-name}
    (ACLU)[¶](#appendix-B-3.4.1){.pilcrow}
    :::

-   ::: {#appendix-B-3.5}
    [Patrick McManus]{.contact-name}
    (Mozilla)[¶](#appendix-B-3.5.1){.pilcrow}
    :::

-   ::: {#appendix-B-3.6}
    [Ian Swett]{.contact-name} (Google)[¶](#appendix-B-3.6.1){.pilcrow}
    :::

-   ::: {#appendix-B-3.7}
    [Mark Nottingham]{.contact-name}
    (Fastly)[¶](#appendix-B-3.7.1){.pilcrow}
    :::

The task force team discussed various design ideas, including
cryptographically generated session IDs using hash chains and public key
encryption, but dismissed them due to their inefficiency. The approach
described in this specification is the simplest possible design that
works, given the limitations of DTLS 1.2. DTLS 1.3 provides better
privacy features, and developers are encouraged to switch to the new
version of DTLS.[¶](#appendix-B-4){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-C .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Eric Rescorla ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Mozilla]{.org}
:::

::: email
Email: <ekr@rtfm.com>
:::

::: {.left dir="auto"}
[Hannes Tschofenig ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Arm Limited]{.org}
:::

::: email
Email: <hannes.tschofenig@arm.com>
:::

::: {.left dir="auto"}
[Thomas Fossati]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Arm Limited]{.org}
:::

::: email
Email: <thomas.fossati@arm.com>
:::

::: {.left dir="auto"}
[Achim Kraus]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Bosch.IO GmbH]{.org}
:::

::: email
Email: <achim.kraus@bosch.io>
:::
:::
:::
