  RFC 9124        A Firmware Manifest Information Model   January 2022
  --------------- --------------------------------------- --------------
  Moran, et al.   Informational                           \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9124](https://www.rfc-editor.org/rfc/rfc9124){.eref}

Category:
:   Informational

Published:
:   January 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    B. Moran
    :::

    ::: org
    Arm Limited
    :::
    :::

    ::: author
    ::: author-name
    H. Tschofenig
    :::

    ::: org
    Arm Limited
    :::
    :::

    ::: author
    ::: author-name
    H. Birkholz
    :::

    ::: org
    Fraunhofer SIT
    :::
    :::
:::

# RFC 9124 {#rfcnum}

# A Manifest Information Model for Firmware Updates in Internet of Things (IoT) Devices {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

Vulnerabilities with Internet of Things (IoT) devices have raised the
need for a reliable and secure firmware update mechanism that is also
suitable for constrained devices. Ensuring that devices function and
remain secure over their service lifetime requires such an update
mechanism to fix vulnerabilities, update configuration settings, and add
new functionality.[¶](#section-abstract-1){.pilcrow}

One component of such a firmware update is a concise and
machine-processable metadata document, or manifest, that describes the
firmware image(s) and offers appropriate protection. This document
describes the information that must be present in the
manifest.[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for informational
purposes.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Not all documents approved
by the IESG are candidates for any level of Internet Standard; see
Section 2 of RFC 7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9124>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Requirements and
    Terminology](#name-requirements-and-terminolog){.xref}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Requirements
        Notation](#name-requirements-notation){.xref}
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [Terminology](#name-terminology){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Manifest Information
    Elements](#name-manifest-information-elemen){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Version ID of the Manifest
        Structure](#name-version-id-of-the-manifest-){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Monotonic Sequence
        Number](#name-monotonic-sequence-number){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Vendor ID](#name-vendor-id){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [Class ID](#name-class-id){.xref}

        -   ::: {#section-toc.1-1.3.2.4.2.1}
            [3.4.1](#section-3.4.1){.xref}.  [Example 1: Different
            Classes](#name-example-1-different-classes){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.4.2.2}
            [3.4.2](#section-3.4.2){.xref}.  [Example 2: Upgrading Class
            ID](#name-example-2-upgrading-class-i){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.4.2.3}
            [3.4.3](#section-3.4.3){.xref}.  [Example 3: Shared
            Functionality](#name-example-3-shared-functional){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.4.2.4}
            [3.4.4](#section-3.4.4){.xref}.  [Example 4:
            Rebranding](#name-example-4-rebranding){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.5}
        [3.5](#section-3.5){.xref}.  [Precursor Image Digest
        Condition](#name-precursor-image-digest-cond){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.6}
        [3.6](#section-3.6){.xref}.  [Required Image Version
        List](#name-required-image-version-list){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.7}
        [3.7](#section-3.7){.xref}.  [Expiration
        Time](#name-expiration-time){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.8}
        [3.8](#section-3.8){.xref}.  [Payload
        Format](#name-payload-format){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.9}
        [3.9](#section-3.9){.xref}.  [Processing
        Steps](#name-processing-steps){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.10}
        [3.10](#section-3.10){.xref}. [Storage
        Location](#name-storage-location){.xref}

        -   ::: {#section-toc.1-1.3.2.10.2.1}
            [3.10.1](#section-3.10.1){.xref}.  [Example 1: Two Storage
            Locations](#name-example-1-two-storage-locat){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.10.2.2}
            [3.10.2](#section-3.10.2){.xref}.  [Example 2:
            Filesystem](#name-example-2-filesystem){.xref}
            :::

        -   ::: {#section-toc.1-1.3.2.10.2.3}
            [3.10.3](#section-3.10.3){.xref}.  [Example 3: Flash
            Memory](#name-example-3-flash-memory){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.11}
        [3.11](#section-3.11){.xref}. [Component
        Identifier](#name-component-identifier){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.12}
        [3.12](#section-3.12){.xref}. [Payload
        Indicator](#name-payload-indicator){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.13}
        [3.13](#section-3.13){.xref}. [Payload
        Digests](#name-payload-digests){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.14}
        [3.14](#section-3.14){.xref}. [Size](#name-size){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.15}
        [3.15](#section-3.15){.xref}. [Manifest Envelope Element:
        Signature](#name-manifest-envelope-element-s){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.16}
        [3.16](#section-3.16){.xref}. [Additional Installation
        Instructions](#name-additional-installation-ins){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.17}
        [3.17](#section-3.17){.xref}. [Manifest Text
        Information](#name-manifest-text-information){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.18}
        [3.18](#section-3.18){.xref}. [Aliases](#name-aliases){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.19}
        [3.19](#section-3.19){.xref}. [Dependencies](#name-dependencies){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.20}
        [3.20](#section-3.20){.xref}. [Encryption
        Wrapper](#name-encryption-wrapper){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.21}
        [3.21](#section-3.21){.xref}. [XIP
        Address](#name-xip-address){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.22}
        [3.22](#section-3.22){.xref}. [Load-Time
        Metadata](#name-load-time-metadata){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.23}
        [3.23](#section-3.23){.xref}. [Runtime
        Metadata](#name-runtime-metadata){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.24}
        [3.24](#section-3.24){.xref}. [Payload](#name-payload){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.25}
        [3.25](#section-3.25){.xref}. [Manifest Envelope Element:
        Delegation Chain](#name-manifest-envelope-element-d){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Threat
        Model](#name-threat-model){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Threat
        Descriptions](#name-threat-descriptions){.xref}

        -   ::: {#section-toc.1-1.4.2.2.2.1}
            [4.2.1](#section-4.2.1){.xref}.  [THREAT.IMG.EXPIRED: Old
            Firmware](#name-threatimgexpired-old-firmwa){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.2}
            [4.2.2](#section-4.2.2){.xref}.  [THREAT.IMG.EXPIRED.OFFLINE:
            Offline Device + Old
            Firmware](#name-threatimgexpiredoffline-off){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.3}
            [4.2.3](#section-4.2.3){.xref}.  [THREAT.IMG.INCOMPATIBLE:
            Mismatched
            Firmware](#name-threatimgincompatible-misma){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.4}
            [4.2.4](#section-4.2.4){.xref}.  [THREAT.IMG.FORMAT: The
            Target Device Misinterprets the Type of
            Payload](#name-threatimgformat-the-target-){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.5}
            [4.2.5](#section-4.2.5){.xref}.  [THREAT.IMG.LOCATION: The
            Target Device Installs the Payload to the Wrong
            Location](#name-threatimglocation-the-targe){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.6}
            [4.2.6](#section-4.2.6){.xref}.  [THREAT.NET.REDIRECT:
            Redirection to Inauthentic Payload
            Hosting](#name-threatnetredirect-redirecti){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.7}
            [4.2.7](#section-4.2.7){.xref}.  [THREAT.NET.ONPATH: Traffic
            Interception](#name-threatnetonpath-traffic-int){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.8}
            [4.2.8](#section-4.2.8){.xref}.  [THREAT.IMG.REPLACE:
            Payload
            Replacement](#name-threatimgreplace-payload-re){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.9}
            [4.2.9](#section-4.2.9){.xref}.  [THREAT.IMG.NON_AUTH:
            Unauthenticated
            Images](#name-threatimgnon_auth-unauthent){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.10}
            [4.2.10](#section-4.2.10){.xref}. [THREAT.UPD.WRONG_PRECURSOR:
            Unexpected Precursor
            Images](#name-threatupdwrong_precursor-un){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.11}
            [4.2.11](#section-4.2.11){.xref}. [THREAT.UPD.UNAPPROVED:
            Unapproved
            Firmware](#name-threatupdunapproved-unappro){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.12}
            [4.2.12](#section-4.2.12){.xref}. [THREAT.IMG.DISCLOSURE:
            Reverse Engineering of Firmware Image for Vulnerability
            Analysis](#name-threatimgdisclosure-reverse){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.13}
            [4.2.13](#section-4.2.13){.xref}. [THREAT.MFST.OVERRIDE:
            Overriding Critical Manifest
            Elements](#name-threatmfstoverride-overridi){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.14}
            [4.2.14](#section-4.2.14){.xref}. [THREAT.MFST.EXPOSURE:
            Confidential Manifest Element
            Exposure](#name-threatmfstexposure-confiden){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.15}
            [4.2.15](#section-4.2.15){.xref}. [THREAT.IMG.EXTRA: Extra
            Data after Image](#name-threatimgextra-extra-data-a){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.16}
            [4.2.16](#section-4.2.16){.xref}. [THREAT.KEY.EXPOSURE:
            Exposure of Signing
            Keys](#name-threatkeyexposure-exposure-){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.17}
            [4.2.17](#section-4.2.17){.xref}. [THREAT.MFST.MODIFICATION:
            Modification of Manifest or Payload prior to
            Signing](#name-threatmfstmodification-modi){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.18}
            [4.2.18](#section-4.2.18){.xref}. [THREAT.MFST.TOCTOU:
            Modification of Manifest between Authentication and
            Use](#name-threatmfsttoctou-modificati){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Security
        Requirements](#name-security-requirements){.xref}

        -   ::: {#section-toc.1-1.4.2.3.2.1}
            [4.3.1](#section-4.3.1){.xref}.  [REQ.SEC.SEQUENCE:
            Monotonic Sequence
            Numbers](#name-reqsecsequence-monotonic-se){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.2}
            [4.3.2](#section-4.3.2){.xref}.  [REQ.SEC.COMPATIBLE:
            Vendor, Device-Type
            Identifiers](#name-reqseccompatible-vendor-dev){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.3}
            [4.3.3](#section-4.3.3){.xref}.  [REQ.SEC.EXP: Expiration
            Time](#name-reqsecexp-expiration-time){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.4}
            [4.3.4](#section-4.3.4){.xref}.  [REQ.SEC.AUTHENTIC:
            Cryptographic
            Authenticity](#name-reqsecauthentic-cryptograph){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.5}
            [4.3.5](#section-4.3.5){.xref}.  [REQ.SEC.AUTH.IMG_TYPE:
            Authenticated Payload
            Type](#name-reqsecauthimg_type-authenti){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.6}
            [4.3.6](#section-4.3.6){.xref}.  [REQ.SEC.AUTH.IMG_LOC:
            Authenticated Storage
            Location](#name-reqsecauthimg_loc-authentic){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.7}
            [4.3.7](#section-4.3.7){.xref}.  [REQ.SEC.AUTH.REMOTE_LOC:
            Authenticated Remote
            Payload](#name-reqsecauthremote_loc-authen){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.8}
            [4.3.8](#section-4.3.8){.xref}.  [REQ.SEC.AUTH.EXEC: Secure
            Execution](#name-reqsecauthexec-secure-execu){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.9}
            [4.3.9](#section-4.3.9){.xref}.  [REQ.SEC.AUTH.PRECURSOR:
            Authenticated Precursor
            Images](#name-reqsecauthprecursor-authent){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.10}
            [4.3.10](#section-4.3.10){.xref}. [REQ.SEC.AUTH.COMPATIBILITY:
            Authenticated Vendor and Class
            IDs](#name-reqsecauthcompatibility-aut){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.11}
            [4.3.11](#section-4.3.11){.xref}. [REQ.SEC.RIGHTS: Rights
            Require
            Authenticity](#name-reqsecrights-rights-require){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.12}
            [4.3.12](#section-4.3.12){.xref}. [REQ.SEC.IMG.CONFIDENTIALITY:
            Payload
            Encryption](#name-reqsecimgconfidentiality-pa){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.13}
            [4.3.13](#section-4.3.13){.xref}. [REQ.SEC.ACCESS_CONTROL:
            Access Control](#name-reqsecaccess_control-access){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.14}
            [4.3.14](#section-4.3.14){.xref}. [REQ.SEC.MFST.CONFIDENTIALITY:
            Encrypted
            Manifests](#name-reqsecmfstconfidentiality-e){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.15}
            [4.3.15](#section-4.3.15){.xref}. [REQ.SEC.IMG.COMPLETE_DIGEST:
            Whole Image
            Digest](#name-reqsecimgcomplete_digest-wh){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.16}
            [4.3.16](#section-4.3.16){.xref}. [REQ.SEC.REPORTING: Secure
            Reporting](#name-reqsecreporting-secure-repo){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.17}
            [4.3.17](#section-4.3.17){.xref}. [REQ.SEC.KEY.PROTECTION:
            Protected Storage of Signing
            Keys](#name-reqseckeyprotection-protect){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.18}
            [4.3.18](#section-4.3.18){.xref}. [REQ.SEC.KEY.ROTATION:
            Protected Storage of Signing
            Keys](#name-reqseckeyrotation-protected){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.19}
            [4.3.19](#section-4.3.19){.xref}. [REQ.SEC.MFST.CHECK:
            Validate Manifests prior to
            Deployment](#name-reqsecmfstcheck-validate-ma){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.20}
            [4.3.20](#section-4.3.20){.xref}. [REQ.SEC.MFST.TRUSTED:
            Construct Manifests in a Trusted
            Environment](#name-reqsecmfsttrusted-construct){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.21}
            [4.3.21](#section-4.3.21){.xref}. [REQ.SEC.MFST.CONST:
            Manifest Kept Immutable between Check and
            Use](#name-reqsecmfstconst-manifest-ke){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [User
        Stories](#name-user-stories){.xref}

        -   ::: {#section-toc.1-1.4.2.4.2.1}
            [4.4.1](#section-4.4.1){.xref}.  [USER_STORY.INSTALL.INSTRUCTIONS:
            Installation
            Instructions](#name-user_storyinstallinstructio){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.2}
            [4.4.2](#section-4.4.2){.xref}.  [USER_STORY.MFST.FAIL_EARLY:
            Fail Early](#name-user_storymfstfail_early-fa){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.3}
            [4.4.3](#section-4.4.3){.xref}.  [USER_STORY.OVERRIDE:
            Override Non-critical Manifest
            Elements](#name-user_storyoverride-override){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.4}
            [4.4.4](#section-4.4.4){.xref}.  [USER_STORY.COMPONENT:
            Component Update](#name-user_storycomponent-compone){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.5}
            [4.4.5](#section-4.4.5){.xref}.  [USER_STORY.MULTI_AUTH:
            Multiple
            Authorizations](#name-user_storymulti_auth-multip){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.6}
            [4.4.6](#section-4.4.6){.xref}.  [USER_STORY.IMG.FORMAT:
            Multiple Payload
            Formats](#name-user_storyimgformat-multipl){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.7}
            [4.4.7](#section-4.4.7){.xref}.  [USER_STORY.IMG.CONFIDENTIALITY:
            Prevent Confidential Information
            Disclosures](#name-user_storyimgconfidentialit){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.8}
            [4.4.8](#section-4.4.8){.xref}.  [USER_STORY.IMG.UNKNOWN_FORMAT:
            Prevent Devices from Unpacking Unknown
            Formats](#name-user_storyimgunknown_format){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.9}
            [4.4.9](#section-4.4.9){.xref}.  [USER_STORY.IMG.CURRENT_VERSION:
            Specify Version Numbers of Target
            Firmware](#name-user_storyimgcurrent_versio){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.10}
            [4.4.10](#section-4.4.10){.xref}. [USER_STORY.IMG.SELECT:
            Enable Devices to Choose between
            Images](#name-user_storyimgselect-enable-){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.11}
            [4.4.11](#section-4.4.11){.xref}. [USER_STORY.EXEC.MFST:
            Secure Execution Using
            Manifests](#name-user_storyexecmfst-secure-e){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.12}
            [4.4.12](#section-4.4.12){.xref}. [USER_STORY.EXEC.DECOMPRESS:
            Decompress on
            Load](#name-user_storyexecdecompress-de){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.13}
            [4.4.13](#section-4.4.13){.xref}. [USER_STORY.MFST.IMG:
            Payload in
            Manifest](#name-user_storymfstimg-payload-i){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.14}
            [4.4.14](#section-4.4.14){.xref}. [USER_STORY.MFST.PARSE:
            Simple Parsing](#name-user_storymfstparse-simple-){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.15}
            [4.4.15](#section-4.4.15){.xref}. [USER_STORY.MFST.DELEGATION:
            Delegated Authority in
            Manifest](#name-user_storymfstdelegation-de){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.16}
            [4.4.16](#section-4.4.16){.xref}. [USER_STORY.MFST.PRE_CHECK:
            Update Evaluation](#name-user_storymfstpre_check-upd){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.17}
            [4.4.17](#section-4.4.17){.xref}. [USER_STORY.MFST.ADMINISTRATION:
            Administration of
            Manifests](#name-user_storymfstadministratio){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [Usability
        Requirements](#name-usability-requirements){.xref}

        -   ::: {#section-toc.1-1.4.2.5.2.1}
            [4.5.1](#section-4.5.1){.xref}.  [REQ.USE.MFST.PRE_CHECK:
            Pre-installation
            Checks](#name-requsemfstpre_check-pre-ins){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.2}
            [4.5.2](#section-4.5.2){.xref}.  [REQ.USE.MFST.TEXT:
            Descriptive Manifest
            Information](#name-requsemfsttext-descriptive-){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.3}
            [4.5.3](#section-4.5.3){.xref}.  [REQ.USE.MFST.OVERRIDE_REMOTE:
            Override Remote Resource
            Location](#name-requsemfstoverride_remote-o){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.4}
            [4.5.4](#section-4.5.4){.xref}.  [REQ.USE.MFST.COMPONENT:
            Component Updates](#name-requsemfstcomponent-compone){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.5}
            [4.5.5](#section-4.5.5){.xref}.  [REQ.USE.MFST.MULTI_AUTH:
            Multiple
            Authentications](#name-requsemfstmulti_auth-multip){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.6}
            [4.5.6](#section-4.5.6){.xref}.  [REQ.USE.IMG.FORMAT: Format
            Usability](#name-requseimgformat-format-usab){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.7}
            [4.5.7](#section-4.5.7){.xref}.  [REQ.USE.IMG.NESTED: Nested
            Formats](#name-requseimgnested-nested-form){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.8}
            [4.5.8](#section-4.5.8){.xref}.  [REQ.USE.IMG.VERSIONS:
            Target Version
            Matching](#name-requseimgversions-target-ve){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.9}
            [4.5.9](#section-4.5.9){.xref}.  [REQ.USE.IMG.SELECT: Select
            Image by
            Destination](#name-requseimgselect-select-imag){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.10}
            [4.5.10](#section-4.5.10){.xref}. [REQ.USE.EXEC: Executable
            Manifest](#name-requseexec-executable-manif){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.11}
            [4.5.11](#section-4.5.11){.xref}. [REQ.USE.LOAD: Load-Time
            Information](#name-requseload-load-time-inform){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.12}
            [4.5.12](#section-4.5.12){.xref}. [REQ.USE.PAYLOAD: Payload
            in Manifest
            Envelope](#name-requsepayload-payload-in-ma){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.13}
            [4.5.13](#section-4.5.13){.xref}. [REQ.USE.PARSE: Simple
            Parsing](#name-requseparse-simple-parsing){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.14}
            [4.5.14](#section-4.5.14){.xref}. [REQ.USE.DELEGATION:
            Delegation of Authority in
            Manifest](#name-requsedelegation-delegation){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [](#appendix-A){.xref}[Acknowledgements](#name-acknowledgements){.xref}
    :::

-   ::: {#section-toc.1-1.8}
    [](#appendix-B){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Vulnerabilities with Internet of Things (IoT) devices have raised the
need for a reliable and secure firmware update mechanism that is also
suitable for constrained devices. Ensuring that devices function and
remain secure over their service lifetime requires such an update
mechanism to fix vulnerabilities, update configuration settings, and add
new functionality.[¶](#section-1-1){.pilcrow}

One component of such a firmware update is a concise and
machine-processable metadata document, or manifest, that describes the
firmware image(s) and offers appropriate protection. This document
describes the information that must be present in the
manifest.[¶](#section-1-2){.pilcrow}

This document describes all the information elements required in a
manifest to secure firmware updates of IoT devices. Each information
element is motivated by user stories and threats it aims to mitigate.
These threats and user stories are not intended to be an exhaustive list
of the threats against IoT devices and possible user stories that
describe how to conduct a firmware update. Instead, they are intended to
describe the threats against firmware updates in isolation and provide
sufficient motivation to specify the information elements that cover a
wide range of user stories.[¶](#section-1-3){.pilcrow}

To distinguish information elements from their encoding and
serialization over the wire, this document presents an information
model. RFC 3444 \[[RFC3444](#RFC3444){.xref}\] describes the differences
between information models and data models.[¶](#section-1-4){.pilcrow}

Because this document covers a wide range of user stories and a wide
range of threats, not all information elements apply to all scenarios.
As a result, various information elements are optional to implement and
optional to use, depending on which threats exist in a particular domain
of application and which user stories are important for
deployments.[¶](#section-1-5){.pilcrow}
:::
:::

::: {#requirements-and-terminology}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Requirements and Terminology](#name-requirements-and-terminolog){.section-name .selfRef} {#name-requirements-and-terminolog}

::: {#requirements-notation}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Requirements Notation](#name-requirements-notation){.section-name .selfRef} {#name-requirements-notation}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2.1-1){.pilcrow}

Unless otherwise stated, these words apply to the design of the manifest
format, not its implementation or application. Hence, whenever an
information element is declared as \"[REQUIRED]{.bcp14}\", this implies
that the manifest format document has to include support for
it.[¶](#section-2.1-2){.pilcrow}
:::
:::

::: {#terminology}
::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

This document uses terms defined in \[[RFC9019](#RFC9019){.xref}\]. The
term \"Operator\" refers to either a device operator or a network
operator.[¶](#section-2.2-1){.pilcrow}

\"Secure time\" and \"secure clock\" refer to a set of requirements on
time sources. For local time sources, this primarily means that the
clock must be monotonically increasing, including across power cycles,
firmware updates, etc. For remote time sources, the provided time must
be both authenticated and guaranteed to be correct to within some
predetermined bounds, whenever the time source is
accessible.[¶](#section-2.2-2){.pilcrow}

The term \"Envelope\" (or \"Manifest Envelope\") is used to describe an
encoding that allows the bundling of a manifest with related information
elements that are not directly contained within the
manifest.[¶](#section-2.2-3){.pilcrow}

The term \"payload\" is used to describe the data that is delivered to a
device during an update. This is distinct from a \"firmware image\", as
described in \[[RFC9019](#RFC9019){.xref}\], because the payload is
often in an intermediate state, such as being encrypted, compressed,
and/or encoded as a differential update. The payload, taken in
isolation, is often not the final firmware
image.[¶](#section-2.2-4){.pilcrow}
:::
:::
:::
:::

::: {#manifest-information-elements}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Manifest Information Elements](#name-manifest-information-elemen){.section-name .selfRef} {#name-manifest-information-elemen}

Each manifest information element is anchored in a security requirement
or a usability requirement. The manifest elements are described below,
justified by their requirements.[¶](#section-3-1){.pilcrow}

::: {#element-version-id}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Version ID of the Manifest Structure](#name-version-id-of-the-manifest-){.section-name .selfRef} {#name-version-id-of-the-manifest-}

This is an identifier that describes which iteration of the manifest
format is contained in the structure. This allows devices to identify
the version of the manifest data model that is in
use.[¶](#section-3.1-1){.pilcrow}

This element is [REQUIRED]{.bcp14}.[¶](#section-3.1-2){.pilcrow}
:::
:::

::: {#element-sequence-number}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Monotonic Sequence Number](#name-monotonic-sequence-number){.section-name .selfRef} {#name-monotonic-sequence-number}

This element provides a monotonically increasing (unsigned) sequence
number to prevent malicious actors from reverting a firmware update
against the policies of the relevant authority. This number must not
wrap around.[¶](#section-3.2-1){.pilcrow}

For convenience, the monotonic sequence number may be a UTC timestamp.
This allows global synchronization of sequence numbers without any
additional management.[¶](#section-3.2-2){.pilcrow}

This element is [REQUIRED]{.bcp14}.[¶](#section-3.2-3){.pilcrow}

[]{.break}

Implements:
:   [REQ.SEC.SEQUENCE](#req-sec-sequence){.xref} ([Section
    4.3.1](#req-sec-sequence){.xref})[¶](#section-3.2-4.2){.pilcrow}
:   
:::
:::

::: {#element-vendor-id}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Vendor ID](#name-vendor-id){.section-name .selfRef} {#name-vendor-id}

The Vendor ID element helps to distinguish between identically named
products from different vendors. The Vendor ID is not intended to be a
human-readable element. It is intended for binary match/mismatch
comparison only.[¶](#section-3.3-1){.pilcrow}

Recommended practice is to use version 5 Universally Unique Identifiers
(UUIDs) \[[RFC4122](#RFC4122){.xref}\] with the vendor\'s domain name
and the DNS name space ID. Other options include type 1 and type 4
UUIDs.[¶](#section-3.3-2){.pilcrow}

Fixed-size binary identifiers are preferred because they are simple to
match, unambiguous in length, explicitly non-parsable, and require no
issuing authority. Guaranteed unique integers are preferred because they
are small and simple to match; however, they may not be fixed length,
and they may require an issuing authority to ensure uniqueness.
Free-form text is avoided because it is variable length, prone to error,
and often requires parsing outside the scope of the manifest
serialization.[¶](#section-3.3-3){.pilcrow}

If human-readable content is required, it [SHOULD]{.bcp14} be contained
in a separate manifest information element: [Manifest Text
Information](#manifest-element-text){.xref} ([Section
3.17](#manifest-element-text){.xref}).[¶](#section-3.3-4){.pilcrow}

This element is [RECOMMENDED]{.bcp14}.[¶](#section-3.3-5){.pilcrow}

[]{.break}

Implements:
:   [REQ.SEC.COMPATIBLE](#req-sec-compatible){.xref} ([Section
    4.3.2](#req-sec-compatible){.xref}),
    [REQ.SEC.AUTH.COMPATIBILITY](#req-sec-authentic-compatibility){.xref}
    ([Section
    4.3.10](#req-sec-authentic-compatibility){.xref})[¶](#section-3.3-6.2){.pilcrow}
:   

Here is an example for a domain-name-based UUID. Vendor A creates a UUID
based on a domain name it controls, such as vendorId = UUID5(DNS,
\"vendor-a.example\").[¶](#section-3.3-7){.pilcrow}

Because the DNS infrastructure prevents multiple registrations of the
same domain name, this UUID is (with very high probability) guaranteed
to be unique. Because the domain name is known, this UUID is
reproducible. Type 1 and type 4 UUIDs produce similar guarantees of
uniqueness, but not reproducibility.[¶](#section-3.3-8){.pilcrow}

This approach creates a contention when a vendor changes its name or
relinquishes control of a domain name. In this scenario, it is possible
that another vendor would start using that same domain name. However,
this UUID is not proof of identity; a device\'s trust in a vendor must
be anchored in a cryptographic key, not a
UUID.[¶](#section-3.3-9){.pilcrow}
:::
:::

::: {#element-class-id}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [Class ID](#name-class-id){.section-name .selfRef} {#name-class-id}

A device \"Class\" is a set of different device types that can accept
the same firmware update without modification. It thereby allows devices
to determine the applicability of the firmware in an unambiguous way.
Class IDs must be unique within the scope of a Vendor ID. This is to
prevent similarly or identically named devices from colliding in their
customer\'s infrastructure.[¶](#section-3.4-1){.pilcrow}

Recommended practice is to use version 5 UUIDs
\[[RFC4122](#RFC4122){.xref}\] with as much information as necessary to
define firmware compatibility. Possible information used to derive the
Class ID UUID includes:[¶](#section-3.4-2){.pilcrow}

-   [Model name or
    number[¶](#section-3.4-3.1){.pilcrow}]{#section-3.4-3.1}
-   [Hardware revision[¶](#section-3.4-3.2){.pilcrow}]{#section-3.4-3.2}
-   [Runtime library
    version[¶](#section-3.4-3.3){.pilcrow}]{#section-3.4-3.3}
-   [Bootloader
    version[¶](#section-3.4-3.4){.pilcrow}]{#section-3.4-3.4}
-   [ROM revision[¶](#section-3.4-3.5){.pilcrow}]{#section-3.4-3.5}
-   [Silicon batch
    number[¶](#section-3.4-3.6){.pilcrow}]{#section-3.4-3.6}

The Class ID UUID should use the Vendor ID as the name space identifier.
Classes may be more fine-grained than is required to identify firmware
compatibility. Classes must not be less granular than is required to
identify firmware compatibility. Devices may have multiple Class
IDs.[¶](#section-3.4-4){.pilcrow}

The Class ID is not intended to be a human-readable element. It is
intended for binary match/mismatch comparison only. A manifest
serialization [SHOULD NOT]{.bcp14} permit free-form text content to be
used for the Class ID. A fixed-size binary identifier [SHOULD]{.bcp14}
be used.[¶](#section-3.4-5){.pilcrow}

Some organizations desire to keep the same product naming across
multiple, incompatible hardware revisions for ease of user experience.
If this naming is propagated into the firmware, then matching a specific
hardware version becomes a challenge. An opaque, non-readable binary
identifier has no naming implications and so is more likely to be usable
for distinguishing among incompatible device groupings, regardless of
naming.[¶](#section-3.4-6){.pilcrow}

Fixed-size binary identifiers are preferred because they are simple to
match, unambiguous in length, opaque and free from naming implications,
and explicitly non-parsable. Free-form text is avoided because it is
variable length, prone to error, often requires parsing outside the
scope of the manifest serialization, and may be homogenized across
incompatible device groupings.[¶](#section-3.4-7){.pilcrow}

If the Class ID is not implemented, then each logical device class must
use a unique trust anchor for
authorization.[¶](#section-3.4-8){.pilcrow}

This element is [RECOMMENDED]{.bcp14}.[¶](#section-3.4-9){.pilcrow}

[]{.break}

Implements:
:   [REQ.SEC.COMPATIBLE](#req-sec-compatible){.xref} ([Section
    4.3.2](#req-sec-compatible){.xref}),
    [REQ.SEC.AUTH.COMPATIBILITY](#req-sec-authentic-compatibility){.xref}
    ([Section
    4.3.10](#req-sec-authentic-compatibility){.xref})[¶](#section-3.4-10.2){.pilcrow}
:   

::: {#example-1-different-classes}
::: {#section-3.4.1 .section}
#### [3.4.1.](#section-3.4.1){.section-number .selfRef} [Example 1: Different Classes](#name-example-1-different-classes){.section-name .selfRef} {#name-example-1-different-classes}

Vendor A creates Product Z and Product Y. The firmware images of
Products Z and Y are not interchangeable. Vendor A creates UUIDs as
follows:[¶](#section-3.4.1-1){.pilcrow}

-   [vendorId = UUID5(DNS,
    \"vendor-a.example\")[¶](#section-3.4.1-2.1){.pilcrow}]{#section-3.4.1-2.1}
-   [ZclassId = UUID5(vendorId, \"Product
    Z\")[¶](#section-3.4.1-2.2){.pilcrow}]{#section-3.4.1-2.2}
-   [YclassId = UUID5(vendorId, \"Product
    Y\")[¶](#section-3.4.1-2.3){.pilcrow}]{#section-3.4.1-2.3}

This ensures that Vendor A\'s Product Z cannot install firmware for
Product Y and Product Y cannot install firmware for Product
Z.[¶](#section-3.4.1-3){.pilcrow}
:::
:::

::: {#example-2-upgrading-class-id}
::: {#section-3.4.2 .section}
#### [3.4.2.](#section-3.4.2){.section-number .selfRef} [Example 2: Upgrading Class ID](#name-example-2-upgrading-class-i){.section-name .selfRef} {#name-example-2-upgrading-class-i}

Vendor A creates Product X. Later, Vendor A adds a new feature to
Product X, creating Product X v2. Product X requires a firmware update
to work with firmware intended for Product X
v2.[¶](#section-3.4.2-1){.pilcrow}

Vendor A creates UUIDs as follows:[¶](#section-3.4.2-2){.pilcrow}

-   [vendorId = UUID5(DNS,
    \"vendor-a.example\")[¶](#section-3.4.2-3.1){.pilcrow}]{#section-3.4.2-3.1}
-   [XclassId = UUID5(vendorId, \"Product
    X\")[¶](#section-3.4.2-3.2){.pilcrow}]{#section-3.4.2-3.2}
-   [Xv2classId = UUID5(vendorId, \"Product X
    v2\")[¶](#section-3.4.2-3.3){.pilcrow}]{#section-3.4.2-3.3}

When Product X receives the firmware update necessary to be compatible
with Product X v2, part of the firmware update changes the Class ID to
Xv2classId.[¶](#section-3.4.2-4){.pilcrow}
:::
:::

::: {#example-3-shared-functionality}
::: {#section-3.4.3 .section}
#### [3.4.3.](#section-3.4.3){.section-number .selfRef} [Example 3: Shared Functionality](#name-example-3-shared-functional){.section-name .selfRef} {#name-example-3-shared-functional}

Vendor A produces two products: Product X and Product Y. These
components share a common core (such as an operating system (OS)) but
have different applications. The common core and the applications can be
updated independently. To enable X and Y to receive the same common core
update, they require the same Class ID. To ensure that only Product X
receives Application X and only Product Y receives Application Y,
Product X and Product Y must have different Class IDs. The vendor
creates Class IDs as follows:[¶](#section-3.4.3-1){.pilcrow}

-   [vendorId = UUID5(DNS,
    \"vendor-a.example\")[¶](#section-3.4.3-2.1){.pilcrow}]{#section-3.4.3-2.1}
-   [XclassId = UUID5(vendorId, \"Product
    X\")[¶](#section-3.4.3-2.2){.pilcrow}]{#section-3.4.3-2.2}
-   [YclassId = UUID5(vendorId, \"Product
    Y\")[¶](#section-3.4.3-2.3){.pilcrow}]{#section-3.4.3-2.3}
-   [CommonClassId = UUID5(vendorId, \"common
    core\")[¶](#section-3.4.3-2.4){.pilcrow}]{#section-3.4.3-2.4}

Product X matches against both XclassId and CommonClassId. Product Y
matches against both YclassId and
CommonClassId.[¶](#section-3.4.3-3){.pilcrow}
:::
:::

::: {#example-4-rebranding}
::: {#section-3.4.4 .section}
#### [3.4.4.](#section-3.4.4){.section-number .selfRef} [Example 4: Rebranding](#name-example-4-rebranding){.section-name .selfRef} {#name-example-4-rebranding}

Vendor A creates a Product A and its firmware. Vendor B sells the
product under its own name as Product B with some customized
configuration. The vendors create the Class IDs as
follows:[¶](#section-3.4.4-1){.pilcrow}

-   [vendorIdA = UUID5(DNS,
    \"vendor-a.example\")[¶](#section-3.4.4-2.1){.pilcrow}]{#section-3.4.4-2.1}
-   [classIdA = UUID5(vendorIdA, \"Product
    A-Unlabeled\")[¶](#section-3.4.4-2.2){.pilcrow}]{#section-3.4.4-2.2}
-   [vendorIdB = UUID5(DNS,
    \"vendor-b.example\")[¶](#section-3.4.4-2.3){.pilcrow}]{#section-3.4.4-2.3}
-   [classIdB = UUID5(vendorIdB, \"Product
    B\")[¶](#section-3.4.4-2.4){.pilcrow}]{#section-3.4.4-2.4}

The product will match against each of these Class IDs. If Vendor A and
Vendor B provide different components for the device, the implementor
may choose to make ID matching scoped to each component. Then, the
vendorIdA, classIdA match the component ID supplied by Vendor A, and the
vendorIdB, classIdB match the component ID supplied by Vendor
B.[¶](#section-3.4.4-3){.pilcrow}
:::
:::
:::
:::

::: {#element-precursor-digest}
::: {#section-3.5 .section}
### [3.5.](#section-3.5){.section-number .selfRef} [Precursor Image Digest Condition](#name-precursor-image-digest-cond){.section-name .selfRef} {#name-precursor-image-digest-cond}

This element provides information about the payload that needs to be
present on the device for an update to apply. This may, for example, be
the case with differential updates.[¶](#section-3.5-1){.pilcrow}

This element is [OPTIONAL]{.bcp14}.[¶](#section-3.5-2){.pilcrow}

[]{.break}

Implements:
:   [REQ.SEC.AUTH.PRECURSOR](#req-sec-authentic-precursor){.xref}
    ([Section
    4.3.9](#req-sec-authentic-precursor){.xref})[¶](#section-3.5-3.2){.pilcrow}
:   
:::
:::

::: {#element-required-version}
::: {#section-3.6 .section}
### [3.6.](#section-3.6){.section-number .selfRef} [Required Image Version List](#name-required-image-version-list){.section-name .selfRef} {#name-required-image-version-list}

Payloads may only be applied to a specific firmware version or multiple
firmware versions. For example, a payload containing a differential
update may be applied only to a specific firmware
version.[¶](#section-3.6-1){.pilcrow}

When a payload applies to multiple versions of firmware, the required
image version list specifies which firmware versions must be present for
the update to be applied. This allows the update author to target
specific versions of firmware for an update, while excluding those to
which it should not or cannot be applied.[¶](#section-3.6-2){.pilcrow}

This element is [OPTIONAL]{.bcp14}.[¶](#section-3.6-3){.pilcrow}

[]{.break}

Implements:
:   [REQ.USE.IMG.VERSIONS](#req-use-img-versions){.xref} ([Section
    4.5.8](#req-use-img-versions){.xref})[¶](#section-3.6-4.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-expiration}
::: {#section-3.7 .section}
### [3.7.](#section-3.7){.section-number .selfRef} [Expiration Time](#name-expiration-time){.section-name .selfRef} {#name-expiration-time}

This element tells a device the time at which the manifest expires and
should no longer be used. This element should be used where a secure
source of time is provided and firmware is intended to expire
predictably. This element may also be displayed (e.g., via an app) for
user confirmation, since users typically have a reliable knowledge of
the date.[¶](#section-3.7-1){.pilcrow}

Special consideration is required for end-of-life if firmware will not
be updated again \-- for example, if a business stops issuing updates to
a device. In this case, the last valid firmware should not have an
expiration time.[¶](#section-3.7-2){.pilcrow}

This element is [OPTIONAL]{.bcp14}.[¶](#section-3.7-3){.pilcrow}

[]{.break}

Implements:
:   [REQ.SEC.EXP](#req-sec-exp){.xref} ([Section
    4.3.3](#req-sec-exp){.xref})[¶](#section-3.7-4.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-format}
::: {#section-3.8 .section}
### [3.8.](#section-3.8){.section-number .selfRef} [Payload Format](#name-payload-format){.section-name .selfRef} {#name-payload-format}

This element describes the payload format within the signed metadata. It
is used to enable devices to decode payloads
correctly.[¶](#section-3.8-1){.pilcrow}

This element is [REQUIRED]{.bcp14}.[¶](#section-3.8-2){.pilcrow}

[]{.break}

Implements:
:   [REQ.SEC.AUTH.IMG_TYPE](#req-sec-authentic-image-type){.xref}
    ([Section 4.3.5](#req-sec-authentic-image-type){.xref}),
    [REQ.USE.IMG.FORMAT](#req-use-img-format){.xref} ([Section
    4.5.6](#req-use-img-format){.xref})[¶](#section-3.8-3.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-processing-steps}
::: {#section-3.9 .section}
### [3.9.](#section-3.9){.section-number .selfRef} [Processing Steps](#name-processing-steps){.section-name .selfRef} {#name-processing-steps}

This element provides a representation of the processing steps required
to decode a payload \-- in particular, those that are compressed,
packed, or encrypted. The representation must describe which algorithms
are used and must convey any additional parameters required by those
algorithms.[¶](#section-3.9-1){.pilcrow}

A processing step may indicate the expected digest of the payload after
the processing is complete.[¶](#section-3.9-2){.pilcrow}

This element is [RECOMMENDED]{.bcp14}.[¶](#section-3.9-3){.pilcrow}

[]{.break}

Implements:
:   [REQ.USE.IMG.NESTED](#req-use-img-nested){.xref} ([Section
    4.5.7](#req-use-img-nested){.xref})[¶](#section-3.9-4.2){.pilcrow}
:   
:::
:::

::: {#maniest-element-storage-location}
::: {#section-3.10 .section}
### [3.10.](#section-3.10){.section-number .selfRef} [Storage Location](#name-storage-location){.section-name .selfRef} {#name-storage-location}

This element tells the device where to store a payload within a given
component. The device can use this to establish which permissions are
necessary and the physical storage location to
use.[¶](#section-3.10-1){.pilcrow}

This element is [REQUIRED]{.bcp14}.[¶](#section-3.10-2){.pilcrow}

[]{.break}

Implements:
:   [REQ.SEC.AUTH.IMG_LOC](#req-sec-authentic-image-location){.xref}
    ([Section
    4.3.6](#req-sec-authentic-image-location){.xref})[¶](#section-3.10-3.2){.pilcrow}
:   

::: {#example-1-two-storage-locations}
::: {#section-3.10.1 .section}
#### [3.10.1.](#section-3.10.1){.section-number .selfRef} [Example 1: Two Storage Locations](#name-example-1-two-storage-locat){.section-name .selfRef} {#name-example-1-two-storage-locat}

A device supports two components: an OS and an application. These
components can be updated independently, expressing dependencies to
ensure compatibility between the components. The author chooses two
storage identifiers:[¶](#section-3.10.1-1){.pilcrow}

-   [\"OS\"[¶](#section-3.10.1-2.1){.pilcrow}]{#section-3.10.1-2.1}
-   [\"APP\"[¶](#section-3.10.1-2.2){.pilcrow}]{#section-3.10.1-2.2}
:::
:::

::: {#example-2-file-system}
::: {#section-3.10.2 .section}
#### [3.10.2.](#section-3.10.2){.section-number .selfRef} [Example 2: Filesystem](#name-example-2-filesystem){.section-name .selfRef} {#name-example-2-filesystem}

A device supports a full-featured filesystem. The author chooses to use
the storage identifier as the path at which to install the payload. The
payload may be a tarball, in which case it unpacks the tarball into the
specified path.[¶](#section-3.10.2-1){.pilcrow}
:::
:::

::: {#example-3-flash-memory}
::: {#section-3.10.3 .section}
#### [3.10.3.](#section-3.10.3){.section-number .selfRef} [Example 3: Flash Memory](#name-example-3-flash-memory){.section-name .selfRef} {#name-example-3-flash-memory}

A device supports flash memory. The author chooses to make the storage
identifier the offset where the image should be
written.[¶](#section-3.10.3-1){.pilcrow}
:::
:::
:::
:::

::: {#manifest-element-component-identifier}
::: {#section-3.11 .section}
### [3.11.](#section-3.11){.section-number .selfRef} [Component Identifier](#name-component-identifier){.section-name .selfRef} {#name-component-identifier}

In a device with more than one storage subsystem, a storage identifier
is insufficient to identify where and how to store a payload. To resolve
this, a component identifier indicates to which part of the storage
subsystem the payload shall be placed.[¶](#section-3.11-1){.pilcrow}

A serialization may choose to combine the use of a component identifier
and [storage location](#maniest-element-storage-location){.xref}
([Section
3.10](#maniest-element-storage-location){.xref}).[¶](#section-3.11-2){.pilcrow}

This element is [OPTIONAL]{.bcp14}.[¶](#section-3.11-3){.pilcrow}

[]{.break}

Implements:
:   [REQ.USE.MFST.COMPONENT](#req-use-mfst-component){.xref} ([Section
    4.5.4](#req-use-mfst-component){.xref})[¶](#section-3.11-4.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-payload-indicator}
::: {#section-3.12 .section}
### [3.12.](#section-3.12){.section-number .selfRef} [Payload Indicator](#name-payload-indicator){.section-name .selfRef} {#name-payload-indicator}

This element provides the information required for the device to acquire
the payload. This functionality is only needed when the target device
does not intrinsically know where to find the
payload.[¶](#section-3.12-1){.pilcrow}

This can be encoded in several ways:[¶](#section-3.12-2){.pilcrow}

-   [One URI[¶](#section-3.12-3.1){.pilcrow}]{#section-3.12-3.1}
-   [A list of URIs[¶](#section-3.12-3.2){.pilcrow}]{#section-3.12-3.2}
-   [A prioritized list of
    URIs[¶](#section-3.12-3.3){.pilcrow}]{#section-3.12-3.3}
-   [A list of signed
    URIs[¶](#section-3.12-3.4){.pilcrow}]{#section-3.12-3.4}

This element is [OPTIONAL]{.bcp14}.[¶](#section-3.12-4){.pilcrow}

[]{.break}

Implements:
:   [REQ.SEC.AUTH.REMOTE_LOC](#req-sec-authenticated-remote-payload){.xref}
    ([Section
    4.3.7](#req-sec-authenticated-remote-payload){.xref})[¶](#section-3.12-5.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-payload-digest}
::: {#section-3.13 .section}
### [3.13.](#section-3.13){.section-number .selfRef} [Payload Digests](#name-payload-digests){.section-name .selfRef} {#name-payload-digests}

This element contains one or more digests of one or more payloads. This
allows the target device to ensure authenticity of the payload(s) when
combined with the [Signature](#manifest-element-signature){.xref}
([Section 3.15](#manifest-element-signature){.xref}) element. A manifest
format must provide a mechanism to select one payload from a list based
on system parameters, such as an execute-in-place (XIP) installation
address.[¶](#section-3.13-1){.pilcrow}

This element is [REQUIRED]{.bcp14}. Support for more than one digest is
[OPTIONAL]{.bcp14}.[¶](#section-3.13-2){.pilcrow}

[]{.break}

Implements:
:   [REQ.SEC.AUTHENTIC](#req-sec-authentic){.xref} ([Section
    4.3.4](#req-sec-authentic){.xref}),
    [REQ.USE.IMG.SELECT](#req-use-img-select){.xref} ([Section
    4.5.9](#req-use-img-select){.xref})[¶](#section-3.13-3.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-size}
::: {#section-3.14 .section}
### [3.14.](#section-3.14){.section-number .selfRef} [Size](#name-size){.section-name .selfRef} {#name-size}

This element provides the size of the payload in bytes, which informs
the target device how big of a payload to expect. Without it, devices
are exposed to some classes of denial-of-service
attacks.[¶](#section-3.14-1){.pilcrow}

This element is [REQUIRED]{.bcp14}.[¶](#section-3.14-2){.pilcrow}

[]{.break}

Implements:
:   [REQ.SEC.AUTH.EXEC](#req-sec-authentic-execution){.xref} ([Section
    4.3.8](#req-sec-authentic-execution){.xref})[¶](#section-3.14-3.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-signature}
::: {#section-3.15 .section}
### [3.15.](#section-3.15){.section-number .selfRef} [Manifest Envelope Element: Signature](#name-manifest-envelope-element-s){.section-name .selfRef} {#name-manifest-envelope-element-s}

The signature element contains all the information necessary to protect
the contents of the manifest against modification and to offer
authentication of the signer. Because the signature element
authenticates the manifest, it cannot be contained within the manifest.
Instead, either the manifest is contained within the signature element
or the signature element is a member of the Manifest Envelope and
bundled with the manifest.[¶](#section-3.15-1){.pilcrow}

The signature element represents the foundation of all security
properties of the manifest. Manifests, which are included as
dependencies by other manifests, should include a signature so that the
recipient can distinguish between different actors with different
permissions.[¶](#section-3.15-2){.pilcrow}

The signature element must support multiple signers and multiple signing
algorithms. A manifest format may allow multiple manifests to be covered
by a single signature element.[¶](#section-3.15-3){.pilcrow}

This element is [REQUIRED]{.bcp14} in non-dependency
manifests.[¶](#section-3.15-4){.pilcrow}

[]{.break}

Implements:
:   [REQ.SEC.AUTHENTIC](#req-sec-authentic){.xref} ([Section
    4.3.4](#req-sec-authentic){.xref}),
    [REQ.SEC.RIGHTS](#req-sec-rights){.xref} ([Section
    4.3.11](#req-sec-rights){.xref}),
    [REQ.USE.MFST.MULTI_AUTH](#req-use-mfst-multi-auth){.xref} ([Section
    4.5.5](#req-use-mfst-multi-auth){.xref})[¶](#section-3.15-5.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-additional-install-info}
::: {#section-3.16 .section}
### [3.16.](#section-3.16){.section-number .selfRef} [Additional Installation Instructions](#name-additional-installation-ins){.section-name .selfRef} {#name-additional-installation-ins}

Additional installation instructions are machine-readable commands the
device should execute when processing the manifest. This information is
distinct from the information necessary to process a payload. Additional
installation instructions include information such as update timing (for
example, install only on Sunday, at 0200), procedural considerations
(for example, shut down the equipment under control before executing the
update), and pre- and post-installation steps (for example, run a
script). Other installation instructions could include requesting user
confirmation before installing.[¶](#section-3.16-1){.pilcrow}

This element is [OPTIONAL]{.bcp14}.[¶](#section-3.16-2){.pilcrow}

[]{.break}

Implements:
:   [REQ.USE.MFST.PRE_CHECK](#req-use-mfst-pre-check){.xref} ([Section
    4.5.1](#req-use-mfst-pre-check){.xref})[¶](#section-3.16-3.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-text}
::: {#section-3.17 .section}
### [3.17.](#section-3.17){.section-number .selfRef} [Manifest Text Information](#name-manifest-text-information){.section-name .selfRef} {#name-manifest-text-information}

This is textual information pertaining to the update described by the
manifest. This information is for human consumption only. It [MUST
NOT]{.bcp14} be the basis of any decision made by the
recipient.[¶](#section-3.17-1){.pilcrow}

This element is [OPTIONAL]{.bcp14}.[¶](#section-3.17-2){.pilcrow}

[]{.break}

Implements:
:   [REQ.USE.MFST.TEXT](#req-use-mfst-text){.xref} ([Section
    4.5.2](#req-use-mfst-text){.xref})[¶](#section-3.17-3.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-aliases}
::: {#section-3.18 .section}
### [3.18.](#section-3.18){.section-number .selfRef} [Aliases](#name-aliases){.section-name .selfRef} {#name-aliases}

Aliases provide a mechanism for a manifest to augment or replace URIs or
URI lists defined by one or more of its
dependencies.[¶](#section-3.18-1){.pilcrow}

This element is [OPTIONAL]{.bcp14}.[¶](#section-3.18-2){.pilcrow}

[]{.break}

Implements:
:   [REQ.USE.MFST.OVERRIDE_REMOTE](#req-use-mfst-override){.xref}
    ([Section
    4.5.3](#req-use-mfst-override){.xref})[¶](#section-3.18-3.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-dependencies}
::: {#section-3.19 .section}
### [3.19.](#section-3.19){.section-number .selfRef} [Dependencies](#name-dependencies){.section-name .selfRef} {#name-dependencies}

This is a list of other manifests that are required by the current
manifest. Manifests are identified in an unambiguous way, such as a
cryptographic digest.[¶](#section-3.19-1){.pilcrow}

This element is [REQUIRED]{.bcp14} to support deployments that include
both multiple authorities and multiple
payloads.[¶](#section-3.19-2){.pilcrow}

[]{.break}

Implements:
:   [REQ.USE.MFST.COMPONENT](#req-use-mfst-component){.xref} ([Section
    4.5.4](#req-use-mfst-component){.xref})[¶](#section-3.19-3.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-encryption-wrapper}
::: {#section-3.20 .section}
### [3.20.](#section-3.20){.section-number .selfRef} [Encryption Wrapper](#name-encryption-wrapper){.section-name .selfRef} {#name-encryption-wrapper}

Encrypting firmware images requires symmetric content encryption keys.
The encryption wrapper provides the information needed for a device to
obtain or locate a key that it uses to decrypt the
firmware.[¶](#section-3.20-1){.pilcrow}

This element is [REQUIRED]{.bcp14} for encrypted
payloads.[¶](#section-3.20-2){.pilcrow}

[]{.break}

Implements:
:   [REQ.SEC.IMG.CONFIDENTIALITY](#req-sec-image-confidentiality){.xref}
    ([Section
    4.3.12](#req-sec-image-confidentiality){.xref})[¶](#section-3.20-3.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-xip-address}
::: {#section-3.21 .section}
### [3.21.](#section-3.21){.section-number .selfRef} [XIP Address](#name-xip-address){.section-name .selfRef} {#name-xip-address}

In order to support XIP systems with multiple possible base addresses,
it is necessary to specify which address the payload is linked
for.[¶](#section-3.21-1){.pilcrow}

For example, a microcontroller may have a simple bootloader that chooses
one of two images to boot. That microcontroller then needs to choose one
of two firmware images to install, based on which of its two images is
older.[¶](#section-3.21-2){.pilcrow}

This element is [OPTIONAL]{.bcp14}.[¶](#section-3.21-3){.pilcrow}

[]{.break}

Implements:
:   [REQ.USE.IMG.SELECT](#req-use-img-select){.xref} ([Section
    4.5.9](#req-use-img-select){.xref})[¶](#section-3.21-4.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-load-metadata}
::: {#section-3.22 .section}
### [3.22.](#section-3.22){.section-number .selfRef} [Load-Time Metadata](#name-load-time-metadata){.section-name .selfRef} {#name-load-time-metadata}

Load-time metadata provides the device with information that it needs in
order to load one or more images. This metadata may include any of the
following:[¶](#section-3.22-1){.pilcrow}

-   [The source (e.g., non-volatile
    storage)[¶](#section-3.22-2.1){.pilcrow}]{#section-3.22-2.1}
-   [The destination (e.g., an address in
    RAM)[¶](#section-3.22-2.2){.pilcrow}]{#section-3.22-2.2}
-   [Cryptographic
    information[¶](#section-3.22-2.3){.pilcrow}]{#section-3.22-2.3}
-   [Decompression
    information[¶](#section-3.22-2.4){.pilcrow}]{#section-3.22-2.4}
-   [Unpacking
    information[¶](#section-3.22-2.5){.pilcrow}]{#section-3.22-2.5}

Typically, loading is done by copying an image from its permanent
storage location into its active use location. The metadata allows
operations such as decryption, decompression, and unpacking to be
performed during that copy.[¶](#section-3.22-3){.pilcrow}

This element is [OPTIONAL]{.bcp14}.[¶](#section-3.22-4){.pilcrow}

[]{.break}

Implements:
:   [REQ.USE.LOAD](#req-use-load){.xref} ([Section
    4.5.11](#req-use-load){.xref})[¶](#section-3.22-5.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-exec-metadata}
::: {#section-3.23 .section}
### [3.23.](#section-3.23){.section-number .selfRef} [Runtime Metadata](#name-runtime-metadata){.section-name .selfRef} {#name-runtime-metadata}

Runtime metadata provides the device with any extra information needed
to boot the device. This may include the entry point of an XIP image or
the kernel command line to boot a Linux
image.[¶](#section-3.23-1){.pilcrow}

This element is [OPTIONAL]{.bcp14}.[¶](#section-3.23-2){.pilcrow}

[]{.break}

Implements:
:   [REQ.USE.EXEC](#req-use-exec){.xref} ([Section
    4.5.10](#req-use-exec){.xref})[¶](#section-3.23-3.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-payload}
::: {#section-3.24 .section}
### [3.24.](#section-3.24){.section-number .selfRef} [Payload](#name-payload){.section-name .selfRef} {#name-payload}

The Payload element is contained within the manifest or Manifest
Envelope and enables the manifest and payload to be delivered
simultaneously. This is used for delivering small payloads, such as
cryptographic keys or configuration data.[¶](#section-3.24-1){.pilcrow}

This element is [OPTIONAL]{.bcp14}.[¶](#section-3.24-2){.pilcrow}

[]{.break}

Implements:
:   [REQ.USE.PAYLOAD](#req-use-payload){.xref} ([Section
    4.5.12](#req-use-payload){.xref})[¶](#section-3.24-3.2){.pilcrow}
:   
:::
:::

::: {#manifest-element-key-claims}
::: {#section-3.25 .section}
### [3.25.](#section-3.25){.section-number .selfRef} [Manifest Envelope Element: Delegation Chain](#name-manifest-envelope-element-d){.section-name .selfRef} {#name-manifest-envelope-element-d}

The delegation chain offers enhanced authorization functionality via
authorization tokens, such as Concise Binary Object Representation
(CBOR) Web Tokens \[[RFC8392](#RFC8392){.xref}\] with
Proof-of-Possession Key Semantics \[[RFC8747](#RFC8747){.xref}\]. Each
token itself is protected and does not require another layer of
protection. Each authorization token typically includes a public key or
a public key fingerprint; however, this is dependent on the tokens used.
Each token [MAY]{.bcp14} include additional metadata, such as key usage
information. Because the delegation chain is needed to verify the
signature, it must be placed in the Manifest Envelope, rather than the
manifest.[¶](#section-3.25-1){.pilcrow}

The first token in any delegation chain [MUST]{.bcp14} be authenticated
by the recipient\'s trust anchor. Each subsequent token [MUST]{.bcp14}
be authenticated using the previous token. This allows a recipient to
discard each antecedent token after it has authenticated the subsequent
token. The final token [MUST]{.bcp14} enable authentication of the
manifest. More than one delegation chain [MAY]{.bcp14} be used if more
than one signature is used. Note that no restriction is placed on the
encoding order of these tokens; the order of elements is logical
only.[¶](#section-3.25-2){.pilcrow}

This element is [OPTIONAL]{.bcp14}.[¶](#section-3.25-3){.pilcrow}

[]{.break}

Implements:
:   [REQ.USE.DELEGATION](#req-use-delegation){.xref} ([Section
    4.5.14](#req-use-delegation){.xref}),
    [REQ.SEC.KEY.ROTATION](#req-sec-key-rotation){.xref} ([Section
    4.3.18](#req-sec-key-rotation){.xref})[¶](#section-3.25-4.2){.pilcrow}
:   
:::
:::
:::
:::

::: {#design-motivation}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

The following subsections describe the threat model, user stories,
security requirements, and usability requirements. This section also
provides the motivations for each of the manifest information
elements.[¶](#section-4-1){.pilcrow}

Note that it is worthwhile to recall that a firmware update is, by
definition, remote code execution. Hence, if a device is configured to
trust an entity to provide firmware, it trusts this entity to behave
correctly. Many classes of attacks can be mitigated by verifying that a
firmware update came from a trusted party and that no rollback is taking
place. However, if the trusted entity has been compromised and
distributes attacker-provided firmware to devices, then the
possibilities for defense are limited.[¶](#section-4-2){.pilcrow}

::: {#threat-model}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Threat Model](#name-threat-model){.section-name .selfRef} {#name-threat-model}

The following subsections aim to provide information about the threats
that were considered, the security requirements that are derived from
those threats, and the fields that permit implementation of the security
requirements. This model uses the Spoofing, Tampering, Repudiation,
Information Disclosure, Denial of Service, and Elevation of Privilege
(STRIDE) approach \[[STRIDE](#STRIDE){.xref}\]. Each threat is
classified according to the following:[¶](#section-4.1-1){.pilcrow}

-   [Spoofing identity[¶](#section-4.1-2.1){.pilcrow}]{#section-4.1-2.1}
-   [Tampering with
    data[¶](#section-4.1-2.2){.pilcrow}]{#section-4.1-2.2}
-   [Repudiation[¶](#section-4.1-2.3){.pilcrow}]{#section-4.1-2.3}
-   [Information
    disclosure[¶](#section-4.1-2.4){.pilcrow}]{#section-4.1-2.4}
-   [Denial of service[¶](#section-4.1-2.5){.pilcrow}]{#section-4.1-2.5}
-   [Elevation of
    privilege[¶](#section-4.1-2.6){.pilcrow}]{#section-4.1-2.6}

This threat model only covers elements related to the transport of
firmware updates. It explicitly does not cover threats outside of the
transport of firmware updates. For example, threats to an IoT device due
to physical access are out of scope.[¶](#section-4.1-3){.pilcrow}
:::
:::

::: {#threat-descriptions}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Threat Descriptions](#name-threat-descriptions){.section-name .selfRef} {#name-threat-descriptions}

Many of the threats detailed in this section contain a \"threat
escalation\" description. This explains how the described threat might
fit together with other threats and produce a high-severity threat. This
is important because some of the described threats may seem low severity
but could be used with others to construct a high-severity
compromise.[¶](#section-4.2-1){.pilcrow}

::: {#threat-expired}
::: {#section-4.2.1 .section}
#### [4.2.1.](#section-4.2.1){.section-number .selfRef} [THREAT.IMG.EXPIRED: Old Firmware](#name-threatimgexpired-old-firmwa){.section-name .selfRef} {#name-threatimgexpired-old-firmwa}

[]{.break}

Classification:
:   Elevation of Privilege[¶](#section-4.2.1-1.2){.pilcrow}
:   

An attacker sends an old, but valid, manifest with an old, but valid,
firmware image to a device. If there is a known vulnerability in the
provided firmware image, this may allow an attacker to exploit the
vulnerability and gain control of the
device.[¶](#section-4.2.1-2){.pilcrow}

[]{.break}

Threat Escalation:
:   If the attacker is able to exploit the known vulnerability, then
    this threat can be escalated to all
    types.[¶](#section-4.2.1-3.2){.pilcrow}
:   

Mitigated by:
:   [REQ.SEC.SEQUENCE](#req-sec-sequence){.xref} ([Section
    4.3.1](#req-sec-sequence){.xref})[¶](#section-4.2.1-3.4){.pilcrow}
:   
:::
:::

::: {#threat-expired-offline}
::: {#section-4.2.2 .section}
#### [4.2.2.](#section-4.2.2){.section-number .selfRef} [THREAT.IMG.EXPIRED.OFFLINE: Offline Device + Old Firmware](#name-threatimgexpiredoffline-off){.section-name .selfRef} {#name-threatimgexpiredoffline-off}

[]{.break}

Classification:
:   Elevation of Privilege[¶](#section-4.2.2-1.2){.pilcrow}
:   

An attacker targets a device that has been offline for a long time and
runs an old firmware version. The attacker sends an old, but valid,
manifest to a device with an old, but valid, firmware image. The
attacker-provided firmware is newer than the installed firmware but
older than the most recently available firmware. If there is a known
vulnerability in the provided firmware image, then this may allow an
attacker to gain control of a device. Because the device has been
offline for a long time, it is unaware of any new updates. As such, it
will treat the old manifest as the most
current.[¶](#section-4.2.2-2){.pilcrow}

The exact mitigation for this threat depends on where the threat comes
from. This requires careful consideration by the implementor. If the
threat is from a network actor, including an on-path attacker, or an
intruder into a management system, then a user confirmation can mitigate
this attack, simply by displaying an expiration date and requesting
confirmation. On the other hand, if the user is the attacker, then an
online confirmation system (for example, a trusted timestamp server) can
be used as a mitigation system.[¶](#section-4.2.2-3){.pilcrow}

[]{.break}

Threat Escalation:
:   If the attacker is able to exploit the known vulnerability, then
    this threat can be escalated to all
    types.[¶](#section-4.2.2-4.2){.pilcrow}
:   

Mitigated by:
:   [REQ.SEC.EXP](#req-sec-exp){.xref} ([Section
    4.3.3](#req-sec-exp){.xref}),
    [REQ.USE.MFST.PRE_CHECK](#req-use-mfst-pre-check){.xref} ([Section
    4.5.1](#req-use-mfst-pre-check){.xref})[¶](#section-4.2.2-4.4){.pilcrow}
:   
:::
:::

::: {#threat-incompatible}
::: {#section-4.2.3 .section}
#### [4.2.3.](#section-4.2.3){.section-number .selfRef} [THREAT.IMG.INCOMPATIBLE: Mismatched Firmware](#name-threatimgincompatible-misma){.section-name .selfRef} {#name-threatimgincompatible-misma}

[]{.break}

Classification:
:   Denial of Service[¶](#section-4.2.3-1.2){.pilcrow}
:   

An attacker sends a valid firmware image, for the wrong type of device,
signed by an actor with firmware installation permission on both device
types. The firmware is verified by the device positively because it is
signed by an actor with the appropriate permission. This could have
wide-ranging consequences. For devices that are similar, it could cause
minor breakage or expose security vulnerabilities. For devices that are
very different, it is likely to render devices
inoperable.[¶](#section-4.2.3-2){.pilcrow}

[]{.break}

Mitigated by:
:   [REQ.SEC.COMPATIBLE](#req-sec-compatible){.xref} ([Section
    4.3.2](#req-sec-compatible){.xref})[¶](#section-4.2.3-3.2){.pilcrow}
:   

For example, suppose that two vendors \-- Vendor A and Vendor B \--
adopt the same trade name in different geographic regions, and they both
make products with the same names, or product name matching is not used.
This causes firmware from Vendor A to match devices from Vendor
B.[¶](#section-4.2.3-4){.pilcrow}

If the vendors are the firmware authorities, then devices from Vendor A
will reject images signed by Vendor B, since they use different
credentials. However, if both devices trust the same author, then
devices from Vendor A could install firmware intended for devices from
Vendor B.[¶](#section-4.2.3-5){.pilcrow}
:::
:::

::: {#threat-img-format}
::: {#section-4.2.4 .section}
#### [4.2.4.](#section-4.2.4){.section-number .selfRef} [THREAT.IMG.FORMAT: The Target Device Misinterprets the Type of Payload](#name-threatimgformat-the-target-){.section-name .selfRef} {#name-threatimgformat-the-target-}

[]{.break}

Classification:
:   Denial of Service[¶](#section-4.2.4-1.2){.pilcrow}
:   

If a device misinterprets the format of the firmware image, it may cause
a device to install a firmware image incorrectly. An incorrectly
installed firmware image would likely cause the device to stop
functioning.[¶](#section-4.2.4-2){.pilcrow}

[]{.break}

Threat Escalation:
:   An attacker that can cause a device to misinterpret the received
    firmware image may gain elevation of privilege and potentially
    expand this to all types of
    threats.[¶](#section-4.2.4-3.2){.pilcrow}
:   

Mitigated by:
:   [REQ.SEC.AUTH.IMG_TYPE](#req-sec-authentic-image-type){.xref}
    ([Section
    4.3.5](#req-sec-authentic-image-type){.xref})[¶](#section-4.2.4-3.4){.pilcrow}
:   
:::
:::

::: {#threat-img-location}
::: {#section-4.2.5 .section}
#### [4.2.5.](#section-4.2.5){.section-number .selfRef} [THREAT.IMG.LOCATION: The Target Device Installs the Payload to the Wrong Location](#name-threatimglocation-the-targe){.section-name .selfRef} {#name-threatimglocation-the-targe}

[]{.break}

Classification:
:   Denial of Service[¶](#section-4.2.5-1.2){.pilcrow}
:   

If a device installs a firmware image to the wrong location on the
device, then it is likely to break. For example, a firmware image
installed as an application could cause a device and/or application to
stop functioning.[¶](#section-4.2.5-2){.pilcrow}

[]{.break}

Threat Escalation:
:   An attacker that can cause a device to misinterpret the received
    code may gain elevation of privilege and potentially expand this to
    all types of threats.[¶](#section-4.2.5-3.2){.pilcrow}
:   

Mitigated by:
:   [REQ.SEC.AUTH.IMG_LOC](#req-sec-authentic-image-location){.xref}
    ([Section
    4.3.6](#req-sec-authentic-image-location){.xref})[¶](#section-4.2.5-3.4){.pilcrow}
:   
:::
:::

::: {#threat-net-redirect}
::: {#section-4.2.6 .section}
#### [4.2.6.](#section-4.2.6){.section-number .selfRef} [THREAT.NET.REDIRECT: Redirection to Inauthentic Payload Hosting](#name-threatnetredirect-redirecti){.section-name .selfRef} {#name-threatnetredirect-redirecti}

[]{.break}

Classification:
:   Denial of Service[¶](#section-4.2.6-1.2){.pilcrow}
:   

If a device is tricked into fetching a payload for an
attacker-controlled site, the attacker may send corrupted payloads to
devices.[¶](#section-4.2.6-2){.pilcrow}

[]{.break}

Mitigated by:
:   [REQ.SEC.AUTH.REMOTE_LOC](#req-sec-authenticated-remote-payload){.xref}
    ([Section
    4.3.7](#req-sec-authenticated-remote-payload){.xref})[¶](#section-4.2.6-3.2){.pilcrow}
:   
:::
:::

::: {#threat-net-onpath}
::: {#section-4.2.7 .section}
#### [4.2.7.](#section-4.2.7){.section-number .selfRef} [THREAT.NET.ONPATH: Traffic Interception](#name-threatnetonpath-traffic-int){.section-name .selfRef} {#name-threatnetonpath-traffic-int}

[]{.break}

Classification:
:   Spoofing Identity, Tampering with
    Data[¶](#section-4.2.7-1.2){.pilcrow}
:   

An attacker intercepts all traffic to and from a device. The attacker
can monitor or modify any data sent to or received from the device. This
can take the form of manifests, payloads, status reports, and capability
reports being modified or not delivered to the intended recipient. It
can also take the form of analysis of data sent to or from the device,
in content, size, or frequency.[¶](#section-4.2.7-2){.pilcrow}

[]{.break}

Mitigated by:
:   [REQ.SEC.AUTHENTIC](#req-sec-authentic){.xref} ([Section
    4.3.4](#req-sec-authentic){.xref}),
    [REQ.SEC.IMG.CONFIDENTIALITY](#req-sec-image-confidentiality){.xref}
    ([Section 4.3.12](#req-sec-image-confidentiality){.xref}),
    [REQ.SEC.AUTH.REMOTE_LOC](#req-sec-authenticated-remote-payload){.xref}
    ([Section 4.3.7](#req-sec-authenticated-remote-payload){.xref}),
    [REQ.SEC.MFST.CONFIDENTIALITY](#req-sec-mfst-confidentiality){.xref}
    ([Section 4.3.14](#req-sec-mfst-confidentiality){.xref}),
    [REQ.SEC.REPORTING](#req-sec-reporting){.xref} ([Section
    4.3.16](#req-sec-reporting){.xref})[¶](#section-4.2.7-3.2){.pilcrow}
:   
:::
:::

::: {#threat-image-replacement}
::: {#section-4.2.8 .section}
#### [4.2.8.](#section-4.2.8){.section-number .selfRef} [THREAT.IMG.REPLACE: Payload Replacement](#name-threatimgreplace-payload-re){.section-name .selfRef} {#name-threatimgreplace-payload-re}

[]{.break}

Classification:
:   Elevation of Privilege[¶](#section-4.2.8-1.2){.pilcrow}
:   

An attacker replaces newly downloaded firmware after a device finishes
verifying a manifest. This could cause the device to execute the
attacker\'s code. This attack likely requires physical access to the
device. However, it is possible that this attack is carried out in
combination with another threat that allows remote execution. This is a
typical Time Of Check / Time Of Use (TOCTOU)
attack.[¶](#section-4.2.8-2){.pilcrow}

[]{.break}

Threat Escalation:
:   If the attacker is able to exploit a known vulnerability or if the
    attacker can supply their own firmware, then this threat can be
    escalated to all types.[¶](#section-4.2.8-3.2){.pilcrow}
:   

Mitigated by:
:   [REQ.SEC.AUTH.EXEC](#req-sec-authentic-execution){.xref} ([Section
    4.3.8](#req-sec-authentic-execution){.xref})[¶](#section-4.2.8-3.4){.pilcrow}
:   
:::
:::

::: {#threat-img-unauthenticated}
::: {#section-4.2.9 .section}
#### [4.2.9.](#section-4.2.9){.section-number .selfRef} [THREAT.IMG.NON_AUTH: Unauthenticated Images](#name-threatimgnon_auth-unauthent){.section-name .selfRef} {#name-threatimgnon_auth-unauthent}

[]{.break}

Classification:
:   Elevation of Privilege / all types[¶](#section-4.2.9-1.2){.pilcrow}
:   

If an attacker can install their firmware on a device \-- for example,
by manipulating either payload or metadata \-- then they have complete
control of the device.[¶](#section-4.2.9-2){.pilcrow}

[]{.break}

Mitigated by:
:   [REQ.SEC.AUTHENTIC](#req-sec-authentic){.xref} ([Section
    4.3.4](#req-sec-authentic){.xref})[¶](#section-4.2.9-3.2){.pilcrow}
:   
:::
:::

::: {#threat-upd-wrong-precursor}
::: {#section-4.2.10 .section}
#### [4.2.10.](#section-4.2.10){.section-number .selfRef} [THREAT.UPD.WRONG_PRECURSOR: Unexpected Precursor Images](#name-threatupdwrong_precursor-un){.section-name .selfRef} {#name-threatupdwrong_precursor-un}

[]{.break}

Classification:
:   Denial of Service / all types[¶](#section-4.2.10-1.2){.pilcrow}
:   

Modifications of payloads and metadata allow an attacker to introduce a
number of denial-of-service attacks. Below are some
examples.[¶](#section-4.2.10-2){.pilcrow}

An attacker sends a valid, current manifest to a device that has an
unexpected precursor image. If a payload format requires a precursor
image (for example, delta updates) and that precursor image is not
available on the target device, it could cause the update to
break.[¶](#section-4.2.10-3){.pilcrow}

An attacker that can cause a device to install a payload against the
wrong precursor image could gain elevation of privilege and potentially
expand this to all types of threats. However, it is unlikely that a
valid differential update applied to an incorrect precursor would result
in functional, but vulnerable, firmware.[¶](#section-4.2.10-4){.pilcrow}

[]{.break}

Mitigated by:
:   [REQ.SEC.AUTH.PRECURSOR](#req-sec-authentic-precursor){.xref}
    ([Section
    4.3.9](#req-sec-authentic-precursor){.xref})[¶](#section-4.2.10-5.2){.pilcrow}
:   
:::
:::

::: {#threat-upd-unapproved}
::: {#section-4.2.11 .section}
#### [4.2.11.](#section-4.2.11){.section-number .selfRef} [THREAT.UPD.UNAPPROVED: Unapproved Firmware](#name-threatupdunapproved-unappro){.section-name .selfRef} {#name-threatupdunapproved-unappro}

[]{.break}

Classification:
:   Denial of Service, Elevation of
    Privilege[¶](#section-4.2.11-1.2){.pilcrow}
:   

This threat can appear in several ways; however, it is ultimately about
ensuring that devices retain the behavior required by their owner or
Operator. The owner or Operator of a device typically requires that the
device maintain certain features, functions, capabilities, behaviors, or
interoperability constraints (more generally, behavior). If these
requirements are broken, then a device will not fulfill its purpose.
Therefore, if any party other than the device\'s owner or the owner\'s
contracted device operator has the ability to modify device behavior
without approval, then this constitutes an elevation of
privilege.[¶](#section-4.2.11-2){.pilcrow}

Similarly, a network operator may require that devices behave in a
particular way in order to maintain the integrity of the network. If
device behavior on a network can be modified without the approval of the
network operator, then this constitutes an elevation of privilege with
respect to the network.[¶](#section-4.2.11-3){.pilcrow}

For example, if the owner of a device has purchased that device because
of Features A, B, and C, and a firmware update that removes Feature A is
issued by the manufacturer, then the device may not fulfill the owner\'s
requirements any more. In certain circumstances, this can cause
significantly greater threats. Suppose that Feature A is used to
implement a safety-critical system, whether the manufacturer intended
this behavior or not. When unapproved firmware is installed, the system
may become unsafe.[¶](#section-4.2.11-4){.pilcrow}

In a second example, the owner or Operator of a system of two or more
interoperating devices needs to approve firmware for their system in
order to ensure interoperability with other devices in the system. If
the firmware is not qualified, the system as a whole may not work.
Therefore, if a device installs firmware without the approval of the
device owner or Operator, this is a threat to devices or the system as a
whole.[¶](#section-4.2.11-5){.pilcrow}

Similarly, the Operator of a network may need to approve firmware for
devices attached to the network in order to ensure favorable operating
conditions within the network. If the firmware is not qualified, it may
degrade the performance of the network. Therefore, if a device installs
firmware without the approval of the network operator, this is a threat
to the network itself.[¶](#section-4.2.11-6){.pilcrow}

[]{.break}

Threat Escalation:
:   If the network operator expects configuration that is present in
    devices deployed in Network A, but not in devices deployed in
    Network B, then the device may experience degraded security, leading
    to threats of all types.[¶](#section-4.2.11-7.2){.pilcrow}
:   

Mitigated by:
:   [REQ.SEC.RIGHTS](#req-sec-rights){.xref} ([Section
    4.3.11](#req-sec-rights){.xref}),
    [REQ.SEC.ACCESS_CONTROL](#req-sec-access-control){.xref} ([Section
    4.3.13](#req-sec-access-control){.xref})[¶](#section-4.2.11-7.4){.pilcrow}
:   

::: {#example-1-multiple-network-operators-with-a-single-device-operator}
::: {#section-4.2.11.1 .section}
##### [4.2.11.1.](#section-4.2.11.1){.section-number .selfRef} [Example 1: Multiple Network Operators with a Single Device Operator](#name-example-1-multiple-network-){.section-name .selfRef} {#name-example-1-multiple-network-}

In this example, assume that device operators expect the rights to
create firmware but that network operators expect the rights to qualify
firmware as \"fit for purpose\" on their networks. Additionally, assume
that device operators manage devices that can be deployed on any
network, including Network A and Network B in our
example.[¶](#section-4.2.11.1-1){.pilcrow}

An attacker may obtain a manifest for a device on Network A. Then, this
attacker sends that manifest to a device on Network B. Because Network A
and Network B are under the control of different Operators, and the
firmware for a device on Network A has not been qualified to be deployed
on Network B, the target device on Network B is now in violation of
Operator B\'s policy and may be disabled by this unqualified, but
signed, firmware.[¶](#section-4.2.11.1-2){.pilcrow}

This is a denial of service because it can render devices inoperable.
This is an elevation of privilege because it allows the attacker to make
installation decisions that should be made by the
Operator.[¶](#section-4.2.11.1-3){.pilcrow}
:::
:::

::: {#example-2-single-network-operator-with-multiple-device-operators}
::: {#section-4.2.11.2 .section}
##### [4.2.11.2.](#section-4.2.11.2){.section-number .selfRef} [Example 2: Single Network Operator with Multiple Device Operators](#name-example-2-single-network-op){.section-name .selfRef} {#name-example-2-single-network-op}

Multiple devices that interoperate are used on the same network and
communicate with each other. Some devices are manufactured and managed
by Device Operator A and other devices by Device Operator B. New
firmware is released by Device Operator A that breaks compatibility with
devices from Device Operator B. An attacker sends the new firmware to
the devices managed by Device Operator A without the approval of the
network operator. This breaks the behavior of the larger system, causing
denial of service and, possibly, other threats. Where the network is a
distributed Supervisory Control and Data Acquisition (SCADA) system,
this could cause misbehavior of the process that is under
control.[¶](#section-4.2.11.2-1){.pilcrow}
:::
:::
:::
:::

::: {#threat-img-disclosure}
::: {#section-4.2.12 .section}
#### [4.2.12.](#section-4.2.12){.section-number .selfRef} [THREAT.IMG.DISCLOSURE: Reverse Engineering of Firmware Image for Vulnerability Analysis](#name-threatimgdisclosure-reverse){.section-name .selfRef} {#name-threatimgdisclosure-reverse}

[]{.break}

Classification:
:   all types[¶](#section-4.2.12-1.2){.pilcrow}
:   

An attacker wants to mount an attack on an IoT device. To prepare the
attack, the provided firmware image is reverse engineered and analyzed
for vulnerabilities.[¶](#section-4.2.12-2){.pilcrow}

[]{.break}

Mitigated by:
:   [REQ.SEC.IMG.CONFIDENTIALITY](#req-sec-image-confidentiality){.xref}
    ([Section
    4.3.12](#req-sec-image-confidentiality){.xref})[¶](#section-4.2.12-3.2){.pilcrow}
:   
:::
:::

::: {#threat-mfst-override}
::: {#section-4.2.13 .section}
#### [4.2.13.](#section-4.2.13){.section-number .selfRef} [THREAT.MFST.OVERRIDE: Overriding Critical Manifest Elements](#name-threatmfstoverride-overridi){.section-name .selfRef} {#name-threatmfstoverride-overridi}

[]{.break}

Classification:
:   Elevation of Privilege[¶](#section-4.2.13-1.2){.pilcrow}
:   

An authorized actor, but not the author, uses an override mechanism
([USER_STORY.OVERRIDE](#user-story-override){.xref} ([Section
4.4.3](#user-story-override){.xref})) to change an information element
in a manifest signed by the author. For example, if the authorized actor
overrides the digest and URI of the payload, the actor can replace the
entire payload with a payload of their
choice.[¶](#section-4.2.13-2){.pilcrow}

[]{.break}

Threat Escalation:
:   By overriding elements such as payload installation instructions or
    a firmware digest, this threat can be escalated to all
    types.[¶](#section-4.2.13-3.2){.pilcrow}
:   

Mitigated by:
:   [REQ.SEC.ACCESS_CONTROL](#req-sec-access-control){.xref} ([Section
    4.3.13](#req-sec-access-control){.xref})[¶](#section-4.2.13-3.4){.pilcrow}
:   
:::
:::

::: {#threat-mfst-exposure}
::: {#section-4.2.14 .section}
#### [4.2.14.](#section-4.2.14){.section-number .selfRef} [THREAT.MFST.EXPOSURE: Confidential Manifest Element Exposure](#name-threatmfstexposure-confiden){.section-name .selfRef} {#name-threatmfstexposure-confiden}

[]{.break}

Classification:
:   Information Disclosure[¶](#section-4.2.14-1.2){.pilcrow}
:   

A third party may be able to extract sensitive information from the
manifest.[¶](#section-4.2.14-2){.pilcrow}

[]{.break}

Mitigated by:
:   [REQ.SEC.MFST.CONFIDENTIALITY](#req-sec-mfst-confidentiality){.xref}
    ([Section
    4.3.14](#req-sec-mfst-confidentiality){.xref})[¶](#section-4.2.14-3.2){.pilcrow}
:   
:::
:::

::: {#threat-img-extra}
::: {#section-4.2.15 .section}
#### [4.2.15.](#section-4.2.15){.section-number .selfRef} [THREAT.IMG.EXTRA: Extra Data after Image](#name-threatimgextra-extra-data-a){.section-name .selfRef} {#name-threatimgextra-extra-data-a}

[]{.break}

Classification:
:   all types[¶](#section-4.2.15-1.2){.pilcrow}
:   

If a third party modifies the image so that it contains extra code after
a valid, authentic image, that third party can then use their own code
in order to make better use of an existing
vulnerability.[¶](#section-4.2.15-2){.pilcrow}

[]{.break}

Mitigated by:
:   [REQ.SEC.IMG.COMPLETE_DIGEST](#req-sec-img-complete-digest){.xref}
    ([Section
    4.3.15](#req-sec-img-complete-digest){.xref})[¶](#section-4.2.15-3.2){.pilcrow}
:   
:::
:::

::: {#threat-key-exposure}
::: {#section-4.2.16 .section}
#### [4.2.16.](#section-4.2.16){.section-number .selfRef} [THREAT.KEY.EXPOSURE: Exposure of Signing Keys](#name-threatkeyexposure-exposure-){.section-name .selfRef} {#name-threatkeyexposure-exposure-}

[]{.break}

Classification:
:   all types[¶](#section-4.2.16-1.2){.pilcrow}
:   

If a third party obtains a key or even indirect access to a key \-- for
example, in a hardware security module (HSM) \-- then they can perform
the same actions as the legitimate owner of the key. If the key is
trusted for firmware updates, then the third party can perform firmware
updates as though they were the legitimate owner of the
key.[¶](#section-4.2.16-2){.pilcrow}

For example, if manifest signing is performed on a server connected to
the internet, an attacker may compromise the server and then be able to
sign manifests, even if the keys for manifest signing are held in an HSM
that is accessed by the server.[¶](#section-4.2.16-3){.pilcrow}

[]{.break}

Mitigated by:
:   [REQ.SEC.KEY.PROTECTION](#req-sec-key-protection){.xref} ([Section
    4.3.17](#req-sec-key-protection){.xref}),
    [REQ.SEC.KEY.ROTATION](#req-sec-key-rotation){.xref} ([Section
    4.3.18](#req-sec-key-rotation){.xref})[¶](#section-4.2.16-4.2){.pilcrow}
:   
:::
:::

::: {#threat-mfst-modification}
::: {#section-4.2.17 .section}
#### [4.2.17.](#section-4.2.17){.section-number .selfRef} [THREAT.MFST.MODIFICATION: Modification of Manifest or Payload prior to Signing](#name-threatmfstmodification-modi){.section-name .selfRef} {#name-threatmfstmodification-modi}

[]{.break}

Classification:
:   all types[¶](#section-4.2.17-1.2){.pilcrow}
:   

If an attacker can alter a manifest or payload before it is signed, they
can perform all the same actions as the manifest author. This allows the
attacker to deploy firmware updates to any devices that trust the
manifest author. If an attacker can modify the code of a payload before
the corresponding manifest is created, they can insert their own code.
If an attacker can modify the manifest before it is signed, they can
redirect the manifest to their own
payload.[¶](#section-4.2.17-2){.pilcrow}

For example, the attacker deploys malware to the developer\'s computer
or signing service that watches manifest creation activities and inserts
code into any binary that is referenced by a
manifest.[¶](#section-4.2.17-3){.pilcrow}

For example, the attacker deploys malware to the developer\'s computer
or signing service that replaces the referenced binary (digest) and URI
with the attacker\'s binary (digest) and
URI.[¶](#section-4.2.17-4){.pilcrow}

[]{.break}

Mitigated by:
:   [REQ.SEC.MFST.CHECK](#req-sec-mfst-check){.xref} ([Section
    4.3.19](#req-sec-mfst-check){.xref}),
    [REQ.SEC.MFST.TRUSTED](#req-sec-mfst-trusted){.xref} ([Section
    4.3.20](#req-sec-mfst-trusted){.xref})[¶](#section-4.2.17-5.2){.pilcrow}
:   
:::
:::

::: {#threat-mfst-toctou}
::: {#section-4.2.18 .section}
#### [4.2.18.](#section-4.2.18){.section-number .selfRef} [THREAT.MFST.TOCTOU: Modification of Manifest between Authentication and Use](#name-threatmfsttoctou-modificati){.section-name .selfRef} {#name-threatmfsttoctou-modificati}

[]{.break}

Classification:
:   all types[¶](#section-4.2.18-1.2){.pilcrow}
:   

If an attacker can modify a manifest after it is authenticated (time of
check) but before it is used (time of use), then the attacker can place
any content whatsoever in the manifest.[¶](#section-4.2.18-2){.pilcrow}

[]{.break}

Mitigated by:
:   [REQ.SEC.MFST.CONST](#req-sec-mfst-const){.xref} ([Section
    4.3.21](#req-sec-mfst-const){.xref})[¶](#section-4.2.18-3.2){.pilcrow}
:   
:::
:::
:::
:::

::: {#security-requirements}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Security Requirements](#name-security-requirements){.section-name .selfRef} {#name-security-requirements}

The security requirements here are a set of policies that mitigate the
threats described in [Section
4.1](#threat-model){.xref}.[¶](#section-4.3-1){.pilcrow}

::: {#req-sec-sequence}
::: {#section-4.3.1 .section}
#### [4.3.1.](#section-4.3.1){.section-number .selfRef} [REQ.SEC.SEQUENCE: Monotonic Sequence Numbers](#name-reqsecsequence-monotonic-se){.section-name .selfRef} {#name-reqsecsequence-monotonic-se}

Only an actor with firmware installation authority is permitted to
decide when device firmware can be installed. To enforce this rule,
manifests [MUST]{.bcp14} contain monotonically increasing sequence
numbers. Manifests may use UTC epoch timestamps to coordinate
monotonically increasing sequence numbers across many actors in many
locations. If UTC epoch timestamps are used, they must not be treated as
times; they must be treated only as sequence numbers. Devices must
reject manifests with sequence numbers smaller than any onboard sequence
number, i.e., there is no sequence number
rollover.[¶](#section-4.3.1-1){.pilcrow}

Note: This is not a firmware version field. It is a manifest sequence
number. A firmware version may be rolled back by creating a new manifest
for the old firmware version with a later sequence
number.[¶](#section-4.3.1-2.1){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.IMG.EXPIRED](#threat-expired){.xref} ([Section
    4.2.1](#threat-expired){.xref})[¶](#section-4.3.1-3.2){.pilcrow}
:   

Implemented by:
:   [Monotonic Sequence Number](#element-sequence-number){.xref}
    ([Section
    3.2](#element-sequence-number){.xref})[¶](#section-4.3.1-3.4){.pilcrow}
:   
:::
:::

::: {#req-sec-compatible}
::: {#section-4.3.2 .section}
#### [4.3.2.](#section-4.3.2){.section-number .selfRef} [REQ.SEC.COMPATIBLE: Vendor, Device-Type Identifiers](#name-reqseccompatible-vendor-dev){.section-name .selfRef} {#name-reqseccompatible-vendor-dev}

Devices [MUST]{.bcp14} only apply firmware that is intended for them.
Devices must know that a given update applies to their vendor, model,
hardware revision, and software revision. Human-readable identifiers are
often prone to error in this regard, so unique identifiers should be
used instead.[¶](#section-4.3.2-1){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.IMG.INCOMPATIBLE](#threat-incompatible){.xref} ([Section
    4.2.3](#threat-incompatible){.xref})[¶](#section-4.3.2-2.2){.pilcrow}
:   

Implemented by:
:   [Vendor ID Condition](#element-vendor-id){.xref} ([Section
    3.3](#element-vendor-id){.xref}), [Class ID
    Condition](#element-class-id){.xref} ([Section
    3.4](#element-class-id){.xref})[¶](#section-4.3.2-2.4){.pilcrow}
:   
:::
:::

::: {#req-sec-exp}
::: {#section-4.3.3 .section}
#### [4.3.3.](#section-4.3.3){.section-number .selfRef} [REQ.SEC.EXP: Expiration Time](#name-reqsecexp-expiration-time){.section-name .selfRef} {#name-reqsecexp-expiration-time}

A firmware manifest [MAY]{.bcp14} expire after a given time, and devices
may have a secure clock (local or remote). If a secure clock is provided
and the firmware manifest has an expiration timestamp, the device must
reject the manifest if the current time is later than the expiration
time.[¶](#section-4.3.3-1){.pilcrow}

Special consideration is required for end-of-life in cases where a
device will not be updated again \-- for example, if a business stops
issuing updates for a device. The last valid firmware should not have an
expiration time.[¶](#section-4.3.3-2){.pilcrow}

If a device has a flawed time source (either local or remote), an old
update can be deployed as new.[¶](#section-4.3.3-3){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.IMG.EXPIRED.OFFLINE](#threat-expired-offline){.xref}
    ([Section
    4.2.2](#threat-expired-offline){.xref})[¶](#section-4.3.3-4.2){.pilcrow}
:   

Implemented by:
:   [Expiration Time](#manifest-element-expiration){.xref} ([Section
    3.7](#manifest-element-expiration){.xref})[¶](#section-4.3.3-4.4){.pilcrow}
:   
:::
:::

::: {#req-sec-authentic}
::: {#section-4.3.4 .section}
#### [4.3.4.](#section-4.3.4){.section-number .selfRef} [REQ.SEC.AUTHENTIC: Cryptographic Authenticity](#name-reqsecauthentic-cryptograph){.section-name .selfRef} {#name-reqsecauthentic-cryptograph}

The authenticity of an update [MUST]{.bcp14} be demonstrable. Typically,
this means that updates must be digitally signed. Because the manifest
contains information about how to install the update, the manifest\'s
authenticity must also be demonstrable. To reduce the overhead required
for validation, the manifest contains the cryptographic digest of the
firmware image, rather than a second digital signature. The authenticity
of the manifest can be verified with a digital signature or Message
Authentication Code. The authenticity of the firmware image is tied to
the manifest by the use of a cryptographic digest of the firmware
image.[¶](#section-4.3.4-1){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.IMG.NON_AUTH](#threat-img-unauthenticated){.xref} ([Section
    4.2.9](#threat-img-unauthenticated){.xref}),
    [THREAT.NET.ONPATH](#threat-net-onpath){.xref} ([Section
    4.2.7](#threat-net-onpath){.xref})[¶](#section-4.3.4-2.2){.pilcrow}
:   

Implemented by:
:   [Signature](#manifest-element-signature){.xref} ([Section
    3.15](#manifest-element-signature){.xref}), [Payload
    Digests](#manifest-element-payload-digest){.xref} ([Section
    3.13](#manifest-element-payload-digest){.xref})[¶](#section-4.3.4-2.4){.pilcrow}
:   
:::
:::

::: {#req-sec-authentic-image-type}
::: {#section-4.3.5 .section}
#### [4.3.5.](#section-4.3.5){.section-number .selfRef} [REQ.SEC.AUTH.IMG_TYPE: Authenticated Payload Type](#name-reqsecauthimg_type-authenti){.section-name .selfRef} {#name-reqsecauthimg_type-authenti}

The type of payload [MUST]{.bcp14} be authenticated. For example, the
target must know whether the payload is XIP firmware, a loadable module,
or configuration data.[¶](#section-4.3.5-1){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.IMG.FORMAT](#threat-img-format){.xref} ([Section
    4.2.4](#threat-img-format){.xref})[¶](#section-4.3.5-2.2){.pilcrow}
:   

Implemented by:
:   [Payload Format](#manifest-element-format){.xref} ([Section
    3.8](#manifest-element-format){.xref}),
    [Signature](#manifest-element-signature){.xref} ([Section
    3.15](#manifest-element-signature){.xref})[¶](#section-4.3.5-2.4){.pilcrow}
:   
:::
:::

::: {#req-sec-authentic-image-location}
::: {#section-4.3.6 .section}
#### [4.3.6.](#section-4.3.6){.section-number .selfRef} [REQ.SEC.AUTH.IMG_LOC: Authenticated Storage Location](#name-reqsecauthimg_loc-authentic){.section-name .selfRef} {#name-reqsecauthimg_loc-authentic}

The location on the target where the payload is to be stored
[MUST]{.bcp14} be authenticated.[¶](#section-4.3.6-1){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.IMG.LOCATION](#threat-img-location){.xref} ([Section
    4.2.5](#threat-img-location){.xref})[¶](#section-4.3.6-2.2){.pilcrow}
:   

Implemented by:
:   [Storage Location](#maniest-element-storage-location){.xref}
    ([Section
    3.10](#maniest-element-storage-location){.xref})[¶](#section-4.3.6-2.4){.pilcrow}
:   
:::
:::

::: {#req-sec-authenticated-remote-payload}
::: {#section-4.3.7 .section}
#### [4.3.7.](#section-4.3.7){.section-number .selfRef} [REQ.SEC.AUTH.REMOTE_LOC: Authenticated Remote Payload](#name-reqsecauthremote_loc-authen){.section-name .selfRef} {#name-reqsecauthremote_loc-authen}

The location where a target should find a payload [MUST]{.bcp14} be
authenticated. Remote resources need to receive an equal amount of
cryptographic protection as the manifest itself, when dereferencing
URIs. The security considerations of Uniform Resource Identifiers (URIs)
are applicable
\[[RFC3986](#RFC3986){.xref}\].[¶](#section-4.3.7-1){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.NET.REDIRECT](#threat-net-redirect){.xref} ([Section
    4.2.6](#threat-net-redirect){.xref}),
    [THREAT.NET.ONPATH](#threat-net-onpath){.xref} ([Section
    4.2.7](#threat-net-onpath){.xref})[¶](#section-4.3.7-2.2){.pilcrow}
:   

Implemented by:
:   [Payload Indicator](#manifest-element-payload-indicator){.xref}
    ([Section
    3.12](#manifest-element-payload-indicator){.xref})[¶](#section-4.3.7-2.4){.pilcrow}
:   
:::
:::

::: {#req-sec-authentic-execution}
::: {#section-4.3.8 .section}
#### [4.3.8.](#section-4.3.8){.section-number .selfRef} [REQ.SEC.AUTH.EXEC: Secure Execution](#name-reqsecauthexec-secure-execu){.section-name .selfRef} {#name-reqsecauthexec-secure-execu}

The target [SHOULD]{.bcp14} verify firmware at the time of boot. This
requires authenticated payload size and firmware
digest.[¶](#section-4.3.8-1){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.IMG.REPLACE](#threat-image-replacement){.xref} ([Section
    4.2.8](#threat-image-replacement){.xref})[¶](#section-4.3.8-2.2){.pilcrow}
:   

Implemented by:
:   [Payload Digests](#manifest-element-payload-digest){.xref} ([Section
    3.13](#manifest-element-payload-digest){.xref}),
    [Size](#manifest-element-size){.xref} ([Section
    3.14](#manifest-element-size){.xref})[¶](#section-4.3.8-2.4){.pilcrow}
:   
:::
:::

::: {#req-sec-authentic-precursor}
::: {#section-4.3.9 .section}
#### [4.3.9.](#section-4.3.9){.section-number .selfRef} [REQ.SEC.AUTH.PRECURSOR: Authenticated Precursor Images](#name-reqsecauthprecursor-authent){.section-name .selfRef} {#name-reqsecauthprecursor-authent}

If an update uses a differential compression method, it [MUST]{.bcp14}
specify the digest of the precursor image, and that digest
[MUST]{.bcp14} be authenticated.[¶](#section-4.3.9-1){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.UPD.WRONG_PRECURSOR](#threat-upd-wrong-precursor){.xref}
    ([Section
    4.2.10](#threat-upd-wrong-precursor){.xref})[¶](#section-4.3.9-2.2){.pilcrow}
:   

Implemented by:
:   [Precursor Image Digest](#element-precursor-digest){.xref} ([Section
    3.5](#element-precursor-digest){.xref})[¶](#section-4.3.9-2.4){.pilcrow}
:   
:::
:::

::: {#req-sec-authentic-compatibility}
::: {#section-4.3.10 .section}
#### [4.3.10.](#section-4.3.10){.section-number .selfRef} [REQ.SEC.AUTH.COMPATIBILITY: Authenticated Vendor and Class IDs](#name-reqsecauthcompatibility-aut){.section-name .selfRef} {#name-reqsecauthcompatibility-aut}

The identifiers that specify firmware compatibility [MUST]{.bcp14} be
authenticated to ensure that only compatible firmware is installed on a
target device.[¶](#section-4.3.10-1){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.IMG.INCOMPATIBLE](#threat-incompatible){.xref} ([Section
    4.2.3](#threat-incompatible){.xref})[¶](#section-4.3.10-2.2){.pilcrow}
:   

Implemented by:
:   [Vendor ID Condition](#element-vendor-id){.xref} ([Section
    3.3](#element-vendor-id){.xref}), [Class ID
    Condition](#element-class-id){.xref} ([Section
    3.4](#element-class-id){.xref})[¶](#section-4.3.10-2.4){.pilcrow}
:   
:::
:::

::: {#req-sec-rights}
::: {#section-4.3.11 .section}
#### [4.3.11.](#section-4.3.11){.section-number .selfRef} [REQ.SEC.RIGHTS: Rights Require Authenticity](#name-reqsecrights-rights-require){.section-name .selfRef} {#name-reqsecrights-rights-require}

If a device grants different rights to different actors, exercising
those rights [MUST]{.bcp14} be accompanied by proof of those rights, in
the form of proof of authenticity. Authenticity mechanisms, such as
those required in [REQ.SEC.AUTHENTIC](#req-sec-authentic){.xref}
([Section 4.3.4](#req-sec-authentic){.xref}), can be used to prove
authenticity.[¶](#section-4.3.11-1){.pilcrow}

For example, if a device has a policy that requires that firmware have
both an Authorship right and a Qualification right and if that device
grants Authorship and Qualification rights to different parties, such as
a device operator and a network operator, respectively, then the
firmware cannot be installed without proof of rights from both the
device operator and the network
operator.[¶](#section-4.3.11-2){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.UPD.UNAPPROVED](#threat-upd-unapproved){.xref} ([Section
    4.2.11](#threat-upd-unapproved){.xref})[¶](#section-4.3.11-3.2){.pilcrow}
:   

Implemented by:
:   [Signature](#manifest-element-signature){.xref} ([Section
    3.15](#manifest-element-signature){.xref})[¶](#section-4.3.11-3.4){.pilcrow}
:   
:::
:::

::: {#req-sec-image-confidentiality}
::: {#section-4.3.12 .section}
#### [4.3.12.](#section-4.3.12){.section-number .selfRef} [REQ.SEC.IMG.CONFIDENTIALITY: Payload Encryption](#name-reqsecimgconfidentiality-pa){.section-name .selfRef} {#name-reqsecimgconfidentiality-pa}

The manifest information model [MUST]{.bcp14} enable encrypted payloads.
Encryption helps to prevent third parties, including attackers, from
reading the content of the firmware image. This can protect against
confidential information disclosures and discovery of vulnerabilities
through reverse engineering. Therefore, the manifest must convey the
information required to allow an intended recipient to decrypt an
encrypted payload.[¶](#section-4.3.12-1){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.IMG.DISCLOSURE](#threat-img-disclosure){.xref} ([Section
    4.2.12](#threat-img-disclosure){.xref}),
    [THREAT.NET.ONPATH](#threat-net-onpath){.xref} ([Section
    4.2.7](#threat-net-onpath){.xref})[¶](#section-4.3.12-2.2){.pilcrow}
:   

Implemented by:
:   [Encryption Wrapper](#manifest-element-encryption-wrapper){.xref}
    ([Section
    3.20](#manifest-element-encryption-wrapper){.xref})[¶](#section-4.3.12-2.4){.pilcrow}
:   
:::
:::

::: {#req-sec-access-control}
::: {#section-4.3.13 .section}
#### [4.3.13.](#section-4.3.13){.section-number .selfRef} [REQ.SEC.ACCESS_CONTROL: Access Control](#name-reqsecaccess_control-access){.section-name .selfRef} {#name-reqsecaccess_control-access}

If a device grants different rights to different actors, then an
exercise of those rights [MUST]{.bcp14} be validated against a list of
rights for the actor. This typically takes the form of an Access Control
List (ACL). ACLs are applied to two
scenarios:[¶](#section-4.3.13-1){.pilcrow}

1.  [An ACL decides which elements of the manifest may be overridden and
    by which
    actors.[¶](#section-4.3.13-2.1){.pilcrow}]{#section-4.3.13-2.1}
2.  [An ACL decides which component identifier / storage identifier
    pairs can be written by which
    actors.[¶](#section-4.3.13-2.2){.pilcrow}]{#section-4.3.13-2.2}

[]{.break}

Mitigates:
:   [THREAT.MFST.OVERRIDE](#threat-mfst-override){.xref} ([Section
    4.2.13](#threat-mfst-override){.xref}),
    [THREAT.UPD.UNAPPROVED](#threat-upd-unapproved){.xref} ([Section
    4.2.11](#threat-upd-unapproved){.xref})[¶](#section-4.3.13-3.2){.pilcrow}
:   

Implemented by:
:   Client-side code, not specified in
    manifest[¶](#section-4.3.13-3.4){.pilcrow}
:   
:::
:::

::: {#req-sec-mfst-confidentiality}
::: {#section-4.3.14 .section}
#### [4.3.14.](#section-4.3.14){.section-number .selfRef} [REQ.SEC.MFST.CONFIDENTIALITY: Encrypted Manifests](#name-reqsecmfstconfidentiality-e){.section-name .selfRef} {#name-reqsecmfstconfidentiality-e}

A manifest format [MUST]{.bcp14} allow encryption of selected parts of
the manifest or encryption of the entire manifest to prevent sensitive
content of the firmware metadata from being
leaked.[¶](#section-4.3.14-1){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.MFST.EXPOSURE](#threat-mfst-exposure){.xref} ([Section
    4.2.14](#threat-mfst-exposure){.xref}),
    [THREAT.NET.ONPATH](#threat-net-onpath){.xref} ([Section
    4.2.7](#threat-net-onpath){.xref})[¶](#section-4.3.14-2.2){.pilcrow}
:   

Implemented by:
:   Manifest Encryption Wrapper / Transport
    Security[¶](#section-4.3.14-2.4){.pilcrow}
:   
:::
:::

::: {#req-sec-img-complete-digest}
::: {#section-4.3.15 .section}
#### [4.3.15.](#section-4.3.15){.section-number .selfRef} [REQ.SEC.IMG.COMPLETE_DIGEST: Whole Image Digest](#name-reqsecimgcomplete_digest-wh){.section-name .selfRef} {#name-reqsecimgcomplete_digest-wh}

The digest [SHOULD]{.bcp14} cover all available space in a fixed-size
storage location. Variable-size storage locations [MUST]{.bcp14} be
restricted to exactly the size of deployed payload. This prevents any
data from being distributed without being covered by the digest. For
example, XIP microcontrollers typically have fixed-size storage. These
devices should deploy a digest that covers the deployed firmware image,
concatenated with the default erased value of any remaining
space.[¶](#section-4.3.15-1){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.IMG.EXTRA](#threat-img-extra){.xref} ([Section
    4.2.15](#threat-img-extra){.xref})[¶](#section-4.3.15-2.2){.pilcrow}
:   

Implemented by:
:   [Payload Digests](#manifest-element-payload-digest){.xref} ([Section
    3.13](#manifest-element-payload-digest){.xref})[¶](#section-4.3.15-2.4){.pilcrow}
:   
:::
:::

::: {#req-sec-reporting}
::: {#section-4.3.16 .section}
#### [4.3.16.](#section-4.3.16){.section-number .selfRef} [REQ.SEC.REPORTING: Secure Reporting](#name-reqsecreporting-secure-repo){.section-name .selfRef} {#name-reqsecreporting-secure-repo}

Status reports from the device to any remote system [MUST]{.bcp14} be
performed over an authenticated, confidential channel in order to
prevent modification or spoofing of the
reports.[¶](#section-4.3.16-1){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.NET.ONPATH](#threat-net-onpath){.xref} ([Section
    4.2.7](#threat-net-onpath){.xref})[¶](#section-4.3.16-2.2){.pilcrow}
:   

Implemented by:
:   Transport Security / Manifest format triggering generation of
    reports[¶](#section-4.3.16-2.4){.pilcrow}
:   
:::
:::

::: {#req-sec-key-protection}
::: {#section-4.3.17 .section}
#### [4.3.17.](#section-4.3.17){.section-number .selfRef} [REQ.SEC.KEY.PROTECTION: Protected Storage of Signing Keys](#name-reqseckeyprotection-protect){.section-name .selfRef} {#name-reqseckeyprotection-protect}

Cryptographic keys for signing/authenticating manifests [SHOULD]{.bcp14}
be stored in a manner that is inaccessible to networked devices \-- for
example, in an HSM or an air-gapped computer. This protects against an
attacker obtaining the keys.[¶](#section-4.3.17-1){.pilcrow}

Keys [SHOULD]{.bcp14} be stored in a way that limits the risk of a
legitimate, but compromised, entity (such as a server or developer
computer) issuing signing requests.[¶](#section-4.3.17-2){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.KEY.EXPOSURE](#threat-key-exposure){.xref} ([Section
    4.2.16](#threat-key-exposure){.xref})[¶](#section-4.3.17-3.2){.pilcrow}
:   

Implemented by:
:   Hardware-assisted isolation technologies, which are outside the
    scope of the manifest format[¶](#section-4.3.17-3.4){.pilcrow}
:   
:::
:::

::: {#req-sec-key-rotation}
::: {#section-4.3.18 .section}
#### [4.3.18.](#section-4.3.18){.section-number .selfRef} [REQ.SEC.KEY.ROTATION: Protected Storage of Signing Keys](#name-reqseckeyrotation-protected){.section-name .selfRef} {#name-reqseckeyrotation-protected}

Cryptographic keys for signing/authenticating manifests [SHOULD]{.bcp14}
be replaced from time to time. Because it is difficult and risky to
replace a trust anchor, keys used for signing updates [SHOULD]{.bcp14}
be delegates of that trust anchor.[¶](#section-4.3.18-1){.pilcrow}

If key expiration is performed based on time, then a secure clock is
needed. If the time source used by a recipient to check for expiration
is flawed, an old signing key can be used as current, which compounds
[THREAT.KEY.EXPOSURE](#threat-key-exposure){.xref} ([Section
4.2.16](#threat-key-exposure){.xref}).[¶](#section-4.3.18-2){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.KEY.EXPOSURE](#threat-key-exposure){.xref} ([Section
    4.2.16](#threat-key-exposure){.xref})[¶](#section-4.3.18-3.2){.pilcrow}
:   

Implemented by:
:   Secure storage technology, which is a system design/implementation
    aspect outside the scope of the manifest
    format[¶](#section-4.3.18-3.4){.pilcrow}
:   
:::
:::

::: {#req-sec-mfst-check}
::: {#section-4.3.19 .section}
#### [4.3.19.](#section-4.3.19){.section-number .selfRef} [REQ.SEC.MFST.CHECK: Validate Manifests prior to Deployment](#name-reqsecmfstcheck-validate-ma){.section-name .selfRef} {#name-reqsecmfstcheck-validate-ma}

Manifests [SHOULD]{.bcp14} be verified prior to deployment. This reduces
problems that may arise with devices installing firmware images that
damage devices unintentionally.[¶](#section-4.3.19-1){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.MFST.MODIFICATION](#threat-mfst-modification){.xref}
    ([Section
    4.2.17](#threat-mfst-modification){.xref})[¶](#section-4.3.19-2.2){.pilcrow}
:   

Implemented by:
:   Testing infrastructure. While outside the scope of the manifest
    format, proper testing of low-level software is essential for
    avoiding unnecessary downtime or worse
    situations.[¶](#section-4.3.19-2.4){.pilcrow}
:   
:::
:::

::: {#req-sec-mfst-trusted}
::: {#section-4.3.20 .section}
#### [4.3.20.](#section-4.3.20){.section-number .selfRef} [REQ.SEC.MFST.TRUSTED: Construct Manifests in a Trusted Environment](#name-reqsecmfsttrusted-construct){.section-name .selfRef} {#name-reqsecmfsttrusted-construct}

For high-risk deployments, such as large numbers of devices or devices
that provide critical functions, manifests [SHOULD]{.bcp14} be
constructed in an environment that is protected from interference, such
as an air-gapped computer. Note that a networked computer connected to
an HSM does not fulfill this requirement (see
[THREAT.MFST.MODIFICATION](#threat-mfst-modification){.xref} ([Section
4.2.17](#threat-mfst-modification){.xref})).[¶](#section-4.3.20-1){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.MFST.MODIFICATION](#threat-mfst-modification){.xref}
    ([Section
    4.2.17](#threat-mfst-modification){.xref})[¶](#section-4.3.20-2.2){.pilcrow}
:   

Implemented by:
:   Physical and network security for protecting the environment where
    firmware updates are prepared to avoid unauthorized access to this
    infrastructure[¶](#section-4.3.20-2.4){.pilcrow}
:   
:::
:::

::: {#req-sec-mfst-const}
::: {#section-4.3.21 .section}
#### [4.3.21.](#section-4.3.21){.section-number .selfRef} [REQ.SEC.MFST.CONST: Manifest Kept Immutable between Check and Use](#name-reqsecmfstconst-manifest-ke){.section-name .selfRef} {#name-reqsecmfstconst-manifest-ke}

Both the manifest and any data extracted from it [MUST]{.bcp14} be held
immutable between its authenticity verification (time of check) and its
use (time of use). To make this guarantee, the manifest [MUST]{.bcp14}
fit within internal memory or secure memory, such as encrypted memory.
The recipient [SHOULD]{.bcp14} defend the manifest from tampering by
code or hardware resident in the recipient \-- for example, other
processes or debuggers.[¶](#section-4.3.21-1){.pilcrow}

If an application requires that the manifest be verified before storing
it, then this means the manifest [MUST]{.bcp14} fit in
RAM.[¶](#section-4.3.21-2){.pilcrow}

[]{.break}

Mitigates:
:   [THREAT.MFST.TOCTOU](#threat-mfst-toctou){.xref} ([Section
    4.2.18](#threat-mfst-toctou){.xref})[¶](#section-4.3.21-3.2){.pilcrow}
:   

Implemented by:
:   Proper system design with sufficient resources and implementation
    avoiding TOCTOU attacks[¶](#section-4.3.21-3.4){.pilcrow}
:   
:::
:::
:::
:::

::: {#user-stories}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [User Stories](#name-user-stories){.section-name .selfRef} {#name-user-stories}

User stories provide expected use cases. These are used to feed into
usability requirements.[¶](#section-4.4-1){.pilcrow}

::: {#user-story-install-instructions}
::: {#section-4.4.1 .section}
#### [4.4.1.](#section-4.4.1){.section-number .selfRef} [USER_STORY.INSTALL.INSTRUCTIONS: Installation Instructions](#name-user_storyinstallinstructio){.section-name .selfRef} {#name-user_storyinstallinstructio}

As a device operator, I want to provide my devices with additional
installation instructions so that I can keep process details out of my
payload data.[¶](#section-4.4.1-1){.pilcrow}

Some installation instructions might be as
follows:[¶](#section-4.4.1-2){.pilcrow}

-   [Use a table of hashes to ensure that each block of the payload is
    validated before
    writing.[¶](#section-4.4.1-3.1){.pilcrow}]{#section-4.4.1-3.1}
-   [Do not report
    progress.[¶](#section-4.4.1-3.2){.pilcrow}]{#section-4.4.1-3.2}
-   [Pre-cache the update, but do not
    install.[¶](#section-4.4.1-3.3){.pilcrow}]{#section-4.4.1-3.3}
-   [Install the pre-cached update matching this
    manifest.[¶](#section-4.4.1-3.4){.pilcrow}]{#section-4.4.1-3.4}
-   [Install this update immediately, overriding any long-running
    tasks.[¶](#section-4.4.1-3.5){.pilcrow}]{#section-4.4.1-3.5}

[]{.break}

Satisfied by:
:   [REQ.USE.MFST.PRE_CHECK](#req-use-mfst-pre-check){.xref} ([Section
    4.5.1](#req-use-mfst-pre-check){.xref})[¶](#section-4.4.1-4.2){.pilcrow}
:   
:::
:::

::: {#user-story-fail-early}
::: {#section-4.4.2 .section}
#### [4.4.2.](#section-4.4.2){.section-number .selfRef} [USER_STORY.MFST.FAIL_EARLY: Fail Early](#name-user_storymfstfail_early-fa){.section-name .selfRef} {#name-user_storymfstfail_early-fa}

As a designer of a resource-constrained IoT device, I want bad updates
to fail as early as possible to preserve battery life and limit consumed
bandwidth.[¶](#section-4.4.2-1){.pilcrow}

[]{.break}

Satisfied by:
:   [REQ.USE.MFST.PRE_CHECK](#req-use-mfst-pre-check){.xref} ([Section
    4.5.1](#req-use-mfst-pre-check){.xref})[¶](#section-4.4.2-2.2){.pilcrow}
:   
:::
:::

::: {#user-story-override}
::: {#section-4.4.3 .section}
#### [4.4.3.](#section-4.4.3){.section-number .selfRef} [USER_STORY.OVERRIDE: Override Non-critical Manifest Elements](#name-user_storyoverride-override){.section-name .selfRef} {#name-user_storyoverride-override}

As a device operator, I would like to be able to override the
non-critical information in the manifest so that I can control my
devices more precisely. The authority to override this information is
provided via the installation of a limited trust anchor by another
authority.[¶](#section-4.4.3-1){.pilcrow}

Some examples of potentially overridable
information:[¶](#section-4.4.3-2){.pilcrow}

[]{.break}

[URIs](#manifest-element-payload-indicator){.xref} ([Section 3.12](#manifest-element-payload-indicator){.xref}):
:   This allows the device operator to direct devices to their own
    infrastructure in order to reduce network
    load.[¶](#section-4.4.3-3.2){.pilcrow}
:   

Conditions:
:   This allows the device operator to impose additional constraints on
    the installation of the manifest.[¶](#section-4.4.3-3.4){.pilcrow}
:   

[Directives](#manifest-element-additional-install-info){.xref} ([Section 3.16](#manifest-element-additional-install-info){.xref}):
:   This allows the device operator to add more instructions, such as
    time of installation.[¶](#section-4.4.3-3.6){.pilcrow}
:   

[Processing Steps](#manifest-element-processing-steps){.xref} ([Section 3.9](#manifest-element-processing-steps){.xref}):
:   If an intermediary performs an action on behalf of a device, it may
    need to override the processing steps. It is still possible for a
    device to verify the final content and the result of any processing
    step that specifies a digest. Some processing steps should be
    non-overridable.[¶](#section-4.4.3-3.8){.pilcrow}
:   

Satisfied by:
:   [REQ.USE.MFST.COMPONENT](#req-use-mfst-component){.xref} ([Section
    4.5.4](#req-use-mfst-component){.xref})[¶](#section-4.4.3-3.10){.pilcrow}
:   
:::
:::

::: {#user-story-component}
::: {#section-4.4.4 .section}
#### [4.4.4.](#section-4.4.4){.section-number .selfRef} [USER_STORY.COMPONENT: Component Update](#name-user_storycomponent-compone){.section-name .selfRef} {#name-user_storycomponent-compone}

As a device operator, I want to divide my firmware into components, so
that I can reduce the size of updates, make different parties
responsible for different components, and divide my firmware into
frequently updated and infrequently updated
components.[¶](#section-4.4.4-1){.pilcrow}

[]{.break}

Satisfied by:
:   [REQ.USE.MFST.COMPONENT](#req-use-mfst-component){.xref} ([Section
    4.5.4](#req-use-mfst-component){.xref})[¶](#section-4.4.4-2.2){.pilcrow}
:   
:::
:::

::: {#user-story-multi-auth}
::: {#section-4.4.5 .section}
#### [4.4.5.](#section-4.4.5){.section-number .selfRef} [USER_STORY.MULTI_AUTH: Multiple Authorizations](#name-user_storymulti_auth-multip){.section-name .selfRef} {#name-user_storymulti_auth-multip}

As a device operator, I want to ensure the quality of a firmware update
before installing it, so that I can ensure interoperability of all
devices in my product family. I want to restrict the ability to make
changes to my devices to require my express
approval.[¶](#section-4.4.5-1){.pilcrow}

[]{.break}

Satisfied by:
:   [REQ.USE.MFST.MULTI_AUTH](#req-use-mfst-multi-auth){.xref} ([Section
    4.5.5](#req-use-mfst-multi-auth){.xref}),
    [REQ.SEC.ACCESS_CONTROL](#req-sec-access-control){.xref} ([Section
    4.3.13](#req-sec-access-control){.xref})[¶](#section-4.4.5-2.2){.pilcrow}
:   
:::
:::

::: {#user-story-img-format}
::: {#section-4.4.6 .section}
#### [4.4.6.](#section-4.4.6){.section-number .selfRef} [USER_STORY.IMG.FORMAT: Multiple Payload Formats](#name-user_storyimgformat-multipl){.section-name .selfRef} {#name-user_storyimgformat-multipl}

As a device operator, I want to be able to send multiple payload formats
to suit the needs of my update, so that I can optimize the bandwidth
used by my devices.[¶](#section-4.4.6-1){.pilcrow}

[]{.break}

Satisfied by:
:   [REQ.USE.IMG.FORMAT](#req-use-img-format){.xref} ([Section
    4.5.6](#req-use-img-format){.xref})[¶](#section-4.4.6-2.2){.pilcrow}
:   
:::
:::

::: {#user-story-img-confidentiality}
::: {#section-4.4.7 .section}
#### [4.4.7.](#section-4.4.7){.section-number .selfRef} [USER_STORY.IMG.CONFIDENTIALITY: Prevent Confidential Information Disclosures](#name-user_storyimgconfidentialit){.section-name .selfRef} {#name-user_storyimgconfidentialit}

As a firmware author, I want to prevent confidential information in the
manifest from being disclosed when distributing manifests and firmware
images. Confidential information may include information about the
device these updates are being applied to as well as information in the
firmware image itself.[¶](#section-4.4.7-1){.pilcrow}

[]{.break}

Satisfied by:
:   [REQ.SEC.IMG.CONFIDENTIALITY](#req-sec-image-confidentiality){.xref}
    ([Section
    4.3.12](#req-sec-image-confidentiality){.xref})[¶](#section-4.4.7-2.2){.pilcrow}
:   
:::
:::

::: {#user-story-img-unknown-format}
::: {#section-4.4.8 .section}
#### [4.4.8.](#section-4.4.8){.section-number .selfRef} [USER_STORY.IMG.UNKNOWN_FORMAT: Prevent Devices from Unpacking Unknown Formats](#name-user_storyimgunknown_format){.section-name .selfRef} {#name-user_storyimgunknown_format}

As a device operator, I want devices to determine whether they can
process a payload prior to downloading
it.[¶](#section-4.4.8-1){.pilcrow}

In some cases, it may be desirable for a third party to perform some
processing on behalf of a target. For this to occur, the third party
[MUST]{.bcp14} indicate what processing occurred and how to verify it
against the Trust Provisioning Authority\'s
intent.[¶](#section-4.4.8-2){.pilcrow}

This amounts to overriding [Processing
Steps](#manifest-element-processing-steps){.xref} ([Section
3.9](#manifest-element-processing-steps){.xref}) and [Payload
Indicator](#manifest-element-payload-indicator){.xref} ([Section
3.12](#manifest-element-payload-indicator){.xref}).[¶](#section-4.4.8-3){.pilcrow}

[]{.break}

Satisfied by:
:   [REQ.USE.IMG.FORMAT](#req-use-img-format){.xref} ([Section
    4.5.6](#req-use-img-format){.xref}),
    [REQ.USE.IMG.NESTED](#req-use-img-nested){.xref} ([Section
    4.5.7](#req-use-img-nested){.xref}),
    [REQ.USE.MFST.OVERRIDE_REMOTE](#req-use-mfst-override){.xref}
    ([Section
    4.5.3](#req-use-mfst-override){.xref})[¶](#section-4.4.8-4.2){.pilcrow}
:   
:::
:::

::: {#user-story-img-current-version}
::: {#section-4.4.9 .section}
#### [4.4.9.](#section-4.4.9){.section-number .selfRef} [USER_STORY.IMG.CURRENT_VERSION: Specify Version Numbers of Target Firmware](#name-user_storyimgcurrent_versio){.section-name .selfRef} {#name-user_storyimgcurrent_versio}

As a device operator, I want to be able to target devices for updates
based on their current firmware version, so that I can control which
versions are replaced with a single
manifest.[¶](#section-4.4.9-1){.pilcrow}

[]{.break}

Satisfied by:
:   [REQ.USE.IMG.VERSIONS](#req-use-img-versions){.xref} ([Section
    4.5.8](#req-use-img-versions){.xref})[¶](#section-4.4.9-2.2){.pilcrow}
:   
:::
:::

::: {#user-story-img-select}
::: {#section-4.4.10 .section}
#### [4.4.10.](#section-4.4.10){.section-number .selfRef} [USER_STORY.IMG.SELECT: Enable Devices to Choose between Images](#name-user_storyimgselect-enable-){.section-name .selfRef} {#name-user_storyimgselect-enable-}

As a developer, I want to be able to sign two or more versions of my
firmware in a single manifest so that I can use a very simple bootloader
that chooses between two or more images that are executed in
place.[¶](#section-4.4.10-1){.pilcrow}

[]{.break}

Satisfied by:
:   [REQ.USE.IMG.SELECT](#req-use-img-select){.xref} ([Section
    4.5.9](#req-use-img-select){.xref})[¶](#section-4.4.10-2.2){.pilcrow}
:   
:::
:::

::: {#user-story-exec-mfst}
::: {#section-4.4.11 .section}
#### [4.4.11.](#section-4.4.11){.section-number .selfRef} [USER_STORY.EXEC.MFST: Secure Execution Using Manifests](#name-user_storyexecmfst-secure-e){.section-name .selfRef} {#name-user_storyexecmfst-secure-e}

As a signer for both secure execution/boot and firmware deployment, I
would like to use the same signed document for both tasks so that my
data size is smaller, I can share common code, and I can reduce
signature verifications.[¶](#section-4.4.11-1){.pilcrow}

[]{.break}

Satisfied by:
:   [REQ.USE.EXEC](#req-use-exec){.xref} ([Section
    4.5.10](#req-use-exec){.xref})[¶](#section-4.4.11-2.2){.pilcrow}
:   
:::
:::

::: {#user-story-exec-decompress}
::: {#section-4.4.12 .section}
#### [4.4.12.](#section-4.4.12){.section-number .selfRef} [USER_STORY.EXEC.DECOMPRESS: Decompress on Load](#name-user_storyexecdecompress-de){.section-name .selfRef} {#name-user_storyexecdecompress-de}

As a developer of firmware for a run-from-RAM device, I would like to
use compressed images and to indicate to the bootloader that I am using
a compressed image in the manifest so that it can be used with secure
execution/boot.[¶](#section-4.4.12-1){.pilcrow}

[]{.break}

Satisfied by:
:   [REQ.USE.LOAD](#req-use-load){.xref} ([Section
    4.5.11](#req-use-load){.xref})[¶](#section-4.4.12-2.2){.pilcrow}
:   
:::
:::

::: {#user-story-mfst-img}
::: {#section-4.4.13 .section}
#### [4.4.13.](#section-4.4.13){.section-number .selfRef} [USER_STORY.MFST.IMG: Payload in Manifest](#name-user_storymfstimg-payload-i){.section-name .selfRef} {#name-user_storymfstimg-payload-i}

As an Operator of devices on a constrained network, I would like the
manifest to be able to include a small payload in the same packet so
that I can reduce network traffic.[¶](#section-4.4.13-1){.pilcrow}

Small payloads may include, for example, wrapped content encryption
keys, configuration information, public keys, authorization tokens, or
X.509 certificates.[¶](#section-4.4.13-2){.pilcrow}

[]{.break}

Satisfied by:
:   [REQ.USE.PAYLOAD](#req-use-payload){.xref} ([Section
    4.5.12](#req-use-payload){.xref})[¶](#section-4.4.13-3.2){.pilcrow}
:   
:::
:::

::: {#user-story-mfst-parse}
::: {#section-4.4.14 .section}
#### [4.4.14.](#section-4.4.14){.section-number .selfRef} [USER_STORY.MFST.PARSE: Simple Parsing](#name-user_storymfstparse-simple-){.section-name .selfRef} {#name-user_storymfstparse-simple-}

As a developer for constrained devices, I want a low-complexity library
for processing updates so that I can fit more application code on my
device.[¶](#section-4.4.14-1){.pilcrow}

[]{.break}

Satisfied by:
:   [REQ.USE.PARSE](#req-use-parse){.xref} ([Section
    4.5.13](#req-use-parse){.xref})[¶](#section-4.4.14-2.2){.pilcrow}
:   
:::
:::

::: {#user-story-mfst-delegation}
::: {#section-4.4.15 .section}
#### [4.4.15.](#section-4.4.15){.section-number .selfRef} [USER_STORY.MFST.DELEGATION: Delegated Authority in Manifest](#name-user_storymfstdelegation-de){.section-name .selfRef} {#name-user_storymfstdelegation-de}

As a device operator that rotates delegated authority more often than
delivering firmware updates, I would like to delegate a new authority
when I deliver a firmware update so that I can accomplish both tasks in
a single transmission.[¶](#section-4.4.15-1){.pilcrow}

[]{.break}

Satisfied by:
:   [REQ.USE.DELEGATION](#req-use-delegation){.xref} ([Section
    4.5.14](#req-use-delegation){.xref})[¶](#section-4.4.15-2.2){.pilcrow}
:   
:::
:::

::: {#user-story-mfst-pre-check}
::: {#section-4.4.16 .section}
#### [4.4.16.](#section-4.4.16){.section-number .selfRef} [USER_STORY.MFST.PRE_CHECK: Update Evaluation](#name-user_storymfstpre_check-upd){.section-name .selfRef} {#name-user_storymfstpre_check-upd}

As an Operator of a constrained network, I would like devices on my
network to be able to evaluate the suitability of an update prior to
initiating any large download so that I can prevent unnecessary
consumption of bandwidth.[¶](#section-4.4.16-1){.pilcrow}

[]{.break}

Satisfied by:
:   [REQ.USE.MFST.PRE_CHECK](#req-use-mfst-pre-check){.xref} ([Section
    4.5.1](#req-use-mfst-pre-check){.xref})[¶](#section-4.4.16-2.2){.pilcrow}
:   
:::
:::

::: {#user-story-mfst-admin}
::: {#section-4.4.17 .section}
#### [4.4.17.](#section-4.4.17){.section-number .selfRef} [USER_STORY.MFST.ADMINISTRATION: Administration of Manifests](#name-user_storymfstadministratio){.section-name .selfRef} {#name-user_storymfstadministratio}

As a device operator, I want to understand what an update will do and to
which devices it applies so that I can make informed choices about which
updates to apply, when to apply them, and which devices should be
updated.[¶](#section-4.4.17-1){.pilcrow}

[]{.break}

Satisfied by:
:   [REQ.USE.MFST.TEXT](#req-use-mfst-text){.xref} ([Section
    4.5.2](#req-use-mfst-text){.xref})[¶](#section-4.4.17-2.2){.pilcrow}
:   
:::
:::
:::
:::

::: {#usability-requirements}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [Usability Requirements](#name-usability-requirements){.section-name .selfRef} {#name-usability-requirements}

The following usability requirements satisfy the user stories listed
above.[¶](#section-4.5-1){.pilcrow}

::: {#req-use-mfst-pre-check}
::: {#section-4.5.1 .section}
#### [4.5.1.](#section-4.5.1){.section-number .selfRef} [REQ.USE.MFST.PRE_CHECK: Pre-installation Checks](#name-requsemfstpre_check-pre-ins){.section-name .selfRef} {#name-requsemfstpre_check-pre-ins}

A manifest format [MUST]{.bcp14} be able to carry all information
required to process an update.[¶](#section-4.5.1-1){.pilcrow}

For example, information about which precursor image is required for a
differential update must be placed in the
manifest.[¶](#section-4.5.1-2){.pilcrow}

[]{.break}

Satisfies:
:   [USER_STORY.MFST.PRE_CHECK](#user-story-mfst-pre-check){.xref}
    ([Section 4.4.16](#user-story-mfst-pre-check){.xref}),
    [USER_STORY.INSTALL.INSTRUCTIONS](#user-story-install-instructions){.xref}
    ([Section
    4.4.1](#user-story-install-instructions){.xref})[¶](#section-4.5.1-3.2){.pilcrow}
:   

Implemented by:
:   [Additional Installation
    Instructions](#manifest-element-additional-install-info){.xref}
    ([Section
    3.16](#manifest-element-additional-install-info){.xref})[¶](#section-4.5.1-3.4){.pilcrow}
:   
:::
:::

::: {#req-use-mfst-text}
::: {#section-4.5.2 .section}
#### [4.5.2.](#section-4.5.2){.section-number .selfRef} [REQ.USE.MFST.TEXT: Descriptive Manifest Information](#name-requsemfsttext-descriptive-){.section-name .selfRef} {#name-requsemfsttext-descriptive-}

It [MUST]{.bcp14} be possible for a device operator to determine what a
manifest will do and which devices will accept it prior to
distribution.[¶](#section-4.5.2-1){.pilcrow}

[]{.break}

Satisfies:
:   [USER_STORY.MFST.ADMINISTRATION](#user-story-mfst-admin){.xref}
    ([Section
    4.4.17](#user-story-mfst-admin){.xref})[¶](#section-4.5.2-2.2){.pilcrow}
:   

Implemented by:
:   [Manifest Text Information](#manifest-element-text){.xref} ([Section
    3.17](#manifest-element-text){.xref})[¶](#section-4.5.2-2.4){.pilcrow}
:   
:::
:::

::: {#req-use-mfst-override}
::: {#section-4.5.3 .section}
#### [4.5.3.](#section-4.5.3){.section-number .selfRef} [REQ.USE.MFST.OVERRIDE_REMOTE: Override Remote Resource Location](#name-requsemfstoverride_remote-o){.section-name .selfRef} {#name-requsemfstoverride_remote-o}

A manifest format [MUST]{.bcp14} be able to redirect payload fetches.
This applies where two manifests are used in conjunction. For example, a
device operator creates a manifest specifying a payload and signs it,
and provides a URI for that payload. A network operator creates a second
manifest, with a dependency on the first. They use this second manifest
to override the URIs provided by the device operator, directing them
into their own infrastructure instead. Some devices may provide this
capability, while others may only look at canonical sources of firmware.
For this to be possible, the device must fetch the payload, whereas a
device that accepts payload pushes will ignore this
feature.[¶](#section-4.5.3-1){.pilcrow}

[]{.break}

Satisfies:
:   [USER_STORY.OVERRIDE](#user-story-override){.xref} ([Section
    4.4.3](#user-story-override){.xref})[¶](#section-4.5.3-2.2){.pilcrow}
:   

Implemented by:
:   [Aliases](#manifest-element-aliases){.xref} ([Section
    3.18](#manifest-element-aliases){.xref})[¶](#section-4.5.3-2.4){.pilcrow}
:   
:::
:::

::: {#req-use-mfst-component}
::: {#section-4.5.4 .section}
#### [4.5.4.](#section-4.5.4){.section-number .selfRef} [REQ.USE.MFST.COMPONENT: Component Updates](#name-requsemfstcomponent-compone){.section-name .selfRef} {#name-requsemfstcomponent-compone}

A manifest format [MUST]{.bcp14} be able to express the requirement to
install one or more payloads from one or more authorities so that a
multi-payload update can be described. This allows multiple parties with
different permissions to collaborate in creating a single update for the
IoT device, across multiple components.[¶](#section-4.5.4-1){.pilcrow}

This requirement implies that it must be possible to construct a tree of
manifests on a multi-image target.[¶](#section-4.5.4-2){.pilcrow}

In order to enable devices with a heterogeneous storage architecture,
the manifest must enable specification of both a storage system and the
storage location within that storage
system.[¶](#section-4.5.4-3){.pilcrow}

[]{.break}

Satisfies:
:   [USER_STORY.OVERRIDE](#user-story-override){.xref} ([Section
    4.4.3](#user-story-override){.xref}),
    [USER_STORY.COMPONENT](#user-story-component){.xref} ([Section
    4.4.4](#user-story-component){.xref})[¶](#section-4.5.4-4.2){.pilcrow}
:   

Implemented by:
:   Dependencies, StorageIdentifier,
    ComponentIdentifier[¶](#section-4.5.4-4.4){.pilcrow}
:   

::: {#example-1-multiple-microcontrollers}
::: {#section-4.5.4.1 .section}
##### [4.5.4.1.](#section-4.5.4.1){.section-number .selfRef} [Example 1: Multiple Microcontrollers](#name-example-1-multiple-microcon){.section-name .selfRef} {#name-example-1-multiple-microcon}

An IoT device with multiple microcontrollers in the same physical device
will likely require multiple payloads with different component
identifiers.[¶](#section-4.5.4.1-1){.pilcrow}
:::
:::

::: {#example-2-code-and-configuration}
::: {#section-4.5.4.2 .section}
##### [4.5.4.2.](#section-4.5.4.2){.section-number .selfRef} [Example 2: Code and Configuration](#name-example-2-code-and-configur){.section-name .selfRef} {#name-example-2-code-and-configur}

A firmware image can be divided into two payloads: code and
configuration. These payloads may require authorizations from different
actors in order to install (see [REQ.SEC.RIGHTS](#req-sec-rights){.xref}
([Section 4.3.11](#req-sec-rights){.xref}) and
[REQ.SEC.ACCESS_CONTROL](#req-sec-access-control){.xref} ([Section
4.3.13](#req-sec-access-control){.xref})). This structure means that
multiple manifests may be required, with a dependency structure between
them.[¶](#section-4.5.4.2-1){.pilcrow}
:::
:::

::: {#example-3-multiple-software-modules}
::: {#section-4.5.4.3 .section}
##### [4.5.4.3.](#section-4.5.4.3){.section-number .selfRef} [Example 3: Multiple Software Modules](#name-example-3-multiple-software){.section-name .selfRef} {#name-example-3-multiple-software}

A firmware image can be divided into multiple functional blocks for
separate testing and distribution. This means that code would need to be
distributed in multiple payloads. For example, this might be desirable
in order to ensure that common code between devices is identical in
order to reduce distribution bandwidth.[¶](#section-4.5.4.3-1){.pilcrow}
:::
:::
:::
:::

::: {#req-use-mfst-multi-auth}
::: {#section-4.5.5 .section}
#### [4.5.5.](#section-4.5.5){.section-number .selfRef} [REQ.USE.MFST.MULTI_AUTH: Multiple Authentications](#name-requsemfstmulti_auth-multip){.section-name .selfRef} {#name-requsemfstmulti_auth-multip}

A manifest format [MUST]{.bcp14} be able to carry multiple signatures so
that authorizations from multiple parties with different permissions can
be required in order to authorize installation of a
manifest.[¶](#section-4.5.5-1){.pilcrow}

[]{.break}

Satisfies:
:   [USER_STORY.MULTI_AUTH](#user-story-multi-auth){.xref} ([Section
    4.4.5](#user-story-multi-auth){.xref})[¶](#section-4.5.5-2.2){.pilcrow}
:   

Implemented by:
:   [Signature](#manifest-element-signature){.xref} ([Section
    3.15](#manifest-element-signature){.xref})[¶](#section-4.5.5-2.4){.pilcrow}
:   
:::
:::

::: {#req-use-img-format}
::: {#section-4.5.6 .section}
#### [4.5.6.](#section-4.5.6){.section-number .selfRef} [REQ.USE.IMG.FORMAT: Format Usability](#name-requseimgformat-format-usab){.section-name .selfRef} {#name-requseimgformat-format-usab}

The manifest format [MUST]{.bcp14} accommodate any payload format that
an Operator wishes to use. This enables the recipient to detect which
format the Operator has chosen. Some examples of payload format are as
follows:[¶](#section-4.5.6-1){.pilcrow}

-   [Binary[¶](#section-4.5.6-2.1){.pilcrow}]{#section-4.5.6-2.1}
-   [Executable and Linkable Format
    (ELF)[¶](#section-4.5.6-2.2){.pilcrow}]{#section-4.5.6-2.2}
-   [Differential[¶](#section-4.5.6-2.3){.pilcrow}]{#section-4.5.6-2.3}
-   [Compressed[¶](#section-4.5.6-2.4){.pilcrow}]{#section-4.5.6-2.4}
-   [Packed
    configuration[¶](#section-4.5.6-2.5){.pilcrow}]{#section-4.5.6-2.5}
-   [Intel HEX[¶](#section-4.5.6-2.6){.pilcrow}]{#section-4.5.6-2.6}
-   [Motorola
    S-Record[¶](#section-4.5.6-2.7){.pilcrow}]{#section-4.5.6-2.7}

[]{.break}

Satisfies:
:   [USER_STORY.IMG.FORMAT](#user-story-img-format){.xref} ([Section
    4.4.6](#user-story-img-format){.xref})
    [USER_STORY.IMG.UNKNOWN_FORMAT](#user-story-img-unknown-format){.xref}
    ([Section
    4.4.8](#user-story-img-unknown-format){.xref})[¶](#section-4.5.6-3.2){.pilcrow}
:   

Implemented by:
:   [Payload Format](#manifest-element-format){.xref} ([Section
    3.8](#manifest-element-format){.xref})[¶](#section-4.5.6-3.4){.pilcrow}
:   
:::
:::

::: {#req-use-img-nested}
::: {#section-4.5.7 .section}
#### [4.5.7.](#section-4.5.7){.section-number .selfRef} [REQ.USE.IMG.NESTED: Nested Formats](#name-requseimgnested-nested-form){.section-name .selfRef} {#name-requseimgnested-nested-form}

The manifest format [MUST]{.bcp14} accommodate nested formats,
announcing to the target device all the nesting steps and any parameters
used by those steps.[¶](#section-4.5.7-1){.pilcrow}

[]{.break}

Satisfies:
:   [USER_STORY.IMG.CONFIDENTIALITY](#user-story-img-confidentiality){.xref}
    ([Section
    4.4.7](#user-story-img-confidentiality){.xref})[¶](#section-4.5.7-2.2){.pilcrow}
:   

Implemented by:
:   [Processing Steps](#manifest-element-processing-steps){.xref}
    ([Section
    3.9](#manifest-element-processing-steps){.xref})[¶](#section-4.5.7-2.4){.pilcrow}
:   
:::
:::

::: {#req-use-img-versions}
::: {#section-4.5.8 .section}
#### [4.5.8.](#section-4.5.8){.section-number .selfRef} [REQ.USE.IMG.VERSIONS: Target Version Matching](#name-requseimgversions-target-ve){.section-name .selfRef} {#name-requseimgversions-target-ve}

The manifest format [MUST]{.bcp14} provide a method to specify multiple
version numbers of firmware to which the manifest applies, either with a
list or with range matching.[¶](#section-4.5.8-1){.pilcrow}

[]{.break}

Satisfies:
:   [USER_STORY.IMG.CURRENT_VERSION](#user-story-img-current-version){.xref}
    ([Section
    4.4.9](#user-story-img-current-version){.xref})[¶](#section-4.5.8-2.2){.pilcrow}
:   

Implemented by:
:   [Required Image Version List](#element-required-version){.xref}
    ([Section
    3.6](#element-required-version){.xref})[¶](#section-4.5.8-2.4){.pilcrow}
:   
:::
:::

::: {#req-use-img-select}
::: {#section-4.5.9 .section}
#### [4.5.9.](#section-4.5.9){.section-number .selfRef} [REQ.USE.IMG.SELECT: Select Image by Destination](#name-requseimgselect-select-imag){.section-name .selfRef} {#name-requseimgselect-select-imag}

The manifest format [MUST]{.bcp14} provide a mechanism to list multiple
equivalent payloads by execute-in-place (XIP) installation address,
including the payload digest and, optionally, payload
URIs.[¶](#section-4.5.9-1){.pilcrow}

[]{.break}

Satisfies:
:   [USER_STORY.IMG.SELECT](#user-story-img-select){.xref} ([Section
    4.4.10](#user-story-img-select){.xref})[¶](#section-4.5.9-2.2){.pilcrow}
:   

Implemented by:
:   [XIP Address](#manifest-element-xip-address){.xref} ([Section
    3.21](#manifest-element-xip-address){.xref})[¶](#section-4.5.9-2.4){.pilcrow}
:   
:::
:::

::: {#req-use-exec}
::: {#section-4.5.10 .section}
#### [4.5.10.](#section-4.5.10){.section-number .selfRef} [REQ.USE.EXEC: Executable Manifest](#name-requseexec-executable-manif){.section-name .selfRef} {#name-requseexec-executable-manif}

The manifest format [MUST]{.bcp14} allow the description of an
executable system with a manifest on both XIP microcontrollers and
complex operating systems. In addition, the manifest format
[MUST]{.bcp14} be able to express metadata, such as a kernel command
line, used by any loader or bootloader.[¶](#section-4.5.10-1){.pilcrow}

[]{.break}

Satisfies:
:   [USER_STORY.EXEC.MFST](#user-story-exec-mfst){.xref} ([Section
    4.4.11](#user-story-exec-mfst){.xref})[¶](#section-4.5.10-2.2){.pilcrow}
:   

Implemented by:
:   [Runtime Metadata](#manifest-element-exec-metadata){.xref} ([Section
    3.23](#manifest-element-exec-metadata){.xref})[¶](#section-4.5.10-2.4){.pilcrow}
:   
:::
:::

::: {#req-use-load}
::: {#section-4.5.11 .section}
#### [4.5.11.](#section-4.5.11){.section-number .selfRef} [REQ.USE.LOAD: Load-Time Information](#name-requseload-load-time-inform){.section-name .selfRef} {#name-requseload-load-time-inform}

The manifest format [MUST]{.bcp14} enable carrying additional metadata
for load-time processing of a payload, such as cryptographic
information, load address, and compression algorithm. Note that load
comes before execution/boot.[¶](#section-4.5.11-1){.pilcrow}

[]{.break}

Satisfies:
:   [USER_STORY.EXEC.DECOMPRESS](#user-story-exec-decompress){.xref}
    ([Section
    4.4.12](#user-story-exec-decompress){.xref})[¶](#section-4.5.11-2.2){.pilcrow}
:   

Implemented by:
:   [Load-Time Metadata](#manifest-element-load-metadata){.xref}
    ([Section
    3.22](#manifest-element-load-metadata){.xref})[¶](#section-4.5.11-2.4){.pilcrow}
:   
:::
:::

::: {#req-use-payload}
::: {#section-4.5.12 .section}
#### [4.5.12.](#section-4.5.12){.section-number .selfRef} [REQ.USE.PAYLOAD: Payload in Manifest Envelope](#name-requsepayload-payload-in-ma){.section-name .selfRef} {#name-requsepayload-payload-in-ma}

The manifest format [MUST]{.bcp14} allow placing a payload in the same
structure as the manifest. This may place the payload in the same packet
as the manifest.[¶](#section-4.5.12-1){.pilcrow}

Integrated payloads may include, for example, binaries as well as
configuration information, and keying
material.[¶](#section-4.5.12-2){.pilcrow}

When an integrated payload is provided, this increases the size of the
manifest. Manifest size can cause several processing and storage
concerns that require careful consideration. The payload can prevent the
whole manifest from being contained in a single network packet, which
can cause fragmentation and the loss of portions of the manifest in
lossy networks. This causes the need for reassembly and retransmission
logic. The manifest [MUST]{.bcp14} be held immutable between
verification and processing (see
[REQ.SEC.MFST.CONST](#req-sec-mfst-const){.xref} ([Section
4.3.21](#req-sec-mfst-const){.xref})), so a larger manifest will consume
more memory with immutability guarantees \-- for example, internal RAM
or NVRAM, or external secure memory. If the manifest exceeds the
available immutable memory, then it [MUST]{.bcp14} be processed
modularly, evaluating each of the following: delegation chains; the
security container; and the actual manifest, which includes verifying
the integrated payload. If the security model calls for downloading the
manifest and validating it before storing to NVRAM in order to prevent
wear to NVRAM and energy expenditure in NVRAM, then either increasing
memory allocated to manifest storage or modular processing of the
received manifest may be required. While the manifest has been organized
to enable this type of processing, it creates additional complexity in
the parser. If the manifest is stored in NVRAM prior to processing, the
integrated payload may cause the manifest to exceed the available
storage. Because the manifest is received prior to validation of
applicability, authority, or correctness, integrated payloads cause the
recipient to expend network bandwidth and energy that may not be
required if the manifest is discarded, and these costs vary with the
size of the integrated payload.[¶](#section-4.5.12-3){.pilcrow}

[]{.break}

See also:
:   [REQ.SEC.MFST.CONST](#req-sec-mfst-const){.xref} ([Section
    4.3.21](#req-sec-mfst-const){.xref})[¶](#section-4.5.12-4.2){.pilcrow}
:   

Satisfies:
:   [USER_STORY.MFST.IMG](#user-story-mfst-img){.xref} ([Section
    4.4.13](#user-story-mfst-img){.xref})[¶](#section-4.5.12-4.4){.pilcrow}
:   

Implemented by:
:   [Payload](#manifest-element-payload){.xref} ([Section
    3.24](#manifest-element-payload){.xref})[¶](#section-4.5.12-4.6){.pilcrow}
:   
:::
:::

::: {#req-use-parse}
::: {#section-4.5.13 .section}
#### [4.5.13.](#section-4.5.13){.section-number .selfRef} [REQ.USE.PARSE: Simple Parsing](#name-requseparse-simple-parsing){.section-name .selfRef} {#name-requseparse-simple-parsing}

The structure of the manifest [MUST]{.bcp14} be simple to parse to
reduce the attack vectors against manifest
parsers.[¶](#section-4.5.13-1){.pilcrow}

[]{.break}

Satisfies:
:   [USER_STORY.MFST.PARSE](#user-story-mfst-parse){.xref} ([Section
    4.4.14](#user-story-mfst-parse){.xref})[¶](#section-4.5.13-2.2){.pilcrow}
:   

Implemented by:
:   N/A[¶](#section-4.5.13-2.4){.pilcrow}
:   
:::
:::

::: {#req-use-delegation}
::: {#section-4.5.14 .section}
#### [4.5.14.](#section-4.5.14){.section-number .selfRef} [REQ.USE.DELEGATION: Delegation of Authority in Manifest](#name-requsedelegation-delegation){.section-name .selfRef} {#name-requsedelegation-delegation}

A manifest format [MUST]{.bcp14} enable the delivery of delegation
information. This information delivers a new key with which the
recipient can verify the manifest.[¶](#section-4.5.14-1){.pilcrow}

[]{.break}

Satisfies:
:   [USER_STORY.MFST.DELEGATION](#user-story-mfst-delegation){.xref}
    ([Section
    4.4.15](#user-story-mfst-delegation){.xref})[¶](#section-4.5.14-2.2){.pilcrow}
:   

Implemented by:
:   [Delegation Chain](#manifest-element-key-claims){.xref} ([Section
    3.25](#manifest-element-key-claims){.xref})[¶](#section-4.5.14-2.4){.pilcrow}
:   
:::
:::
:::
:::
:::
:::

::: {#iana-considerations}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-5-1){.pilcrow}
:::
:::

::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC4122\]
:   [Leach, P.]{.refAuthor}, [Mealling, M.]{.refAuthor}, and [R.
    Salz]{.refAuthor}, [\"A Universally Unique IDentifier (UUID) URN
    Namespace\"]{.refTitle}, [RFC 4122]{.seriesInfo}, [DOI
    10.17487/RFC4122]{.seriesInfo}, July 2005,
    \<<https://www.rfc-editor.org/info/rfc4122>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8392\]
:   [Jones, M.]{.refAuthor}, [Wahlstroem, E.]{.refAuthor},
    [Erdtman, S.]{.refAuthor}, and [H. Tschofenig]{.refAuthor}, [\"CBOR
    Web Token (CWT)\"]{.refTitle}, [RFC 8392]{.seriesInfo}, [DOI
    10.17487/RFC8392]{.seriesInfo}, May 2018,
    \<<https://www.rfc-editor.org/info/rfc8392>\>.
:   

\[RFC8747\]
:   [Jones, M.]{.refAuthor}, [Seitz, L.]{.refAuthor},
    [Selander, G.]{.refAuthor}, [Erdtman, S.]{.refAuthor}, and [H.
    Tschofenig]{.refAuthor}, [\"Proof-of-Possession Key Semantics for
    CBOR Web Tokens (CWTs)\"]{.refTitle}, [RFC 8747]{.seriesInfo}, [DOI
    10.17487/RFC8747]{.seriesInfo}, March 2020,
    \<<https://www.rfc-editor.org/info/rfc8747>\>.
:   

\[RFC9019\]
:   [Moran, B.]{.refAuthor}, [Tschofenig, H.]{.refAuthor},
    [Brown, D.]{.refAuthor}, and [M. Meriac]{.refAuthor}, [\"A Firmware
    Update Architecture for Internet of Things\"]{.refTitle}, [RFC
    9019]{.seriesInfo}, [DOI 10.17487/RFC9019]{.seriesInfo}, April 2021,
    \<<https://www.rfc-editor.org/info/rfc9019>\>.
:   
:::

::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[RFC3444\]
:   [Pras, A.]{.refAuthor} and [J. Schoenwaelder]{.refAuthor}, [\"On the
    Difference between Information Models and Data Models\"]{.refTitle},
    [RFC 3444]{.seriesInfo}, [DOI 10.17487/RFC3444]{.seriesInfo},
    January 2003, \<<https://www.rfc-editor.org/info/rfc3444>\>.
:   

\[RFC3986\]
:   [Berners-Lee, T.]{.refAuthor}, [Fielding, R.]{.refAuthor}, and [L.
    Masinter]{.refAuthor}, [\"Uniform Resource Identifier (URI): Generic
    Syntax\"]{.refTitle}, [STD 66]{.seriesInfo}, [RFC
    3986]{.seriesInfo}, [DOI 10.17487/RFC3986]{.seriesInfo}, January
    2005, \<<https://www.rfc-editor.org/info/rfc3986>\>.
:   

\[STRIDE\]
:   [Microsoft]{.refAuthor}, [\"The STRIDE Threat Model\"]{.refTitle},
    November 2009,
    \<<https://docs.microsoft.com/en-us/previous-versions/commerce-server/ee823878(v=cs.20)>\>.
:   
:::
:::

::: {#acknowledgements}
::: {#appendix-A .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

We would like to thank our working group chairs \-- [Dave
Thaler]{.contact-name}, [Russ Housley]{.contact-name}, and [David
Waltermire]{.contact-name} \-- for their review comments and their
support.[¶](#appendix-A-1){.pilcrow}

We would like to thank the participants of the 2018 Berlin Software
Updates for Internet of Things (SUIT) Hackathon and the June 2018
virtual design team meetings for their discussion
input.[¶](#appendix-A-2){.pilcrow}

In particular, we would like to thank [Koen Zandberg]{.contact-name},
[Emmanuel Baccelli]{.contact-name}, [Carsten Bormann]{.contact-name},
[David Brown]{.contact-name}, [Markus Gueller]{.contact-name}, [Frank
Audun Kvamtrø]{.contact-name}, [Øyvind Rønningstad]{.contact-name},
[Michael Richardson]{.contact-name}, [Jan-Frederik
Rieckers]{.contact-name}, [Francisco Acosta]{.contact-name}, [Anton
Gerasimov]{.contact-name}, [Matthias Wählisch]{.contact-name}, [Max
Gröning]{.contact-name}, [Daniel Petry]{.contact-name}, [Gaëtan
Harter]{.contact-name}, [Ralph Hamm]{.contact-name}, [Steve
Patrick]{.contact-name}, [Fabio Utzig]{.contact-name}, [Paul
Lambert]{.contact-name}, [Saïd Gharout]{.contact-name}, and [Milen
Stoychev]{.contact-name}.[¶](#appendix-A-3){.pilcrow}

We would like to thank those who contributed to the development of this
information model. In particular, we would like to thank [Milosch
Meriac]{.contact-name}, [Jean-Luc Giraud]{.contact-name}, [Dan
Ros]{.contact-name}, [Amyas Phillips]{.contact-name}, and [Gary
Thomson]{.contact-name}.[¶](#appendix-A-4){.pilcrow}

Finally, we would like to thank the following IESG members for their
review feedback: [Erik Kline]{.contact-name}, [Murray
Kucherawy]{.contact-name}, [Barry Leiba]{.contact-name}, [Alissa
Cooper]{.contact-name}, [Stephen Farrell]{.contact-name}, and [Benjamin
Kaduk]{.contact-name}.[¶](#appendix-A-5){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-B .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Brendan Moran]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Arm Limited]{.org}
:::

::: email
Email: <Brendan.Moran@arm.com>
:::

::: {.left dir="auto"}
[Hannes Tschofenig]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Arm Limited]{.org}
:::

::: email
Email: <hannes.tschofenig@gmx.net>
:::

::: {.left dir="auto"}
[Henk Birkholz]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Fraunhofer SIT]{.org}
:::

::: email
Email: <henk.birkholz@sit.fraunhofer.de>
:::
:::
:::
