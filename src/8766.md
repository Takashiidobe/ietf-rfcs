  RFC 8766   Multicast Service Discovery Proxy   June 2020
  ---------- ----------------------------------- -----------
  Cheshire   Standards Track                     \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8766](https://www.rfc-editor.org/rfc/rfc8766){.eref}

Category:
:   Standards Track

Published:
:   June 2020

ISSN:
:   2070-1721

Author:

:   ::: author
    ::: author-name
    S. Cheshire
    :::

    ::: org
    Apple Inc.
    :::
    :::
:::

# RFC 8766 {#rfcnum}

# Discovery Proxy for Multicast DNS-Based Service Discovery {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document specifies a network proxy that uses Multicast DNS to
automatically populate the wide-area unicast Domain Name System
namespace with records describing devices and services found on the
local link.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8766>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Operational
    Analogy](#name-operational-analogy){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Conventions and Terminology Used in This
    Document](#name-conventions-and-terminology){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Compatibility
    Considerations](#name-compatibility-consideration){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Discovery Proxy
    Operation](#name-discovery-proxy-operation){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Delegated Subdomain for DNS-based
        Service Discovery
        Records](#name-delegated-subdomain-for-dns){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Domain
        Enumeration](#name-domain-enumeration){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.5.2.2.2.1}
            [5.2.1](#section-5.2.1){.xref}.  [Domain Enumeration via
            Unicast
            Queries](#name-domain-enumeration-via-unic){.xref}[¶](#section-toc.1-1.5.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.2}
            [5.2.2](#section-5.2.2){.xref}.  [Domain Enumeration via
            Multicast
            Queries](#name-domain-enumeration-via-mult){.xref}[¶](#section-toc.1-1.5.2.2.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Delegated Subdomain for LDH Host
        Names](#name-delegated-subdomain-for-ldh){.xref}[¶](#section-toc.1-1.5.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [Delegated Subdomain for Reverse
        Mapping](#name-delegated-subdomain-for-rev){.xref}[¶](#section-toc.1-1.5.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [Data
        Translation](#name-data-translation){.xref}[¶](#section-toc.1-1.5.2.5.1){.pilcrow}

        -   ::: {#section-toc.1-1.5.2.5.2.1}
            [5.5.1](#section-5.5.1){.xref}.  [DNS TTL
            Limiting](#name-dns-ttl-limiting){.xref}[¶](#section-toc.1-1.5.2.5.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.5.2.2}
            [5.5.2](#section-5.5.2){.xref}.  [Suppressing Unusable
            Records](#name-suppressing-unusable-record){.xref}[¶](#section-toc.1-1.5.2.5.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.5.2.3}
            [5.5.3](#section-5.5.3){.xref}.  [NSEC and NSEC3
            Queries](#name-nsec-and-nsec3-queries){.xref}[¶](#section-toc.1-1.5.2.5.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.5.2.4}
            [5.5.4](#section-5.5.4){.xref}.  [No Text-Encoding
            Translation](#name-no-text-encoding-translatio){.xref}[¶](#section-toc.1-1.5.2.5.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.5.2.5}
            [5.5.5](#section-5.5.5){.xref}.  [Application-Specific Data
            Translation](#name-application-specific-data-t){.xref}[¶](#section-toc.1-1.5.2.5.2.5.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.6}
        [5.6](#section-5.6){.xref}.  [Answer
        Aggregation](#name-answer-aggregation){.xref}[¶](#section-toc.1-1.5.2.6.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Administrative DNS
    Records](#name-administrative-dns-records){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [DNS SOA (Start of Authority)
        Record](#name-dns-soa-start-of-authority-){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [DNS NS
        Records](#name-dns-ns-records){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [DNS Delegation
        Records](#name-dns-delegation-records){.xref}[¶](#section-toc.1-1.6.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [DNS SRV
        Records](#name-dns-srv-records){.xref}[¶](#section-toc.1-1.6.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.5}
        [6.5](#section-6.5){.xref}.  [Domain Enumeration
        Records](#name-domain-enumeration-records){.xref}[¶](#section-toc.1-1.6.2.5.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [DNSSEC
    Considerations](#name-dnssec-considerations){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Online Signing
        Only](#name-online-signing-only){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [NSEC and NSEC3
        Records](#name-nsec-and-nsec3-records){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [IPv6
    Considerations](#name-ipv6-considerations){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Authenticity](#name-authenticity){.xref}[¶](#section-toc.1-1.9.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Privacy](#name-privacy){.xref}[¶](#section-toc.1-1.9.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.3}
        [9.3](#section-9.3){.xref}.  [Denial of
        Service](#name-denial-of-service){.xref}[¶](#section-toc.1-1.9.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}

    -   ::: {#section-toc.1-1.11.2.1}
        [11.1](#section-11.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.11.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [11.2](#section-11.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.11.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [Appendix A](#section-appendix.a){.xref}.  [Implementation
    Status](#name-implementation-status){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}

    -   ::: {#section-toc.1-1.12.2.1}
        [A.1](#section-a.1){.xref}.  [Already Implemented and
        Deployed](#name-already-implemented-and-dep){.xref}[¶](#section-toc.1-1.12.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [A.2](#section-a.2){.xref}.  [Already
        Implemented](#name-already-implemented){.xref}[¶](#section-toc.1-1.12.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.12.2.3}
        [A.3](#section-a.3){.xref}.  [Partially
        Implemented](#name-partially-implemented){.xref}[¶](#section-toc.1-1.12.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [](#section-appendix.b){.xref}[Acknowledgments](#name-acknowledgments){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.14}
    [](#section-appendix.c){.xref}[Author\'s
    Address](#name-authors-address){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::
:::
:::

::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Multicast DNS \[[RFC6762](#RFC6762){.xref}\] and its companion
technology DNS-based Service Discovery \[[RFC6763](#RFC6763){.xref}\]
were created to provide IP networking with the ease of use and
autoconfiguration for which AppleTalk was well known
\[[RFC6760](#RFC6760){.xref}\] \[[ZC](#ZC){.xref}\]
\[[ROADMAP](#I-D.cheshire-dnssd-roadmap){.xref}\].[¶](#section-1-1){.pilcrow}

For a small home network consisting of just a single link (or a few
physical links bridged together to appear as a single logical link from
the point of view of IP), Multicast DNS \[[RFC6762](#RFC6762){.xref}\]
is sufficient for client devices to look up the \".local\" host names of
peers on the same home network, and to use Multicast DNS-based Service
Discovery (DNS-SD) \[[RFC6763](#RFC6763){.xref}\] to discover services
offered on that home network.[¶](#section-1-2){.pilcrow}

For a larger network consisting of multiple links that are
interconnected using IP-layer routing instead of link-layer bridging,
link-local Multicast DNS alone is insufficient because link-local
Multicast DNS packets, by design, are not propagated onto other
links.[¶](#section-1-3){.pilcrow}

Using link-local multicast packets for Multicast DNS was a conscious
design choice \[[RFC6762](#RFC6762){.xref}\]. Even when limited to a
single link, multicast traffic is still generally considered to be more
expensive than unicast, because multicast traffic impacts many devices
instead of just a single recipient. In addition, with some technologies
like Wi-Fi \[[IEEE-11](#IEEE-11){.xref}\], multicast traffic is
inherently less efficient and less reliable than unicast, because Wi-Fi
multicast traffic is sent at lower data rates, and is not acknowledged
\[[MCAST](#I-D.ietf-mboned-ieee802-mcast-problems){.xref}\]. Increasing
the amount of expensive multicast traffic by flooding it across multiple
links would make the traffic load even worse.[¶](#section-1-4){.pilcrow}

Partitioning the network into many small links curtails the spread of
expensive multicast traffic but limits the discoverability of services.
At the opposite end of the spectrum, using a very large local link with
thousands of hosts enables better service discovery but at the cost of
larger amounts of multicast traffic.[¶](#section-1-5){.pilcrow}

Performing DNS-based Service Discovery using purely Unicast DNS is more
efficient and doesn\'t require large multicast domains but does require
that the relevant data be available in the Unicast DNS namespace. The
Unicast DNS namespace in question could fall within a traditionally
assigned globally unique domain name, or it could be within a private
local unicast domain name such as \".home.arpa\"
\[[RFC8375](#RFC8375){.xref}\].[¶](#section-1-6){.pilcrow}

In the DNS-SD specification \[[RFC6763](#RFC6763){.xref}\], [Section
10](https://www.rfc-editor.org/rfc/rfc6763#section-10){.relref}
(\"Populating the DNS with Information\") discusses various possible
ways that a service\'s PTR, SRV, TXT, and address records can make their
way into the Unicast DNS namespace, including manual zone file
configuration \[[RFC1034](#RFC1034){.xref}\]
\[[RFC1035](#RFC1035){.xref}\], DNS Update
\[[RFC2136](#RFC2136){.xref}\] \[[RFC3007](#RFC3007){.xref}\], and
proxies of various kinds.[¶](#section-1-7){.pilcrow}

One option is to make the relevant data available in the Unicast DNS
namespace by manual DNS configuration. This option has been used for
many years at IETF meetings to advertise the IETF terminal room printer.
Details of this example are given in [Appendix
A](https://tools.ietf.org/html/draft-cheshire-dnssd-roadmap-03#appendix-A){.relref}
of the Roadmap document
\[[ROADMAP](#I-D.cheshire-dnssd-roadmap){.xref}\]. However, this manual
DNS configuration is labor intensive, error prone, and requires a
reasonable degree of DNS expertise.[¶](#section-1-8){.pilcrow}

Another option is to populate the Unicast DNS namespace by having the
devices offering the services do that themselves, using DNS Update
\[[REG-PROT](#I-D.sctl-service-registration){.xref}\]
\[[DNS-UL](#I-D.sekar-dns-ul){.xref}\]. However, this requires
configuration of DNS Update keys on those devices, which has proven
onerous and impractical for simple devices like printers and network
cameras.[¶](#section-1-9){.pilcrow}

Hence, to facilitate efficient and reliable DNS-based Service Discovery,
a hybrid is needed that combines the ease of use of Multicast DNS with
the efficiency and scalability of Unicast
DNS.[¶](#section-1-10){.pilcrow}

This document specifies a type of proxy called a \"Discovery Proxy\"
that uses Multicast DNS \[[RFC6762](#RFC6762){.xref}\] to discover
Multicast DNS records on its local link on demand, and makes
corresponding DNS records visible in the Unicast DNS
namespace.[¶](#section-1-11){.pilcrow}

In principle, similar mechanisms could be defined for other local
discovery protocols, by creating a proxy that (i) uses the protocol in
question to discover local information on demand, and then (ii) makes
corresponding DNS records visible in the Unicast DNS namespace. Such
mechanisms for other local discovery protocols could be addressed in
future documents.[¶](#section-1-12){.pilcrow}

The design of the Discovery Proxy is guided by the previously published
DNS-based Service Discovery requirements document
\[[RFC7558](#RFC7558){.xref}\].[¶](#section-1-13){.pilcrow}

In simple terms, a descriptive DNS name is chosen for each link in an
organization. Using a DNS NS record, responsibility for that DNS name is
delegated to a Discovery Proxy physically attached to that link. When a
remote client issues a unicast query for a name falling within the
delegated subdomain, the normal DNS delegation mechanism results in the
unicast query arriving at the Discovery Proxy, since it has been
declared authoritative for those names. Now, instead of consulting a
textual zone file on disk to discover the answer to the query as a
traditional authoritative DNS server would, a Discovery Proxy consults
its local link, using Multicast DNS, to find the answer to the
question.[¶](#section-1-14){.pilcrow}

For fault tolerance reasons, there may be more than one Discovery Proxy
serving a given link.[¶](#section-1-15){.pilcrow}

Note that the Discovery Proxy uses a \"pull\" model. Until some remote
client has requested data, the local link is not queried using Multicast
DNS. In the idle state, in the absence of client requests, the Discovery
Proxy sends no packets and imposes no burden on the network. It operates
purely \"on demand\".[¶](#section-1-16){.pilcrow}

An alternative proposal that has been discussed is a proxy that performs
DNS updates to a remote DNS server on behalf of the Multicast DNS
devices on the local network. The difficulty with this is that Multicast
DNS devices do not routinely announce their records on the network.
Generally, they remain silent until queried. This means that the
complete set of Multicast DNS records in use on a link can only be
discovered by active querying, not by passive listening. Because of
this, a proxy can only know what names exist on a link by issuing
queries for them, and since it would be impractical to issue queries for
every possible name just to find out which names exist and which do not,
there is no reasonable way for a proxy to programmatically learn all the
answers it would need to push up to the remote DNS server using DNS
Update. Even if such a mechanism were possible, it would risk generating
high load on the network continuously, even when there are no clients
with any interest in that data.[¶](#section-1-17){.pilcrow}

Hence, having a model where the query comes to the Discovery Proxy is
much more efficient than a model where the Discovery Proxy pushes the
answers out to some other remote DNS server.[¶](#section-1-18){.pilcrow}

A client seeking to discover services and other information performs
this by sending traditional DNS queries to the Discovery Proxy or by
sending DNS Push Notification subscription requests
\[[RFC8765](#RFC8765){.xref}\].[¶](#section-1-19){.pilcrow}

How a client discovers what domain name(s) to use for its DNS-based
Service Discovery queries (and, consequently, what Discovery Proxy or
Proxies to use) is described in [Section
5.2](#dom-enum){.xref}.[¶](#section-1-20){.pilcrow}

The diagram below illustrates a network topology using a Discovery Proxy
to provide discovery service to a remote
client.[¶](#section-1-21){.pilcrow}

[]{#name-example-deployment}

::: {#section-1-22.1 .artwork .art-text .alignCenter}
     +--------+   Unicast     +-----------+  +---------+  +---------+
     | Remote | Communication | Discovery |  | Network |  | Network |
     | Client |---- . . . ----|   Proxy   |  | Printer |  | Camera  |
     +--------+               +-----------+  +---------+  +---------+
          |                         |             |            |
    ------------            --------------------------------------------
                           Multicast-capable LAN segment (e.g., Ethernet)
:::

[Figure 1](#figure-1){.selfRef}: [Example
Deployment](#name-example-deployment){.selfRef}

Note that there need not be any Discovery Proxy on the link to which the
remote client is directly attached. The remote client communicates
directly with the Discovery Proxy using normal unicast TCP/IP
communication mechanisms, potentially spanning multiple IP hops,
possibly including VPN tunnels and other similar long-distance
communication channels.[¶](#section-1-23){.pilcrow}
:::

::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Operational Analogy](#name-operational-analogy){.section-name .selfRef} {#name-operational-analogy}

A Discovery Proxy does not operate as a multicast relay or multicast
forwarder. There is no danger of multicast forwarding loops that result
in traffic storms, because no multicast packets are forwarded. A
Discovery Proxy operates as a *proxy* for remote clients, performing
queries on their behalf and reporting the results
back.[¶](#section-2-1){.pilcrow}

A reasonable analogy is making a telephone call to a colleague at your
workplace and saying, \"I\'m out of the office right now. Would you mind
bringing up a printer browser window and telling me the names of the
printers you see?\" That entails no risk of a forwarding loop causing a
traffic storm, because no multicast packets are sent over the telephone
call.[¶](#section-2-2){.pilcrow}

A similar analogy, instead of enlisting another human being to initiate
the service discovery operation on your behalf, is to log in to your own
desktop work computer using screen sharing and then run the printer
browser yourself to see the list of printers. Or, log in using Secure
Shell (ssh) and type \"dns-sd -B \_ipp.\_tcp\" and observe the list of
discovered printer names. In neither case is there any risk of a
forwarding loop causing a traffic storm, because no multicast packets
are being sent over the screen-sharing or ssh
connection.[¶](#section-2-3){.pilcrow}

The Discovery Proxy provides another way of performing remote queries,
which uses a different protocol instead of screen sharing or ssh. The
Discovery Proxy mechanism can be thought of as a custom Remote Procedure
Call (RPC) protocol that allows a remote client to exercise the
Multicast DNS APIs on the Discovery Proxy device, just as a local client
running on the Discovery Proxy device would use those
APIs.[¶](#section-2-4){.pilcrow}

When the Discovery Proxy software performs Multicast DNS operations, the
exact same Multicast DNS caching mechanisms are applied as when any
other client software on that Discovery Proxy device performs Multicast
DNS operations, regardless of whether that be running a printer browser
client locally, a remote user running the printer browser client via a
screen-sharing connection, a remote user logged in via ssh running a
command-line tool like \"dns-sd\", or a remote user sending DNS requests
that cause a Discovery Proxy to perform discovery operations on its
behalf.[¶](#section-2-5){.pilcrow}
:::

::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Conventions and Terminology Used in This Document](#name-conventions-and-terminology){.section-name .selfRef} {#name-conventions-and-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-3-1){.pilcrow}

The Discovery Proxy builds on Multicast DNS, which works between hosts
on the same link. For the purposes of this document, a set of hosts is
considered to be \"on the same link\" if:[¶](#section-3-2){.pilcrow}

-   [when any host from that set sends a packet to any other host in
    that set, using unicast, multicast, or broadcast, the entire
    link-layer packet payload arrives unmodified,
    and[¶](#section-3-3.1){.pilcrow}]{#section-3-3.1}
-   [a broadcast sent over that link, by any host from that set of
    hosts, can be received by every other host in that
    set.[¶](#section-3-3.2){.pilcrow}]{#section-3-3.2}

The link-layer *header* may be modified, such as in Token Ring Source
Routing \[[IEEE-5](#IEEE-5){.xref}\], but not the link-layer *payload*.
In particular, if any device forwarding a packet modifies any part of
the IP header or IP payload, then the packet is no longer considered to
be on the same link. This means that the packet may pass through devices
such as repeaters, bridges, hubs, or switches and still be considered to
be on the same link for the purpose of this document, but not through a
device such as an IP router that decrements the IP TTL or otherwise
modifies the IP header.[¶](#section-3-4){.pilcrow}
:::

::: {#compatibility}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Compatibility Considerations](#name-compatibility-consideration){.section-name .selfRef} {#name-compatibility-consideration}

No changes to existing devices are required to work with a Discovery
Proxy.[¶](#section-4-1){.pilcrow}

Existing devices that advertise services using Multicast DNS work with a
Discovery Proxy.[¶](#section-4-2){.pilcrow}

Existing clients that support DNS-based Service Discovery over Unicast
DNS work with a Discovery Proxy. DNS-based Service Discovery over
Unicast DNS was introduced in Mac OS X 10.4 Tiger in April 2005 and has
been included in Apple products introduced since then, including the
iPhone and iPad. It has also been included in products from other
vendors, such as Microsoft Windows 10.[¶](#section-4-3){.pilcrow}

An overview of the larger collection of associated DNS-based Service
Discovery technologies, and how the Discovery Proxy technology relates
to those, is given in the Service Discovery Road Map document
\[[ROADMAP](#I-D.cheshire-dnssd-roadmap){.xref}\].[¶](#section-4-4){.pilcrow}
:::
:::

::: {#operation}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Discovery Proxy Operation](#name-discovery-proxy-operation){.section-name .selfRef} {#name-discovery-proxy-operation}

In a typical configuration, a Discovery Proxy is configured to be
authoritative \[[RFC1034](#RFC1034){.xref}\]
\[[RFC1035](#RFC1035){.xref}\] for four or more DNS subdomains, listed
below. Authority for these subdomains is delegated from the parent
domain to the Discovery Proxy in the usual way for DNS delegation, via
NS records.[¶](#section-5-1){.pilcrow}

A DNS subdomain for DNS-based Service Discovery records.
:   This subdomain name may contain rich text, including spaces and
    other punctuation. This is because this subdomain name is used only
    in graphical user interfaces, where rich text is
    appropriate.[¶](#section-5-2.2){.pilcrow}
:   

A DNS subdomain for host name records.
:   This subdomain name [SHOULD]{.bcp14} be limited to letters, digits,
    and hyphens in order to facilitate the convenient use of host names
    in command-line interfaces.[¶](#section-5-2.4){.pilcrow}
:   

One or more DNS subdomains for IPv4 Reverse Mapping records.
:   These subdomains will have names that end in
    \"in-addr.arpa\".[¶](#section-5-2.6){.pilcrow}
:   

One or more DNS subdomains for IPv6 Reverse Mapping records.
:   These subdomains will have names that end in
    \"ip6.arpa\".[¶](#section-5-2.8){.pilcrow}
:   

In an enterprise network, the naming and delegation of these subdomains
is typically performed by conscious action of the network administrator.
In a home network, naming and delegation would typically be performed
using some automatic configuration mechanism such as Home Networking
Control Protocol (HNCP)
\[[RFC7788](#RFC7788){.xref}\].[¶](#section-5-3){.pilcrow}

These three varieties of delegated subdomains (service discovery, host
names, and reverse mapping) are described below in Sections
[5.1](#dom-sd){.xref}, [5.3](#dom-host){.xref}, and
[5.4](#dom-rev){.xref}.[¶](#section-5-4){.pilcrow}

How a client discovers where to issue its DNS-based Service Discovery
queries is described in [Section
5.2](#dom-enum){.xref}.[¶](#section-5-5){.pilcrow}

::: {#dom-sd}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Delegated Subdomain for DNS-based Service Discovery Records](#name-delegated-subdomain-for-dns){.section-name .selfRef} {#name-delegated-subdomain-for-dns}

In its simplest form, each link in an organization is assigned a unique
Unicast DNS domain name such as \"Building 1.example.com\" or
\"2nd Floor.Building 3.example.com\". Grouping multiple links under a
single Unicast DNS domain name is to be specified in a future companion
document, but for the purposes of this document, assume that each link
has its own unique Unicast DNS domain name. In a graphical user
interface these names are not displayed as strings with dots as shown
above, but something more akin to a typical file browser graphical user
interface (which is harder to illustrate in a text-only document)
showing folders, subfolders, and files in a file
system.[¶](#section-5.1-1){.pilcrow}

[]{#name-illustrative-gui}

::: {#browser}
::: {#section-5.1-2.1 .artwork .art-text .alignCenter}
     +---------------+--------------+-------------+-------------------+
     | *example.com* |  Building 1  |  1st Floor  | Alice's printer   |
     |               |  Building 2  | *2nd Floor* | Bob's printer     |
     |               | *Building 3* |  3rd Floor  | Charlie's printer |
     |               |  Building 4  |  4th Floor  |                   |
     |               |  Building 5  |             |                   |
     |               |  Building 6  |             |                   |
     +---------------+--------------+-------------+-------------------+
:::

[Figure 2](#figure-2){.selfRef}: [Illustrative
GUI](#name-illustrative-gui){.selfRef}
:::

Each named link in an organization has one or more Discovery Proxies
that serve it. This Discovery Proxy function could be performed by a
device like a router or switch that is physically attached to that link.
In the parent domain, NS records are used to delegate ownership of each
defined link name (e.g., \"Building 1.example.com\") to one or more
Discovery Proxies that serve the named link. In other words, the
Discovery Proxies are the authoritative name servers for that subdomain.
As in the rest of DNS-based Service Discovery, all names are represented
as-is using plain UTF-8 encoding and, as described in [Section
5.5.4](#notrans){.xref}, no text-encoding translations are
performed.[¶](#section-5.1-3){.pilcrow}

With appropriate VLAN configuration \[[IEEE-1Q](#IEEE-1Q){.xref}\], a
single Discovery Proxy device could have a logical presence on many
links and serve as the Discovery Proxy for all those links. In such a
configuration, the Discovery Proxy device would have a single physical
Ethernet \[[IEEE-3](#IEEE-3){.xref}\] port, configured as a VLAN trunk
port, which would appear to software on that device as multiple virtual
Ethernet interfaces, one connected to each of the VLAN
links.[¶](#section-5.1-4){.pilcrow}

As an alternative to using VLAN technology, using a Multicast DNS
Discovery Relay \[[RELAY](#I-D.sctl-dnssd-mdns-relay){.xref}\] is
another way that a Discovery Proxy can have a \"virtual\" presence on a
remote link.[¶](#section-5.1-5){.pilcrow}

When a DNS-SD client issues a Unicast DNS query to discover services in
a particular Unicast DNS subdomain
(e.g., \"\_ipp.\_tcp.Building 1.example.com. PTR ?\"), the normal DNS
delegation mechanism results in that query being forwarded until it
reaches the delegated authoritative name server for that subdomain,
namely, the Discovery Proxy on the link in question. Like a conventional
Unicast DNS server, a Discovery Proxy implements the usual Unicast DNS
protocol \[[RFC1034](#RFC1034){.xref}\] \[[RFC1035](#RFC1035){.xref}\]
over UDP and TCP. However, unlike a conventional Unicast DNS server that
generates answers from the data in its manually configured zone file, a
Discovery Proxy learns answers using Multicast DNS. A Discovery Proxy
does this by consulting its Multicast DNS cache and/or issuing Multicast
DNS queries, as appropriate according to the usual protocol rules of
Multicast DNS \[[RFC6762](#RFC6762){.xref}\], for the corresponding
Multicast DNS name, type, and class, with the delegated zone part of the
name replaced with \".local\" (e.g., in this case,
\"\_ipp.\_tcp.local. PTR ?\"). Then, from the received Multicast DNS
data, the Discovery Proxy synthesizes the appropriate Unicast DNS
response, with the \".local\" top-level label of the owner name replaced
with the name of the delegated zone. Further details of the name
translation rules are described in [Section 5.5](#translation){.xref}.
Rules specifying how long the Discovery Proxy should wait to accumulate
Multicast DNS responses before sending its unicast reply are described
in [Section 5.6](#aggregation){.xref}.[¶](#section-5.1-6){.pilcrow}

The existing Multicast DNS caching mechanism is used to minimize
unnecessary Multicast DNS queries on the wire. The Discovery Proxy is
acting as a client of the underlying Multicast DNS subsystem and
benefits from the same caching and efficiency measures as any other
client using that subsystem.[¶](#section-5.1-7){.pilcrow}

Note that the contents of the delegated zone, generated as it is by
performing \".local\" Multicast DNS queries, mirrors the records
available on the local link via Multicast DNS very closely, but not
precisely. There is not a full bidirectional equivalence between the
two. Certain records that are available via Multicast DNS may not have
equivalents in the delegated zone possibly because they are invalid or
not relevant in the delegated zone or because they are being suppressed
because they are unusable outside the local link (see [Section
5.5.2](#unusable){.xref}). Conversely, certain records that appear in
the delegated zone may not have corresponding records available on the
local link via Multicast DNS. In particular, there are certain
administrative SRV records (see [Section 6](#admin){.xref}) that
logically fall within the delegated zone but semantically represent
metadata *about* the zone rather than records *within* the zone.
Consequently, these administrative records in the delegated zone do not
have any corresponding counterparts in the Multicast DNS namespace of
the local link.[¶](#section-5.1-8){.pilcrow}
:::
:::

::: {#dom-enum}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Domain Enumeration](#name-domain-enumeration){.section-name .selfRef} {#name-domain-enumeration}

A DNS-SD client performs Domain Enumeration
\[[RFC6763](#RFC6763){.xref}\] via certain PTR queries, using both
unicast and multicast.[¶](#section-5.2-1){.pilcrow}

If a DNS-SD client receives a Domain Name configuration via DHCP then it
issues unicast queries derived from this domain name. It also issues
unicast queries using names derived from its IPv4 subnet address(es) and
IPv6 prefix(es). These unicast Domain Enumeration queries are described
in [Section 5.2.1](#unicast){.xref}. A DNS-SD client also issues
multicast Domain Enumeration queries in the \"local\" domain
\[[RFC6762](#RFC6762){.xref}\], as described in [Section
5.2.2](#multicast){.xref}. The results of all the Domain Enumeration
queries are combined for DNS-based Service Discovery
purposes.[¶](#section-5.2-2){.pilcrow}

::: {#unicast}
::: {#section-5.2.1 .section}
#### [5.2.1.](#section-5.2.1){.section-number .selfRef} [Domain Enumeration via Unicast Queries](#name-domain-enumeration-via-unic){.section-name .selfRef} {#name-domain-enumeration-via-unic}

The (human or automated) administrator creates Unicast DNS Domain
Enumeration PTR records \[[RFC6763](#RFC6763){.xref}\] to inform clients
of available service discovery domains. Two varieties of such Unicast
DNS Domain Enumeration PTR records exist: those with names derived from
the domain name communicated to the clients via [DHCP option
15](#RFC2132){.xref} \[[RFC2132](#RFC2132){.xref}\], and those with
names derived from either IPv4 subnet address(es) or IPv6 prefix(es) in
use by the clients. Below is an example showing the name-based variety,
where the DHCP server configured the client with the domain name
\"example.com\":[¶](#section-5.2.1-1){.pilcrow}

::: {#section-5.2.1-2 .artwork .art-text .alignCenter}
        b._dns-sd._udp.example.com.    PTR   Building 1.example.com.
                                       PTR   Building 2.example.com.
                                       PTR   Building 3.example.com.
                                       PTR   Building 4.example.com.

        db._dns-sd._udp.example.com.   PTR   Building 1.example.com.

        lb._dns-sd._udp.example.com.   PTR   Building 1.example.com.

[¶](#section-5.2.1-2){.pilcrow}
:::

The meaning of these records is defined in the [DNS-based Service
Discovery specification](#RFC6763){.xref} \[[RFC6763](#RFC6763){.xref}\]
but, for convenience, is repeated here. The \"b\" (\"browse\") records
tell the client device the list of browsing domains to display for the
user to select from. The \"db\" (\"default browse\") record tells the
client device which domain in that list should be selected by default.
The \"db\" domain [MUST]{.bcp14} be one of the domains in the \"b\"
list; if not, then no domain is selected by default. The \"lb\"
(\"legacy browse\") record tells the client device which domain to
automatically browse on behalf of applications that don\'t implement
user interface for multi-domain browsing (which is most of them at the
time of writing). The \"lb\" domain is often the same as the \"db\"
domain, or sometimes the \"db\" domain plus one or more others that
should be included in the list of automatic browsing domains for legacy
clients.[¶](#section-5.2.1-3){.pilcrow}

Note that in the example above, for clarity, space characters in names
are shown as actual spaces. If this data is manually entered into a
textual zone file for authoritative server software such as BIND, care
must be taken because the space character is used as a field separator,
and other characters like dot (\'.\'), semicolon (\';\'), dollar
(\'\$\'), backslash (\'\\\'), etc., also have special meaning. These
characters have to be escaped when entered into a textual zone file,
following the rules in [Section
5.1](https://www.rfc-editor.org/rfc/rfc1035#section-5.1){.relref} of the
DNS specification \[[RFC1035](#RFC1035){.xref}\]. For example, a literal
space in a name is represented in the textual zone file using \'\\032\',
so \"Building 1.example.com\" is entered as
\"Building\\0321.example.com\".[¶](#section-5.2.1-4){.pilcrow}

DNS responses are limited to a maximum size of 65535 bytes. This limits
the maximum number of domains that can be returned for a Domain
Enumeration query as follows:[¶](#section-5.2.1-5){.pilcrow}

A DNS response header is 12 bytes. That\'s typically followed by a
single qname (up to 256 bytes) plus qtype (2 bytes) and qclass
(2 bytes), leaving 65275 for the Answer
Section.[¶](#section-5.2.1-6){.pilcrow}

An Answer Section Resource Record consists
of:[¶](#section-5.2.1-7){.pilcrow}

-   [Owner name, encoded as a compression pointer, 2
    bytes[¶](#section-5.2.1-8.1){.pilcrow}]{#section-5.2.1-8.1}
-   [RRTYPE (type PTR), 2
    bytes[¶](#section-5.2.1-8.2){.pilcrow}]{#section-5.2.1-8.2}
-   [RRCLASS (class IN), 2
    bytes[¶](#section-5.2.1-8.3){.pilcrow}]{#section-5.2.1-8.3}
-   [TTL, 4 bytes[¶](#section-5.2.1-8.4){.pilcrow}]{#section-5.2.1-8.4}
-   [RDLENGTH, 2
    bytes[¶](#section-5.2.1-8.5){.pilcrow}]{#section-5.2.1-8.5}
-   [RDATA (domain name), up to 256
    bytes[¶](#section-5.2.1-8.6){.pilcrow}]{#section-5.2.1-8.6}

This means that each Resource Record in the Answer Section can take up
to 268 bytes total, which means that the Answer Section can contain, in
the worst case, no more than 243 domains.[¶](#section-5.2.1-9){.pilcrow}

In a more typical scenario, where the domain names are not all
maximum-sized names, and there is some similarity between names so that
reasonable name compression is possible, each Answer Section Resource
Record may average 140 bytes, which means that the Answer Section can
contain up to 466 domains.[¶](#section-5.2.1-10){.pilcrow}

It is anticipated that this should be sufficient for even a large
corporate network or university campus.[¶](#section-5.2.1-11){.pilcrow}
:::
:::

::: {#multicast}
::: {#section-5.2.2 .section}
#### [5.2.2.](#section-5.2.2){.section-number .selfRef} [Domain Enumeration via Multicast Queries](#name-domain-enumeration-via-mult){.section-name .selfRef} {#name-domain-enumeration-via-mult}

In the case where Discovery Proxy functionality is widely deployed
within an enterprise (either by having a Discovery Proxy physically on
each link, or by having a Discovery Proxy with a remote \"virtual\"
presence on each link using VLANs or Multicast DNS Discovery Relays
\[[RELAY](#I-D.sctl-dnssd-mdns-relay){.xref}\]), this offers an
additional way to provide Domain Enumeration configuration data for
clients.[¶](#section-5.2.2-1){.pilcrow}

Note that this function of the Discovery Proxy is supplementary to the
primary purpose of the Discovery Proxy, which is to facilitate *remote*
clients discovering services on the Discovery Proxy\'s local link. This
publication of Domain Enumeration configuration data via link-local
multicast on the Discovery Proxy\'s local link is performed for the
benefit of *local* clients attached to that link, and typically directs
those clients to contact other distant Discovery Proxies attached to
other links. Generally, a client does not need to use the local
Discovery Proxy on its own link, because a client is generally able to
perform its own Multicast DNS queries on that link. (The exception to
this is when the local Wi-Fi access point is blocking or filtering local
multicast traffic, requiring even local clients to use their local
Discovery Proxy to perform local
discovery.)[¶](#section-5.2.2-2){.pilcrow}

A Discovery Proxy can be configured to generate Multicast DNS responses
for the following Multicast DNS Domain Enumeration queries issued by
clients:[¶](#section-5.2.2-3){.pilcrow}

::: {#section-5.2.2-4 .artwork .art-text .alignLeft}
        b._dns-sd._udp.local.    PTR   ?
        db._dns-sd._udp.local.   PTR   ?
        lb._dns-sd._udp.local.   PTR   ?

[¶](#section-5.2.2-4){.pilcrow}
:::

This provides the ability for Discovery Proxies to indicate recommended
browsing domains to DNS-SD clients on a per-link granularity. In some
enterprises, it may be preferable to provide this per-link configuration
information in the form of Discovery Proxy configuration data rather
than by populating the Unicast DNS servers with the same data (in the
\"ip6.arpa\" or \"in-addr.arpa\"
domains).[¶](#section-5.2.2-5){.pilcrow}

Regardless of how the network operator chooses to provide this
configuration data, clients will perform Domain Enumeration via both
unicast and multicast queries and then combine the results of these
queries.[¶](#section-5.2.2-6){.pilcrow}
:::
:::
:::
:::

::: {#dom-host}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Delegated Subdomain for LDH Host Names](#name-delegated-subdomain-for-ldh){.section-name .selfRef} {#name-delegated-subdomain-for-ldh}

DNS-SD service instance names and domains are allowed to contain
arbitrary Net-Unicode text \[[RFC5198](#RFC5198){.xref}\], encoded as
precomposed UTF-8
\[[RFC3629](#RFC3629){.xref}\].[¶](#section-5.3-1){.pilcrow}

Users typically interact with service discovery software by viewing a
list of discovered service instance names on a display and selecting one
of them by pointing, touching, or clicking. Similarly, in software that
provides a multi-domain DNS-SD user interface, users view a list of
offered domains on the display and select one of them by pointing,
touching, or clicking. To use a service, users don\'t have to remember
domain or instance names, or type them; users just have to be able to
recognize what they see on the display and touch or click on the thing
they want.[¶](#section-5.3-2){.pilcrow}

In contrast, host names are often remembered and typed. Also, host names
have historically been used in command-line interfaces where spaces can
be inconvenient. For this reason, host names have traditionally been
restricted to letters, digits, and hyphens (LDH) with no spaces or other
punctuation.[¶](#section-5.3-3){.pilcrow}

While we do want to allow rich text for DNS-SD service instance names
and domains, it is advisable, for maximum compatibility with existing
usage, to restrict host names to the traditional letter-digit-hyphen
rules. This means that while the service name
\"My Printer.\_ipp.\_tcp.Building 1.example.com\" is acceptable and
desirable (it is displayed in a graphical user interface as an instance
called \"My Printer\" in the domain \"Building 1\" at \"example.com\"),
the host name \"My-Printer.Building 1.example.com\" is less desirable
(because of the space in \"Building 1\").[¶](#section-5.3-4){.pilcrow}

To accommodate this difference in allowable characters, a Discovery
Proxy [SHOULD]{.bcp14} support having two separate subdomains delegated
to it for each link it serves: one whose name is allowed to contain
arbitrary Net-Unicode text \[[RFC5198](#RFC5198){.xref}\], and a second
more constrained subdomain whose name is restricted to contain only
letters, digits, and hyphens, to be used for host name records (names of
\'A\' and \'AAAA\' address records). The restricted names may be any
valid name consisting of only letters, digits, and hyphens, including
Punycode-encoded names
\[[RFC3492](#RFC3492){.xref}\].[¶](#section-5.3-5){.pilcrow}

For example, a Discovery Proxy could have the two subdomains
\"Building 1.example.com\" and \"bldg‑1.example.com\" delegated to it.
The Discovery Proxy would then translate these two Multicast DNS
records:[¶](#section-5.3-6){.pilcrow}

::: {#section-5.3-7 .artwork .art-text .alignLeft}
       My Printer._ipp._tcp.local. SRV 0 0 631 prnt.local.
       prnt.local.                 A   203.0.113.2

[¶](#section-5.3-7){.pilcrow}
:::

into Unicast DNS records as follows:[¶](#section-5.3-8){.pilcrow}

::: {#section-5.3-9 .artwork .art-text .alignLeft}
       My Printer._ipp._tcp.Building 1.example.com.
                                   SRV 0 0 631 prnt.bldg-1.example.com.
       prnt.bldg-1.example.com.     A   203.0.113.2

[¶](#section-5.3-9){.pilcrow}
:::

Note that the SRV record name is translated using the rich-text domain
name (\"Building 1.example.com\"), and the address record name is
translated using the LDH domain (\"bldg‑1.example.com\"). Further
details of the name translation rules are described in [Section
5.5](#translation){.xref}.[¶](#section-5.3-10){.pilcrow}

A Discovery Proxy [MAY]{.bcp14} support only a single rich-text
Net-Unicode domain and use that domain for all records, including \'A\'
and \'AAAA\' address records, but implementers choosing this option
should be aware that this choice may produce host names that are awkward
to use in command-line environments. Whether or not this is an issue
depends on whether users in the target environment are expected to be
using command-line interfaces.[¶](#section-5.3-11){.pilcrow}

A Discovery Proxy [MUST NOT]{.bcp14} be restricted to support only a
letter-digit-hyphen subdomain, because that results in an unnecessarily
poor user experience.[¶](#section-5.3-12){.pilcrow}

As described in [Section 5.2.1](#unicast){.xref}, for clarity, in
examples here space characters in names are shown as actual spaces. If
this dynamically discovered data were to be manually entered into a
textual zone file (which it isn\'t), then spaces would need to be
represented using \'\\032\', so
\"My Printer.\_ipp.\_tcp.Building 1.example.com\" would become
\"My\\032Printer.\_ipp.\_tcp.Building\\0321.example.com\".[¶](#section-5.3-13){.pilcrow}

Note that the \'\\032\' representation does not appear in DNS messages
sent over the air. In the wire format of DNS messages, spaces are sent
as spaces, not as \'\\032\', and likewise, in a graphical user interface
at the client device, spaces are shown as spaces, not as
\'\\032\'.[¶](#section-5.3-14){.pilcrow}
:::
:::

::: {#dom-rev}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [Delegated Subdomain for Reverse Mapping](#name-delegated-subdomain-for-rev){.section-name .selfRef} {#name-delegated-subdomain-for-rev}

A Discovery Proxy can facilitate easier management of reverse mapping
domains, particularly for IPv6 addresses where manual management may be
more onerous than it is for IPv4 addresses.[¶](#section-5.4-1){.pilcrow}

To achieve this, in the parent domain, NS records are used to delegate
ownership of the appropriate reverse mapping domain to the Discovery
Proxy. In other words, the Discovery Proxy becomes the authoritative
name server for the reverse mapping domain. For fault tolerance reasons,
there may be more than one Discovery Proxy serving a given
link.[¶](#section-5.4-2){.pilcrow}

If a given link is using the IPv4 subnet 203.0.113/24, then the domain
\"113.0.203.in-addr.arpa\" is delegated to the Discovery Proxy for that
link.[¶](#section-5.4-3){.pilcrow}

If a given link is using the IPv6 prefix 2001:0DB8:1234:5678::/64, then
the domain \"8.7.6.5.4.3.2.1.8.b.d.0.1.0.0.2.ip6.arpa\" is delegated to
the Discovery Proxy for that link.[¶](#section-5.4-4){.pilcrow}

When a reverse mapping query arrives at the Discovery Proxy, it issues
the identical query on its local link, as a Multicast DNS query. The
mechanism to force an apparently unicast name to be resolved using
link-local Multicast DNS varies depending on the API set being used. For
example, in the \"dns_sd.h\" APIs (available on macOS, iOS, Bonjour for
Windows, Linux, and Android), using kDNSServiceFlagsForceMulticast
indicates that the DNSServiceQueryRecord() call should perform the query
using Multicast DNS. Other API sets have different ways of forcing
multicast queries. When the host owning that IPv4 or IPv6 address
responds with a name of the form \"something.local\", the Discovery
Proxy rewrites it to use its configured LDH host name domain instead of
\".local\" and returns the response to the
caller.[¶](#section-5.4-5){.pilcrow}

For example, a Discovery Proxy with the two subdomains
\"113.0.203.in‑addr.arpa\" and \"bldg‑1.example.com\" delegated to it
would translate this Multicast DNS record:[¶](#section-5.4-6){.pilcrow}

::: {#section-5.4-7 .artwork .art-text .alignLeft}
       2.113.0.203.in-addr.arpa. PTR prnt.local.

[¶](#section-5.4-7){.pilcrow}
:::

into this Unicast DNS response:[¶](#section-5.4-8){.pilcrow}

::: {#section-5.4-9 .artwork .art-text .alignLeft}
       2.113.0.203.in-addr.arpa. PTR prnt.bldg-1.example.com.

[¶](#section-5.4-9){.pilcrow}
:::

In this example the \"prnt.local\" host name is translated using the
delegated LDH subdomain, as described in [Section
5.5](#translation){.xref}.[¶](#section-5.4-10){.pilcrow}

Subsequent queries for the prnt.bldg‑1.example.com address record,
falling as it does within the bldg‑1.example.com domain, which is
delegated to this Discovery Proxy, will arrive at this Discovery Proxy
where they are answered by issuing Multicast DNS queries and using the
received Multicast DNS answers to synthesize Unicast DNS responses, as
described above.[¶](#section-5.4-11){.pilcrow}

Note that this description assumes that all addresses on a given IPv4
subnet or IPv6 prefix are mapped to host names using the Discovery Proxy
mechanism. It would be possible to implement a Discovery Proxy that can
be configured so that some address-to-name mappings are performed using
Multicast DNS on the local link, while other address-to-name mappings
within the same IPv4 subnet or IPv6 prefix are configured
manually.[¶](#section-5.4-12){.pilcrow}
:::
:::

::: {#translation}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [Data Translation](#name-data-translation){.section-name .selfRef} {#name-data-translation}

For the delegated rich-text and LDH subdomains, generating appropriate
Multicast DNS queries involves translating from the configured DNS
domain (e.g., \"Building 1.example.com\") on the Unicast DNS side to
\".local\" on the Multicast DNS side.[¶](#section-5.5-1){.pilcrow}

For the delegated reverse-mapping subdomain, generating appropriate
Multicast DNS queries involves using the appropriate API mechanism to
indicate that a query should be performed using Multicast DNS, as
described in [Section
5.4](#dom-rev){.xref}.[¶](#section-5.5-2){.pilcrow}

Generating appropriate Unicast DNS responses from the received Multicast
DNS answers involves translating back from \".local\" to the appropriate
configured Unicast DNS domain as necessary, as described
below.[¶](#section-5.5-3){.pilcrow}

In the examples below, the delegated subdomains are as
follows:[¶](#section-5.5-4){.pilcrow}

::: {#section-5.5-5 .artwork .art-text .alignLeft}
    Delegated subdomain for rich-text names       Building 1.example.com.
    Delegated subdomain for LDH names                 bldg‑1.example.com.
    Delegated subdomain for IPv4 reverse mapping  113.0.203.in-addr.arpa.

[¶](#section-5.5-5){.pilcrow}
:::

Names in Multicast DNS answers that do not end in \".local\" do not
require any translation.[¶](#section-5.5-6){.pilcrow}

Names in Multicast DNS answers that end in \".local\" are only
meaningful on the local link, and require translation to make them
useable by clients outside the local link.[¶](#section-5.5-7){.pilcrow}

Names that end in \".local\" may appear both as the owner names of
received Multicast DNS answer records, and in the RDATA of received
Multicast DNS answer records.[¶](#section-5.5-8){.pilcrow}

In a received Multicast DNS answer record, if the owner name ends with
\".local\", then the \".local\" top-level label is replaced with the
name of the delegated subdomain as was used in the originating
query.[¶](#section-5.5-9){.pilcrow}

In a received Multicast DNS answer record, if a name in the RDATA ends
with \".local\", then the name is translated according to the delegated
subdomain that was used in the originating query, as explained
below.[¶](#section-5.5-10){.pilcrow}

For queries in subdomains delegated for LDH host names, \".local\" names
in RDATA are translated to that delegated LDH subdomain. For example, a
query for \"thing.bldg‑1.example.com\" will be translated to a Multicast
DNS query for \"thing.local\". If that query returns this CNAME
record:[¶](#section-5.5-11){.pilcrow}

::: {#section-5.5-12 .artwork .art-text .alignLeft}
      thing.local.               CNAME  prnt.local.

[¶](#section-5.5-12){.pilcrow}
:::

then both the owner name and the name in the RDATA are translated from
\".local\" to the LDH subdomain
\"bldg‑1.example.com\":[¶](#section-5.5-13){.pilcrow}

::: {#section-5.5-14 .artwork .art-text .alignLeft}
      thing.bldg‑1.example.com.  CNAME  prnt.bldg‑1.example.com.

[¶](#section-5.5-14){.pilcrow}
:::

For queries in subdomains delegated for reverse mapping names,
\".local\" names in RDATA are translated to the delegated LDH subdomain,
if one is configured, or to the delegated rich-text subdomain otherwise.
For example, consider a reverse mapping query that returns this PTR
record:[¶](#section-5.5-15){.pilcrow}

::: {#section-5.5-16 .artwork .art-text .alignLeft}
      2.113.0.203.in-addr.arpa.  PTR  prnt.local.

[¶](#section-5.5-16){.pilcrow}
:::

The owner name is not translated because it does not end in \".local\".
The name in the RDATA is translated from \".local\" to the LDH subdomain
\"bldg‑1.example.com\":[¶](#section-5.5-17){.pilcrow}

::: {#section-5.5-18 .artwork .art-text .alignLeft}
      2.113.0.203.in-addr.arpa.  PTR  prnt.bldg‑1.example.com.

[¶](#section-5.5-18){.pilcrow}
:::

For queries in subdomains delegated for rich-text names, \".local\"
names in RDATA are translated according to whether or not they represent
host names (i.e., RDATA names that are the owner names of A and AAAA DNS
records). RDATA names ending in \".local\" that represent host names are
translated to the delegated LDH subdomain, if one is configured, or to
the delegated rich-text subdomain otherwise. All other RDATA names
ending in \".local\" are translated to the delegated rich-text
subdomain. For example, consider a DNS-SD service browsing PTR query
that returns this PTR record for IPP
printing:[¶](#section-5.5-19){.pilcrow}

::: {#section-5.5-20 .artwork .art-text .alignLeft}
      _ipp._tcp.local.  PTR  My Printer._ipp._tcp.local.

[¶](#section-5.5-20){.pilcrow}
:::

Both the owner name and the name in the RDATA are translated from
\".local\" to the rich-text subdomain:[¶](#section-5.5-21){.pilcrow}

::: {#section-5.5-22 .artwork .art-text .alignLeft}
      _ipp._tcp.Building 1.example.com.
                        PTR  My Printer._ipp._tcp.Building 1.example.com.

[¶](#section-5.5-22){.pilcrow}
:::

In contrast, consider a query that returns this SRV record for a
specific IPP printing instance:[¶](#section-5.5-23){.pilcrow}

::: {#section-5.5-24 .artwork .art-text .alignLeft}
      My Printer._ipp._tcp.local.  SRV  0 0 631 prnt.local.

[¶](#section-5.5-24){.pilcrow}
:::

As for all queries, the owner name is translated to the delegated
subdomain of the originating query, the delegated rich-text subdomain
\"Building 1.example.com\". However, the \".local\" name in the RDATA is
the target host name field of an SRV record, a field that is used
exclusively for host names. Consequently it is translated to the LDH
subdomain \"bldg‑1.example.com\", if configured, instead of the
rich-text subdomain:[¶](#section-5.5-25){.pilcrow}

::: {#section-5.5-26 .artwork .art-text .alignLeft}
      My Printer._ipp._tcp.Building 1.example.com.
                                   SRV  0 0 631 prnt.bldg‑1.example.com.

[¶](#section-5.5-26){.pilcrow}
:::

Other beneficial translation and filtering operations are described
below.[¶](#section-5.5-27){.pilcrow}

::: {#ttl}
::: {#section-5.5.1 .section}
#### [5.5.1.](#section-5.5.1){.section-number .selfRef} [DNS TTL Limiting](#name-dns-ttl-limiting){.section-name .selfRef} {#name-dns-ttl-limiting}

For efficiency, Multicast DNS typically uses moderately high DNS TTL
values. For example, the typical TTL on DNS-SD service browsing PTR
records is 75 minutes. What makes these moderately high TTLs acceptable
is the cache coherency mechanisms built in to the Multicast DNS
protocol, which protect against stale data persisting for too long. When
a service shuts down gracefully, it sends goodbye packets to remove its
service browsing PTR record(s) immediately from neighboring caches. If a
service shuts down abruptly without sending goodbye packets, the Passive
Observation Of Failures (POOF) mechanism described in [Section
10.5](https://www.rfc-editor.org/rfc/rfc6762#section-10.5){.relref} of
the Multicast DNS specification \[[RFC6762](#RFC6762){.xref}\] comes
into play to purge the cache of stale
data.[¶](#section-5.5.1-1){.pilcrow}

A traditional Unicast DNS client on a distant remote link does not get
to participate in these Multicast DNS cache coherency mechanisms on the
local link. For traditional Unicast DNS queries (those received without
using Long-Lived Queries (LLQ) \[[RFC8764](#RFC8764){.xref}\] or DNS
Push Notification subscriptions \[[RFC8765](#RFC8765){.xref}\]), the DNS
TTLs reported in the resulting Unicast DNS response [MUST]{.bcp14} be
capped to be no more than ten seconds.[¶](#section-5.5.1-2){.pilcrow}

Similarly, for negative responses, the negative caching TTL indicated in
the SOA record \[[RFC2308](#RFC2308){.xref}\] should also be ten seconds
(see [Section 6.1](#soa){.xref}).[¶](#section-5.5.1-3){.pilcrow}

This value of ten seconds is chosen based on user-experience
considerations.[¶](#section-5.5.1-4){.pilcrow}

For negative caching, suppose a user is attempting to access a remote
device (e.g., a printer), and they are unsuccessful because that device
is powered off. Suppose they then place a telephone call and ask for the
device to be powered on. We want the device to become available to the
user within a reasonable time period. It is reasonable to expect it to
take on the order of ten seconds for a simple device with a simple
embedded operating system to power on. Once the device is powered on and
has announced its presence on the network via Multicast DNS, we would
like it to take no more than a further ten seconds for stale negative
cache entries to expire from Unicast DNS caches, making the device
available to the user desiring to access
it.[¶](#section-5.5.1-5){.pilcrow}

Similar reasoning applies to capping positive TTLs at ten seconds. In
the event of a device moving location, getting a new DHCP address, or
other renumbering events, we would like the updated information to be
available to remote clients in a relatively timely
fashion.[¶](#section-5.5.1-6){.pilcrow}

However, network administrators should be aware that many recursive
resolvers by default are configured to impose a minimum TTL of 30
seconds. If stale data appears to be persisting in the network to the
extent that it adversely impacts user experience, network administrators
are advised to check the configuration of their recursive
resolvers.[¶](#section-5.5.1-7){.pilcrow}

For received Unicast DNS queries that use LLQ
\[[RFC8764](#RFC8764){.xref}\] or DNS Push Notifications
\[[RFC8765](#RFC8765){.xref}\], the Multicast DNS record\'s TTL
[SHOULD]{.bcp14} be returned unmodified, because the notification
channel exists to inform the remote client as records come and go. For
further details about Long-Lived Queries and its newer replacement, DNS
Push Notifications, see [Section
5.6](#aggregation){.xref}.[¶](#section-5.5.1-8){.pilcrow}
:::
:::

::: {#unusable}
::: {#section-5.5.2 .section}
#### [5.5.2.](#section-5.5.2){.section-number .selfRef} [Suppressing Unusable Records](#name-suppressing-unusable-record){.section-name .selfRef} {#name-suppressing-unusable-record}

A Discovery Proxy [SHOULD]{.bcp14} offer a configurable option, enabled
by default, to suppress Unicast DNS answers for records that are not
useful outside the local link. When the option to suppress unusable
records is enabled:[¶](#section-5.5.2-1){.pilcrow}

-   [For a Discovery Proxy that is serving only clients outside the
    local link, DNS A and AAAA records for IPv4 link-local addresses
    \[[RFC3927](#RFC3927){.xref}\] and IPv6 link-local addresses
    \[[RFC4862](#RFC4862){.xref}\] [SHOULD]{.bcp14} be
    suppressed.[¶](#section-5.5.2-2.1){.pilcrow}]{#section-5.5.2-2.1}
-   [Similarly, for sites that have multiple private address realms
    \[[RFC1918](#RFC1918){.xref}\], in cases where the Discovery Proxy
    can determine that the querying client is in a different address
    realm, private addresses [SHOULD NOT]{.bcp14} be communicated to
    that client.[¶](#section-5.5.2-2.2){.pilcrow}]{#section-5.5.2-2.2}
-   [IPv6 Unique Local Addresses \[[RFC4193](#RFC4193){.xref}\]
    [SHOULD]{.bcp14} be suppressed in cases where the Discovery Proxy
    can determine that the querying client is in a different IPv6
    address realm.[¶](#section-5.5.2-2.3){.pilcrow}]{#section-5.5.2-2.3}
-   [By the same logic, DNS SRV records that reference target host names
    that have no addresses usable by the requester should be suppressed,
    and likewise, DNS-SD service browsing PTR records that point to
    unusable SRV records should similarly be
    suppressed.[¶](#section-5.5.2-2.4){.pilcrow}]{#section-5.5.2-2.4}
:::
:::

::: {#section-5.5.3 .section}
#### [5.5.3.](#section-5.5.3){.section-number .selfRef} [NSEC and NSEC3 Queries](#name-nsec-and-nsec3-queries){.section-name .selfRef} {#name-nsec-and-nsec3-queries}

Multicast DNS devices do not routinely announce their records on the
network. Generally, they remain silent until queried. This means that
the complete set of Multicast DNS records in use on a link can only be
discovered by active querying, not by passive listening. Because of
this, a Discovery Proxy can only know what names exist on a link by
issuing queries for them, and since it would be impractical to issue
queries for every possible name just to find out which names exist and
which do not, a Discovery Proxy cannot programmatically generate the
traditional Unicast DNS NSEC \[[RFC4034](#RFC4034){.xref}\] and NSEC3
\[[RFC5155](#RFC5155){.xref}\] records that assert the nonexistence of a
large range of names.[¶](#section-5.5.3-1){.pilcrow}

When queried for an NSEC or NSEC3 record type, the Discovery Proxy
issues a qtype \"ANY\" query using Multicast DNS on the local link and
then generates an NSEC or NSEC3 response with a Type Bit Map signifying
which record types do and do not exist for just the specific name
queried, and no other names.[¶](#section-5.5.3-2){.pilcrow}

Multicast DNS NSEC records received on the local link [MUST NOT]{.bcp14}
be forwarded unmodified to a unicast querier, because there are slight
differences in the NSEC record data. In particular, Multicast DNS NSEC
records do not have the NSEC bit set in the Type Bit Map, whereas
conventional Unicast DNS NSEC records do have the NSEC bit
set.[¶](#section-5.5.3-3){.pilcrow}
:::

::: {#notrans}
::: {#section-5.5.4 .section}
#### [5.5.4.](#section-5.5.4){.section-number .selfRef} [No Text-Encoding Translation](#name-no-text-encoding-translatio){.section-name .selfRef} {#name-no-text-encoding-translatio}

A Discovery Proxy does no translation between text encodings.
Specifically, a Discovery Proxy does no translation between Punycode
encoding \[[RFC3492](#RFC3492){.xref}\] and UTF-8 encoding
\[[RFC3629](#RFC3629){.xref}\], either in the owner name of DNS records
or anywhere in the RDATA of DNS records (such as the RDATA of PTR
records, SRV records, NS records, or other record types like TXT, where
it is ambiguous whether the RDATA may contain DNS names). All bytes are
treated as-is with no attempt at text-encoding translation. A client
implementing DNS-based Service Discovery \[[RFC6763](#RFC6763){.xref}\]
will use UTF-8 encoding for its unicast DNS-based Service Discovery
queries, which the Discovery Proxy passes through without any
text-encoding translation to the Multicast DNS subsystem. Responses from
the Multicast DNS subsystem are similarly returned, without any
text-encoding translation, back to the requesting unicast
client.[¶](#section-5.5.4-1){.pilcrow}
:::
:::

::: {#section-5.5.5 .section}
#### [5.5.5.](#section-5.5.5){.section-number .selfRef} [Application-Specific Data Translation](#name-application-specific-data-t){.section-name .selfRef} {#name-application-specific-data-t}

There may be cases where Application-Specific Data Translation is
appropriate.[¶](#section-5.5.5-1){.pilcrow}

For example, AirPrint printers tend to advertise fairly verbose
information about their capabilities in their DNS-SD TXT record. TXT
record sizes in the range of 500-1000 bytes are not uncommon. This
information is a legacy from lineprinter (LPR) printing, because LPR
does not have in-band capability negotiation, so all of this information
is conveyed using the DNS-SD TXT record instead. Internet Printing
Protocol (IPP) printing does have in-band capability negotiation, but
for convenience, printers tend to include the same capability
information in their IPP DNS-SD TXT records as well. For local Multicast
DNS (mDNS) use, this extra TXT record information is wasteful but not
fatal. However, when a Discovery Proxy aggregates data from multiple
printers on a link, and sends it via unicast (via UDP or TCP), this
amount of unnecessary TXT record information can result in large
responses. A DNS reply over TCP carrying information about 70 printers
with an average of 700 bytes per printer adds up to about 50 kilobytes
of data. Therefore, a Discovery Proxy that is aware of the specifics of
an application-layer protocol such as AirPrint (which uses IPP) can
elide unnecessary key/value pairs from the DNS-SD TXT record for better
network efficiency.[¶](#section-5.5.5-2){.pilcrow}

Also, the DNS-SD TXT record for many printers contains an \"adminurl\"
key (e.g., \"adminurl=http://printername.local/status.html\"). For this
URL to be useful outside the local link, the embedded \".local\" host
name needs to be translated to an appropriate name with larger scope. It
is easy to translate \".local\" names when they appear in well-defined
places: as a record\'s owner name, or in domain name fields in the RDATA
of record types like PTR and SRV. In the printing case, some
application-specific knowledge about the semantics of the \"adminurl\"
key is needed for the Discovery Proxy to know that it contains a name
that needs to be translated. This is somewhat analogous to the need for
NAT gateways to contain ALGs (Application-Level Gateways) to facilitate
the correct translation of protocols that embed addresses in unexpected
places.[¶](#section-5.5.5-3){.pilcrow}

To avoid the need for application-specific knowledge about the semantics
of particular TXT record keys, protocol designers are advised to avoid
placing link-local names or link-local IP addresses in TXT record keys
if translation of those names or addresses would be required for
off-link operation. In the printing case, the consequence of failing to
translate the \"adminurl\" key correctly would be that, when accessed
from a different link, printing will still work, but clicking the
\"Admin\" user interface button will fail to open the printer\'s
administration page. Rather than duplicating the host name from the
service\'s SRV record in its \"adminurl\" key, thereby having the same
host name appear in two places, a better design might have been to omit
the host name from the \"adminurl\" key and instead have the client
implicitly substitute the target host name from the service\'s SRV
record in place of a missing host name in the \"adminurl\" key. That
way, the desired host name only appears once and is in a well-defined
place where software like the Discovery Proxy is expecting to find
it.[¶](#section-5.5.5-4){.pilcrow}

Note that this kind of Application-Specific Data Translation is expected
to be very rare; it is the exception rather than the rule. This is an
example of a common theme in computing. It is frequently the case that
it is wise to start with a clean, layered design with clear boundaries.
Then, in certain special cases, those layer boundaries may be violated
where the performance and efficiency benefits outweigh the inelegance of
the layer violation.[¶](#section-5.5.5-5){.pilcrow}

These layer violations are optional. They are done primarily for
efficiency reasons and generally should not be required for correct
operation. A Discovery Proxy [MAY]{.bcp14} operate solely at the mDNS
layer without any knowledge of semantics at the DNS-SD layer or
above.[¶](#section-5.5.5-6){.pilcrow}
:::
:::
:::

::: {#aggregation}
::: {#section-5.6 .section}
### [5.6.](#section-5.6){.section-number .selfRef} [Answer Aggregation](#name-answer-aggregation){.section-name .selfRef} {#name-answer-aggregation}

In a simple analysis, simply gathering multicast answers and forwarding
them in a unicast response seems adequate, but it raises the question of
how long the Discovery Proxy should wait to be sure that it has received
all the Multicast DNS answers it needs to form a complete Unicast DNS
response. If it waits too little time, then it risks its Unicast DNS
response being incomplete. If it waits too long, then it creates a poor
user experience at the client end. In fact, there may be no time that is
both short enough to produce a good user experience and at the same time
long enough to reliably produce complete
results.[¶](#section-5.6-1){.pilcrow}

Similarly, the Discovery Proxy (the authoritative name server for the
subdomain in question) needs to decide what DNS TTL to report for these
records. If the TTL is too long, then the recursive resolvers issuing
queries on behalf of their clients risk caching stale data for too long.
If the TTL is too short, then the amount of network traffic will be more
than necessary. In fact, there may be no TTL that is both short enough
to avoid undesirable stale data and, at the same time, long enough to be
efficient on the network.[¶](#section-5.6-2){.pilcrow}

Both these dilemmas are solved by the use of DNS Long-Lived Queries
(LLQ) \[[RFC8764](#RFC8764){.xref}\] or its newer replacement, DNS Push
Notifications
\[[RFC8765](#RFC8765){.xref}\].[¶](#section-5.6-3){.pilcrow}

Clients supporting unicast DNS-based Service Discovery [SHOULD]{.bcp14}
implement DNS Push Notifications \[[RFC8765](#RFC8765){.xref}\] for
improved user experience.[¶](#section-5.6-4){.pilcrow}

Clients and Discovery Proxies [MAY]{.bcp14} support both LLQ and
DNS Push Notifications, and when talking to a Discovery Proxy that
supports both, the client may use either protocol, as it chooses, though
it is expected that only DNS Push Notifications will continue to be
supported in the long run.[¶](#section-5.6-5){.pilcrow}

When a Discovery Proxy receives a query using LLQ or DNS Push
Notifications, it responds immediately using the Multicast DNS records
it already has in its cache (if any). This provides a good client user
experience by providing a near-instantaneous response. Simultaneously,
the Discovery Proxy issues a Multicast DNS query on the local link to
discover if there are any additional Multicast DNS records it did not
already know about. Should additional Multicast DNS responses be
received, these are then delivered to the client using additional LLQ or
DNS Push Notification update messages. The timeliness of such update
messages is limited only by the timeliness of the device responding to
the Multicast DNS query. If the Multicast DNS device responds quickly,
then the update message is delivered quickly. If the Multicast DNS
device responds slowly, then the update message is delivered slowly. The
benefit of using multiple update messages to deliver results as they
become available is that the Discovery Proxy can respond promptly
because it doesn\'t have to deliver all the results in a single response
that needs to be delayed to allow for the expected worst-case delay for
receiving all the Multicast DNS responses.[¶](#section-5.6-6){.pilcrow}

With a proxy that supported only standard DNS queries, even if it were
to try to provide reliability by assuming an excessively pessimistic
worst-case time (thereby giving a very poor user experience), there
would still be the risk of a slow Multicast DNS device taking even
longer than that worst-case time (e.g., a device that is not even
powered on until ten seconds after the initial query is received),
resulting in incomplete responses. Using update messages to deliver
subsequent asynchronous replies solves this dilemma: even very late
responses are not lost; they are delivered in subsequent update
messages.[¶](#section-5.6-7){.pilcrow}

Note that while normal DNS queries are generally received via the
client\'s configured recursive resolver, LLQ and DNS Push Notification
subscriptions may be received directly from the
client.[¶](#section-5.6-8){.pilcrow}

There are two factors that determine how unicast responses are
generated:[¶](#section-5.6-9){.pilcrow}

The first factor is whether or not the Discovery Proxy already has at
least one record in its cache that answers the
question.[¶](#section-5.6-10){.pilcrow}

The second factor is whether the client used a normal DNS query, or
established a subscription using LLQ or DNS Push Notifications. Normal
DNS queries are typically used for one-shot operations like SRV or
address record queries. LLQ and DNS Push Notification subscriptions are
typically used for long-lived service browsing PTR queries. Normal DNS
queries and LLQ each have different response timing depending on the
cache state, yielding the first four cases listed below. DNS Push
Notifications, the newer protocol, has uniform behavior regardless of
cache state, yielding the fifth case listed
below.[¶](#section-5.6-11){.pilcrow}

-   ::: {#section-5.6-12.1}
    Standard DNS query; no answer in
    cache:[¶](#section-5.6-12.1.1){.pilcrow}

    Issue an mDNS query on the local link, exactly as a local client
    would issue an mDNS query, for the desired record name, type, and
    class, including retransmissions, as appropriate, according to the
    established mDNS retransmission schedule
    \[[RFC6762](#RFC6762){.xref}\]. The Discovery Proxy awaits Multicast
    DNS responses.[¶](#section-5.6-12.1.2){.pilcrow}

    As soon as any Multicast DNS response packet is received that
    contains one or more positive answers to that question (with or
    without the Cache Flush bit \[[RFC6762](#RFC6762){.xref}\] set) or a
    negative answer (signified via a Multicast DNS NSEC record
    \[[RFC6762](#RFC6762){.xref}\]), the Discovery Proxy generates a
    Unicast DNS response message containing the corresponding (filtered
    and translated) answers and sends it to the remote
    client.[¶](#section-5.6-12.1.3){.pilcrow}

    If after six seconds no relevant Multicast DNS answers have been
    received, cancel the mDNS query and return a negative response to
    the remote client. Six seconds is enough time for the underlying
    Multicast DNS subsystem to transmit three mDNS queries and allow
    some time for responses to arrive.[¶](#section-5.6-12.1.4){.pilcrow}

    (Reasoning: Queries not using LLQ or Push Notifications are
    generally queries that expect an answer from only one device, so the
    first response is also the only
    response.)[¶](#section-5.6-12.1.5){.pilcrow}

    DNS TTLs in responses [MUST]{.bcp14} be capped to at most ten
    seconds.[¶](#section-5.6-12.1.6){.pilcrow}
    :::

-   ::: {#section-5.6-12.2}
    Standard DNS query; at least one answer in
    cache:[¶](#section-5.6-12.2.1){.pilcrow}

    No local mDNS queries are
    performed.[¶](#section-5.6-12.2.2){.pilcrow}

    The Discovery Proxy generates a Unicast DNS response message
    containing the answer(s) from the cache right away, to minimize
    delay.[¶](#section-5.6-12.2.3){.pilcrow}

    (Reasoning: Queries not using LLQ or Push Notifications are
    generally queries that expect an answer from only one device. Given
    RRSet TTL harmonization, if the proxy has one Multicast DNS answer
    in its cache, it can reasonably assume that it has the whole
    set.)[¶](#section-5.6-12.2.4){.pilcrow}

    DNS TTLs in responses [MUST]{.bcp14} be capped to at most ten
    seconds.[¶](#section-5.6-12.2.5){.pilcrow}
    :::

-   ::: {#section-5.6-12.3}
    Long-Lived Query (LLQ); no answer in
    cache:[¶](#section-5.6-12.3.1){.pilcrow}

    As in the case above with no answer in the cache, plan to perform
    mDNS querying for six seconds, returning an LLQ response message to
    the remote client as soon as any relevant mDNS response is
    received.[¶](#section-5.6-12.3.2){.pilcrow}

    If after six seconds no relevant mDNS answers have been received,
    and the client has not cancelled its Long-Lived Query, return a
    negative LLQ response message to the remote
    client.[¶](#section-5.6-12.3.3){.pilcrow}

    (Reasoning: We don\'t need to rush to send an empty
    answer.)[¶](#section-5.6-12.3.4){.pilcrow}

    Regardless of whether or not a relevant mDNS response is received
    within six seconds, the Long-Lived Query remains active for as long
    as the client maintains the LLQ state, and results in the ongoing
    transmission of mDNS queries until the Long-Lived Query is
    cancelled. If the set of mDNS answers changes, LLQ Event Response
    messages are sent.[¶](#section-5.6-12.3.5){.pilcrow}

    DNS TTLs in responses are returned
    unmodified.[¶](#section-5.6-12.3.6){.pilcrow}
    :::

-   ::: {#section-5.6-12.4}
    Long-Lived Query (LLQ); at least one answer in
    cache:[¶](#section-5.6-12.4.1){.pilcrow}

    As in the case above with at least one answer in the cache, the
    Discovery Proxy generates a unicast LLQ response message containing
    the answer(s) from the cache right away, to minimize
    delay.[¶](#section-5.6-12.4.2){.pilcrow}

    The Long-Lived Query remains active for as long as the client
    maintains the LLQ state, and results in the transmission of mDNS
    queries (with appropriate Known Answer lists) to determine if
    further answers are available. If the set of mDNS answers changes,
    LLQ Event Response messages are
    sent.[¶](#section-5.6-12.4.3){.pilcrow}

    (Reasoning: We want a user interface that is displayed very rapidly
    yet continues to remain accurate even as the network environment
    changes.)[¶](#section-5.6-12.4.4){.pilcrow}

    DNS TTLs in responses are returned
    unmodified.[¶](#section-5.6-12.4.5){.pilcrow}
    :::

-   ::: {#section-5.6-12.5}
    Push Notification Subscription[¶](#section-5.6-12.5.1){.pilcrow}

    The Discovery Proxy acknowledges the subscription request
    immediately.[¶](#section-5.6-12.5.2){.pilcrow}

    If one or more answers are already available in the cache, those
    answers are then sent in an immediately following DNS PUSH
    message.[¶](#section-5.6-12.5.3){.pilcrow}

    The Push Notification subscription remains active until the client
    cancels the subscription, and results in the transmission of mDNS
    queries (with appropriate Known Answer lists) to determine if
    further answers are available. If the set of mDNS answers changes,
    further DNS PUSH messages are
    sent.[¶](#section-5.6-12.5.4){.pilcrow}

    (Reasoning: We want a user interface that is displayed very rapidly
    yet continues to remain accurate even as the network environment
    changes.)[¶](#section-5.6-12.5.5){.pilcrow}

    DNS TTLs in responses are returned
    unmodified.[¶](#section-5.6-12.5.6){.pilcrow}
    :::

Where the text above refers to returning \"a negative response to the
remote client\", it is describing returning a \"no error no answer\"
negative response, not NXDOMAIN. This is because the Discovery Proxy
cannot know all the Multicast DNS domain names that may exist on a link
at any given time, so any name with no answers may have child names that
do exist, making it an \"empty non-terminal\"
name.[¶](#section-5.6-13){.pilcrow}

Note that certain aspects of the behavior described here do not have to
be implemented overtly by the Discovery Proxy; they occur naturally as a
result of using existing Multicast DNS
APIs.[¶](#section-5.6-14){.pilcrow}

For example, in the first case above (standard DNS query and no answers
in the cache), if a new Multicast DNS query is requested (either by a
local client on the Discovery Proxy device, or by the Discovery Proxy
software on that device on behalf of a remote client), and there is not
already an identical Multicast DNS query active and there are no
matching answers already in the Multicast DNS cache on the Discovery
Proxy device, then this will cause a series of Multicast DNS query
packets to be issued with exponential backoff. The exponential backoff
sequence in some implementations starts at one second and then doubles
for each retransmission (0, 1, 3, 7 seconds, etc.), and in others, it
starts at one second and then triples for each retransmission (0, 1, 4,
13 seconds, etc.). In either case, if no response has been received
after six seconds, that is long enough that the underlying Multicast DNS
implementation will have sent three query packets without receiving any
response. At that point, the Discovery Proxy cancels its Multicast DNS
query (so no further Multicast DNS query packets will be sent for this
query) and returns a negative response to the remote client via
unicast.[¶](#section-5.6-15){.pilcrow}

The six-second delay is chosen to be long enough to give enough time for
devices to respond, yet short enough not to be too onerous for a human
user waiting for a response. For example, using the \"dig\" DNS
debugging tool, the current default settings result in it waiting a
total of 15 seconds for a reply (three transmissions of the DNS UDP
query packet, with a wait of 5 seconds after each packet), which is
ample time for it to have received a negative reply from a Discovery
Proxy after six seconds.[¶](#section-5.6-16){.pilcrow}

The text above states that for a standard DNS query, if at least one
answer is already available in the cache, then a Discovery Proxy should
not issue additional mDNS query packets. This also occurs naturally as a
result of using existing Multicast DNS APIs. If a new Multicast DNS
query is requested (either locally, or by the Discovery Proxy on behalf
of a remote client) for which there are relevant answers already in the
Multicast DNS cache on the Discovery Proxy device, and after the answers
are delivered the Multicast DNS query is immediately cancelled, then no
Multicast DNS query packets will be generated for this
query.[¶](#section-5.6-17){.pilcrow}
:::
:::
:::
:::

::: {#admin}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Administrative DNS Records](#name-administrative-dns-records){.section-name .selfRef} {#name-administrative-dns-records}

::: {#soa}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [DNS SOA (Start of Authority) Record](#name-dns-soa-start-of-authority-){.section-name .selfRef} {#name-dns-soa-start-of-authority-}

The MNAME field [SHOULD]{.bcp14} contain the host name of the Discovery
Proxy device (i.e., the same domain name as the RDATA of the NS record
delegating the relevant zone(s) to this Discovery Proxy
device).[¶](#section-6.1-1){.pilcrow}

The RNAME field [SHOULD]{.bcp14} contain the mailbox of the person
responsible for administering this Discovery Proxy
device.[¶](#section-6.1-2){.pilcrow}

The SERIAL field [MUST]{.bcp14} be zero.[¶](#section-6.1-3){.pilcrow}

Zone transfers are undefined for Discovery Proxy zones, and
consequently, the REFRESH, RETRY, and EXPIRE fields have no useful
meaning for Discovery Proxy zones. These fields [SHOULD]{.bcp14} contain
reasonable default values. The [RECOMMENDED]{.bcp14} values are: REFRESH
7200, RETRY 3600, and EXPIRE 86400.[¶](#section-6.1-4){.pilcrow}

The MINIMUM field (used to control the lifetime of negative cache
entries) [SHOULD]{.bcp14} contain the value 10. This value is chosen
based on user-experience considerations (see [Section
5.5.1](#ttl){.xref}).[¶](#section-6.1-5){.pilcrow}

In the event that there are multiple Discovery Proxy devices on a link
for fault tolerance reasons, this will result in clients receiving
inconsistent SOA records (different MNAME and possibly RNAME) depending
on which Discovery Proxy answers their SOA query. However, since clients
generally have no reason to use the MNAME or RNAME data, this is
unlikely to cause any problems.[¶](#section-6.1-6){.pilcrow}
:::
:::

::: {#ns}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [DNS NS Records](#name-dns-ns-records){.section-name .selfRef} {#name-dns-ns-records}

In the event that there are multiple Discovery Proxy devices on a link
for fault tolerance reasons, the parent zone [MUST]{.bcp14} be
configured with NS records giving the names of all the Discovery Proxy
devices on the link.[¶](#section-6.2-1){.pilcrow}

Each Discovery Proxy device [MUST]{.bcp14} be configured to answer NS
queries for the zone apex name by giving its own NS record, and the NS
records of its fellow Discovery Proxy devices on the same link, so that
it can return the correct answers for NS
queries.[¶](#section-6.2-2){.pilcrow}

The target host name in the RDATA of an NS record [MUST NOT]{.bcp14}
reference a name that falls within any zone delegated to a Discovery
Proxy. Apart from the zone apex name, all other host names (names of A
and AAAA DNS records) that fall within a zone delegated to a Discovery
Proxy correspond to local Multicast DNS host names, which logically
belong to the respective Multicast DNS hosts defending those names, not
the Discovery Proxy. Generally speaking, the Discovery Proxy does not
own or control the delegated zone; it is merely a conduit to the
corresponding \".local\" namespace, which is controlled by the Multicast
DNS hosts on that link. If an NS record were to reference a manually
determined host name that falls within a delegated zone, that manually
determined host name may inadvertently conflict with a corresponding
\".local\" host name that is owned and controlled by some device on that
link.[¶](#section-6.2-3){.pilcrow}
:::
:::

::: {#delegation}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [DNS Delegation Records](#name-dns-delegation-records){.section-name .selfRef} {#name-dns-delegation-records}

Since the [Multicast DNS specification](#RFC6762){.xref}
\[[RFC6762](#RFC6762){.xref}\] states that there can be no delegation
(subdomains) within a \".local\" namespace, this implies that any name
within a zone delegated to a Discovery Proxy (except for the zone apex
name itself) cannot have any answers for any DNS queries for RRTYPEs
SOA, NS, or DS. Consequently:[¶](#section-6.3-1){.pilcrow}

-   [for any query for the zone apex name of a zone delegated to a
    Discovery Proxy, the Discovery Proxy [MUST]{.bcp14} generate the
    appropriate immediate answers as described above,
    and[¶](#section-6.3-2.1){.pilcrow}]{#section-6.3-2.1}
-   [for any query for any name below the zone apex, for RRTYPEs SOA,
    NS, or DS, the Discovery Proxy [MUST]{.bcp14} generate an immediate
    negative answer.[¶](#section-6.3-2.2){.pilcrow}]{#section-6.3-2.2}
:::
:::

::: {#srv}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [DNS SRV Records](#name-dns-srv-records){.section-name .selfRef} {#name-dns-srv-records}

There are certain special DNS records that logically fall within the
delegated Unicast DNS subdomain, but rather than mapping to their
corresponding \".local\" namesakes, they actually contain metadata
pertaining to the operation of the delegated Unicast DNS subdomain
itself. They do not exist in the corresponding \".local\" namespace of
the local link. For these queries, a Discovery Proxy [MUST]{.bcp14}
generate immediate answers, whether positive or negative, to avoid
delays while clients wait for their query to be
answered.[¶](#section-6.4-1){.pilcrow}

For example, if a Discovery Proxy implements Long-Lived Queries
\[[RFC8764](#RFC8764){.xref}\], then it [MUST]{.bcp14} positively
respond to `_dns‑llq._udp.<zone> SRV` queries,
`_dns‑llq._tcp.<zone> SRV` queries, and `_dns‑llq‑tls._tcp.<zone> SRV`
queries as appropriate. If it does not implement Long-Lived Queries, it
[MUST]{.bcp14} return an immediate negative answer for those queries,
instead of passing those queries through to the local network as
Multicast DNS queries and then waiting unsuccessfully for answers that
will not be forthcoming.[¶](#section-6.4-2){.pilcrow}

If a Discovery Proxy implements DNS Push Notifications
\[[RFC8765](#RFC8765){.xref}\], then it [MUST]{.bcp14} positively
respond to `_dns‑push‑tls._tcp.<zone>` queries. Otherwise, it
[MUST]{.bcp14} return an immediate negative answer for those
queries.[¶](#section-6.4-3){.pilcrow}

A Discovery Proxy [MUST]{.bcp14} return an immediate negative answer for
`_dns‑update._udp.<zone> SRV` queries, `_dns‑update._tcp.<zone> SRV`
queries, and `_dns‑update-tls._tcp.<zone> SRV` queries, since using DNS
Update \[[RFC2136](#RFC2136){.xref}\] to change zones generated
dynamically from local Multicast DNS data is not
possible.[¶](#section-6.4-4){.pilcrow}
:::
:::

::: {#section-6.5 .section}
### [6.5.](#section-6.5){.section-number .selfRef} [Domain Enumeration Records](#name-domain-enumeration-records){.section-name .selfRef} {#name-domain-enumeration-records}

If the network operator chooses to use address-based unicast Domain
Enumeration queries for client configuration (see [Section
5.2.1](#unicast){.xref}), and the network operator also chooses to
delegate the enclosing reverse mapping subdomain to a Discovery Proxy,
then that Discovery Proxy becomes responsible for serving the answers to
those address-based unicast Domain Enumeration
queries.[¶](#section-6.5-1){.pilcrow}

As with the SRV metadata records described above, a Discovery Proxy
configured with delegated reverse mapping subdomains is responsible for
generating immediate (positive or negative) answers for address-based
unicast Domain Enumeration queries, rather than passing them though to
the underlying Multicast DNS subsystem and then waiting unsuccessfully
for answers that will not be forthcoming.[¶](#section-6.5-2){.pilcrow}
:::
:::
:::

::: {#DNSSEC}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [DNSSEC Considerations](#name-dnssec-considerations){.section-name .selfRef} {#name-dnssec-considerations}

::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Online Signing Only](#name-online-signing-only){.section-name .selfRef} {#name-online-signing-only}

The Discovery Proxy acts as the authoritative name server for designated
subdomains, and if DNSSEC is to be used, the Discovery Proxy needs to
possess a copy of the signing keys in order to generate authoritative
signed data from the local Multicast DNS responses it receives. Offline
signing is not applicable to Discovery
Proxy.[¶](#section-7.1-1){.pilcrow}
:::

::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [NSEC and NSEC3 Records](#name-nsec-and-nsec3-records){.section-name .selfRef} {#name-nsec-and-nsec3-records}

In DNSSEC, NSEC and NSEC3 records are used to assert the nonexistence of
certain names, also described as \"authenticated denial of existence\"
\[[RFC4034](#RFC4034){.xref}\]
\[[RFC5155](#RFC5155){.xref}\].[¶](#section-7.2-1){.pilcrow}

Since a Discovery Proxy only knows what names exist on the local link by
issuing queries for them, and since it would be impractical to issue
queries for every possible name just to find out which names exist and
which do not, a Discovery Proxy cannot programmatically synthesize the
traditional NSEC and NSEC3 records that assert the nonexistence of a
large range of names. Instead, when generating a negative response, a
Discovery Proxy programmatically synthesizes a single NSEC record
asserting the nonexistence of just the specific name queried and no
others. Since the Discovery Proxy has the zone signing key, it can do
this on demand. Since the NSEC record asserts the nonexistence of only a
single name, zone walking is not a concern, and NSEC3 is therefore not
necessary.[¶](#section-7.2-2){.pilcrow}

Note that this applies only to traditional immediate DNS queries, which
may return immediate negative answers when no immediate positive answer
is available. When used with a DNS Push Notification subscription
\[[RFC8765](#RFC8765){.xref}\], there are no negative answers, merely
the absence of answers so far, which may change in the future if answers
become available.[¶](#section-7.2-3){.pilcrow}
:::
:::
:::

::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [IPv6 Considerations](#name-ipv6-considerations){.section-name .selfRef} {#name-ipv6-considerations}

An IPv4-only host and an IPv6-only host behave as \"ships that pass in
the night\". Even if they are on the same Ethernet
\[[IEEE-3](#IEEE-3){.xref}\], neither is aware of the other\'s traffic.
For this reason, each link may have *two* unrelated \".local.\" zones:
one for IPv4 and one for IPv6. Since, for practical purposes, a group of
IPv4-only hosts and a group of IPv6-only hosts on the same Ethernet act
as if they were on two entirely separate Ethernet segments, it is
unsurprising that their use of the \".local.\" zone should occur exactly
as it would if they really were on two entirely separate Ethernet
segments.[¶](#section-8-1){.pilcrow}

It will be desirable to have a mechanism to \"stitch\" together these
two unrelated \".local.\" zones so that they appear as one. Such a
mechanism will need to be able to differentiate between a dual-stack
(v4/v6) host participating in both \".local.\" zones, and two different
hosts: one IPv4-only and the other IPv6-only, which are both trying to
use the same name(s). Such a mechanism will be specified in a future
companion document.[¶](#section-8-2){.pilcrow}

At present, it is [RECOMMENDED]{.bcp14} that a Discovery Proxy be
configured with a single domain name for both the IPv4 and IPv6
\".local.\" zones on the local link, and when a unicast query is
received, it should issue Multicast DNS queries using both IPv4 and IPv6
on the local link and then combine the
results.[¶](#section-8-3){.pilcrow}
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Authenticity](#name-authenticity){.section-name .selfRef} {#name-authenticity}

A service proves its presence on a link by its ability to answer
link-local multicast queries on that link. If greater security is
desired, then the Discovery Proxy mechanism should not be used, and
something with stronger security should be used instead such as
authenticated secure DNS Update \[[RFC2136](#RFC2136){.xref}\]
\[[RFC3007](#RFC3007){.xref}\].[¶](#section-9.1-1){.pilcrow}
:::

::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Privacy](#name-privacy){.section-name .selfRef} {#name-privacy}

The Domain Name System is, generally speaking, a global public database.
Records that exist in the Domain Name System name hierarchy can be
queried by name from, in principle, anywhere in the world. If services
on a mobile device (like a laptop computer) are made visible via the
Discovery Proxy mechanism, then when those services become visible in a
domain such as \"My House.example.com\", it might indicate to
(potentially hostile) observers that the mobile device is in the
owner\'s home. When those services disappear from
\"My House.example.com\", that change could be used by observers to
infer when the mobile device (and possibly its owner) may have left the
house. The privacy of this information may be protected using techniques
like firewalls, split-view DNS, and Virtual Private Networks (VPNs), as
are customarily used today to protect the privacy of corporate DNS
information.[¶](#section-9.2-1){.pilcrow}

The privacy issue is particularly serious for the IPv4 and IPv6 reverse
zones. If the public delegation of the reverse zones points to the
Discovery Proxy, and the Discovery Proxy is reachable globally, then it
could leak a significant amount of information. Attackers could discover
hosts that otherwise might not be easy to identify, and learn their host
names. Attackers could also discover the existence of links where hosts
frequently come and go.[¶](#section-9.2-2){.pilcrow}

The Discovery Proxy could provide sensitive records only to
authenticated users. This is a general DNS problem, not specific to the
Discovery Proxy. Work is underway in the IETF to tackle this problem
\[[RFC7626](#RFC7626){.xref}\].[¶](#section-9.2-3){.pilcrow}
:::

::: {#section-9.3 .section}
### [9.3.](#section-9.3){.section-number .selfRef} [Denial of Service](#name-denial-of-service){.section-name .selfRef} {#name-denial-of-service}

A remote attacker could use a rapid series of unique Unicast DNS queries
to induce a Discovery Proxy to generate a rapid series of corresponding
Multicast DNS queries on one or more of its local links. Multicast
traffic is generally more expensive than unicast traffic, especially on
Wi-Fi links \[[MCAST](#I-D.ietf-mboned-ieee802-mcast-problems){.xref}\],
which makes this attack particularly serious. To limit the damage that
can be caused by such attacks, a Discovery Proxy (or the underlying
Multicast DNS subsystem that it utilizes) [MUST]{.bcp14} implement
Multicast DNS query rate limiting appropriate to the link technology in
question. For today\'s 802.11b/g/n/ac Wi-Fi links (for which
approximately 200 multicast packets per second is sufficient to consume
approximately 100% of the wireless spectrum), a limit of 20 Multicast
DNS query packets per second is [RECOMMENDED]{.bcp14}. On other link
technologies like Gigabit Ethernet, higher limits may be appropriate. A
consequence of this rate limiting is that a rogue remote client could
issue an excessive number of queries resulting in denial of service to
other legitimate remote clients attempting to use that Discovery Proxy.
However, this is preferable to a rogue remote client being able to
inflict even greater harm on the local network, which could impact the
correct operation of all local clients on that
network.[¶](#section-9.3-1){.pilcrow}
:::
:::

::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-10-1){.pilcrow}
:::

::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-11.1 .section}
### [11.1.](#section-11.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC1034\]
:   [Mockapetris, P.]{.refAuthor}, [\"Domain names - concepts and
    facilities\"]{.refTitle}, [STD 13]{.seriesInfo}, [RFC
    1034]{.seriesInfo}, [DOI 10.17487/RFC1034]{.seriesInfo}, November
    1987, \<<https://www.rfc-editor.org/info/rfc1034>\>.
:   

\[RFC1035\]
:   [Mockapetris, P.]{.refAuthor}, [\"Domain names - implementation and
    specification\"]{.refTitle}, [STD 13]{.seriesInfo}, [RFC
    1035]{.seriesInfo}, [DOI 10.17487/RFC1035]{.seriesInfo}, November
    1987, \<<https://www.rfc-editor.org/info/rfc1035>\>.
:   

\[RFC1918\]
:   [Rekhter, Y.]{.refAuthor}[, Moskowitz, B.]{.refAuthor}[,
    Karrenberg, D.]{.refAuthor}[, de Groot, G. J.]{.refAuthor}[, and E.
    Lear]{.refAuthor}, [\"Address Allocation for Private
    Internets\"]{.refTitle}, [BCP 5]{.seriesInfo}, [RFC
    1918]{.seriesInfo}, [DOI 10.17487/RFC1918]{.seriesInfo}, February
    1996, \<<https://www.rfc-editor.org/info/rfc1918>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC2308\]
:   [Andrews, M.]{.refAuthor}, [\"Negative Caching of DNS Queries (DNS
    NCACHE)\"]{.refTitle}, [RFC 2308]{.seriesInfo}, [DOI
    10.17487/RFC2308]{.seriesInfo}, March 1998,
    \<<https://www.rfc-editor.org/info/rfc2308>\>.
:   

\[RFC3629\]
:   [Yergeau, F.]{.refAuthor}, [\"UTF-8, a transformation format of ISO
    10646\"]{.refTitle}, [STD 63]{.seriesInfo}, [RFC 3629]{.seriesInfo},
    [DOI 10.17487/RFC3629]{.seriesInfo}, November 2003,
    \<<https://www.rfc-editor.org/info/rfc3629>\>.
:   

\[RFC3927\]
:   [Cheshire, S.]{.refAuthor}[, Aboba, B.]{.refAuthor}[, and E.
    Guttman]{.refAuthor}, [\"Dynamic Configuration of IPv4 Link-Local
    Addresses\"]{.refTitle}, [RFC 3927]{.seriesInfo}, [DOI
    10.17487/RFC3927]{.seriesInfo}, May 2005,
    \<<https://www.rfc-editor.org/info/rfc3927>\>.
:   

\[RFC4034\]
:   [Arends, R.]{.refAuthor}[, Austein, R.]{.refAuthor}[,
    Larson, M.]{.refAuthor}[, Massey, D.]{.refAuthor}[, and S.
    Rose]{.refAuthor}, [\"Resource Records for the DNS Security
    Extensions\"]{.refTitle}, [RFC 4034]{.seriesInfo}, [DOI
    10.17487/RFC4034]{.seriesInfo}, March 2005,
    \<<https://www.rfc-editor.org/info/rfc4034>\>.
:   

\[RFC4862\]
:   [Thomson, S.]{.refAuthor}[, Narten, T.]{.refAuthor}[, and T.
    Jinmei]{.refAuthor}, [\"IPv6 Stateless Address
    Autoconfiguration\"]{.refTitle}, [RFC 4862]{.seriesInfo}, [DOI
    10.17487/RFC4862]{.seriesInfo}, September 2007,
    \<<https://www.rfc-editor.org/info/rfc4862>\>.
:   

\[RFC5155\]
:   [Laurie, B.]{.refAuthor}[, Sisson, G.]{.refAuthor}[,
    Arends, R.]{.refAuthor}[, and D. Blacka]{.refAuthor}, [\"DNS
    Security (DNSSEC) Hashed Authenticated Denial of
    Existence\"]{.refTitle}, [RFC 5155]{.seriesInfo}, [DOI
    10.17487/RFC5155]{.seriesInfo}, March 2008,
    \<<https://www.rfc-editor.org/info/rfc5155>\>.
:   

\[RFC5198\]
:   [Klensin, J.]{.refAuthor}[ and M. Padlipsky]{.refAuthor}, [\"Unicode
    Format for Network Interchange\"]{.refTitle}, [RFC
    5198]{.seriesInfo}, [DOI 10.17487/RFC5198]{.seriesInfo}, March 2008,
    \<<https://www.rfc-editor.org/info/rfc5198>\>.
:   

\[RFC6762\]
:   [Cheshire, S.]{.refAuthor}[ and M. Krochmal]{.refAuthor},
    [\"Multicast DNS\"]{.refTitle}, [RFC 6762]{.seriesInfo}, [DOI
    10.17487/RFC6762]{.seriesInfo}, February 2013,
    \<<https://www.rfc-editor.org/info/rfc6762>\>.
:   

\[RFC6763\]
:   [Cheshire, S.]{.refAuthor}[ and M. Krochmal]{.refAuthor},
    [\"DNS-Based Service Discovery\"]{.refTitle}, [RFC
    6763]{.seriesInfo}, [DOI 10.17487/RFC6763]{.seriesInfo}, February
    2013, \<<https://www.rfc-editor.org/info/rfc6763>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8490\]
:   [Bellis, R.]{.refAuthor}[, Cheshire, S.]{.refAuthor}[,
    Dickinson, J.]{.refAuthor}[, Dickinson, S.]{.refAuthor}[,
    Lemon, T.]{.refAuthor}[, and T. Pusateri]{.refAuthor}, [\"DNS
    Stateful Operations\"]{.refTitle}, [RFC 8490]{.seriesInfo}, [DOI
    10.17487/RFC8490]{.seriesInfo}, March 2019,
    \<<https://www.rfc-editor.org/info/rfc8490>\>.
:   

\[RFC8765\]
:   [Pusateri, T.]{.refAuthor}[ and S. Cheshire]{.refAuthor}, [\"DNS
    Push Notifications\"]{.refTitle}, [RFC 8765]{.seriesInfo}, [DOI
    10.17487/RFC8765]{.seriesInfo}, June 2020,
    \<<https://www.rfc-editor.org/info/rfc8765>\>.
:   
:::

::: {#section-11.2 .section}
### [11.2.](#section-11.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[DNS-UL\]
:   [Cheshire, S.]{.refAuthor}[ and T. Lemon]{.refAuthor}, [\"Dynamic
    DNS Update Leases\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-sekar-dns-ul-02]{.seriesInfo}, 2 August 2018,
    \<<https://tools.ietf.org/html/draft-sekar-dns-ul-02>\>.
:   

\[IEEE-1Q\]
:   [IEEE]{.refAuthor}, [\"IEEE Standard for Local and metropolitan area
    networks \-- Bridges and Bridged Networks\"]{.refTitle}, [IEEE Std
    802.1Q-2014]{.seriesInfo}, [DOI
    10.1109/IEEESTD.2014.6991462]{.seriesInfo}, 2014,
    \<<https://ieeexplore.ieee.org/document/6991462>\>.
:   

\[IEEE-3\]
:   [IEEE]{.refAuthor}, [\"IEEE Standard for Ethernet\"]{.refTitle},
    [DOI 10.1109/IEEESTD.2018.8457469]{.seriesInfo}, [IEEE Std
    802.3-2018]{.seriesInfo}, December 2008,
    \<<https://ieeexplore.ieee.org/document/8457469>\>.
:   

\[IEEE-5\]
:   [IEEE]{.refAuthor}, [\"Telecommunications and information exchange
    between systems - Local and metropolitan area networks - Part 5:
    Token ring access method and physical layer
    specifications\"]{.refTitle}, [IEEE Std 802.5-1998]{.seriesInfo},
    1998, \<<https://standards.ieee.org/standard/802_5-1998.html>\>.
:   

\[IEEE-11\]
:   [IEEE]{.refAuthor}, [\"Information technology - Telecommunications
    and information exchange between systems - Local and metropolitan
    area networks - Specific requirements - Part 11: Wireless LAN Medium
    Access Control (MAC) and Physical Layer (PHY)
    Specifications\"]{.refTitle}, [IEEE Std 802.11-2016]{.seriesInfo},
    December 2016,
    \<<https://standards.ieee.org/standard/802_11-2016.html>\>.
:   

\[MCAST\]
:   [Perkins, C.]{.refAuthor}[, McBride, M.]{.refAuthor}[,
    Stanley, D.]{.refAuthor}[, Kumari, W.]{.refAuthor}[, and J.
    Zuniga]{.refAuthor}, [\"Multicast Considerations over IEEE 802
    Wireless Media\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft,
    draft-ietf-mboned-ieee802-mcast-problems-11]{.seriesInfo}, 11
    December 2019,
    \<<https://tools.ietf.org/html/draft-ietf-mboned-ieee802-mcast-problems-11>\>.
:   

\[OHP\]
:   [\"ohybridproxy - an mDNS/DNS hybrid-proxy based on
    mDNSResponder\"]{.refTitle}, [commit 464d6c9]{.refContent}, June
    2017, \<<https://github.com/sbyx/ohybridproxy/>\>.
:   

\[REG-PROT\]
:   [Cheshire, S.]{.refAuthor}[ and T. Lemon]{.refAuthor}, [\"Service
    Registration Protocol for DNS-Based Service Discovery\"]{.refTitle},
    [Work in Progress]{.refContent}, [Internet-Draft,
    draft-sctl-service-registration-02]{.seriesInfo}, 15 July 2018,
    \<<https://tools.ietf.org/html/draft-sctl-service-registration-02>\>.
:   

\[RELAY\]
:   [Cheshire, S.]{.refAuthor}[ and T. Lemon]{.refAuthor}, [\"Multicast
    DNS Discovery Relay\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-sctl-dnssd-mdns-relay-04]{.seriesInfo}, 21
    March 2018,
    \<<https://tools.ietf.org/html/draft-sctl-dnssd-mdns-relay-04>\>.
:   

\[RFC2132\]
:   [Alexander, S.]{.refAuthor}[ and R. Droms]{.refAuthor}, [\"DHCP
    Options and BOOTP Vendor Extensions\"]{.refTitle}, [RFC
    2132]{.seriesInfo}, [DOI 10.17487/RFC2132]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2132>\>.
:   

\[RFC2136\]
:   [Vixie, P., Ed.]{.refAuthor}[, Thomson, S.]{.refAuthor}[,
    Rekhter, Y.]{.refAuthor}[, and J. Bound]{.refAuthor}, [\"Dynamic
    Updates in the Domain Name System (DNS UPDATE)\"]{.refTitle}, [RFC
    2136]{.seriesInfo}, [DOI 10.17487/RFC2136]{.seriesInfo}, April 1997,
    \<<https://www.rfc-editor.org/info/rfc2136>\>.
:   

\[RFC3007\]
:   [Wellington, B.]{.refAuthor}, [\"Secure Domain Name System (DNS)
    Dynamic Update\"]{.refTitle}, [RFC 3007]{.seriesInfo}, [DOI
    10.17487/RFC3007]{.seriesInfo}, November 2000,
    \<<https://www.rfc-editor.org/info/rfc3007>\>.
:   

\[RFC3492\]
:   [Costello, A.]{.refAuthor}, [\"Punycode: A Bootstring encoding of
    Unicode for Internationalized Domain Names in Applications
    (IDNA)\"]{.refTitle}, [RFC 3492]{.seriesInfo}, [DOI
    10.17487/RFC3492]{.seriesInfo}, March 2003,
    \<<https://www.rfc-editor.org/info/rfc3492>\>.
:   

\[RFC4193\]
:   [Hinden, R.]{.refAuthor}[ and B. Haberman]{.refAuthor}, [\"Unique
    Local IPv6 Unicast Addresses\"]{.refTitle}, [RFC 4193]{.seriesInfo},
    [DOI 10.17487/RFC4193]{.seriesInfo}, October 2005,
    \<<https://www.rfc-editor.org/info/rfc4193>\>.
:   

\[RFC6760\]
:   [Cheshire, S.]{.refAuthor}[ and M. Krochmal]{.refAuthor},
    [\"Requirements for a Protocol to Replace the AppleTalk Name Binding
    Protocol (NBP)\"]{.refTitle}, [RFC 6760]{.seriesInfo}, [DOI
    10.17487/RFC6760]{.seriesInfo}, February 2013,
    \<<https://www.rfc-editor.org/info/rfc6760>\>.
:   

\[RFC7558\]
:   [Lynn, K.]{.refAuthor}[, Cheshire, S.]{.refAuthor}[,
    Blanchet, M.]{.refAuthor}[, and D. Migault]{.refAuthor},
    [\"Requirements for Scalable DNS-Based Service Discovery (DNS-SD) /
    Multicast DNS (mDNS) Extensions\"]{.refTitle}, [RFC
    7558]{.seriesInfo}, [DOI 10.17487/RFC7558]{.seriesInfo}, July 2015,
    \<<https://www.rfc-editor.org/info/rfc7558>\>.
:   

\[RFC7626\]
:   [Bortzmeyer, S.]{.refAuthor}, [\"DNS Privacy
    Considerations\"]{.refTitle}, [RFC 7626]{.seriesInfo}, [DOI
    10.17487/RFC7626]{.seriesInfo}, August 2015,
    \<<https://www.rfc-editor.org/info/rfc7626>\>.
:   

\[RFC7788\]
:   [Stenberg, M.]{.refAuthor}[, Barth, S.]{.refAuthor}[, and P.
    Pfister]{.refAuthor}, [\"Home Networking Control
    Protocol\"]{.refTitle}, [RFC 7788]{.seriesInfo}, [DOI
    10.17487/RFC7788]{.seriesInfo}, April 2016,
    \<<https://www.rfc-editor.org/info/rfc7788>\>.
:   

\[RFC8375\]
:   [Pfister, P.]{.refAuthor}[ and T. Lemon]{.refAuthor}, [\"Special-Use
    Domain \'home.arpa.\'\"]{.refTitle}, [RFC 8375]{.seriesInfo}, [DOI
    10.17487/RFC8375]{.seriesInfo}, May 2018,
    \<<https://www.rfc-editor.org/info/rfc8375>\>.
:   

\[RFC8764\]
:   [Cheshire, S.]{.refAuthor}[ and M. Krochmal]{.refAuthor},
    [\"Apple\'s DNS Long-Lived Queries Protocol\"]{.refTitle}, [RFC
    8764]{.seriesInfo}, [DOI 10.17487/RFC8764]{.seriesInfo}, June 2020,
    \<<https://www.rfc-editor.org/info/rfc8764>\>.
:   

\[ROADMAP\]
:   [Cheshire, S.]{.refAuthor}, [\"Service Discovery Road
    Map\"]{.refTitle}, [Work in Progress]{.refContent}, [Internet-Draft,
    draft-cheshire-dnssd-roadmap-03]{.seriesInfo}, 23 October 2018,
    \<<https://tools.ietf.org/html/draft-cheshire-dnssd-roadmap-03>\>.
:   

\[ZC\]
:   [Cheshire, S.]{.refAuthor}[ and D.H. Steinberg]{.refAuthor}, [\"Zero
    Configuration Networking: The Definitive Guide\"]{.refTitle},
    [O\'Reilly Media, Inc.]{.refContent}, [ISBN
    0-596-10100-7]{.seriesInfo}, December 2005.
:   
:::
:::

::: {#implementation}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Implementation Status](#name-implementation-status){.section-name .selfRef} {#name-implementation-status}

Some aspects of the mechanism specified in this document already exist
in deployed software. Some aspects are new. This section outlines which
aspects already exist and which are
new.[¶](#section-appendix.a-1){.pilcrow}

::: {#section-a.1 .section}
## [A.1.](#section-a.1){.section-number .selfRef} [Already Implemented and Deployed](#name-already-implemented-and-dep){.section-name .selfRef} {#name-already-implemented-and-dep}

Domain enumeration by the client (\"b.\_dns-sd.\_udp.\<zone>\" queries)
is already implemented and deployed.[¶](#section-a.1-1){.pilcrow}

Performing unicast queries to the indicated discovery domain is already
implemented and deployed.[¶](#section-a.1-2){.pilcrow}

These are implemented and deployed in Mac OS X 10.4 Tiger and later
(including all versions of Apple iOS, on all models of iPhones, iPads,
Apple TVs and HomePods), in Bonjour for Windows, and in Android 4.1
\"Jelly Bean\" (API Level 16) and later.[¶](#section-a.1-3){.pilcrow}

Domain enumeration and unicast querying have been used for several years
at IETF meetings to make terminal room printers discoverable from
outside the terminal room. When an IETF attendee presses \"Cmd‑P\" on a
Mac, or selects AirPrint on an iPad or iPhone, and the terminal room
printers appear, it is because the client is sending Unicast DNS queries
to the IETF DNS servers. A walk-through giving the details of this
particular specific example is given in [Appendix
A](https://tools.ietf.org/html/draft-cheshire-dnssd-roadmap-03#appendix-A){.relref}
of the Roadmap document
\[[ROADMAP](#I-D.cheshire-dnssd-roadmap){.xref}\].[¶](#section-a.1-4){.pilcrow}

The Long-Lived Query mechanism \[[RFC8764](#RFC8764){.xref}\] referred
to in this specification exists and is deployed but was not standardized
by the IETF. The IETF has developed a superior Long-Lived Query
mechanism called DNS Push Notifications \[[RFC8765](#RFC8765){.xref}\],
which is built on DNS Stateful Operations
\[[RFC8490](#RFC8490){.xref}\]. DNS Push Notifications is implemented
and deployed in Mac OS X 10.15 and later, and iOS 13 and
later.[¶](#section-a.1-5){.pilcrow}
:::

::: {#section-a.2 .section}
## [A.2.](#section-a.2){.section-number .selfRef} [Already Implemented](#name-already-implemented){.section-name .selfRef} {#name-already-implemented}

A minimal portable Discovery Proxy implementation has been produced by
Markus Stenberg and Steven Barth, which runs on OS X and several Linux
variants including OpenWrt \[[OHP](#OHP){.xref}\]. It was demonstrated
at the Berlin IETF in July 2013.[¶](#section-a.2-1){.pilcrow}

Tom Pusateri has an implementation that runs on any Unix/Linux system.
It has a RESTful interface for management and an experimental demo
command-line interface (CLI) and web
interface.[¶](#section-a.2-2){.pilcrow}

Ted Lemon also has produced a portable implementation of Discovery
Proxy, which is available in the mDNSResponder open source
code.[¶](#section-a.2-3){.pilcrow}
:::

::: {#section-a.3 .section}
## [A.3.](#section-a.3){.section-number .selfRef} [Partially Implemented](#name-partially-implemented){.section-name .selfRef} {#name-partially-implemented}

At the time of writing, existing APIs make multiple domains visible to
client software, but most client user interfaces lump all discovered
services into a single flat list. This is largely a chicken-and-egg
problem. Application writers were naturally reluctant to spend time
writing domain-aware user interface code when few customers would
benefit from it. If Discovery Proxy deployment becomes common, then
application writers will have a reason to provide a better user
experience. Existing applications will work with the Discovery Proxy but
will show all services in a single flat list. Applications with improved
user interfaces will show services grouped by
domain.[¶](#section-a.3-1){.pilcrow}
:::
:::
:::

::: {#section-appendix.b .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

Thanks to [Markus Stenberg]{.contact-name} for helping develop the
policy regarding the four styles of unicast response according to what
data is immediately available in the cache. Thanks to [Anders
Brandt]{.contact-name}, [Ben Campbell]{.contact-name}, [Tim
Chown]{.contact-name}, [Alissa Cooper]{.contact-name}, [Spencer
Dawkins]{.contact-name}, [Ralph Droms]{.contact-name}, [Joel
Halpern]{.contact-name}, [Ray Hunter]{.contact-name}, [Joel
Jaeggli]{.contact-name}, [Warren Kumari]{.contact-name}, [Ted
Lemon]{.contact-name}, [Alexey Melnikov]{.contact-name}, [Kathleen
Moriarty]{.contact-name}, [Tom Pusateri]{.contact-name}, [Eric
Rescorla]{.contact-name}, [Adam Roach]{.contact-name}, [David
Schinazi]{.contact-name}, [Markus Stenberg]{.contact-name}, [Dave
Thaler]{.contact-name}, and [Andrew Yourtchenko]{.contact-name} for
their comments.[¶](#section-appendix.b-1){.pilcrow}
:::

::: {#authors-addresses}
::: {#section-appendix.c .section}
## [Author\'s Address](#name-authors-address){.section-name .selfRef} {#name-authors-address}

::: {.left dir="auto"}
[Stuart Cheshire]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Apple Inc.]{.org}
:::

::: {.left dir="auto"}
[One Apple Park Way]{.street-address}
:::

::: {.left dir="auto"}
[Cupertino]{.locality}, [California]{.region} [95014]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: tel
Phone: [+1 (408) 996-1010](tel:+1%20(408)%20996-1010){.tel}
:::

::: email
Email: <cheshire@apple.com>
:::
:::
:::
