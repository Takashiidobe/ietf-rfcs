  RFC 9162         Certificate Transparency Version 2.0   December 2021
  ---------------- -------------------------------------- ---------------
  Laurie, et al.   Experimental                           \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9162](https://www.rfc-editor.org/rfc/rfc9162){.eref}

Obsoletes:
:   [6962](https://www.rfc-editor.org/rfc/rfc6962){.eref}

Category:
:   Experimental

Published:
:   December 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    B. Laurie
    :::

    ::: org
    Google
    :::
    :::

    ::: author
    ::: author-name
    E. Messeri
    :::

    ::: org
    Google
    :::
    :::

    ::: author
    ::: author-name
    R. Stradling
    :::

    ::: org
    Sectigo
    :::
    :::
:::

# RFC 9162 {#rfcnum}

# Certificate Transparency Version 2.0 {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes version 2.0 of the Certificate Transparency (CT)
protocol for publicly logging the existence of Transport Layer Security
(TLS) server certificates as they are issued or observed, in a manner
that allows anyone to audit certification authority (CA) activity and
notice the issuance of suspect certificates as well as to audit the
certificate logs themselves. The intent is that eventually clients would
refuse to honor certificates that do not appear in a log, effectively
forcing CAs to add all issued certificates to the
logs.[¶](#section-abstract-1){.pilcrow}

This document obsoletes RFC 6962. It also specifies a new TLS extension
that is used to send various CT log
artifacts.[¶](#section-abstract-2){.pilcrow}

Logs are network services that implement the protocol operations for
submissions and queries that are defined in this
document.[¶](#section-abstract-3){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for examination, experimental implementation, and
evaluation.[¶](#section-boilerplate.1-1){.pilcrow}

This document defines an Experimental Protocol for the Internet
community. This document is a product of the Internet Engineering Task
Force (IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Not all documents approved
by the IESG are candidates for any level of Internet Standard; see
Section 2 of RFC 7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9162>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Requirements
        Language](#name-requirements-language){.xref}
        :::

    -   ::: {#section-toc.1-1.1.2.2}
        [1.2](#section-1.2){.xref}.  [Data
        Structures](#name-data-structures){.xref}
        :::

    -   ::: {#section-toc.1-1.1.2.3}
        [1.3](#section-1.3){.xref}.  [Major Differences from CT
        1.0](#name-major-differences-from-ct-1){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Cryptographic
    Components](#name-cryptographic-components){.xref}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Merkle
        Trees](#name-merkle-trees){.xref}

        -   ::: {#section-toc.1-1.2.2.1.2.1}
            [2.1.1](#section-2.1.1){.xref}.  [Definition of the Merkle
            Tree](#name-definition-of-the-merkle-tr){.xref}
            :::

        -   ::: {#section-toc.1-1.2.2.1.2.2}
            [2.1.2](#section-2.1.2){.xref}.  [Verifying a Tree Head
            Given Entries](#name-verifying-a-tree-head-given){.xref}
            :::

        -   ::: {#section-toc.1-1.2.2.1.2.3}
            [2.1.3](#section-2.1.3){.xref}.  [Merkle Inclusion
            Proofs](#name-merkle-inclusion-proofs){.xref}
            :::

        -   ::: {#section-toc.1-1.2.2.1.2.4}
            [2.1.4](#section-2.1.4){.xref}.  [Merkle Consistency
            Proofs](#name-merkle-consistency-proofs){.xref}
            :::

        -   ::: {#section-toc.1-1.2.2.1.2.5}
            [2.1.5](#section-2.1.5){.xref}.  [Example](#name-example){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [Signatures](#name-signatures){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Submitters](#name-submitters){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Certificates](#name-certificates){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Precertificates](#name-precertificates){.xref}

        -   ::: {#section-toc.1-1.3.2.2.2.1}
            [3.2.1](#section-3.2.1){.xref}.  [Binding Intent to
            Issue](#name-binding-intent-to-issue){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Log Format and
    Operation](#name-log-format-and-operation){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Log
        Parameters](#name-log-parameters){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Evaluating
        Submissions](#name-evaluating-submissions){.xref}

        -   ::: {#section-toc.1-1.4.2.2.2.1}
            [4.2.1](#section-4.2.1){.xref}.  [Minimum Acceptance
            Criteria](#name-minimum-acceptance-criteria){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.2}
            [4.2.2](#section-4.2.2){.xref}.  [Discretionary Acceptance
            Criteria](#name-discretionary-acceptance-cr){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Log
        Entries](#name-log-entries){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Log ID](#name-log-id){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [TransItem
        Structure](#name-transitem-structure){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.6}
        [4.6](#section-4.6){.xref}.  [Log Artifact
        Extensions](#name-log-artifact-extensions){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.7}
        [4.7](#section-4.7){.xref}.  [Merkle Tree
        Leaves](#name-merkle-tree-leaves){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.8}
        [4.8](#section-4.8){.xref}.  [Signed Certificate Timestamp
        (SCT)](#name-signed-certificate-timestam){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.9}
        [4.9](#section-4.9){.xref}.  [Merkle Tree
        Head](#name-merkle-tree-head){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.10}
        [4.10](#section-4.10){.xref}. [Signed Tree Head
        (STH)](#name-signed-tree-head-sth){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.11}
        [4.11](#section-4.11){.xref}. [Merkle Consistency
        Proofs](#name-merkle-consistency-proofs-2){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.12}
        [4.12](#section-4.12){.xref}. [Merkle Inclusion
        Proofs](#name-merkle-inclusion-proofs-2){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.13}
        [4.13](#section-4.13){.xref}. [Shutting Down a
        Log](#name-shutting-down-a-log){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Log Client
    Messages](#name-log-client-messages){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Submit Entry to
        Log](#name-submit-entry-to-log){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Retrieve Latest
        STH](#name-retrieve-latest-sth){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Retrieve Merkle Consistency Proof
        between Two STHs](#name-retrieve-merkle-consistency){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [Retrieve Merkle Inclusion Proof
        from Log by Leaf Hash](#name-retrieve-merkle-inclusion-p){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [Retrieve Merkle Inclusion Proof,
        STH, and Consistency Proof by Leaf
        Hash](#name-retrieve-merkle-inclusion-pr){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.6}
        [5.6](#section-5.6){.xref}.  [Retrieve Entries and STH from
        Log](#name-retrieve-entries-and-sth-fr){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.7}
        [5.7](#section-5.7){.xref}.  [Retrieve Accepted Trust
        Anchors](#name-retrieve-accepted-trust-anc){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [TLS Servers](#name-tls-servers){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [TLS Client
        Authentication](#name-tls-client-authentication){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Multiple
        SCTs](#name-multiple-scts){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [TransItemList
        Structure](#name-transitemlist-structure){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [Presenting SCTs, Inclusions
        Proofs, and STHs](#name-presenting-scts-inclusions-){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.5}
        [6.5](#section-6.5){.xref}.  [transparency_info TLS
        Extension](#name-transparency_info-tls-exten){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Certification
    Authorities](#name-certification-authorities){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Transparency Information X.509v3
        Extension](#name-transparency-information-x5){.xref}

        -   ::: {#section-toc.1-1.7.2.1.2.1}
            [7.1.1](#section-7.1.1){.xref}.  [OCSP Response
            Extension](#name-ocsp-response-extension){.xref}
            :::

        -   ::: {#section-toc.1-1.7.2.1.2.2}
            [7.1.2](#section-7.1.2){.xref}.  [Certificate
            Extension](#name-certificate-extension){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [TLS Feature X.509v3
        Extension](#name-tls-feature-x509v3-extensio){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Clients](#name-clients){.xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [TLS
        Client](#name-tls-client){.xref}

        -   ::: {#section-toc.1-1.8.2.1.2.1}
            [8.1.1](#section-8.1.1){.xref}.  [Receiving SCTs and
            Inclusion Proofs](#name-receiving-scts-and-inclusio){.xref}
            :::

        -   ::: {#section-toc.1-1.8.2.1.2.2}
            [8.1.2](#section-8.1.2){.xref}.  [Reconstructing the
            TBSCertificate](#name-reconstructing-the-tbscerti){.xref}
            :::

        -   ::: {#section-toc.1-1.8.2.1.2.3}
            [8.1.3](#section-8.1.3){.xref}.  [Validating
            SCTs](#name-validating-scts){.xref}
            :::

        -   ::: {#section-toc.1-1.8.2.1.2.4}
            [8.1.4](#section-8.1.4){.xref}.  [Fetching Inclusion
            Proofs](#name-fetching-inclusion-proofs){.xref}
            :::

        -   ::: {#section-toc.1-1.8.2.1.2.5}
            [8.1.5](#section-8.1.5){.xref}.  [Validating Inclusion
            Proofs](#name-validating-inclusion-proofs){.xref}
            :::

        -   ::: {#section-toc.1-1.8.2.1.2.6}
            [8.1.6](#section-8.1.6){.xref}.  [Evaluating
            Compliance](#name-evaluating-compliance){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Monitor](#name-monitor){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [8.3](#section-8.3){.xref}.  [Auditing](#name-auditing){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Algorithm
    Agility](#name-algorithm-agility){.xref}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}

    -   ::: {#section-toc.1-1.10.2.1}
        [10.1](#section-10.1){.xref}.  [Additions to Existing
        Registries](#name-additions-to-existing-regis){.xref}

        -   ::: {#section-toc.1-1.10.2.1.2.1}
            [10.1.1](#section-10.1.1){.xref}.  [New Entry to the TLS
            ExtensionType
            Registry](#name-new-entry-to-the-tls-extens){.xref}
            :::

        -   ::: {#section-toc.1-1.10.2.1.2.2}
            [10.1.2](#section-10.1.2){.xref}.  [URN Sub-namespace for
            TRANS
            (urn:ietf:params:trans)](#name-urn-sub-namespace-for-trans){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [10.2](#section-10.2){.xref}.  [New CT-Related
        Registries](#name-new-ct-related-registries){.xref}

        -   ::: {#section-toc.1-1.10.2.2.2.1}
            [10.2.1](#section-10.2.1){.xref}.  [Hash
            Algorithms](#name-hash-algorithms){.xref}
            :::

        -   ::: {#section-toc.1-1.10.2.2.2.2}
            [10.2.2](#section-10.2.2){.xref}.  [Signature
            Algorithms](#name-signature-algorithms){.xref}
            :::

        -   ::: {#section-toc.1-1.10.2.2.2.3}
            [10.2.3](#section-10.2.3){.xref}.  [VersionedTransTypes](#name-versionedtranstypes){.xref}
            :::

        -   ::: {#section-toc.1-1.10.2.2.2.4}
            [10.2.4](#section-10.2.4){.xref}.  [Log Artifact
            Extensions](#name-log-artifact-extensions-2){.xref}
            :::

        -   ::: {#section-toc.1-1.10.2.2.2.5}
            [10.2.5](#section-10.2.5){.xref}.  [Log
            IDs](#name-log-ids){.xref}
            :::

        -   ::: {#section-toc.1-1.10.2.2.2.6}
            [10.2.6](#section-10.2.6){.xref}.  [Error
            Types](#name-error-types){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.10.2.3}
        [10.3](#section-10.3){.xref}.  [OID
        Assignment](#name-oid-assignment){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.11.2.1}
        [11.1](#section-11.1){.xref}.  [Misissued
        Certificates](#name-misissued-certificates){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [11.2](#section-11.2){.xref}.  [Detection of
        Misissue](#name-detection-of-misissue){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.3}
        [11.3](#section-11.3){.xref}.  [Misbehaving
        Logs](#name-misbehaving-logs){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.4}
        [11.4](#section-11.4){.xref}.  [Multiple
        SCTs](#name-multiple-scts-2){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.5}
        [11.5](#section-11.5){.xref}.  [Leakage of DNS
        Information](#name-leakage-of-dns-information){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.12.2.1}
        [12.1](#section-12.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [12.2](#section-12.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [Appendix A](#appendix-A){.xref}.  [Supporting v1 and v2
    Simultaneously
    (Informative)](#name-supporting-v1-and-v2-simult){.xref}
    :::

-   ::: {#section-toc.1-1.14}
    [Appendix B](#appendix-B){.xref}.  [An ASN.1 Module
    (Informative)](#name-an-asn1-module-informative){.xref}
    :::

-   ::: {#section-toc.1-1.15}
    [](#appendix-C){.xref}[Acknowledgements](#name-acknowledgements){.xref}
    :::

-   ::: {#section-toc.1-1.16}
    [](#appendix-D){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Certificate Transparency aims to mitigate the problem of misissued
certificates by providing append-only logs of issued certificates. The
logs do not themselves prevent misissuance, but they ensure that
interested parties (particularly those named in certificates) can detect
such misissuance. Note that this is a general mechanism that could be
used for transparently logging any form of binary data, subject to some
kind of inclusion criteria. In this document, we only describe its use
for public TLS server certificates (i.e., where the inclusion criteria
is a valid certificate issued by a public certification authority (CA)).
A typical definition of \"public\" can be found in
\[[CABBR](#CABBR){.xref}\].[¶](#section-1-1){.pilcrow}

Each log contains certificate chains, which can be submitted by anyone.
It is expected that public CAs will contribute all their newly issued
certificates to one or more logs; however, certificate holders can also
contribute their own certificate chains, as can third parties. In order
to avoid logs being rendered useless by the submission of large numbers
of spurious certificates, it is required that each chain ends with a
trust anchor that is accepted by the log. A log may also limit the
length of the chain it is willing to accept; such chains must also end
with an acceptable trust anchor. When a chain is accepted by a log, a
signed timestamp is returned, which can later be used to provide
evidence to TLS clients that the chain has been submitted. TLS clients
can thus require that all certificates they accept as valid are
accompanied by signed timestamps.[¶](#section-1-2){.pilcrow}

Those who are concerned about misissuance can monitor the logs, asking
them regularly for all new entries, and can thus check whether domains
for which they are responsible have had certificates issued that they
did not expect. What they do with this information, particularly when
they find that a misissuance has happened, is beyond the scope of this
document. However, broadly speaking, they can invoke existing business
mechanisms for dealing with misissued certificates, such as working with
the CA to get the certificate revoked or with maintainers of trust
anchor lists to get the CA removed. Of course, anyone who wants can
monitor the logs and, if they believe a certificate is incorrectly
issued, take action as they see fit.[¶](#section-1-3){.pilcrow}

Similarly, those who have seen signed timestamps from a particular log
can later demand a proof of inclusion from that log. If the log is
unable to provide this (or, indeed, if the corresponding certificate is
absent from monitors\' copies of that log), that is evidence of the
incorrect operation of the log. The checking operation is asynchronous
to allow clients to proceed without delay, despite possible issues, such
as network connectivity and the vagaries of
firewalls.[¶](#section-1-4){.pilcrow}

The append-only property of each log is achieved using Merkle Trees,
which can be used to efficiently prove that any particular instance of
the log is a superset of any particular previous instance and to
efficiently detect various misbehaviors of the log (e.g., issuing a
signed timestamp for a certificate that is not subsequently
logged).[¶](#section-1-5){.pilcrow}

The log auditing mechanisms described in this document can be
circumvented by a misbehaving log that shows different, inconsistent
views of itself to different clients. Therefore, it is necessary to
treat each log as a trusted third party. While mechanisms are being
developed to address these shortcomings and thereby avoid the need to
blindly trust logs, such mechanisms are outside the scope of this
document.[¶](#section-1-6){.pilcrow}

::: {#requirements-language}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Requirements Language](#name-requirements-language){.section-name .selfRef} {#name-requirements-language}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-1){.pilcrow}
:::
:::

::: {#data_structures}
::: {#section-1.2 .section}
### [1.2.](#section-1.2){.section-number .selfRef} [Data Structures](#name-data-structures){.section-name .selfRef} {#name-data-structures}

Data structures are defined and encoded according to the conventions
laid out in [Section
3](https://www.rfc-editor.org/rfc/rfc8446#section-3){.relref} of
\[[RFC8446](#RFC8446){.xref}\].[¶](#section-1.2-1){.pilcrow}

This document uses object identifiers (OIDs) to identify Log IDs (see
[Section 4.4](#log_id){.xref}), the precertificate Cryptographic Message
Syntax (CMS) `eContentType` (see [Section
3.2](#precertificates){.xref}), X.509v3 extensions in certificates (see
[Section 7.1.2](#cert_transinfo_extension){.xref}), and Online
Certificate Status Protocol (OCSP) responses (see [Section
7.1.1](#ocsp_transinfo_extension){.xref}). The OIDs are defined in an
arc that was selected due to its short
encoding.[¶](#section-1.2-2){.pilcrow}
:::
:::

::: {#major-differences-from-ct-10}
::: {#section-1.3 .section}
### [1.3.](#section-1.3){.section-number .selfRef} [Major Differences from CT 1.0](#name-major-differences-from-ct-1){.section-name .selfRef} {#name-major-differences-from-ct-1}

This document revises and obsoletes the CT 1.0 protocol
\[[RFC6962](#RFC6962){.xref}\], drawing on insights gained from CT 1.0
deployments and on feedback from the community. The major changes
are:[¶](#section-1.3-1){.pilcrow}

-   [Hash and signature algorithm agility: Permitted algorithms are now
    specified in IANA
    registries.[¶](#section-1.3-2.1){.pilcrow}]{#section-1.3-2.1}
-   [Precertificate format: Precertificates are now CMS objects rather
    than X.509 certificates, which avoids violating the certificate
    serial number uniqueness requirement in [Section
    4.1.2.2](https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.2){.relref}
    of
    \[[RFC5280](#RFC5280){.xref}\].[¶](#section-1.3-2.2){.pilcrow}]{#section-1.3-2.2}
-   [Removal of precertificate signing certificates and the
    precertificate poison extension: The change of precertificate format
    means that these are no longer
    needed.[¶](#section-1.3-2.3){.pilcrow}]{#section-1.3-2.3}
-   [Logs IDs: Each log is now identified by an OID rather than by the
    hash of its public key. OID allocations are available from an IANA
    registry.[¶](#section-1.3-2.4){.pilcrow}]{#section-1.3-2.4}
-   [`TransItem` structure: This new data structure is used to
    encapsulate most types of CT data. A `TransItemList`, consisting of
    one or more `TransItem` structures, can be used anywhere that
    `SignedCertificateTimestampList` was used in
    \[[RFC6962](#RFC6962){.xref}\].[¶](#section-1.3-2.5){.pilcrow}]{#section-1.3-2.5}
-   [Merkle Tree leaves: The `MerkleTreeLeaf` structure has been
    replaced by the `TransItem` structure, which eases extensibility and
    simplifies the leaf structure by removing one layer of
    abstraction.[¶](#section-1.3-2.6){.pilcrow}]{#section-1.3-2.6}
-   [Unified leaf format: The structure for both certificate and
    precertificate entries now includes only the TBSCertificate (whereas
    certificate entries in \[[RFC6962](#RFC6962){.xref}\] included the
    entire
    certificate).[¶](#section-1.3-2.7){.pilcrow}]{#section-1.3-2.7}
-   [Log artifact extensions: These are now typed and managed by an IANA
    registry, and they can now appear not only in Signed Certificate
    Timestamps (SCTs) but also in Signed Tree Heads
    (STHs).[¶](#section-1.3-2.8){.pilcrow}]{#section-1.3-2.8}
-   [API outputs: Complete `TransItem` structures are returned rather
    than the constituent parts of each
    structure.[¶](#section-1.3-2.9){.pilcrow}]{#section-1.3-2.9}
-   [`get-all-by-hash`: This is a new client API for obtaining an
    inclusion proof and the corresponding consistency proof at the same
    time.[¶](#section-1.3-2.10){.pilcrow}]{#section-1.3-2.10}
-   [`submit-entry`: This is a new client API, replacing `add-chain` and
    `add-pre-chain`.[¶](#section-1.3-2.11){.pilcrow}]{#section-1.3-2.11}
-   [Presenting SCTs with proofs: TLS servers may present SCTs together
    with the corresponding inclusion proofs, using any of the mechanisms
    that \[[RFC6962](#RFC6962){.xref}\] defined for presenting SCTs
    only. (Presenting SCTs only is still
    supported).[¶](#section-1.3-2.12){.pilcrow}]{#section-1.3-2.12}
-   [CT TLS extension: The `signed_certificate_timestamp` TLS extension
    has been replaced by the `transparency_info` TLS
    extension.[¶](#section-1.3-2.13){.pilcrow}]{#section-1.3-2.13}
-   [Verification algorithms: Detailed algorithms for verifying
    inclusion proofs, for verifying consistency between two STHs, and
    for verifying a root hash given a complete list of the relevant leaf
    input entries have been
    added.[¶](#section-1.3-2.14){.pilcrow}]{#section-1.3-2.14}
-   [Extensive clarifications and editorial
    work.[¶](#section-1.3-2.15){.pilcrow}]{#section-1.3-2.15}
:::
:::
:::
:::

::: {#cryptographic-components}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Cryptographic Components](#name-cryptographic-components){.section-name .selfRef} {#name-cryptographic-components}

::: {#mht}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Merkle Trees](#name-merkle-trees){.section-name .selfRef} {#name-merkle-trees}

A full description of the Merkle Tree is beyond the scope of this
document. Briefly, it is a binary tree where each non-leaf node is a
hash of its children. For CT, the number of children is at most two.
Additional information can be found in the Introduction and Reference
sections of \[[RFC8391](#RFC8391){.xref}\].[¶](#section-2.1-1){.pilcrow}

::: {#mht_definition}
::: {#section-2.1.1 .section}
#### [2.1.1.](#section-2.1.1){.section-number .selfRef} [Definition of the Merkle Tree](#name-definition-of-the-merkle-tr){.section-name .selfRef} {#name-definition-of-the-merkle-tr}

The log uses a binary Merkle Tree for efficient auditing. The hash
algorithm used is one of the log\'s parameters (see [Section
4.1](#log_parameters){.xref}). This document establishes a registry of
acceptable hash algorithms (see [Section
10.2.1](#hash_algorithms){.xref}). Throughout this document, the hash
algorithm in use is referred to as HASH and the size of its output in
bytes is referred to as HASH_SIZE. The input to the Merkle Tree Hash is
a list of data entries; these entries will be hashed to form the leaves
of the Merkle Tree. The output is a single HASH_SIZE Merkle Tree Hash.
Given an ordered list of n inputs, D_n = {d\[0\], d\[1\], \...,
d\[n-1\]}, the Merkle Tree Hash (MTH) is thus defined as
follows:[¶](#section-2.1.1-1){.pilcrow}

The hash of an empty list is the hash of an empty
string:[¶](#section-2.1.1-2){.pilcrow}

::: {#section-2.1.1-3 .alignLeft .art-text .artwork}
    MTH({}) = HASH().

[¶](#section-2.1.1-3){.pilcrow}
:::

The hash of a list with one entry (also known as a leaf hash)
is:[¶](#section-2.1.1-4){.pilcrow}

::: {#section-2.1.1-5 .alignLeft .art-text .artwork}
    MTH({d[0]}) = HASH(0x00 || d[0]).

[¶](#section-2.1.1-5){.pilcrow}
:::

For n \> 1, let k be the largest power of two smaller than n (i.e., k \<
n \<= 2k). The Merkle Tree Hash of an n-element list D_n is then defined
recursively as:[¶](#section-2.1.1-6){.pilcrow}

::: {#section-2.1.1-7 .alignLeft .art-text .artwork}
    MTH(D_n) = HASH(0x01 || MTH(D[0:k]) || MTH(D[k:n])),

[¶](#section-2.1.1-7){.pilcrow}
:::

where:[¶](#section-2.1.1-8){.pilcrow}

-   [\|\| denotes
    concatenation[¶](#section-2.1.1-9.1){.pilcrow}]{#section-2.1.1-9.1}
-   [: denotes concatenation of
    lists[¶](#section-2.1.1-9.2){.pilcrow}]{#section-2.1.1-9.2}
-   [D\[k1:k2\] = D\'\_(k2-k1) denotes the list {d\'\[0\] = d\[k1\],
    d\'\[1\] = d\[k1+1\], \..., d\'\[k2-k1-1\] = d\[k2-1\]} of length
    (k2 - k1).[¶](#section-2.1.1-9.3){.pilcrow}]{#section-2.1.1-9.3}

Note that the hash calculations for leaves and nodes differ; this domain
separation is required to give second preimage
resistance.[¶](#section-2.1.1-10){.pilcrow}

Note that we do not require the length of the input list to be a power
of two. The resulting Merkle Tree may thus not be balanced; however, its
shape is uniquely determined by the number of leaves. (Note: This Merkle
Tree is essentially the same as the history tree proposed by
\[[CrosbyWallach](#CrosbyWallach){.xref}\], except our definition
handles non-full trees differently.)[¶](#section-2.1.1-11){.pilcrow}
:::
:::

::: {#verify_hash}
::: {#section-2.1.2 .section}
#### [2.1.2.](#section-2.1.2){.section-number .selfRef} [Verifying a Tree Head Given Entries](#name-verifying-a-tree-head-given){.section-name .selfRef} {#name-verifying-a-tree-head-given}

When a client has a complete list of `entries` from `0` up to
`tree_size - 1` and wishes to verify this list against a tree head
`root_hash` returned by the log for the same `tree_size`, the following
algorithm may be used:[¶](#section-2.1.2-1){.pilcrow}

1.  [Set `stack` to an empty
    stack.[¶](#section-2.1.2-2.1){.pilcrow}]{#section-2.1.2-2.1}

2.  ::: {#section-2.1.2-2.2}
    For each `i` from `0` up to
    `tree_size - 1`:[¶](#section-2.1.2-2.2.1){.pilcrow}

    a.  [Push `HASH(0x00 || entries[i])` to
        `stack`.[¶](#section-2.1.2-2.2.2.1){.pilcrow}]{#section-2.1.2-2.2.2.1}

    b.  [Set `merge_count` to the lowest value (`0` included) such that
        `LSB(i >> merge_count)` is not set, where `LSB` means the least
        significant bit. In other words, set `merge_count` to the number
        of consecutive `1`s found starting at the least significant bit
        of
        `i`.[¶](#section-2.1.2-2.2.2.2){.pilcrow}]{#section-2.1.2-2.2.2.2}

    c.  ::: {#section-2.1.2-2.2.2.3}
        Repeat `merge_count`
        times:[¶](#section-2.1.2-2.2.2.3.1){.pilcrow}

        i.  [Pop `right` from
            `stack`.[¶](#section-2.1.2-2.2.2.3.2.1){.pilcrow}]{#section-2.1.2-2.2.2.3.2.1}
        ii. [Pop `left` from
            `stack`.[¶](#section-2.1.2-2.2.2.3.2.2){.pilcrow}]{#section-2.1.2-2.2.2.3.2.2}
        iii. [Push `HASH(0x01 || left || right)` to
             `stack`.[¶](#section-2.1.2-2.2.2.3.2.3){.pilcrow}]{#section-2.1.2-2.2.2.3.2.3}
        :::
    :::

3.  [If there is more than one element in the `stack`, repeat the same
    merge procedure (the sub-items of Step 2(c) above) until only a
    single element
    remains.[¶](#section-2.1.2-2.3){.pilcrow}]{#section-2.1.2-2.3}

4.  [The remaining element in `stack` is the Merkle Tree Hash for the
    given `tree_size` and should be compared by equality against the
    supplied
    `root_hash`.[¶](#section-2.1.2-2.4){.pilcrow}]{#section-2.1.2-2.4}
:::
:::

::: {#merkle_inclusion_proof}
::: {#section-2.1.3 .section}
#### [2.1.3.](#section-2.1.3){.section-number .selfRef} [Merkle Inclusion Proofs](#name-merkle-inclusion-proofs){.section-name .selfRef} {#name-merkle-inclusion-proofs}

A Merkle inclusion proof for a leaf in a Merkle Tree is the shortest
list of additional nodes in the Merkle Tree required to compute the
Merkle Tree Hash for that tree. Each node in the tree is either a leaf
node or is computed from the two nodes immediately below it (i.e.,
towards the leaves). At each step up the tree (towards the root), a node
from the inclusion proof is combined with the node computed so far. In
other words, the inclusion proof consists of the list of missing nodes
required to compute the nodes leading from a leaf to the root of the
tree. If the root computed from the inclusion proof matches the true
root, then the inclusion proof proves that the leaf exists in the
tree.[¶](#section-2.1.3-1){.pilcrow}

::: {#generating-an-inclusion-proof}
::: {#section-2.1.3.1 .section}
##### [2.1.3.1.](#section-2.1.3.1){.section-number .selfRef} [Generating an Inclusion Proof](#name-generating-an-inclusion-pro){.section-name .selfRef} {#name-generating-an-inclusion-pro}

Given an ordered list of n inputs to the tree, D_n = {d\[0\], d\[1\],
\..., d\[n-1\]}, the Merkle inclusion proof PATH(m, D_n) for the (m+1)th
input d\[m\], 0 \<= m \< n, is defined as
follows:[¶](#section-2.1.3.1-1){.pilcrow}

The proof for the single leaf in a tree with a one-element input list
D\[1\] = {d\[0\]} is empty:[¶](#section-2.1.3.1-2){.pilcrow}

::: {#section-2.1.3.1-3 .alignLeft .art-text .artwork}
    PATH(0, {d[0]}) = {}

[¶](#section-2.1.3.1-3){.pilcrow}
:::

For n \> 1, let k be the largest power of two smaller than n. The proof
for the (m+1)th element d\[m\] in a list of n \> m elements is then
defined recursively as:[¶](#section-2.1.3.1-4){.pilcrow}

::: {#section-2.1.3.1-5 .alignLeft .art-text .artwork}
    PATH(m, D_n) = PATH(m, D[0:k]) : MTH(D[k:n]) for m < k; and

    PATH(m, D_n) = PATH(m - k, D[k:n]) : MTH(D[0:k]) for m >= k,

[¶](#section-2.1.3.1-5){.pilcrow}
:::

The : operator and D\[k1:k2\] are defined the same as in [Section
2.1.1](#mht_definition){.xref}.[¶](#section-2.1.3.1-6){.pilcrow}
:::
:::

::: {#verify_inclusion}
::: {#section-2.1.3.2 .section}
##### [2.1.3.2.](#section-2.1.3.2){.section-number .selfRef} [Verifying an Inclusion Proof](#name-verifying-an-inclusion-proo){.section-name .selfRef} {#name-verifying-an-inclusion-proo}

When a client has received an inclusion proof (e.g., in a `TransItem` of
type `inclusion_proof_v2`) and wishes to verify inclusion of an input
`hash` for a given `tree_size` and `root_hash`, the following algorithm
may be used to prove the `hash` was included in the
`root_hash`:[¶](#section-2.1.3.2-1){.pilcrow}

1.  [Compare `leaf_index` from the `inclusion_proof_v2` structure
    against `tree_size`. If `leaf_index` is greater than or equal to
    `tree_size`, then fail the proof
    verification.[¶](#section-2.1.3.2-2.1){.pilcrow}]{#section-2.1.3.2-2.1}

2.  [Set `fn` to `leaf_index` and `sn` to
    `tree_size -        1`.[¶](#section-2.1.3.2-2.2){.pilcrow}]{#section-2.1.3.2-2.2}

3.  [Set `r` to
    `hash`.[¶](#section-2.1.3.2-2.3){.pilcrow}]{#section-2.1.3.2-2.3}

4.  ::: {#section-2.1.3.2-2.4}
    For each value `p` in the `inclusion_path`
    array:[¶](#section-2.1.3.2-2.4.1){.pilcrow}

    a.  [If `sn` is 0, then stop the iteration and fail the proof
        verification.[¶](#section-2.1.3.2-2.4.2.1){.pilcrow}]{#section-2.1.3.2-2.4.2.1}

    b.  ::: {#section-2.1.3.2-2.4.2.2}
        If `LSB(fn)` is set, or if `fn` is equal to `sn`,
        then:[¶](#section-2.1.3.2-2.4.2.2.1){.pilcrow}

        i.  [Set `r` to
            `HASH(0x01 || p || r)`.[¶](#section-2.1.3.2-2.4.2.2.2.1){.pilcrow}]{#section-2.1.3.2-2.4.2.2.2.1}
        ii. [If `LSB(fn)` is not set, then right-shift both `fn` and
            `sn` equally until either `LSB(fn)` is set or `fn` is
            `0`.[¶](#section-2.1.3.2-2.4.2.2.2.2){.pilcrow}]{#section-2.1.3.2-2.4.2.2.2.2}

        Otherwise:[¶](#section-2.1.3.2-2.4.2.2.3){.pilcrow}

        i.  [Set `r` to
            `HASH(0x01 || r || p)`.[¶](#section-2.1.3.2-2.4.2.2.4.1){.pilcrow}]{#section-2.1.3.2-2.4.2.2.4.1}
        :::

    c.  [Finally, right-shift both `fn` and `sn` one
        time.[¶](#section-2.1.3.2-2.4.2.3){.pilcrow}]{#section-2.1.3.2-2.4.2.3}
    :::

5.  [Compare `sn` to 0. Compare `r` against the `root_hash`. If `sn` is
    equal to 0 and `r` and the `root_hash` are equal, then the log has
    proven the inclusion of `hash`. Otherwise, fail the proof
    verification.[¶](#section-2.1.3.2-2.5){.pilcrow}]{#section-2.1.3.2-2.5}
:::
:::
:::
:::

::: {#consistency}
::: {#section-2.1.4 .section}
#### [2.1.4.](#section-2.1.4){.section-number .selfRef} [Merkle Consistency Proofs](#name-merkle-consistency-proofs){.section-name .selfRef} {#name-merkle-consistency-proofs}

Merkle consistency proofs prove the append-only property of the tree. A
Merkle consistency proof for a Merkle Tree Hash MTH(D_n) and a
previously advertised hash MTH(D\[0:m\]) of the first m leaves, m \<= n,
is the list of nodes in the Merkle Tree required to verify that the
first m inputs D\[0:m\] are equal in both trees. Thus, a consistency
proof must contain a set of intermediate nodes (i.e., commitments to
inputs) sufficient to verify MTH(D_n), such that (a subset of) the same
nodes can be used to verify MTH(D\[0:m\]). We define an algorithm that
outputs the (unique) minimal consistency
proof.[¶](#section-2.1.4-1){.pilcrow}

::: {#generating-a-consistency-proof}
::: {#section-2.1.4.1 .section}
##### [2.1.4.1.](#section-2.1.4.1){.section-number .selfRef} [Generating a Consistency Proof](#name-generating-a-consistency-pr){.section-name .selfRef} {#name-generating-a-consistency-pr}

Given an ordered list of n inputs to the tree, D_n = {d\[0\], d\[1\],
\..., d\[n-1\]}, the Merkle consistency proof PROOF(m, D_n) for a
previous Merkle Tree Hash MTH(D\[0:m\]), 0 \< m \< n, is defined
as:[¶](#section-2.1.4.1-1){.pilcrow}

::: {#section-2.1.4.1-2 .alignLeft .art-text .artwork}
    PROOF(m, D_n) = SUBPROOF(m, D_n, true)

[¶](#section-2.1.4.1-2){.pilcrow}
:::

In SUBPROOF, the boolean value represents whether the subtree created
from D\[0:m\] is a complete subtree of the Merkle Tree created from D_n
and, consequently, whether the subtree Merkle Tree Hash MTH(D\[0:m\]) is
known. The initial call to SUBPROOF sets this to be true, and SUBPROOF
is then defined as follows:[¶](#section-2.1.4.1-3){.pilcrow}

The subproof for m = n is empty if m is the value for which PROOF was
originally requested (meaning that the subtree created from D\[0:m\] is
a complete subtree of the Merkle Tree created from the original D_n for
which PROOF was requested and the subtree Merkle Tree Hash MTH(D\[0:m\])
is known):[¶](#section-2.1.4.1-4){.pilcrow}

::: {#section-2.1.4.1-5 .alignLeft .art-text .artwork}
    SUBPROOF(m, D_m, true) = {}

[¶](#section-2.1.4.1-5){.pilcrow}
:::

Otherwise, the subproof for m = n is the Merkle Tree Hash committing
inputs D\[0:m\]:[¶](#section-2.1.4.1-6){.pilcrow}

::: {#section-2.1.4.1-7 .alignLeft .art-text .artwork}
    SUBPROOF(m, D_m, false) = {MTH(D_m)}

[¶](#section-2.1.4.1-7){.pilcrow}
:::

For m \< n, let k be the largest power of two smaller than n. The
subproof is then defined recursively, using the appropriate step
below:[¶](#section-2.1.4.1-8){.pilcrow}

If m \<= k, the right subtree entries D\[k:n\] only exist in the current
tree. We prove that the left subtree entries D\[0:k\] are consistent and
add a commitment to D\[k:n\]:[¶](#section-2.1.4.1-9){.pilcrow}

::: {#section-2.1.4.1-10 .alignLeft .art-text .artwork}
    SUBPROOF(m, D_n, b) = SUBPROOF(m, D[0:k], b) : MTH(D[k:n])

[¶](#section-2.1.4.1-10){.pilcrow}
:::

If m \> k, the left subtree entries D\[0:k\] are identical in both
trees. We prove that the right subtree entries D\[k:n\] are consistent
and add a commitment to D\[0:k\]:[¶](#section-2.1.4.1-11){.pilcrow}

::: {#section-2.1.4.1-12 .alignLeft .art-text .artwork}
    SUBPROOF(m, D_n, b) = SUBPROOF(m - k, D[k:n], false) : MTH(D[0:k])

[¶](#section-2.1.4.1-12){.pilcrow}
:::

The number of nodes in the resulting proof is bounded above by
ceil(log2(n)) + 1.[¶](#section-2.1.4.1-13){.pilcrow}

The : operator and D\[k1:k2\] are defined the same as in [Section
2.1.1](#mht_definition){.xref}.[¶](#section-2.1.4.1-14){.pilcrow}
:::
:::

::: {#verify_consistency}
::: {#section-2.1.4.2 .section}
##### [2.1.4.2.](#section-2.1.4.2){.section-number .selfRef} [Verifying Consistency between Two Tree Heads](#name-verifying-consistency-betwe){.section-name .selfRef} {#name-verifying-consistency-betwe}

When a client has a tree head `first_hash` for tree size `first`, has a
tree head `second_hash` for tree size `second` where
`0 < first <      second`, and has received a consistency proof between
the two (e.g., in a `TransItem` of type `consistency_proof_v2`), the
following algorithm may be used to verify the consistency
proof:[¶](#section-2.1.4.2-1){.pilcrow}

1.  [If `consistency_path` is an empty array, stop and fail the proof
    verification.[¶](#section-2.1.4.2-2.1){.pilcrow}]{#section-2.1.4.2-2.1}

2.  [If `first` is an exact power of 2, then prepend `first_hash` to the
    `consistency_path`
    array.[¶](#section-2.1.4.2-2.2){.pilcrow}]{#section-2.1.4.2-2.2}

3.  [Set `fn` to `first - 1` and `sn` to
    `second -        1`.[¶](#section-2.1.4.2-2.3){.pilcrow}]{#section-2.1.4.2-2.3}

4.  [If `LSB(fn)` is set, then right-shift both `fn` and `sn` equally
    until `LSB(fn)` is not
    set.[¶](#section-2.1.4.2-2.4){.pilcrow}]{#section-2.1.4.2-2.4}

5.  [Set both `fr` and `sr` to the first value in the `consistency_path`
    array.[¶](#section-2.1.4.2-2.5){.pilcrow}]{#section-2.1.4.2-2.5}

6.  ::: {#section-2.1.4.2-2.6}
    For each subsequent value `c` in the `consistency_path`
    array:[¶](#section-2.1.4.2-2.6.1){.pilcrow}

    a.  [If `sn` is 0, then stop the iteration and fail the proof
        verification.[¶](#section-2.1.4.2-2.6.2.1){.pilcrow}]{#section-2.1.4.2-2.6.2.1}

    b.  ::: {#section-2.1.4.2-2.6.2.2}
        If `LSB(fn)` is set, or if `fn` is equal to `sn`,
        then:[¶](#section-2.1.4.2-2.6.2.2.1){.pilcrow}

        i.  [Set `fr` to
            `HASH(0x01 || c || fr)`.[¶](#section-2.1.4.2-2.6.2.2.2.1){.pilcrow}]{#section-2.1.4.2-2.6.2.2.2.1}
        ii. [Set `sr` to
            `HASH(0x01 || c || sr)`.[¶](#section-2.1.4.2-2.6.2.2.2.2){.pilcrow}]{#section-2.1.4.2-2.6.2.2.2.2}
        iii. [If `LSB(fn)` is not set, then right-shift both `fn` and
             `sn` equally until either `LSB(fn)` is set or `fn` is
             `0`.[¶](#section-2.1.4.2-2.6.2.2.2.3){.pilcrow}]{#section-2.1.4.2-2.6.2.2.2.3}

        Otherwise:[¶](#section-2.1.4.2-2.6.2.2.3){.pilcrow}

        i.  [Set `sr` to
            `HASH(0x01 || sr || c)`.[¶](#section-2.1.4.2-2.6.2.2.4.1){.pilcrow}]{#section-2.1.4.2-2.6.2.2.4.1}
        :::

    c.  [Finally, right-shift both `fn` and `sn` one
        time.[¶](#section-2.1.4.2-2.6.2.3){.pilcrow}]{#section-2.1.4.2-2.6.2.3}
    :::

7.  [After completing iterating through the `consistency_path` array as
    described above, verify that the `fr` calculated is equal to the
    `first_hash` supplied, that the `sr` calculated is equal to the
    `second_hash` supplied, and that `sn` is
    0.[¶](#section-2.1.4.2-2.7){.pilcrow}]{#section-2.1.4.2-2.7}
:::
:::
:::
:::

::: {#example}
::: {#section-2.1.5 .section}
#### [2.1.5.](#section-2.1.5){.section-number .selfRef} [Example](#name-example){.section-name .selfRef} {#name-example}

The following is a binary Merkle Tree with 7
leaves:[¶](#section-2.1.5-1){.pilcrow}

::: {#section-2.1.5-2 .alignLeft .art-text .artwork}
                hash
               /    \
              /      \
             /        \
            /          \
           /            \
          k              l
         / \            / \
        /   \          /   \
       /     \        /     \
      g       h      i      j
     / \     / \    / \     |
     a b     c d    e f     d6
     | |     | |    | |
    d0 d1   d2 d3  d4 d5

[¶](#section-2.1.5-2){.pilcrow}
:::

The inclusion proof for `d0` is \[`b`, `h`,
`l`\].[¶](#section-2.1.5-3){.pilcrow}

The inclusion proof for `d3` is \[`c`, `g`,
`l`\].[¶](#section-2.1.5-4){.pilcrow}

The inclusion proof for `d4` is \[`f`, `j`,
`k`\].[¶](#section-2.1.5-5){.pilcrow}

The inclusion proof for `d6` is \[`i`,
`k`\].[¶](#section-2.1.5-6){.pilcrow}

The same tree, built incrementally in four
steps:[¶](#section-2.1.5-7){.pilcrow}

::: {#section-2.1.5-8 .alignLeft .art-text .artwork}
        hash0          hash1=k
        / \              /  \
       /   \            /    \
      /     \          /      \
      g      c         g       h
     / \     |        / \     / \
     a b     d2       a b     c d
     | |              | |     | |
    d0 d1            d0 d1   d2 d3

              hash2                    hash
              /  \                    /    \
             /    \                  /      \
            /      \                /        \
           /        \              /          \
          /          \            /            \
         k            i          k              l
        / \          / \        / \            / \
       /   \         e f       /   \          /   \
      /     \        | |      /     \        /     \
     g       h      d4 d5    g       h      i      j
    / \     / \             / \     / \    / \     |
    a b     c d             a b     c d    e f     d6
    | |     | |             | |     | |    | |
    d0 d1   d2 d3           d0 d1   d2 d3  d4 d5

[¶](#section-2.1.5-8){.pilcrow}
:::

The consistency proof between `hash0` and `hash` is PROOF(3, D\[7\]) =
\[`c`, `d`, `g`, `l`\]. Non-leaf nodes `c`, `g` are used to verify
`hash0`, and non-leaf nodes `d`, `l` are additionally used to show
`hash` is consistent with `hash0`.[¶](#section-2.1.5-9){.pilcrow}

The consistency proof between `hash1` and `hash` is PROOF(4, D\[7\]) =
\[`l`\]. `hash` can be verified using `hash1`=`k` and
`l`.[¶](#section-2.1.5-10){.pilcrow}

The consistency proof between `hash2` and `hash` is PROOF(6, D\[7\]) =
\[`i`, `j`, `k`\]. Non-leaf nodes `k`, `i` are used to verify `hash2`,
and non-leaf node `j` is additionally used to show `hash` is consistent
with `hash2`.[¶](#section-2.1.5-11){.pilcrow}
:::
:::
:::
:::

::: {#signatures}
::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [Signatures](#name-signatures){.section-name .selfRef} {#name-signatures}

When signing data structures, a log [MUST]{.bcp14} use one of the
signature algorithms from the IANA \"Signature Algorithms\" registry,
described in [Section
10.2.2](#signature_algorithms){.xref}.[¶](#section-2.2-1){.pilcrow}
:::
:::
:::
:::

::: {#submitters}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Submitters](#name-submitters){.section-name .selfRef} {#name-submitters}

Submitters submit certificates or preannouncements of certificates prior
to issuance (precertificates) to logs for public auditing, as described
below. In order to enable attribution of each logged certificate or
precertificate to its issuer, each submission [MUST]{.bcp14} be
accompanied by all additional certificates required to verify the chain
up to an accepted trust anchor ([Section 5.7](#get-anchors){.xref}). The
trust anchor (a root or intermediate CA certificate) [MAY]{.bcp14} be
omitted from the submission.[¶](#section-3-1){.pilcrow}

If a log accepts a submission, it will return a Signed Certificate
Timestamp (SCT) (see [Section 4.8](#sct){.xref}). The submitter
[SHOULD]{.bcp14} validate the returned SCT, as described in [Section
8.1](#tls_clients){.xref}, if they understand its format and they intend
to use it directly in a TLS handshake or to construct a certificate. If
the submitter does not need the SCT (for example, the certificate is
being submitted simply to make it available in the log), it
[MAY]{.bcp14} validate the SCT.[¶](#section-3-2){.pilcrow}

::: {#certificates}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Certificates](#name-certificates){.section-name .selfRef} {#name-certificates}

Any entity can submit a certificate ([Section
5.1](#submit-entry){.xref}) to a log. Since it is anticipated that TLS
clients will reject certificates that are not logged, it is expected
that certificate issuers and subjects will be strongly motivated to
submit them.[¶](#section-3.1-1){.pilcrow}
:::
:::

::: {#precertificates}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Precertificates](#name-precertificates){.section-name .selfRef} {#name-precertificates}

CAs may preannounce a certificate prior to issuance by submitting a
precertificate ([Section 5.1](#submit-entry){.xref}) that the log can
use to create an entry that will be valid against the issued
certificate. The CA [MAY]{.bcp14} incorporate the returned SCT in the
issued certificate. One example of where the returned SCT is not
incorporated in the issued certificate is when a CA sends the
precertificate to multiple logs but only incorporates the SCTs that are
returned first.[¶](#section-3.2-1){.pilcrow}

A precertificate is a CMS \[[RFC5652](#RFC5652){.xref}\] `signed-data`
object that conforms to the following
profile:[¶](#section-3.2-2){.pilcrow}

-   [It [MUST]{.bcp14} be DER encoded, as described in
    \[[X690](#X690){.xref}\].[¶](#section-3.2-3.1){.pilcrow}]{#section-3.2-3.1}

-   [`SignedData.version` [MUST]{.bcp14} be
    v3(3).[¶](#section-3.2-3.2){.pilcrow}]{#section-3.2-3.2}

-   [`SignedData.digestAlgorithms` [MUST]{.bcp14} be the same as the
    `SignerInfo.digestAlgorithm` OID value (see
    below).[¶](#section-3.2-3.3){.pilcrow}]{#section-3.2-3.3}

-   ::: {#section-3.2-3.4}
    `SignedData.encapContentInfo`:[¶](#section-3.2-3.4.1){.pilcrow}

    -   [`eContentType` [MUST]{.bcp14} be the OID
        1.3.101.78.[¶](#section-3.2-3.4.2.1){.pilcrow}]{#section-3.2-3.4.2.1}
    -   [`eContent` [MUST]{.bcp14} contain a TBSCertificate
        \[[RFC5280](#RFC5280){.xref}\] that will be identical to the
        TBSCertificate in the issued certificate, except that the
        Transparency Information ([Section
        7.1](#x509v3_transinfo_extension){.xref}) extension
        [MUST]{.bcp14} be
        omitted.[¶](#section-3.2-3.4.2.2){.pilcrow}]{#section-3.2-3.4.2.2}
    :::

-   [`SignedData.certificates` [MUST]{.bcp14} be
    omitted.[¶](#section-3.2-3.5){.pilcrow}]{#section-3.2-3.5}

-   [`SignedData.crls` [MUST]{.bcp14} be
    omitted.[¶](#section-3.2-3.6){.pilcrow}]{#section-3.2-3.6}

-   ::: {#section-3.2-3.7}
    `SignedData.signerInfos` [MUST]{.bcp14} contain one
    `SignerInfo`:[¶](#section-3.2-3.7.1){.pilcrow}

    -   [`version` [MUST]{.bcp14} be
        v3(3).[¶](#section-3.2-3.7.2.1){.pilcrow}]{#section-3.2-3.7.2.1}

    -   [`sid` [MUST]{.bcp14} use the `subjectKeyIdentifier`
        option.[¶](#section-3.2-3.7.2.2){.pilcrow}]{#section-3.2-3.7.2.2}

    -   [`digestAlgorithm` [MUST]{.bcp14} be one of the hash algorithm
        OIDs listed in the IANA \"Hash Algorithms\" registry, described
        in [Section
        10.2.1](#hash_algorithms){.xref}.[¶](#section-3.2-3.7.2.3){.pilcrow}]{#section-3.2-3.7.2.3}

    -   ::: {#section-3.2-3.7.2.4}
        `signedAttrs` [MUST]{.bcp14} be present and [MUST]{.bcp14}
        contain two attributes:[¶](#section-3.2-3.7.2.4.1){.pilcrow}

        -   [a content-type attribute whose value is the same as
            `SignedData.encapContentInfo.eContentType`
            and[¶](#section-3.2-3.7.2.4.2.1){.pilcrow}]{#section-3.2-3.7.2.4.2.1}
        -   [a message-digest attribute whose value is the message
            digest of
            `SignedData.encapContentInfo.eContent`.[¶](#section-3.2-3.7.2.4.2.2){.pilcrow}]{#section-3.2-3.7.2.4.2.2}
        :::

    -   [`signatureAlgorithm` [MUST]{.bcp14} be the same OID as
        `TBSCertificate.signature`.[¶](#section-3.2-3.7.2.5){.pilcrow}]{#section-3.2-3.7.2.5}

    -   [`signature` [MUST]{.bcp14} be from the same (root or
        intermediate) CA that intends to issue the corresponding
        certificate (see [Section
        3.2.1](#binding_intent_to_issue){.xref}).[¶](#section-3.2-3.7.2.6){.pilcrow}]{#section-3.2-3.7.2.6}

    -   [`unsignedAttrs` [MUST]{.bcp14} be
        omitted.[¶](#section-3.2-3.7.2.7){.pilcrow}]{#section-3.2-3.7.2.7}
    :::

`SignerInfo.signedAttrs` is included in the message digest calculation
process (see [Section
5.4](https://www.rfc-editor.org/rfc/rfc5652#section-5.4){.relref} of
\[[RFC5652](#RFC5652){.xref}\]), which ensures that the
`SignerInfo.signature` value will not be a valid X.509v3 signature that
could be used in conjunction with the TBSCertificate (from
`SignedData.encapContentInfo.eContent`) to construct a valid
certificate.[¶](#section-3.2-4){.pilcrow}

::: {#binding_intent_to_issue}
::: {#section-3.2.1 .section}
#### [3.2.1.](#section-3.2.1){.section-number .selfRef} [Binding Intent to Issue](#name-binding-intent-to-issue){.section-name .selfRef} {#name-binding-intent-to-issue}

Under normal circumstances, there will be a short delay between
precertificate submission and issuance of the corresponding certificate.
Longer delays are to be expected occasionally (e.g., due to log server
downtime); in some cases, the CA might not actually issue the
corresponding certificate. Nevertheless, a precertificate\'s `signature`
indicates the CA\'s binding intent to issue the corresponding
certificate, which means that:[¶](#section-3.2.1-1){.pilcrow}

-   [Misissuance of a precertificate is considered equivalent to
    misissuance of the corresponding certificate. The CA should expect
    to be held accountable, even if the corresponding certificate has
    not actually been
    issued.[¶](#section-3.2.1-2.1){.pilcrow}]{#section-3.2.1-2.1}
-   [Upon observing a precertificate, a client can reasonably presume
    that the corresponding certificate has been issued. A client may
    wish to obtain status information (e.g., by using the Online
    Certificate Status Protocol \[[RFC6960](#RFC6960){.xref}\] or by
    checking a Certificate Revocation List
    \[[RFC5280](#RFC5280){.xref}\]) about a certificate that is presumed
    to exist, especially if there is evidence or suspicion that the
    corresponding precertificate was
    misissued.[¶](#section-3.2.1-2.2){.pilcrow}]{#section-3.2.1-2.2}
-   [TLS clients may have policies that require CAs to be able to revoke
    and to provide certificate status services for each certificate that
    is presumed to exist based on the existence of a corresponding
    precertificate.[¶](#section-3.2.1-2.3){.pilcrow}]{#section-3.2.1-2.3}
:::
:::
:::
:::
:::
:::

::: {#log-format-and-operation}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Log Format and Operation](#name-log-format-and-operation){.section-name .selfRef} {#name-log-format-and-operation}

A log is a single, append-only Merkle Tree of submitted certificate and
precertificate entries.[¶](#section-4-1){.pilcrow}

When it receives and accepts a valid submission, the log [MUST]{.bcp14}
return an SCT that corresponds to the submitted certificate or
precertificate. If the log has previously seen this valid submission, it
[SHOULD]{.bcp14} return the same SCT as it returned before, as discussed
in [Section 11.3](#misbehaving_logs){.xref}. If different SCTs are
produced for the same submission, multiple log entries will have to be
created, one for each SCT (as the timestamp is a part of the leaf
structure). Note that if a certificate was previously logged as a
precertificate, then the precertificate\'s SCT of type `precert_sct_v2`
would not be appropriate; instead, a fresh SCT of type `x509_sct_v2`
should be generated.[¶](#section-4-2){.pilcrow}

An SCT is the log\'s promise to append to its Merkle Tree an entry for
the accepted submission. Upon producing an SCT, the log [MUST]{.bcp14}
fulfill this promise by performing the following actions within a fixed
amount of time known as the Maximum Merge Delay (MMD), which is one of
the log\'s parameters (see [Section
4.1](#log_parameters){.xref}):[¶](#section-4-3){.pilcrow}

-   [Allocate a tree index to the entry representing the accepted
    submission.[¶](#section-4-4.1){.pilcrow}]{#section-4-4.1}
-   [Calculate the root of the
    tree.[¶](#section-4-4.2){.pilcrow}]{#section-4-4.2}
-   [Sign the root of the tree (see [Section
    4.10](#sth){.xref}).[¶](#section-4-4.3){.pilcrow}]{#section-4-4.3}

The log may append multiple entries before signing the root of the
tree.[¶](#section-4-5){.pilcrow}

Log operators [SHOULD NOT]{.bcp14} impose any conditions on retrieving
or sharing data from the log.[¶](#section-4-6){.pilcrow}

::: {#log_parameters}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Log Parameters](#name-log-parameters){.section-name .selfRef} {#name-log-parameters}

A log is defined by a collection of immutable parameters, which are used
by clients to communicate with the log and to verify log artifacts.
Except for the Final STH, each of these parameters [MUST]{.bcp14} be
established before the log operator begins to operate the
log.[¶](#section-4.1-1){.pilcrow}

[]{.break}

Base URL:
:   The prefix used to construct URLs \[[RFC3986](#RFC3986){.xref}\] for
    client messages (see [Section 5](#client_messages){.xref}). The base
    URL [MUST]{.bcp14} be an \"https\" URL, [MAY]{.bcp14} contain a
    port, and [MAY]{.bcp14} contain a path with any number of path
    segments but [MUST NOT]{.bcp14} contain a query string, fragment, or
    trailing \"/\". Example:
    https://ct.example.org/blue.[¶](#section-4.1-2.2){.pilcrow}
:   

Hash Algorithm:
:   The hash algorithm used for the Merkle Tree (see [Section
    10.2.1](#hash_algorithms){.xref}).[¶](#section-4.1-2.4){.pilcrow}
:   

Signature Algorithm:
:   The signature algorithm used (see [Section
    2.2](#signatures){.xref}).[¶](#section-4.1-2.6){.pilcrow}
:   

Public Key:
:   The public key used to verify signatures generated by the log. A log
    [MUST NOT]{.bcp14} use the same keypair as any other
    log.[¶](#section-4.1-2.8){.pilcrow}
:   

Log ID:
:   The OID that uniquely identifies the
    log.[¶](#section-4.1-2.10){.pilcrow}
:   

Maximum Merge Delay:
:   The MMD the log has committed to. This document deliberately does
    not specify any limits on the value to allow for
    experimentation.[¶](#section-4.1-2.12){.pilcrow}
:   

Version:
:   The version of the protocol supported by the log (currently 1 or
    2).[¶](#section-4.1-2.14){.pilcrow}
:   

Maximum Chain Length:
:   The longest certificate chain submission the log is willing to
    accept, if the log imposes any
    limit.[¶](#section-4.1-2.16){.pilcrow}
:   

STH Frequency Count:
:   The maximum number of STHs the log may produce in any period equal
    to the `Maximum Merge Delay` (see [Section
    4.10](#sth){.xref}).[¶](#section-4.1-2.18){.pilcrow}
:   

Final STH:
:   If a log has been closed down (i.e., no longer accepts new entries),
    existing entries may still be valid. In this case, the client should
    know the final valid STH in the log to ensure no new entries can be
    added without detection. This value [MUST]{.bcp14} be provided in
    the form of a `TransItem` of type `signed_tree_head_v2`. If a log is
    still accepting entries, this value should not be
    provided.[¶](#section-4.1-2.20){.pilcrow}
:   

\[[JSON.Metadata](#JSON.Metadata){.xref}\] is an example of a metadata
format that includes the above elements.[¶](#section-4.1-3){.pilcrow}
:::
:::

::: {#evaluating-submissions}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Evaluating Submissions](#name-evaluating-submissions){.section-name .selfRef} {#name-evaluating-submissions}

A log determines whether to accept or reject a submission by evaluating
it against the minimum acceptance criteria (see [Section
4.2.1](#minimum_criteria){.xref}) and against the log\'s discretionary
acceptance criteria (see [Section
4.2.2](#discretionary_criteria){.xref}).[¶](#section-4.2-1){.pilcrow}

If the acceptance criteria are met, the log [SHOULD]{.bcp14} accept the
submission. (A log may decide, for example, to temporarily reject
acceptable submissions to protect itself against denial-of-service
attacks.)[¶](#section-4.2-2){.pilcrow}

The log [SHALL]{.bcp14} allow retrieval of its list of accepted trust
anchors (see [Section 5.7](#get-anchors){.xref}), each of which is a
root or intermediate CA certificate. This list might usefully be the
union of root certificates trusted by major browser
vendors.[¶](#section-4.2-3){.pilcrow}

::: {#minimum_criteria}
::: {#section-4.2.1 .section}
#### [4.2.1.](#section-4.2.1){.section-number .selfRef} [Minimum Acceptance Criteria](#name-minimum-acceptance-criteria){.section-name .selfRef} {#name-minimum-acceptance-criteria}

To ensure that logged certificates and precertificates are attributable
to an accepted trust anchor, to set clear expectations for what monitors
would find in the log, and to avoid being overloaded by invalid
submissions, the log [MUST]{.bcp14} reject a submission if any of the
following conditions are not met:[¶](#section-4.2.1-1){.pilcrow}

-   [The `submission`, `type`, and `chain` inputs [MUST]{.bcp14} be set
    as described in [Section 5.1](#submit-entry){.xref}. The log [MUST
    NOT]{.bcp14} accommodate misordered CA certificates or use any other
    source of intermediate CA certificates to attempt certification path
    construction.[¶](#section-4.2.1-2.1){.pilcrow}]{#section-4.2.1-2.1}

-   ::: {#section-4.2.1-2.2}
    Each of the zero or more intermediate CA certificates in the chain
    [MUST]{.bcp14} have one or both of the following
    features:[¶](#section-4.2.1-2.2.1){.pilcrow}

    -   [The Basic Constraints extension with the cA boolean
        asserted.[¶](#section-4.2.1-2.2.2.1){.pilcrow}]{#section-4.2.1-2.2.2.1}
    -   [The Key Usage extension with the keyCertSign bit
        asserted.[¶](#section-4.2.1-2.2.2.2){.pilcrow}]{#section-4.2.1-2.2.2.2}
    :::

-   [Each certificate in the chain [MUST]{.bcp14} fall within the limits
    imposed by the zero or more Basic Constraints pathLenConstraint
    values found higher up the
    chain.[¶](#section-4.2.1-2.3){.pilcrow}]{#section-4.2.1-2.3}

-   [Precertificate submissions [MUST]{.bcp14} conform to all of the
    requirements in [Section
    3.2](#precertificates){.xref}.[¶](#section-4.2.1-2.4){.pilcrow}]{#section-4.2.1-2.4}
:::
:::

::: {#discretionary_criteria}
::: {#section-4.2.2 .section}
#### [4.2.2.](#section-4.2.2){.section-number .selfRef} [Discretionary Acceptance Criteria](#name-discretionary-acceptance-cr){.section-name .selfRef} {#name-discretionary-acceptance-cr}

If the minimum acceptance criteria are met but the submission is not
fully valid according to \[[RFC5280](#RFC5280){.xref}\] verification
rules (e.g., the certificate or precertificate has expired, is not yet
valid, has been revoked, exhibits ASN.1 DER encoding errors but the log
can still parse it, etc.), then the acceptability of the submission is
left to the log\'s discretion. It is useful for logs to accept such
submissions in order to accommodate quirks of CA certificate-issuing
software and to facilitate monitoring of CA compliance with applicable
policies and technical standards. However, it is impractical for this
document to enumerate, and for logs to consider, all of the ways that a
submission might fail to comply with
\[[RFC5280](#RFC5280){.xref}\].[¶](#section-4.2.2-1){.pilcrow}

Logs [SHOULD]{.bcp14} limit the length of chain they will accept. The
maximum chain length is one of the log\'s parameters (see [Section
4.1](#log_parameters){.xref}).[¶](#section-4.2.2-2){.pilcrow}
:::
:::
:::
:::

::: {#log_entries}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Log Entries](#name-log-entries){.section-name .selfRef} {#name-log-entries}

If a submission is accepted and an SCT is issued, the accepting log
[MUST]{.bcp14} store the entire chain used for verification. This chain
[MUST]{.bcp14} include the certificate or precertificate itself, the
zero or more intermediate CA certificates provided by the submitter, and
the trust anchor used to verify the chain (even if it was omitted from
the submission). The log [MUST]{.bcp14} provide this chain for auditing
upon request (see [Section 5.6](#get-entries){.xref}) so that the CA
cannot avoid blame by logging a partial or empty chain. Each log entry
is a `TransItem` structure of type `x509_entry_v2` or
`precert_entry_v2`. However, a log may store its entries in any format.
If a log does not store this `TransItem` in full, it must store the
`timestamp` and `sct_extensions` of the corresponding
`TimestampedCertificateEntryDataV2` structure. The `TransItem` can be
reconstructed from these fields and the entire chain that the log used
to verify the submission.[¶](#section-4.3-1){.pilcrow}
:::
:::

::: {#log_id}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Log ID](#name-log-id){.section-name .selfRef} {#name-log-id}

Each log is identified by an OID, which is one of the log\'s parameters
(see [Section 4.1](#log_parameters){.xref}) and which [MUST NOT]{.bcp14}
be used to identify any other log. A log\'s operator [MUST]{.bcp14}
either allocate the OID themselves or request an OID from the Log ID
registry (see [Section 10.2.5](#log_id_registry){.xref}). One way to get
an OID arc, from which OIDs can be allocated, is to request a Private
Enterprise Number from IANA by completing the [registration
form](https://pen.iana.org/pen/PenApplication.page). The only advantage
of the registry is that the DER encoding can be small. (Recall that OID
allocations do not require a central registration, although logs will
most likely want to make themselves known to potential clients through
out-of-band means.) Various data structures include the DER encoding of
this OID, excluding the ASN.1 tag and length bytes, in an opaque
vector:[¶](#section-4.4-1){.pilcrow}

::: {#section-4.4-2}
``` {.lang-tls-presentation .sourcecode}
    opaque LogID<2..127>;
```

[¶](#section-4.4-2){.pilcrow}
:::

Note that the ASN.1 length and the opaque vector length are identical in
size (1 byte) and value, so the full DER encoding (including the tag and
length) of the OID can be reproduced simply by prepending an OBJECT
IDENTIFIER tag (0x06) to the opaque vector length and
contents.[¶](#section-4.4-3){.pilcrow}

The OID used to identify a log is limited such that the DER encoding of
its value, excluding the tag and length, [MUST]{.bcp14} be no longer
than 127 octets.[¶](#section-4.4-4){.pilcrow}
:::
:::

::: {#transitem-structure}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [TransItem Structure](#name-transitem-structure){.section-name .selfRef} {#name-transitem-structure}

Various data structures are encapsulated in the `TransItem` structure to
ensure that the type and version of each one is identified in a common
fashion:[¶](#section-4.5-1){.pilcrow}

::: {#section-4.5-2}
``` {.lang-tls-presentation .sourcecode}
    enum {
        x509_entry_v2(0x0100), precert_entry_v2(0x0101),
        x509_sct_v2(0x0102), precert_sct_v2(0x0103),
        signed_tree_head_v2(0x0104), consistency_proof_v2(0x0105),
        inclusion_proof_v2(0x0106),

        /* Reserved Code Points */
        reserved_rfc6962(0x0000..0x00FF),
        reserved_experimentaluse(0xE000..0xEFFF),
        reserved_privateuse(0xF000..0xFFFF),
        (0xFFFF)
    } VersionedTransType;

    struct {
        VersionedTransType versioned_type;
        select (versioned_type) {
            case x509_entry_v2: TimestampedCertificateEntryDataV2;
            case precert_entry_v2: TimestampedCertificateEntryDataV2;
            case x509_sct_v2: SignedCertificateTimestampDataV2;
            case precert_sct_v2: SignedCertificateTimestampDataV2;
            case signed_tree_head_v2: SignedTreeHeadDataV2;
            case consistency_proof_v2: ConsistencyProofDataV2;
            case inclusion_proof_v2: InclusionProofDataV2;
        } data;
    } TransItem;
```

[¶](#section-4.5-2){.pilcrow}
:::

`versioned_type` is a value from the IANA registry in [Section
10.2.3](#versioned_trans_types){.xref} that identifies the type of the
encapsulated data structure and the earliest version of this protocol to
which it conforms. This document is v2.[¶](#section-4.5-3){.pilcrow}

`data` is the encapsulated data structure. The various structures named
with the `DataV2` suffix are defined in later sections of this
document.[¶](#section-4.5-4){.pilcrow}

Note that `VersionedTransType` combines the v1 type enumerations
`Version`, `LogEntryType`, `SignatureType`, and `MerkleLeafType`
\[[RFC6962](#RFC6962){.xref}\]. Note also that v1 did not define
`TransItem`, but this document provides guidelines (see [Appendix
A](#v1_coexistence){.xref}) on how v2 implementations can coexist with
v1 implementations.[¶](#section-4.5-5){.pilcrow}

Future versions of this protocol may reuse `VersionedTransType` values
defined in this document as long as the corresponding data structures
are not modified and may add new `VersionedTransType` values for new or
modified data structures.[¶](#section-4.5-6){.pilcrow}
:::
:::

::: {#log-artifact-extensions}
::: {#section-4.6 .section}
### [4.6.](#section-4.6){.section-number .selfRef} [Log Artifact Extensions](#name-log-artifact-extensions){.section-name .selfRef} {#name-log-artifact-extensions}

::: {#section-4.6-1}
``` {.lang-tls-presentation .sourcecode}
    enum {
        reserved(65535)
    } ExtensionType;

    struct {
        ExtensionType extension_type;
        opaque extension_data<0..2^16-1>;
    } Extension;
```

[¶](#section-4.6-1){.pilcrow}
:::

The `Extension` structure provides a generic extensibility for log
artifacts, including SCTs ([Section 4.8](#sct){.xref}) and STHs
([Section 4.10](#sth){.xref}). The interpretation of the
`extension_data` field is determined solely by the value of the
`extension_type` field.[¶](#section-4.6-2){.pilcrow}

This document does not define any extensions, but it does establish a
registry for future `ExtensionType` values (see [Section
10.2.4](#log_artifact_extension_registry){.xref}). Each document that
registers a new `ExtensionType` must specify the context in which it may
be used (e.g., SCT, STH, or both) and describe how to interpret the
corresponding `extension_data`.[¶](#section-4.6-3){.pilcrow}
:::
:::

::: {#tree_leaves}
::: {#section-4.7 .section}
### [4.7.](#section-4.7){.section-number .selfRef} [Merkle Tree Leaves](#name-merkle-tree-leaves){.section-name .selfRef} {#name-merkle-tree-leaves}

The leaves of a log\'s Merkle Tree correspond to the log\'s entries (see
[Section 4.3](#log_entries){.xref}). Each leaf is the leaf hash
([Section 2.1](#mht){.xref}) of a `TransItem` structure of type
`x509_entry_v2` or `precert_entry_v2`, which encapsulates a
`TimestampedCertificateEntryDataV2` structure. Note that leaf hashes are
calculated as `HASH(0x00 || TransItem)`, where the hash algorithm is one
of the log\'s parameters.[¶](#section-4.7-1){.pilcrow}

::: {#section-4.7-2}
``` {.lang-tls-presentation .sourcecode}
    opaque TBSCertificate<1..2^24-1>;

    struct {
        uint64 timestamp;
        opaque issuer_key_hash<32..2^8-1>;
        TBSCertificate tbs_certificate;
        Extension sct_extensions<0..2^16-1>;
    } TimestampedCertificateEntryDataV2;
```

[¶](#section-4.7-2){.pilcrow}
:::

`timestamp` is the date and time at which the certificate or
precertificate was accepted by the log, in the form of a 64-bit unsigned
number of milliseconds elapsed since the Unix Epoch (1 January 1970
00:00:00 UTC \-- see \[[UNIXTIME](#UNIXTIME){.xref}\]), ignoring leap
seconds, in network byte order. Note that the leaves of a log\'s Merkle
Tree are not required to be in strict chronological
order.[¶](#section-4.7-3){.pilcrow}

`issuer_key_hash` is the HASH of the public key of the CA that issued
the certificate or precertificate, calculated over the DER encoding of
the key represented as SubjectPublicKeyInfo
\[[RFC5280](#RFC5280){.xref}\]. This is needed to bind the CA to the
certificate or precertificate, making it impossible for the
corresponding SCT to be valid for any other certificate or
precertificate whose TBSCertificate matches `tbs_certificate`. The
length of the `issuer_key_hash` [MUST]{.bcp14} match
HASH_SIZE.[¶](#section-4.7-4){.pilcrow}

`tbs_certificate` is the DER-encoded TBSCertificate from the submission.
(Note that a precertificate\'s TBSCertificate can be reconstructed from
the corresponding certificate, as described in [Section
8.1.2](#reconstructing_tbscertificate){.xref}).[¶](#section-4.7-5){.pilcrow}

`sct_extensions` is byte-for-byte identical to the SCT extensions of the
corresponding SCT.[¶](#section-4.7-6){.pilcrow}

The type of the `TransItem` corresponds to the value of the `type`
parameter supplied in the [Section 5.1](#submit-entry){.xref}
call.[¶](#section-4.7-7){.pilcrow}
:::
:::

::: {#sct}
::: {#section-4.8 .section}
### [4.8.](#section-4.8){.section-number .selfRef} [Signed Certificate Timestamp (SCT)](#name-signed-certificate-timestam){.section-name .selfRef} {#name-signed-certificate-timestam}

An SCT is a `TransItem` structure of type `x509_sct_v2` or
`precert_sct_v2`, which encapsulates a
`SignedCertificateTimestampDataV2`
structure:[¶](#section-4.8-1){.pilcrow}

::: {#section-4.8-2}
``` {.lang-tls-presentation .sourcecode}
    struct {
        LogID log_id;
        uint64 timestamp;
        Extension sct_extensions<0..2^16-1>;
        opaque signature<1..2^16-1>;
    } SignedCertificateTimestampDataV2;
```

[¶](#section-4.8-2){.pilcrow}
:::

`log_id` is this log\'s unique ID, encoded in an opaque vector, as
described in [Section 4.4](#log_id){.xref}.[¶](#section-4.8-3){.pilcrow}

`timestamp` is equal to the timestamp from the corresponding
`TimestampedCertificateEntryDataV2`
structure.[¶](#section-4.8-4){.pilcrow}

`sct_extensions` is a vector of 0 or more SCT extensions. This vector
[MUST NOT]{.bcp14} include more than one extension with the same
`extension_type`. The extensions in the vector [MUST]{.bcp14} be ordered
by the value of the `extension_type` field, smallest value first. All
SCT extensions are similar to noncritical X.509v3 extensions (i.e., the
`mustUnderstand` field is not set), and a recipient [SHOULD]{.bcp14}
ignore any extension it does not understand. Furthermore, an
implementation [MAY]{.bcp14} choose to ignore any extension(s) that it
does understand.[¶](#section-4.8-5){.pilcrow}

`signature` is computed over a `TransItem` structure of type
`x509_entry_v2` or `precert_entry_v2` (see [Section
4.7](#tree_leaves){.xref}) using the signature algorithm declared in the
log\'s parameters (see [Section
4.1](#log_parameters){.xref}).[¶](#section-4.8-6){.pilcrow}
:::
:::

::: {#tree_head}
::: {#section-4.9 .section}
### [4.9.](#section-4.9){.section-number .selfRef} [Merkle Tree Head](#name-merkle-tree-head){.section-name .selfRef} {#name-merkle-tree-head}

The log stores information about its Merkle Tree in a
`TreeHeadDataV2`:[¶](#section-4.9-1){.pilcrow}

::: {#section-4.9-2}
``` {.lang-tls-presentation .sourcecode}
    opaque NodeHash<32..2^8-1>;

    struct {
        uint64 timestamp;
        uint64 tree_size;
        NodeHash root_hash;
        Extension sth_extensions<0..2^16-1>;
    } TreeHeadDataV2;
```

[¶](#section-4.9-2){.pilcrow}
:::

The length of NodeHash [MUST]{.bcp14} match HASH_SIZE of the
log.[¶](#section-4.9-3){.pilcrow}

`timestamp` is the current date and time, using the format defined in
[Section 4.7](#tree_leaves){.xref}.[¶](#section-4.9-4){.pilcrow}

`tree_size` is the number of entries currently in the log\'s Merkle
Tree.[¶](#section-4.9-5){.pilcrow}

`root_hash` is the root of the Merkle Tree.[¶](#section-4.9-6){.pilcrow}

`sth_extensions` is a vector of 0 or more STH extensions. This vector
[MUST NOT]{.bcp14} include more than one extension with the same
`extension_type`. The extensions in the vector [MUST]{.bcp14} be ordered
by the value of the `extension_type` field, smallest value first. If an
implementation sees an extension that it does not understand, it
[SHOULD]{.bcp14} ignore that extension. Furthermore, an implementation
[MAY]{.bcp14} choose to ignore any extension(s) that it does
understand.[¶](#section-4.9-7){.pilcrow}
:::
:::

::: {#sth}
::: {#section-4.10 .section}
### [4.10.](#section-4.10){.section-number .selfRef} [Signed Tree Head (STH)](#name-signed-tree-head-sth){.section-name .selfRef} {#name-signed-tree-head-sth}

Periodically, each log [SHOULD]{.bcp14} sign its current tree head
information (see [Section 4.9](#tree_head){.xref}) to produce an STH.
When a client requests a log\'s latest STH (see [Section
5.2](#get-sth){.xref}), the log [MUST]{.bcp14} return an STH that is no
older than the log\'s MMD. However, since STHs could be used to mark
individual clients (by producing a new STH for each query), a log [MUST
NOT]{.bcp14} produce STHs more frequently than its parameters declare
(see [Section 4.1](#log_parameters){.xref}). In general, there is no
need to produce a new STH unless there are new entries in the log;
however, in the event that a log does not accept any submissions during
an MMD period, the log [MUST]{.bcp14} sign the same Merkle Tree Hash
with a fresh timestamp.[¶](#section-4.10-1){.pilcrow}

An STH is a `TransItem` structure of type `signed_tree_head_v2`, which
encapsulates a `SignedTreeHeadDataV2`
structure:[¶](#section-4.10-2){.pilcrow}

::: {#section-4.10-3}
``` {.lang-tls-presentation .sourcecode}
    struct {
        LogID log_id;
        TreeHeadDataV2 tree_head;
        opaque signature<1..2^16-1>;
    } SignedTreeHeadDataV2;
```

[¶](#section-4.10-3){.pilcrow}
:::

`log_id` is this log\'s unique ID encoded in an opaque vector, as
described in [Section
4.4](#log_id){.xref}.[¶](#section-4.10-4){.pilcrow}

The `timestamp` in `tree_head` [MUST]{.bcp14} be at least as recent as
the most recent SCT timestamp in the tree. Each subsequent timestamp
[MUST]{.bcp14} be more recent than the timestamp of the previous
update.[¶](#section-4.10-5){.pilcrow}

`tree_head` contains the latest tree head information (see [Section
4.9](#tree_head){.xref}).[¶](#section-4.10-6){.pilcrow}

`signature` is computed over the `tree_head` field using the signature
algorithm declared in the log\'s parameters (see [Section
4.1](#log_parameters){.xref}).[¶](#section-4.10-7){.pilcrow}
:::
:::

::: {#merkle-consistency-proofs}
::: {#section-4.11 .section}
### [4.11.](#section-4.11){.section-number .selfRef} [Merkle Consistency Proofs](#name-merkle-consistency-proofs-2){.section-name .selfRef} {#name-merkle-consistency-proofs-2}

To prepare a Merkle consistency proof for distribution to clients, the
log produces a `TransItem` structure of type `consistency_proof_v2`,
which encapsulates a `ConsistencyProofDataV2`
structure:[¶](#section-4.11-1){.pilcrow}

::: {#section-4.11-2}
``` {.lang-tls-presentation .sourcecode}
    struct {
        LogID log_id;
        uint64 tree_size_1;
        uint64 tree_size_2;
        NodeHash consistency_path<0..2^16-1>;
    } ConsistencyProofDataV2;
```

[¶](#section-4.11-2){.pilcrow}
:::

`log_id` is this log\'s unique ID encoded in an opaque vector, as
described in [Section
4.4](#log_id){.xref}.[¶](#section-4.11-3){.pilcrow}

`tree_size_1` is the size of the older
tree.[¶](#section-4.11-4){.pilcrow}

`tree_size_2` is the size of the newer
tree.[¶](#section-4.11-5){.pilcrow}

`consistency_path` is a vector of Merkle Tree nodes proving the
consistency of two STHs, as described in [Section
2.1.4](#consistency){.xref}.[¶](#section-4.11-6){.pilcrow}
:::
:::

::: {#merkle-inclusion-proofs}
::: {#section-4.12 .section}
### [4.12.](#section-4.12){.section-number .selfRef} [Merkle Inclusion Proofs](#name-merkle-inclusion-proofs-2){.section-name .selfRef} {#name-merkle-inclusion-proofs-2}

To prepare a Merkle inclusion proof for distribution to clients, the log
produces a `TransItem` structure of type `inclusion_proof_v2`, which
encapsulates an `InclusionProofDataV2`
structure:[¶](#section-4.12-1){.pilcrow}

::: {#section-4.12-2}
``` {.lang-tls-presentation .sourcecode}
    struct {
        LogID log_id;
        uint64 tree_size;
        uint64 leaf_index;
        NodeHash inclusion_path<0..2^16-1>;
    } InclusionProofDataV2;
```

[¶](#section-4.12-2){.pilcrow}
:::

`log_id` is this log\'s unique ID encoded in an opaque vector, as
described in [Section
4.4](#log_id){.xref}.[¶](#section-4.12-3){.pilcrow}

`tree_size` is the size of the tree on which this inclusion proof is
based.[¶](#section-4.12-4){.pilcrow}

`leaf_index` is the 0-based index of the log entry corresponding to this
inclusion proof.[¶](#section-4.12-5){.pilcrow}

`inclusion_path` is a vector of Merkle Tree nodes proving the inclusion
of the chosen certificate or precertificate, as described in [Section
2.1.3](#merkle_inclusion_proof){.xref}.[¶](#section-4.12-6){.pilcrow}
:::
:::

::: {#log_shutdown}
::: {#section-4.13 .section}
### [4.13.](#section-4.13){.section-number .selfRef} [Shutting Down a Log](#name-shutting-down-a-log){.section-name .selfRef} {#name-shutting-down-a-log}

Log operators may decide to shut down a log for various reasons, such as
deprecation of the signature algorithm. If there are entries in the log
for certificates that have not yet expired, simply making TLS clients
stop recognizing that log will have the effect of invalidating SCTs from
that log. In order to avoid that, the following actions [SHOULD]{.bcp14}
be taken:[¶](#section-4.13-1){.pilcrow}

-   [Make it known to clients and monitors that the log will be frozen.
    This is not part of the API, so it will have to be done via a
    relevant out-of-band
    mechanism.[¶](#section-4.13-2.1){.pilcrow}]{#section-4.13-2.1}
-   [Stop accepting new submissions (the error code \"shutdown\" should
    be returned for such
    requests).[¶](#section-4.13-2.2){.pilcrow}]{#section-4.13-2.2}
-   [Once MMD from the last accepted submission has passed and all
    pending submissions are incorporated, issue a final STH and publish
    it as one of the log\'s parameters. Having an STH with a timestamp
    that is after the MMD has passed from the last SCT issuance allows
    clients to audit this log regularly without special handling for the
    final STH. At this point, the log\'s private key is no longer needed
    and can be
    destroyed.[¶](#section-4.13-2.3){.pilcrow}]{#section-4.13-2.3}
-   [Keep the log running until the certificates in all of its entries
    have expired or exist in other logs (this can be determined by
    scanning other logs or connecting to domains mentioned in the
    certificates and inspecting the SCTs
    served).[¶](#section-4.13-2.4){.pilcrow}]{#section-4.13-2.4}
:::
:::
:::
:::

::: {#client_messages}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Log Client Messages](#name-log-client-messages){.section-name .selfRef} {#name-log-client-messages}

Messages are sent as HTTPS GET or POST requests. Parameters for POSTs
and all responses are encoded as JavaScript Object Notation (JSON)
objects \[[RFC8259](#RFC8259){.xref}\]. Parameters for GETs are encoded
as order-independent key/value URL parameters, using the
\"application/x-www-form-urlencoded\" format described in the \"HTML
4.01 Specification\" \[[HTML401](#HTML401){.xref}\]. Binary data is
base64 encoded according to [Section
4](https://www.rfc-editor.org/rfc/rfc4648#section-4){.relref} of
\[[RFC4648](#RFC4648){.xref}\], as specified in the individual
messages.[¶](#section-5-1){.pilcrow}

Clients are configured with a log\'s base URL, which is one of the
log\'s parameters. Clients construct URLs for requests by appending
suffixes to this base URL. This structure places some degree of
restriction on how log operators can deploy these services, as noted in
\[[RFC8820](#RFC8820){.xref}\]. However, operational experience with
version 1 of this protocol has not indicated that these restrictions are
a problem in practice.[¶](#section-5-2){.pilcrow}

Note that JSON objects and URL parameters may contain fields not
specified here to allow for experimentation. Any fields that are not
understood [SHOULD]{.bcp14} be ignored.[¶](#section-5-3){.pilcrow}

In practice, log servers may include multiple front-end machines. Since
it is impractical to keep these machines in perfect sync, errors that
are caused by skew between the machines may occur. Where such errors are
possible, the front end will return additional information (as specified
below), making it possible for clients to make progress, if progress is
possible. Front ends [MUST]{.bcp14} only serve data that is free of gaps
(that is, for example, no front end will respond with an STH unless it
is also able to prove consistency from all log entries logged within
that STH).[¶](#section-5-4){.pilcrow}

For example, when a consistency proof between two STHs is requested, the
front end reached may not yet be aware of one or both STHs. In the case
where it is unaware of both, it will return the latest STH it is aware
of. Where it is aware of the first but not the second, it will return
the latest STH it is aware of and a consistency proof from the first STH
to the returned STH. The case where it knows the second but not the
first should not arise (see the \"no gaps\" requirement
above).[¶](#section-5-5){.pilcrow}

If the log is unable to process a client\'s request, it [MUST]{.bcp14}
return an HTTP response code of 4xx/5xx (see
\[[RFC7231](#RFC7231){.xref}\]), and, in place of the responses outlined
in the subsections below, the body [SHOULD]{.bcp14} be a JSON problem
details object (see [Section
3](https://www.rfc-editor.org/rfc/rfc7807#section-3){.relref} of
\[[RFC7807](#RFC7807){.xref}\]) containing:[¶](#section-5-6){.pilcrow}

[]{.break}

type:
:   A URN reference identifying the problem. To facilitate automated
    response to errors, this document defines a set of standard tokens
    for use in the `type` field within the URN namespace of:
    \"urn:ietf:params:trans:error:\".[¶](#section-5-7.2){.pilcrow}
:   

detail:
:   A human-readable string describing the error that prevented the log
    from processing the request, ideally with sufficient detail to
    enable the error to be rectified.[¶](#section-5-7.4){.pilcrow}
:   

For example, in response to a request of
`<Base URL>/ct/v2/get-entries?start=100&end=99`, the log would return a
`400 Bad Request` response code with a body similar to the
following:[¶](#section-5-8){.pilcrow}

::: {#section-5-9}
``` {.lang-json .sourcecode}
    {
        "type": "urn:ietf:params:trans:error:endBeforeStart",
        "detail": "'start' cannot be greater than 'end'"
    }
```

[¶](#section-5-9){.pilcrow}
:::

Most error types are specific to the type of request and are defined in
the respective subsections below. The one exception is the \"malformed\"
error type, which indicates that the log server could not parse the
client\'s request because it did not comply with this
document:[¶](#section-5-10){.pilcrow}

  type        detail
  ----------- ----------------------------------
  malformed   The request could not be parsed.

  : [Table 1](#table-1){.selfRef}

Clients [SHOULD]{.bcp14} treat `500 Internal Server Error` and
`503       Service Unavailable` responses as transient failures and
[MAY]{.bcp14} retry the same request without modification at a later
date. Note that in the case of a 503 response, the log [MAY]{.bcp14}
include a `Retry-After` header field per \[[RFC7231](#RFC7231){.xref}\]
in order to request a minimum time for the client to wait before
retrying the request. In the absence of this header field, this document
does not specify a minimum.[¶](#section-5-12){.pilcrow}

Clients [SHOULD]{.bcp14} treat any 4xx error as a problem with the
request and not attempt to resubmit without some modification to the
request. The full status code [MAY]{.bcp14} provide additional
details.[¶](#section-5-13){.pilcrow}

This document deliberately does not provide more specific guidance on
the use of HTTP status codes.[¶](#section-5-14){.pilcrow}

::: {#submit-entry}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Submit Entry to Log](#name-submit-entry-to-log){.section-name .selfRef} {#name-submit-entry-to-log}

POST \<Base URL>/ct/v2/submit-entry[¶](#section-5.1-1){.pilcrow}

[]{.break}

Inputs:
:   []{.break}

    submission:
    :   The base64-encoded certificate or
        precertificate.[¶](#section-5.1-2.2.1.2){.pilcrow}
    :   

    type:
    :   The `VersionedTransType` integer value that indicates the type
        of the `submission`: 1 for `x509_entry_v2` or 2 for
        `precert_entry_v2`.[¶](#section-5.1-2.2.1.4){.pilcrow}
    :   

    chain:
    :   An array of zero or more JSON strings, each of which is a
        base64-encoded CA certificate. The first element is the
        certifier of the `submission`, the second certifies the first,
        etc. The last element of `chain` (or, if `chain` is an empty
        array, the `submission`) is certified by an accepted trust
        anchor.[¶](#section-5.1-2.2.1.6){.pilcrow}
    :   
:   

Outputs:

:   []{.break}

    sct:

    :   A base64-encoded `TransItem` of type `x509_sct_v2` or
        `precert_sct_v2`, signed by this log, that corresponds to the
        `submission`.[¶](#section-5.1-2.4.1.2.1){.pilcrow}

    :   

    If the submitted entry is immediately appended to (or already exists
    in) this log\'s tree, then the log [SHOULD]{.bcp14} also
    output:[¶](#section-5.1-2.4.2){.pilcrow}

    []{.break}

    sth:
    :   A base64-encoded `TransItem` of type `signed_tree_head_v2`
        signed by this log.[¶](#section-5.1-2.4.3.2){.pilcrow}
    :   

    inclusion:
    :   A base64-encoded `TransItem` of type `inclusion_proof_v2` whose
        `inclusion_path` array of Merkle Tree nodes proves the inclusion
        of the `submission` in the returned
        `sth`.[¶](#section-5.1-2.4.3.4){.pilcrow}
    :   

:   

Error codes:[¶](#section-5.1-3){.pilcrow}

  type             detail
  ---------------- --------------------------------------------------------------------------------------------------------------------------------------------
  badSubmission    `submission` is neither a valid certificate nor a valid precertificate.
  badType          `type` is neither 1 nor 2.
  badChain         The first element of `chain` is not the certifier of the `submission`, or the second element does not certify the first, etc.
  badCertificate   One or more certificates in `chain` are not valid (e.g., not properly encoded).
  unknownAnchor    The last element of `chain` (or, if `chain` is an empty array, the `submission`) is not, nor is it certified by, an accepted trust anchor.
  shutdown         The log is no longer accepting submissions.

  : [Table 2](#table-2){.selfRef}

If the version of `sct` is not v2, then a v2 client may be unable to
verify the signature. It [MUST NOT]{.bcp14} construe this as an error.
This is to avoid forcing an upgrade of compliant v2 clients that do not
use the returned SCTs.[¶](#section-5.1-5){.pilcrow}

If a log detects bad encoding in a chain that otherwise verifies
correctly, then the log [MUST]{.bcp14} either log the certificate or
return the \"badCertificate\" error. If the certificate is logged, an
SCT [MUST]{.bcp14} be issued. Logging the certificate is useful, because
monitors ([Section 8.2](#monitor){.xref}) can then detect these encoding
errors, which may be accepted by some TLS
clients.[¶](#section-5.1-6){.pilcrow}

If `submission` is an accepted trust anchor whose certifier is neither
an accepted trust anchor nor the first element of `chain`, then the log
[MUST]{.bcp14} return the \"unknownAnchor\" error. A log is not able to
generate an SCT for a submission if it does not have access to the
issuer\'s public key.[¶](#section-5.1-7){.pilcrow}

If the returned `sct` is intended to be provided to TLS clients, then
`sth` and `inclusion` (if returned) [SHOULD]{.bcp14} also be provided to
TLS clients. For example, if `type` was 2 (indicating `precert_sct_v2`),
then all three `TransItem`s could be embedded in the
certificate.[¶](#section-5.1-8){.pilcrow}
:::
:::

::: {#get-sth}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Retrieve Latest STH](#name-retrieve-latest-sth){.section-name .selfRef} {#name-retrieve-latest-sth}

GET \<Base URL>/ct/v2/get-sth[¶](#section-5.2-1){.pilcrow}

No inputs.[¶](#section-5.2-2){.pilcrow}

[]{.break}

Outputs:
:   []{.break}

    sth:
    :   A base64-encoded `TransItem` of type `signed_tree_head_v2`
        signed by this log that is no older than the log\'s
        MMD.[¶](#section-5.2-3.2.1.2){.pilcrow}
    :   
:   
:::
:::

::: {#get-sth-consistency}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Retrieve Merkle Consistency Proof between Two STHs](#name-retrieve-merkle-consistency){.section-name .selfRef} {#name-retrieve-merkle-consistency}

GET \<Base URL>/ct/v2/get-sth-consistency[¶](#section-5.3-1){.pilcrow}

[]{.break}

Inputs:

:   []{.break}

    first:
    :   The `tree_size` of the older tree, in
        decimal.[¶](#section-5.3-2.2.1.2){.pilcrow}
    :   

    second:
    :   The `tree_size` of the newer tree, in decimal
        (optional).[¶](#section-5.3-2.2.1.4){.pilcrow}
    :   

    Both tree sizes must be from existing v2 STHs. However, because of
    skew, the receiving front end may not know one or both of the
    existing STHs. If both are known, then only the `consistency` output
    is returned. If the first is known but the second is not (or has
    been omitted), then the latest known STH is returned, along with a
    consistency proof between the first STH and the latest. If neither
    are known, then the latest known STH is returned without a
    consistency proof.[¶](#section-5.3-2.2.2){.pilcrow}

:   

[]{.break}

Outputs:

:   []{.break}

    consistency:
    :   A base64-encoded `TransItem` of type `consistency_proof_v2`
        whose `tree_size_1` [MUST]{.bcp14} match the `first` input. If
        the `sth` output is omitted, then `tree_size_2` [MUST]{.bcp14}
        match the `second` input. If `first` and `second` are equal and
        correspond to a known STH, the returned consistency proof
        [MUST]{.bcp14} be empty (a `consistency_path` array with zero
        elements).[¶](#section-5.3-3.2.1.2){.pilcrow}
    :   

    sth:
    :   A base64-encoded `TransItem` of type `signed_tree_head_v2`,
        signed by this log.[¶](#section-5.3-3.2.1.4){.pilcrow}
    :   

    Note that no signature is required for the `consistency` output, as
    it is used to verify the consistency between two signed
    STHs.[¶](#section-5.3-3.2.2){.pilcrow}

:   

Error codes:[¶](#section-5.3-4){.pilcrow}

  type                detail
  ------------------- --------------------------------------------------------------------------
  firstUnknown        `first` is before the latest known STH but is not from an existing STH.
  secondUnknown       `second` is before the latest known STH but is not from an existing STH.
  secondBeforeFirst   `second` is smaller than `first`.

  : [Table 3](#table-3){.selfRef}

See [Section 2.1.4.2](#verify_consistency){.xref} for an outline of how
to use the `consistency` output.[¶](#section-5.3-6){.pilcrow}
:::
:::

::: {#get-proof-by-hash}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [Retrieve Merkle Inclusion Proof from Log by Leaf Hash](#name-retrieve-merkle-inclusion-p){.section-name .selfRef} {#name-retrieve-merkle-inclusion-p}

GET \<Base URL>/ct/v2/get-proof-by-hash[¶](#section-5.4-1){.pilcrow}

[]{.break}

Inputs:

:   []{.break}

    hash:
    :   A base64-encoded v2 leaf
        hash.[¶](#section-5.4-2.2.1.2){.pilcrow}
    :   

    tree_size:
    :   The `tree_size` of the tree on which to base the proof, in
        decimal.[¶](#section-5.4-2.2.1.4){.pilcrow}
    :   

    The `hash` must be calculated as defined in [Section
    4.7](#tree_leaves){.xref}. A v2 STH must exist for the `tree_size`.
    Because of skew, the front end may not know the requested tree head.
    In that case, it will return the latest STH it knows, along with an
    inclusion proof to that STH. If the front end knows the requested
    tree head, then only `inclusion` is
    returned.[¶](#section-5.4-2.2.2){.pilcrow}

:   

[]{.break}

Outputs:

:   []{.break}

    inclusion:
    :   A base64-encoded `TransItem` of type `inclusion_proof_v2` whose
        `inclusion_path` array of Merkle Tree nodes proves the inclusion
        of the certificate (as specified by the `hash` parameter) in the
        selected STH.[¶](#section-5.4-3.2.1.2){.pilcrow}
    :   

    sth:
    :   A base64-encoded `TransItem` of type `signed_tree_head_v2`,
        signed by this log.[¶](#section-5.4-3.2.1.4){.pilcrow}
    :   

    Note that no signature is required for the `inclusion` output, as it
    is used to verify inclusion in the selected STH, which is
    signed.[¶](#section-5.4-3.2.2){.pilcrow}

:   

Error codes:[¶](#section-5.4-4){.pilcrow}

  type              detail
  ----------------- ----------------------------------------------------------------------------------------------------------
  hashUnknown       `hash` is not the hash of a known leaf (may be caused by skew or by a known certificate not yet merged).
  treeSizeUnknown   `hash` is before the latest known STH but is not from an existing STH.

  : [Table 4](#table-4){.selfRef}

See [Section 2.1.3.2](#verify_inclusion){.xref} for an outline of how to
use the `inclusion` output.[¶](#section-5.4-6){.pilcrow}
:::
:::

::: {#get-all-by-hash}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [Retrieve Merkle Inclusion Proof, STH, and Consistency Proof by Leaf Hash](#name-retrieve-merkle-inclusion-pr){.section-name .selfRef} {#name-retrieve-merkle-inclusion-pr}

GET \<Base URL>/ct/v2/get-all-by-hash[¶](#section-5.5-1){.pilcrow}

[]{.break}

Inputs:

:   []{.break}

    hash:
    :   A base64-encoded v2 leaf
        hash.[¶](#section-5.5-2.2.1.2){.pilcrow}
    :   

    tree_size:
    :   The `tree_size` of the tree on which to base the proofs, in
        decimal.[¶](#section-5.5-2.2.1.4){.pilcrow}
    :   

    The `hash` must be calculated as defined in [Section
    4.7](#tree_leaves){.xref}. A v2 STH must exist for the
    `tree_size`.[¶](#section-5.5-2.2.2){.pilcrow}

:   

Because of skew, the front end may not know the requested tree head or
the requested hash, which leads to a number of
cases:[¶](#section-5.5-3){.pilcrow}

  Case                                    Response
  --------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------
  latest STH \< requested tree head       Return latest STH.
  latest STH \> requested tree head       Return latest STH and a consistency proof between it and the requested tree head (see [Section 5.3](#get-sth-consistency){.xref}).
  index of requested hash \< latest STH   Return `inclusion`.

  : [Table 5](#table-5){.selfRef}

Note that more than one case can be true; in which case, the returned
data is their union. It is also possible for none to be true; in which
case, the front end [MUST]{.bcp14} return an empty
response.[¶](#section-5.5-5){.pilcrow}

[]{.break}

Outputs:

:   []{.break}

    inclusion:
    :   A base64-encoded `TransItem` of type `inclusion_proof_v2` whose
        `inclusion_path` array of Merkle Tree nodes proves the inclusion
        of the certificate (as specified by the `hash` parameter) in the
        selected STH.[¶](#section-5.5-6.2.1.2){.pilcrow}
    :   

    sth:
    :   A base64-encoded `TransItem` of type `signed_tree_head_v2`,
        signed by this log.[¶](#section-5.5-6.2.1.4){.pilcrow}
    :   

    consistency:
    :   A base64-encoded `TransItem` of type `consistency_proof_v2` that
        proves the consistency of the requested tree head and the
        returned STH.[¶](#section-5.5-6.2.1.6){.pilcrow}
    :   

    Note that no signature is required for the `inclusion` or
    `consistency` outputs, as they are used to verify inclusion in and
    consistency of signed STHs.[¶](#section-5.5-6.2.2){.pilcrow}

:   

Errors are the same as in [Section
5.4](#get-proof-by-hash){.xref}.[¶](#section-5.5-7){.pilcrow}

See [Section 2.1.3.2](#verify_inclusion){.xref} for an outline of how to
use the `inclusion` output, and see [Section
2.1.4.2](#verify_consistency){.xref} for an outline of how to use the
`consistency` output.[¶](#section-5.5-8){.pilcrow}
:::
:::

::: {#get-entries}
::: {#section-5.6 .section}
### [5.6.](#section-5.6){.section-number .selfRef} [Retrieve Entries and STH from Log](#name-retrieve-entries-and-sth-fr){.section-name .selfRef} {#name-retrieve-entries-and-sth-fr}

GET \<Base URL>/ct/v2/get-entries[¶](#section-5.6-1){.pilcrow}

[]{.break}

Inputs:
:   []{.break}

    start:
    :   0-based index of first entry to retrieve, in
        decimal.[¶](#section-5.6-2.2.1.2){.pilcrow}
    :   

    end:
    :   0-based index of last entry to retrieve, in
        decimal.[¶](#section-5.6-2.2.1.4){.pilcrow}
    :   
:   

Outputs:
:   []{.break}

    entries:

    :   An array of objects, each consisting
        of:[¶](#section-5.6-2.4.1.2.1){.pilcrow}

        []{.break}

        log_entry:
        :   The base64-encoded `TransItem` structure of type
            `x509_entry_v2` or `precert_entry_v2` (see [Section
            4.3](#log_entries){.xref}).[¶](#section-5.6-2.4.1.2.2.2){.pilcrow}
        :   

        submitted_entry:
        :   JSON object equivalent to inputs that were submitted to
            `submit-entry`, with the addition of the trust anchor to the
            `chain` field if the submission did not include
            it.[¶](#section-5.6-2.4.1.2.2.4){.pilcrow}
        :   

        sct:
        :   The base64-encoded `TransItem` of type `x509_sct_v2` or
            `precert_sct_v2`, corresponding to this log
            entry.[¶](#section-5.6-2.4.1.2.2.6){.pilcrow}
        :   

        sth:
        :   A base64-encoded `TransItem` of type `signed_tree_head_v2`,
            signed by this log.[¶](#section-5.6-2.4.1.2.2.8){.pilcrow}
        :   

    :   
:   

Note that this message is not signed \-- the `entries` data can be
verified by constructing the Merkle Tree Hash corresponding to a
retrieved STH. All leaves [MUST]{.bcp14} be v2. However, a compliant v2
client [MUST NOT]{.bcp14} construe an unrecognized `TransItem` type as
an error. This means it may be unable to parse some entries, but note
that each client can inspect the entries it does recognize as well as
verify the integrity of the data by treating unrecognized leaves as
opaque input to the tree.[¶](#section-5.6-3){.pilcrow}

The `start` and `end` parameters [SHOULD]{.bcp14} be within the range 0
\<= x \< `tree_size`, as returned by `get-sth` in [Section
5.2](#get-sth){.xref}.[¶](#section-5.6-4){.pilcrow}

The `start` parameter [MUST]{.bcp14} be less than or equal to the `end`
parameter.[¶](#section-5.6-5){.pilcrow}

Each `submitted_entry` output parameter [MUST]{.bcp14} include the trust
anchor that the log used to verify the `submission`, even if that trust
anchor was not provided to `submit-entry` (see [Section
5.1](#submit-entry){.xref}). If the `submission` does not certify
itself, then the first element of `chain` [MUST]{.bcp14} be present and
[MUST]{.bcp14} certify the `submission`.[¶](#section-5.6-6){.pilcrow}

Log servers [MUST]{.bcp14} honor requests where 0 \<= `start` \<
`tree_size` and `end` \>= `tree_size` by returning a partial response
covering only the valid entries in the specified range. `end` \>=
`tree_size` could be caused by skew. Note that the following restriction
may also apply:[¶](#section-5.6-7){.pilcrow}

Logs [MAY]{.bcp14} restrict the number of entries that can be retrieved
per `get-entries` request. If a client requests more than the permitted
number of entries, the log [SHALL]{.bcp14} return the maximum number of
entries permissible. These entries [SHALL]{.bcp14} be sequential
beginning with the entry specified by `start`. Note that a limit on the
number of entries is not immutable, and therefore the restriction may be
changed or lifted at any time and is not listed with the other Log
Parameters in [Section
4.1](#log_parameters){.xref}.[¶](#section-5.6-8){.pilcrow}

Because of skew, it is possible the log server will not have any entries
between `start` and `end`. In this case, it [MUST]{.bcp14} return an
empty `entries` array.[¶](#section-5.6-9){.pilcrow}

In any case, the log server [MUST]{.bcp14} return the latest STH it
knows about.[¶](#section-5.6-10){.pilcrow}

See [Section 2.1.2](#verify_hash){.xref} for an outline of how to use a
complete list of `log_entry` entries to verify the
`root_hash`.[¶](#section-5.6-11){.pilcrow}

Error codes:[¶](#section-5.6-12){.pilcrow}

  type             detail
  ---------------- -------------------------------------------------------------------
  startUnknown     `start` is greater than the number of entries in the Merkle Tree.
  endBeforeStart   `start` cannot be greater than `end`.

  : [Table 6](#table-6){.selfRef}
:::
:::

::: {#get-anchors}
::: {#section-5.7 .section}
### [5.7.](#section-5.7){.section-number .selfRef} [Retrieve Accepted Trust Anchors](#name-retrieve-accepted-trust-anc){.section-name .selfRef} {#name-retrieve-accepted-trust-anc}

GET \<Base URL>/ct/v2/get-anchors[¶](#section-5.7-1){.pilcrow}

No inputs.[¶](#section-5.7-2){.pilcrow}

[]{.break}

Outputs:

:   []{.break}

    certificates:
    :   An array of JSON strings, each of which is a base64-encoded CA
        certificate that is acceptable to the
        log.[¶](#section-5.7-3.2.1.2){.pilcrow}
    :   

    max_chain_length:
    :   If the server has chosen to limit the length of chains it
        accepts, this is the maximum number of certificates in the
        chain, in decimal. If there is no limit, this is
        omitted.[¶](#section-5.7-3.2.1.4){.pilcrow}
    :   

    This data is not signed, and the protocol depends on the security
    guarantees of TLS to ensure
    correctness.[¶](#section-5.7-3.2.2){.pilcrow}

:   
:::
:::
:::
:::

::: {#tls_servers}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [TLS Servers](#name-tls-servers){.section-name .selfRef} {#name-tls-servers}

CT-using TLS servers [MUST]{.bcp14} use at least one of the mechanisms
described below to present one or more SCTs from one or more logs to
each TLS client during full TLS handshakes, when requested by the
client, where each SCT corresponds to the server certificate. (Of
course, a server can only send a TLS extension if the client has
specified it first.) Servers [SHOULD]{.bcp14} also present corresponding
inclusion proofs and STHs.[¶](#section-6-1){.pilcrow}

A server can provide SCTs using a TLS 1.3 extension ([Section
4.2](https://www.rfc-editor.org/rfc/rfc8446#section-4.2){.relref} of
\[[RFC8446](#RFC8446){.xref}\]) with type `transparency_info` (see
[Section 6.5](#tls_transinfo_extension){.xref}). This mechanism allows
TLS servers to participate in CT without the cooperation of CAs, unlike
the other two mechanisms. It also allows SCTs and inclusion proofs to be
updated on the fly.[¶](#section-6-2){.pilcrow}

The server may also use an Online Certificate Status Protocol (OCSP)
\[[RFC6960](#RFC6960){.xref}\] response extension (see [Section
7.1.1](#ocsp_transinfo_extension){.xref}), providing the OCSP response
as part of the TLS handshake. Providing a response during a TLS
handshake is popularly known as \"OCSP stapling\". For TLS 1.3, the
information is encoded as an extension in the `status_request` extension
data; see [Section
4.4.2.1](https://www.rfc-editor.org/rfc/rfc8446#section-4.4.2.1){.relref}
of \[[RFC8446](#RFC8446){.xref}\]. For TLS 1.2
\[[RFC5246](#RFC5246){.xref}\], the information is encoded in the
`CertificateStatus` message; see [Section
8](https://www.rfc-editor.org/rfc/rfc6066#section-8){.relref} of
\[[RFC6066](#RFC6066){.xref}\]. Using stapling also allows SCTs and
inclusion proofs to be updated on the fly.[¶](#section-6-3){.pilcrow}

CT information can also be encoded as an extension in the X.509v3
certificate (see [Section 7.1.2](#cert_transinfo_extension){.xref}).
This mechanism allows the use of unmodified TLS servers, but the SCTs
and inclusion proofs cannot be updated on the fly. Since the logs from
which the SCTs and inclusion proofs originated won\'t necessarily be
accepted by TLS clients for the full lifetime of the certificate, there
is a risk that TLS clients may subsequently consider the certificate to
be noncompliant. In such an event, one of the other two mechanisms will
need to be used to deliver CT information, or, if this is not possible,
the certificate will need to be reissued.[¶](#section-6-4){.pilcrow}

::: {#tls-client-authentication}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [TLS Client Authentication](#name-tls-client-authentication){.section-name .selfRef} {#name-tls-client-authentication}

This specification includes no description of how a TLS server can use
CT for TLS client certificates. While this may be useful, it is not
documented here for the following reasons:[¶](#section-6.1-1){.pilcrow}

-   [The greater security exposure is for clients to end up interacting
    with an illegitimate
    server.[¶](#section-6.1-2.1){.pilcrow}]{#section-6.1-2.1}
-   [In general, TLS client certificates are not expected to be
    submitted to CT logs, particularly those intended for general public
    use.[¶](#section-6.1-2.2){.pilcrow}]{#section-6.1-2.2}

A future version could include such
information.[¶](#section-6.1-3){.pilcrow}
:::
:::

::: {#multiple-scts}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Multiple SCTs](#name-multiple-scts){.section-name .selfRef} {#name-multiple-scts}

CT-using TLS servers [SHOULD]{.bcp14} send SCTs from multiple logs
because:[¶](#section-6.2-1){.pilcrow}

-   [The set of logs trusted by TLS clients is neither unified nor
    static; each client vendor may maintain an independent list of
    trusted logs, and, over time, new logs may become trusted and
    current logs may become distrusted. Note that client discovery,
    trust, and distrust of logs are expected to be handled out of band
    and are out of scope of this
    document.[¶](#section-6.2-2.1){.pilcrow}]{#section-6.2-2.1}
-   [If a CA and a log collude, it is possible to temporarily hide
    misissuance from clients. When a TLS client requires SCTs from
    multiple logs to be provided, it is more difficult to mount this
    attack.[¶](#section-6.2-2.2){.pilcrow}]{#section-6.2-2.2}
-   [If a log misbehaves or suffers a key compromise, a consequence may
    be that clients cease to trust it. Since the time an SCT may be in
    use can be considerable (several years is common in current practice
    when embedded in a certificate), including SCTs from multiple logs
    reduces the probability of the certificate being rejected by TLS
    clients.[¶](#section-6.2-2.3){.pilcrow}]{#section-6.2-2.3}
-   [TLS clients may have policies related to the above risks requiring
    TLS servers to present multiple SCTs. For example, at the time of
    writing, Chromium
    \[[Chromium.Log.Policy](#Chromium.Log.Policy){.xref}\] requires
    multiple SCTs to be presented with Extended Validation (EV)
    certificates in order for the EV indicator to be
    shown.[¶](#section-6.2-2.4){.pilcrow}]{#section-6.2-2.4}

To select the logs from which to obtain SCTs, a TLS server can, for
example, examine the set of logs popular TLS clients accept and
recognize.[¶](#section-6.2-3){.pilcrow}
:::
:::

::: {#transitemlist-structure}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [TransItemList Structure](#name-transitemlist-structure){.section-name .selfRef} {#name-transitemlist-structure}

Multiple SCTs, inclusion proofs, and indeed `TransItem` structures of
any type are combined into a list as
follows:[¶](#section-6.3-1){.pilcrow}

::: {#section-6.3-2}
``` {.lang-tls-presentation .sourcecode}
      opaque SerializedTransItem<1..2^16-1>;

      struct {
          SerializedTransItem trans_item_list<1..2^16-1>;
      } TransItemList;
```

[¶](#section-6.3-2){.pilcrow}
:::

Here, `SerializedTransItem` is an opaque byte string that contains the
serialized `TransItem` structure. This encoding ensures that TLS clients
can decode each `TransItem` individually (so, for example, if there is a
version upgrade, out-of-date clients can still parse old `TransItem`
structures while skipping over new `TransItem` structures whose versions
they don\'t understand).[¶](#section-6.3-3){.pilcrow}
:::
:::

::: {#presenting_transitems}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [Presenting SCTs, Inclusions Proofs, and STHs](#name-presenting-scts-inclusions-){.section-name .selfRef} {#name-presenting-scts-inclusions-}

In each `TransItemList` that is sent during a TLS handshake, the TLS
server [MUST]{.bcp14} include a `TransItem` structure of type
`x509_sct_v2` or `precert_sct_v2`.[¶](#section-6.4-1){.pilcrow}

Presenting inclusion proofs and STHs in the TLS handshake helps to
protect the client\'s privacy (see [Section
8.1.4](#fetching_inclusion_proofs){.xref}) and reduces load on log
servers. Therefore, if the TLS server can obtain them, it
[SHOULD]{.bcp14} also include `TransItem`s of type `inclusion_proof_v2`
and `signed_tree_head_v2` in the
`TransItemList`.[¶](#section-6.4-2){.pilcrow}
:::
:::

::: {#tls_transinfo_extension}
::: {#section-6.5 .section}
### [6.5.](#section-6.5){.section-number .selfRef} [transparency_info TLS Extension](#name-transparency_info-tls-exten){.section-name .selfRef} {#name-transparency_info-tls-exten}

Provided that a TLS client includes the `transparency_info` extension
type in the ClientHello and the TLS server supports the
`transparency_info` extension:[¶](#section-6.5-1){.pilcrow}

-   [The TLS server [MUST]{.bcp14} verify that the received
    `extension_data` is
    empty.[¶](#section-6.5-2.1){.pilcrow}]{#section-6.5-2.1}
-   [The TLS server [MUST]{.bcp14} construct a `TransItemList` of
    relevant `TransItem`s (see [Section
    6.4](#presenting_transitems){.xref}), which [SHOULD]{.bcp14} omit
    any `TransItem`s that are already embedded in the server certificate
    or the stapled OCSP response (see [Section
    7.1](#x509v3_transinfo_extension){.xref}). If the constructed
    `TransItemList` is not empty, then the TLS server [MUST]{.bcp14}
    include the `transparency_info` extension with the `extension_data`
    set to this `TransItemList`. If the list is empty, then the server
    [SHOULD]{.bcp14} omit the `extension_data` element but [MAY]{.bcp14}
    send it with an empty
    array.[¶](#section-6.5-2.2){.pilcrow}]{#section-6.5-2.2}

TLS servers [MUST]{.bcp14} only include this extension in the following
messages:[¶](#section-6.5-3){.pilcrow}

-   [the ServerHello message (for TLS 1.2 or
    earlier)[¶](#section-6.5-4.1){.pilcrow}]{#section-6.5-4.1}
-   [the Certificate or CertificateRequest message (for TLS
    1.3)[¶](#section-6.5-4.2){.pilcrow}]{#section-6.5-4.2}

TLS servers [MUST NOT]{.bcp14} process or include this extension when a
TLS session is resumed, since session resumption uses the original
session information.[¶](#section-6.5-5){.pilcrow}
:::
:::
:::
:::

::: {#certification-authorities}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Certification Authorities](#name-certification-authorities){.section-name .selfRef} {#name-certification-authorities}

::: {#x509v3_transinfo_extension}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Transparency Information X.509v3 Extension](#name-transparency-information-x5){.section-name .selfRef} {#name-transparency-information-x5}

The Transparency Information X.509v3 extension, which has OID 1.3.101.75
and [SHOULD]{.bcp14} be noncritical, contains one or more `TransItem`
structures in a `TransItemList`. This extension [MAY]{.bcp14} be
included in OCSP responses (see [Section
7.1.1](#ocsp_transinfo_extension){.xref}) and certificates (see [Section
7.1.2](#cert_transinfo_extension){.xref}). Since
\[[RFC5280](#RFC5280){.xref}\] requires the `extnValue` field (an OCTET
STRING) of each X.509v3 extension to include the DER encoding of an
ASN.1 value, a `TransItemList` [MUST NOT]{.bcp14} be included directly.
Instead, it [MUST]{.bcp14} be wrapped inside an additional OCTET STRING,
which is then put into the `extnValue`
field:[¶](#section-7.1-1){.pilcrow}

::: {#section-7.1-2}
``` {.lang-asn.1 .sourcecode}
    TransparencyInformationSyntax ::= OCTET STRING
```

[¶](#section-7.1-2){.pilcrow}
:::

`TransparencyInformationSyntax` contains a
`TransItemList`.[¶](#section-7.1-3){.pilcrow}

::: {#ocsp_transinfo_extension}
::: {#section-7.1.1 .section}
#### [7.1.1.](#section-7.1.1){.section-number .selfRef} [OCSP Response Extension](#name-ocsp-response-extension){.section-name .selfRef} {#name-ocsp-response-extension}

A certification authority [MAY]{.bcp14} include a Transparency
Information X.509v3 extension in the `singleExtensions` of a
`SingleResponse` in an OCSP response. All included SCTs and inclusion
proofs [MUST]{.bcp14} be for the certificate identified by the `certID`
of that `SingleResponse` or for a precertificate that corresponds to
that certificate.[¶](#section-7.1.1-1){.pilcrow}
:::
:::

::: {#cert_transinfo_extension}
::: {#section-7.1.2 .section}
#### [7.1.2.](#section-7.1.2){.section-number .selfRef} [Certificate Extension](#name-certificate-extension){.section-name .selfRef} {#name-certificate-extension}

A certification authority [MAY]{.bcp14} include a Transparency
Information X.509v3 extension in a certificate. All included SCTs and
inclusion proofs [MUST]{.bcp14} be for a precertificate that corresponds
to this certificate.[¶](#section-7.1.2-1){.pilcrow}
:::
:::
:::
:::

::: {#tls-feature-x509v3-extension}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [TLS Feature X.509v3 Extension](#name-tls-feature-x509v3-extensio){.section-name .selfRef} {#name-tls-feature-x509v3-extensio}

A certification authority [SHOULD NOT]{.bcp14} issue any certificate
that identifies the `transparency_info` TLS extension in a TLS feature
extension \[[RFC7633](#RFC7633){.xref}\], because TLS servers are not
required to support the `transparency_info` TLS extension in order to
participate in CT (see [Section
6](#tls_servers){.xref}).[¶](#section-7.2-1){.pilcrow}
:::
:::
:::
:::

::: {#clients}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Clients](#name-clients){.section-name .selfRef} {#name-clients}

There are various different functions clients of logs might perform. We
describe here some typical clients and how they should function. Any
inconsistency may be used as evidence that a log has not behaved
correctly, and the signatures on the data structures prevent the log
from denying that misbehavior.[¶](#section-8-1){.pilcrow}

All clients need various parameters in order to communicate with logs
and verify their responses. These parameters are described in [Section
4.1](#log_parameters){.xref}, but note that this document does not
describe how the parameters are obtained, which is implementation
dependent (for example, see
\[[Chromium.Policy](#Chromium.Policy){.xref}\]).[¶](#section-8-2){.pilcrow}

::: {#tls_clients}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [TLS Client](#name-tls-client){.section-name .selfRef} {#name-tls-client}

::: {#receiving_transitems}
::: {#section-8.1.1 .section}
#### [8.1.1.](#section-8.1.1){.section-number .selfRef} [Receiving SCTs and Inclusion Proofs](#name-receiving-scts-and-inclusio){.section-name .selfRef} {#name-receiving-scts-and-inclusio}

TLS clients receive SCTs and inclusion proofs alongside or in
certificates. CT-using TLS clients [MUST]{.bcp14} implement all of the
three mechanisms by which TLS servers may present SCTs (see [Section
6](#tls_servers){.xref}).[¶](#section-8.1.1-1){.pilcrow}

TLS clients that support the `transparency_info` TLS extension (see
[Section 6.5](#tls_transinfo_extension){.xref}) [SHOULD]{.bcp14} include
it in ClientHello messages, with empty `extension_data`. If a TLS server
includes the `transparency_info` TLS extension when resuming a TLS
session, the TLS client [MUST]{.bcp14} abort the
handshake.[¶](#section-8.1.1-2){.pilcrow}
:::
:::

::: {#reconstructing_tbscertificate}
::: {#section-8.1.2 .section}
#### [8.1.2.](#section-8.1.2){.section-number .selfRef} [Reconstructing the TBSCertificate](#name-reconstructing-the-tbscerti){.section-name .selfRef} {#name-reconstructing-the-tbscerti}

Validation of an SCT for a certificate (where the `type` of the
`TransItem` is `x509_sct_v2`) uses the unmodified TBSCertificate
component of the certificate.[¶](#section-8.1.2-1){.pilcrow}

Before an SCT for a precertificate (where the `type` of the `TransItem`
is `precert_sct_v2`) can be validated, the TBSCertificate component of
the precertificate needs to be reconstructed from the TBSCertificate
component of the certificate as follows:[¶](#section-8.1.2-2){.pilcrow}

-   [Remove the Transparency Information extension (see [Section
    7.1](#x509v3_transinfo_extension){.xref}).[¶](#section-8.1.2-3.1){.pilcrow}]{#section-8.1.2-3.1}
-   [Remove embedded v1 SCTs, identified by OID 1.3.6.1.4.1.11129.2.4.2
    (see [Section
    3.3](https://www.rfc-editor.org/rfc/rfc6962#section-3.3){.relref} of
    \[[RFC6962](#RFC6962){.xref}\]). This allows embedded v1 and v2 SCTs
    to co-exist in a certificate (see [Appendix
    A](#v1_coexistence){.xref}).[¶](#section-8.1.2-3.2){.pilcrow}]{#section-8.1.2-3.2}
:::
:::

::: {#validating-scts}
::: {#section-8.1.3 .section}
#### [8.1.3.](#section-8.1.3){.section-number .selfRef} [Validating SCTs](#name-validating-scts){.section-name .selfRef} {#name-validating-scts}

In order to make use of a received SCT, the TLS client [MUST]{.bcp14}
first validate it as follows:[¶](#section-8.1.3-1){.pilcrow}

-   ::: {#section-8.1.3-2.1}
    Compute the signature input by constructing a `TransItem` of type
    `x509_entry_v2` or `precert_entry_v2`, depending on the SCT\'s
    `TransItem` type. The `TimestampedCertificateEntryDataV2` structure
    is constructed in the following
    manner:[¶](#section-8.1.3-2.1.1){.pilcrow}

    -   [`timestamp` is copied from the
        SCT.[¶](#section-8.1.3-2.1.2.1){.pilcrow}]{#section-8.1.3-2.1.2.1}
    -   [`tbs_certificate` is the reconstructed TBSCertificate portion
        of the server certificate, as described in [Section
        8.1.2](#reconstructing_tbscertificate){.xref}.[¶](#section-8.1.3-2.1.2.2){.pilcrow}]{#section-8.1.3-2.1.2.2}
    -   [`issuer_key_hash` is computed as described in [Section
        4.7](#tree_leaves){.xref}.[¶](#section-8.1.3-2.1.2.3){.pilcrow}]{#section-8.1.3-2.1.2.3}
    -   [`sct_extensions` is copied from the
        SCT.[¶](#section-8.1.3-2.1.2.4){.pilcrow}]{#section-8.1.3-2.1.2.4}
    :::

-   [Verify the SCT\'s `signature` against the computed signature input
    using the public key of the corresponding log, which is identified
    by the `log_id`. The required signature algorithm is one of the
    log\'s
    parameters.[¶](#section-8.1.3-2.2){.pilcrow}]{#section-8.1.3-2.2}

If the TLS client does not have the corresponding log\'s parameters, it
cannot attempt to validate the SCT. When evaluating compliance (see
[Section 8.1.6](#evaluating_compliance){.xref}), the TLS client will
consider only those SCTs that it was able to
validate.[¶](#section-8.1.3-3){.pilcrow}

Note that SCT validation is not a substitute for the normal validation
of the server certificate and its chain.[¶](#section-8.1.3-4){.pilcrow}
:::
:::

::: {#fetching_inclusion_proofs}
::: {#section-8.1.4 .section}
#### [8.1.4.](#section-8.1.4){.section-number .selfRef} [Fetching Inclusion Proofs](#name-fetching-inclusion-proofs){.section-name .selfRef} {#name-fetching-inclusion-proofs}

When a TLS client has validated a received SCT but does not yet possess
a corresponding inclusion proof, the TLS client [MAY]{.bcp14} request
the inclusion proof directly from a log using `get-proof-by-hash`
([Section 5.4](#get-proof-by-hash){.xref}) or `get-all-by-hash`
([Section 5.5](#get-all-by-hash){.xref}).[¶](#section-8.1.4-1){.pilcrow}

Note that fetching inclusion proofs directly from a log will disclose to
the log which TLS server the client has been communicating with. This
may be regarded as a significant privacy concern, and so it is
preferable for the TLS server to send the inclusion proofs (see [Section
6.4](#presenting_transitems){.xref}).[¶](#section-8.1.4-2){.pilcrow}
:::
:::

::: {#validating_inclusion_proofs}
::: {#section-8.1.5 .section}
#### [8.1.5.](#section-8.1.5){.section-number .selfRef} [Validating Inclusion Proofs](#name-validating-inclusion-proofs){.section-name .selfRef} {#name-validating-inclusion-proofs}

When a TLS client has received, or fetched, an inclusion proof (and an
STH), it [SHOULD]{.bcp14} proceed to verify the inclusion proof to the
provided STH. The TLS client [SHOULD]{.bcp14} also verify consistency
between the provided STH and an STH it knows
about.[¶](#section-8.1.5-1){.pilcrow}

If the TLS client holds an STH that predates the SCT, it [MAY]{.bcp14},
in the process of auditing, request a new STH from the log ([Section
5.2](#get-sth){.xref}) and then verify it by requesting a consistency
proof ([Section 5.3](#get-sth-consistency){.xref}). Note that if the TLS
client uses `get-all-by-hash`, then it will already have the new
STH.[¶](#section-8.1.5-2){.pilcrow}
:::
:::

::: {#evaluating_compliance}
::: {#section-8.1.6 .section}
#### [8.1.6.](#section-8.1.6){.section-number .selfRef} [Evaluating Compliance](#name-evaluating-compliance){.section-name .selfRef} {#name-evaluating-compliance}

It is up to a client\'s local policy to specify the quantity and form of
evidence (SCTs, inclusion proofs, or a combination) needed to achieve
compliance and how to handle
noncompliance.[¶](#section-8.1.6-1){.pilcrow}

A TLS client can only evaluate compliance if it has given the TLS server
the opportunity to send SCTs and inclusion proofs by any of the three
mechanisms that are mandatory to implement for CT-using TLS clients (see
[Section 8.1.1](#receiving_transitems){.xref}). Therefore, a TLS client
[MUST NOT]{.bcp14} evaluate compliance if it did not include both the
`transparency_info` and `status_request` TLS extensions in the
ClientHello.[¶](#section-8.1.6-2){.pilcrow}
:::
:::
:::
:::

::: {#monitor}
::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Monitor](#name-monitor){.section-name .selfRef} {#name-monitor}

Monitors watch logs to check for correct behavior, for certificates of
interest, or for both. For example, a monitor may be configured to
report on all certificates that apply to a specific domain name when
fetching new entries for consistency
validation.[¶](#section-8.2-1){.pilcrow}

A monitor [MUST]{.bcp14} at least inspect every new entry in every log
it watches, and it [MAY]{.bcp14} also choose to keep copies of entire
logs.[¶](#section-8.2-2){.pilcrow}

To inspect all of the existing entries, the monitor [SHOULD]{.bcp14}
follow these steps once for each log:[¶](#section-8.2-3){.pilcrow}

1.  [Fetch the current STH ([Section
    5.2](#get-sth){.xref}).[¶](#section-8.2-4.1){.pilcrow}]{#section-8.2-4.1}
2.  [Verify the STH
    signature.[¶](#section-8.2-4.2){.pilcrow}]{#section-8.2-4.2}
3.  [Fetch all the entries in the tree corresponding to the STH
    ([Section
    5.6](#get-entries){.xref}).[¶](#section-8.2-4.3){.pilcrow}]{#section-8.2-4.3}
4.  [If applicable, check each entry to see if it\'s a certificate of
    interest.[¶](#section-8.2-4.4){.pilcrow}]{#section-8.2-4.4}
5.  [Confirm that the tree made from the fetched entries produces the
    same hash as that in the
    STH.[¶](#section-8.2-4.5){.pilcrow}]{#section-8.2-4.5}

To inspect new entries, the monitor [SHOULD]{.bcp14} follow these steps
repeatedly for each log:[¶](#section-8.2-5){.pilcrow}

1.  [Fetch the current STH ([Section 5.2](#get-sth){.xref}). Repeat
    until the STH changes. To allow for experimentation, this document
    does not specify the polling
    frequency.[¶](#section-8.2-6.1){.pilcrow}]{#section-8.2-6.1}

2.  [Verify the STH
    signature.[¶](#section-8.2-6.2){.pilcrow}]{#section-8.2-6.2}

3.  [Fetch all the new entries in the tree corresponding to the STH
    ([Section 5.6](#get-entries){.xref}). If they remain unavailable for
    an extended period, then this should be viewed as misbehavior on the
    part of the log.[¶](#section-8.2-6.3){.pilcrow}]{#section-8.2-6.3}

4.  [If applicable, check each entry to see if it\'s a certificate of
    interest.[¶](#section-8.2-6.4){.pilcrow}]{#section-8.2-6.4}

5.  ::: {#section-8.2-6.5}
    Either:[¶](#section-8.2-6.5.1){.pilcrow}

    a.  [Verify that the updated list of all entries generates a tree
        with the same hash as the new
        STH.[¶](#section-8.2-6.5.2.1){.pilcrow}]{#section-8.2-6.5.2.1}

    Or, if it is not keeping all log
    entries:[¶](#section-8.2-6.5.3){.pilcrow}

    a.  [Fetch a consistency proof for the new STH with the previous STH
        ([Section
        5.3](#get-sth-consistency){.xref}).[¶](#section-8.2-6.5.4.1){.pilcrow}]{#section-8.2-6.5.4.1}
    b.  [Verify the consistency
        proof.[¶](#section-8.2-6.5.4.2){.pilcrow}]{#section-8.2-6.5.4.2}
    c.  [Verify that the new entries generate the corresponding elements
        in the consistency
        proof.[¶](#section-8.2-6.5.4.3){.pilcrow}]{#section-8.2-6.5.4.3}
    :::

6.  [Repeat from Step
    1.[¶](#section-8.2-6.6){.pilcrow}]{#section-8.2-6.6}
:::
:::

::: {#auditing}
::: {#section-8.3 .section}
### [8.3.](#section-8.3){.section-number .selfRef} [Auditing](#name-auditing){.section-name .selfRef} {#name-auditing}

Auditing ensures that the current published state of a log is reachable
from previously published states that are known to be good and that the
promises made by the log, in the form of SCTs, have been kept. Audits
are performed by monitors or TLS clients.[¶](#section-8.3-1){.pilcrow}

In particular, there are four properties of log behavior that should be
checked:[¶](#section-8.3-2){.pilcrow}

-   [the Maximum Merge Delay
    (MMD)[¶](#section-8.3-3.1){.pilcrow}]{#section-8.3-3.1}
-   [the STH Frequency
    Count[¶](#section-8.3-3.2){.pilcrow}]{#section-8.3-3.2}
-   [the append-only
    property[¶](#section-8.3-3.3){.pilcrow}]{#section-8.3-3.3}
-   [the consistency of the log view presented to all query
    sources[¶](#section-8.3-3.4){.pilcrow}]{#section-8.3-3.4}

A benign, conformant log publishes a series of STHs over time, each
derived from the previous STH and the submitted entries incorporated
into the log since publication of the previous STH. This can be proven
through auditing of STHs. SCTs returned to TLS clients can be audited by
verifying against the accompanying certificate and using Merkle
inclusion proofs against the log\'s Merkle
Tree.[¶](#section-8.3-4){.pilcrow}

The action taken by the auditor, if an audit fails, is not specified,
but note that in general, if an audit fails, the auditor is in
possession of signed proof of the log\'s
misbehavior.[¶](#section-8.3-5){.pilcrow}

A monitor ([Section 8.2](#monitor){.xref}) can audit by verifying the
consistency of STHs it receives, ensuring that each entry can be fetched
and that the STH is indeed the result of making a tree from all fetched
entries.[¶](#section-8.3-6){.pilcrow}

A TLS client ([Section 8.1](#tls_clients){.xref}) can audit by verifying
an SCT against any STH dated after the SCT timestamp + the Maximum Merge
Delay by requesting a Merkle inclusion proof ([Section
5.4](#get-proof-by-hash){.xref}). It can also verify that the SCT
corresponds to the server certificate it arrived with (i.e., the log
entry is that certificate or is a precertificate corresponding to that
certificate).[¶](#section-8.3-7){.pilcrow}

Checking of the consistency of the log view presented to all entities is
more difficult to perform because it requires a way to share log
responses among a set of CT-using entities and is discussed in [Section
11.3](#misbehaving_logs){.xref}.[¶](#section-8.3-8){.pilcrow}
:::
:::
:::
:::

::: {#algorithm-agility}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Algorithm Agility](#name-algorithm-agility){.section-name .selfRef} {#name-algorithm-agility}

It is not possible for a log to change either of its algorithms part way
through its lifetime:[¶](#section-9-1){.pilcrow}

[]{.break}

Signature algorithm:
:   SCT signatures must remain valid so signature algorithms can only be
    added, not removed.[¶](#section-9-2.2){.pilcrow}
:   

Hash algorithm:
:   A log would have to support the old and new hash algorithms to allow
    backwards compatibility with clients that are not aware of a hash
    algorithm change.[¶](#section-9-2.4){.pilcrow}
:   

Allowing multiple signature or hash algorithms for a log would require
that all data structures support it and would significantly complicate
client implementation, which is why it is not supported by this
document.[¶](#section-9-3){.pilcrow}

If it should become necessary to deprecate an algorithm used by a live
log, then the log [MUST]{.bcp14} be frozen, as specified in [Section
4.13](#log_shutdown){.xref}, and a new log [SHOULD]{.bcp14} be started.
Certificates in the frozen log that have not yet expired and require new
SCTs [SHOULD]{.bcp14} be submitted to the new log and the SCTs from that
log used instead.[¶](#section-9-4){.pilcrow}
:::
:::

::: {#iana-considerations}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

The assignment policy criteria mentioned in this section refer to the
policies outlined in
\[[RFC8126](#RFC8126){.xref}\].[¶](#section-10-1){.pilcrow}

::: {#additions-to-existing-registries}
::: {#section-10.1 .section}
### [10.1.](#section-10.1){.section-number .selfRef} [Additions to Existing Registries](#name-additions-to-existing-regis){.section-name .selfRef} {#name-additions-to-existing-regis}

This subsection defines additions to existing
registries.[¶](#section-10.1-1){.pilcrow}

::: {#new-entry-to-the-tls-extensiontype-registry}
::: {#section-10.1.1 .section}
#### [10.1.1.](#section-10.1.1){.section-number .selfRef} [New Entry to the TLS ExtensionType Registry](#name-new-entry-to-the-tls-extens){.section-name .selfRef} {#name-new-entry-to-the-tls-extens}

IANA has added the following entry to the \"TLS ExtensionType Values\"
registry defined in \[[RFC8446](#RFC8446){.xref}\], with an assigned
Value:[¶](#section-10.1.1-1){.pilcrow}

  Value   Extension Name      TLS 1.3      DTLS-Only   Recommended   Reference
  ------- ------------------- ------------ ----------- ------------- -----------
  52      transparency_info   CH, CR, CT   N           Y             RFC 9162

  : [Table 7](#table-7){.selfRef}
:::
:::

::: {#urn-sub-namespace-for-trans-urnietfparamstrans}
::: {#section-10.1.2 .section}
#### [10.1.2.](#section-10.1.2){.section-number .selfRef} [URN Sub-namespace for TRANS (urn:ietf:params:trans)](#name-urn-sub-namespace-for-trans){.section-name .selfRef} {#name-urn-sub-namespace-for-trans}

IANA has added a new entry in the \"IETF URN Sub-namespace for
Registered Protocol Parameter Identifiers\" registry, following the
template in
\[[RFC3553](#RFC3553){.xref}\]:[¶](#section-10.1.2-1){.pilcrow}

[]{.break}

Registry name:
:   trans[¶](#section-10.1.2-2.2){.pilcrow}
:   

Specification:
:   RFC 9162[¶](#section-10.1.2-2.4){.pilcrow}
:   

Repository:
:   \<<https://www.iana.org/assignments/trans>\>[¶](#section-10.1.2-2.6){.pilcrow}
:   

Index value:
:   No transformation needed.[¶](#section-10.1.2-2.8){.pilcrow}
:   
:::
:::
:::
:::

::: {#new-ct-related-registries}
::: {#section-10.2 .section}
### [10.2.](#section-10.2){.section-number .selfRef} [New CT-Related Registries](#name-new-ct-related-registries){.section-name .selfRef} {#name-new-ct-related-registries}

IANA has added a new protocol registry, \"Public Notary Transparency\",
to the list that appears at
\<<https://www.iana.org/assignments/>\>[¶](#section-10.2-1){.pilcrow}

The rest of this section defines the subregistries that have been
created within the new \"Public Notary Transparency\"
registry.[¶](#section-10.2-2){.pilcrow}

::: {#hash_algorithms}
::: {#section-10.2.1 .section}
#### [10.2.1.](#section-10.2.1){.section-number .selfRef} [Hash Algorithms](#name-hash-algorithms){.section-name .selfRef} {#name-hash-algorithms}

IANA has established a registry of hash algorithm values, named \"Hash
Algorithms\", with the following registration
procedures:[¶](#section-10.2.1-1){.pilcrow}

  Range       Registration Procedures
  ----------- -------------------------
  0x00-0xDF   Specification Required
  0xE0-0xEF   Experimental Use
  0xF0-0xFF   Private Use

  : [Table 8](#table-8){.selfRef}

The \"Hash Algorithms\" registry initially consists
of:[¶](#section-10.2.1-3){.pilcrow}

  Value         Hash Algorithm                  OID                      Reference
  ------------- ------------------------------- ------------------------ --------------------------------
  0x00          SHA-256                         2.16.840.1.101.3.4.2.1   \[[RFC6234](#RFC6234){.xref}\]
  0x01 - 0xDF   Unassigned                                               RFC 9162
  0xE0 - 0xEF   Reserved for Experimental Use                            RFC 9162
  0xF0 - 0xFF   Reserved for Private Use                                 RFC 9162

  : [Table 9](#table-9){.selfRef}

The designated expert(s) should ensure that the proposed algorithm has a
public specification and is suitable for use as a cryptographic hash
algorithm with no known preimage or collision attacks. These attacks can
damage the integrity of the log.[¶](#section-10.2.1-5){.pilcrow}
:::
:::

::: {#signature_algorithms}
::: {#section-10.2.2 .section}
#### [10.2.2.](#section-10.2.2){.section-number .selfRef} [Signature Algorithms](#name-signature-algorithms){.section-name .selfRef} {#name-signature-algorithms}

IANA has established a registry of signature algorithm values, named
\"Signature Algorithms\".[¶](#section-10.2.2-1){.pilcrow}

The following notes have been added to the
registry:[¶](#section-10.2.2-2){.pilcrow}

> []{.break}
>
> **Note:**
> :   This is a subset of the \"TLS SignatureScheme\" registry, limited
>     to those algorithms that are appropriate for CT. A major advantage
>     of this is leveraging the expertise of the TLS Working Group and
>     its designated expert(s).[¶](#section-10.2.2-3.1.2){.pilcrow}
> :   

> []{.break}
>
> **Note:**
> :   The value `0x0403` appears twice. While this may be confusing, it
>     is okay because the verification process is the same for both
>     algorithms, and the choice of which to use when generating a
>     signature is purely internal to the log
>     server.[¶](#section-10.2.2-4.1.2){.pilcrow}
> :   

The \"Signature Algorithms\" registry has the following registration
procedures:[¶](#section-10.2.2-5){.pilcrow}

  Range           Registration Procedures
  --------------- -------------------------
  0x0000-0x0807   Specification Required
  0x0808-0xFDFF   Expert Review
  0xFE00-0xFEFF   Experimental Use
  0xFF00-0xFFFF   Private Use

  : [Table 10](#table-10){.selfRef}

The \"Signature Algorithms\" registry initially consists
of:[¶](#section-10.2.2-7){.pilcrow}

  SignatureScheme Value             Signature Algorithm                                 Reference
  --------------------------------- --------------------------------------------------- ------------------------------------
  0x0000 - 0x0402                   Unassigned                                           
  ecdsa_secp256r1_sha256 (0x0403)   ECDSA (NIST P-256) with SHA-256                     \[[FIPS186-4](#FIPS186-4){.xref}\]
  ecdsa_secp256r1_sha256 (0x0403)   Deterministic ECDSA (NIST P-256) with HMAC-SHA256   \[[RFC6979](#RFC6979){.xref}\]
  0x0404 - 0x0806                   Unassigned                                           
  ed25519 (0x0807)                  Ed25519 (PureEdDSA with the edwards25519 curve)     \[[RFC8032](#RFC8032){.xref}\]
  0x0808 - 0xFDFF                   Unassigned                                           
  0xFE00 - 0xFEFF                   Reserved for Experimental Use                       RFC 9162
  0xFF00 - 0xFFFF                   Reserved for Private Use                            RFC 9162

  : [Table 11](#table-11){.selfRef}

The designated expert(s) should ensure that the proposed algorithm has a
public specification, has a value assigned to it in the \"TLS
SignatureScheme\" registry (which was established by
\[[RFC8446](#RFC8446){.xref}\]), and is suitable for use as a
cryptographic signature algorithm.[¶](#section-10.2.2-9){.pilcrow}
:::
:::

::: {#versioned_trans_types}
::: {#section-10.2.3 .section}
#### [10.2.3.](#section-10.2.3){.section-number .selfRef} [VersionedTransTypes](#name-versionedtranstypes){.section-name .selfRef} {#name-versionedtranstypes}

IANA has established a registry of `VersionedTransType` values, named
\"VersionedTransTypes\".[¶](#section-10.2.3-1){.pilcrow}

The following note has been added:[¶](#section-10.2.3-2){.pilcrow}

> []{.break}
>
> **Note:**
> :   The range 0x0000..0x00FF is reserved so that v1 SCTs are
>     distinguishable from v2 SCTs and other `TransItem`
>     structures.[¶](#section-10.2.3-3.1.2){.pilcrow}
> :   

The registration procedures for the \"VersionedTransTypes\" registry are
the following:[¶](#section-10.2.3-4){.pilcrow}

  Range           Registration Procedures
  --------------- -------------------------
  0x0100-0xDFFF   Specification Required
  0xE000-0xEFFF   Experimental Use
  0xF000-0xFFFF   Private Use

  : [Table 12](#table-12){.selfRef}

The \"VersionedTransTypes\" registry initially consists
of:[¶](#section-10.2.3-6){.pilcrow}

  Value             Type and Version                Reference
  ----------------- ------------------------------- --------------------------------
  0x0000 - 0x00FF   Reserved                        \[[RFC6962](#RFC6962){.xref}\]
  0x0100            x509_entry_v2                   RFC 9162
  0x0101            precert_entry_v2                RFC 9162
  0x0102            x509_sct_v2                     RFC 9162
  0x0103            precert_sct_v2                  RFC 9162
  0x0104            signed_tree_head_v2             RFC 9162
  0x0105            consistency_proof_v2            RFC 9162
  0x0106            inclusion_proof_v2              RFC 9162
  0x0107 - 0xDFFF   Unassigned                       
  0xE000 - 0xEFFF   Reserved for Experimental Use   RFC 9162
  0xF000 - 0xFFFF   Reserved for Private Use        RFC 9162

  : [Table 13](#table-13){.selfRef}

The designated expert(s) should review the public specification to
ensure that it is detailed enough to ensure implementation
interoperability.[¶](#section-10.2.3-8){.pilcrow}
:::
:::

::: {#log_artifact_extension_registry}
::: {#section-10.2.4 .section}
#### [10.2.4.](#section-10.2.4){.section-number .selfRef} [Log Artifact Extensions](#name-log-artifact-extensions-2){.section-name .selfRef} {#name-log-artifact-extensions-2}

IANA has established a registry of `ExtensionType` values, named \"Log
Artifact Extensions\".[¶](#section-10.2.4-1){.pilcrow}

The registration procedures for the \"Log Artifact Extensions\" registry
are the following:[¶](#section-10.2.4-2){.pilcrow}

  Range           Registration Procedures
  --------------- -------------------------
  0x0000-0xDFFF   Specification Required
  0xE000-0xEFFF   Experimental Use
  0xF000-0xFFFF   Private Use

  : [Table 14](#table-14){.selfRef}

The \"Log Artifact Extensions\" registry initially consists
of:[¶](#section-10.2.4-4){.pilcrow}

  ExtensionType     Status                          Use   Reference
  ----------------- ------------------------------- ----- -----------
  0x0000 - 0xDFFF   Unassigned                      n/a    
  0xE000 - 0xEFFF   Reserved for Experimental Use   n/a   RFC 9162
  0xF000 - 0xFFFF   Reserved for Private Use        n/a   RFC 9162

  : [Table 15](#table-15){.selfRef}

The \"Use\" column should contain one or both of the following
values:[¶](#section-10.2.4-6){.pilcrow}

-   [\"SCT\", for extensions specified for use in Signed Certificate
    Timestamps.[¶](#section-10.2.4-7.1){.pilcrow}]{#section-10.2.4-7.1}
-   [\"STH\", for extensions specified for use in Signed Tree
    Heads.[¶](#section-10.2.4-7.2){.pilcrow}]{#section-10.2.4-7.2}

The designated expert(s) should review the public specification to
ensure that it is detailed enough to ensure implementation
interoperability. They should also verify that the extension is
appropriate to the contexts in which it is specified to be used (SCT,
STH, or both).[¶](#section-10.2.4-8){.pilcrow}
:::
:::

::: {#log_id_registry}
::: {#section-10.2.5 .section}
#### [10.2.5.](#section-10.2.5){.section-number .selfRef} [Log IDs](#name-log-ids){.section-name .selfRef} {#name-log-ids}

IANA has established a registry of Log IDs, named \"Log
IDs\".[¶](#section-10.2.5-1){.pilcrow}

The registry\'s registration procedure is First Come First
Served.[¶](#section-10.2.5-2){.pilcrow}

The \"Log IDs\" registry initially consists
of:[¶](#section-10.2.5-3){.pilcrow}

  Log ID                         Log Base URL   Log Operator   Reference
  ------------------------------ -------------- -------------- -----------
  1.3.101.8192 - 1.3.101.16383   Unassigned     Unassigned      
  1.3.101.80.0 - 1.3.101.80.\*   Unassigned     Unassigned      

  : [Table 16](#table-16){.selfRef}

The following notes have been added to the
registry:[¶](#section-10.2.5-5){.pilcrow}

> []{.break}
>
> **Note:**
> :   All OIDs in the range from 1.3.101.8192 to 1.3.101.16383 have been
>     set aside for Log IDs. This is a limited resource of 8,192 OIDs,
>     each of which has an encoded length of 4
>     octets.[¶](#section-10.2.5-6.1.2){.pilcrow}
> :   

> []{.break}
>
> **Note:**
> :   The 1.3.101.80 arc has also been set aside for Log IDs. This is an
>     unlimited resource, but only the 128 OIDs from 1.3.101.80.0 to
>     1.3.101.80.127 have an encoded length of only 4
>     octets.[¶](#section-10.2.5-7.1.2){.pilcrow}
> :   

Each application for the allocation of a Log ID [MUST]{.bcp14} be
accompanied by:[¶](#section-10.2.5-8){.pilcrow}

-   [the Log\'s Base URL (see [Section 4.1](#log_parameters){.xref})
    and[¶](#section-10.2.5-9.1){.pilcrow}]{#section-10.2.5-9.1}
-   [the Log Operator\'s contact
    details.[¶](#section-10.2.5-9.2){.pilcrow}]{#section-10.2.5-9.2}

IANA is asked to reject any request to update a Log ID or Log Base URL
in this registry because these fields are immutable (see [Section
4.1](#log_parameters){.xref}).[¶](#section-10.2.5-10){.pilcrow}

IANA is asked to accept requests from log operators to update their
contact details in this registry.[¶](#section-10.2.5-11){.pilcrow}

Since log operators can choose to not use this registry (see [Section
4.4](#log_id){.xref}), it is not expected to be a global directory of
all logs.[¶](#section-10.2.5-12){.pilcrow}
:::
:::

::: {#error-types-registry}
::: {#section-10.2.6 .section}
#### [10.2.6.](#section-10.2.6){.section-number .selfRef} [Error Types](#name-error-types){.section-name .selfRef} {#name-error-types}

IANA has created a new registry for errors, the \"Error Types\"
registry.[¶](#section-10.2.6-1){.pilcrow}

The registration procedure for this registry is Specification
Required.[¶](#section-10.2.6-2){.pilcrow}

This registry has the following three
fields:[¶](#section-10.2.6-3){.pilcrow}

  Field Name   Type     Reference
  ------------ -------- -----------
  Identifier   string   RFC 9162
  Meaning      string   RFC 9162
  Reference    string   RFC 9162

  : [Table 17](#table-17){.selfRef}

The initial values of the \"Error Types\" registry, which are taken from
the text in [Section 5](#client_messages){.xref}, are as
follows:[¶](#section-10.2.6-5){.pilcrow}

  Identifier          Meaning                                                                                                                                      Reference
  ------------------- -------------------------------------------------------------------------------------------------------------------------------------------- -----------
  malformed           The request could not be parsed.                                                                                                             RFC 9162
  badSubmission       `submission` is neither a valid certificate nor a valid precertificate.                                                                      RFC 9162
  badType             `type` is neither 1 nor 2.                                                                                                                   RFC 9162
  badChain            The first element of `chain` is not the certifier of the `submission`, or the second element does not certify the first, etc.                RFC 9162
  badCertificate      One or more certificates in `chain` are not valid (e.g., not properly encoded).                                                              RFC 9162
  unknownAnchor       The last element of `chain` (or, if `chain` is an empty array, the `submission`) is not, nor is it certified by, an accepted trust anchor.   RFC 9162
  shutdown            The log is no longer accepting submissions.                                                                                                  RFC 9162
  firstUnknown        `first` is before the latest known STH but is not from an existing STH.                                                                      RFC 9162
  secondUnknown       `second` is before the latest known STH but is not from an existing STH.                                                                     RFC 9162
  secondBeforeFirst   `second` is smaller than `first`.                                                                                                            RFC 9162
  hashUnknown         `hash` is not the hash of a known leaf (may be caused by skew or by a known certificate not yet merged).                                     RFC 9162
  treeSizeUnknown     `hash` is before the latest known STH but is not from an existing STH.                                                                       RFC 9162
  startUnknown        `start` is greater than the number of entries in the Merkle Tree.                                                                            RFC 9162
  endBeforeStart      `start` cannot be greater than `end`.                                                                                                        RFC 9162

  : [Table 18](#table-18){.selfRef}
:::
:::
:::
:::

::: {#oid-assignment}
::: {#section-10.3 .section}
### [10.3.](#section-10.3){.section-number .selfRef} [OID Assignment](#name-oid-assignment){.section-name .selfRef} {#name-oid-assignment}

IANA has assigned an object identifier from the \"SMI Security for PKIX
Module Identifier\" registry to identify the ASN.1 module in [Appendix
B](#asn1_module){.xref} of this document.[¶](#section-10.3-1){.pilcrow}

  Decimal   Description               References
  --------- ------------------------- ------------
  102       id-mod-public-notary-v2   RFC 9162

  : [Table 19](#table-19){.selfRef}
:::
:::
:::
:::

::: {#security-considerations}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

With CAs, logs, and servers performing the actions described here, TLS
clients can use logs and signed timestamps to reduce the likelihood that
they will accept misissued certificates. If a server presents a valid
signed timestamp for a certificate, then the client knows that a log has
committed to publishing the certificate. From this, the client knows
that monitors acting for the subject of the certificate have had some
time to notice the misissuance and take some action, such as asking a CA
to revoke a misissued certificate. A signed timestamp does not guarantee
this, though, since appropriate monitors might not have checked the logs
or the CA might have refused to revoke the
certificate.[¶](#section-11-1){.pilcrow}

In addition, if TLS clients will not accept unlogged certificates, then
site owners will have a greater incentive to submit certificates to
logs, possibly with the assistance of their CA, increasing the overall
transparency of the system.[¶](#section-11-2){.pilcrow}

::: {#misissued-certificates}
::: {#section-11.1 .section}
### [11.1.](#section-11.1){.section-number .selfRef} [Misissued Certificates](#name-misissued-certificates){.section-name .selfRef} {#name-misissued-certificates}

Misissued certificates that have not been publicly logged, and thus do
not have a valid SCT, are not considered compliant. Misissued
certificates that do have an SCT from a log will appear in that public
log within the Maximum Merge Delay, assuming the log is operating
correctly. Since a log is allowed to serve an STH of any age up to the
MMD, the maximum period of time during which a misissued certificate can
be used without being available for audit is twice the
MMD.[¶](#section-11.1-1){.pilcrow}
:::
:::

::: {#detection-of-misissue}
::: {#section-11.2 .section}
### [11.2.](#section-11.2){.section-number .selfRef} [Detection of Misissue](#name-detection-of-misissue){.section-name .selfRef} {#name-detection-of-misissue}

The logs do not themselves detect misissued certificates; they rely
instead on interested parties, such as domain owners, to monitor them
and take corrective action when a misissue is
detected.[¶](#section-11.2-1){.pilcrow}
:::
:::

::: {#misbehaving_logs}
::: {#section-11.3 .section}
### [11.3.](#section-11.3){.section-number .selfRef} [Misbehaving Logs](#name-misbehaving-logs){.section-name .selfRef} {#name-misbehaving-logs}

A log can misbehave in several ways. Examples include the following:
failing to incorporate a certificate with an SCT in the Merkle Tree
within the MMD; presenting different, conflicting views of the Merkle
Tree at different times and/or to different parties; issuing STHs too
frequently; mutating the signature of a logged certificate; and failing
to present a chain containing the certifier of a logged
certificate.[¶](#section-11.3-1){.pilcrow}

Violation of the MMD contract is detected by log clients requesting a
Merkle inclusion proof ([Section 5.4](#get-proof-by-hash){.xref}) for
each observed SCT. These checks can be asynchronous and need only be
done once per certificate. However, note that there may be privacy
concerns (see [Section
8.1.4](#fetching_inclusion_proofs){.xref}).[¶](#section-11.3-2){.pilcrow}

Violation of the append-only property or the STH issuance rate limit can
be detected by multiple clients comparing their instances of the STHs.
This technique, known as \"gossip\", is an active area of research and
not defined here. Proof of misbehavior in such cases would be either a
series of STHs that were issued too closely together, proving violation
of the STH issuance rate limit, or an STH with a root hash that does not
match the one calculated from a copy of the log, proving violation of
the append-only property.[¶](#section-11.3-3){.pilcrow}

Clients that report back SCTs can be tracked or traced if a log produces
multiple STHs or SCTs with the same timestamp and data but different
signatures. Logs [SHOULD]{.bcp14} mitigate this risk by
either:[¶](#section-11.3-4){.pilcrow}

-   [using deterministic signature schemes
    or[¶](#section-11.3-5.1){.pilcrow}]{#section-11.3-5.1}
-   [producing no more than one SCT for each distinct submission and no
    more than one STH for each distinct `tree_size`. Each of these SCTs
    and STHs can be stored by the log and served to other clients that
    submit the same certificate or request the same
    STH.[¶](#section-11.3-5.2){.pilcrow}]{#section-11.3-5.2}
:::
:::

::: {#requiring_multiple_scts}
::: {#section-11.4 .section}
### [11.4.](#section-11.4){.section-number .selfRef} [Multiple SCTs](#name-multiple-scts-2){.section-name .selfRef} {#name-multiple-scts-2}

By requiring TLS servers to offer multiple SCTs, each from a different
log, TLS clients reduce the effectiveness of an attack where a CA and a
log collude (see [Section
6.2](#multiple-scts){.xref}).[¶](#section-11.4-1){.pilcrow}
:::
:::

::: {#leakage-of-dns-information}
::: {#section-11.5 .section}
### [11.5.](#section-11.5){.section-number .selfRef} [Leakage of DNS Information](#name-leakage-of-dns-information){.section-name .selfRef} {#name-leakage-of-dns-information}

Malicious monitors can use logs to learn about the existence of domain
names that might not otherwise be easy to discover. Some subdomain
labels may reveal information about the service and software for which
the subdomain is used, which in turn might facilitate targeted
attacks.[¶](#section-11.5-1){.pilcrow}
:::
:::
:::
:::

::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-12.1 .section}
### [12.1.](#section-12.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[FIPS186-4\]
:   [National Institute of Standards and Technology]{.refAuthor},
    [\"Digital Signature Standard (DSS)\"]{.refTitle}, [FIPS PUB
    186-4]{.seriesInfo}, July 2013,
    \<<http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf>\>.
:   

\[HTML401\]
:   [Raggett, D.]{.refAuthor}, [Le Hors, A.]{.refAuthor}, and [I.
    Jacobs]{.refAuthor}, [\"HTML 4.01 Specification\"]{.refTitle}, [W3C
    Recommendation SPSD-html401-20180327]{.seriesInfo}, March 2018,
    \<<https://www.w3.org/TR/2018/SPSD-html401-20180327>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC3553\]
:   [Mealling, M.]{.refAuthor}, [Masinter, L.]{.refAuthor},
    [Hardie, T.]{.refAuthor}, and [G. Klyne]{.refAuthor}, [\"An IETF URN
    Sub-namespace for Registered Protocol Parameters\"]{.refTitle}, [BCP
    73]{.seriesInfo}, [RFC 3553]{.seriesInfo}, [DOI
    10.17487/RFC3553]{.seriesInfo}, June 2003,
    \<<https://www.rfc-editor.org/info/rfc3553>\>.
:   

\[RFC3986\]
:   [Berners-Lee, T.]{.refAuthor}, [Fielding, R.]{.refAuthor}, and [L.
    Masinter]{.refAuthor}, [\"Uniform Resource Identifier (URI): Generic
    Syntax\"]{.refTitle}, [STD 66]{.seriesInfo}, [RFC
    3986]{.seriesInfo}, [DOI 10.17487/RFC3986]{.seriesInfo}, January
    2005, \<<https://www.rfc-editor.org/info/rfc3986>\>.
:   

\[RFC4648\]
:   [Josefsson, S.]{.refAuthor}, [\"The Base16, Base32, and Base64 Data
    Encodings\"]{.refTitle}, [RFC 4648]{.seriesInfo}, [DOI
    10.17487/RFC4648]{.seriesInfo}, October 2006,
    \<<https://www.rfc-editor.org/info/rfc4648>\>.
:   

\[RFC5246\]
:   [Dierks, T.]{.refAuthor} and [E. Rescorla]{.refAuthor}, [\"The
    Transport Layer Security (TLS) Protocol Version 1.2\"]{.refTitle},
    [RFC 5246]{.seriesInfo}, [DOI 10.17487/RFC5246]{.seriesInfo}, August
    2008, \<<https://www.rfc-editor.org/info/rfc5246>\>.
:   

\[RFC5280\]
:   [Cooper, D.]{.refAuthor}, [Santesson, S.]{.refAuthor},
    [Farrell, S.]{.refAuthor}, [Boeyen, S.]{.refAuthor},
    [Housley, R.]{.refAuthor}, and [W. Polk]{.refAuthor}, [\"Internet
    X.509 Public Key Infrastructure Certificate and Certificate
    Revocation List (CRL) Profile\"]{.refTitle}, [RFC
    5280]{.seriesInfo}, [DOI 10.17487/RFC5280]{.seriesInfo}, May 2008,
    \<<https://www.rfc-editor.org/info/rfc5280>\>.
:   

\[RFC5652\]
:   [Housley, R.]{.refAuthor}, [\"Cryptographic Message Syntax
    (CMS)\"]{.refTitle}, [STD 70]{.seriesInfo}, [RFC 5652]{.seriesInfo},
    [DOI 10.17487/RFC5652]{.seriesInfo}, September 2009,
    \<<https://www.rfc-editor.org/info/rfc5652>\>.
:   

\[RFC6066\]
:   [Eastlake 3rd, D.]{.refAuthor}, [\"Transport Layer Security (TLS)
    Extensions: Extension Definitions\"]{.refTitle}, [RFC
    6066]{.seriesInfo}, [DOI 10.17487/RFC6066]{.seriesInfo}, January
    2011, \<<https://www.rfc-editor.org/info/rfc6066>\>.
:   

\[RFC6234\]
:   [Eastlake 3rd, D.]{.refAuthor} and [T. Hansen]{.refAuthor}, [\"US
    Secure Hash Algorithms (SHA and SHA-based HMAC and
    HKDF)\"]{.refTitle}, [RFC 6234]{.seriesInfo}, [DOI
    10.17487/RFC6234]{.seriesInfo}, May 2011,
    \<<https://www.rfc-editor.org/info/rfc6234>\>.
:   

\[RFC6960\]
:   [Santesson, S.]{.refAuthor}, [Myers, M.]{.refAuthor},
    [Ankney, R.]{.refAuthor}, [Malpani, A.]{.refAuthor},
    [Galperin, S.]{.refAuthor}, and [C. Adams]{.refAuthor}, [\"X.509
    Internet Public Key Infrastructure Online Certificate Status
    Protocol - OCSP\"]{.refTitle}, [RFC 6960]{.seriesInfo}, [DOI
    10.17487/RFC6960]{.seriesInfo}, June 2013,
    \<<https://www.rfc-editor.org/info/rfc6960>\>.
:   

\[RFC6979\]
:   [Pornin, T.]{.refAuthor}, [\"Deterministic Usage of the Digital
    Signature Algorithm (DSA) and Elliptic Curve Digital Signature
    Algorithm (ECDSA)\"]{.refTitle}, [RFC 6979]{.seriesInfo}, [DOI
    10.17487/RFC6979]{.seriesInfo}, August 2013,
    \<<https://www.rfc-editor.org/info/rfc6979>\>.
:   

\[RFC7231\]
:   [Fielding, R., Ed.]{.refAuthor} and [J. Reschke, Ed.]{.refAuthor},
    [\"Hypertext Transfer Protocol (HTTP/1.1): Semantics and
    Content\"]{.refTitle}, [RFC 7231]{.seriesInfo}, [DOI
    10.17487/RFC7231]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7231>\>.
:   

\[RFC7633\]
:   [Hallam-Baker, P.]{.refAuthor}, [\"X.509v3 Transport Layer Security
    (TLS) Feature Extension\"]{.refTitle}, [RFC 7633]{.seriesInfo}, [DOI
    10.17487/RFC7633]{.seriesInfo}, October 2015,
    \<<https://www.rfc-editor.org/info/rfc7633>\>.
:   

\[RFC7807\]
:   [Nottingham, M.]{.refAuthor} and [E. Wilde]{.refAuthor}, [\"Problem
    Details for HTTP APIs\"]{.refTitle}, [RFC 7807]{.seriesInfo}, [DOI
    10.17487/RFC7807]{.seriesInfo}, March 2016,
    \<<https://www.rfc-editor.org/info/rfc7807>\>.
:   

\[RFC8032\]
:   [Josefsson, S.]{.refAuthor} and [I. Liusvaara]{.refAuthor},
    [\"Edwards-Curve Digital Signature Algorithm (EdDSA)\"]{.refTitle},
    [RFC 8032]{.seriesInfo}, [DOI 10.17487/RFC8032]{.seriesInfo},
    January 2017, \<<https://www.rfc-editor.org/info/rfc8032>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8259\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The JavaScript Object Notation
    (JSON) Data Interchange Format\"]{.refTitle}, [STD 90]{.seriesInfo},
    [RFC 8259]{.seriesInfo}, [DOI 10.17487/RFC8259]{.seriesInfo},
    December 2017, \<<https://www.rfc-editor.org/info/rfc8259>\>.
:   

\[RFC8391\]
:   [Huelsing, A.]{.refAuthor}, [Butin, D.]{.refAuthor},
    [Gazdag, S.]{.refAuthor}, [Rijneveld, J.]{.refAuthor}, and [A.
    Mohaisen]{.refAuthor}, [\"XMSS: eXtended Merkle Signature
    Scheme\"]{.refTitle}, [RFC 8391]{.seriesInfo}, [DOI
    10.17487/RFC8391]{.seriesInfo}, May 2018,
    \<<https://www.rfc-editor.org/info/rfc8391>\>.
:   

\[RFC8446\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   

\[UNIXTIME\]
:   [IEEE]{.refAuthor}, [\"The Open Group Base Specifications Issue
    7\"]{.refTitle}, [Section 4.16 Seconds Since the
    Epoch]{.refContent}, [IEEE Std 1003.1-2008]{.seriesInfo}, 2016,
    \<[http://pubs.opengroup.org/onlinepubs/9699919799.2016edition/basedefs/V1_chap04.html#tag_04_16](https://pubs.opengroup.org/onlinepubs/9699919799.2016edition/basedefs/V1_chap04.html#tag_04_16)\>.
:   

\[X690\]
:   [ITU-T]{.refAuthor}, [\"Information technology - ASN.1 encoding
    rules: Specification of Basic Encoding Rules (BER), Canonical
    Encoding Rules (CER) and Distinguished Encoding Rules
    (DER)\"]{.refTitle}, [ITU-T Recommendation X.690]{.seriesInfo},
    [ISO/IEC 8825-1]{.seriesInfo}, February 2021.
:   
:::

::: {#section-12.2 .section}
### [12.2.](#section-12.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[CABBR\]
:   [CA/Browser Forum]{.refAuthor}, [\"Baseline Requirements for the
    Issuance and Management of Publicly-Trusted
    Certificates\"]{.refTitle}, [Version 1.7.3]{.seriesInfo}, October
    2020,
    \<<https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.7.3.pdf>\>.
:   

\[Chromium.Log.Policy\]
:   [The Chromium Projects]{.refAuthor}, [\"Chromium Certificate
    Transparency Log Policy\"]{.refTitle},
    \<<https://googlechrome.github.io/CertificateTransparency/log_policy.html>\>.
:   

\[Chromium.Policy\]
:   [The Chromium Projects]{.refAuthor}, [\"Chromium Certificate
    Transparency Policy\"]{.refTitle},
    \<<https://googlechrome.github.io/CertificateTransparency/ct_policy.html>\>.
:   

\[CrosbyWallach\]
:   [Crosby, S.]{.refAuthor} and [D. Wallach]{.refAuthor}, [\"Efficient
    Data Structures for Tamper-Evident Logging\"]{.refTitle},
    [Proceedings of the 18th USENIX Security Symposium,
    Montreal]{.refContent}, August 2009,
    \<<http://static.usenix.org/event/sec09/tech/full_papers/crosby.pdf>\>.
:   

\[JSON.Metadata\]
:   [The Chromium Projects]{.refAuthor}, [\"Chromium Log Metadata JSON
    Schema\"]{.refTitle},
    \<<https://www.gstatic.com/ct/log_list/log_list_schema.json>\>.
:   

\[RFC5912\]
:   [Hoffman, P.]{.refAuthor} and [J. Schaad]{.refAuthor}, [\"New ASN.1
    Modules for the Public Key Infrastructure Using X.509
    (PKIX)\"]{.refTitle}, [RFC 5912]{.seriesInfo}, [DOI
    10.17487/RFC5912]{.seriesInfo}, June 2010,
    \<<https://www.rfc-editor.org/info/rfc5912>\>.
:   

\[RFC6268\]
:   [Schaad, J.]{.refAuthor} and [S. Turner]{.refAuthor}, [\"Additional
    New ASN.1 Modules for the Cryptographic Message Syntax (CMS) and the
    Public Key Infrastructure Using X.509 (PKIX)\"]{.refTitle}, [RFC
    6268]{.seriesInfo}, [DOI 10.17487/RFC6268]{.seriesInfo}, July 2011,
    \<<https://www.rfc-editor.org/info/rfc6268>\>.
:   

\[RFC6962\]
:   [Laurie, B.]{.refAuthor}, [Langley, A.]{.refAuthor}, and [E.
    Kasper]{.refAuthor}, [\"Certificate Transparency\"]{.refTitle}, [RFC
    6962]{.seriesInfo}, [DOI 10.17487/RFC6962]{.seriesInfo}, June 2013,
    \<<https://www.rfc-editor.org/info/rfc6962>\>.
:   

\[RFC8126\]
:   [Cotton, M.]{.refAuthor}, [Leiba, B.]{.refAuthor}, and [T.
    Narten]{.refAuthor}, [\"Guidelines for Writing an IANA
    Considerations Section in RFCs\"]{.refTitle}, [BCP 26]{.seriesInfo},
    [RFC 8126]{.seriesInfo}, [DOI 10.17487/RFC8126]{.seriesInfo}, June
    2017, \<<https://www.rfc-editor.org/info/rfc8126>\>.
:   

\[RFC8820\]
:   [Nottingham, M.]{.refAuthor}, [\"URI Design and
    Ownership\"]{.refTitle}, [BCP 190]{.seriesInfo}, [RFC
    8820]{.seriesInfo}, [DOI 10.17487/RFC8820]{.seriesInfo}, June 2020,
    \<<https://www.rfc-editor.org/info/rfc8820>\>.
:   

\[X.680\]
:   [ITU-T]{.refAuthor}, [\"Information technology - Abstract Syntax
    Notation One (ASN.1): Specification of basic notation\"]{.refTitle},
    [ITU-T Recommendation X.680]{.seriesInfo}, February 2021.
:   
:::
:::

::: {#v1_coexistence}
::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [Supporting v1 and v2 Simultaneously (Informative)](#name-supporting-v1-and-v2-simult){.section-name .selfRef} {#name-supporting-v1-and-v2-simult}

Certificate Transparency logs have to be either v1 (conforming to
\[[RFC6962](#RFC6962){.xref}\]) or v2 (conforming to this document), as
the data structures are incompatible, and so a v2 log could not issue a
valid v1 SCT.[¶](#appendix-A-1){.pilcrow}

CT clients, however, can support v1 and v2 SCTs for the same certificate
simultaneously, as v1 SCTs are delivered in different TLS, X.509, and
OCSP extensions than v2 SCTs.[¶](#appendix-A-2){.pilcrow}

v1 and v2 SCTs for X.509 certificates can be validated independently.
For precertificates, v2 SCTs should be embedded in the TBSCertificate
before submission of the TBSCertificate (inside a v1 precertificate, as
described in [Section
3.1](https://www.rfc-editor.org/rfc/rfc6962#section-3.1){.relref} of
\[[RFC6962](#RFC6962){.xref}\]) to a v1 log so that TLS clients
conforming to \[[RFC6962](#RFC6962){.xref}\] but not this document are
oblivious to the embedded v2 SCTs. An issuer can follow these steps to
produce an X.509 certificate with embedded v1 and v2
SCTs:[¶](#appendix-A-3){.pilcrow}

-   [Create a CMS precertificate, as described in [Section
    3.2](#precertificates){.xref}, and submit it to v2
    logs.[¶](#appendix-A-4.1){.pilcrow}]{#appendix-A-4.1}
-   [Embed the obtained v2 SCTs in the TBSCertificate, as described in
    [Section
    7.1.2](#cert_transinfo_extension){.xref}.[¶](#appendix-A-4.2){.pilcrow}]{#appendix-A-4.2}
-   [Use that TBSCertificate to create a v1 precertificate, as described
    in [Section
    3.1](https://www.rfc-editor.org/rfc/rfc6962#section-3.1){.relref} of
    \[[RFC6962](#RFC6962){.xref}\], and submit it to v1
    logs.[¶](#appendix-A-4.3){.pilcrow}]{#appendix-A-4.3}
-   [Embed the v1 SCTs in the TBSCertificate, as described in [Section
    3.3](https://www.rfc-editor.org/rfc/rfc6962#section-3.3){.relref} of
    \[[RFC6962](#RFC6962){.xref}\].[¶](#appendix-A-4.4){.pilcrow}]{#appendix-A-4.4}
-   [Sign that TBSCertificate (which now contains v1 and v2 SCTs) to
    issue the final X.509
    certificate.[¶](#appendix-A-4.5){.pilcrow}]{#appendix-A-4.5}
:::
:::

::: {#asn1_module}
::: {#appendix-B .section}
## [Appendix B.](#appendix-B){.section-number .selfRef} [An ASN.1 Module (Informative)](#name-an-asn1-module-informative){.section-name .selfRef} {#name-an-asn1-module-informative}

The following ASN.1 \[[X.680](#X.680){.xref}\] module may be useful to
implementors. This module references \[[RFC5912](#RFC5912){.xref}\] and
\[[RFC6268](#RFC6268){.xref}\].[¶](#appendix-B-1){.pilcrow}

::: {#appendix-B-2}
``` {.lang-asn.1 .sourcecode}
CertificateTransparencyV2Module-2021
 -- { id-mod-public-notary-v2 from above, in
        iso(1) identified-organization(3) ...
    form }
DEFINITIONS IMPLICIT TAGS ::= BEGIN

-- EXPORTS ALL --

IMPORTS
  EXTENSION
  FROM PKIX-CommonTypes-2009 -- RFC 5912
    { iso(1) identified-organization(3) dod(6) internet(1)
      security(5) mechanisms(5) pkix(7) id-mod(0)
      id-mod-pkixCommon-02(57) }

  CONTENT-TYPE
  FROM CryptographicMessageSyntax-2010  -- RFC 6268
    { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
      pkcs-9(9) smime(16) modules(0) id-mod-cms-2009(58) }

  TBSCertificate
  FROM PKIX1Explicit-2009 -- RFC 5912
    { iso(1) identified-organization(3) dod(6) internet(1)
      security(5) mechanisms(5) pkix(7) id-mod(0)
      id-mod-pkix1-explicit-02(51) }
;

--
-- Section 3.2.  Precertificates
--

ct-tbsCertificate CONTENT-TYPE ::= {
  TYPE TBSCertificate
  IDENTIFIED BY id-ct-tbsCertificate }

id-ct-tbsCertificate OBJECT IDENTIFIER ::= { 1 3 101 78 }

--
-- Section 7.1.  Transparency Information X.509v3 Extension
--

ext-transparencyInfo EXTENSION ::= {
   SYNTAX TransparencyInformationSyntax
   IDENTIFIED BY id-ce-transparencyInfo
   CRITICALITY { FALSE } }

id-ce-transparencyInfo OBJECT IDENTIFIER ::= { 1 3 101 75 }

TransparencyInformationSyntax ::= OCTET STRING

--
-- Section 7.1.1.  OCSP Response Extension
--

ext-ocsp-transparencyInfo EXTENSION ::= {
   SYNTAX TransparencyInformationSyntax
   IDENTIFIED BY id-pkix-ocsp-transparencyInfo
   CRITICALITY { FALSE } }

id-pkix-ocsp-transparencyInfo OBJECT IDENTIFIER ::=
   id-ce-transparencyInfo

--
-- Section 8.1.2.  Reconstructing the TBSCertificate
--

ext-embeddedSCT-CTv1 EXTENSION ::= {
   SYNTAX SignedCertificateTimestampList
   IDENTIFIED BY id-ce-embeddedSCT-CTv1
   CRITICALITY { FALSE } }

id-ce-embeddedSCT-CTv1 OBJECT IDENTIFIER ::= {
   1 3 6 1 4 1 11129 2 4 2 }

SignedCertificateTimestampList ::= OCTET STRING

END
```

[¶](#appendix-B-2){.pilcrow}
:::
:::
:::

::: {#acknowledgements}
::: {#appendix-C .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

The authors would like to thank [Erwann Abelea]{.contact-name}, [Robin
Alden]{.contact-name}, [Andrew Ayer]{.contact-name}, [Richard
Barnes]{.contact-name}, [Al Cutter]{.contact-name}, [David
Drysdale]{.contact-name}, [Francis Dupont]{.contact-name}, [Adam
Eijdenberg]{.contact-name}, [Stephen Farrell]{.contact-name}, [Daniel
Kahn Gillmor]{.contact-name}, [Paul Hadfield]{.contact-name}, [Brad
Hill]{.contact-name}, [Jeff Hodges]{.contact-name}, [Paul
Hoffman]{.contact-name}, [Jeffrey Hutzelman]{.contact-name}, [Kat
Joyce]{.contact-name}, [Emilia Kasper]{.contact-name}, [Stephen
Kent]{.contact-name}, [Adam Langley]{.contact-name},
[SM]{.contact-name}, [Alexey Melnikov]{.contact-name}, [Linus
Nordberg]{.contact-name}, [Chris Palmer]{.contact-name}, [Trevor
Perrin]{.contact-name}, [Pierre Phaneuf]{.contact-name}, [Eric
Rescorla]{.contact-name}, [Rich Salz]{.contact-name}, [Melinda
Shore]{.contact-name}, [Ryan Sleevi]{.contact-name}, [Martin
Smith]{.contact-name}, [Carl Wallace]{.contact-name}, and [Paul
Wouters]{.contact-name} for their valuable
contributions.[¶](#appendix-C-1){.pilcrow}

A big thank you to Symantec for kindly donating the OIDs from the
1.3.101 arc that are used in this document.[¶](#appendix-C-2){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-D .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Ben Laurie]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google UK Ltd.]{.org}
:::

::: email
Email: <benl@google.com>
:::

::: {.left dir="auto"}
[Eran Messeri]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google UK Ltd.]{.org}
:::

::: email
Email: <eranm@google.com>
:::

::: {.left dir="auto"}
[Rob Stradling]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Sectigo Ltd.]{.org}
:::

::: email
Email: <rob@sectigo.com>
:::
:::
:::
