  RFC 8662       Entropy Labels for SPRING Tunnels   December 2019
  -------------- ----------------------------------- ---------------
  Kini, et al.   Standards Track                     \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8662](https://www.rfc-editor.org/rfc/rfc8662){.eref}

Category:
:   Standards Track

Published:
:   December 2019

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    S. Kini
    :::
    :::

    ::: author
    ::: author-name
    K. Kompella
    :::

    ::: org
    Juniper
    :::
    :::

    ::: author
    ::: author-name
    S. Sivabalan
    :::

    ::: org
    Cisco
    :::
    :::

    ::: author
    ::: author-name
    S. Litkowski
    :::

    ::: org
    Orange
    :::
    :::

    ::: author
    ::: author-name
    R. Shakir
    :::

    ::: org
    Google
    :::
    :::

    ::: author
    ::: author-name
    J. Tantsura
    :::

    ::: org
    Apstra, Inc.
    :::
    :::
:::

# RFC 8662 {#rfcnum}

# Entropy Label for Source Packet Routing in Networking (SPRING) Tunnels {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

Segment Routing (SR) leverages the source-routing paradigm. A node
steers a packet through an ordered list of instructions, called
segments. Segment Routing can be applied to the Multiprotocol Label
Switching (MPLS) data plane. Entropy labels (ELs) are used in MPLS to
improve load-balancing. This document examines and describes how ELs are
to be applied to Segment Routing MPLS.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8662>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2019 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Requirements
        Language](#name-requirements-language){.xref}[¶](#section-toc.1-1.1.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Abbreviations and
    Terminology](#name-abbreviations-and-terminolo){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Use Case Requiring Multipath
    Load-Balancing](#name-use-case-requiring-multipat){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Entropy Readable Label
    Depth](#name-entropy-readable-label-dept){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Maximum SID
    Depth](#name-maximum-sid-depth){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [LSP Stitching Using the Binding
    SID](#name-lsp-stitching-using-the-bin){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Insertion of Entropy Labels for SPRING
    Path](#name-insertion-of-entropy-labels){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Overview](#name-overview){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.7.2.1.2.1}
            [7.1.1](#section-7.1.1){.xref}.  [Example 1: The Ingress
            Node Has a Sufficient
            MSD](#name-example-1-the-ingress-node-){.xref}[¶](#section-toc.1-1.7.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.7.2.1.2.2}
            [7.1.2](#section-7.1.2){.xref}.  [Example 2: The Ingress
            Node Does Not Have a Sufficient
            MSD](#name-example-2-the-ingress-node-){.xref}[¶](#section-toc.1-1.7.2.1.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Considerations for the Placement
        of Entropy
        Labels](#name-considerations-for-the-plac){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.7.2.2.2.1}
            [7.2.1](#section-7.2.1){.xref}.  [ERLD
            Value](#name-erld-value){.xref}[¶](#section-toc.1-1.7.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.7.2.2.2.2}
            [7.2.2](#section-7.2.2){.xref}.  [Segment
            Type](#name-segment-type){.xref}[¶](#section-toc.1-1.7.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.7.2.2.2.3}
            [7.2.3](#section-7.2.3){.xref}.  [Maximizing Number of LSRs
            That Will
            Load-Balance](#name-maximizing-number-of-lsrs-t){.xref}[¶](#section-toc.1-1.7.2.2.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.7.2.2.2.4}
            [7.2.4](#section-7.2.4){.xref}.  [Preference for a Part of
            the
            Path](#name-preference-for-a-part-of-th){.xref}[¶](#section-toc.1-1.7.2.2.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.7.2.2.2.5}
            [7.2.5](#section-7.2.5){.xref}.  [Combining
            Criteria](#name-combining-criteria){.xref}[¶](#section-toc.1-1.7.2.2.2.5.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [A Simple Example
    Algorithm](#name-a-simple-example-algorithm){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Deployment
    Considerations](#name-deployment-considerations){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Options
    Considered](#name-options-considered){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}

    -   ::: {#section-toc.1-1.10.2.1}
        [10.1](#section-10.1){.xref}.  [Single EL at the Bottom of the
        Stack](#name-single-el-at-the-bottom-of-){.xref}[¶](#section-toc.1-1.10.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [10.2](#section-10.2){.xref}.  [An EL per Segment in the
        Stack](#name-an-el-per-segment-in-the-st){.xref}[¶](#section-toc.1-1.10.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.3}
        [10.3](#section-10.3){.xref}.  [A Reusable EL for a Stack of
        Tunnels](#name-a-reusable-el-for-a-stack-o){.xref}[¶](#section-toc.1-1.10.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.4}
        [10.4](#section-10.4){.xref}.  [EL at Top of
        Stack](#name-el-at-top-of-stack){.xref}[¶](#section-toc.1-1.10.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.5}
        [10.5](#section-10.5){.xref}.  [ELs at Readable Label Stack
        Depths](#name-els-at-readable-label-stack){.xref}[¶](#section-toc.1-1.10.2.5.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.13}
    [13](#section-13){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}

    -   ::: {#section-toc.1-1.13.2.1}
        [13.1](#section-13.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.13.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.13.2.2}
        [13.2](#section-13.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.13.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.14}
    [](#section-appendix.a){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.15}
    [](#section-appendix.b){.xref}[Contributors](#name-contributors){.xref}[¶](#section-toc.1-1.15.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.16}
    [](#section-appendix.c){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.16.1){.pilcrow}
    :::
:::
:::

::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Segment Routing \[[RFC8402](#RFC8402){.xref}\] is based on source-routed
tunnels to steer a packet along a particular path. This path is encoded
as an ordered list of segments. When applied to the MPLS data plane
\[[RFC8660](#RFC8660){.xref}\], each segment is an LSP (Label Switched
Path) with an associated MPLS label value. Hence, label stacking is used
to represent the ordered list of segments, and the label stack
associated with an SR tunnel can be seen as nested LSPs (LSP hierarchy)
in the MPLS architecture.[¶](#section-1-1){.pilcrow}

Using label stacking to encode the list of segments has implications on
the label stack depth.[¶](#section-1-2){.pilcrow}

Traffic load-balancing over ECMP (Equal-Cost Multipath) or LAGs (Link
Aggregation Groups) is usually based on a hashing function. The local
node that performs the load-balancing is required to read some header
fields in the incoming packets and then compute a hash based on those
fields. The result of the hash is finally mapped to a list of outgoing
next hops. The hashing technique is required to perform a per-flow
load-balancing and thus, prevents packet misordering. For IP traffic,
the usual fields that are hashed are the source address, the destination
address, the protocol type, and, if provided by the upper layer, the
source port and destination port.[¶](#section-1-3){.pilcrow}

The MPLS architecture brings some challenges when an LSR (Label
Switching Router) tries to look up at header fields. An LSR needs be
able to look up at header fields that are beyond the MPLS label stack
while the MPLS header does not provide any information about the
upper-layer protocol. An LSR must perform a deeper inspection compared
to an ingress router, which could be challenging for some hardware.
Entropy labels (ELs) \[[RFC6790](#RFC6790){.xref}\] are used in the MPLS
data plane to provide entropy for load-balancing. The idea behind the
entropy label is that the ingress router computes a hash based on
several fields from a given packet and places the result in an
additional label named \"entropy label\". Then, this entropy label can
be used as part of the hash keys used by an LSR. Using the entropy label
as part of the hash keys reduces the need for deep packet inspection in
the LSR while keeping a good level of entropy in the load-balancing.
When the entropy label is used, the keys used in the hashing functions
are still a local configuration matter, and an LSR may use solely the
entropy label or a combination of multiple fields from the incoming
packet.[¶](#section-1-4){.pilcrow}

When using LSP hierarchies, there are implications on how
\[[RFC6790](#RFC6790){.xref}\] should be applied. The current document
addresses the case where a hierarchy is created at a single LSR as
required by Segment Routing.[¶](#section-1-5){.pilcrow}

A use case requiring load-balancing with SR is given in [Section
3](#usecase){.xref}. A recommended solution is described in [Section
7](#solution){.xref} keeping in consideration the limitations of
implementations when applying \[[RFC6790](#RFC6790){.xref}\] to deeper
label stacks. Options that were considered to arrive at the recommended
solution are documented for historical purposes in [Section
10](#other-options){.xref}.[¶](#section-1-6){.pilcrow}

::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Requirements Language](#name-requirements-language){.section-name .selfRef} {#name-requirements-language}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-1){.pilcrow}
:::
:::

::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Abbreviations and Terminology](#name-abbreviations-and-terminolo){.section-name .selfRef} {#name-abbreviations-and-terminolo}

Adj-SID
:   Adjacency Segment Identifier[¶](#section-2-1.2){.pilcrow}

ECMP
:   Equal-Cost Multipath[¶](#section-2-1.4){.pilcrow}

EL
:   Entropy Label[¶](#section-2-1.6){.pilcrow}

ELI
:   Entropy Label Indicator[¶](#section-2-1.8){.pilcrow}

ELC
:   Entropy Label Capability[¶](#section-2-1.10){.pilcrow}

ERLD
:   Entropy Readable Label Depth[¶](#section-2-1.12){.pilcrow}

FEC
:   Forwarding Equivalence Class[¶](#section-2-1.14){.pilcrow}

LAG
:   Link Aggregation Group[¶](#section-2-1.16){.pilcrow}

LSP
:   Label Switched Path[¶](#section-2-1.18){.pilcrow}

LSR
:   Label Switching Router[¶](#section-2-1.20){.pilcrow}

MPLS
:   Multiprotocol Label Switching[¶](#section-2-1.22){.pilcrow}

MSD
:   Maximum SID Depth[¶](#section-2-1.24){.pilcrow}

Node SID
:   Node Segment Identifier[¶](#section-2-1.26){.pilcrow}

OAM
:   Operations, Administration, and
    Maintenance[¶](#section-2-1.28){.pilcrow}

RLD
:   Readable Label Depth[¶](#section-2-1.30){.pilcrow}

SID
:   Segment Identifier[¶](#section-2-1.32){.pilcrow}

SPT
:   Shortest Path Tree[¶](#section-2-1.34){.pilcrow}

SR
:   Segment Routing[¶](#section-2-1.36){.pilcrow}

SRGB
:   Segment Routing Global Block[¶](#section-2-1.38){.pilcrow}

VPN
:   Virtual Private Network[¶](#section-2-1.40){.pilcrow}
:::

::: {#usecase}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Use Case Requiring Multipath Load-Balancing](#name-use-case-requiring-multipat){.section-name .selfRef} {#name-use-case-requiring-multipat}

Traffic engineering is one of the applications of MPLS and is also a
requirement for Segment Routing \[[RFC7855](#RFC7855){.xref}\]. Consider
the topology shown in [Figure 1](#fig_TE_use_case){.xref}. The LSR S
requires data to be sent to LSR D along a traffic-engineered path that
goes over the link L1. Good load-balancing is also required across
equal-cost paths (including parallel links). To steer traffic along a
path that crosses link L1, the label stack that LSR S creates consists
of a label to the Node SID of LSR P3 stacked over the label for the
Adj-SID (Adjacency Segment Identifier) of link L1 and that in turn is
stacked over the label to the Node SID of LSR D. For simplicity, lets
assume that all LSRs use the same label space for Segment Routing (as a
reminder, it is called the SRGB, Segment Routing Global Block). Let
L_N-Px denote the label to be used to reach the Node SID of LSR Px. Let
L_A-Ln denote the label used for the Adj-SID for link Ln. In our
example, the LSR S must use the label stack \<L_N-P3, L_A-L1, L_N-D>.
However, to achieve good load-balancing over the equal-cost paths
P2-P4-D, P2-P5-D, and the parallel links L3 and L4, a mechanism such as
entropy labels \[[RFC6790](#RFC6790){.xref}\] should be adapted for
Segment Routing. Indeed, the Source Packet Routing in Networking
(SPRING) architecture with the MPLS data plane
\[[RFC8660](#RFC8660){.xref}\] uses nested MPLS LSPs composing the
source-routed label stack.[¶](#section-3-1){.pilcrow}

[]{#name-traffic-engineering-use-cas}

::: {#fig_TE_use_case}
::: {#section-3-2.1 .artwork .art-text .alignLeft}
                          +------+
                          |      |
                  +-------|  P3  |-----+
                  | +-----|      |---+ |
                L3| |L4   +------+ L1| |L2     +----+
                  | |                | |    +--| P4 |--+
    +-----+     +-----+            +-----+  |  +----+  |  +-----+
    |  S  |-----| P1  |------------| P2  |--+          +--|  D  |
    |     |     |     |            |     |--+          +--|     |
    +-----+     +-----+            +-----+  |  +----+  |  +-----+
                                            +--| P5 |--+
                                               +----+
        Key:
            S = Source LSR
            D = Destination LSR
            P1, P2, P3, P4, P5 = Transit LSRs
            L1, L2, L3, L4 = Links
:::

[Figure 1](#figure-1){.selfRef}: [Traffic-Engineering Use
Case](#name-traffic-engineering-use-cas){.selfRef}
:::

An MPLS node may have limitations in the number of labels it can push.
It may also have a limitation in the number of labels it can inspect
when looking for hash keys during load-balancing. While the entropy
label is normally inserted at the bottom of the transport tunnel, this
may prevent an LSR from taking into account the EL in its load-balancing
function if the EL is too deep in the stack. In a Segment Routing
environment, it is important to define the considerations that need to
be taken into account when inserting an EL. Multiple ways to apply
entropy labels were considered and are documented in [Section
10](#other-options){.xref} along with their trade-offs. A recommended
solution is described in [Section
7](#solution){.xref}.[¶](#section-3-3){.pilcrow}
:::
:::

::: {#erld_definition}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Entropy Readable Label Depth](#name-entropy-readable-label-dept){.section-name .selfRef} {#name-entropy-readable-label-dept}

The Entropy Readable Label Depth (ERLD) is defined as the number of
labels a router can both:[¶](#section-4-1){.pilcrow}

a.  [Read in an MPLS packet received on its incoming interface(s)
    (starting from the top of the
    stack).[¶](#section-4-2.1){.pilcrow}]{#section-4-2.1}
b.  [Use in its load-balancing
    function.[¶](#section-4-2.2){.pilcrow}]{#section-4-2.2}

The ERLD means that the router will perform load-balancing using the EL
if the EL is placed within the first ERLD
labels.[¶](#section-4-3){.pilcrow}

A router capable of reading N labels but not using an EL located within
those N labels [MUST]{.bcp14} consider its ERLD to be
0.[¶](#section-4-4){.pilcrow}

In a distributed switching architecture, each line card may have a
different capability in terms of ERLD. For simplicity, an implementation
[MAY]{.bcp14} use the minimum ERLD of all line cards as the ERLD value
for the system.[¶](#section-4-5){.pilcrow}

There may also be a case where a router has a fast switching path
(handled by an Application-Specific Integrated Circuit, or ASIC, or
network processor) and a slow switching path (handled by a CPU) with a
different ERLD for each switching path. Again, for simplicity\'s sake,
an implementation [MAY]{.bcp14} use the minimum ERLD as the ERLD value
for the system.[¶](#section-4-6){.pilcrow}

The drawback of using a single ERLD for a system lower than the
capability of one or more specific components is that it may increase
the number of ELI/ELs inserted. This leads to an increase of the label
stack size and may have an impact on the capability of the ingress node
to push this label stack.[¶](#section-4-7){.pilcrow}

Examples:[¶](#section-4-8){.pilcrow}

[]{#name-label-stacks-with-eli-el}

::: {#fig_label_stacks}
::: {#section-4-9.1 .artwork .art-text .alignLeft}
                                                        | Payload  |
                                                        +----------+ 
                                           | Payload  | |    EL    | P7
                                           +----------+ +----------+ 
                              | Payload  | |    EL    | |    ELI   | 
                              +----------+ +----------+ +----------+ 
                 | Payload  | |   EL     | |    ELI   | | Label 50 | 
                 +----------+ +----------+ +----------+ +----------+ 
    |  Payload | |     EL   | |   ELI    | | Label 40 | | Label 40 |
    +----------+ +----------+ +----------+ +----------+ +----------+  
    |     EL   | |    ELI   | | Label 30 | | Label 30 | | Label 30 |  
    +----------+ +----------+ +----------+ +----------+ +----------+
    |    ELI   | | Label 20 | | Label 20 | | Label 20 | | Label 20 | 
    +----------+ +----------+ +----------+ +----------+ +----------+
    | Label 16 | | Label 16 | | Label 16 | | Label 16 | | Label 16 | P1
    +----------+ +----------+ +----------+ +----------+ +----------+
      Packet 1     Packet 2     Packet 3     Packet 4     Packet 5
:::

[Figure 2](#figure-2){.selfRef}: [Label Stacks with
ELI/EL](#name-label-stacks-with-eli-el){.selfRef}
:::

In [Figure 2](#fig_label_stacks){.xref}, we consider the displayed
packets received on a router interface. We consider also a single ERLD
value for the router.[¶](#section-4-10){.pilcrow}

-   [If the router has an ERLD of 3, it will be able to load-balance
    Packet 1 displayed in [Figure 2](#fig_label_stacks){.xref} using the
    EL as part of the load-balancing keys. The ERLD value of 3 means
    that the router can read and take into account the entropy label for
    load-balancing if it is placed between position 1 (top of the MPLS
    label stack) and position
    3.[¶](#section-4-11.1){.pilcrow}]{#section-4-11.1}
-   [If the router has an ERLD of 5, it will be able to load-balance
    Packets 1 to 3 in [Figure 2](#fig_label_stacks){.xref} using the EL
    as part of the load-balancing keys. Packets 4 and 5 have the EL
    placed at a position greater than 5, so the router is not able to
    read it and use it as part of the load-balancing
    keys.[¶](#section-4-11.2){.pilcrow}]{#section-4-11.2}
-   [If the router has an ERLD of 10, it will be able to load-balance
    all the packets displayed in [Figure 2](#fig_label_stacks){.xref}
    using the EL as part of the load-balancing
    keys.[¶](#section-4-11.3){.pilcrow}]{#section-4-11.3}

To allow an efficient load-balancing based on entropy labels, a router
running SPRING [SHOULD]{.bcp14} advertise its ERLD (or ERLDs), so all
the other SPRING routers in the network are aware of its capability. How
this advertisement is done is outside the scope of this document (see
[Section 7.2.1](#erld){.xref} for potential
approaches).[¶](#section-4-12){.pilcrow}

To advertise an ERLD value, a SPRING router:[¶](#section-4-13){.pilcrow}

-   [[MUST]{.bcp14} be entropy label capable and, as a consequence,
    [MUST]{.bcp14} apply the data-plane procedures defined in
    \[[RFC6790](#RFC6790){.xref}\].[¶](#section-4-14.1){.pilcrow}]{#section-4-14.1}
-   [[MUST]{.bcp14} be able to read an ELI/EL, which is located within
    its ERLD value.[¶](#section-4-14.2){.pilcrow}]{#section-4-14.2}
-   [[MUST]{.bcp14} take into account an EL within the first ERLD labels
    in its load-balancing
    function.[¶](#section-4-14.3){.pilcrow}]{#section-4-14.3}
:::
:::

::: {#msd}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Maximum SID Depth](#name-maximum-sid-depth){.section-name .selfRef} {#name-maximum-sid-depth}

The Maximum SID Depth defines the maximum number of labels that a
particular node can impose on a packet. This can include any kind of
labels (service, entropy, transport, etc.). In an MPLS network, the MSD
is a limit of the head-end of an SR tunnel or a Binding SID anchor node
that performs imposition of additional labels on an existing label
stack.[¶](#section-5-1){.pilcrow}

Depending on the number of MPLS operations (POP, SWAP, etc.) to be
performed before the PUSH, the MSD can vary due to hardware or software
limitations. As for the ERLD, different MSD limits can exist within a
single node based on the line-card types used in a distributed switching
system. Thus, the MSD is a per link and/or per-node
property.[¶](#section-5-2){.pilcrow}

An external controller can be used to program a label stack on a
particular node. This node [SHOULD]{.bcp14} advertise its MSD to the
controller in order to let the controller know the maximum label stack
depth of the path computed that is supported on the head-end. How this
advertisement is done is outside the scope of this document.
(\[[RFC8476](#RFC8476){.xref}\], \[[RFC8491](#RFC8491){.xref}\], and
\[[MSD-BGP](#I-D.ietf-idr-bgp-ls-segment-routing-msd){.xref}\] provide
examples of advertisement of the MSD.) As the controller does not have
the knowledge of the entire label stack to be pushed by the node, in
addition to the MSD value, the node [SHOULD]{.bcp14} advertise the type
of the MSD. For instance, the MSD value can represent the limit for
pushing transport labels only while in reality the node can push an
additional service label. As another example, the MSD value can
represent the full limit of the node including all label types
(transport, service, entropy, etc.). This gives the ability for the
controller to program a label stack while leaving room for the local
node to add more labels (e.g., service, entropy, etc.) without reaching
the hardware/software limit. If the node does not provide the meaning of
the MSD value, the controller could program an LSP using a number of
labels equal to the full limit of the node. When receiving this label
stack from the controller, the ingress node may not be able to add any
service (L2VPN, L3VPN, EVPN, etc.) label on top of this label stack. The
consequence could be for the ingress node to drop service packets that
should have been forwarded over the LSP.[¶](#section-5-3){.pilcrow}

[]{#name-topology-illustrating-label}

::: {#fig_packet}
::: {#section-5-4.1 .artwork .art-text .alignLeft}
                  P7 ---- P8 ---- P9
                /                   \
        PE1 --- P1 --- P2 --- P3 --- P4 --- P5 --- P6 --- PE2
                                            |  \            |
    ---->                                  P10  \           |
    IP Pkt                                  |    \          |
                                           P11 --- P12 --- P13
                                               100    10000
:::

[Figure 3](#figure-3){.selfRef}: [Topology Illustrating Label Stack
Reduction](#name-topology-illustrating-label){.selfRef}
:::

In [Figure 3](#fig_packet){.xref}, an IP packet comes into the MPLS
network at PE1. All metrics are considered equal to 1 except P12-P13,
which is 10000, and P11-P12, which is 100. PE1 wants to steer the
traffic using a SPRING path to PE2 along PE1 -\> P1 -\> P7 -\> P8 -\> P9
-\> P4 -\> P5 -\> P10 -\> P11 -\> P12 -\> P13 -\> PE2. By using Adj-SIDs
only, PE1 (acting as an ingress LSR, also known as an I-LSR) will be
required to push 10 labels on the IP packet received and thus, requires
an MSD of 10. If the IP packet should be carried over an MPLS service
like a regular layer 3 VPN, an additional service label should be
imposed requiring an MSD of 11 for PE1. In addition, if PE1 wants to
insert an ELI/EL for load-balancing purposes, PE1 will need to push 13
labels on the IP packet requiring an MSD of
13.[¶](#section-5-5){.pilcrow}

In the SPRING architecture, Node SIDs or Binding SIDs can be used to
reduce the label stack size. As an example, to steer the traffic on the
same path as before, PE1 could use the following label stack: \<Node_P9,
Node_P5, Binding_P5, Node_PE2>. In this example, we consider a
combination of Node SIDs and a Binding SID advertised by P5 that will
stitch the traffic along the path P10 -\> P11 -\> P12 -\> P13. The
instruction associated with the Binding SID at P5 is thus to swap
Binding_P5 to Adj_P12-P13 and then push \<Adj_P11-P12, Node_P11>. P5
acts as a stitching node that pushes additional labels on an existing
label stack; P5\'s MSD needs also to be taken into account and may limit
the number of labels that can be imposed.[¶](#section-5-6){.pilcrow}
:::
:::

::: {#stitching}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [LSP Stitching Using the Binding SID](#name-lsp-stitching-using-the-bin){.section-name .selfRef} {#name-lsp-stitching-using-the-bin}

The Binding SID allows binding a segment identifier to an existing LSP.
As examples, the Binding SID can represent an RSVP-TE tunnel, an LDP
path (through the Mapping Server Advertisement), or a SPRING path. Each
tail-end router of an MPLS LSP associated with a Binding SID has its own
entropy label capability. The entropy label capability of the associated
LSP is advertised in the control-plane protocol used to signal the
LSP.[¶](#section-6-1){.pilcrow}

In [Figure 4](#fig_stitching_example){.xref}, we consider
that:[¶](#section-6-2){.pilcrow}

-   [P6, PE2, P10, P11, P12, and P13 are pure LDP
    routers.[¶](#section-6-3.1){.pilcrow}]{#section-6-3.1}
-   [PE1, P1, P2, P3, P4, P7, P8, and P9 are pure SPRING
    routers.[¶](#section-6-3.2){.pilcrow}]{#section-6-3.2}
-   [P5 is running SPRING and
    LDP.[¶](#section-6-3.3){.pilcrow}]{#section-6-3.3}
-   [P5 acts as a Mapping Server and advertises Prefix-SIDs for the LDP
    FECs: an index value of 20 is used for
    PE2.[¶](#section-6-3.4){.pilcrow}]{#section-6-3.4}
-   [All SPRING routers use an SRGB of \[1000,
    1999\].[¶](#section-6-3.5){.pilcrow}]{#section-6-3.5}
-   [P6 advertises label 20 for the PE2
    FEC.[¶](#section-6-3.6){.pilcrow}]{#section-6-3.6}
-   [Traffic from PE1 to PE2 uses the shortest
    path.[¶](#section-6-3.7){.pilcrow}]{#section-6-3.7}

[]{#name-example-illustrating-need-f}

::: {#fig_stitching_example}
::: {#section-6-4.1 .artwork .art-text .alignLeft}
            PE1 ----- P1 -- P2 -- P3 -- P4 ---- P5 --- P6 --- PE2
        -->    +----+                   +----+   +----+  +----+
      IP Pkt   | IP |                   | IP |   | IP |  | IP |
               +----+                   +----+   +----+  +----+
               |1020|                   |1020|   | 20 |
               +----+                   +----+   +----+
                                        SPRING    LDP
:::

[Figure 4](#figure-4){.selfRef}: [Example Illustrating Need for ELC
Propagation](#name-example-illustrating-need-f){.selfRef}
:::

In terms of packet forwarding, by learning the Mapping Server
Advertisement from P5, PE1 imposes a label 1020 to an IP packet destined
to PE2. SPRING routers along the shortest path to PE2 will switch the
traffic until it reaches P5. P5 will perform the LSP stitching by
swapping the SPRING label 1020 to the LDP label 20 advertised by the
next hop P6. P6 will finally forward the packet using the LDP label
towards PE2.[¶](#section-6-5){.pilcrow}

PE1 cannot push an ELI/EL for the Binding SID without knowing that the
tail end of the LSP associated with the binding (PE2) is entropy label
capable.[¶](#section-6-6){.pilcrow}

To accommodate the mix of signaling protocols involved during the
stitching, the entropy label capability [SHOULD]{.bcp14} be propagated
between the signaling domains. Each Binding SID [SHOULD]{.bcp14} have
its own entropy label capability that [MUST]{.bcp14} be inherited from
the entropy label capability of the associated LSP. If the router
advertising the Binding SID does not know the ELC state of the target
FEC, it [MUST NOT]{.bcp14} set the ELC for the Binding SID. An ingress
node [MUST NOT]{.bcp14} push an ELI/EL associated with a Binding SID
unless this Binding SID has the entropy label capability. How the
entropy label capability is advertised for a Binding SID is outside the
scope of this document (see [Section 7.2.1](#erld){.xref} for potential
approaches).[¶](#section-6-7){.pilcrow}

In our example, if PE2 is LDP entropy label capable, it will add the
entropy label capability in its LDP advertisement. When P5 receives the
FEC/label binding for PE2, it learns about the ELC and can set the ELC
in the Mapping Server Advertisement. Thus, PE1 learns about the ELC of
PE2 and may push an ELI/EL associated with the Binding
SID.[¶](#section-6-8){.pilcrow}

The proposed solution only works if the SPRING router advertising the
Binding SID is also performing the data-plane LSP stitching. In our
example, if the Mapping Server function is hosted on P8 instead of P5,
P8 does not know about the ELC state of PE2\'s LDP FEC. As a
consequence, it does not set the ELC for the associated Binding
SID.[¶](#section-6-9){.pilcrow}
:::
:::

::: {#solution}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Insertion of Entropy Labels for SPRING Path](#name-insertion-of-entropy-labels){.section-name .selfRef} {#name-insertion-of-entropy-labels}

::: {#overview}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Overview](#name-overview){.section-name .selfRef} {#name-overview}

The solution described in this section follows the data-plane processing
defined in \[[RFC6790](#RFC6790){.xref}\]. Within a SPRING path, a node
may be ingress, egress, transit (regarding the entropy label processing
described in \[[RFC6790](#RFC6790){.xref}\]), or it can be any
combination of those. For example:[¶](#section-7.1-1){.pilcrow}

-   [The ingress node of a SPRING domain can be an ingress node from an
    entropy label
    perspective.[¶](#section-7.1-2.1){.pilcrow}]{#section-7.1-2.1}
-   [Any LSR terminating a segment of the SPRING path is an egress node
    (because it terminates the segment) but can also be a transit node
    if the SPRING path is not terminated because there is a subsequent
    SPRING MPLS label in the
    stack.[¶](#section-7.1-2.2){.pilcrow}]{#section-7.1-2.2}
-   [Any LSR processing a Binding SID may be a transit node and an
    ingress node (because it may push additional labels when processing
    the Binding SID).[¶](#section-7.1-2.3){.pilcrow}]{#section-7.1-2.3}

As described earlier, an LSR may have a limitation (the ERLD) on the
depth of the label stack that it can read and process in order to do
multipath load-balancing based on entropy
labels.[¶](#section-7.1-3){.pilcrow}

If an EL does not occur within the ERLD of an LSR in the label stack of
an MPLS packet that it receives, then it would lead to poor
load-balancing at that LSR. Hence, an ELI/EL pair must be within the
ERLD of the LSR in order for the LSR to use the EL during
load-balancing.[¶](#section-7.1-4){.pilcrow}

Adding a single ELI/EL pair for the entire SPRING path can also lead to
poor load-balancing as well because the ELI/EL may not occur within the
ERLD of some LSR on the path (if too deep) or may not be present in the
stack when it reaches some LSRs (if it is too
shallow).[¶](#section-7.1-5){.pilcrow}

In order for the EL to occur within the ERLD of LSRs along the path
corresponding to a SPRING label stack, multiple \<ELI, EL> pairs
[MAY]{.bcp14} be inserted in this label
stack.[¶](#section-7.1-6){.pilcrow}

The insertion of an ELI/EL [MUST]{.bcp14} occur only with a SPRING label
advertised by an LSR that advertised an ERLD (the LSR is entropy label
capable) or with a SPRING label associated with a Binding SID that has
the ELC set.[¶](#section-7.1-7){.pilcrow}

The ELs among multiple \<ELI, EL> pairs inserted in the stack
[MAY]{.bcp14} be the same or different. The LSR that inserts \<ELI, EL>
pairs can have limitations on the number of such pairs that it can
insert and also the depth at which it can insert them. If, due to
limitations, the inserted ELs are at positions such that an LSR along
the path receives an MPLS packet without an EL in the label stack within
that LSR\'s ERLD, then the load-balancing performed by that LSR would be
poor. An implementation [MAY]{.bcp14} consider multiple criteria when
inserting \<ELI, EL> pairs.[¶](#section-7.1-8){.pilcrow}

::: {#ex1}
::: {#section-7.1.1 .section}
#### [7.1.1.](#section-7.1.1){.section-number .selfRef} [Example 1: The Ingress Node Has a Sufficient MSD](#name-example-1-the-ingress-node-){.section-name .selfRef} {#name-example-1-the-ingress-node-}

[]{#name-accommodating-msd-limitatio}

::: {#fig_ex1}
::: {#section-7.1.1-1.1 .artwork .art-text .alignLeft}
                         ECMP          LAG           LAG
       PE1 --- P1 --- P2 --- P3 --- P4 --- P5 --- P6 --- PE2
:::

[Figure 5](#figure-5){.selfRef}: [Accommodating MSD
Limitations](#name-accommodating-msd-limitatio){.selfRef}
:::

In [Figure 5](#fig_ex1){.xref}, PE1 wants to forward some MPLS VPN
traffic over an explicit path to PE2 resulting in the following label
stack to be pushed onto the received IP header: \<Adj_P1P2,
Adj_set_P2P3, Adj_P3P4, Adj_P4P5, Adj_P5P6, Adj_P6PE2, VPN_label>. PE1
is limited to push a maximum of 11 labels (MSD=11). P2, P3, and P6 have
an ERLD of 3 while others have an ERLD of
10.[¶](#section-7.1.1-2){.pilcrow}

PE1 can only add two ELI/EL pairs in the label stack due to its MSD
limitation. It should insert them strategically to benefit
load-balancing along the longest part of the
path.[¶](#section-7.1.1-3){.pilcrow}

PE1 can take into account multiple parameters when inserting ELs; as
examples:[¶](#section-7.1.1-4){.pilcrow}

-   [The ERLD value advertised by transit
    nodes.[¶](#section-7.1.1-5.1){.pilcrow}]{#section-7.1.1-5.1}
-   [The requirement of load-balancing for a particular label
    value.[¶](#section-7.1.1-5.2){.pilcrow}]{#section-7.1.1-5.2}
-   [Any service provider preference: favor beginning of the path or end
    of the path.[¶](#section-7.1.1-5.3){.pilcrow}]{#section-7.1.1-5.3}

In [Figure 5](#fig_ex1){.xref}, a good strategy may be to use the
following stack \<Adj_P1P2, Adj_set_P2P3, ELI1, EL1, Adj_P3P4, Adj_P4P5,
Adj_P5P6, Adj_P6PE2, ELI2, EL2, VPN_label>. The original stack requests
P2 to forward based on an L3 adjacency-set that will require
load-balancing. Therefore, it is important to ensure that P2 can
load-balance correctly. As P2 has a limited ERLD of 3, an ELI/EL must be
inserted just after the label that P2 will use to forward. On the path
to PE2, P3 has also a limited ERLD, but P3 will forward based on a
regular adjacency segment that may not require load-balancing.
Therefore, it does not seem important to ensure that P3 can do
load-balancing despite its limited ERLD. The next nodes along the
forwarding path have a high ERLD that does not cause any issue, except
P6. Moreover, P6 is using some LAGs to PE2 and so is expected to
load-balance. It becomes important to insert a new ELI/EL just after the
P6 forwarding label.[¶](#section-7.1.1-6){.pilcrow}

In the case above, the ingress node was able to support a sufficient MSD
to ensure end-to-end load-balancing while taking into account the path
attributes. However, there might be cases where the ingress node may not
have the necessary label imposition
capacity.[¶](#section-7.1.1-7){.pilcrow}
:::
:::

::: {#ex2}
::: {#section-7.1.2 .section}
#### [7.1.2.](#section-7.1.2){.section-number .selfRef} [Example 2: The Ingress Node Does Not Have a Sufficient MSD](#name-example-2-the-ingress-node-){.section-name .selfRef} {#name-example-2-the-ingress-node-}

[]{#name-msd-considerations}

::: {#fig_ex2}
::: {#section-7.1.2-1.1 .artwork .art-text .alignLeft}
                       ECMP          LAG           ECMP         ECMP
     PE1 --- P1 --- P2 --- P3 --- P4 --- P5 --- P6 --- P7 --- P8 --- PE2
:::

[Figure 6](#figure-6){.selfRef}: [MSD
Considerations](#name-msd-considerations){.selfRef}
:::

In [Figure 6](#fig_ex2){.xref}, PE1 wants to forward MPLS VPN traffic
over an explicit path to PE2 resulting in the following label stack to
be pushed onto the IP header: \<Adj_P1P2, Adj_set_P2P3, Adj_P3P4,
Adj_P4P5, Adj_P5P6, Adj_set_P6P7, Adj_P7P8; Adj_set_P8PE2, VPN_label>.
PE1 is limited to push a maximum of 11 labels. P2, P3, and P6 have an
ERLD of 3 while others have an ERLD of
15.[¶](#section-7.1.2-2){.pilcrow}

Using a similar strategy as the previous case may lead to a dilemma, as
PE1 can only push a single ELI/EL while we may need a minimum of three
to load-balance the end-to-end path. An optimized stack that would
enable end-to-end load-balancing may be: \<Adj_P1P2, Adj_set_P2P3, ELI1,
EL1, Adj_P3P4, Adj_P4P5, Adj_P5P6, Adj_set_P6P7, ELI2, EL2, Adj_P7P8,
Adj_set_P8PE2, ELI3, EL3, VPN_label>.[¶](#section-7.1.2-3){.pilcrow}

A decision needs to be taken to favor some part of the path for
load-balancing considering that load-balancing may not work on the other
parts. A service provider may decide to place the ELI/EL after the P6
forwarding label as it will allow P4 and P6 to load-balance. Placing the
ELI/EL at the bottom of the stack is also a possibility enabling
load-balancing for P4 and P8.[¶](#section-7.1.2-4){.pilcrow}
:::
:::
:::
:::

::: {#el_placement}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Considerations for the Placement of Entropy Labels](#name-considerations-for-the-plac){.section-name .selfRef} {#name-considerations-for-the-plac}

The sample cases described in the previous section showed that ELI/EL
placement when the maximum number of labels to be pushed is limited is
not an easy decision, and multiple criteria may be taken into
account.[¶](#section-7.2-1){.pilcrow}

This section describes some considerations that an implementation
[MAY]{.bcp14} take into account when placing ELI/ELs. This list of
criteria is not considered exhaustive and an implementation
[MAY]{.bcp14} take into account additional criteria or tiebreakers that
are not documented here. As the insertion of ELI/ELs is performed by the
ingress node, having ingress nodes that do not use the same criteria
does not cause an interoperability issue. However, from a network design
and operation perspective, it is better to have all ingress routers
using the same criteria.[¶](#section-7.2-2){.pilcrow}

An implementation [SHOULD]{.bcp14} try to maximize the possibility of
load-balancing along the path by inserting an ELI/EL where multiple
equal-cost paths are available and minimize the number of ELI/ELs that
need to be inserted. In case of a trade-off, an implementation
[SHOULD]{.bcp14} provide flexibility to the operator to select the
criteria to be considered when placing ELI/ELs or specify a subobjective
for optimization.[¶](#section-7.2-3){.pilcrow}

[]{#name-msd-trade-offs}

::: {#fig_consid_sample}
::: {#section-7.2-4.1 .artwork .art-text .alignLeft}
                             2      2
       PE1 -- P1 -- P2 --P3 --- P4 --- P5 -- ... -- P8 -- P9 -- PE2
                         |             |
                         P3'--- P4'--- P5'
:::

[Figure 7](#figure-7){.selfRef}: [MSD
Trade-Offs](#name-msd-trade-offs){.selfRef}
:::

[Figure 7](#fig_consid_sample){.xref} will be used as reference in the
following subsections. All metrics are equal to 1 except P3-P4 and
P4-P5, which have a metric 2. We consider the MSD of nodes to be the
full limit of label imposition (including service labels, entropy
labels, and transport labels).[¶](#section-7.2-5){.pilcrow}

::: {#erld}
::: {#section-7.2.1 .section}
#### [7.2.1.](#section-7.2.1){.section-number .selfRef} [ERLD Value](#name-erld-value){.section-name .selfRef} {#name-erld-value}

As mentioned in [Section 7.1](#overview){.xref}, the ERLD value is an
important parameter to consider when inserting an ELI/EL. If an ELI/EL
does not fall within the ERLD of a node on the path, the node will not
be able to load-balance the traffic
efficiently.[¶](#section-7.2.1-1){.pilcrow}

The ERLD value can be advertised via protocols, and those extensions are
described in separate documents (for instance,
\[[ISIS-ELC](#I-D.ietf-isis-mpls-elc){.xref}\] and
\[[OSPF-ELC](#I-D.ietf-ospf-mpls-elc){.xref}\]).[¶](#section-7.2.1-2){.pilcrow}

Let\'s consider a path from PE1 to PE2 using the following stack pushed
by PE1: \<Adj_P1P2, Node_P9, Adj_P9PE2,
Service_label>.[¶](#section-7.2.1-3){.pilcrow}

Using the ERLD as an input parameter can help to minimize the number of
required ELI/EL pairs to be inserted. An ERLD value must be retrieved
for each SPRING label in the label stack.[¶](#section-7.2.1-4){.pilcrow}

For a label bound to an adjacency segment, the ERLD is the ERLD of the
node that has advertised the adjacency segment. In the example above,
the ERLD associated with Adj_P1P2 would be the ERLD of router P1, as P1
will perform the forwarding based on the Adj_P1P2
label.[¶](#section-7.2.1-5){.pilcrow}

For a label bound to a node segment, multiple strategies [MAY]{.bcp14}
be implemented. An implementation [MAY]{.bcp14} try to evaluate the
minimum ERLD value along the node segment path. If an implementation
cannot find the minimum ERLD along the path of the segment or does not
support the computation of the minimum ERLD, it [SHOULD]{.bcp14} instead
use the ERLD of the tail-end node. Using the ERLD of the tail end of the
node segment mimics the behavior of \[[RFC6790](#RFC6790){.xref}\] where
the ingress takes only care of the egress of the LSP. In the example
above, if the implementation supports computation of minimum ERLD along
the path, the ERLD associated with label Node_P9 would be the minimum
ERLD between nodes {P2,P3,P4 \..., P8}. If the implementation does not
support the computation of minimum ERLD, it will consider the ERLD of P9
(tail-end node of Node_P9 SID). While providing the more optimal ELI/EL
placement, evaluating the minimum ERLD increases the complexity of
ELI/EL insertion. As the path to the Node SID may change over time, a
recomputation of the minimum ERLD is required for each topology change.
This recomputation may require the positions of the ELI/ELs to
change.[¶](#section-7.2.1-6){.pilcrow}

For a label bound to a Binding Segment, if the Binding Segment describes
a path, an implementation [MAY]{.bcp14} also try to evaluate the minimum
ERLD along this path. If the implementation cannot find the minimum ERLD
along the path of the segment or does not support this evaluation, it
[SHOULD]{.bcp14} instead use the ERLD of the node advertising the
Binding SID. As for the node segment, evaluating the minimum ERLD adds
complexity in the ELI/EL insertion
process.[¶](#section-7.2.1-7){.pilcrow}
:::
:::

::: {#sid-type}
::: {#section-7.2.2 .section}
#### [7.2.2.](#section-7.2.2){.section-number .selfRef} [Segment Type](#name-segment-type){.section-name .selfRef} {#name-segment-type}

Depending on the type of segment a particular label is bound to, an
implementation can deduce that this particular label will be subject to
load-balancing on the path.[¶](#section-7.2.2-1){.pilcrow}

::: {#node-sid}
::: {#section-7.2.2.1 .section}
##### [7.2.2.1.](#section-7.2.2.1){.section-number .selfRef} [Node SID](#name-node-sid){.section-name .selfRef} {#name-node-sid}

An MPLS label bound to a Node SID represents a path that may cross
multiple hops. Load-balancing may be needed on the node starting this
path but also on any node along the
path.[¶](#section-7.2.2.1-1){.pilcrow}

In [Figure 7](#fig_consid_sample){.xref}, let\'s consider a path from
PE1 to PE2 using the following stack pushed by PE1: \<Adj_P1P2, Node_P9,
Adj_P9PE2, Service_label>.[¶](#section-7.2.2.1-2){.pilcrow}

If, for example, PE1 is limited to push 6 labels, it can add a single
ELI/EL within the label stack. An operator may want to favor a placement
that would allow load-balancing along the Node SID path. In [Figure
7](#fig_consid_sample){.xref}, P3, which is along the Node SID path,
requires load-balancing between two equal-cost
paths.[¶](#section-7.2.2.1-3){.pilcrow}

An implementation [MAY]{.bcp14} try to evaluate if load-balancing is
really required within a node segment path. This could be done by
running an additional SPT (Shortest Path Tree) computation and analyzing
of the node segment path to prevent a node segment that does not really
require load-balancing from being preferred when placing ELI/ELs. Such
inspection may be time consuming for implementations and without a 100%
guarantee, as a node segment path may use LAGs that are invisible to the
IP topology. As a simpler approach, an implementation [MAY]{.bcp14}
consider that a label bound to a Node SID will be subject to
load-balancing and require an ELI/⁠EL.[¶](#section-7.2.2.1-4){.pilcrow}
:::
:::

::: {#adj-sid1}
::: {#section-7.2.2.2 .section}
##### [7.2.2.2.](#section-7.2.2.2){.section-number .selfRef} [Adjacency-Set SID](#name-adjacency-set-sid){.section-name .selfRef} {#name-adjacency-set-sid}

An adjacency-set is an Adj-SID that refers to a set of adjacencies. When
an adjacency-set segment is used within a label stack, an implementation
can deduce that load-balancing is expected at the node that advertised
this adjacency segment. An implementation [MAY]{.bcp14} favor the
insertion of an ELI/EL after the Adj-SID representing an
adjacency-set.[¶](#section-7.2.2.2-1){.pilcrow}
:::
:::

::: {#adj-sid2}
::: {#section-7.2.2.3 .section}
##### [7.2.2.3.](#section-7.2.2.3){.section-number .selfRef} [Adjacency SID Representing a Single IP Link](#name-adjacency-sid-representing-){.section-name .selfRef} {#name-adjacency-sid-representing-}

When an adjacency segment representing a single IP link is used within a
label stack, an implementation can deduce that load-balancing may not be
expected at the node that advertised this adjacency
segment.[¶](#section-7.2.2.3-1){.pilcrow}

An implementation [MAY]{.bcp14} NOT place an ELI/EL after a regular
Adj-SID in order to favor the insertion of ELI/ELs following other
segments.[¶](#section-7.2.2.3-2){.pilcrow}

Readers should note that an adjacency segment representing a single IP
link may require load-balancing. This is the case when a LAG (L2 bundle)
is implemented between two IP nodes and the L2 bundle SR extensions
\[[RFC8668](#RFC8668){.xref}\] are not implemented. In such a case, it
could be useful to insert an ELI/EL in a readable position for the LSR
advertising the label associated with the adjacency segment. To
communicate the requirement for load-balancing for a particular
Adjacency SID to ingress nodes, a user can enforce the use of the L2
bundle SR extensions defined in \[[RFC8668](#RFC8668){.xref}\] or can
declare the single adjacency as an
adjacency-set.[¶](#section-7.2.2.3-3){.pilcrow}
:::
:::

::: {#adj-sid3}
::: {#section-7.2.2.4 .section}
##### [7.2.2.4.](#section-7.2.2.4){.section-number .selfRef} [Adjacency SID Representing a Single Link within an L2 Bundle](#name-adjacency-sid-representing-a){.section-name .selfRef} {#name-adjacency-sid-representing-a}

When the L2 bundle SR extensions \[[RFC8668](#RFC8668){.xref}\] are
used, adjacency segments may be advertised for each member of the
bundle. In this case, an implementation can deduce that load-balancing
is not expected on the LSR advertising this segment and [MAY]{.bcp14}
NOT insert an ELI/EL after the corresponding
label.[¶](#section-7.2.2.4-1){.pilcrow}
:::
:::

::: {#adj-sid4}
::: {#section-7.2.2.5 .section}
##### [7.2.2.5.](#section-7.2.2.5){.section-number .selfRef} [Adjacency SID Representing an L2 Bundle](#name-adjacency-sid-representing-an){.section-name .selfRef} {#name-adjacency-sid-representing-an}

When the L2 bundle SR extensions \[[RFC8668](#RFC8668){.xref}\] are
used, an adjacency segment may be advertised to represent the bundle. In
this case, an implementation can deduce that load-balancing is expected
on the LSR advertising this segment and [MAY]{.bcp14} insert an ELI/EL
after the corresponding label.[¶](#section-7.2.2.5-1){.pilcrow}
:::
:::
:::
:::

::: {#section-7.2.3 .section}
#### [7.2.3.](#section-7.2.3){.section-number .selfRef} [Maximizing Number of LSRs That Will Load-Balance](#name-maximizing-number-of-lsrs-t){.section-name .selfRef} {#name-maximizing-number-of-lsrs-t}

When placing ELI/ELs, an implementation [MAY]{.bcp14} optimize the
number of LSRs that both need to load-balance (i.e., have ECMPs) and
that will be able to perform load-balancing (i.e., the EL is within
their ERLD).[¶](#section-7.2.3-1){.pilcrow}

Let\'s consider a path from PE1 to PE2 using the following stack pushed
by PE1: \<Adj_P1P2, Node_P9, Adj_P9PE2, Service_label>. All routers have
an ERLD of 10 except P1 and P2, which have an ERLD of 4. PE1 is able to
push 6 labels, so only a single ELI/EL can be
added.[¶](#section-7.2.3-2){.pilcrow}

In the example above, adding an ELI/EL after Adj_P1P2 will only allow
load-balancing at P1, while inserting it after Adj_PE2P9 will allow
load-balancing at P2, P3 \... P9 and maximize the number of LSRs that
can perform load-balancing.[¶](#section-7.2.3-3){.pilcrow}
:::

::: {#section-7.2.4 .section}
#### [7.2.4.](#section-7.2.4){.section-number .selfRef} [Preference for a Part of the Path](#name-preference-for-a-part-of-th){.section-name .selfRef} {#name-preference-for-a-part-of-th}

An implementation [MAY]{.bcp14} allow the user to favor a part of the
end-to-end path when the number of ELI/ELs that can be pushed is not
enough to cover the entire path. As an example, a service provider may
want to favor load-balancing at the beginning of the path or at the end
of the path, so the implementation favors putting the ELI/ELs near the
top or the bottom of the stack.[¶](#section-7.2.4-1){.pilcrow}
:::

::: {#section-7.2.5 .section}
#### [7.2.5.](#section-7.2.5){.section-number .selfRef} [Combining Criteria](#name-combining-criteria){.section-name .selfRef} {#name-combining-criteria}

An implementation [MAY]{.bcp14} combine multiple criteria to determine
the best ELI/ELs placement. However, combining too many criteria could
lead to implementation complexity and high resource consumption. Each
time the network topology changes, a new evaluation of the ELI/EL
placement will be necessary for each impacted
LSP.[¶](#section-7.2.5-1){.pilcrow}
:::
:::
:::
:::
:::

::: {#algo-example}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [A Simple Example Algorithm](#name-a-simple-example-algorithm){.section-name .selfRef} {#name-a-simple-example-algorithm}

A simple implementation might take into account the ERLD when placing
ELI/EL while trying to minimize the number of ELI/ELs inserted and
trying to maximize the number of LSRs that can
load-balance.[¶](#section-8-1){.pilcrow}

The example algorithm is based on the following
considerations:[¶](#section-8-2){.pilcrow}

-   [An LSR that can insert a limited number of \<ELI, EL> pairs should
    insert such pairs deeper in the
    stack.[¶](#section-8-3.1){.pilcrow}]{#section-8-3.1}
-   [An LSR should try to insert \<ELI, EL> pairs at positions to
    maximize the number of transit LSRs for which the EL occurs within
    the ERLD of those
    LSRs.[¶](#section-8-3.2){.pilcrow}]{#section-8-3.2}
-   [An LSR should try to insert the minimum number of such pairs while
    trying to satisfy the above
    criteria.[¶](#section-8-3.3){.pilcrow}]{#section-8-3.3}

The pseudocode of the example algorithm is shown
below.[¶](#section-8-4){.pilcrow}

[]{#name-example-algorithm-to-insert}

::: {#section-8-5.1}
``` {.sourcecode .lang-pseudocode}
   Initialize the current EL insertion point to the
     bottom-most label in the stack that is EL-capable
   while (local-node can push more <ELI,EL> pairs OR
             insertion point is not above label stack) {
       insert an <ELI,EL> pair below current insertion point
       move new insertion point up from current insertion point until
           ((last inserted EL is below the ERLD) AND (ERLD > 2)
                             AND
            (new insertion point is EL-capable))
       set current insertion point to new insertion point
   }
```

[¶](#section-8-5.1){.pilcrow}
:::

[Figure 8](#figure-8){.selfRef}: [Example Algorithm to Insert \<ELI, EL>
Pairs in a Label Stack](#name-example-algorithm-to-insert){.selfRef}

When this algorithm is applied to the example described in [Section
3](#usecase){.xref}, it will result in ELs being inserted in two
positions; one after the label L_N-D and another after L_N-P3. Thus, the
resulting label stack would be \<L_N-P3, ELI, EL, L_A-L1, L_N-D, ELI,
EL>.[¶](#section-8-6){.pilcrow}
:::
:::

::: {#deployment}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Deployment Considerations](#name-deployment-considerations){.section-name .selfRef} {#name-deployment-considerations}

As long as LSR node data-plane capabilities are limited (number of
labels that can be pushed or number of labels that can be inspected),
hop-by-hop load-balancing of SPRING-encapsulated flows will require
trade-offs.[¶](#section-9-1){.pilcrow}

The entropy label is still a good and usable solution as it allows
load-balancing without having to perform deep packet inspection on each
LSR: It does not seem reasonable to have an LSR inspecting UDP ports
within a GRE tunnel carried over a 15-label SPRING
tunnel.[¶](#section-9-2){.pilcrow}

Due to the limited capacity of reading a deep stack of MPLS labels,
multiple ELI/ELs may be required within the stack, which directly
impacts the capacity of the head-end to push a deep stack: each ELI/EL
inserted requires two additional labels to be
pushed.[¶](#section-9-3){.pilcrow}

Placement strategies of ELI/ELs are required to find the best trade-off.
Multiple criteria could be taken into account, and some level of
customization (by the user) is required to accommodate different
deployments. Since analyzing the path of each destination to determine
the best ELI/EL placement may be time consuming for the control plane,
we encourage implementations to find the best trade-off between
simplicity, resource consumption, and load-balancing
efficiency.[¶](#section-9-4){.pilcrow}

In the future, hardware and software capacity may increase data-plane
capabilities and may remove some of these limitations, increasing
load-balancing capability using entropy
labels.[¶](#section-9-5){.pilcrow}
:::
:::

::: {#other-options}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Options Considered](#name-options-considered){.section-name .selfRef} {#name-options-considered}

Different options that were considered to arrive at the recommended
solution are documented in this section.[¶](#section-10-1){.pilcrow}

These options are detailed here only for historical
purposes.[¶](#section-10-2){.pilcrow}

::: {#section-10.1 .section}
### [10.1.](#section-10.1){.section-number .selfRef} [Single EL at the Bottom of the Stack](#name-single-el-at-the-bottom-of-){.section-name .selfRef} {#name-single-el-at-the-bottom-of-}

In this option, a single EL is used for the entire label stack. The
source LSR S encodes the entropy label at the bottom of the label stack.
In the example described in [Section 3](#usecase){.xref}, it will result
in the label stack at LSR S to look like \<L_N-P3, L_A-L1, L_N-D, ELI,
EL> \<remaining packet header>. Note that the notation in
\[[RFC6790](#RFC6790){.xref}\] is used to describe the label stack. An
issue with this approach is that as the label stack grows due an
increase in the number of SIDs, the EL goes correspondingly deeper in
the label stack. Hence, transit LSRs have to access a larger number of
bytes in the packet header when making forwarding decisions. In the
example described in [Section 3](#usecase){.xref}, if we consider that
the LSR P1 has an ERLD of 3, P1 would load-balance traffic poorly on the
parallel links L3 and L4 since the EL is below the ERLD of P1. A
load-balanced network design using this approach must ensure that all
intermediate LSRs have the capability to read the maximum label stack
depth as required for the application that uses source-routed
stacking.[¶](#section-10.1-1){.pilcrow}

This option was rejected since there exist a number of hardware
implementations that have a low maximum readable label depth. Choosing
this option can lead to a loss of load-balancing using EL in a
significant part of the network when that is a critical requirement in a
service-provider network.[¶](#section-10.1-2){.pilcrow}
:::

::: {#section-10.2 .section}
### [10.2.](#section-10.2){.section-number .selfRef} [An EL per Segment in the Stack](#name-an-el-per-segment-in-the-st){.section-name .selfRef} {#name-an-el-per-segment-in-the-st}

In this option, each segment/label in the stack can be given its own EL.
When load-balancing is required to direct traffic on a segment, the
source LSR pushes an \<ELI, EL> before pushing the label associated to
this segment. In the example described in [Section 3](#usecase){.xref},
the source label stack that is LSR S encoded would be \<L_N-P3, ELI, EL,
L_A-L1, L_N-D, ELI, EL>, where all the ELs can be the same. Accessing
the EL at an intermediate LSR is independent of the depth of the label
stack and hence, independent of the specific application that uses
source-routed tunnels with label stacking. A drawback is that the depth
of the label stack grows significantly, almost 3 times as the number of
labels in the label stack. The network design should ensure that source
LSRs have the capability to push such a deep label stack. Also, the
bandwidth overhead and potential MTU issues of deep label stacks should
be considered in the network design.[¶](#section-10.2-1){.pilcrow}

This option was rejected due to the existence of hardware
implementations that can push a limited number of labels on the label
stack. Choosing this option would result in a hardware requirement to
push two additional labels per tunnel label. Hence, it would restrict
the number of tunnels that can be stacked in an LSP and hence, constrain
the types of LSPs that can be created. This was considered
unacceptable.[¶](#section-10.2-2){.pilcrow}
:::

::: {#section-10.3 .section}
### [10.3.](#section-10.3){.section-number .selfRef} [A Reusable EL for a Stack of Tunnels](#name-a-reusable-el-for-a-stack-o){.section-name .selfRef} {#name-a-reusable-el-for-a-stack-o}

In this option, an LSR that terminates a tunnel reuses the EL of the
terminated tunnel for the next inner tunnel. It does this by storing the
EL from the outer tunnel when that tunnel is terminated and reinserting
it below the next inner tunnel label during the label-swap operation.
The LSR that stacks tunnels should insert an EL below the outermost
tunnel. It should not insert ELs for any inner tunnels. Also, the
penultimate hop LSR of a segment must not pop the ELI and EL even though
they are exposed as the top labels since the terminating LSR of that
segment would reuse the EL for the next
segment.[¶](#section-10.3-1){.pilcrow}

In [Section 3](#usecase){.xref}, the source label stack that is LSR S
encoded would be \<L_N-P3, ELI, EL, L_A-L1, L_N-⁠D>. At P1, the outgoing
label stack would be \<L_N-P3, ELI, EL, L_A-L1, L_N-D> after it has
load-balanced to one of the links L3 or L4. At P3, the outgoing label
stack would be \<L_N-D, ELI, EL>. At P2, the outgoing label stack would
be \<L_N-D, ELI, EL> and it would load-balance to one of the next-hop
LSRs P4 or P5. Accessing the EL at an intermediate LSR (e.g., P1) is
independent of the depth of the label stack and hence, independent of
the specific use case to which the label stack is
applied.[¶](#section-10.3-2){.pilcrow}

This option was rejected due to the significant change in label-swap
operations that would be required for existing
hardware.[¶](#section-10.3-3){.pilcrow}
:::

::: {#section-10.4 .section}
### [10.4.](#section-10.4){.section-number .selfRef} [EL at Top of Stack](#name-el-at-top-of-stack){.section-name .selfRef} {#name-el-at-top-of-stack}

A slight variant of the reusable EL option is to keep the EL at the top
of the stack rather than below the tunnel label. In this case, each LSR
that is not terminating a segment should continue to keep the received
EL at the top of the stack when forwarding the packet along the segment.
An LSR that terminates a segment should use the EL from the terminated
segment at the top of the stack when forwarding onto the next
segment.[¶](#section-10.4-1){.pilcrow}

This option was rejected due to the significant change in label swap
operations that would be required for existing
hardware.[¶](#section-10.4-2){.pilcrow}
:::

::: {#section-10.5 .section}
### [10.5.](#section-10.5){.section-number .selfRef} [ELs at Readable Label Stack Depths](#name-els-at-readable-label-stack){.section-name .selfRef} {#name-els-at-readable-label-stack}

In this option, the source LSR inserts ELs for tunnels in the label
stack at depths such that each LSR along the path that must load-balance
is able to access at least one EL. Note that the source LSR may have to
insert multiple ELs in the label stack at different depths for this to
work since intermediate LSRs may have differing capabilities in
accessing the depth of a label stack. The label stack depth access value
of intermediate LSRs must be known to create such a label stack. How
this value is determined is outside the scope of this document. This
value can be advertised using a protocol such as an
IGP.[¶](#section-10.5-1){.pilcrow}

Applying this method to the example in [Section 3](#usecase){.xref}, if
LSR P1 needs to have the EL within a depth of 4, then the source label
stack that is LSR S encoded would be \<L_N-P3, ELI, EL, L_A-L1, L_N-D,
ELI, EL>, where all the ELs would typically have the same
value.[¶](#section-10.5-2){.pilcrow}

In the case where the ERLD has different values along the path and the
LSR that is inserting \<ELI, EL> pairs has no limit on how many pairs it
can insert, and it knows the appropriate positions in the stack where
they should be inserted, this option is the same as the recommended
solution in [Section 7](#solution){.xref}.[¶](#section-10.5-3){.pilcrow}

Note that a refinement of this solution, which balances the number of
pushed labels against the desired entropy, is the solution described in
[Section 7](#solution){.xref}.[¶](#section-10.5-4){.pilcrow}
:::
:::
:::

::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-11-1){.pilcrow}
:::

::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

Compared to \[[RFC6790](#RFC6790){.xref}\], this document introduces the
notion of ERLD and MSD, and may require an ingress node to push multiple
ELIs/ELs. These changes do not introduce any new security considerations
beyond those already listed in
\[[RFC6790](#RFC6790){.xref}\].[¶](#section-12-1){.pilcrow}
:::

::: {#section-13 .section}
## [13.](#section-13){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-13.1 .section}
### [13.1.](#section-13.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC6790\]
:   [Kompella, K.]{.refAuthor}[, Drake, J.]{.refAuthor}[,
    Amante, S.]{.refAuthor}[, Henderickx, W.]{.refAuthor}[, and L.
    Yong]{.refAuthor}, [\"The Use of Entropy Labels in MPLS
    Forwarding\"]{.refTitle}, [RFC 6790]{.seriesInfo}, [DOI
    10.17487/RFC6790]{.seriesInfo}, November 2012,
    \<<https://www.rfc-editor.org/info/rfc6790>\>.

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.

\[RFC8402\]
:   [Filsfils, C., Ed.]{.refAuthor}[, Previdi, S., Ed.]{.refAuthor}[,
    Ginsberg, L.]{.refAuthor}[, Decraene, B.]{.refAuthor}[,
    Litkowski, S.]{.refAuthor}[, and R. Shakir]{.refAuthor}, [\"Segment
    Routing Architecture\"]{.refTitle}, [RFC 8402]{.seriesInfo}, [DOI
    10.17487/RFC8402]{.seriesInfo}, July 2018,
    \<<https://www.rfc-editor.org/info/rfc8402>\>.

\[RFC8660\]
:   [Bashandy, A., Ed.]{.refAuthor}[, Filsfils, C., Ed.]{.refAuthor}[,
    Previdi, S.]{.refAuthor}[, Litkowski, S.]{.refAuthor}[, and R.
    Shakir]{.refAuthor}, [\"Segment Routing with the MPLS Data
    Plane\"]{.refTitle}, [RFC 8660]{.seriesInfo}, [DOI
    10.17487/RFC8660]{.seriesInfo}, December 2019,
    \<<https://www.rfc-editor.org/info/rfc8660>\>.
:::

::: {#section-13.2 .section}
### [13.2.](#section-13.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[ISIS-ELC\]
:   [Xu, X.]{.refAuthor}[, Kini, S.]{.refAuthor}[,
    Psenak, P.]{.refAuthor}[, Filsfils, C.]{.refAuthor}[,
    Litkowski, S.]{.refAuthor}[, and M. Bocci]{.refAuthor}, [\"Signaling
    Entropy Label Capability and Entropy Readable Label Depth Using
    IS-IS\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-isis-mpls-elc-10]{.seriesInfo}, 21
    October 2019,
    \<<https://tools.ietf.org/html/draft-ietf-isis-mpls-elc-10>\>.

\[OSPF-ELC\]
:   [Xu, X.]{.refAuthor}[, Kini, S.]{.refAuthor}[,
    Psenak, P.]{.refAuthor}[, Filsfils, C.]{.refAuthor}[,
    Litkowski, S.]{.refAuthor}[, and M. Bocci]{.refAuthor}, [\"Signaling
    Entropy Label Capability and Entropy Readable Label-stack Depth
    Using OSPF\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-ospf-mpls-elc-12]{.seriesInfo}, 25
    October 2019,
    \<<https://tools.ietf.org/html/draft-ietf-ospf-mpls-elc-12>\>.

\[RFC8668\]
:   [Ginsberg, L.]{.refAuthor}[, Bashandy, A.]{.refAuthor}[,
    Filsfils, C.]{.refAuthor}[, Nanduri, M.]{.refAuthor}[, and E.
    Aries]{.refAuthor}, [\"Advertising Layer 2 Bundle Member Link
    Attributes in IS-IS\"]{.refTitle}, [RFC 8668]{.seriesInfo}, [DOI
    10.17487/RFC8668]{.seriesInfo}, December 2019,
    \<<https://www.rfc-editor.org/info/rfc8668>\>.

\[RFC7855\]
:   [Previdi, S., Ed.]{.refAuthor}[, Filsfils, C., Ed.]{.refAuthor}[,
    Decraene, B.]{.refAuthor}[, Litkowski, S.]{.refAuthor}[,
    Horneffer, M.]{.refAuthor}[, and R. Shakir]{.refAuthor}, [\"Source
    Packet Routing in Networking (SPRING) Problem Statement and
    Requirements\"]{.refTitle}, [RFC 7855]{.seriesInfo}, [DOI
    10.17487/RFC7855]{.seriesInfo}, May 2016,
    \<<https://www.rfc-editor.org/info/rfc7855>\>.

\[RFC8476\]
:   [Tantsura, J.]{.refAuthor}[, Chunduri, U.]{.refAuthor}[,
    Aldrin, S.]{.refAuthor}[, and P. Psenak]{.refAuthor}, [\"Signaling
    Maximum SID Depth (MSD) Using OSPF\"]{.refTitle}, [RFC
    8476]{.seriesInfo}, [DOI 10.17487/RFC8476]{.seriesInfo}, December
    2018, \<<https://www.rfc-editor.org/info/rfc8476>\>.

\[RFC8491\]
:   [Tantsura, J.]{.refAuthor}[, Chunduri, U.]{.refAuthor}[,
    Aldrin, S.]{.refAuthor}[, and L. Ginsberg]{.refAuthor}, [\"Signaling
    Maximum SID Depth (MSD) Using IS-IS\"]{.refTitle}, [RFC
    8491]{.seriesInfo}, [DOI 10.17487/RFC8491]{.seriesInfo}, November
    2018, \<<https://www.rfc-editor.org/info/rfc8491>\>.

\[MSD-BGP\]
:   [Tantsura, J.]{.refAuthor}[, Chunduri, U.]{.refAuthor}[,
    Talaulikar, K.]{.refAuthor}[, Mirsky, G.]{.refAuthor}[, and N.
    Triantafillis]{.refAuthor}, [\"Signaling MSD (Maximum SID Depth)
    using Border Gateway Protocol Link-State\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-idr-bgp-ls-segment-routing-msd-09]{.seriesInfo}, 15
    October 2019,
    \<<https://tools.ietf.org/html/draft-ietf-idr-bgp-ls-segment-routing-msd-09>\>.
:::
:::

::: {#section-appendix.a .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

The authors would like to thank John Drake, Loa Andersson, Curtis
Villamizar, Greg Mirsky, Markus Jork, Kamran Raza, Carlos Pignataro,
Bruno Decraene, Chris Bowers, Nobo Akiya, Daniele Ceccarelli, and Joe
Clarke for their review, comments, and
suggestions.[¶](#section-appendix.a-1){.pilcrow}
:::

::: {#section-appendix.b .section}
## [Contributors](#name-contributors){.section-name .selfRef} {#name-contributors}

::: {#section-appendix.b-1 .artwork .art-text .alignLeft}
    Xiaohu Xu
    Huawei
    Email: xuxiaohu@huawei.com

[¶](#section-appendix.b-1){.pilcrow}
:::

::: {#section-appendix.b-2 .artwork .art-text .alignLeft}
    Wim Hendrickx
    Nokia
    Email: wim.henderickx@nokia.com

[¶](#section-appendix.b-2){.pilcrow}
:::

::: {#section-appendix.b-3 .artwork .art-text .alignLeft}
    Gunter Van de Velde
    Nokia
    Email: gunter.van_de_velde@nokia.com

[¶](#section-appendix.b-3){.pilcrow}
:::

::: {#section-appendix.b-4 .artwork .art-text .alignLeft}
    Acee Lindem
    Cisco
    Email: acee@cisco.com

[¶](#section-appendix.b-4){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.c .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Sriganesh Kini]{.fn .nameRole}
:::

::: email
Email: <sriganeshkini@gmail.com>
:::

::: {.left dir="auto"}
[Kireeti Kompella]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Juniper]{.org}
:::

::: email
Email: <kireeti@juniper.net>
:::

::: {.left dir="auto"}
[Siva Sivabalan]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Cisco]{.org}
:::

::: email
Email: <msiva@cisco.com>
:::

::: {.left dir="auto"}
[Stephane Litkowski]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Orange]{.org}
:::

::: email
Email: <slitkows.ietf@gmail.com>
:::

::: {.left dir="auto"}
[Rob Shakir]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google]{.org}
:::

::: email
Email: <robjs@google.com>
:::

::: {.left dir="auto"}
[Jeff Tantsura]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Apstra, Inc.]{.org}
:::

::: email
Email: <jefftant.ietf@gmail.com>
:::
:::
:::
