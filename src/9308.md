  RFC 9308               QUIC Applicability   September 2022
  ---------------------- -------------------- ----------------
  Kühlewind & Trammell   Informational        \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9308](https://www.rfc-editor.org/rfc/rfc9308){.eref}

Category:
:   Informational

Published:
:   September 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    M. Kühlewind
    :::

    ::: org
    Ericsson
    :::
    :::

    ::: author
    ::: author-name
    B. Trammell
    :::

    ::: org
    Google Switzerland GmbH
    :::
    :::
:::

# RFC 9308 {#rfcnum}

# Applicability of the QUIC Transport Protocol {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document discusses the applicability of the QUIC transport
protocol, focusing on caveats impacting application protocol development
and deployment over QUIC. Its intended audience is designers of
application protocol mappings to QUIC and implementors of these
application protocols.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for informational
purposes.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Not all documents approved
by the IESG are candidates for any level of Internet Standard; see
Section 2 of RFC 7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9308>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.auto .internal
    .xref}.  [Introduction](#name-introduction){.internal .xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.auto .internal .xref}.  [The Necessity of
    Fallback](#name-the-necessity-of-fallback){.internal .xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.auto .internal
    .xref}.  [0-RTT](#name-0-rtt){.internal .xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.auto .internal .xref}.  [Replay
        Attacks](#name-replay-attacks){.internal .xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.auto .internal .xref}.  [Session Resumption
        versus Keep-Alive](#name-session-resumption-versus-k){.internal
        .xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.auto .internal .xref}.  [Use of
    Streams](#name-use-of-streams){.internal .xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.auto .internal .xref}.  [Stream versus Flow
        Multiplexing](#name-stream-versus-flow-multiple){.internal
        .xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.auto .internal
        .xref}.  [Prioritization](#name-prioritization){.internal .xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.auto .internal .xref}.  [Ordered and
        Reliable Delivery](#name-ordered-and-reliable-delive){.internal
        .xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.auto .internal .xref}.  [Flow Control
        Deadlocks](#name-flow-control-deadlocks){.internal .xref}
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.auto .internal .xref}.  [Stream Limit
        Commitments](#name-stream-limit-commitments){.internal .xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.auto .internal .xref}.  [Packetization and
    Latency](#name-packetization-and-latency){.internal .xref}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.auto .internal .xref}.  [Error
    Handling](#name-error-handling){.internal .xref}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.auto .internal .xref}.  [Acknowledgment
    Efficiency](#name-acknowledgment-efficiency){.internal .xref}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.auto .internal .xref}.  [Port Selection and
    Application Endpoint
    Discovery](#name-port-selection-and-applicat){.internal .xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.auto .internal .xref}.  [Source Port
        Selection](#name-source-port-selection){.internal .xref}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.auto .internal .xref}.  [Connection
    Migration](#name-connection-migration){.internal .xref}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.auto .internal .xref}. [Connection
    Termination](#name-connection-termination){.internal .xref}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.auto .internal .xref}. [Information Exposure and
    the Connection ID](#name-information-exposure-and-th){.internal
    .xref}

    -   ::: {#section-toc.1-1.11.2.1}
        [11.1](#section-11.1){.auto .internal .xref}.  [Server-Generated
        Connection ID](#name-server-generated-connection){.internal
        .xref}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [11.2](#section-11.2){.auto .internal .xref}.  [Mitigating
        Timing Linkability with Connection ID
        Migration](#name-mitigating-timing-linkabili){.internal .xref}
        :::

    -   ::: {#section-toc.1-1.11.2.3}
        [11.3](#section-11.3){.auto .internal .xref}.  [Using Server
        Retry for
        Redirection](#name-using-server-retry-for-redi){.internal .xref}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.auto .internal .xref}. [Quality of Service (QoS)
    and Diffserv Code Point
    (DSCP)](#name-quality-of-service-qos-and-){.internal .xref}
    :::

-   ::: {#section-toc.1-1.13}
    [13](#section-13){.auto .internal .xref}. [Use of Versions and
    Cryptographic
    Handshake](#name-use-of-versions-and-cryptog){.internal .xref}
    :::

-   ::: {#section-toc.1-1.14}
    [14](#section-14){.auto .internal .xref}. [Enabling Deployment of
    New Versions](#name-enabling-deployment-of-new-){.internal .xref}
    :::

-   ::: {#section-toc.1-1.15}
    [15](#section-15){.auto .internal .xref}. [Unreliable Datagram
    Service over QUIC](#name-unreliable-datagram-service){.internal
    .xref}
    :::

-   ::: {#section-toc.1-1.16}
    [16](#section-16){.auto .internal .xref}. [IANA
    Considerations](#name-iana-considerations){.internal .xref}
    :::

-   ::: {#section-toc.1-1.17}
    [17](#section-17){.auto .internal .xref}. [Security
    Considerations](#name-security-considerations){.internal .xref}
    :::

-   ::: {#section-toc.1-1.18}
    [18](#section-18){.auto .internal
    .xref}. [References](#name-references){.internal .xref}

    -   ::: {#section-toc.1-1.18.2.1}
        [18.1](#section-18.1){.auto .internal .xref}.  [Normative
        References](#name-normative-references){.internal .xref}
        :::

    -   ::: {#section-toc.1-1.18.2.2}
        [18.2](#section-18.2){.auto .internal .xref}.  [Informative
        References](#name-informative-references){.internal .xref}
        :::
    :::

-   ::: {#section-toc.1-1.19}
    [](#appendix-A){.auto .internal
    .xref}[Acknowledgments](#name-acknowledgments){.internal .xref}
    :::

-   ::: {#section-toc.1-1.20}
    [](#appendix-B){.auto .internal
    .xref}[Contributors](#name-contributors){.internal .xref}
    :::

-   ::: {#section-toc.1-1.21}
    [](#appendix-C){.auto .internal .xref}[Authors\'
    Addresses](#name-authors-addresses){.internal .xref}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

QUIC \[[QUIC](#RFC9000){.cite .xref}\] is a new transport protocol
providing a number of advanced features. While initially designed for
the HTTP use case, it provides capabilities that can be used with a much
wider variety of applications. QUIC is encapsulated in UDP. QUIC version
1 integrates TLS 1.3 \[[TLS13](#RFC8446){.cite .xref}\] to encrypt all
payload data and most control information. The version of HTTP that uses
QUIC is known as HTTP/3 \[[QUIC-HTTP](#RFC9114){.cite
.xref}\].[¶](#section-1-1){.pilcrow}

This document provides guidance for application developers who want to
use the QUIC protocol without implementing it on their own. This
includes general guidance for applications operating over HTTP/3 or
directly over QUIC.[¶](#section-1-2){.pilcrow}

In the following sections, we discuss specific caveats to QUIC\'s
applicability and issues that application developers must consider when
using QUIC as a transport for their
applications.[¶](#section-1-3){.pilcrow}
:::
:::

::: {#fallback}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [The Necessity of Fallback](#name-the-necessity-of-fallback){.section-name .selfRef} {#name-the-necessity-of-fallback}

QUIC uses UDP as a substrate. This enables userspace implementation and
permits traversal of network middleboxes (including NAT) without
requiring updates to existing network
infrastructure.[¶](#section-2-1){.pilcrow}

Measurement studies have shown between 3%
\[[Trammell16](#Trammell16){.cite .xref}\] and 5%
\[[Swett16](#Swett16){.cite .xref}\] of networks block all UDP traffic,
though there is little evidence of other forms of systematic
disadvantage to UDP traffic compared to TCP
\[[Edeline16](#Edeline16){.cite .xref}\]. This blocking implies that all
applications running on top of QUIC must either be prepared to accept
connectivity failure on such networks or be engineered to fall back to
some other transport protocol. In the case of HTTP, this fallback is TLS
over TCP.[¶](#section-2-2){.pilcrow}

The IETF Transport Services (TAPS) specifications
\[[TAPS-ARCH](#I-D.ietf-taps-arch){.cite .xref}\] describe a system with
a common API for multiple protocols. This is particularly relevant for
QUIC as it addresses the implications of fallback among multiple
protocols.[¶](#section-2-3){.pilcrow}

Specifically, fallback to insecure protocols or to weaker versions of
secure protocols needs to be avoided. In general, an application that
implements fallback needs to consider the security consequences. A
fallback to TCP and TLS exposes control information to modification and
manipulation in the network. Additionally, downgrades to TLS versions
older than 1.3, which is used in QUIC version 1, might result in
significantly weaker cryptographic protection. For example, the results
of protocol negotiation \[[RFC7301](#RFC7301){.cite .xref}\] only have
confidentiality protection if TLS 1.3 is
used.[¶](#section-2-4){.pilcrow}

These applications must operate, perhaps with impaired functionality, in
the absence of features provided by QUIC not present in the fallback
protocol. For fallback to TLS over TCP, the most obvious difference is
that TCP does not provide stream multiplexing, and therefore stream
multiplexing would need to be implemented in the application layer if
needed. Further, TCP implementations and network paths often do not
support the TCP Fast Open (TFO) option \[[RFC7413](#RFC7413){.cite
.xref}\], which enables sending of payload data together with the first
control packet of a new connection as also provided by 0-RTT session
resumption in QUIC. Note that there is some evidence of middleboxes
blocking SYN data even if TFO was successfully negotiated (see
\[[PaaschNanog](#PaaschNanog){.cite .xref}\]). And even if Fast Open
successfully operates end to end, it is limited to a single packet of
TLS handshake and application data, unlike QUIC
0-RTT.[¶](#section-2-5){.pilcrow}

Moreover, while encryption (in this case TLS) is inseparably integrated
with QUIC, TLS negotiation over TCP can be blocked. If TLS over TCP
cannot be supported, the connection should be aborted, and the
application then ought to present a suitable prompt to the user that
secure communication is unavailable.[¶](#section-2-6){.pilcrow}

In summary, any fallback mechanism is likely to impose a degradation of
performance and can degrade security; however, fallback must not
silently violate the application\'s expectation of confidentiality or
integrity of its payload data.[¶](#section-2-7){.pilcrow}
:::
:::

::: {#zero-rtt}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [0-RTT](#name-0-rtt){.section-name .selfRef} {#name-0-rtt}

QUIC provides for 0-RTT connection establishment. Though the same
facility exists in TLS 1.3 with TCP, 0-RTT presents opportunities and
challenges for applications using QUIC.[¶](#section-3-1){.pilcrow}

A transport protocol that provides 0-RTT connection establishment is
qualitatively different from one that does not provide 0-RTT from the
point of view of the application using it. Relative trade-offs between
the cost of closing and reopening a connection and trying to keep it
open are different; see [Section 3.2](#resumption-v-keepalive){.auto
.internal .xref}.[¶](#section-3-2){.pilcrow}

An application needs to deliberately choose to use 0-RTT, as 0-RTT
carries a risk of replay attack. Application protocols that use 0-RTT
require a profile that describes the types of information that can be
safely sent. For HTTP, this profile is described in
\[[HTTP-REPLAY](#RFC8470){.cite .xref}\].[¶](#section-3-3){.pilcrow}

::: {#replay-attacks}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Replay Attacks](#name-replay-attacks){.section-name .selfRef} {#name-replay-attacks}

Retransmission or malicious replay of data contained in 0-RTT packets
could cause the server side to receive multiple copies of the same
data.[¶](#section-3.1-1){.pilcrow}

Application data sent by the client in 0-RTT packets could be processed
more than once if it is replayed. Applications need to be aware of what
is safe to send in 0-RTT. Application protocols that seek to enable the
use of 0-RTT need a careful analysis and a description of what can be
sent in 0-RTT; see [Section
5.6](https://www.rfc-editor.org/rfc/rfc9001#section-5.6){.relref} of
\[[QUIC-TLS](#RFC9001){.cite .xref}\].[¶](#section-3.1-2){.pilcrow}

In some cases, it might be sufficient to limit application data sent in
0-RTT to data that does not cause actions with lasting effects at a
server. Initiating data retrieval or establishing configuration are
examples of actions that could be safe. Idempotent operations \-- those
for which repetition has the same net effect as a single operation \--
might be safe. However, it is also possible to combine individually
idempotent operations into a non-idempotent sequence of
operations.[¶](#section-3.1-3){.pilcrow}

Once a server accepts 0-RTT data, there is no means of selectively
discarding data that is received. However, protocols can define ways to
reject individual actions that might be unsafe if
replayed.[¶](#section-3.1-4){.pilcrow}

Some TLS implementations and deployments might be able to provide
partial or even complete replay protection, which could be used to
manage replay risk.[¶](#section-3.1-5){.pilcrow}
:::
:::

::: {#resumption-v-keepalive}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Session Resumption versus Keep-Alive](#name-session-resumption-versus-k){.section-name .selfRef} {#name-session-resumption-versus-k}

Because QUIC is encapsulated in UDP, applications using QUIC must deal
with short network idle timeouts. Deployed stateful middleboxes will
generally establish state for UDP flows on the first packet sent and
keep state for much shorter idle periods than for TCP.
\[[RFC5382](#RFC5382){.cite .xref}\] suggests a TCP idle period of at
least 124 minutes, though there is no evidence of widespread
implementation of this guideline in the literature. However, short
network timeout for UDP is well-documented. According to a 2010 study
(\[[Hatonen10](#Hatonen10){.cite .xref}\]), UDP applications can assume
that any NAT binding or other state entry can expire after just thirty
seconds of inactivity. [Section
3.5](https://www.rfc-editor.org/rfc/rfc8085#section-3.5){.relref} of
\[[RFC8085](#RFC8085){.cite .xref}\] further discusses keep-alive
intervals for UDP: it requires that there is a minimum value of 15
seconds, but recommends larger values, or that keep-alive is omitted
entirely.[¶](#section-3.2-1){.pilcrow}

By using a connection ID, QUIC is designed to be robust to NAT rebinding
after a timeout. However, this only helps if one endpoint maintains
availability at the address its peer uses and the peer is the one to
send after the timeout occurs.[¶](#section-3.2-2){.pilcrow}

Some QUIC connections might not be robust to NAT rebinding because the
routing infrastructure (in particular, load balancers) uses the
address/port 4-tuple to direct traffic. Furthermore, middleboxes with
functions other than address translation could still affect the path. In
particular, some firewalls do not admit server traffic for which the
firewall has no recent state for a corresponding packet sent from the
client.[¶](#section-3.2-3){.pilcrow}

QUIC applications can adjust idle periods to manage the risk of timeout.
Idle periods and the network idle timeout are distinct from the
connection idle timeout, which is defined as the minimum of either
endpoint\'s idle timeout parameter; see [Section
10.1](https://www.rfc-editor.org/rfc/rfc9000#section-10.1){.relref} of
\[[QUIC](#RFC9000){.cite .xref}\]. There are three
options:[¶](#section-3.2-4){.pilcrow}

-   [Ignore the issue if the application-layer protocol consists only of
    interactions with no or very short idle periods or if the
    protocol\'s resistance to NAT rebinding is
    sufficient.[¶](#section-3.2-5.1){.pilcrow}]{#section-3.2-5.1}
-   [Ensure there are no long idle
    periods.[¶](#section-3.2-5.2){.pilcrow}]{#section-3.2-5.2}
-   [Resume the session after a long idle period, using 0-RTT resumption
    when appropriate.[¶](#section-3.2-5.3){.pilcrow}]{#section-3.2-5.3}

The first strategy is the easiest, but it only applies to certain
applications.[¶](#section-3.2-6){.pilcrow}

Either the server or the client in a QUIC application can send PING
frames as keep-alives to prevent the connection and any on-path state
from timing out. Recommendations for the use of keep-alives are
application specific, mainly depending on the latency requirements and
message frequency of the application. In this case, the application
mapping must specify whether the client or server is responsible for
keeping the application alive. While \[[Hatonen10](#Hatonen10){.cite
.xref}\] suggests that 30 seconds might be a suitable value for the
public Internet when a NAT is on path, larger values are preferable if
the deployment can consistently survive NAT rebinding or is known to be
in a controlled environment (e.g., data centers) in order to lower
network and computational load.[¶](#section-3.2-7){.pilcrow}

Sending PING frames more frequently than every 30 seconds over long idle
periods may result in excessive unproductive traffic in some situations
and unacceptable power usage for power-constrained (mobile) devices.
Additionally, timeouts shorter than 30 seconds can make it harder to
handle transient network interruptions, such as Virtual Machine (VM)
migration or coverage loss during mobility. See
\[[RFC8085](#RFC8085){.cite .xref}\], especially Section
[3.5](https://www.rfc-editor.org/rfc/rfc8085#section-3.5){.relref}.[¶](#section-3.2-8){.pilcrow}

Alternatively, the client (but not the server) can use session
resumption instead of sending keep-alive traffic. In this case, a client
that wants to send data to a server over a connection that has been idle
longer than the server\'s idle timeout (available from the idle_timeout
transport parameter) can simply reconnect. When possible, this
reconnection can use 0-RTT session resumption, reducing the latency
involved with restarting the connection. Of course, this approach is
only valid in cases in which it is safe to use 0-RTT and when the client
is the restarting peer.[¶](#section-3.2-9){.pilcrow}

The trade-offs between resumption and keep-alives need to be evaluated
on a per-application basis. In general, applications should use
keep-alives only in circumstances where continued communication is
highly likely; \[[QUIC-HTTP](#RFC9114){.cite .xref}\], for instance,
recommends using keep-alives only when a request is
outstanding.[¶](#section-3.2-10){.pilcrow}
:::
:::
:::
:::

::: {#use-of-streams}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Use of Streams](#name-use-of-streams){.section-name .selfRef} {#name-use-of-streams}

QUIC\'s stream multiplexing feature allows applications to run multiple
streams over a single connection without head-of-line blocking between
streams. Stream data is carried within frames where one QUIC packet on
the wire can carry one or multiple stream
frames.[¶](#section-4-1){.pilcrow}

Streams can be unidirectional or bidirectional, and a stream may be
initiated either by client or server. Only the initiator of a
unidirectional stream can send data on it.[¶](#section-4-2){.pilcrow}

Streams and connections can each carry a maximum of 2^62^-1 bytes in
each direction due to encoding limitations on stream offsets and
connection flow control limits. In the presently unlikely event that
this limit is reached by an application, a new connection would need to
be established.[¶](#section-4-3){.pilcrow}

Streams can be independently opened and closed, gracefully or abruptly.
An application can gracefully close the egress direction of a stream by
instructing QUIC to send a FIN bit in a STREAM frame. It cannot
gracefully close the ingress direction without a peer-generated FIN,
much like in TCP. However, an endpoint can abruptly close the egress
direction or request that its peer abruptly close the ingress direction;
these actions are fully independent of each
other.[¶](#section-4-4){.pilcrow}

QUIC does not provide an interface for exceptional handling of any
stream. If a stream that is critical for an application is closed, the
application can generate error messages on the application layer to
inform the other end and/or the higher layer, which can eventually
terminate the QUIC connection.[¶](#section-4-5){.pilcrow}

Mapping of application data to streams is application specific and
described for HTTP/3 in \[[QUIC-HTTP](#RFC9114){.cite .xref}\]. There
are a few general principles to apply when designing an application\'s
use of streams:[¶](#section-4-6){.pilcrow}

-   [A single stream provides ordering. If the application requires
    certain data to be received in order, that data should be sent on
    the same stream. There is no guarantee of transmission, reception,
    or delivery order across
    streams.[¶](#section-4-7.1){.pilcrow}]{#section-4-7.1}
-   [Multiple streams provide concurrency. Data that can be processed
    independently, and therefore would suffer from head-of-line blocking
    if forced to be received in order, should be transmitted over
    separate streams.[¶](#section-4-7.2){.pilcrow}]{#section-4-7.2}
-   [Streams can provide message orientation and allow messages to be
    canceled. If one message is mapped to a single stream, resetting the
    stream to expire an unacknowledged message can be used to emulate
    partial reliability for that
    message.[¶](#section-4-7.3){.pilcrow}]{#section-4-7.3}

If a QUIC receiver has opened the maximum allowed concurrent streams,
and the sender indicates that more streams are needed, it does not
automatically lead to an increase of the maximum number of streams by
the receiver. Therefore, an application should consider the maximum
number of allowed, currently open, and currently used streams when
determining how to map data to streams.[¶](#section-4-8){.pilcrow}

QUIC assigns a numerical identifier, called the stream ID, to each
stream. While the relationship between these identifiers and stream
types is clearly defined in version 1 of QUIC, future versions might
change this relationship for various reasons. QUIC implementations
should expose the properties of each stream (which endpoint initiated
the stream, whether the stream is unidirectional or bidirectional, the
stream ID used for the stream); applications should query for these
properties rather than attempting to infer them from the stream
ID.[¶](#section-4-9){.pilcrow}

The method of allocating stream identifiers to streams opened by the
application might vary between transport implementations. Therefore, an
application should not assume a particular stream ID will be assigned to
a stream that has not yet been allocated. For example, HTTP/3 uses
stream IDs to refer to streams that have already been opened but makes
no assumptions about future stream IDs or the way in which they are
assigned (see [Section
6](https://www.rfc-editor.org/rfc/rfc9114#section-6){.relref} of
\[[QUIC-HTTP](#RFC9114){.cite .xref}\]).[¶](#section-4-10){.pilcrow}

::: {#stream-versus-flow-multiplexing}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Stream versus Flow Multiplexing](#name-stream-versus-flow-multiple){.section-name .selfRef} {#name-stream-versus-flow-multiple}

Streams are meaningful only to the application; since stream information
is carried inside QUIC\'s encryption boundary, a given packet exposes no
information about which stream(s) are carried within the packet.
Therefore, stream multiplexing is not intended to be used for
differentiating streams in terms of network treatment. Application
traffic requiring different network treatment should therefore be
carried over different 5-tuples (i.e., multiple QUIC connections). Given
QUIC\'s ability to send application data in the first RTT of a
connection (if a previous connection to the same host has been
successfully established to provide the necessary credentials), the cost
of establishing another connection is extremely
low.[¶](#section-4.1-1){.pilcrow}
:::
:::

::: {#prioritization}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Prioritization](#name-prioritization){.section-name .selfRef} {#name-prioritization}

Stream prioritization is not exposed to either the network or the
receiver. Prioritization is managed by the sender, and the QUIC
transport should provide an interface for applications to prioritize
streams \[[QUIC](#RFC9000){.cite .xref}\]. Applications can implement
their own prioritization scheme on top of QUIC: an application protocol
that runs on top of QUIC can define explicit messages for signaling
priority, such as those defined in \[[RFC9218](#RFC9218){.cite .xref}\]
for HTTP. An application protocol can define rules that allow an
endpoint to determine priority based on context or can provide a
higher-level interface and leave the determination to the application on
top.[¶](#section-4.2-1){.pilcrow}

Priority handling of retransmissions can be implemented by the sender in
the transport layer. \[[QUIC](#RFC9000){.cite .xref}\] recommends
retransmitting lost data before new data, unless indicated differently
by the application. When a QUIC endpoint uses fully reliable streams for
transmission, prioritization of retransmissions will be beneficial in
most cases, filling in gaps and freeing up the flow control window. For
partially reliable or unreliable streams, priority scheduling of
retransmissions over data of higher-priority streams might not be
desirable. For such streams, QUIC could either provide an explicit
interface to control prioritization or derive the prioritization
decision from the reliability level of the
stream.[¶](#section-4.2-2){.pilcrow}
:::
:::

::: {#ordered-and-reliable-delivery}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Ordered and Reliable Delivery](#name-ordered-and-reliable-delive){.section-name .selfRef} {#name-ordered-and-reliable-delive}

QUIC streams enable ordered and reliable delivery. Though it is possible
for an implementation to provide options that use streams for partial
reliability or out-of-order delivery, most implementations will assume
that data is reliably delivered in order.[¶](#section-4.3-1){.pilcrow}

Under this assumption, an endpoint that receives stream data might not
make forward progress until data that is contiguous with the start of a
stream is available. In particular, a receiver might withhold flow
control credit until contiguous data is delivered to the application;
see [Section
2.2](https://www.rfc-editor.org/rfc/rfc9000#section-2.2){.relref} of
\[[QUIC](#RFC9000){.cite .xref}\]. To support this receive logic, an
endpoint will send stream data until it is acknowledged, ensuring that
data at the start of the stream is sent and acknowledged
first.[¶](#section-4.3-2){.pilcrow}

An endpoint that uses a different sending behavior and does not
negotiate that change with its peer might encounter performance issues
or deadlocks.[¶](#section-4.3-3){.pilcrow}
:::
:::

::: {#flow-control-deadlocks}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Flow Control Deadlocks](#name-flow-control-deadlocks){.section-name .selfRef} {#name-flow-control-deadlocks}

QUIC flow control ([Section
4](https://www.rfc-editor.org/rfc/rfc9000#section-4){.relref} of
\[[QUIC](#RFC9000){.cite .xref}\]) provides a means of managing access
to the limited buffers that endpoints have for incoming data. This
mechanism limits the amount of data that can be in buffers in endpoints
or in transit on the network. However, there are several ways in which
limits can produce conditions that can cause a connection to either
perform suboptimally or become deadlocked.[¶](#section-4.4-1){.pilcrow}

Deadlocks in flow control are possible for any protocol that uses QUIC,
though whether they become a problem depends on how implementations
consume data and provide flow control credit. Understanding what causes
deadlocking might help implementations avoid
deadlocks.[¶](#section-4.4-2){.pilcrow}

The size and rate of updates to flow control credit can affect
performance. Applications that use QUIC often have a data consumer that
reads data from transport buffers. Some implementations might have
independent receive buffers at the transport layer and application
layer. Consuming data does not always imply it is immediately processed.
However, a common implementation technique is to extend flow control
credit to the sender by emitting MAX_DATA and/or MAX_STREAM_DATA frames
as data is consumed. Delivery of these frames is affected by the latency
of the back channel from the receiver to the data sender. If credit is
not extended in a timely manner, the sending application can be blocked,
effectively throttling the sender.[¶](#section-4.4-3){.pilcrow}

Large application messages can produce deadlocking if the recipient does
not read data from the transport incrementally. If the message is larger
than the flow control credit available and the recipient does not
release additional flow control credit until the entire message is
received and delivered, a deadlock can occur. This is possible even
where stream flow control limits are not reached because connection flow
control limits can be consumed by other
streams.[¶](#section-4.4-4){.pilcrow}

A length-prefixed message format makes it easier for a data consumer to
leave data unread in the transport buffer and thereby withhold flow
control credit. If flow control limits prevent the remainder of a
message from being sent, a deadlock will result. A length prefix might
also enable the detection of this sort of deadlock. Where application
protocols have messages that might be processed as a single unit,
reserving flow control credit for the entire message atomically makes
this style of deadlock less likely.[¶](#section-4.4-5){.pilcrow}

A data consumer can eagerly read all data as it becomes available in
order to make the receiver extend flow control credit and reduce the
chances of a deadlock. However, such a data consumer might need other
means for holding a peer accountable for the additional state it keeps
for partially processed messages.[¶](#section-4.4-6){.pilcrow}

Deadlocking can also occur if data on different streams is
interdependent. Suppose that data on one stream arrives before the data
on a second stream on which it depends. A deadlock can occur if the
first stream is left unread, preventing the receiver from extending flow
control credit for the second stream. To reduce the likelihood of
deadlock for interdependent data, the sender should ensure that
dependent data is not sent until the data it depends on has been
accounted for in both stream- and connection-level flow control
credit.[¶](#section-4.4-7){.pilcrow}

Some deadlocking scenarios might be resolved by canceling affected
streams with STOP_SENDING or RESET_STREAM. Canceling some streams
results in the connection being terminated in some
protocols.[¶](#section-4.4-8){.pilcrow}
:::
:::

::: {#stream-limit-commitments}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [Stream Limit Commitments](#name-stream-limit-commitments){.section-name .selfRef} {#name-stream-limit-commitments}

QUIC endpoints are responsible for communicating the cumulative limit of
streams they would allow to be opened by their peer. Initial limits are
advertised using the initial_max_streams_bidi and
initial_max_streams_uni transport parameters. As streams are opened and
closed, they are consumed, and the cumulative total is incremented.
Limits can be increased using the MAX_STREAMS frame, but there is no
mechanism to reduce limits. Once stream limits are reached, no more
streams can be opened, which prevents applications using QUIC from
making further progress. At this stage, connections can be terminated
via idle timeout or explicit close; see [Section
10](#sec-termination){.auto .internal
.xref}.[¶](#section-4.5-1){.pilcrow}

An application that uses QUIC and communicates a cumulative stream limit
might require the connection to be closed before the limit is reached,
e.g., to stop the server in order to perform scheduled maintenance.
Immediate connection close causes abrupt closure of actively used
streams. Depending on how an application uses QUIC streams, this could
be undesirable or detrimental to behavior or
performance.[¶](#section-4.5-2){.pilcrow}

A more graceful closure technique is to stop sending increases to stream
limits and allow the connection to naturally terminate once remaining
streams are consumed. However, the period of time it takes to do so is
dependent on the peer, and an unpredictable closing period might not fit
application or operational needs. Applications using QUIC can be
conservative with open stream limits in order to reduce the commitment
and indeterminism. However, being overly conservative with stream limits
affects stream concurrency. Balancing these aspects can be specific to
applications and their deployments.[¶](#section-4.5-3){.pilcrow}

Instead of relying on stream limits to avoid abrupt closure, an
application layer\'s graceful close mechanism can be used to communicate
the intention to explicitly close the connection at some future point.
HTTP/3 provides such a mechanism using the GOAWAY frame. In HTTP/3, when
the GOAWAY frame is received by a client, it stops opening new streams
even if the cumulative stream limit would allow. Instead, the client
would create a new connection on which to open further streams. Once all
streams are closed on the old connection, it can be terminated safely by
a connection close or after expiration of the idle timeout (see [Section
10](#sec-termination){.auto .internal
.xref}).[¶](#section-4.5-4){.pilcrow}
:::
:::
:::
:::

::: {#packetization-and-latency}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Packetization and Latency](#name-packetization-and-latency){.section-name .selfRef} {#name-packetization-and-latency}

QUIC exposes an interface that provides multiple streams to the
application; however, the application usually cannot control how data
transmitted over those streams is mapped into frames or how those frames
are bundled into packets.[¶](#section-5-1){.pilcrow}

By default, many implementations will try to pack STREAM frames from one
or more streams into each QUIC packet, in order to minimize bandwidth
consumption and computational costs (see [Section
13](https://www.rfc-editor.org/rfc/rfc9000#section-13){.relref} of
\[[QUIC](#RFC9000){.cite .xref}\]). If there is not enough data
available to fill a packet, an implementation might wait for a short
time to optimize bandwidth efficiency instead of latency. This delay can
either be preconfigured or dynamically adjusted based on the observed
sending pattern of the application.[¶](#section-5-2){.pilcrow}

If the application requires low latency, with only small chunks of data
to send, it may be valuable to indicate to QUIC that all data should be
sent out immediately. Alternatively, if the application expects to use a
specific sending pattern, it can also provide a suggested delay to QUIC
for how long to wait before bundling frames into a
packet.[¶](#section-5-3){.pilcrow}

Similarly, an application usually has no control over the length of a
QUIC packet on the wire. QUIC provides the ability to add a PADDING
frame to arbitrarily increase the size of packets. Padding is used by
QUIC to ensure that the path is capable of transferring datagrams of at
least a certain size during the handshake (see Sections
[8.1](https://www.rfc-editor.org/rfc/rfc9000#section-8.1){.relref} and
[14.1](https://www.rfc-editor.org/rfc/rfc9000#section-14.1){.relref} of
\[[QUIC](#RFC9000){.cite .xref}\]) and for path validation after
connection migration (see [Section
8.2](https://www.rfc-editor.org/rfc/rfc9000#section-8.2){.relref} of
\[[QUIC](#RFC9000){.cite .xref}\]) as well as for Datagram Packetization
Layer PMTU Discovery (DPLPMTUD) (see [Section
14.3](https://www.rfc-editor.org/rfc/rfc9000#section-14.3){.relref} of
\[[QUIC](#RFC9000){.cite .xref}\]).[¶](#section-5-4){.pilcrow}

Padding can also be used by an application to reduce leakage of
information about the data that is sent. A QUIC implementation can
expose an interface that allows an application layer to specify how to
apply padding.[¶](#section-5-5){.pilcrow}
:::
:::

::: {#error-handling}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Error Handling](#name-error-handling){.section-name .selfRef} {#name-error-handling}

QUIC recommends that endpoints signal any detected errors to the peer.
Errors can occur at the transport layer and the application layer.
Transport errors, such as a protocol violation, affect the entire
connection. Applications that use QUIC can define their own error
detection and signaling (see, for example, [Section
8](https://www.rfc-editor.org/rfc/rfc9114#section-8){.relref} of
\[[QUIC-HTTP](#RFC9114){.cite .xref}\]). Application errors can affect
an entire connection or a single stream.[¶](#section-6-1){.pilcrow}

QUIC defines an error code space that is used for error handling at the
transport layer. QUIC encourages endpoints to use the most specific
code, although any applicable code is permitted, including generic
ones.[¶](#section-6-2){.pilcrow}

Applications using QUIC define an error code space that is independent
of QUIC or other applications (see, for example, [Section
8.1](https://www.rfc-editor.org/rfc/rfc9114#section-8.1){.relref} of
\[[QUIC-HTTP](#RFC9114){.cite .xref}\]). The values in an application
error code space can be reused across connection-level and stream-level
errors.[¶](#section-6-3){.pilcrow}

Connection errors lead to connection termination. They are signaled
using a CONNECTION_CLOSE frame, which contains an error code and a
reason field that can be zero length. Different types of
CONNECTION_CLOSE frames are used to signal transport and application
errors.[¶](#section-6-4){.pilcrow}

Stream errors lead to stream termination. These are signaled using
STOP_SENDING or RESET_STREAM frames, which contain only an error
code.[¶](#section-6-5){.pilcrow}
:::
:::

::: {#acknowledgment-efficiency}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Acknowledgment Efficiency](#name-acknowledgment-efficiency){.section-name .selfRef} {#name-acknowledgment-efficiency}

QUIC version 1 without extensions uses an acknowledgment strategy
adopted from TCP (see [Section
13.2](https://www.rfc-editor.org/rfc/rfc9000#section-13.2){.relref} of
\[[QUIC](#RFC9000){.cite .xref}\]). That is, it recommends that every
other packet is acknowledged. However, generating and processing QUIC
acknowledgments consumes resources at a sender and receiver.
Acknowledgments also incur forwarding costs and contribute to link
utilization, which can impact performance over some types of network.
Applications might be able to improve overall performance by using
alternative strategies that reduce the rate of acknowledgments.
\[[QUIC-ACK-FREQUENCY](#I-D.ietf-quic-ack-frequency){.cite .xref}\]
describes an extension to signal the desired delay of acknowledgments
and discusses use cases as well as implications for congestion control
and recovery.[¶](#section-7-1){.pilcrow}
:::
:::

::: {#ports}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Port Selection and Application Endpoint Discovery](#name-port-selection-and-applicat){.section-name .selfRef} {#name-port-selection-and-applicat}

In general, port numbers serve two purposes: \"first, they provide a
demultiplexing identifier to differentiate transport sessions between
the same pair of endpoints, and second, they may also identify the
application protocol and associated service to which processes connect\"
([Section 3](https://www.rfc-editor.org/rfc/rfc6335#section-3){.relref}
of \[[RFC6335](#RFC6335){.cite .xref}\]). The assumption that an
application can be identified in the network based on the port number is
less true today due to encapsulation and mechanisms for dynamic port
assignments, as noted in \[[RFC6335](#RFC6335){.cite
.xref}\].[¶](#section-8-1){.pilcrow}

As QUIC is a general-purpose transport protocol, there are no
requirements that servers use a particular UDP port for QUIC. For an
application with a fallback to TCP that does not already have an
alternate mapping to UDP, it is usually appropriate to register (if
necessary) and use the UDP port number corresponding to the TCP port
already registered for the application. For example, the default port
for HTTP/3 \[[QUIC-HTTP](#RFC9114){.cite .xref}\] is UDP port 443,
analogous to HTTP/1.1 or HTTP/2 over TLS over
TCP.[¶](#section-8-2){.pilcrow}

Given the prevalence of the assumption in network management practice
that a port number maps unambiguously to an application, the use of
ports that cannot easily be mapped to a registered service name might
lead to blocking or other changes to the forwarding behavior by network
elements such as firewalls that use the port number for application
identification.[¶](#section-8-3){.pilcrow}

Applications could define an alternate endpoint discovery mechanism to
allow the usage of ports other than the default. For example, HTTP/3
(Sections
[3.2](https://www.rfc-editor.org/rfc/rfc9114#section-3.2){.relref} and
[3.3](https://www.rfc-editor.org/rfc/rfc9114#section-3.3){.relref} of
\[[QUIC-HTTP](#RFC9114){.cite .xref}\]) specifies the use of HTTP
Alternative Services \[[RFC7838](#RFC7838){.cite .xref}\] for an HTTP
origin to advertise the availability of an equivalent HTTP/3 endpoint on
a certain UDP port by using \"h3\" as the Application-Layer Protocol
Negotiation (ALPN) \[[RFC7301](#RFC7301){.cite .xref}\]
token.[¶](#section-8-4){.pilcrow}

ALPN permits the client and server to negotiate which of several
protocols will be used on a given connection. Therefore, multiple
applications might be supported on a single UDP port based on the ALPN
token offered. Applications using QUIC are required to register an ALPN
token for use in the TLS handshake.[¶](#section-8-5){.pilcrow}

As QUIC version 1 deferred defining a complete version negotiation
mechanism, HTTP/3 requires QUIC version 1 and defines the ALPN token
(\"h3\") to only apply to that version. So far, no single approach has
been selected for managing the use of different QUIC versions, neither
in HTTP/3 nor in general. Application protocols that use QUIC need to
consider how the protocol will manage different QUIC versions. Decisions
for those protocols might be informed by choices made by other
protocols, like HTTP/3.[¶](#section-8-6){.pilcrow}

::: {#source-port-selection}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Source Port Selection](#name-source-port-selection){.section-name .selfRef} {#name-source-port-selection}

Some UDP protocols are vulnerable to reflection attacks, where an
attacker is able to direct traffic to a third party as a denial of
service. For example, these source ports are associated with
applications known to be vulnerable to reflection attacks, often due to
server misconfiguration:[¶](#section-8.1-1){.pilcrow}

-   [port 53 - DNS \[[RFC1034](#RFC1034){.cite
    .xref}\][¶](#section-8.1-2.1){.pilcrow}]{#section-8.1-2.1}
-   [port 123 - NTP \[[RFC5905](#RFC5905){.cite
    .xref}\][¶](#section-8.1-2.2){.pilcrow}]{#section-8.1-2.2}
-   [port 1900 - SSDP \[[SSDP](#SSDP){.cite
    .xref}\][¶](#section-8.1-2.3){.pilcrow}]{#section-8.1-2.3}
-   [port 5353 - mDNS \[[RFC6762](#RFC6762){.cite
    .xref}\][¶](#section-8.1-2.4){.pilcrow}]{#section-8.1-2.4}
-   [port 11211 -
    memcache[¶](#section-8.1-2.5){.pilcrow}]{#section-8.1-2.5}

Services might block source ports associated with protocols known to be
vulnerable to reflection attacks to avoid the overhead of processing
large numbers of packets. However, this practice has negative effects on
clients \-- not only does it require establishment of a new connection
but in some instances might cause the client to avoid using QUIC for
that service for a period of time and downgrade to a non-UDP protocol
(see [Section 2](#fallback){.auto .internal
.xref}).[¶](#section-8.1-3){.pilcrow}

As a result, client implementations are encouraged to avoid using source
ports associated with protocols known to be vulnerable to reflection
attacks. Note that following the general guidance for client
implementations given in \[[RFC6335](#RFC6335){.cite .xref}\], to use
ephemeral ports in the range 49152-65535, has the effect of avoiding
these ports. Note that other source ports might be reflection vectors as
well.[¶](#section-8.1-4){.pilcrow}
:::
:::
:::
:::

::: {#connection-migration}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Connection Migration](#name-connection-migration){.section-name .selfRef} {#name-connection-migration}

QUIC supports connection migration by the client. If the client\'s IP
address changes, a QUIC endpoint can still associate packets with an
existing transport connection using the Destination Connection ID field
(see [Section 11](#connid){.auto .internal .xref}) in the QUIC header.
This supports cases where the address information changes, such as NAT
rebinding, the intentional change of the local interface, the expiration
of a temporary IPv6 address \[[RFC8981](#RFC8981){.cite .xref}\], or the
indication from the server of a preferred address ([Section
9.6](https://www.rfc-editor.org/rfc/rfc9000#section-9.6){.relref} of
\[[QUIC](#RFC9000){.cite .xref}\]).[¶](#section-9-1){.pilcrow}

Use of a non-zero-length connection ID for the server is strongly
recommended if any clients are or could be behind a NAT. A
non-zero-length connection ID is also strongly recommended when active
migration is supported. If a connection is intentionally migrated to a
new path, a new connection ID is used to minimize linkability by network
observers. The other QUIC endpoint uses the connection ID to link
different addresses to the same connection and entity if a
non-zero-length connection ID is provided.[¶](#section-9-2){.pilcrow}

The base specification of QUIC version 1 only supports the use of a
single network path at a time, which enables failover use cases. Path
validation is required so that endpoints validate paths before use to
avoid address spoofing attacks. Path validation takes at least one RTT,
and congestion control will also be reset after path migration.
Therefore, migration usually has a performance
impact.[¶](#section-9-3){.pilcrow}

QUIC probing packets, which can be sent on multiple paths at once, are
used to perform address validation as well as measure path
characteristics. Probing packets cannot carry application data but
likely contain padding frames. Endpoints can use information about their
receipt as input to congestion control for that path. Applications could
use information learned from probing to inform a decision to switch
paths.[¶](#section-9-4){.pilcrow}

Only the client can actively migrate in version 1 of QUIC. However,
servers can indicate during the handshake that they prefer to transfer
the connection to a different address after the handshake. For instance,
this could be used to move from an address that is shared by multiple
servers to an address that is unique to the server instance. The server
can provide an IPv4 and an IPv6 address in a transport parameter during
the TLS handshake, and the client can select between the two if both are
provided. See [Section
9.6](https://www.rfc-editor.org/rfc/rfc9000#section-9.6){.relref} of
\[[QUIC](#RFC9000){.cite .xref}\].[¶](#section-9-5){.pilcrow}
:::
:::

::: {#sec-termination}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Connection Termination](#name-connection-termination){.section-name .selfRef} {#name-connection-termination}

QUIC connections are terminated in one of three ways: implicit idle
timeout, explicit immediate close, or explicit stateless
reset.[¶](#section-10-1){.pilcrow}

QUIC does not provide any mechanism for graceful connection termination;
applications using QUIC can define their own graceful termination
process (see, for example, [Section
5.2](https://www.rfc-editor.org/rfc/rfc9114#section-5.2){.relref} of
\[[QUIC-HTTP](#RFC9114){.cite .xref}\]).[¶](#section-10-2){.pilcrow}

QUIC idle timeout is enabled via transport parameters. The client and
server announce a timeout period, and the effective value for the
connection is the minimum of the two values. After the timeout period
elapses, the connection is silently closed. An application therefore
should be able to configure its own maximum value, as well as have
access to the computed minimum value for this connection. An application
may adjust the maximum idle timeout for new connections based on the
number of open or expected connections since shorter timeout values may
free up resources more quickly.[¶](#section-10-3){.pilcrow}

Application data exchanged on streams or in datagrams defers the QUIC
idle timeout. Applications that provide their own keep-alive mechanisms
will therefore keep a QUIC connection alive. Applications that do not
provide their own keep-alive can use transport-layer mechanisms (see
[Section
10.1.2](https://www.rfc-editor.org/rfc/rfc9000#section-10.1.2){.relref}
of \[[QUIC](#RFC9000){.cite .xref}\] and [Section
3.2](#resumption-v-keepalive){.auto .internal .xref}). However, QUIC
implementation interfaces for controlling such transport behavior can
vary, affecting the robustness of such
approaches.[¶](#section-10-4){.pilcrow}

An immediate close is signaled by a CONNECTION_CLOSE frame (see [Section
6](#error-handling){.auto .internal .xref}). Immediate close causes all
streams to become immediately closed, which may affect applications; see
[Section 4.5](#stream-limit-commitments){.auto .internal
.xref}.[¶](#section-10-5){.pilcrow}

A stateless reset is an option of last resort for an endpoint that does
not have access to connection state. Receiving a stateless reset is an
indication of an unrecoverable error distinct from connection errors in
that there is no application-layer information
provided.[¶](#section-10-6){.pilcrow}
:::
:::

::: {#connid}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [Information Exposure and the Connection ID](#name-information-exposure-and-th){.section-name .selfRef} {#name-information-exposure-and-th}

QUIC exposes some information to the network in the unencrypted part of
the header either before the encryption context is established or
because the information is intended to be used by the network. For more
information on manageability of QUIC, see
\[[QUIC-MANAGEABILITY](#RFC9312){.cite .xref}\]. QUIC has a long header
that exposes some additional information (the version and the source
connection ID), while the short header exposes only the destination
connection ID. In QUIC version 1, the long header is used during
connection establishment, while the short header is used for data
transmission in an established connection.[¶](#section-11-1){.pilcrow}

The connection ID can be zero length. Zero-length connection IDs can be
chosen on each endpoint individually and on any packet except the first
packets sent by clients during connection
establishment.[¶](#section-11-2){.pilcrow}

An endpoint that selects a zero-length connection ID will receive
packets with a zero-length destination connection ID. The endpoint needs
to use other information, such as the source and destination IP address
and port number to identify which connection is referred to. This could
mean that the endpoint is unable to match datagrams to connections
successfully if these values change, making the connection effectively
unable to survive NAT rebinding or migrate to a new
path.[¶](#section-11-3){.pilcrow}

::: {#server-generated-connection-id}
::: {#section-11.1 .section}
### [11.1.](#section-11.1){.section-number .selfRef} [Server-Generated Connection ID](#name-server-generated-connection){.section-name .selfRef} {#name-server-generated-connection}

QUIC supports a server-generated connection ID that is transmitted to
the client during connection establishment (see [Section
7.2](https://www.rfc-editor.org/rfc/rfc9000#section-7.2){.relref} of
\[[QUIC](#RFC9000){.cite .xref}\]). Servers behind load balancers may
need to change the connection ID during the handshake, encoding the
identity of the server or information about its load balancing pool, in
order to support stateless load balancing.[¶](#section-11.1-1){.pilcrow}

Server deployments with load balancers and other routing infrastructure
need to ensure that this infrastructure consistently routes packets to
the server instance that has the connection state, even if addresses,
ports, or connection IDs change. This might require coordination between
servers and infrastructure. One method of achieving this involves
encoding routing information into the connection ID. For an example of
this technique, see \[[QUIC-LB](#I-D.ietf-quic-load-balancers){.cite
.xref}\].[¶](#section-11.1-2){.pilcrow}
:::
:::

::: {#mitigating-timing-linkability-with-connection-id-migration}
::: {#section-11.2 .section}
### [11.2.](#section-11.2){.section-number .selfRef} [Mitigating Timing Linkability with Connection ID Migration](#name-mitigating-timing-linkabili){.section-name .selfRef} {#name-mitigating-timing-linkabili}

If QUIC endpoints do not issue fresh connection IDs, then clients cannot
reduce the linkability of address migration by using them. Choosing
values that are unlinkable to an outside observer ensures that activity
on different paths cannot be trivially correlated using the connection
ID.[¶](#section-11.2-1){.pilcrow}

While sufficiently robust connection ID generation schemes will mitigate
linkability issues, they do not provide full protection. Analysis of the
lifetimes of 6-tuples (source and destination addresses as well as the
migrated Connection ID) may expose these links
anyway.[¶](#section-11.2-2){.pilcrow}

In the case where connection migration in a server pool is rare, it is
trivial for an observer to associate two connection IDs. Conversely,
where every server handles multiple simultaneous migrations, even an
exposed server mapping may be insufficient
information.[¶](#section-11.2-3){.pilcrow}

The most efficient mitigations for these attacks are through network
design and/or operational practices, by using a load-balancing
architecture that loads more flows onto a single server-side address, by
coordinating the timing of migrations in an attempt to increase the
number of simultaneous migrations at a given time, or by using other
means.[¶](#section-11.2-4){.pilcrow}
:::
:::

::: {#using-server-retry-for-redirection}
::: {#section-11.3 .section}
### [11.3.](#section-11.3){.section-number .selfRef} [Using Server Retry for Redirection](#name-using-server-retry-for-redi){.section-name .selfRef} {#name-using-server-retry-for-redi}

QUIC provides a Retry packet that can be sent by a server in response to
the client Initial packet. The server may choose a new connection ID in
that packet, and the client will retry by sending another client Initial
packet with the server-selected connection ID. This mechanism can be
used to redirect a connection to a different server, e.g., due to
performance reasons or when servers in a server pool are upgraded
gradually and therefore may support different versions of
QUIC.[¶](#section-11.3-1){.pilcrow}

In this case, it is assumed that all servers belonging to a certain pool
are served in cooperation with load balancers that forward the traffic
based on the connection ID. A server can choose the connection ID in the
Retry packet such that the load balancer will redirect the next Initial
packet to a different server in that pool. Alternatively, the load
balancer can directly offer a Retry offload as further described in
\[[QUIC-RETRY](#I-D.ietf-quic-retry-offload){.cite
.xref}\].[¶](#section-11.3-2){.pilcrow}

The approach described in [Section
4](https://www.rfc-editor.org/rfc/rfc5077#section-4){.relref} of
\[[RFC5077](#RFC5077){.cite .xref}\] for constructing TLS resumption
tickets provides an example that can be also applied to validation
tokens. However, the use of more modern cryptographic algorithms is
highly recommended.[¶](#section-11.3-3){.pilcrow}
:::
:::
:::
:::

::: {#quality-of-service-qos-and-dscp}
::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [Quality of Service (QoS) and Diffserv Code Point (DSCP)](#name-quality-of-service-qos-and-){.section-name .selfRef} {#name-quality-of-service-qos-and-}

QUIC, as defined in \[[QUIC](#RFC9000){.cite .xref}\], has a single
congestion controller and recovery handler. This design assumes that all
packets of a QUIC connection, or at least with the same 5-tuple {dest
addr, source addr, protocol, dest port, source port}, that have the same
Diffserv Code Point (DSCP) \[[RFC2475](#RFC2475){.cite .xref}\] will
receive similar network treatment since feedback about loss or delay of
each packet is used as input to the congestion controller. Therefore,
packets belonging to the same connection should use a single DSCP.
[Section
5.1](https://www.rfc-editor.org/rfc/rfc7657#section-5.1){.relref} of
\[[RFC7657](#RFC7657){.cite .xref}\] provides a discussion of Diffserv
interactions with datagram transport protocols
\[[RFC7657](#RFC7657){.cite .xref}\] (in this respect, the interactions
with QUIC resemble those of Stream Control Transmission Protocol
(SCTP)).[¶](#section-12-1){.pilcrow}

When multiplexing multiple flows over a single QUIC connection, the
selected DSCP value should be the one associated with the highest
priority requested for all multiplexed
flows.[¶](#section-12-2){.pilcrow}

If differential network treatment is desired, e.g., by the use of
different DSCPs, multiple QUIC connections to the same server may be
used. In general, it is recommended to minimize the number of QUIC
connections to the same server to avoid increased overhead and, more
importantly, competing congestion control.[¶](#section-12-3){.pilcrow}

As in other uses of Diffserv, when a packet enters a network segment
that does not support the DSCP value, this could result in the
connection not receiving the network treatment it expects. The DSCP
value in this packet could also be remarked as the packet travels along
the network path, changing the requested
treatment.[¶](#section-12-4){.pilcrow}
:::
:::

::: {#use-of-versions-and-cryptographic-handshake}
::: {#section-13 .section}
## [13.](#section-13){.section-number .selfRef} [Use of Versions and Cryptographic Handshake](#name-use-of-versions-and-cryptog){.section-name .selfRef} {#name-use-of-versions-and-cryptog}

Versioning in QUIC may change the protocol\'s behavior completely,
except for the meaning of a few header fields that have been declared to
be invariant \[[QUIC-INVARIANTS](#RFC8999){.cite .xref}\]. A version of
QUIC with a higher version number will not necessarily provide a better
service but might simply provide a different feature set. As such, an
application needs to be able to select which versions of QUIC it wants
to use.[¶](#section-13-1){.pilcrow}

A new version could use an encryption scheme other than TLS 1.3 or
higher. \[[QUIC](#RFC9000){.cite .xref}\] specifies requirements for the
cryptographic handshake as currently realized by TLS 1.3 and described
in a separate specification \[[QUIC-TLS](#RFC9001){.cite .xref}\]. This
split is performed to enable lightweight versioning with different
cryptographic handshakes.[¶](#section-13-2){.pilcrow}

The \"QUIC Versions\" registry established in \[[QUIC](#RFC9000){.cite
.xref}\] allows for provisional registrations for experimentation.
Registration, also of experimental versions, is important to avoid
collision. Experimental versions should not be used long-term or
registered as permanent to minimize the risk of fingerprinting based on
the version number.[¶](#section-13-3){.pilcrow}
:::
:::

::: {#enabling-deployment-of-new-versions}
::: {#section-14 .section}
## [14.](#section-14){.section-number .selfRef} [Enabling Deployment of New Versions](#name-enabling-deployment-of-new-){.section-name .selfRef} {#name-enabling-deployment-of-new-}

QUIC version 1 does not specify a version negotiation mechanism in the
base specification, but
\[[QUIC-VERSION-NEGOTIATION](#I-D.ietf-quic-version-negotiation){.cite
.xref}\] proposes an extension that provides compatible version
negotiation.[¶](#section-14-1){.pilcrow}

This approach uses a three-stage deployment mechanism, enabling
progressive rollout and experimentation with multiple versions across a
large server deployment. In this approach, all servers in the deployment
must accept connections using a new version (stage 1) before any server
advertises it (stage 2), and authentication of the new version (stage 3)
only proceeds after advertising of that version is completely
deployed.[¶](#section-14-2){.pilcrow}

See [Section
5](https://datatracker.ietf.org/doc/html/draft-ietf-quic-version-negotiation-10#section-5){.relref}
of
\[[QUIC-VERSION-NEGOTIATION](#I-D.ietf-quic-version-negotiation){.cite
.xref}\] for details.[¶](#section-14-3){.pilcrow}
:::
:::

::: {#unreliable-datagram-service-over-quic}
::: {#section-15 .section}
## [15.](#section-15){.section-number .selfRef} [Unreliable Datagram Service over QUIC](#name-unreliable-datagram-service){.section-name .selfRef} {#name-unreliable-datagram-service}

\[[RFC9221](#RFC9221){.cite .xref}\] specifies a QUIC extension to
enable sending and receiving unreliable datagrams over QUIC. Unlike
operating directly over UDP, applications that use the QUIC datagram
service do not need to implement their own congestion control, per
\[[RFC8085](#RFC8085){.cite .xref}\], as QUIC datagrams are congestion
controlled.[¶](#section-15-1){.pilcrow}

QUIC datagrams are not flow controlled, and as such data chunks may be
dropped if the receiver is overloaded. While the reliable transmission
service of QUIC provides a stream-based interface to send and receive
data in order over multiple QUIC streams, the datagram service has an
unordered message-based interface. If needed, an application-layer
framing can be used on top to allow separate flows of unreliable
datagrams to be multiplexed on one QUIC
connection.[¶](#section-15-2){.pilcrow}
:::
:::

::: {#iana-considerations}
::: {#section-16 .section}
## [16.](#section-16){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no actions for IANA; however, note that [Section
8](#ports){.auto .internal .xref} recommends that an application that
has already registered a TCP port but wants to specify QUIC as a
transport should register a UDP port analogous to their existing TCP
registration.[¶](#section-16-1){.pilcrow}
:::
:::

::: {#security-considerations}
::: {#section-17 .section}
## [17.](#section-17){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

See the security considerations in \[[QUIC](#RFC9000){.cite .xref}\] and
\[[QUIC-TLS](#RFC9001){.cite .xref}\]; the security considerations for
the underlying transport protocol are relevant for applications using
QUIC. Considerations on linkability, replay attacks, and randomness
discussed in \[[QUIC-TLS](#RFC9001){.cite .xref}\] should be taken into
account when deploying and using QUIC.[¶](#section-17-1){.pilcrow}

Further, migration to a new address exposes a linkage between client
addresses to the server and may expose this linkage also to the path if
the connection ID cannot be changed or flows can otherwise be
correlated. When migration is supported, this needs to be considered
with respective to user privacy.[¶](#section-17-2){.pilcrow}

Application developers should note that any fallback they use when QUIC
cannot be used due to network blocking of UDP should guarantee the same
security properties as QUIC. If this is not possible, the connection
should fail to allow the application to explicitly handle fallback to a
less-secure alternative. See [Section 2](#fallback){.auto .internal
.xref}.[¶](#section-17-3){.pilcrow}

Further, \[[QUIC-HTTP](#RFC9114){.cite .xref}\] provides security
considerations specific to HTTP. However, discussions such as on
cross-protocol attacks, traffic analysis and padding, or migration might
be relevant for other applications using QUIC as
well.[¶](#section-17-4){.pilcrow}
:::
:::

::: {#section-18 .section}
## [18.](#section-18){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-18.1 .section}
### [18.1.](#section-18.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[QUIC\]
:   [Iyengar, J., Ed.]{.refAuthor} and [M. Thomson, Ed.]{.refAuthor},
    [\"QUIC: A UDP-Based Multiplexed and Secure Transport\"]{.refTitle},
    [RFC 9000]{.seriesInfo}, [DOI 10.17487/RFC9000]{.seriesInfo}, May
    2021, \<<https://www.rfc-editor.org/info/rfc9000>\>.
:   

\[QUIC-INVARIANTS\]
:   [Thomson, M.]{.refAuthor}, [\"Version-Independent Properties of
    QUIC\"]{.refTitle}, [RFC 8999]{.seriesInfo}, [DOI
    10.17487/RFC8999]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc8999>\>.
:   

\[QUIC-TLS\]
:   [Thomson, M., Ed.]{.refAuthor} and [S. Turner, Ed.]{.refAuthor},
    [\"Using TLS to Secure QUIC\"]{.refTitle}, [RFC 9001]{.seriesInfo},
    [DOI 10.17487/RFC9001]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc9001>\>.
:   
:::

::: {#section-18.2 .section}
### [18.2.](#section-18.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[Edeline16\]
:   [Edeline, K.]{.refAuthor}, [Kühlewind, M.]{.refAuthor},
    [Trammell, B.]{.refAuthor}, [Aben, E.]{.refAuthor}, and [B.
    Donnet]{.refAuthor}, [\"Using UDP for Internet Transport
    Evolution\"]{.refTitle}, [DOI
    10.48550/arXiv.1612.07816]{.seriesInfo}, 22 December 2016,
    \<<https://arxiv.org/abs/1612.07816>\>.
:   

\[Hatonen10\]
:   [Hätönen, S.]{.refAuthor}, [Nyrhinen, A.]{.refAuthor},
    [Eggert, L.]{.refAuthor}, [Strowes, S.]{.refAuthor},
    [Sarolahti, P.]{.refAuthor}, and [M. Kojo]{.refAuthor}, [\"An
    Experimental Study of Home Gateway Characteristics\"]{.refTitle},
    [Proc. ACM IMC 2010]{.refContent}, November 2010,
    \<<https://conferences.sigcomm.org/imc/2010/papers/p260.pdf>\>.
:   

\[HTTP-REPLAY\]
:   [Thomson, M.]{.refAuthor}, [Nottingham, M.]{.refAuthor}, and [W.
    Tarreau]{.refAuthor}, [\"Using Early Data in HTTP\"]{.refTitle},
    [RFC 8470]{.seriesInfo}, [DOI 10.17487/RFC8470]{.seriesInfo},
    September 2018, \<<https://www.rfc-editor.org/info/rfc8470>\>.
:   

\[PaaschNanog\]
:   [Paasch, C.]{.refAuthor}, [\"Network support for TCP Fast
    Open\"]{.refTitle}, [NANOG 67 Presentation]{.refContent}, 13 June
    2016,
    \<<https://www.nanog.org/sites/default/files/Paasch_Network_Support.pdf>\>.
:   

\[QUIC-ACK-FREQUENCY\]
:   [Iyengar, J.]{.refAuthor} and [I. Swett]{.refAuthor}, [\"QUIC
    Acknowledgement Frequency\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-quic-ack-frequency-02]{.seriesInfo}, 11 July 2022,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-quic-ack-frequency-02>\>.
:   

\[QUIC-HTTP\]
:   [Bishop, M., Ed.]{.refAuthor}, [\"HTTP/3\"]{.refTitle}, [RFC
    9114]{.seriesInfo}, [DOI 10.17487/RFC9114]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9114>\>.
:   

\[QUIC-LB\]
:   [Duke, M.]{.refAuthor}, [Banks, N.]{.refAuthor}, and [C.
    Huitema]{.refAuthor}, [\"QUIC-LB: Generating Routable QUIC
    Connection IDs\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-quic-load-balancers-14]{.seriesInfo}, 11
    July 2022,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-quic-load-balancers-14>\>.
:   

\[QUIC-MANAGEABILITY\]
:   [Kühlewind, M.]{.refAuthor} and [B. Trammell]{.refAuthor},
    [\"Manageability of the QUIC Transport Protocol\"]{.refTitle}, [RFC
    9312]{.seriesInfo}, [DOI 10.17487/RFC9312]{.seriesInfo}, September
    2022, \<<https://www.rfc-editor.org/info/rfc9312>\>.
:   

\[QUIC-RETRY\]
:   [Duke, M.]{.refAuthor} and [N. Banks]{.refAuthor}, [\"QUIC Retry
    Offload\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-quic-retry-offload-00]{.seriesInfo}, 25
    May 2022,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-quic-retry-offload-00>\>.
:   

\[QUIC-VERSION-NEGOTIATION\]
:   [Schinazi, D.]{.refAuthor} and [E. Rescorla]{.refAuthor},
    [\"Compatible Version Negotiation for QUIC\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-quic-version-negotiation-10]{.seriesInfo}, 27 September
    2022,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-quic-version-negotiation-10>\>.
:   

\[RFC1034\]
:   [Mockapetris, P.]{.refAuthor}, [\"Domain names - concepts and
    facilities\"]{.refTitle}, [STD 13]{.seriesInfo}, [RFC
    1034]{.seriesInfo}, [DOI 10.17487/RFC1034]{.seriesInfo}, November
    1987, \<<https://www.rfc-editor.org/info/rfc1034>\>.
:   

\[RFC2475\]
:   [Blake, S.]{.refAuthor}, [Black, D.]{.refAuthor},
    [Carlson, M.]{.refAuthor}, [Davies, E.]{.refAuthor},
    [Wang, Z.]{.refAuthor}, and [W. Weiss]{.refAuthor}, [\"An
    Architecture for Differentiated Services\"]{.refTitle}, [RFC
    2475]{.seriesInfo}, [DOI 10.17487/RFC2475]{.seriesInfo}, December
    1998, \<<https://www.rfc-editor.org/info/rfc2475>\>.
:   

\[RFC5077\]
:   [Salowey, J.]{.refAuthor}, [Zhou, H.]{.refAuthor},
    [Eronen, P.]{.refAuthor}, and [H. Tschofenig]{.refAuthor},
    [\"Transport Layer Security (TLS) Session Resumption without
    Server-Side State\"]{.refTitle}, [RFC 5077]{.seriesInfo}, [DOI
    10.17487/RFC5077]{.seriesInfo}, January 2008,
    \<<https://www.rfc-editor.org/info/rfc5077>\>.
:   

\[RFC5382\]
:   [Guha, S., Ed.]{.refAuthor}, [Biswas, K.]{.refAuthor},
    [Ford, B.]{.refAuthor}, [Sivakumar, S.]{.refAuthor}, and [P.
    Srisuresh]{.refAuthor}, [\"NAT Behavioral Requirements for
    TCP\"]{.refTitle}, [BCP 142]{.seriesInfo}, [RFC 5382]{.seriesInfo},
    [DOI 10.17487/RFC5382]{.seriesInfo}, October 2008,
    \<<https://www.rfc-editor.org/info/rfc5382>\>.
:   

\[RFC5905\]
:   [Mills, D.]{.refAuthor}, [Martin, J., Ed.]{.refAuthor},
    [Burbank, J.]{.refAuthor}, and [W. Kasch]{.refAuthor}, [\"Network
    Time Protocol Version 4: Protocol and Algorithms
    Specification\"]{.refTitle}, [RFC 5905]{.seriesInfo}, [DOI
    10.17487/RFC5905]{.seriesInfo}, June 2010,
    \<<https://www.rfc-editor.org/info/rfc5905>\>.
:   

\[RFC6335\]
:   [Cotton, M.]{.refAuthor}, [Eggert, L.]{.refAuthor},
    [Touch, J.]{.refAuthor}, [Westerlund, M.]{.refAuthor}, and [S.
    Cheshire]{.refAuthor}, [\"Internet Assigned Numbers Authority (IANA)
    Procedures for the Management of the Service Name and Transport
    Protocol Port Number Registry\"]{.refTitle}, [BCP 165]{.seriesInfo},
    [RFC 6335]{.seriesInfo}, [DOI 10.17487/RFC6335]{.seriesInfo}, August
    2011, \<<https://www.rfc-editor.org/info/rfc6335>\>.
:   

\[RFC6762\]
:   [Cheshire, S.]{.refAuthor} and [M. Krochmal]{.refAuthor},
    [\"Multicast DNS\"]{.refTitle}, [RFC 6762]{.seriesInfo}, [DOI
    10.17487/RFC6762]{.seriesInfo}, February 2013,
    \<<https://www.rfc-editor.org/info/rfc6762>\>.
:   

\[RFC7301\]
:   [Friedl, S.]{.refAuthor}, [Popov, A.]{.refAuthor},
    [Langley, A.]{.refAuthor}, and [E. Stephan]{.refAuthor},
    [\"Transport Layer Security (TLS) Application-Layer Protocol
    Negotiation Extension\"]{.refTitle}, [RFC 7301]{.seriesInfo}, [DOI
    10.17487/RFC7301]{.seriesInfo}, July 2014,
    \<<https://www.rfc-editor.org/info/rfc7301>\>.
:   

\[RFC7413\]
:   [Cheng, Y.]{.refAuthor}, [Chu, J.]{.refAuthor},
    [Radhakrishnan, S.]{.refAuthor}, and [A. Jain]{.refAuthor}, [\"TCP
    Fast Open\"]{.refTitle}, [RFC 7413]{.seriesInfo}, [DOI
    10.17487/RFC7413]{.seriesInfo}, December 2014,
    \<<https://www.rfc-editor.org/info/rfc7413>\>.
:   

\[RFC7657\]
:   [Black, D., Ed.]{.refAuthor} and [P. Jones]{.refAuthor},
    [\"Differentiated Services (Diffserv) and Real-Time
    Communication\"]{.refTitle}, [RFC 7657]{.seriesInfo}, [DOI
    10.17487/RFC7657]{.seriesInfo}, November 2015,
    \<<https://www.rfc-editor.org/info/rfc7657>\>.
:   

\[RFC7838\]
:   [Nottingham, M.]{.refAuthor}, [McManus, P.]{.refAuthor}, and [J.
    Reschke]{.refAuthor}, [\"HTTP Alternative Services\"]{.refTitle},
    [RFC 7838]{.seriesInfo}, [DOI 10.17487/RFC7838]{.seriesInfo}, April
    2016, \<<https://www.rfc-editor.org/info/rfc7838>\>.
:   

\[RFC8085\]
:   [Eggert, L.]{.refAuthor}, [Fairhurst, G.]{.refAuthor}, and [G.
    Shepherd]{.refAuthor}, [\"UDP Usage Guidelines\"]{.refTitle}, [BCP
    145]{.seriesInfo}, [RFC 8085]{.seriesInfo}, [DOI
    10.17487/RFC8085]{.seriesInfo}, March 2017,
    \<<https://www.rfc-editor.org/info/rfc8085>\>.
:   

\[RFC8981\]
:   [Gont, F.]{.refAuthor}, [Krishnan, S.]{.refAuthor},
    [Narten, T.]{.refAuthor}, and [R. Draves]{.refAuthor}, [\"Temporary
    Address Extensions for Stateless Address Autoconfiguration in
    IPv6\"]{.refTitle}, [RFC 8981]{.seriesInfo}, [DOI
    10.17487/RFC8981]{.seriesInfo}, February 2021,
    \<<https://www.rfc-editor.org/info/rfc8981>\>.
:   

\[RFC9218\]
:   [Oku, K.]{.refAuthor} and [L. Pardue]{.refAuthor}, [\"Extensible
    Prioritization Scheme for HTTP\"]{.refTitle}, [RFC
    9218]{.seriesInfo}, [DOI 10.17487/RFC9218]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9218>\>.
:   

\[RFC9221\]
:   [Pauly, T.]{.refAuthor}, [Kinnear, E.]{.refAuthor}, and [D.
    Schinazi]{.refAuthor}, [\"An Unreliable Datagram Extension to
    QUIC\"]{.refTitle}, [RFC 9221]{.seriesInfo}, [DOI
    10.17487/RFC9221]{.seriesInfo}, March 2022,
    \<<https://www.rfc-editor.org/info/rfc9221>\>.
:   

\[SSDP\]
:   [Donoho, A.]{.refAuthor}, [Roe, B.]{.refAuthor},
    [Bodlaender, M.]{.refAuthor}, [Gildred, J.]{.refAuthor},
    [Messer, A.]{.refAuthor}, [Kim, Y.]{.refAuthor},
    [Fairman, B.]{.refAuthor}, and [J. Tourzan]{.refAuthor}, [\"UPnP
    Device Architecture 2.0\"]{.refTitle}, 17 April 2020,
    \<<https://openconnectivity.org/upnp-specs/UPnP-arch-DeviceArchitecture-v2.0-20200417.pdf>\>.
:   

\[Swett16\]
:   [Swett, I.]{.refAuthor}, [\"QUIC Deployment Experience
    \@Google\"]{.refTitle}, [IETF96 QUIC BoF Presentation]{.refContent},
    20 July 2016,
    \<<https://www.ietf.org/proceedings/96/slides/slides-96-quic-3.pdf>\>.
:   

\[TAPS-ARCH\]
:   [Pauly, T.]{.refAuthor}, [Trammell, B.]{.refAuthor},
    [Brunstrom, A.]{.refAuthor}, [Fairhurst, G.]{.refAuthor}, and [C.
    Perkins]{.refAuthor}, [\"An Architecture for Transport
    Services\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-taps-arch-14]{.seriesInfo}, 27 September
    2022,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-taps-arch-14>\>.
:   

\[TLS13\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   

\[Trammell16\]
:   [Trammell, B.]{.refAuthor} and [M. Kühlewind]{.refAuthor},
    [\"Internet Path Transparency Measurements using RIPE
    Atlas\"]{.refTitle}, [RIPE 72 MAT Presentation]{.refContent}, 25 May
    2016,
    \<<https://ripe72.ripe.net/wp-content/uploads/presentations/86-atlas-udpdiff.pdf>\>.
:   
:::
:::

::: {#acknowledgments}
::: {#appendix-A .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

Special thanks to Last Call reviewers [Chris Lonvick]{.contact-name} and
[Ines Robles]{.contact-name}.[¶](#appendix-A-1){.pilcrow}

This work was partially supported by the European Commission under
Horizon 2020 grant agreement no. 688421 Measurement and Architecture for
a Middleboxed Internet (MAMI) and by the Swiss State Secretariat for
Education, Research, and Innovation under contract no. 15.0268. This
support does not imply endorsement.[¶](#appendix-A-2){.pilcrow}
:::
:::

::: {#contributors}
::: {#appendix-B .section}
## [Contributors](#name-contributors){.section-name .selfRef} {#name-contributors}

The following people have contributed significant text to or feedback on
this document:[¶](#appendix-B-1){.pilcrow}

::: {.left dir="auto"}
[Gorry Fairhurst]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Ian Swett]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Igor Lubashev]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Lucas Pardue]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Mike Bishop]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Mark Nottingham]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Martin Duke]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Martin Thomson]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Sean Turner]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Tommy Pauly]{.fn .nameRole}
:::
:::
:::

::: {#authors-addresses}
::: {#appendix-C .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Mirja Kühlewind]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Ericsson]{.org}
:::

::: email
Email: <mirja.kuehlewind@ericsson.com>
:::

::: {.left dir="auto"}
[Brian Trammell]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google Switzerland GmbH]{.org}
:::

::: {.left dir="auto"}
[Gustav-Gull-Platz 1]{.street-address}
:::

::: {.left dir="auto"}
CH-[8004]{.postal-code} [Zurich]{.locality}
:::

::: {.left dir="auto"}
[Switzerland]{.country-name}
:::

::: email
Email: <ietf@trammell.ch>
:::
:::
:::
