  RFC 9001           Using TLS to Secure QUIC   May 2021
  ------------------ -------------------------- ----------
  Thomson & Turner   Standards Track            \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9001](https://www.rfc-editor.org/rfc/rfc9001){.eref}

Category:
:   Standards Track

Published:
:   May 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    M. Thomson, [Ed.]{.editor}
    :::

    ::: org
    Mozilla
    :::
    :::

    ::: author
    ::: author-name
    S. Turner, [Ed.]{.editor}
    :::

    ::: org
    sn3rd
    :::
    :::
:::

# RFC 9001 {#rfcnum}

# Using TLS to Secure QUIC {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes how Transport Layer Security (TLS) is used to
secure QUIC.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9001>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Notational
    Conventions](#name-notational-conventions){.xref}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [TLS
        Overview](#name-tls-overview){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Protocol
    Overview](#name-protocol-overview){.xref}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Carrying TLS
    Messages](#name-carrying-tls-messages){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Interface to
        TLS](#name-interface-to-tls){.xref}

        -   ::: {#section-toc.1-1.4.2.1.2.1}
            [4.1.1](#section-4.1.1){.xref}.  [Handshake
            Complete](#name-handshake-complete){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.2}
            [4.1.2](#section-4.1.2){.xref}.  [Handshake
            Confirmed](#name-handshake-confirmed){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.3}
            [4.1.3](#section-4.1.3){.xref}.  [Sending and Receiving
            Handshake
            Messages](#name-sending-and-receiving-hands){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.4}
            [4.1.4](#section-4.1.4){.xref}.  [Encryption Level
            Changes](#name-encryption-level-changes){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.5}
            [4.1.5](#section-4.1.5){.xref}.  [TLS Interface
            Summary](#name-tls-interface-summary){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [TLS
        Version](#name-tls-version){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [ClientHello
        Size](#name-clienthello-size){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Peer
        Authentication](#name-peer-authentication){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [Session
        Resumption](#name-session-resumption){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.6}
        [4.6](#section-4.6){.xref}.  [0-RTT](#name-0-rtt){.xref}

        -   ::: {#section-toc.1-1.4.2.6.2.1}
            [4.6.1](#section-4.6.1){.xref}.  [Enabling
            0-RTT](#name-enabling-0-rtt){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.6.2.2}
            [4.6.2](#section-4.6.2){.xref}.  [Accepting and Rejecting
            0-RTT](#name-accepting-and-rejecting-0-r){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.6.2.3}
            [4.6.3](#section-4.6.3){.xref}.  [Validating 0-RTT
            Configuration](#name-validating-0-rtt-configurat){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.7}
        [4.7](#section-4.7){.xref}.  [HelloRetryRequest](#name-helloretryrequest){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.8}
        [4.8](#section-4.8){.xref}.  [TLS
        Errors](#name-tls-errors){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.9}
        [4.9](#section-4.9){.xref}.  [Discarding Unused
        Keys](#name-discarding-unused-keys){.xref}

        -   ::: {#section-toc.1-1.4.2.9.2.1}
            [4.9.1](#section-4.9.1){.xref}.  [Discarding Initial
            Keys](#name-discarding-initial-keys){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.9.2.2}
            [4.9.2](#section-4.9.2){.xref}.  [Discarding Handshake
            Keys](#name-discarding-handshake-keys){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.9.2.3}
            [4.9.3](#section-4.9.3){.xref}.  [Discarding 0-RTT
            Keys](#name-discarding-0-rtt-keys){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Packet
    Protection](#name-packet-protection){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Packet Protection
        Keys](#name-packet-protection-keys){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Initial
        Secrets](#name-initial-secrets){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [AEAD
        Usage](#name-aead-usage){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [Header
        Protection](#name-header-protection){.xref}

        -   ::: {#section-toc.1-1.5.2.4.2.1}
            [5.4.1](#section-5.4.1){.xref}.  [Header Protection
            Application](#name-header-protection-applicati){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.4.2.2}
            [5.4.2](#section-5.4.2){.xref}.  [Header Protection
            Sample](#name-header-protection-sample){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.4.2.3}
            [5.4.3](#section-5.4.3){.xref}.  [AES-Based Header
            Protection](#name-aes-based-header-protection){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.4.2.4}
            [5.4.4](#section-5.4.4){.xref}.  [ChaCha20-Based Header
            Protection](#name-chacha20-based-header-prote){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [Receiving Protected
        Packets](#name-receiving-protected-packets){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.6}
        [5.6](#section-5.6){.xref}.  [Use of 0-RTT
        Keys](#name-use-of-0-rtt-keys){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.7}
        [5.7](#section-5.7){.xref}.  [Receiving Out-of-Order Protected
        Packets](#name-receiving-out-of-order-prot){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.8}
        [5.8](#section-5.8){.xref}.  [Retry Packet
        Integrity](#name-retry-packet-integrity){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Key Update](#name-key-update){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Initiating a Key
        Update](#name-initiating-a-key-update){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Responding to a Key
        Update](#name-responding-to-a-key-update){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Timing of Receive Key
        Generation](#name-timing-of-receive-key-gener){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [Sending with Updated
        Keys](#name-sending-with-updated-keys){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.5}
        [6.5](#section-6.5){.xref}.  [Receiving with Different
        Keys](#name-receiving-with-different-ke){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.6}
        [6.6](#section-6.6){.xref}.  [Limits on AEAD
        Usage](#name-limits-on-aead-usage){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.7}
        [6.7](#section-6.7){.xref}.  [Key Update Error
        Code](#name-key-update-error-code){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Security of Initial
    Messages](#name-security-of-initial-message){.xref}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [QUIC-Specific Adjustments to the TLS
    Handshake](#name-quic-specific-adjustments-t){.xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Protocol
        Negotiation](#name-protocol-negotiation){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [QUIC Transport Parameters
        Extension](#name-quic-transport-parameters-e){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [8.3](#section-8.3){.xref}.  [Removing the EndOfEarlyData
        Message](#name-removing-the-endofearlydata){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.4}
        [8.4](#section-8.4){.xref}.  [Prohibit TLS Middlebox
        Compatibility Mode](#name-prohibit-tls-middlebox-comp){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Session
        Linkability](#name-session-linkability){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Replay Attacks with
        0-RTT](#name-replay-attacks-with-0-rtt){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.3}
        [9.3](#section-9.3){.xref}.  [Packet Reflection Attack
        Mitigation](#name-packet-reflection-attack-mi){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.4}
        [9.4](#section-9.4){.xref}.  [Header Protection
        Analysis](#name-header-protection-analysis){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.5}
        [9.5](#section-9.5){.xref}.  [Header Protection Timing Side
        Channels](#name-header-protection-timing-si){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.6}
        [9.6](#section-9.6){.xref}.  [Key
        Diversity](#name-key-diversity){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.7}
        [9.7](#section-9.7){.xref}.  [Randomness](#name-randomness){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.11.2.1}
        [11.1](#section-11.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [11.2](#section-11.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [Appendix A](#section-appendix.a){.xref}.  [Sample Packet
    Protection](#name-sample-packet-protection){.xref}

    -   ::: {#section-toc.1-1.12.2.1}
        [A.1](#section-a.1){.xref}.  [Keys](#name-keys){.xref}
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [A.2](#section-a.2){.xref}.  [Client
        Initial](#name-client-initial){.xref}
        :::

    -   ::: {#section-toc.1-1.12.2.3}
        [A.3](#section-a.3){.xref}.  [Server
        Initial](#name-server-initial){.xref}
        :::

    -   ::: {#section-toc.1-1.12.2.4}
        [A.4](#section-a.4){.xref}.  [Retry](#name-retry){.xref}
        :::

    -   ::: {#section-toc.1-1.12.2.5}
        [A.5](#section-a.5){.xref}.  [ChaCha20-Poly1305 Short Header
        Packet](#name-chacha20-poly1305-short-hea){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [Appendix B](#section-appendix.b){.xref}.  [AEAD Algorithm
    Analysis](#name-aead-algorithm-analysis){.xref}

    -   ::: {#section-toc.1-1.13.2.1}
        [B.1](#section-b.1){.xref}.  [Analysis of AEAD_AES_128_GCM and
        AEAD_AES_256_GCM Usage
        Limits](#name-analysis-of-aead_aes_128_gc){.xref}

        -   ::: {#section-toc.1-1.13.2.1.2.1}
            [B.1.1](#section-b.1.1){.xref}.  [Confidentiality
            Limit](#name-confidentiality-limit){.xref}
            :::

        -   ::: {#section-toc.1-1.13.2.1.2.2}
            [B.1.2](#section-b.1.2){.xref}.  [Integrity
            Limit](#name-integrity-limit){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.13.2.2}
        [B.2](#section-b.2){.xref}.  [Analysis of AEAD_AES_128_CCM Usage
        Limits](#name-analysis-of-aead_aes_128_cc){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.14}
    [](#section-appendix.c){.xref}[Contributors](#name-contributors){.xref}
    :::

-   ::: {#section-toc.1-1.15}
    [](#section-appendix.d){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

This document describes how QUIC
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\] is secured using TLS
\[[TLS13](#TLS13){.xref}\].[¶](#section-1-1){.pilcrow}

TLS 1.3 provides critical latency improvements for connection
establishment over previous versions. Absent packet loss, most new
connections can be established and secured within a single round trip;
on subsequent connections between the same client and server, the client
can often send application data immediately, that is, using a zero
round-trip setup.[¶](#section-1-2){.pilcrow}

This document describes how TLS acts as a security component of
QUIC.[¶](#section-1-3){.pilcrow}
:::
:::

::: {#notational-conventions}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Notational Conventions](#name-notational-conventions){.section-name .selfRef} {#name-notational-conventions}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}

This document uses the terminology established in
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-2-2){.pilcrow}

For brevity, the acronym TLS is used to refer to TLS 1.3, though a newer
version could be used; see [Section
4.2](#tls-version){.xref}.[¶](#section-2-3){.pilcrow}

::: {#tls-overview}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [TLS Overview](#name-tls-overview){.section-name .selfRef} {#name-tls-overview}

TLS provides two endpoints with a way to establish a means of
communication over an untrusted medium (for example, the Internet). TLS
enables authentication of peers and provides confidentiality and
integrity protection for messages that endpoints
exchange.[¶](#section-2.1-1){.pilcrow}

Internally, TLS is a layered protocol, with the structure shown in
[Figure 1](#tls-layers){.xref}.[¶](#section-2.1-2){.pilcrow}

[]{#name-tls-layers}

::: {#tls-layers}
::: {#section-2.1-3.1 .artwork .art-text .alignLeft}
              +-------------+------------+--------------+---------+
    Content   |             |            |  Application |         |
    Layer     |  Handshake  |   Alerts   |     Data     |   ...   |
              |             |            |              |         |
              +-------------+------------+--------------+---------+
    Record    |                                                   |
    Layer     |                      Records                      |
              |                                                   |
              +---------------------------------------------------+
:::

[Figure 1](#figure-1){.selfRef}: [TLS
Layers](#name-tls-layers){.selfRef}
:::

Each content-layer message (e.g., handshake, alerts, and application
data) is carried as a series of typed TLS records by the record layer.
Records are individually cryptographically protected and then
transmitted over a reliable transport (typically TCP), which provides
sequencing and guaranteed delivery.[¶](#section-2.1-4){.pilcrow}

The TLS authenticated key exchange occurs between two endpoints: client
and server. The client initiates the exchange and the server responds.
If the key exchange completes successfully, both client and server will
agree on a secret. TLS supports both pre-shared key (PSK) and
Diffie-Hellman over either finite fields or elliptic curves ((EC)DHE)
key exchanges. PSK is the basis for Early Data (0-RTT); the latter
provides forward secrecy (FS) when the (EC)DHE keys are destroyed. The
two modes can also be combined to provide forward secrecy while using
the PSK for authentication.[¶](#section-2.1-5){.pilcrow}

After completing the TLS handshake, the client will have learned and
authenticated an identity for the server, and the server is optionally
able to learn and authenticate an identity for the client. TLS supports
X.509 \[[RFC5280](#RFC5280){.xref}\] certificate-based authentication
for both server and client. When PSK key exchange is used (as in
resumption), knowledge of the PSK serves to authenticate the
peer.[¶](#section-2.1-6){.pilcrow}

The TLS key exchange is resistant to tampering by attackers, and it
produces shared secrets that cannot be controlled by either
participating peer.[¶](#section-2.1-7){.pilcrow}

TLS provides two basic handshake modes of interest to
QUIC:[¶](#section-2.1-8){.pilcrow}

-   [A full 1-RTT handshake, in which the client is able to send
    application data after one round trip and the server immediately
    responds after receiving the first handshake message from the
    client.[¶](#section-2.1-9.1){.pilcrow}]{#section-2.1-9.1}
-   [A 0-RTT handshake, in which the client uses information it has
    previously learned about the server to send application data
    immediately. This application data can be replayed by an attacker,
    so 0-RTT is not suitable for carrying instructions that might
    initiate any action that could cause unwanted effects if
    replayed.[¶](#section-2.1-9.2){.pilcrow}]{#section-2.1-9.2}

A simplified TLS handshake with 0-RTT application data is shown in
[Figure 2](#tls-full){.xref}.[¶](#section-2.1-10){.pilcrow}

[]{#name-tls-handshake-with-0-rtt}

::: {#tls-full}
::: {#section-2.1-11.1 .artwork .art-text .alignLeft}
        Client                                             Server

        ClientHello
       (0-RTT Application Data)  -------->
                                                      ServerHello
                                             {EncryptedExtensions}
                                                        {Finished}
                                 <--------      [Application Data]
       {Finished}                -------->

       [Application Data]        <------->      [Application Data]

        () Indicates messages protected by Early Data (0-RTT) Keys
        {} Indicates messages protected using Handshake Keys
        [] Indicates messages protected using Application Data
           (1-RTT) Keys
:::

[Figure 2](#figure-2){.selfRef}: [TLS Handshake with
0-RTT](#name-tls-handshake-with-0-rtt){.selfRef}
:::

[Figure 2](#tls-full){.xref} omits the EndOfEarlyData message, which is
not used in QUIC; see [Section 8.3](#remove-eoed){.xref}. Likewise,
neither ChangeCipherSpec nor KeyUpdate messages are used by QUIC.
ChangeCipherSpec is redundant in TLS 1.3; see [Section
8.4](#compat-mode){.xref}. QUIC has its own key update mechanism; see
[Section 6](#key-update){.xref}.[¶](#section-2.1-12){.pilcrow}

Data is protected using a number of encryption
levels:[¶](#section-2.1-13){.pilcrow}

-   [Initial keys[¶](#section-2.1-14.1){.pilcrow}]{#section-2.1-14.1}
-   [Early data (0-RTT)
    keys[¶](#section-2.1-14.2){.pilcrow}]{#section-2.1-14.2}
-   [Handshake keys[¶](#section-2.1-14.3){.pilcrow}]{#section-2.1-14.3}
-   [Application data (1-RTT)
    keys[¶](#section-2.1-14.4){.pilcrow}]{#section-2.1-14.4}

Application data can only appear in the early data and application data
levels. Handshake and alert messages may appear in any
level.[¶](#section-2.1-15){.pilcrow}

The 0-RTT handshake can be used if the client and server have previously
communicated. In the 1-RTT handshake, the client is unable to send
protected application data until it has received all of the handshake
messages sent by the server.[¶](#section-2.1-16){.pilcrow}
:::
:::
:::
:::

::: {#protocol-overview}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Protocol Overview](#name-protocol-overview){.section-name .selfRef} {#name-protocol-overview}

QUIC \[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\] assumes responsibility
for the confidentiality and integrity protection of packets. For this it
uses keys derived from a TLS handshake \[[TLS13](#TLS13){.xref}\], but
instead of carrying TLS records over QUIC (as with TCP), TLS handshake
and alert messages are carried directly over the QUIC transport, which
takes over the responsibilities of the TLS record layer, as shown in
[Figure 3](#quic-layers){.xref}.[¶](#section-3-1){.pilcrow}

[]{#name-quic-layers}

::: {#quic-layers}
::: {#section-3-2.1 .artwork .art-text .alignLeft}
    +--------------+--------------+ +-------------+
    |     TLS      |     TLS      | |    QUIC     |
    |  Handshake   |    Alerts    | | Applications|
    |              |              | |  (h3, etc.) |
    +--------------+--------------+-+-------------+
    |                                             |
    |                QUIC Transport               |
    |   (streams, reliability, congestion, etc.)  |
    |                                             |
    +---------------------------------------------+
    |                                             |
    |            QUIC Packet Protection           |
    |                                             |
    +---------------------------------------------+
:::

[Figure 3](#figure-3){.selfRef}: [QUIC
Layers](#name-quic-layers){.selfRef}
:::

QUIC also relies on TLS for authentication and negotiation of parameters
that are critical to security and
performance.[¶](#section-3-3){.pilcrow}

Rather than a strict layering, these two protocols cooperate: QUIC uses
the TLS handshake; TLS uses the reliability, ordered delivery, and
record layer provided by QUIC.[¶](#section-3-4){.pilcrow}

At a high level, there are two main interactions between the TLS and
QUIC components:[¶](#section-3-5){.pilcrow}

-   [The TLS component sends and receives messages via the QUIC
    component, with QUIC providing a reliable stream abstraction to
    TLS.[¶](#section-3-6.1){.pilcrow}]{#section-3-6.1}
-   [The TLS component provides a series of updates to the QUIC
    component, including (a) new packet protection keys to install
    and (b) state changes such as handshake completion, the server
    certificate, etc.[¶](#section-3-6.2){.pilcrow}]{#section-3-6.2}

[Figure 4](#schematic){.xref} shows these interactions in more detail,
with the QUIC packet protection being called out
specially.[¶](#section-3-7){.pilcrow}

[]{#name-quic-and-tls-interactions}

::: {#schematic}
::: {#section-3-8.1 .artwork .art-text .alignLeft}
    +------------+                               +------------+
    |            |<---- Handshake Messages ----->|            |
    |            |<- Validate 0-RTT Parameters ->|            |
    |            |<--------- 0-RTT Keys ---------|            |
    |    QUIC    |<------- Handshake Keys -------|    TLS     |
    |            |<--------- 1-RTT Keys ---------|            |
    |            |<------- Handshake Done -------|            |
    +------------+                               +------------+
     |         ^
     | Protect | Protected
     v         | Packet
    +------------+
    |   QUIC     |
    |  Packet    |
    | Protection |
    +------------+
:::

[Figure 4](#figure-4){.selfRef}: [QUIC and TLS
Interactions](#name-quic-and-tls-interactions){.selfRef}
:::

Unlike TLS over TCP, QUIC applications that want to send data do not
send it using TLS Application Data records. Rather, they send it as QUIC
STREAM frames or other frame types, which are then carried in QUIC
packets.[¶](#section-3-9){.pilcrow}
:::
:::

::: {#carrying-tls}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Carrying TLS Messages](#name-carrying-tls-messages){.section-name .selfRef} {#name-carrying-tls-messages}

QUIC carries TLS handshake data in CRYPTO frames, each of which consists
of a contiguous block of handshake data identified by an offset and
length. Those frames are packaged into QUIC packets and encrypted under
the current encryption level. As with TLS over TCP, once TLS handshake
data has been delivered to QUIC, it is QUIC\'s responsibility to deliver
it reliably. Each chunk of data that is produced by TLS is associated
with the set of keys that TLS is currently using. If QUIC needs to
retransmit that data, it [MUST]{.bcp14} use the same keys even if TLS
has already updated to newer keys.[¶](#section-4-1){.pilcrow}

Each encryption level corresponds to a packet number space. The packet
number space that is used determines the semantics of frames. Some
frames are prohibited in different packet number spaces; see [Section
12.5](https://www.rfc-editor.org/rfc/rfc9000#section-12.5){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-4-2){.pilcrow}

Because packets could be reordered on the wire, QUIC uses the packet
type to indicate which keys were used to protect a given packet, as
shown in [Table 1](#packet-types-keys){.xref}. When packets of different
types need to be sent, endpoints [SHOULD]{.bcp14} use coalesced packets
to send them in the same UDP datagram.[¶](#section-4-3){.pilcrow}

[]{#name-encryption-keys-by-packet-t}

::: {#packet-types-keys}
  Packet Type           Encryption Keys   PN Space
  --------------------- ----------------- ------------------
  Initial               Initial secrets   Initial
  0-RTT Protected       0-RTT             Application data
  Handshake             Handshake         Handshake
  Retry                 Retry             N/A
  Version Negotiation   N/A               N/A
  Short Header          1-RTT             Application data

  : [Table 1](#table-1){.selfRef}: [Encryption Keys by Packet
  Type](#name-encryption-keys-by-packet-t){.selfRef}
:::

[Section 17](https://www.rfc-editor.org/rfc/rfc9000#section-17){.relref}
of \[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\] shows how packets at the
various encryption levels fit into the handshake
process.[¶](#section-4-5){.pilcrow}

::: {#interface-to-tls}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Interface to TLS](#name-interface-to-tls){.section-name .selfRef} {#name-interface-to-tls}

As shown in [Figure 4](#schematic){.xref}, the interface from QUIC to
TLS consists of four primary functions:[¶](#section-4.1-1){.pilcrow}

-   [Sending and receiving handshake
    messages[¶](#section-4.1-2.1){.pilcrow}]{#section-4.1-2.1}
-   [Processing stored transport and application state from a resumed
    session and determining if it is valid to generate or accept 0-RTT
    data[¶](#section-4.1-2.2){.pilcrow}]{#section-4.1-2.2}
-   [Rekeying (both transmit and
    receive)[¶](#section-4.1-2.3){.pilcrow}]{#section-4.1-2.3}
-   [Updating handshake
    state[¶](#section-4.1-2.4){.pilcrow}]{#section-4.1-2.4}

Additional functions might be needed to configure TLS. In particular,
QUIC and TLS need to agree on which is responsible for validation of
peer credentials, such as certificate validation
\[[RFC5280](#RFC5280){.xref}\].[¶](#section-4.1-3){.pilcrow}

::: {#handshake-complete}
::: {#section-4.1.1 .section}
#### [4.1.1.](#section-4.1.1){.section-number .selfRef} [Handshake Complete](#name-handshake-complete){.section-name .selfRef} {#name-handshake-complete}

In this document, the TLS handshake is considered complete when the TLS
stack has reported that the handshake is complete. This happens when the
TLS stack has both sent a Finished message and verified the peer\'s
Finished message. Verifying the peer\'s Finished message provides the
endpoints with an assurance that previous handshake messages have not
been modified. Note that the handshake does not complete at both
endpoints simultaneously. Consequently, any requirement that is based on
the completion of the handshake depends on the perspective of the
endpoint in question.[¶](#section-4.1.1-1){.pilcrow}
:::
:::

::: {#handshake-confirmed}
::: {#section-4.1.2 .section}
#### [4.1.2.](#section-4.1.2){.section-number .selfRef} [Handshake Confirmed](#name-handshake-confirmed){.section-name .selfRef} {#name-handshake-confirmed}

In this document, the TLS handshake is considered confirmed at the
server when the handshake completes. The server [MUST]{.bcp14} send a
HANDSHAKE_DONE frame as soon as the handshake is complete. At the
client, the handshake is considered confirmed when a HANDSHAKE_DONE
frame is received.[¶](#section-4.1.2-1){.pilcrow}

Additionally, a client [MAY]{.bcp14} consider the handshake to be
confirmed when it receives an acknowledgment for a 1-RTT packet. This
can be implemented by recording the lowest packet number sent with 1-RTT
keys and comparing it to the Largest Acknowledged field in any received
1-RTT ACK frame: once the latter is greater than or equal to the former,
the handshake is confirmed.[¶](#section-4.1.2-2){.pilcrow}
:::
:::

::: {#sending-and-receiving-handshake-messages}
::: {#section-4.1.3 .section}
#### [4.1.3.](#section-4.1.3){.section-number .selfRef} [Sending and Receiving Handshake Messages](#name-sending-and-receiving-hands){.section-name .selfRef} {#name-sending-and-receiving-hands}

In order to drive the handshake, TLS depends on being able to send and
receive handshake messages. There are two basic functions on this
interface: one where QUIC requests handshake messages and one where QUIC
provides bytes that comprise handshake
messages.[¶](#section-4.1.3-1){.pilcrow}

Before starting the handshake, QUIC provides TLS with the transport
parameters (see [Section 8.2](#quic_parameters){.xref}) that it wishes
to carry.[¶](#section-4.1.3-2){.pilcrow}

A QUIC client starts TLS by requesting TLS handshake bytes from TLS. The
client acquires handshake bytes before sending its first packet. A QUIC
server starts the process by providing TLS with the client\'s handshake
bytes.[¶](#section-4.1.3-3){.pilcrow}

At any time, the TLS stack at an endpoint will have a current sending
encryption level and a receiving encryption level. TLS encryption levels
determine the QUIC packet type and keys that are used for protecting
data.[¶](#section-4.1.3-4){.pilcrow}

Each encryption level is associated with a different sequence of bytes,
which is reliably transmitted to the peer in CRYPTO frames. When TLS
provides handshake bytes to be sent, they are appended to the handshake
bytes for the current encryption level. The encryption level then
determines the type of packet that the resulting CRYPTO frame is carried
in; see [Table
1](#packet-types-keys){.xref}.[¶](#section-4.1.3-5){.pilcrow}

Four encryption levels are used, producing keys for Initial, 0-RTT,
Handshake, and 1-RTT packets. CRYPTO frames are carried in just three of
these levels, omitting the 0-RTT level. These four levels correspond to
three packet number spaces: Initial and Handshake encrypted packets use
their own separate spaces; 0-RTT and 1-RTT packets use the application
data packet number space.[¶](#section-4.1.3-6){.pilcrow}

QUIC takes the unprotected content of TLS handshake records as the
content of CRYPTO frames. TLS record protection is not used by QUIC.
QUIC assembles CRYPTO frames into QUIC packets, which are protected
using QUIC packet protection.[¶](#section-4.1.3-7){.pilcrow}

QUIC CRYPTO frames only carry TLS handshake messages. TLS alerts are
turned into QUIC CONNECTION_CLOSE error codes; see [Section
4.8](#tls-errors){.xref}. TLS application data and other content types
cannot be carried by QUIC at any encryption level; it is an error if
they are received from the TLS stack.[¶](#section-4.1.3-8){.pilcrow}

When an endpoint receives a QUIC packet containing a CRYPTO frame from
the network, it proceeds as follows:[¶](#section-4.1.3-9){.pilcrow}

-   [If the packet uses the current TLS receiving encryption level,
    sequence the data into the input flow as usual. As with STREAM
    frames, the offset is used to find the proper location in the data
    sequence. If the result of this process is that new data is
    available, then it is delivered to TLS in
    order.[¶](#section-4.1.3-10.1){.pilcrow}]{#section-4.1.3-10.1}
-   [If the packet is from a previously installed encryption level, it
    [MUST NOT]{.bcp14} contain data that extends past the end of
    previously received data in that flow. Implementations
    [MUST]{.bcp14} treat any violations of this requirement as a
    connection error of type
    PROTOCOL_VIOLATION.[¶](#section-4.1.3-10.2){.pilcrow}]{#section-4.1.3-10.2}
-   [If the packet is from a new encryption level, it is saved for later
    processing by TLS. Once TLS moves to receiving from this encryption
    level, saved data can be provided to TLS. When TLS provides keys for
    a higher encryption level, if there is data from a previous
    encryption level that TLS has not consumed, this [MUST]{.bcp14} be
    treated as a connection error of type
    PROTOCOL_VIOLATION.[¶](#section-4.1.3-10.3){.pilcrow}]{#section-4.1.3-10.3}

Each time that TLS is provided with new data, new handshake bytes are
requested from TLS. TLS might not provide any bytes if the handshake
messages it has received are incomplete or it has no data to
send.[¶](#section-4.1.3-11){.pilcrow}

The content of CRYPTO frames might either be processed incrementally by
TLS or buffered until complete messages or flights are available. TLS is
responsible for buffering handshake bytes that have arrived in order.
QUIC is responsible for buffering handshake bytes that arrive out of
order or for encryption levels that are not yet ready. QUIC does not
provide any means of flow control for CRYPTO frames; see [Section
7.5](https://www.rfc-editor.org/rfc/rfc9000#section-7.5){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-4.1.3-12){.pilcrow}

Once the TLS handshake is complete, this is indicated to QUIC along with
any final handshake bytes that TLS needs to send. At this stage, the
transport parameters that the peer advertised during the handshake are
authenticated; see [Section
8.2](#quic_parameters){.xref}.[¶](#section-4.1.3-13){.pilcrow}

Once the handshake is complete, TLS becomes passive. TLS can still
receive data from its peer and respond in kind, but it will not need to
send more data unless specifically requested \-- either by an
application or QUIC. One reason to send data is that the server might
wish to provide additional or updated session tickets to a
client.[¶](#section-4.1.3-14){.pilcrow}

When the handshake is complete, QUIC only needs to provide TLS with any
data that arrives in CRYPTO streams. In the same manner that is used
during the handshake, new data is requested from TLS after providing
received data.[¶](#section-4.1.3-15){.pilcrow}
:::
:::

::: {#encryption-level-changes}
::: {#section-4.1.4 .section}
#### [4.1.4.](#section-4.1.4){.section-number .selfRef} [Encryption Level Changes](#name-encryption-level-changes){.section-name .selfRef} {#name-encryption-level-changes}

As keys at a given encryption level become available to TLS, TLS
indicates to QUIC that reading or writing keys at that encryption level
are available.[¶](#section-4.1.4-1){.pilcrow}

The availability of new keys is always a result of providing inputs to
TLS. TLS only provides new keys after being initialized (by a client) or
when provided with new handshake data.[¶](#section-4.1.4-2){.pilcrow}

However, a TLS implementation could perform some of its processing
asynchronously. In particular, the process of validating a certificate
can take some time. While waiting for TLS processing to complete, an
endpoint [SHOULD]{.bcp14} buffer received packets if they might be
processed using keys that are not yet available. These packets can be
processed once keys are provided by TLS. An endpoint [SHOULD]{.bcp14}
continue to respond to packets that can be processed during this
time.[¶](#section-4.1.4-3){.pilcrow}

After processing inputs, TLS might produce handshake bytes, keys for new
encryption levels, or both.[¶](#section-4.1.4-4){.pilcrow}

TLS provides QUIC with three items as a new encryption level becomes
available:[¶](#section-4.1.4-5){.pilcrow}

-   [A secret[¶](#section-4.1.4-6.1){.pilcrow}]{#section-4.1.4-6.1}
-   [An Authenticated Encryption with Associated Data (AEAD)
    function[¶](#section-4.1.4-6.2){.pilcrow}]{#section-4.1.4-6.2}
-   [A Key Derivation Function
    (KDF)[¶](#section-4.1.4-6.3){.pilcrow}]{#section-4.1.4-6.3}

These values are based on the values that TLS negotiates and are used by
QUIC to generate packet and header protection keys; see [Section
5](#packet-protection){.xref} and [Section
5.4](#header-protect){.xref}.[¶](#section-4.1.4-7){.pilcrow}

If 0-RTT is possible, it is ready after the client sends a TLS
ClientHello message or the server receives that message. After providing
a QUIC client with the first handshake bytes, the TLS stack might signal
the change to 0-RTT keys. On the server, after receiving handshake bytes
that contain a ClientHello message, a TLS server might signal that 0-RTT
keys are available.[¶](#section-4.1.4-8){.pilcrow}

Although TLS only uses one encryption level at a time, QUIC may use more
than one level. For instance, after sending its Finished message (using
a CRYPTO frame at the Handshake encryption level) an endpoint can send
STREAM data (in 1-RTT encryption). If the Finished message is lost, the
endpoint uses the Handshake encryption level to retransmit the lost
message. Reordering or loss of packets can mean that QUIC will need to
handle packets at multiple encryption levels. During the handshake, this
means potentially handling packets at higher and lower encryption levels
than the current encryption level used by
TLS.[¶](#section-4.1.4-9){.pilcrow}

In particular, server implementations need to be able to read packets at
the Handshake encryption level at the same time as the 0-RTT encryption
level. A client could interleave ACK frames that are protected with
Handshake keys with 0-RTT data, and the server needs to process those
acknowledgments in order to detect lost Handshake
packets.[¶](#section-4.1.4-10){.pilcrow}

QUIC also needs access to keys that might not ordinarily be available to
a TLS implementation. For instance, a client might need to acknowledge
Handshake packets before it is ready to send CRYPTO frames at that
encryption level. TLS therefore needs to provide keys to QUIC before it
might produce them for its own use.[¶](#section-4.1.4-11){.pilcrow}
:::
:::

::: {#tls-interface-summary}
::: {#section-4.1.5 .section}
#### [4.1.5.](#section-4.1.5){.section-number .selfRef} [TLS Interface Summary](#name-tls-interface-summary){.section-name .selfRef} {#name-tls-interface-summary}

[Figure 5](#exchange-summary){.xref} summarizes the exchange between
QUIC and TLS for both client and server. Solid arrows indicate packets
that carry handshake data; dashed arrows show where application data can
be sent. Each arrow is tagged with the encryption level used for that
transmission.[¶](#section-4.1.5-1){.pilcrow}

[]{#name-interaction-summary-between}

::: {#exchange-summary}
::: {#section-4.1.5-2.1 .artwork .art-text .alignLeft}
    Client                                                    Server
    ======                                                    ======

    Get Handshake
                         Initial ------------->
    Install tx 0-RTT keys
                         0-RTT - - - - - - - ->

                                                  Handshake Received
                                                       Get Handshake
                         <------------- Initial
                                               Install rx 0-RTT keys
                                              Install Handshake keys
                                                       Get Handshake
                         <----------- Handshake
                                               Install tx 1-RTT keys
                         <- - - - - - - - 1-RTT

    Handshake Received (Initial)
    Install Handshake keys
    Handshake Received (Handshake)
    Get Handshake
                         Handshake ----------->
    Handshake Complete
    Install 1-RTT keys
                         1-RTT - - - - - - - ->

                                                  Handshake Received
                                                  Handshake Complete
                                                 Handshake Confirmed
                                               Install rx 1-RTT keys
                         <--------------- 1-RTT
                               (HANDSHAKE_DONE)
    Handshake Confirmed
:::

[Figure 5](#figure-5){.selfRef}: [Interaction Summary between QUIC and
TLS](#name-interaction-summary-between){.selfRef}
:::

[Figure 5](#exchange-summary){.xref} shows the multiple packets that
form a single \"flight\" of messages being processed individually, to
show what incoming messages trigger different actions. This shows
multiple \"Get Handshake\" invocations to retrieve handshake messages at
different encryption levels. New handshake messages are requested after
incoming packets have been processed.[¶](#section-4.1.5-3){.pilcrow}

[Figure 5](#exchange-summary){.xref} shows one possible structure for a
simple handshake exchange. The exact process varies based on the
structure of endpoint implementations and the order in which packets
arrive. Implementations could use a different number of operations or
execute them in other orders.[¶](#section-4.1.5-4){.pilcrow}
:::
:::
:::
:::

::: {#tls-version}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [TLS Version](#name-tls-version){.section-name .selfRef} {#name-tls-version}

This document describes how TLS 1.3 \[[TLS13](#TLS13){.xref}\] is used
with QUIC.[¶](#section-4.2-1){.pilcrow}

In practice, the TLS handshake will negotiate a version of TLS to use.
This could result in a version of TLS newer than 1.3 being negotiated if
both endpoints support that version. This is acceptable provided that
the features of TLS 1.3 that are used by QUIC are supported by the newer
version.[¶](#section-4.2-2){.pilcrow}

Clients [MUST NOT]{.bcp14} offer TLS versions older than 1.3. A badly
configured TLS implementation could negotiate TLS 1.2 or another older
version of TLS. An endpoint [MUST]{.bcp14} terminate the connection if a
version of TLS older than 1.3 is
negotiated.[¶](#section-4.2-3){.pilcrow}
:::
:::

::: {#clienthello-size}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [ClientHello Size](#name-clienthello-size){.section-name .selfRef} {#name-clienthello-size}

The first Initial packet from a client contains the start or all of its
first cryptographic handshake message, which for TLS is the ClientHello.
Servers might need to parse the entire ClientHello (e.g., to access
extensions such as Server Name Identification (SNI) or Application-Layer
Protocol Negotiation (ALPN)) in order to decide whether to accept the
new incoming QUIC connection. If the ClientHello spans multiple Initial
packets, such servers would need to buffer the first received fragments,
which could consume excessive resources if the client\'s address has not
yet been validated. To avoid this, servers [MAY]{.bcp14} use the Retry
feature (see [Section
8.1](https://www.rfc-editor.org/rfc/rfc9000#section-8.1){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]) to only buffer partial
ClientHello messages from clients with a validated
address.[¶](#section-4.3-1){.pilcrow}

QUIC packet and framing add at least 36 bytes of overhead to the
ClientHello message. That overhead increases if the client chooses a
Source Connection ID field longer than zero bytes. Overheads also do not
include the token or a Destination Connection ID longer than 8 bytes,
both of which might be required if a server sends a Retry
packet.[¶](#section-4.3-2){.pilcrow}

A typical TLS ClientHello can easily fit into a 1200-byte packet.
However, in addition to the overheads added by QUIC, there are several
variables that could cause this limit to be exceeded. Large session
tickets, multiple or large key shares, and long lists of supported
ciphers, signature algorithms, versions, QUIC transport parameters, and
other negotiable parameters and extensions could cause this message to
grow.[¶](#section-4.3-3){.pilcrow}

For servers, in addition to connection IDs and tokens, the size of TLS
session tickets can have an effect on a client\'s ability to connect
efficiently. Minimizing the size of these values increases the
probability that clients can use them and still fit their entire
ClientHello message in their first Initial
packet.[¶](#section-4.3-4){.pilcrow}

The TLS implementation does not need to ensure that the ClientHello is
large enough to meet QUIC\'s requirements for datagrams that carry
Initial packets; see [Section
14.1](https://www.rfc-editor.org/rfc/rfc9000#section-14.1){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]. QUIC implementations use
PADDING frames or packet coalescing to ensure that datagrams are large
enough.[¶](#section-4.3-5){.pilcrow}
:::
:::

::: {#peer-authentication}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Peer Authentication](#name-peer-authentication){.section-name .selfRef} {#name-peer-authentication}

The requirements for authentication depend on the application protocol
that is in use. TLS provides server authentication and permits the
server to request client authentication.[¶](#section-4.4-1){.pilcrow}

A client [MUST]{.bcp14} authenticate the identity of the server. This
typically involves verification that the identity of the server is
included in a certificate and that the certificate is issued by a
trusted entity (see for example
\[[RFC2818](#RFC2818){.xref}\]).[¶](#section-4.4-2){.pilcrow}

Note: Where servers provide certificates for authentication, the size of
the certificate chain can consume a large number of bytes. Controlling
the size of certificate chains is critical to performance in QUIC as
servers are limited to sending 3 bytes for every byte received prior to
validating the client address; see [Section
8.1](https://www.rfc-editor.org/rfc/rfc9000#section-8.1){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]. The size of a certificate
chain can be managed by limiting the number of names or extensions;
using keys with small public key representations, like ECDSA; or by
using certificate compression
\[[COMPRESS](#COMPRESS){.xref}\].[¶](#section-4.4-3.1){.pilcrow}

A server [MAY]{.bcp14} request that the client authenticate during the
handshake. A server [MAY]{.bcp14} refuse a connection if the client is
unable to authenticate when requested. The requirements for client
authentication vary based on application protocol and
deployment.[¶](#section-4.4-4){.pilcrow}

A server [MUST NOT]{.bcp14} use post-handshake client authentication (as
defined in [Section
4.6.2](https://www.rfc-editor.org/rfc/rfc8446#section-4.6.2){.relref} of
\[[TLS13](#TLS13){.xref}\]) because the multiplexing offered by QUIC
prevents clients from correlating the certificate request with the
application-level event that triggered it (see
\[[HTTP2-TLS13](#HTTP2-TLS13){.xref}\]). More specifically, servers
[MUST NOT]{.bcp14} send post-handshake TLS CertificateRequest messages,
and clients [MUST]{.bcp14} treat receipt of such messages as a
connection error of type
PROTOCOL_VIOLATION.[¶](#section-4.4-5){.pilcrow}
:::
:::

::: {#resumption}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [Session Resumption](#name-session-resumption){.section-name .selfRef} {#name-session-resumption}

QUIC can use the session resumption feature of TLS 1.3. It does this by
carrying NewSessionTicket messages in CRYPTO frames after the handshake
is complete. Session resumption can be used to provide 0-RTT and can
also be used when 0-RTT is disabled.[¶](#section-4.5-1){.pilcrow}

Endpoints that use session resumption might need to remember some
information about the current connection when creating a resumed
connection. TLS requires that some information be retained; see [Section
4.6.1](https://www.rfc-editor.org/rfc/rfc8446#section-4.6.1){.relref} of
\[[TLS13](#TLS13){.xref}\]. QUIC itself does not depend on any state
being retained when resuming a connection unless 0-RTT is also used; see
[Section
7.4.1](https://www.rfc-editor.org/rfc/rfc9000#section-7.4.1){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\] and [Section
4.6.1](#enable-0rtt){.xref}. Application protocols could depend on state
that is retained between resumed
connections.[¶](#section-4.5-2){.pilcrow}

Clients can store any state required for resumption along with the
session ticket. Servers can use the session ticket to help carry
state.[¶](#section-4.5-3){.pilcrow}

Session resumption allows servers to link activity on the original
connection with the resumed connection, which might be a privacy issue
for clients. Clients can choose not to enable resumption to avoid
creating this correlation. Clients [SHOULD NOT]{.bcp14} reuse tickets as
that allows entities other than the server to correlate connections; see
[Appendix
C.4](https://www.rfc-editor.org/rfc/rfc8446#appendix-C.4){.relref} of
\[[TLS13](#TLS13){.xref}\].[¶](#section-4.5-4){.pilcrow}
:::
:::

::: {#rtt}
::: {#section-4.6 .section}
### [4.6.](#section-4.6){.section-number .selfRef} [0-RTT](#name-0-rtt){.section-name .selfRef} {#name-0-rtt}

The 0-RTT feature in QUIC allows a client to send application data
before the handshake is complete. This is made possible by reusing
negotiated parameters from a previous connection. To enable this, 0-RTT
depends on the client remembering critical parameters and providing the
server with a TLS session ticket that allows the server to recover the
same information.[¶](#section-4.6-1){.pilcrow}

This information includes parameters that determine TLS state, as
governed by \[[TLS13](#TLS13){.xref}\], QUIC transport parameters, the
chosen application protocol, and any information the application
protocol might need; see [Section 4.6.3](#app-0rtt){.xref}. This
information determines how 0-RTT packets and their contents are
formed.[¶](#section-4.6-2){.pilcrow}

To ensure that the same information is available to both endpoints, all
information used to establish 0-RTT comes from the same connection.
Endpoints cannot selectively disregard information that might alter the
sending or processing of 0-RTT.[¶](#section-4.6-3){.pilcrow}

\[[TLS13](#TLS13){.xref}\] sets a limit of seven days on the time
between the original connection and any attempt to use 0-RTT. There are
other constraints on 0-RTT usage, notably those caused by the potential
exposure to replay attack; see [Section
9.2](#replay){.xref}.[¶](#section-4.6-4){.pilcrow}

::: {#enable-0rtt}
::: {#section-4.6.1 .section}
#### [4.6.1.](#section-4.6.1){.section-number .selfRef} [Enabling 0-RTT](#name-enabling-0-rtt){.section-name .selfRef} {#name-enabling-0-rtt}

The TLS early_data extension in the NewSessionTicket message is defined
to convey (in the max_early_data_size parameter) the amount of TLS 0-RTT
data the server is willing to accept. QUIC does not use TLS early data.
QUIC uses 0-RTT packets to carry early data. Accordingly, the
max_early_data_size parameter is repurposed to hold a sentinel value
0xffffffff to indicate that the server is willing to accept QUIC 0-RTT
data. To indicate that the server does not accept 0-RTT data, the
early_data extension is omitted from the NewSessionTicket. The amount of
data that the client can send in QUIC 0-RTT is controlled by the
initial_max_data transport parameter supplied by the
server.[¶](#section-4.6.1-1){.pilcrow}

Servers [MUST NOT]{.bcp14} send the early_data extension with a
max_early_data_size field set to any value other than 0xffffffff. A
client [MUST]{.bcp14} treat receipt of a NewSessionTicket that contains
an early_data extension with any other value as a connection error of
type PROTOCOL_VIOLATION.[¶](#section-4.6.1-2){.pilcrow}

A client that wishes to send 0-RTT packets uses the early_data extension
in the ClientHello message of a subsequent handshake; see [Section
4.2.10](https://www.rfc-editor.org/rfc/rfc8446#section-4.2.10){.relref}
of \[[TLS13](#TLS13){.xref}\]. It then sends application data in 0-RTT
packets.[¶](#section-4.6.1-3){.pilcrow}

A client that attempts 0-RTT might also provide an address validation
token if the server has sent a NEW_TOKEN frame; see [Section
8.1](https://www.rfc-editor.org/rfc/rfc9000#section-8.1){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-4.6.1-4){.pilcrow}
:::
:::

::: {#accepting-and-rejecting-0-rtt}
::: {#section-4.6.2 .section}
#### [4.6.2.](#section-4.6.2){.section-number .selfRef} [Accepting and Rejecting 0-RTT](#name-accepting-and-rejecting-0-r){.section-name .selfRef} {#name-accepting-and-rejecting-0-r}

A server accepts 0-RTT by sending an early_data extension in the
EncryptedExtensions; see [Section
4.2.10](https://www.rfc-editor.org/rfc/rfc8446#section-4.2.10){.relref}
of \[[TLS13](#TLS13){.xref}\]. The server then processes and
acknowledges the 0-RTT packets that it
receives.[¶](#section-4.6.2-1){.pilcrow}

A server rejects 0-RTT by sending the EncryptedExtensions without an
early_data extension. A server will always reject 0-RTT if it sends a
TLS HelloRetryRequest. When rejecting 0-RTT, a server [MUST NOT]{.bcp14}
process any 0-RTT packets, even if it could. When 0-RTT was rejected, a
client [SHOULD]{.bcp14} treat receipt of an acknowledgment for a 0-RTT
packet as a connection error of type PROTOCOL_VIOLATION, if it is able
to detect the condition.[¶](#section-4.6.2-2){.pilcrow}

When 0-RTT is rejected, all connection characteristics that the client
assumed might be incorrect. This includes the choice of application
protocol, transport parameters, and any application configuration. The
client therefore [MUST]{.bcp14} reset the state of all streams,
including application state bound to those
streams.[¶](#section-4.6.2-3){.pilcrow}

A client [MAY]{.bcp14} reattempt 0-RTT if it receives a Retry or Version
Negotiation packet. These packets do not signify rejection of
0-RTT.[¶](#section-4.6.2-4){.pilcrow}
:::
:::

::: {#app-0rtt}
::: {#section-4.6.3 .section}
#### [4.6.3.](#section-4.6.3){.section-number .selfRef} [Validating 0-RTT Configuration](#name-validating-0-rtt-configurat){.section-name .selfRef} {#name-validating-0-rtt-configurat}

When a server receives a ClientHello with the early_data extension, it
has to decide whether to accept or reject 0-RTT data from the client.
Some of this decision is made by the TLS stack (e.g., checking that the
cipher suite being resumed was included in the ClientHello; see [Section
4.2.10](https://www.rfc-editor.org/rfc/rfc8446#section-4.2.10){.relref}
of \[[TLS13](#TLS13){.xref}\]). Even when the TLS stack has no reason to
reject 0-RTT data, the QUIC stack or the application protocol using QUIC
might reject 0-RTT data because the configuration of the transport or
application associated with the resumed session is not compatible with
the server\'s current configuration.[¶](#section-4.6.3-1){.pilcrow}

QUIC requires additional transport state to be associated with a 0-RTT
session ticket. One common way to implement this is using stateless
session tickets and storing this state in the session ticket.
Application protocols that use QUIC might have similar requirements
regarding associating or storing state. This associated state is used
for deciding whether 0-RTT data must be rejected. For example, HTTP/3
settings \[[QUIC-HTTP](#QUIC-HTTP){.xref}\] determine how 0-RTT data
from the client is interpreted. Other applications using QUIC could have
different requirements for determining whether to accept or reject 0-RTT
data.[¶](#section-4.6.3-2){.pilcrow}
:::
:::
:::
:::

::: {#helloretryrequest}
::: {#section-4.7 .section}
### [4.7.](#section-4.7){.section-number .selfRef} [HelloRetryRequest](#name-helloretryrequest){.section-name .selfRef} {#name-helloretryrequest}

The HelloRetryRequest message (see [Section
4.1.4](https://www.rfc-editor.org/rfc/rfc8446#section-4.1.4){.relref} of
\[[TLS13](#TLS13){.xref}\]) can be used to request that a client provide
new information, such as a key share, or to validate some characteristic
of the client. From the perspective of QUIC, HelloRetryRequest is not
differentiated from other cryptographic handshake messages that are
carried in Initial packets. Although it is in principle possible to use
this feature for address verification, QUIC implementations
[SHOULD]{.bcp14} instead use the Retry feature; see [Section
8.1](https://www.rfc-editor.org/rfc/rfc9000#section-8.1){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-4.7-1){.pilcrow}
:::
:::

::: {#tls-errors}
::: {#section-4.8 .section}
### [4.8.](#section-4.8){.section-number .selfRef} [TLS Errors](#name-tls-errors){.section-name .selfRef} {#name-tls-errors}

If TLS experiences an error, it generates an appropriate alert as
defined in [Section
6](https://www.rfc-editor.org/rfc/rfc8446#section-6){.relref} of
\[[TLS13](#TLS13){.xref}\].[¶](#section-4.8-1){.pilcrow}

A TLS alert is converted into a QUIC connection error. The
AlertDescription value is added to 0x0100 to produce a QUIC error code
from the range reserved for CRYPTO_ERROR; see [Section
20.1](https://www.rfc-editor.org/rfc/rfc9000#section-20.1){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]. The resulting value is
sent in a QUIC CONNECTION_CLOSE frame of type
0x1c.[¶](#section-4.8-2){.pilcrow}

QUIC is only able to convey an alert level of \"fatal\". In TLS 1.3, the
only existing uses for the \"warning\" level are to signal connection
close; see [Section
6.1](https://www.rfc-editor.org/rfc/rfc8446#section-6.1){.relref} of
\[[TLS13](#TLS13){.xref}\]. As QUIC provides alternative mechanisms for
connection termination and the TLS connection is only closed if an error
is encountered, a QUIC endpoint [MUST]{.bcp14} treat any alert from TLS
as if it were at the \"fatal\" level.[¶](#section-4.8-3){.pilcrow}

QUIC permits the use of a generic code in place of a specific error
code; see [Section
11](https://www.rfc-editor.org/rfc/rfc9000#section-11){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]. For TLS alerts, this
includes replacing any alert with a generic alert, such as
handshake_failure (0x0128 in QUIC). Endpoints [MAY]{.bcp14} use a
generic error code to avoid possibly exposing confidential
information.[¶](#section-4.8-4){.pilcrow}
:::
:::

::: {#discarding-unused-keys}
::: {#section-4.9 .section}
### [4.9.](#section-4.9){.section-number .selfRef} [Discarding Unused Keys](#name-discarding-unused-keys){.section-name .selfRef} {#name-discarding-unused-keys}

After QUIC has completed a move to a new encryption level, packet
protection keys for previous encryption levels can be discarded. This
occurs several times during the handshake, as well as when keys are
updated; see [Section
6](#key-update){.xref}.[¶](#section-4.9-1){.pilcrow}

Packet protection keys are not discarded immediately when new keys are
available. If packets from a lower encryption level contain CRYPTO
frames, frames that retransmit that data [MUST]{.bcp14} be sent at the
same encryption level. Similarly, an endpoint generates acknowledgments
for packets at the same encryption level as the packet being
acknowledged. Thus, it is possible that keys for a lower encryption
level are needed for a short time after keys for a newer encryption
level are available.[¶](#section-4.9-2){.pilcrow}

An endpoint cannot discard keys for a given encryption level unless it
has received all the cryptographic handshake messages from its peer at
that encryption level and its peer has done the same. Different methods
for determining this are provided for Initial keys ([Section
4.9.1](#discard-initial){.xref}) and Handshake keys ([Section
4.9.2](#discard-handshake){.xref}). These methods do not prevent packets
from being received or sent at that encryption level because a peer
might not have received all the acknowledgments
necessary.[¶](#section-4.9-3){.pilcrow}

Though an endpoint might retain older keys, new data [MUST]{.bcp14} be
sent at the highest currently available encryption level. Only ACK
frames and retransmissions of data in CRYPTO frames are sent at a
previous encryption level. These packets [MAY]{.bcp14} also include
PADDING frames.[¶](#section-4.9-4){.pilcrow}

::: {#discard-initial}
::: {#section-4.9.1 .section}
#### [4.9.1.](#section-4.9.1){.section-number .selfRef} [Discarding Initial Keys](#name-discarding-initial-keys){.section-name .selfRef} {#name-discarding-initial-keys}

Packets protected with Initial secrets ([Section
5.2](#initial-secrets){.xref}) are not authenticated, meaning that an
attacker could spoof packets with the intent to disrupt a connection. To
limit these attacks, Initial packet protection keys are discarded more
aggressively than other keys.[¶](#section-4.9.1-1){.pilcrow}

The successful use of Handshake packets indicates that no more Initial
packets need to be exchanged, as these keys can only be produced after
receiving all CRYPTO frames from Initial packets. Thus, a client
[MUST]{.bcp14} discard Initial keys when it first sends a Handshake
packet and a server [MUST]{.bcp14} discard Initial keys when it first
successfully processes a Handshake packet. Endpoints [MUST NOT]{.bcp14}
send Initial packets after this point.[¶](#section-4.9.1-2){.pilcrow}

This results in abandoning loss recovery state for the Initial
encryption level and ignoring any outstanding Initial
packets.[¶](#section-4.9.1-3){.pilcrow}
:::
:::

::: {#discard-handshake}
::: {#section-4.9.2 .section}
#### [4.9.2.](#section-4.9.2){.section-number .selfRef} [Discarding Handshake Keys](#name-discarding-handshake-keys){.section-name .selfRef} {#name-discarding-handshake-keys}

An endpoint [MUST]{.bcp14} discard its Handshake keys when the TLS
handshake is confirmed ([Section
4.1.2](#handshake-confirmed){.xref}).[¶](#section-4.9.2-1){.pilcrow}
:::
:::

::: {#discarding-0-rtt-keys}
::: {#section-4.9.3 .section}
#### [4.9.3.](#section-4.9.3){.section-number .selfRef} [Discarding 0-RTT Keys](#name-discarding-0-rtt-keys){.section-name .selfRef} {#name-discarding-0-rtt-keys}

0-RTT and 1-RTT packets share the same packet number space, and clients
do not send 0-RTT packets after sending a 1-RTT packet ([Section
5.6](#using-early-data){.xref}).[¶](#section-4.9.3-1){.pilcrow}

Therefore, a client [SHOULD]{.bcp14} discard 0-RTT keys as soon as it
installs 1-RTT keys as they have no use after that
moment.[¶](#section-4.9.3-2){.pilcrow}

Additionally, a server [MAY]{.bcp14} discard 0-RTT keys as soon as it
receives a 1-RTT packet. However, due to packet reordering, a 0-RTT
packet could arrive after a 1-RTT packet. Servers [MAY]{.bcp14}
temporarily retain 0-RTT keys to allow decrypting reordered packets
without requiring their contents to be retransmitted with 1-RTT keys.
After receiving a 1-RTT packet, servers [MUST]{.bcp14} discard 0-RTT
keys within a short time; the [RECOMMENDED]{.bcp14} time period is three
times the Probe Timeout (PTO, see
\[[QUIC-RECOVERY](#QUIC-RECOVERY){.xref}\]). A server [MAY]{.bcp14}
discard 0-RTT keys earlier if it determines that it has received all
0-RTT packets, which can be done by keeping track of missing packet
numbers.[¶](#section-4.9.3-3){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#packet-protection}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Packet Protection](#name-packet-protection){.section-name .selfRef} {#name-packet-protection}

As with TLS over TCP, QUIC protects packets with keys derived from the
TLS handshake, using the AEAD algorithm \[[AEAD](#AEAD){.xref}\]
negotiated by TLS.[¶](#section-5-1){.pilcrow}

QUIC packets have varying protections depending on their
type:[¶](#section-5-2){.pilcrow}

-   [Version Negotiation packets have no cryptographic
    protection.[¶](#section-5-3.1){.pilcrow}]{#section-5-3.1}
-   [Retry packets use AEAD_AES_128_GCM to provide protection against
    accidental modification and to limit the entities that can produce a
    valid Retry; see [Section
    5.8](#retry-integrity){.xref}.[¶](#section-5-3.2){.pilcrow}]{#section-5-3.2}
-   [Initial packets use AEAD_AES_128_GCM with keys derived from the
    Destination Connection ID field of the first Initial packet sent by
    the client; see [Section
    5.2](#initial-secrets){.xref}.[¶](#section-5-3.3){.pilcrow}]{#section-5-3.3}
-   [All other packets have strong cryptographic protections for
    confidentiality and integrity, using keys and algorithms negotiated
    by TLS.[¶](#section-5-3.4){.pilcrow}]{#section-5-3.4}

This section describes how packet protection is applied to Handshake
packets, 0-RTT packets, and 1-RTT packets. The same packet protection
process is applied to Initial packets. However, as it is trivial to
determine the keys used for Initial packets, these packets are not
considered to have confidentiality or integrity protection. Retry
packets use a fixed key and so similarly lack confidentiality and
integrity protection.[¶](#section-5-4){.pilcrow}

::: {#protection-keys}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Packet Protection Keys](#name-packet-protection-keys){.section-name .selfRef} {#name-packet-protection-keys}

QUIC derives packet protection keys in the same way that TLS derives
record protection keys.[¶](#section-5.1-1){.pilcrow}

Each encryption level has separate secret values for protection of
packets sent in each direction. These traffic secrets are derived by TLS
(see [Section
7.1](https://www.rfc-editor.org/rfc/rfc8446#section-7.1){.relref} of
\[[TLS13](#TLS13){.xref}\]) and are used by QUIC for all encryption
levels except the Initial encryption level. The secrets for the Initial
encryption level are computed based on the client\'s initial Destination
Connection ID, as described in [Section
5.2](#initial-secrets){.xref}.[¶](#section-5.1-2){.pilcrow}

The keys used for packet protection are computed from the TLS secrets
using the KDF provided by TLS. In TLS 1.3, the HKDF-Expand-Label
function described in [Section
7.1](https://www.rfc-editor.org/rfc/rfc8446#section-7.1){.relref} of
\[[TLS13](#TLS13){.xref}\] is used with the hash function from the
negotiated cipher suite. All uses of HKDF-Expand-Label in QUIC use a
zero-length Context.[¶](#section-5.1-3){.pilcrow}

Note that labels, which are described using strings, are encoded as
bytes using ASCII \[[ASCII](#ASCII){.xref}\] without quotes or any
trailing NUL byte.[¶](#section-5.1-4){.pilcrow}

Other versions of TLS [MUST]{.bcp14} provide a similar function in order
to be used with QUIC.[¶](#section-5.1-5){.pilcrow}

The current encryption level secret and the label \"quic key\" are input
to the KDF to produce the AEAD key; the label \"quic iv\" is used to
derive the Initialization Vector (IV); see [Section 5.3](#aead){.xref}.
The header protection key uses the \"quic hp\" label; see [Section
5.4](#header-protect){.xref}. Using these labels provides key separation
between QUIC and TLS; see [Section
9.6](#key-diversity){.xref}.[¶](#section-5.1-6){.pilcrow}

Both \"quic key\" and \"quic hp\" are used to produce keys, so the
Length provided to HKDF-Expand-Label along with these labels is
determined by the size of keys in the AEAD or header protection
algorithm. The Length provided with \"quic iv\" is the minimum length of
the AEAD nonce or 8 bytes if that is larger; see
\[[AEAD](#AEAD){.xref}\].[¶](#section-5.1-7){.pilcrow}

The KDF used for initial secrets is always the HKDF-Expand-Label
function from TLS 1.3; see [Section
5.2](#initial-secrets){.xref}.[¶](#section-5.1-8){.pilcrow}
:::
:::

::: {#initial-secrets}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Initial Secrets](#name-initial-secrets){.section-name .selfRef} {#name-initial-secrets}

Initial packets apply the packet protection process, but use a secret
derived from the Destination Connection ID field from the client\'s
first Initial packet.[¶](#section-5.2-1){.pilcrow}

This secret is determined by using HKDF-Extract (see [Section
2.2](https://www.rfc-editor.org/rfc/rfc5869#section-2.2){.relref} of
\[[HKDF](#HKDF){.xref}\]) with a salt of
0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a and the input keying material
(IKM) of the Destination Connection ID field. This produces an
intermediate pseudorandom key (PRK) that is used to derive two separate
secrets for sending and receiving.[¶](#section-5.2-2){.pilcrow}

The secret used by clients to construct Initial packets uses the PRK and
the label \"client in\" as input to the HKDF-Expand-Label function from
TLS \[[TLS13](#TLS13){.xref}\] to produce a 32-byte secret. Packets
constructed by the server use the same process with the label \"server
in\". The hash function for HKDF when deriving initial secrets and keys
is SHA-256 \[[SHA](#SHA){.xref}\].[¶](#section-5.2-3){.pilcrow}

This process in pseudocode is:[¶](#section-5.2-4){.pilcrow}

::: {#section-5.2-5 .artwork .art-text .alignLeft}
    initial_salt = 0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a
    initial_secret = HKDF-Extract(initial_salt,
                                  client_dst_connection_id)

    client_initial_secret = HKDF-Expand-Label(initial_secret,
                                              "client in", "",
                                              Hash.length)
    server_initial_secret = HKDF-Expand-Label(initial_secret,
                                              "server in", "",
                                              Hash.length)

[¶](#section-5.2-5){.pilcrow}
:::

The connection ID used with HKDF-Expand-Label is the Destination
Connection ID in the Initial packet sent by the client. This will be a
randomly selected value unless the client creates the Initial packet
after receiving a Retry packet, where the Destination Connection ID is
selected by the server.[¶](#section-5.2-6){.pilcrow}

Future versions of QUIC [SHOULD]{.bcp14} generate a new salt value, thus
ensuring that the keys are different for each version of QUIC. This
prevents a middlebox that recognizes only one version of QUIC from
seeing or modifying the contents of packets from future
versions.[¶](#section-5.2-7){.pilcrow}

The HKDF-Expand-Label function defined in TLS 1.3 [MUST]{.bcp14} be used
for Initial packets even where the TLS versions offered do not include
TLS 1.3.[¶](#section-5.2-8){.pilcrow}

The secrets used for constructing subsequent Initial packets change when
a server sends a Retry packet to use the connection ID value selected by
the server. The secrets do not change when a client changes the
Destination Connection ID it uses in response to an Initial packet from
the server.[¶](#section-5.2-9){.pilcrow}

Note: The Destination Connection ID field could be any length up to 20
bytes, including zero length if the server sends a Retry packet with a
zero-length Source Connection ID field. After a Retry, the Initial keys
provide the client no assurance that the server received its packet, so
the client has to rely on the exchange that included the Retry packet to
validate the server address; see [Section
8.1](https://www.rfc-editor.org/rfc/rfc9000#section-8.1){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-5.2-10.1){.pilcrow}

[Appendix A](#test-vectors){.xref} contains sample Initial
packets.[¶](#section-5.2-11){.pilcrow}
:::
:::

::: {#aead}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [AEAD Usage](#name-aead-usage){.section-name .selfRef} {#name-aead-usage}

The Authenticated Encryption with Associated Data (AEAD) function (see
\[[AEAD](#AEAD){.xref}\]) used for QUIC packet protection is the AEAD
that is negotiated for use with the TLS connection. For example, if TLS
is using the TLS_AES_128_GCM_SHA256 cipher suite, the AEAD_AES_128_GCM
function is used.[¶](#section-5.3-1){.pilcrow}

QUIC can use any of the cipher suites defined in
\[[TLS13](#TLS13){.xref}\] with the exception of
TLS_AES_128_CCM_8\_SHA256. A cipher suite [MUST NOT]{.bcp14} be
negotiated unless a header protection scheme is defined for the cipher
suite. This document defines a header protection scheme for all cipher
suites defined in \[[TLS13](#TLS13){.xref}\] aside from
TLS_AES_128_CCM_8\_SHA256. These cipher suites have a 16-byte
authentication tag and produce an output 16 bytes larger than their
input.[¶](#section-5.3-2){.pilcrow}

An endpoint [MUST NOT]{.bcp14} reject a ClientHello that offers a cipher
suite that it does not support, or it would be impossible to deploy a
new cipher suite. This also applies to
TLS_AES_128_CCM_8\_SHA256.[¶](#section-5.3-3){.pilcrow}

When constructing packets, the AEAD function is applied prior to
applying header protection; see [Section 5.4](#header-protect){.xref}.
The unprotected packet header is part of the associated data (A). When
processing packets, an endpoint first removes the header
protection.[¶](#section-5.3-4){.pilcrow}

The key and IV for the packet are computed as described in [Section
5.1](#protection-keys){.xref}. The nonce, N, is formed by combining the
packet protection IV with the packet number. The 62 bits of the
reconstructed QUIC packet number in network byte order are left-padded
with zeros to the size of the IV. The exclusive OR of the padded packet
number and the IV forms the AEAD nonce.[¶](#section-5.3-5){.pilcrow}

The associated data, A, for the AEAD is the contents of the QUIC header,
starting from the first byte of either the short or long header, up to
and including the unprotected packet
number.[¶](#section-5.3-6){.pilcrow}

The input plaintext, P, for the AEAD is the payload of the QUIC packet,
as described in
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-5.3-7){.pilcrow}

The output ciphertext, C, of the AEAD is transmitted in place of
P.[¶](#section-5.3-8){.pilcrow}

Some AEAD functions have limits for how many packets can be encrypted
under the same key and IV; see [Section 6.6](#aead-limits){.xref}. This
might be lower than the packet number limit. An endpoint [MUST]{.bcp14}
initiate a key update ([Section 6](#key-update){.xref}) prior to
exceeding any limit set for the AEAD that is in
use.[¶](#section-5.3-9){.pilcrow}
:::
:::

::: {#header-protect}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [Header Protection](#name-header-protection){.section-name .selfRef} {#name-header-protection}

Parts of QUIC packet headers, in particular the Packet Number field, are
protected using a key that is derived separately from the packet
protection key and IV. The key derived using the \"quic hp\" label is
used to provide confidentiality protection for those fields that are not
exposed to on-path elements.[¶](#section-5.4-1){.pilcrow}

This protection applies to the least significant bits of the first byte,
plus the Packet Number field. The four least significant bits of the
first byte are protected for packets with long headers; the five least
significant bits of the first byte are protected for packets with short
headers. For both header forms, this covers the reserved bits and the
Packet Number Length field; the Key Phase bit is also protected for
packets with a short header.[¶](#section-5.4-2){.pilcrow}

The same header protection key is used for the duration of the
connection, with the value not changing after a key update (see [Section
6](#key-update){.xref}). This allows header protection to be used to
protect the key phase.[¶](#section-5.4-3){.pilcrow}

This process does not apply to Retry or Version Negotiation packets,
which do not contain a protected payload or any of the fields that are
protected by this process.[¶](#section-5.4-4){.pilcrow}

::: {#header-protection-application}
::: {#section-5.4.1 .section}
#### [5.4.1.](#section-5.4.1){.section-number .selfRef} [Header Protection Application](#name-header-protection-applicati){.section-name .selfRef} {#name-header-protection-applicati}

Header protection is applied after packet protection is applied (see
[Section 5.3](#aead){.xref}). The ciphertext of the packet is sampled
and used as input to an encryption algorithm. The algorithm used depends
on the negotiated AEAD.[¶](#section-5.4.1-1){.pilcrow}

The output of this algorithm is a 5-byte mask that is applied to the
protected header fields using exclusive OR. The least significant bits
of the first byte of the packet are masked by the least significant bits
of the first mask byte, and the packet number is masked with the
remaining bytes. Any unused bytes of mask that might result from a
shorter packet number encoding are
unused.[¶](#section-5.4.1-2){.pilcrow}

[Figure 6](#pseudo-hp){.xref} shows a sample algorithm for applying
header protection. Removing header protection only differs in the order
in which the packet number length (pn_length) is determined (here \"\^\"
is used to represent exclusive OR).[¶](#section-5.4.1-3){.pilcrow}

[]{#name-header-protection-pseudocod}

::: {#pseudo-hp}
::: {#section-5.4.1-4.1}
``` {.sourcecode .lang-pseudocode}
mask = header_protection(hp_key, sample)

pn_length = (packet[0] & 0x03) + 1
if (packet[0] & 0x80) == 0x80:
   # Long header: 4 bits masked
   packet[0] ^= mask[0] & 0x0f
else:
   # Short header: 5 bits masked
   packet[0] ^= mask[0] & 0x1f

# pn_offset is the start of the Packet Number field.
packet[pn_offset:pn_offset+pn_length] ^= mask[1:1+pn_length]
```
:::

[Figure 6](#figure-6){.selfRef}: [Header Protection
Pseudocode](#name-header-protection-pseudocod){.selfRef}
:::

Specific header protection functions are defined based on the selected
cipher suite; see [Section 5.4.3](#hp-aes){.xref} and [Section
5.4.4](#hp-chacha){.xref}.[¶](#section-5.4.1-5){.pilcrow}

[Figure 7](#fig-sample){.xref} shows an example long header packet
(Initial) and a short header packet (1-RTT). [Figure
7](#fig-sample){.xref} shows the fields in each header that are covered
by header protection and the portion of the protected packet payload
that is sampled.[¶](#section-5.4.1-6){.pilcrow}

[]{#name-header-protection-and-ciphe}

::: {#fig-sample}
::: {#section-5.4.1-7.1 .artwork .art-text .alignLeft}
    Initial Packet {
      Header Form (1) = 1,
      Fixed Bit (1) = 1,
      Long Packet Type (2) = 0,
      Reserved Bits (2),         # Protected
      Packet Number Length (2),  # Protected
      Version (32),
      DCID Len (8),
      Destination Connection ID (0..160),
      SCID Len (8),
      Source Connection ID (0..160),
      Token Length (i),
      Token (..),
      Length (i),
      Packet Number (8..32),     # Protected
      Protected Payload (0..24), # Skipped Part
      Protected Payload (128),   # Sampled Part
      Protected Payload (..)     # Remainder
    }

    1-RTT Packet {
      Header Form (1) = 0,
      Fixed Bit (1) = 1,
      Spin Bit (1),
      Reserved Bits (2),         # Protected
      Key Phase (1),             # Protected
      Packet Number Length (2),  # Protected
      Destination Connection ID (0..160),
      Packet Number (8..32),     # Protected
      Protected Payload (0..24), # Skipped Part
      Protected Payload (128),   # Sampled Part
      Protected Payload (..),    # Remainder
    }
:::

[Figure 7](#figure-7){.selfRef}: [Header Protection and Ciphertext
Sample](#name-header-protection-and-ciphe){.selfRef}
:::

Before a TLS cipher suite can be used with QUIC, a header protection
algorithm [MUST]{.bcp14} be specified for the AEAD used with that cipher
suite. This document defines algorithms for AEAD_AES_128_GCM,
AEAD_AES_128_CCM, AEAD_AES_256_GCM (all these AES AEADs are defined in
\[[AEAD](#AEAD){.xref}\]), and AEAD_CHACHA20_POLY1305 (defined in
\[[CHACHA](#CHACHA){.xref}\]). Prior to TLS selecting a cipher suite,
AES header protection is used ([Section 5.4.3](#hp-aes){.xref}),
matching the AEAD_AES_128_GCM packet
protection.[¶](#section-5.4.1-8){.pilcrow}
:::
:::

::: {#hp-sample}
::: {#section-5.4.2 .section}
#### [5.4.2.](#section-5.4.2){.section-number .selfRef} [Header Protection Sample](#name-header-protection-sample){.section-name .selfRef} {#name-header-protection-sample}

The header protection algorithm uses both the header protection key and
a sample of the ciphertext from the packet Payload
field.[¶](#section-5.4.2-1){.pilcrow}

The same number of bytes are always sampled, but an allowance needs to
be made for the removal of protection by a receiving endpoint, which
will not know the length of the Packet Number field. The sample of
ciphertext is taken starting from an offset of 4 bytes after the start
of the Packet Number field. That is, in sampling packet ciphertext for
header protection, the Packet Number field is assumed to be 4 bytes long
(its maximum possible encoded length).[¶](#section-5.4.2-2){.pilcrow}

An endpoint [MUST]{.bcp14} discard packets that are not long enough to
contain a complete sample.[¶](#section-5.4.2-3){.pilcrow}

To ensure that sufficient data is available for sampling, packets are
padded so that the combined lengths of the encoded packet number and
protected payload is at least 4 bytes longer than the sample required
for header protection. The cipher suites defined in
\[[TLS13](#TLS13){.xref}\] \-- other than TLS_AES_128_CCM_8\_SHA256, for
which a header protection scheme is not defined in this document \--
have 16-byte expansions and 16-byte header protection samples. This
results in needing at least 3 bytes of frames in the unprotected payload
if the packet number is encoded on a single byte, or 2 bytes of frames
for a 2-byte packet number encoding.[¶](#section-5.4.2-4){.pilcrow}

The sampled ciphertext can be determined by the following
pseudocode:[¶](#section-5.4.2-5){.pilcrow}

::: {#section-5.4.2-6}
``` {.sourcecode .lang-pseudocode}
# pn_offset is the start of the Packet Number field.
sample_offset = pn_offset + 4

sample = packet[sample_offset..sample_offset+sample_length]
```

[¶](#section-5.4.2-6){.pilcrow}
:::

Where the packet number offset of a short header packet can be
calculated as:[¶](#section-5.4.2-7){.pilcrow}

::: {#section-5.4.2-8}
``` {.sourcecode .lang-pseudocode}
pn_offset = 1 + len(connection_id)
```

[¶](#section-5.4.2-8){.pilcrow}
:::

And the packet number offset of a long header packet can be calculated
as:[¶](#section-5.4.2-9){.pilcrow}

::: {#section-5.4.2-10}
``` {.sourcecode .lang-pseudocode}
pn_offset = 7 + len(destination_connection_id) +
                len(source_connection_id) +
                len(payload_length)
if packet_type == Initial:
    pn_offset += len(token_length) +
                 len(token)
```

[¶](#section-5.4.2-10){.pilcrow}
:::

For example, for a packet with a short header, an 8-byte connection ID,
and protected with AEAD_AES_128_GCM, the sample takes bytes 13 to 28
inclusive (using zero-based indexing).[¶](#section-5.4.2-11){.pilcrow}

Multiple QUIC packets might be included in the same UDP datagram. Each
packet is handled separately.[¶](#section-5.4.2-12){.pilcrow}
:::
:::

::: {#hp-aes}
::: {#section-5.4.3 .section}
#### [5.4.3.](#section-5.4.3){.section-number .selfRef} [AES-Based Header Protection](#name-aes-based-header-protection){.section-name .selfRef} {#name-aes-based-header-protection}

This section defines the packet protection algorithm for
AEAD_AES_128_GCM, AEAD_AES_128_CCM, and AEAD_AES_256_GCM.
AEAD_AES_128_GCM and AEAD_AES_128_CCM use 128-bit AES in Electronic
Codebook (ECB) mode. AEAD_AES_256_GCM uses 256-bit AES in ECB mode. AES
is defined in \[[AES](#AES){.xref}\].[¶](#section-5.4.3-1){.pilcrow}

This algorithm samples 16 bytes from the packet ciphertext. This value
is used as the input to AES-ECB. In pseudocode, the header protection
function is defined as:[¶](#section-5.4.3-2){.pilcrow}

::: {#section-5.4.3-3}
``` {.sourcecode .lang-pseudocode}
header_protection(hp_key, sample):
  mask = AES-ECB(hp_key, sample)
```

[¶](#section-5.4.3-3){.pilcrow}
:::
:::
:::

::: {#hp-chacha}
::: {#section-5.4.4 .section}
#### [5.4.4.](#section-5.4.4){.section-number .selfRef} [ChaCha20-Based Header Protection](#name-chacha20-based-header-prote){.section-name .selfRef} {#name-chacha20-based-header-prote}

When AEAD_CHACHA20_POLY1305 is in use, header protection uses the raw
ChaCha20 function as defined in [Section
2.4](https://www.rfc-editor.org/rfc/rfc8439#section-2.4){.relref} of
\[[CHACHA](#CHACHA){.xref}\]. This uses a 256-bit key and 16 bytes
sampled from the packet protection
output.[¶](#section-5.4.4-1){.pilcrow}

The first 4 bytes of the sampled ciphertext are the block counter. A
ChaCha20 implementation could take a 32-bit integer in place of a byte
sequence, in which case, the byte sequence is interpreted as a
little-endian value.[¶](#section-5.4.4-2){.pilcrow}

The remaining 12 bytes are used as the nonce. A ChaCha20 implementation
might take an array of three 32-bit integers in place of a byte
sequence, in which case, the nonce bytes are interpreted as a sequence
of 32-bit little-endian integers.[¶](#section-5.4.4-3){.pilcrow}

The encryption mask is produced by invoking ChaCha20 to protect 5 zero
bytes. In pseudocode, the header protection function is defined
as:[¶](#section-5.4.4-4){.pilcrow}

::: {#section-5.4.4-5}
``` {.sourcecode .lang-pseudocode}
header_protection(hp_key, sample):
  counter = sample[0..3]
  nonce = sample[4..15]
  mask = ChaCha20(hp_key, counter, nonce, {0,0,0,0,0})
```

[¶](#section-5.4.4-5){.pilcrow}
:::
:::
:::
:::
:::

::: {#receiving-protected-packets}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [Receiving Protected Packets](#name-receiving-protected-packets){.section-name .selfRef} {#name-receiving-protected-packets}

Once an endpoint successfully receives a packet with a given packet
number, it [MUST]{.bcp14} discard all packets in the same packet number
space with higher packet numbers if they cannot be successfully
unprotected with either the same key, or \-- if there is a key update
\-- a subsequent packet protection key; see [Section
6](#key-update){.xref}. Similarly, a packet that appears to trigger a
key update but cannot be unprotected successfully [MUST]{.bcp14} be
discarded.[¶](#section-5.5-1){.pilcrow}

Failure to unprotect a packet does not necessarily indicate the
existence of a protocol error in a peer or an attack. The truncated
packet number encoding used in QUIC can cause packet numbers to be
decoded incorrectly if they are delayed
significantly.[¶](#section-5.5-2){.pilcrow}
:::
:::

::: {#using-early-data}
::: {#section-5.6 .section}
### [5.6.](#section-5.6){.section-number .selfRef} [Use of 0-RTT Keys](#name-use-of-0-rtt-keys){.section-name .selfRef} {#name-use-of-0-rtt-keys}

If 0-RTT keys are available (see [Section 4.6.1](#enable-0rtt){.xref}),
the lack of replay protection means that restrictions on their use are
necessary to avoid replay attacks on the
protocol.[¶](#section-5.6-1){.pilcrow}

Of the frames defined in \[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\],
the STREAM, RESET_STREAM, STOP_SENDING, and CONNECTION_CLOSE frames are
potentially unsafe for use with 0-RTT as they carry application data.
Application data that is received in 0-RTT could cause an application at
the server to process the data multiple times rather than just once.
Additional actions taken by a server as a result of processing replayed
application data could have unwanted consequences. A client therefore
[MUST NOT]{.bcp14} use 0-RTT for application data unless specifically
requested by the application that is in
use.[¶](#section-5.6-2){.pilcrow}

An application protocol that uses QUIC [MUST]{.bcp14} include a profile
that defines acceptable use of 0-RTT; otherwise, 0-RTT can only be used
to carry QUIC frames that do not carry application data. For example, a
profile for HTTP is described in \[[HTTP-REPLAY](#HTTP-REPLAY){.xref}\]
and used for HTTP/3; see [Section
10.9](https://tools.ietf.org/html/draft-ietf-quic-http-34#section-10.9){.relref}
of \[[QUIC-HTTP](#QUIC-HTTP){.xref}\].[¶](#section-5.6-3){.pilcrow}

Though replaying packets might result in additional connection attempts,
the effect of processing replayed frames that do not carry application
data is limited to changing the state of the affected connection. A TLS
handshake cannot be successfully completed using replayed
packets.[¶](#section-5.6-4){.pilcrow}

A client [MAY]{.bcp14} wish to apply additional restrictions on what
data it sends prior to the completion of the TLS
handshake.[¶](#section-5.6-5){.pilcrow}

A client otherwise treats 0-RTT keys as equivalent to 1-RTT keys, except
that it cannot send certain frames with 0-RTT keys; see [Section
12.5](https://www.rfc-editor.org/rfc/rfc9000#section-12.5){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-5.6-6){.pilcrow}

A client that receives an indication that its 0-RTT data has been
accepted by a server can send 0-RTT data until it receives all of the
server\'s handshake messages. A client [SHOULD]{.bcp14} stop sending
0-RTT data if it receives an indication that 0-RTT data has been
rejected.[¶](#section-5.6-7){.pilcrow}

A server [MUST NOT]{.bcp14} use 0-RTT keys to protect packets; it uses
1-RTT keys to protect acknowledgments of 0-RTT packets. A client [MUST
NOT]{.bcp14} attempt to decrypt 0-RTT packets it receives and instead
[MUST]{.bcp14} discard them.[¶](#section-5.6-8){.pilcrow}

Once a client has installed 1-RTT keys, it [MUST NOT]{.bcp14} send any
more 0-RTT packets.[¶](#section-5.6-9){.pilcrow}

Note: 0-RTT data can be acknowledged by the server as it receives it,
but any packets containing acknowledgments of 0-RTT data cannot have
packet protection removed by the client until the TLS handshake is
complete. The 1-RTT keys necessary to remove packet protection cannot be
derived until the client receives all server handshake
messages.[¶](#section-5.6-10.1){.pilcrow}
:::
:::

::: {#pre-hs-protected}
::: {#section-5.7 .section}
### [5.7.](#section-5.7){.section-number .selfRef} [Receiving Out-of-Order Protected Packets](#name-receiving-out-of-order-prot){.section-name .selfRef} {#name-receiving-out-of-order-prot}

Due to reordering and loss, protected packets might be received by an
endpoint before the final TLS handshake messages are received. A client
will be unable to decrypt 1-RTT packets from the server, whereas a
server will be able to decrypt 1-RTT packets from the client. Endpoints
in either role [MUST NOT]{.bcp14} decrypt 1-RTT packets from their peer
prior to completing the handshake.[¶](#section-5.7-1){.pilcrow}

Even though 1-RTT keys are available to a server after receiving the
first handshake messages from a client, it is missing assurances on the
client state:[¶](#section-5.7-2){.pilcrow}

-   [The client is not authenticated, unless the server has chosen to
    use a pre-shared key and validated the client\'s pre-shared key
    binder; see [Section
    4.2.11](https://www.rfc-editor.org/rfc/rfc8446#section-4.2.11){.relref}
    of
    \[[TLS13](#TLS13){.xref}\].[¶](#section-5.7-3.1){.pilcrow}]{#section-5.7-3.1}
-   [The client has not demonstrated liveness, unless the server has
    validated the client\'s address with a Retry packet or other means;
    see [Section
    8.1](https://www.rfc-editor.org/rfc/rfc9000#section-8.1){.relref} of
    \[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\].[¶](#section-5.7-3.2){.pilcrow}]{#section-5.7-3.2}
-   [Any received 0-RTT data that the server responds to might be due to
    a replay attack.[¶](#section-5.7-3.3){.pilcrow}]{#section-5.7-3.3}

Therefore, the server\'s use of 1-RTT keys before the handshake is
complete is limited to sending data. A server [MUST NOT]{.bcp14} process
incoming 1-RTT protected packets before the TLS handshake is complete.
Because sending acknowledgments indicates that all frames in a packet
have been processed, a server cannot send acknowledgments for 1-RTT
packets until the TLS handshake is complete. Received packets protected
with 1-RTT keys [MAY]{.bcp14} be stored and later decrypted and used
once the handshake is complete.[¶](#section-5.7-4){.pilcrow}

Note: TLS implementations might provide all 1-RTT secrets prior to
handshake completion. Even where QUIC implementations have 1-RTT read
keys, those keys are not to be used prior to completing the
handshake.[¶](#section-5.7-5.1){.pilcrow}

The requirement for the server to wait for the client Finished message
creates a dependency on that message being delivered. A client can avoid
the potential for head-of-line blocking that this implies by sending its
1-RTT packets coalesced with a Handshake packet containing a copy of the
CRYPTO frame that carries the Finished message, until one of the
Handshake packets is acknowledged. This enables immediate server
processing for those packets.[¶](#section-5.7-6){.pilcrow}

A server could receive packets protected with 0-RTT keys prior to
receiving a TLS ClientHello. The server [MAY]{.bcp14} retain these
packets for later decryption in anticipation of receiving a
ClientHello.[¶](#section-5.7-7){.pilcrow}

A client generally receives 1-RTT keys at the same time as the handshake
completes. Even if it has 1-RTT secrets, a client [MUST NOT]{.bcp14}
process incoming 1-RTT protected packets before the TLS handshake is
complete.[¶](#section-5.7-8){.pilcrow}
:::
:::

::: {#retry-integrity}
::: {#section-5.8 .section}
### [5.8.](#section-5.8){.section-number .selfRef} [Retry Packet Integrity](#name-retry-packet-integrity){.section-name .selfRef} {#name-retry-packet-integrity}

Retry packets (see [Section
17.2.5](https://www.rfc-editor.org/rfc/rfc9000#section-17.2.5){.relref}
of \[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]) carry a Retry Integrity
Tag that provides two properties: it allows the discarding of packets
that have accidentally been corrupted by the network, and only an entity
that observes an Initial packet can send a valid Retry
packet.[¶](#section-5.8-1){.pilcrow}

The Retry Integrity Tag is a 128-bit field that is computed as the
output of AEAD_AES_128_GCM \[[AEAD](#AEAD){.xref}\] used with the
following inputs:[¶](#section-5.8-2){.pilcrow}

-   [The secret key, K, is 128 bits equal to
    0xbe0c690b9f66575a1d766b54e368c84e.[¶](#section-5.8-3.1){.pilcrow}]{#section-5.8-3.1}
-   [The nonce, N, is 96 bits equal to
    0x461599d35d632bf2239825bb.[¶](#section-5.8-3.2){.pilcrow}]{#section-5.8-3.2}
-   [The plaintext, P, is
    empty.[¶](#section-5.8-3.3){.pilcrow}]{#section-5.8-3.3}
-   [The associated data, A, is the contents of the Retry Pseudo-Packet,
    as illustrated in [Figure
    8](#retry-pseudo){.xref}:[¶](#section-5.8-3.4){.pilcrow}]{#section-5.8-3.4}

The secret key and the nonce are values derived by calling
HKDF-Expand-Label using
0xd9c9943e6101fd200021506bcc02814c73030f25c79d71ce876eca876e6fca8e as
the secret, with labels being \"quic key\" and \"quic iv\" ([Section
5.1](#protection-keys){.xref}).[¶](#section-5.8-4){.pilcrow}

[]{#name-retry-pseudo-packet}

::: {#retry-pseudo}
::: {#section-5.8-5.1 .artwork .art-text .alignLeft}
    Retry Pseudo-Packet {
      ODCID Length (8),
      Original Destination Connection ID (0..160),
      Header Form (1) = 1,
      Fixed Bit (1) = 1,
      Long Packet Type (2) = 3,
      Unused (4),
      Version (32),
      DCID Len (8),
      Destination Connection ID (0..160),
      SCID Len (8),
      Source Connection ID (0..160),
      Retry Token (..),
    }
:::

[Figure 8](#figure-8){.selfRef}: [Retry
Pseudo-Packet](#name-retry-pseudo-packet){.selfRef}
:::

The Retry Pseudo-Packet is not sent over the wire. It is computed by
taking the transmitted Retry packet, removing the Retry Integrity Tag,
and prepending the two following fields:[¶](#section-5.8-6){.pilcrow}

[]{.break}

ODCID Length:

:   The ODCID Length field contains the length in bytes of the Original
    Destination Connection ID field that follows it, encoded as an 8-bit
    unsigned integer.[¶](#section-5.8-7.2.1){.pilcrow}

:   

Original Destination Connection ID:

:   The Original Destination Connection ID contains the value of the
    Destination Connection ID from the Initial packet that this Retry is
    in response to. The length of this field is given in ODCID Length.
    The presence of this field ensures that a valid Retry packet can
    only be sent by an entity that observes the Initial
    packet.[¶](#section-5.8-7.4.1){.pilcrow}

:   
:::
:::
:::
:::

::: {#key-update}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Key Update](#name-key-update){.section-name .selfRef} {#name-key-update}

Once the handshake is confirmed (see [Section
4.1.2](#handshake-confirmed){.xref}), an endpoint [MAY]{.bcp14} initiate
a key update.[¶](#section-6-1){.pilcrow}

The Key Phase bit indicates which packet protection keys are used to
protect the packet. The Key Phase bit is initially set to 0 for the
first set of 1-RTT packets and toggled to signal each subsequent key
update.[¶](#section-6-2){.pilcrow}

The Key Phase bit allows a recipient to detect a change in keying
material without needing to receive the first packet that triggered the
change. An endpoint that notices a changed Key Phase bit updates keys
and decrypts the packet that contains the changed
value.[¶](#section-6-3){.pilcrow}

Initiating a key update results in both endpoints updating keys. This
differs from TLS where endpoints can update keys
independently.[¶](#section-6-4){.pilcrow}

This mechanism replaces the key update mechanism of TLS, which relies on
KeyUpdate messages sent using 1-RTT encryption keys. Endpoints [MUST
NOT]{.bcp14} send a TLS KeyUpdate message. Endpoints [MUST]{.bcp14}
treat the receipt of a TLS KeyUpdate message as a connection error of
type 0x010a, equivalent to a fatal TLS alert of unexpected_message; see
[Section 4.8](#tls-errors){.xref}.[¶](#section-6-5){.pilcrow}

[Figure 9](#ex-key-update){.xref} shows a key update process, where the
initial set of keys used (identified with \@M) are replaced by updated
keys (identified with \@N). The value of the Key Phase bit is indicated
in brackets \[\].[¶](#section-6-6){.pilcrow}

[]{#name-key-update-2}

::: {#ex-key-update}
::: {#section-6-7.1 .artwork .art-text .alignLeft}
       Initiating Peer                    Responding Peer

    @M [0] QUIC Packets

    ... Update to @N
    @N [1] QUIC Packets
                          -------->
                                             Update to @N ...
                                          QUIC Packets [1] @N
                          <--------
                                          QUIC Packets [1] @N
                                        containing ACK
                          <--------
    ... Key Update Permitted

    @N [1] QUIC Packets
             containing ACK for @N packets
                          -------->
                                     Key Update Permitted ...
:::

[Figure 9](#figure-9){.selfRef}: [Key
Update](#name-key-update-2){.selfRef}
:::

::: {#key-update-initiate}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Initiating a Key Update](#name-initiating-a-key-update){.section-name .selfRef} {#name-initiating-a-key-update}

Endpoints maintain separate read and write secrets for packet
protection. An endpoint initiates a key update by updating its packet
protection write secret and using that to protect new packets. The
endpoint creates a new write secret from the existing write secret as
performed in [Section
7.2](https://www.rfc-editor.org/rfc/rfc8446#section-7.2){.relref} of
\[[TLS13](#TLS13){.xref}\]. This uses the KDF function provided by TLS
with a label of \"quic ku\". The corresponding key and IV are created
from that secret as defined in [Section 5.1](#protection-keys){.xref}.
The header protection key is not updated.[¶](#section-6.1-1){.pilcrow}

For example, to update write keys with TLS 1.3, HKDF-Expand-Label is
used as:[¶](#section-6.1-2){.pilcrow}

::: {#section-6.1-3}
``` {.sourcecode .lang-pseudocode}
secret_<n+1> = HKDF-Expand-Label(secret_<n>, "quic ku",
                                 "", Hash.length)
```

[¶](#section-6.1-3){.pilcrow}
:::

The endpoint toggles the value of the Key Phase bit and uses the updated
key and IV to protect all subsequent
packets.[¶](#section-6.1-4){.pilcrow}

An endpoint [MUST NOT]{.bcp14} initiate a key update prior to having
confirmed the handshake ([Section 4.1.2](#handshake-confirmed){.xref}).
An endpoint [MUST NOT]{.bcp14} initiate a subsequent key update unless
it has received an acknowledgment for a packet that was sent protected
with keys from the current key phase. This ensures that keys are
available to both peers before another key update can be initiated. This
can be implemented by tracking the lowest packet number sent with each
key phase and the highest acknowledged packet number in the 1-RTT space:
once the latter is higher than or equal to the former, another key
update can be initiated.[¶](#section-6.1-5){.pilcrow}

Note: Keys of packets other than the 1-RTT packets are never updated;
their keys are derived solely from the TLS handshake
state.[¶](#section-6.1-6.1){.pilcrow}

The endpoint that initiates a key update also updates the keys that it
uses for receiving packets. These keys will be needed to process packets
the peer sends after updating.[¶](#section-6.1-7){.pilcrow}

An endpoint [MUST]{.bcp14} retain old keys until it has successfully
unprotected a packet sent using the new keys. An endpoint
[SHOULD]{.bcp14} retain old keys for some time after unprotecting a
packet sent using the new keys. Discarding old keys too early can cause
delayed packets to be discarded. Discarding packets will be interpreted
as packet loss by the peer and could adversely affect
performance.[¶](#section-6.1-8){.pilcrow}
:::
:::

::: {#responding-to-a-key-update}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Responding to a Key Update](#name-responding-to-a-key-update){.section-name .selfRef} {#name-responding-to-a-key-update}

A peer is permitted to initiate a key update after receiving an
acknowledgment of a packet in the current key phase. An endpoint detects
a key update when processing a packet with a key phase that differs from
the value used to protect the last packet it sent. To process this
packet, the endpoint uses the next packet protection key and IV. See
[Section 6.3](#receive-key-generation){.xref} for considerations about
generating these keys.[¶](#section-6.2-1){.pilcrow}

If a packet is successfully processed using the next key and IV, then
the peer has initiated a key update. The endpoint [MUST]{.bcp14} update
its send keys to the corresponding key phase in response, as described
in [Section 6.1](#key-update-initiate){.xref}. Sending keys
[MUST]{.bcp14} be updated before sending an acknowledgment for the
packet that was received with updated keys. By acknowledging the packet
that triggered the key update in a packet protected with the updated
keys, the endpoint signals that the key update is
complete.[¶](#section-6.2-2){.pilcrow}

An endpoint can defer sending the packet or acknowledgment according to
its normal packet sending behavior; it is not necessary to immediately
generate a packet in response to a key update. The next packet sent by
the endpoint will use the updated keys. The next packet that contains an
acknowledgment will cause the key update to be completed. If an endpoint
detects a second update before it has sent any packets with updated keys
containing an acknowledgment for the packet that initiated the key
update, it indicates that its peer has updated keys twice without
awaiting confirmation. An endpoint [MAY]{.bcp14} treat such consecutive
key updates as a connection error of type
KEY_UPDATE_ERROR.[¶](#section-6.2-3){.pilcrow}

An endpoint that receives an acknowledgment that is carried in a packet
protected with old keys where any acknowledged packet was protected with
newer keys [MAY]{.bcp14} treat that as a connection error of type
KEY_UPDATE_ERROR. This indicates that a peer has received and
acknowledged a packet that initiates a key update, but has not updated
keys in response.[¶](#section-6.2-4){.pilcrow}
:::
:::

::: {#receive-key-generation}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Timing of Receive Key Generation](#name-timing-of-receive-key-gener){.section-name .selfRef} {#name-timing-of-receive-key-gener}

Endpoints responding to an apparent key update [MUST NOT]{.bcp14}
generate a timing side-channel signal that might indicate that the Key
Phase bit was invalid (see [Section 9.5](#hp-side-channel){.xref}).
Endpoints can use randomized packet protection keys in place of
discarded keys when key updates are not yet permitted. Using randomized
keys ensures that attempting to remove packet protection does not result
in timing variations, and results in packets with an invalid Key Phase
bit being rejected.[¶](#section-6.3-1){.pilcrow}

The process of creating new packet protection keys for receiving packets
could reveal that a key update has occurred. An endpoint [MAY]{.bcp14}
generate new keys as part of packet processing, but this creates a
timing signal that could be used by an attacker to learn when key
updates happen and thus leak the value of the Key Phase
bit.[¶](#section-6.3-2){.pilcrow}

Endpoints are generally expected to have current and next receive packet
protection keys available. For a short period after a key update
completes, up to the PTO, endpoints [MAY]{.bcp14} defer generation of
the next set of receive packet protection keys. This allows endpoints to
retain only two sets of receive keys; see [Section
6.5](#old-keys-recv){.xref}.[¶](#section-6.3-3){.pilcrow}

Once generated, the next set of packet protection keys [SHOULD]{.bcp14}
be retained, even if the packet that was received was subsequently
discarded. Packets containing apparent key updates are easy to forge,
and while the process of key update does not require significant effort,
triggering this process could be used by an attacker for
DoS.[¶](#section-6.3-4){.pilcrow}

For this reason, endpoints [MUST]{.bcp14} be able to retain two sets of
packet protection keys for receiving packets: the current and the next.
Retaining the previous keys in addition to these might improve
performance, but this is not essential.[¶](#section-6.3-5){.pilcrow}
:::
:::

::: {#old-keys-send}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [Sending with Updated Keys](#name-sending-with-updated-keys){.section-name .selfRef} {#name-sending-with-updated-keys}

An endpoint never sends packets that are protected with old keys. Only
the current keys are used. Keys used for protecting packets can be
discarded immediately after switching to newer
keys.[¶](#section-6.4-1){.pilcrow}

Packets with higher packet numbers [MUST]{.bcp14} be protected with
either the same or newer packet protection keys than packets with lower
packet numbers. An endpoint that successfully removes protection with
old keys when newer keys were used for packets with lower packet numbers
[MUST]{.bcp14} treat this as a connection error of type
KEY_UPDATE_ERROR.[¶](#section-6.4-2){.pilcrow}
:::
:::

::: {#old-keys-recv}
::: {#section-6.5 .section}
### [6.5.](#section-6.5){.section-number .selfRef} [Receiving with Different Keys](#name-receiving-with-different-ke){.section-name .selfRef} {#name-receiving-with-different-ke}

For receiving packets during a key update, packets protected with older
keys might arrive if they were delayed by the network. Retaining old
packet protection keys allows these packets to be successfully
processed.[¶](#section-6.5-1){.pilcrow}

As packets protected with keys from the next key phase use the same Key
Phase value as those protected with keys from the previous key phase, it
is necessary to distinguish between the two if packets protected with
old keys are to be processed. This can be done using packet numbers. A
recovered packet number that is lower than any packet number from the
current key phase uses the previous packet protection keys; a recovered
packet number that is higher than any packet number from the current key
phase requires the use of the next packet protection
keys.[¶](#section-6.5-2){.pilcrow}

Some care is necessary to ensure that any process for selecting between
previous, current, and next packet protection keys does not expose a
timing side channel that might reveal which keys were used to remove
packet protection. See [Section 9.5](#hp-side-channel){.xref} for more
information.[¶](#section-6.5-3){.pilcrow}

Alternatively, endpoints can retain only two sets of packet protection
keys, swapping previous for next after enough time has passed to allow
for reordering in the network. In this case, the Key Phase bit alone can
be used to select keys.[¶](#section-6.5-4){.pilcrow}

An endpoint [MAY]{.bcp14} allow a period of approximately the Probe
Timeout (PTO; see \[[QUIC-RECOVERY](#QUIC-RECOVERY){.xref}\]) after
promoting the next set of receive keys to be current before it creates
the subsequent set of packet protection keys. These updated keys
[MAY]{.bcp14} replace the previous keys at that time. With the caveat
that PTO is a subjective measure \-- that is, a peer could have a
different view of the RTT \-- this time is expected to be long enough
that any reordered packets would be declared lost by a peer even if they
were acknowledged and short enough to allow a peer to initiate further
key updates.[¶](#section-6.5-5){.pilcrow}

Endpoints need to allow for the possibility that a peer might not be
able to decrypt packets that initiate a key update during the period
when the peer retains old keys. Endpoints [SHOULD]{.bcp14} wait three
times the PTO before initiating a key update after receiving an
acknowledgment that confirms that the previous key update was received.
Failing to allow sufficient time could lead to packets being
discarded.[¶](#section-6.5-6){.pilcrow}

An endpoint [SHOULD]{.bcp14} retain old read keys for no more than three
times the PTO after having received a packet protected using the new
keys. After this period, old read keys and their corresponding secrets
[SHOULD]{.bcp14} be discarded.[¶](#section-6.5-7){.pilcrow}
:::
:::

::: {#aead-limits}
::: {#section-6.6 .section}
### [6.6.](#section-6.6){.section-number .selfRef} [Limits on AEAD Usage](#name-limits-on-aead-usage){.section-name .selfRef} {#name-limits-on-aead-usage}

This document sets usage limits for AEAD algorithms to ensure that
overuse does not give an adversary a disproportionate advantage in
attacking the confidentiality and integrity of communications when using
QUIC.[¶](#section-6.6-1){.pilcrow}

The usage limits defined in TLS 1.3 exist for protection against attacks
on confidentiality and apply to successful applications of AEAD
protection. The integrity protections in authenticated encryption also
depend on limiting the number of attempts to forge packets. TLS achieves
this by closing connections after any record fails an authentication
check. In comparison, QUIC ignores any packet that cannot be
authenticated, allowing multiple forgery
attempts.[¶](#section-6.6-2){.pilcrow}

QUIC accounts for AEAD confidentiality and integrity limits separately.
The confidentiality limit applies to the number of packets encrypted
with a given key. The integrity limit applies to the number of packets
decrypted within a given connection. Details on enforcing these limits
for each AEAD algorithm follow below.[¶](#section-6.6-3){.pilcrow}

Endpoints [MUST]{.bcp14} count the number of encrypted packets for each
set of keys. If the total number of encrypted packets with the same key
exceeds the confidentiality limit for the selected AEAD, the endpoint
[MUST]{.bcp14} stop using those keys. Endpoints [MUST]{.bcp14} initiate
a key update before sending more protected packets than the
confidentiality limit for the selected AEAD permits. If a key update is
not possible or integrity limits are reached, the endpoint
[MUST]{.bcp14} stop using the connection and only send stateless resets
in response to receiving packets. It is [RECOMMENDED]{.bcp14} that
endpoints immediately close the connection with a connection error of
type AEAD_LIMIT_REACHED before reaching a state where key updates are
not possible.[¶](#section-6.6-4){.pilcrow}

For AEAD_AES_128_GCM and AEAD_AES_256_GCM, the confidentiality limit is
2^23^ encrypted packets; see [Appendix B.1](#gcm-bounds){.xref}. For
AEAD_CHACHA20_POLY1305, the confidentiality limit is greater than the
number of possible packets (2^62^) and so can be disregarded. For
AEAD_AES_128_CCM, the confidentiality limit is 2^21.5^ encrypted
packets; see [Appendix B.2](#ccm-bounds){.xref}. Applying a limit
reduces the probability that an attacker can distinguish the AEAD in use
from a random permutation; see \[[AEBounds](#AEBounds){.xref}\],
\[[ROBUST](#ROBUST){.xref}\], and
\[[GCM-MU](#GCM-MU){.xref}\].[¶](#section-6.6-5){.pilcrow}

In addition to counting packets sent, endpoints [MUST]{.bcp14} count the
number of received packets that fail authentication during the lifetime
of a connection. If the total number of received packets that fail
authentication within the connection, across all keys, exceeds the
integrity limit for the selected AEAD, the endpoint [MUST]{.bcp14}
immediately close the connection with a connection error of type
AEAD_LIMIT_REACHED and not process any more
packets.[¶](#section-6.6-6){.pilcrow}

For AEAD_AES_128_GCM and AEAD_AES_256_GCM, the integrity limit is 2^52^
invalid packets; see [Appendix B.1](#gcm-bounds){.xref}. For
AEAD_CHACHA20_POLY1305, the integrity limit is 2^36^ invalid packets;
see \[[AEBounds](#AEBounds){.xref}\]. For AEAD_AES_128_CCM, the
integrity limit is 2^21.5^ invalid packets; see [Appendix
B.2](#ccm-bounds){.xref}. Applying this limit reduces the probability
that an attacker can successfully forge a packet; see
\[[AEBounds](#AEBounds){.xref}\], \[[ROBUST](#ROBUST){.xref}\], and
\[[GCM-MU](#GCM-MU){.xref}\].[¶](#section-6.6-7){.pilcrow}

Endpoints that limit the size of packets [MAY]{.bcp14} use higher
confidentiality and integrity limits; see [Appendix
B](#aead-analysis){.xref} for details.[¶](#section-6.6-8){.pilcrow}

Future analyses and specifications [MAY]{.bcp14} relax confidentiality
or integrity limits for an AEAD.[¶](#section-6.6-9){.pilcrow}

Any TLS cipher suite that is specified for use with QUIC [MUST]{.bcp14}
define limits on the use of the associated AEAD function that preserves
margins for confidentiality and integrity. That is, limits
[MUST]{.bcp14} be specified for the number of packets that can be
authenticated and for the number of packets that can fail
authentication. Providing a reference to any analysis upon which values
are based \-- and any assumptions used in that analysis \-- allows
limits to be adapted to varying usage
conditions.[¶](#section-6.6-10){.pilcrow}
:::
:::

::: {#key-update-error}
::: {#section-6.7 .section}
### [6.7.](#section-6.7){.section-number .selfRef} [Key Update Error Code](#name-key-update-error-code){.section-name .selfRef} {#name-key-update-error-code}

The KEY_UPDATE_ERROR error code (0x0e) is used to signal errors related
to key updates.[¶](#section-6.7-1){.pilcrow}
:::
:::
:::
:::

::: {#security-of-initial-messages}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Security of Initial Messages](#name-security-of-initial-message){.section-name .selfRef} {#name-security-of-initial-message}

Initial packets are not protected with a secret key, so they are subject
to potential tampering by an attacker. QUIC provides protection against
attackers that cannot read packets but does not attempt to provide
additional protection against attacks where the attacker can observe and
inject packets. Some forms of tampering \-- such as modifying the TLS
messages themselves \-- are detectable, but some \-- such as modifying
ACKs \-- are not.[¶](#section-7-1){.pilcrow}

For example, an attacker could inject a packet containing an ACK frame
to make it appear that a packet had not been received or to create a
false impression of the state of the connection (e.g., by modifying the
ACK Delay). Note that such a packet could cause a legitimate packet to
be dropped as a duplicate. Implementations [SHOULD]{.bcp14} use caution
in relying on any data that is contained in Initial packets that is not
otherwise authenticated.[¶](#section-7-2){.pilcrow}

It is also possible for the attacker to tamper with data that is carried
in Handshake packets, but because that sort of tampering requires
modifying TLS handshake messages, any such tampering will cause the TLS
handshake to fail.[¶](#section-7-3){.pilcrow}
:::
:::

::: {#quic-specific-adjustments-to-the-tls-handshake}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [QUIC-Specific Adjustments to the TLS Handshake](#name-quic-specific-adjustments-t){.section-name .selfRef} {#name-quic-specific-adjustments-t}

Certain aspects of the TLS handshake are different when used with
QUIC.[¶](#section-8-1){.pilcrow}

QUIC also requires additional features from TLS. In addition to
negotiation of cryptographic parameters, the TLS handshake carries and
authenticates values for QUIC transport
parameters.[¶](#section-8-2){.pilcrow}

::: {#protocol-negotiation}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Protocol Negotiation](#name-protocol-negotiation){.section-name .selfRef} {#name-protocol-negotiation}

QUIC requires that the cryptographic handshake provide authenticated
protocol negotiation. TLS uses Application-Layer Protocol Negotiation
\[[ALPN](#ALPN){.xref}\] to select an application protocol. Unless
another mechanism is used for agreeing on an application protocol,
endpoints [MUST]{.bcp14} use ALPN for this
purpose.[¶](#section-8.1-1){.pilcrow}

When using ALPN, endpoints [MUST]{.bcp14} immediately close a connection
(see [Section
10.2](https://www.rfc-editor.org/rfc/rfc9000#section-10.2){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]) with a
no_application_protocol TLS alert (QUIC error code 0x0178; see [Section
4.8](#tls-errors){.xref}) if an application protocol is not negotiated.
While \[[ALPN](#ALPN){.xref}\] only specifies that servers use this
alert, QUIC clients [MUST]{.bcp14} use error 0x0178 to terminate a
connection when ALPN negotiation fails.[¶](#section-8.1-2){.pilcrow}

An application protocol [MAY]{.bcp14} restrict the QUIC versions that it
can operate over. Servers [MUST]{.bcp14} select an application protocol
compatible with the QUIC version that the client has selected. The
server [MUST]{.bcp14} treat the inability to select a compatible
application protocol as a connection error of type 0x0178
(no_application_protocol). Similarly, a client [MUST]{.bcp14} treat the
selection of an incompatible application protocol by a server as a
connection error of type 0x0178.[¶](#section-8.1-3){.pilcrow}
:::
:::

::: {#quic_parameters}
::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [QUIC Transport Parameters Extension](#name-quic-transport-parameters-e){.section-name .selfRef} {#name-quic-transport-parameters-e}

QUIC transport parameters are carried in a TLS extension. Different
versions of QUIC might define a different method for negotiating
transport configuration.[¶](#section-8.2-1){.pilcrow}

Including transport parameters in the TLS handshake provides integrity
protection for these values.[¶](#section-8.2-2){.pilcrow}

::: {#section-8.2-3}
``` {.sourcecode .lang-tls-presentation}
   enum {
      quic_transport_parameters(0x39), (65535)
   } ExtensionType;
```

[¶](#section-8.2-3){.pilcrow}
:::

The extension_data field of the quic_transport_parameters extension
contains a value that is defined by the version of QUIC that is in
use.[¶](#section-8.2-4){.pilcrow}

The quic_transport_parameters extension is carried in the ClientHello
and the EncryptedExtensions messages during the handshake. Endpoints
[MUST]{.bcp14} send the quic_transport_parameters extension; endpoints
that receive ClientHello or EncryptedExtensions messages without the
quic_transport_parameters extension [MUST]{.bcp14} close the connection
with an error of type 0x016d (equivalent to a fatal TLS
missing_extension alert, see [Section
4.8](#tls-errors){.xref}).[¶](#section-8.2-5){.pilcrow}

Transport parameters become available prior to the completion of the
handshake. A server might use these values earlier than handshake
completion. However, the value of transport parameters is not
authenticated until the handshake completes, so any use of these
parameters cannot depend on their authenticity. Any tampering with
transport parameters will cause the handshake to
fail.[¶](#section-8.2-6){.pilcrow}

Endpoints [MUST NOT]{.bcp14} send this extension in a TLS connection
that does not use QUIC (such as the use of TLS with TCP defined in
\[[TLS13](#TLS13){.xref}\]). A fatal unsupported_extension alert
[MUST]{.bcp14} be sent by an implementation that supports this extension
if the extension is received when the transport is not
QUIC.[¶](#section-8.2-7){.pilcrow}

Negotiating the quic_transport_parameters extension causes the
EndOfEarlyData to be removed; see [Section
8.3](#remove-eoed){.xref}.[¶](#section-8.2-8){.pilcrow}
:::
:::

::: {#remove-eoed}
::: {#section-8.3 .section}
### [8.3.](#section-8.3){.section-number .selfRef} [Removing the EndOfEarlyData Message](#name-removing-the-endofearlydata){.section-name .selfRef} {#name-removing-the-endofearlydata}

The TLS EndOfEarlyData message is not used with QUIC. QUIC does not rely
on this message to mark the end of 0-RTT data or to signal the change to
Handshake keys.[¶](#section-8.3-1){.pilcrow}

Clients [MUST NOT]{.bcp14} send the EndOfEarlyData message. A server
[MUST]{.bcp14} treat receipt of a CRYPTO frame in a 0-RTT packet as a
connection error of type
PROTOCOL_VIOLATION.[¶](#section-8.3-2){.pilcrow}

As a result, EndOfEarlyData does not appear in the TLS handshake
transcript.[¶](#section-8.3-3){.pilcrow}
:::
:::

::: {#compat-mode}
::: {#section-8.4 .section}
### [8.4.](#section-8.4){.section-number .selfRef} [Prohibit TLS Middlebox Compatibility Mode](#name-prohibit-tls-middlebox-comp){.section-name .selfRef} {#name-prohibit-tls-middlebox-comp}

Appendix D.4 of \[[TLS13](#TLS13){.xref}\] describes an alteration to
the TLS 1.3 handshake as a workaround for bugs in some middleboxes. The
TLS 1.3 middlebox compatibility mode involves setting the
legacy_session_id field to a 32-byte value in the ClientHello and
ServerHello, then sending a change_cipher_spec record. Both field and
record carry no semantic content and are
ignored.[¶](#section-8.4-1){.pilcrow}

This mode has no use in QUIC as it only applies to middleboxes that
interfere with TLS over TCP. QUIC also provides no means to carry a
change_cipher_spec record. A client [MUST NOT]{.bcp14} request the use
of the TLS 1.3 compatibility mode. A server [SHOULD]{.bcp14} treat the
receipt of a TLS ClientHello with a non-empty legacy_session_id field as
a connection error of type
PROTOCOL_VIOLATION.[¶](#section-8.4-2){.pilcrow}
:::
:::
:::
:::

::: {#security-considerations}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

All of the security considerations that apply to TLS also apply to the
use of TLS in QUIC. Reading all of \[[TLS13](#TLS13){.xref}\] and its
appendices is the best way to gain an understanding of the security
properties of QUIC.[¶](#section-9-1){.pilcrow}

This section summarizes some of the more important security aspects
specific to the TLS integration, though there are many security-relevant
details in the remainder of the document.[¶](#section-9-2){.pilcrow}

::: {#session-linkability}
::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Session Linkability](#name-session-linkability){.section-name .selfRef} {#name-session-linkability}

Use of TLS session tickets allows servers and possibly other entities to
correlate connections made by the same client; see [Section
4.5](#resumption){.xref} for details.[¶](#section-9.1-1){.pilcrow}
:::
:::

::: {#replay}
::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Replay Attacks with 0-RTT](#name-replay-attacks-with-0-rtt){.section-name .selfRef} {#name-replay-attacks-with-0-rtt}

As described in [Section
8](https://www.rfc-editor.org/rfc/rfc8446#section-8){.relref} of
\[[TLS13](#TLS13){.xref}\], use of TLS early data comes with an exposure
to replay attack. The use of 0-RTT in QUIC is similarly vulnerable to
replay attack.[¶](#section-9.2-1){.pilcrow}

Endpoints [MUST]{.bcp14} implement and use the replay protections
described in \[[TLS13](#TLS13){.xref}\], however it is recognized that
these protections are imperfect. Therefore, additional consideration of
the risk of replay is needed.[¶](#section-9.2-2){.pilcrow}

QUIC is not vulnerable to replay attack, except via the application
protocol information it might carry. The management of QUIC protocol
state based on the frame types defined in
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\] is not vulnerable to
replay. Processing of QUIC frames is idempotent and cannot result in
invalid connection states if frames are replayed, reordered, or lost.
QUIC connections do not produce effects that last beyond the lifetime of
the connection, except for those produced by the application protocol
that QUIC serves.[¶](#section-9.2-3){.pilcrow}

TLS session tickets and address validation tokens are used to carry QUIC
configuration information between connections, specifically, to enable a
server to efficiently recover state that is used in connection
establishment and address validation. These [MUST NOT]{.bcp14} be used
to communicate application semantics between endpoints; clients
[MUST]{.bcp14} treat them as opaque values. The potential for reuse of
these tokens means that they require stronger protections against
replay.[¶](#section-9.2-4){.pilcrow}

A server that accepts 0-RTT on a connection incurs a higher cost than
accepting a connection without 0-RTT. This includes higher processing
and computation costs. Servers need to consider the probability of
replay and all associated costs when accepting
0-RTT.[¶](#section-9.2-5){.pilcrow}

Ultimately, the responsibility for managing the risks of replay attacks
with 0-RTT lies with an application protocol. An application protocol
that uses QUIC [MUST]{.bcp14} describe how the protocol uses 0-RTT and
the measures that are employed to protect against replay attack. An
analysis of replay risk needs to consider all QUIC protocol features
that carry application semantics.[¶](#section-9.2-6){.pilcrow}

Disabling 0-RTT entirely is the most effective defense against replay
attack.[¶](#section-9.2-7){.pilcrow}

QUIC extensions [MUST]{.bcp14} either describe how replay attacks affect
their operation or prohibit the use of the extension in 0-RTT.
Application protocols [MUST]{.bcp14} either prohibit the use of
extensions that carry application semantics in 0-RTT or provide replay
mitigation strategies.[¶](#section-9.2-8){.pilcrow}
:::
:::

::: {#reflection}
::: {#section-9.3 .section}
### [9.3.](#section-9.3){.section-number .selfRef} [Packet Reflection Attack Mitigation](#name-packet-reflection-attack-mi){.section-name .selfRef} {#name-packet-reflection-attack-mi}

A small ClientHello that results in a large block of handshake messages
from a server can be used in packet reflection attacks to amplify the
traffic generated by an attacker.[¶](#section-9.3-1){.pilcrow}

QUIC includes three defenses against this attack. First, the packet
containing a ClientHello [MUST]{.bcp14} be padded to a minimum size.
Second, if responding to an unverified source address, the server is
forbidden to send more than three times as many bytes as the number of
bytes it has received (see [Section
8.1](https://www.rfc-editor.org/rfc/rfc9000#section-8.1){.relref} of
\[[QUIC-TRANSPORT](#QUIC-TRANSPORT){.xref}\]). Finally, because
acknowledgments of Handshake packets are authenticated, a blind attacker
cannot forge them. Put together, these defenses limit the level of
amplification.[¶](#section-9.3-2){.pilcrow}
:::
:::

::: {#header-protect-analysis}
::: {#section-9.4 .section}
### [9.4.](#section-9.4){.section-number .selfRef} [Header Protection Analysis](#name-header-protection-analysis){.section-name .selfRef} {#name-header-protection-analysis}

\[[NAN](#NAN){.xref}\] analyzes authenticated encryption algorithms that
provide nonce privacy, referred to as \"Hide Nonce\" (HN) transforms.
The general header protection construction in this document is one of
those algorithms (HN1). Header protection is applied after the packet
protection AEAD, sampling a set of bytes (`sample`) from the AEAD output
and encrypting the header field using a pseudorandom function (PRF) as
follows:[¶](#section-9.4-1){.pilcrow}

::: {#section-9.4-2}
``` {.sourcecode .lang-pseudocode}
protected_field = field XOR PRF(hp_key, sample)
```

[¶](#section-9.4-2){.pilcrow}
:::

The header protection variants in this document use a pseudorandom
permutation (PRP) in place of a generic PRF. However, since all PRPs are
also PRFs \[[IMC](#IMC){.xref}\], these variants do not deviate from the
HN1 construction.[¶](#section-9.4-3){.pilcrow}

As `hp_key` is distinct from the packet protection key, it follows that
header protection achieves AE2 security as defined in
\[[NAN](#NAN){.xref}\] and therefore guarantees privacy of `field`, the
protected packet header. Future header protection variants based on this
construction [MUST]{.bcp14} use a PRF to ensure equivalent security
guarantees.[¶](#section-9.4-4){.pilcrow}

Use of the same key and ciphertext sample more than once risks
compromising header protection. Protecting two different headers with
the same key and ciphertext sample reveals the exclusive OR of the
protected fields. Assuming that the AEAD acts as a PRF, if L bits are
sampled, the odds of two ciphertext samples being identical approach
2^-L/2^, that is, the birthday bound. For the algorithms described in
this document, that probability is one in
2^64^.[¶](#section-9.4-5){.pilcrow}

To prevent an attacker from modifying packet headers, the header is
transitively authenticated using packet protection; the entire packet
header is part of the authenticated additional data. Protected fields
that are falsified or modified can only be detected once the packet
protection is removed.[¶](#section-9.4-6){.pilcrow}
:::
:::

::: {#hp-side-channel}
::: {#section-9.5 .section}
### [9.5.](#section-9.5){.section-number .selfRef} [Header Protection Timing Side Channels](#name-header-protection-timing-si){.section-name .selfRef} {#name-header-protection-timing-si}

An attacker could guess values for packet numbers or Key Phase and have
an endpoint confirm guesses through timing side channels. Similarly,
guesses for the packet number length can be tried and exposed. If the
recipient of a packet discards packets with duplicate packet numbers
without attempting to remove packet protection, they could reveal
through timing side channels that the packet number matches a received
packet. For authentication to be free from side channels, the entire
process of header protection removal, packet number recovery, and packet
protection removal [MUST]{.bcp14} be applied together without timing and
other side channels.[¶](#section-9.5-1){.pilcrow}

For the sending of packets, construction and protection of packet
payloads and packet numbers [MUST]{.bcp14} be free from side channels
that would reveal the packet number or its encoded
size.[¶](#section-9.5-2){.pilcrow}

During a key update, the time taken to generate new keys could reveal
through timing side channels that a key update has occurred.
Alternatively, where an attacker injects packets, this side channel
could reveal the value of the Key Phase on injected packets. After
receiving a key update, an endpoint [SHOULD]{.bcp14} generate and save
the next set of receive packet protection keys, as described in [Section
6.3](#receive-key-generation){.xref}. By generating new keys before a
key update is received, receipt of packets will not create timing
signals that leak the value of the Key
Phase.[¶](#section-9.5-3){.pilcrow}

This depends on not doing this key generation during packet processing,
and it can require that endpoints maintain three sets of packet
protection keys for receiving: for the previous key phase, for the
current key phase, and for the next key phase. Endpoints can instead
choose to defer generation of the next receive packet protection keys
until they discard old keys so that only two sets of receive keys need
to be retained at any point in time.[¶](#section-9.5-4){.pilcrow}
:::
:::

::: {#key-diversity}
::: {#section-9.6 .section}
### [9.6.](#section-9.6){.section-number .selfRef} [Key Diversity](#name-key-diversity){.section-name .selfRef} {#name-key-diversity}

In using TLS, the central key schedule of TLS is used. As a result of
the TLS handshake messages being integrated into the calculation of
secrets, the inclusion of the QUIC transport parameters extension
ensures that the handshake and 1-RTT keys are not the same as those that
might be produced by a server running TLS over TCP. To avoid the
possibility of cross-protocol key synchronization, additional measures
are provided to improve key separation.[¶](#section-9.6-1){.pilcrow}

The QUIC packet protection keys and IVs are derived using a different
label than the equivalent keys in TLS.[¶](#section-9.6-2){.pilcrow}

To preserve this separation, a new version of QUIC [SHOULD]{.bcp14}
define new labels for key derivation for packet protection key and IV,
plus the header protection keys. This version of QUIC uses the string
\"quic\". Other versions can use a version-specific label in place of
that string.[¶](#section-9.6-3){.pilcrow}

The initial secrets use a key that is specific to the negotiated QUIC
version. New QUIC versions [SHOULD]{.bcp14} define a new salt value used
in calculating initial secrets.[¶](#section-9.6-4){.pilcrow}
:::
:::

::: {#randomness}
::: {#section-9.7 .section}
### [9.7.](#section-9.7){.section-number .selfRef} [Randomness](#name-randomness){.section-name .selfRef} {#name-randomness}

QUIC depends on endpoints being able to generate secure random numbers,
both directly for protocol values such as the connection ID, and
transitively via TLS. See \[[RFC4086](#RFC4086){.xref}\] for guidance on
secure random number generation.[¶](#section-9.7-1){.pilcrow}
:::
:::
:::
:::

::: {#iana-considerations}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

IANA has registered a codepoint of 57 (or 0x39) for the
quic_transport_parameters extension (defined in [Section
8.2](#quic_parameters){.xref}) in the \"TLS ExtensionType Values\"
registry
\[[TLS-REGISTRIES](#TLS-REGISTRIES){.xref}\].[¶](#section-10-1){.pilcrow}

The Recommended column for this extension is marked Yes. The TLS 1.3
Column includes CH (ClientHello) and EE
(EncryptedExtensions).[¶](#section-10-2){.pilcrow}

[]{#name-tls-extensiontype-values-re}

::: {#iana-tls-ext}
  Value   Extension Name              TLS 1.3   Recommended   Reference
  ------- --------------------------- --------- ------------- ---------------
  57      quic_transport_parameters   CH, EE    Y             This document

  : [Table 2](#table-2){.selfRef}: [TLS ExtensionType Values Registry
  Entry](#name-tls-extensiontype-values-re){.selfRef}
:::
:::
:::

::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-11.1 .section}
### [11.1.](#section-11.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[AEAD\]
:   [McGrew, D.]{.refAuthor}, [\"An Interface and Algorithms for
    Authenticated Encryption\"]{.refTitle}, [RFC 5116]{.seriesInfo},
    [DOI 10.17487/RFC5116]{.seriesInfo}, January 2008,
    \<<https://www.rfc-editor.org/info/rfc5116>\>.
:   

\[AES\]
:   [\"Advanced encryption standard (AES)\"]{.refTitle}, [National
    Institute of Standards and Technology report]{.seriesInfo}, [DOI
    10.6028/nist.fips.197]{.seriesInfo}, November 2001,
    \<<https://doi.org/10.6028/nist.fips.197>\>.
:   

\[ALPN\]
:   [Friedl, S.]{.refAuthor}, [Popov, A.]{.refAuthor},
    [Langley, A.]{.refAuthor}, and [E. Stephan]{.refAuthor},
    [\"Transport Layer Security (TLS) Application-Layer Protocol
    Negotiation Extension\"]{.refTitle}, [RFC 7301]{.seriesInfo}, [DOI
    10.17487/RFC7301]{.seriesInfo}, July 2014,
    \<<https://www.rfc-editor.org/info/rfc7301>\>.
:   

\[CHACHA\]
:   [Nir, Y.]{.refAuthor} and [A. Langley]{.refAuthor}, [\"ChaCha20 and
    Poly1305 for IETF Protocols\"]{.refTitle}, [RFC 8439]{.seriesInfo},
    [DOI 10.17487/RFC8439]{.seriesInfo}, June 2018,
    \<<https://www.rfc-editor.org/info/rfc8439>\>.
:   

\[HKDF\]
:   [Krawczyk, H.]{.refAuthor} and [P. Eronen]{.refAuthor},
    [\"HMAC-based Extract-and-Expand Key Derivation Function
    (HKDF)\"]{.refTitle}, [RFC 5869]{.seriesInfo}, [DOI
    10.17487/RFC5869]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5869>\>.
:   

\[QUIC-RECOVERY\]
:   [Iyengar, J., Ed.]{.refAuthor} and [I. Swett, Ed.]{.refAuthor},
    [\"QUIC Loss Detection and Congestion Control\"]{.refTitle}, [RFC
    9002]{.seriesInfo}, [DOI 10.17487/RFC9002]{.seriesInfo}, May 2021,
    \<<https://www.rfc-editor.org/info/rfc9002>\>.
:   

\[QUIC-TRANSPORT\]
:   [Iyengar, J., Ed.]{.refAuthor} and [M. Thomson, Ed.]{.refAuthor},
    [\"QUIC: A UDP-Based Multiplexed and Secure Transport\"]{.refTitle},
    [RFC 9000]{.seriesInfo}, [DOI 10.17487/RFC9000]{.seriesInfo}, May
    2021, \<<https://www.rfc-editor.org/info/rfc9000>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC4086\]
:   [Eastlake 3rd, D.]{.refAuthor}, [Schiller, J.]{.refAuthor}, and [S.
    Crocker]{.refAuthor}, [\"Randomness Requirements for
    Security\"]{.refTitle}, [BCP 106]{.seriesInfo}, [RFC
    4086]{.seriesInfo}, [DOI 10.17487/RFC4086]{.seriesInfo}, June 2005,
    \<<https://www.rfc-editor.org/info/rfc4086>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[SHA\]
:   [Dang, Q.]{.refAuthor}, [\"Secure Hash Standard\"]{.refTitle},
    [National Institute of Standards and Technology
    report]{.seriesInfo}, [DOI 10.6028/nist.fips.180-4]{.seriesInfo},
    July 2015, \<<https://doi.org/10.6028/nist.fips.180-4>\>.
:   

\[TLS-REGISTRIES\]
:   [Salowey, J.]{.refAuthor} and [S. Turner]{.refAuthor}, [\"IANA
    Registry Updates for TLS and DTLS\"]{.refTitle}, [RFC
    8447]{.seriesInfo}, [DOI 10.17487/RFC8447]{.seriesInfo}, August
    2018, \<<https://www.rfc-editor.org/info/rfc8447>\>.
:   

\[TLS13\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   
:::

::: {#section-11.2 .section}
### [11.2.](#section-11.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[AEBounds\]
:   [Luykx, A.]{.refAuthor} and [K. Paterson]{.refAuthor}, [\"Limits on
    Authenticated Encryption Use in TLS\"]{.refTitle}, 28 August 2017,
    \<<https://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>\>.
:   

\[ASCII\]
:   [Cerf, V.]{.refAuthor}, [\"ASCII format for network
    interchange\"]{.refTitle}, [STD 80]{.seriesInfo}, [RFC
    20]{.seriesInfo}, [DOI 10.17487/RFC0020]{.seriesInfo}, October 1969,
    \<<https://www.rfc-editor.org/info/rfc20>\>.
:   

\[CCM-ANALYSIS\]
:   [Jonsson, J.]{.refAuthor}, [\"On the Security of CTR +
    CBC-MAC\"]{.refTitle}, [Selected Areas in
    Cryptography]{.refContent}, [SAC 2002]{.refContent}, [Lecture Notes
    in Computer Science, vol 2595]{.refContent}, [pp.
    76-93]{.refContent}, [DOI 10.1007/3-540-36492-7_7]{.seriesInfo},
    2003, \<<https://doi.org/10.1007/3-540-36492-7_7>\>.
:   

\[COMPRESS\]
:   [Ghedini, A.]{.refAuthor} and [V. Vasiliev]{.refAuthor}, [\"TLS
    Certificate Compression\"]{.refTitle}, [RFC 8879]{.seriesInfo}, [DOI
    10.17487/RFC8879]{.seriesInfo}, December 2020,
    \<<https://www.rfc-editor.org/info/rfc8879>\>.
:   

\[GCM-MU\]
:   [Hoang, V.]{.refAuthor}, [Tessaro, S.]{.refAuthor}, and [A.
    Thiruvengadam]{.refAuthor}, [\"The Multi-user Security of GCM,
    Revisited: Tight Bounds for Nonce Randomization\"]{.refTitle}, [CCS
    \'18: Proceedings of the 2018 ACM SIGSAC Conference on Computer and
    Communications Security]{.refContent}, [pp. 1429-1440]{.refContent},
    [DOI 10.1145/3243734.3243816]{.seriesInfo}, 2018,
    \<<https://doi.org/10.1145/3243734.3243816>\>.
:   

\[HTTP-REPLAY\]
:   [Thomson, M.]{.refAuthor}, [Nottingham, M.]{.refAuthor}, and [W.
    Tarreau]{.refAuthor}, [\"Using Early Data in HTTP\"]{.refTitle},
    [RFC 8470]{.seriesInfo}, [DOI 10.17487/RFC8470]{.seriesInfo},
    September 2018, \<<https://www.rfc-editor.org/info/rfc8470>\>.
:   

\[HTTP2-TLS13\]
:   [Benjamin, D.]{.refAuthor}, [\"Using TLS 1.3 with
    HTTP/2\"]{.refTitle}, [RFC 8740]{.seriesInfo}, [DOI
    10.17487/RFC8740]{.seriesInfo}, February 2020,
    \<<https://www.rfc-editor.org/info/rfc8740>\>.
:   

\[IMC\]
:   [Katz, J.]{.refAuthor} and [Y. Lindell]{.refAuthor}, [\"Introduction
    to Modern Cryptography, Second Edition\"]{.refTitle}, [ISBN
    978-1466570269]{.seriesInfo}, 6 November 2014.
:   

\[NAN\]
:   [Bellare, M.]{.refAuthor}, [Ng, R.]{.refAuthor}, and [B.
    Tackmann]{.refAuthor}, [\"Nonces Are Noticed: AEAD
    Revisited\"]{.refTitle}, [Advances in Cryptology - CRYPTO
    2019]{.refContent}, [Lecture Notes in Computer Science, vol
    11692]{.refContent}, [pp. 235-265]{.refContent}, [DOI
    10.1007/978-3-030-26948-7_9]{.seriesInfo}, 2019,
    \<<https://doi.org/10.1007/978-3-030-26948-7_9>\>.
:   

\[QUIC-HTTP\]
:   [Bishop, M., Ed.]{.refAuthor}, [\"Hypertext Transfer Protocol
    Version 3 (HTTP/3)\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-quic-http-34]{.seriesInfo}, 2 February
    2021, \<<https://tools.ietf.org/html/draft-ietf-quic-http-34>\>.
:   

\[RFC2818\]
:   [Rescorla, E.]{.refAuthor}, [\"HTTP Over TLS\"]{.refTitle}, [RFC
    2818]{.seriesInfo}, [DOI 10.17487/RFC2818]{.seriesInfo}, May 2000,
    \<<https://www.rfc-editor.org/info/rfc2818>\>.
:   

\[RFC5280\]
:   [Cooper, D.]{.refAuthor}, [Santesson, S.]{.refAuthor},
    [Farrell, S.]{.refAuthor}, [Boeyen, S.]{.refAuthor},
    [Housley, R.]{.refAuthor}, and [W. Polk]{.refAuthor}, [\"Internet
    X.509 Public Key Infrastructure Certificate and Certificate
    Revocation List (CRL) Profile\"]{.refTitle}, [RFC
    5280]{.seriesInfo}, [DOI 10.17487/RFC5280]{.seriesInfo}, May 2008,
    \<<https://www.rfc-editor.org/info/rfc5280>\>.
:   

\[ROBUST\]
:   [Fischlin, M.]{.refAuthor}, [Günther, F.]{.refAuthor}, and [C.
    Janson]{.refAuthor}, [\"Robust Channels: Handling Unreliable
    Networks in the Record Layers of QUIC and DTLS 1.3\"]{.refTitle}, 16
    May 2020, \<<https://eprint.iacr.org/2020/718>\>.
:   
:::
:::

::: {#test-vectors}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Sample Packet Protection](#name-sample-packet-protection){.section-name .selfRef} {#name-sample-packet-protection}

This section shows examples of packet protection so that implementations
can be verified incrementally. Samples of Initial packets from both
client and server plus a Retry packet are defined. These packets use an
8-byte client-chosen Destination Connection ID of 0x8394c8f03e515708.
Some intermediate values are included. All values are shown in
hexadecimal.[¶](#section-appendix.a-1){.pilcrow}

::: {#keys}
::: {#section-a.1 .section}
## [A.1.](#section-a.1){.section-number .selfRef} [Keys](#name-keys){.section-name .selfRef} {#name-keys}

The labels generated during the execution of the HKDF-Expand-Label
function (that is, HkdfLabel.label) and part of the value given to the
HKDF-Expand function in order to produce its output
are:[¶](#section-a.1-1){.pilcrow}

[]{.break}

client in:

:   00200f746c73313320636c69656e7420696e00[¶](#section-a.1-2.2.1){.pilcrow}

:   

server in:

:   00200f746c7331332073657276657220696e00[¶](#section-a.1-2.4.1){.pilcrow}

:   

quic key:

:   00100e746c7331332071756963206b657900[¶](#section-a.1-2.6.1){.pilcrow}

:   

quic iv:

:   000c0d746c733133207175696320697600[¶](#section-a.1-2.8.1){.pilcrow}

:   

quic hp:

:   00100d746c733133207175696320687000[¶](#section-a.1-2.10.1){.pilcrow}

:   

The initial secret is common:[¶](#section-a.1-3){.pilcrow}

::: {#section-a.1-4 .artwork .art-text .alignLeft}
    initial_secret = HKDF-Extract(initial_salt, cid)
        = 7db5df06e7a69e432496adedb0085192
          3595221596ae2ae9fb8115c1e9ed0a44

[¶](#section-a.1-4){.pilcrow}
:::

The secrets for protecting client packets
are:[¶](#section-a.1-5){.pilcrow}

::: {#section-a.1-6 .artwork .art-text .alignLeft}
    client_initial_secret
        = HKDF-Expand-Label(initial_secret, "client in", "", 32)
        = c00cf151ca5be075ed0ebfb5c80323c4
          2d6b7db67881289af4008f1f6c357aea

    key = HKDF-Expand-Label(client_initial_secret, "quic key", "", 16)
        = 1f369613dd76d5467730efcbe3b1a22d

    iv  = HKDF-Expand-Label(client_initial_secret, "quic iv", "", 12)
        = fa044b2f42a3fd3b46fb255c

    hp  = HKDF-Expand-Label(client_initial_secret, "quic hp", "", 16)
        = 9f50449e04a0e810283a1e9933adedd2

[¶](#section-a.1-6){.pilcrow}
:::

The secrets for protecting server packets
are:[¶](#section-a.1-7){.pilcrow}

::: {#section-a.1-8 .artwork .art-text .alignLeft}
    server_initial_secret
        = HKDF-Expand-Label(initial_secret, "server in", "", 32)
        = 3c199828fd139efd216c155ad844cc81
          fb82fa8d7446fa7d78be803acdda951b

    key = HKDF-Expand-Label(server_initial_secret, "quic key", "", 16)
        = cf3a5331653c364c88f0f379b6067e37

    iv  = HKDF-Expand-Label(server_initial_secret, "quic iv", "", 12)
        = 0ac1493ca1905853b0bba03e

    hp  = HKDF-Expand-Label(server_initial_secret, "quic hp", "", 16)
        = c206b8d9b9f0f37644430b490eeaa314

[¶](#section-a.1-8){.pilcrow}
:::
:::
:::

::: {#sample-client-initial}
::: {#section-a.2 .section}
## [A.2.](#section-a.2){.section-number .selfRef} [Client Initial](#name-client-initial){.section-name .selfRef} {#name-client-initial}

The client sends an Initial packet. The unprotected payload of this
packet contains the following CRYPTO frame, plus enough PADDING frames
to make a 1162-byte payload:[¶](#section-a.2-1){.pilcrow}

::: {#section-a.2-2 .artwork .art-text .alignLeft}
    060040f1010000ed0303ebf8fa56f129 39b9584a3896472ec40bb863cfd3e868
    04fe3a47f06a2b69484c000004130113 02010000c000000010000e00000b6578
    616d706c652e636f6dff01000100000a 00080006001d00170018001000070005
    04616c706e0005000501000000000033 00260024001d00209370b2c9caa47fba
    baf4559fedba753de171fa71f50f1ce1 5d43e994ec74d748002b000302030400
    0d0010000e0403050306030203080408 050806002d00020101001c0002400100
    3900320408ffffffffffffffff050480 00ffff07048000ffff08011001048000
    75300901100f088394c8f03e51570806 048000ffff

[¶](#section-a.2-2){.pilcrow}
:::

The unprotected header indicates a length of 1182 bytes: the 4-byte
packet number, 1162 bytes of frames, and the 16-byte authentication tag.
The header includes the connection ID and a packet number of
2:[¶](#section-a.2-3){.pilcrow}

::: {#section-a.2-4 .artwork .art-text .alignLeft}
    c300000001088394c8f03e5157080000449e00000002

[¶](#section-a.2-4){.pilcrow}
:::

Protecting the payload produces output that is sampled for header
protection. Because the header uses a 4-byte packet number encoding, the
first 16 bytes of the protected payload is sampled and then applied to
the header as follows:[¶](#section-a.2-5){.pilcrow}

::: {#section-a.2-6 .artwork .art-text .alignLeft}
    sample = d1b1c98dd7689fb8ec11d242b123dc9b

    mask = AES-ECB(hp, sample)[0..4]
         = 437b9aec36

    header[0] ^= mask[0] & 0x0f
         = c0
    header[18..21] ^= mask[1..4]
         = 7b9aec34
    header = c000000001088394c8f03e5157080000449e7b9aec34

[¶](#section-a.2-6){.pilcrow}
:::

The resulting protected packet is:[¶](#section-a.2-7){.pilcrow}

::: {#section-a.2-8 .artwork .art-text .alignLeft}
    c000000001088394c8f03e5157080000 449e7b9aec34d1b1c98dd7689fb8ec11
    d242b123dc9bd8bab936b47d92ec356c 0bab7df5976d27cd449f63300099f399
    1c260ec4c60d17b31f8429157bb35a12 82a643a8d2262cad67500cadb8e7378c
    8eb7539ec4d4905fed1bee1fc8aafba1 7c750e2c7ace01e6005f80fcb7df6212
    30c83711b39343fa028cea7f7fb5ff89 eac2308249a02252155e2347b63d58c5
    457afd84d05dfffdb20392844ae81215 4682e9cf012f9021a6f0be17ddd0c208
    4dce25ff9b06cde535d0f920a2db1bf3 62c23e596d11a4f5a6cf3948838a3aec
    4e15daf8500a6ef69ec4e3feb6b1d98e 610ac8b7ec3faf6ad760b7bad1db4ba3
    485e8a94dc250ae3fdb41ed15fb6a8e5 eba0fc3dd60bc8e30c5c4287e53805db
    059ae0648db2f64264ed5e39be2e20d8 2df566da8dd5998ccabdae053060ae6c
    7b4378e846d29f37ed7b4ea9ec5d82e7 961b7f25a9323851f681d582363aa5f8
    9937f5a67258bf63ad6f1a0b1d96dbd4 faddfcefc5266ba6611722395c906556
    be52afe3f565636ad1b17d508b73d874 3eeb524be22b3dcbc2c7468d54119c74
    68449a13d8e3b95811a198f3491de3e7 fe942b330407abf82a4ed7c1b311663a
    c69890f4157015853d91e923037c227a 33cdd5ec281ca3f79c44546b9d90ca00
    f064c99e3dd97911d39fe9c5d0b23a22 9a234cb36186c4819e8b9c5927726632
    291d6a418211cc2962e20fe47feb3edf 330f2c603a9d48c0fcb5699dbfe58964
    25c5bac4aee82e57a85aaf4e2513e4f0 5796b07ba2ee47d80506f8d2c25e50fd
    14de71e6c418559302f939b0e1abd576 f279c4b2e0feb85c1f28ff18f58891ff
    ef132eef2fa09346aee33c28eb130ff2 8f5b766953334113211996d20011a198
    e3fc433f9f2541010ae17c1bf202580f 6047472fb36857fe843b19f5984009dd
    c324044e847a4f4a0ab34f719595de37 252d6235365e9b84392b061085349d73
    203a4a13e96f5432ec0fd4a1ee65accd d5e3904df54c1da510b0ff20dcc0c77f
    cb2c0e0eb605cb0504db87632cf3d8b4 dae6e705769d1de354270123cb11450e
    fc60ac47683d7b8d0f811365565fd98c 4c8eb936bcab8d069fc33bd801b03ade
    a2e1fbc5aa463d08ca19896d2bf59a07 1b851e6c239052172f296bfb5e724047
    90a2181014f3b94a4e97d117b4381303 68cc39dbb2d198065ae3986547926cd2
    162f40a29f0c3c8745c0f50fba3852e5 66d44575c29d39a03f0cda721984b6f4
    40591f355e12d439ff150aab7613499d bd49adabc8676eef023b15b65bfc5ca0
    6948109f23f350db82123535eb8a7433 bdabcb909271a6ecbcb58b936a88cd4e
    8f2e6ff5800175f113253d8fa9ca8885 c2f552e657dc603f252e1a8e308f76f0
    be79e2fb8f5d5fbbe2e30ecadd220723 c8c0aea8078cdfcb3868263ff8f09400
    54da48781893a7e49ad5aff4af300cd8 04a6b6279ab3ff3afb64491c85194aab
    760d58a606654f9f4400e8b38591356f bf6425aca26dc85244259ff2b19c41b9
    f96f3ca9ec1dde434da7d2d392b905dd f3d1f9af93d1af5950bd493f5aa731b4
    056df31bd267b6b90a079831aaf579be 0a39013137aac6d404f518cfd4684064
    7e78bfe706ca4cf5e9c5453e9f7cfd2b 8b4c8d169a44e55c88d4a9a7f9474241
    e221af44860018ab0856972e194cd934

[¶](#section-a.2-8){.pilcrow}
:::
:::
:::

::: {#server-initial}
::: {#section-a.3 .section}
## [A.3.](#section-a.3){.section-number .selfRef} [Server Initial](#name-server-initial){.section-name .selfRef} {#name-server-initial}

The server sends the following payload in response, including an ACK
frame, a CRYPTO frame, and no PADDING
frames:[¶](#section-a.3-1){.pilcrow}

::: {#section-a.3-2 .artwork .art-text .alignLeft}
    02000000000600405a020000560303ee fce7f7b37ba1d1632e96677825ddf739
    88cfc79825df566dc5430b9a045a1200 130100002e00330024001d00209d3c94
    0d89690b84d08a60993c144eca684d10 81287c834d5311bcf32bb9da1a002b00
    020304

[¶](#section-a.3-2){.pilcrow}
:::

The header from the server includes a new connection ID and a 2-byte
packet number encoding for a packet number of
1:[¶](#section-a.3-3){.pilcrow}

::: {#section-a.3-4 .artwork .art-text .alignLeft}
    c1000000010008f067a5502a4262b50040750001

[¶](#section-a.3-4){.pilcrow}
:::

As a result, after protection, the header protection sample is taken
starting from the third protected byte:[¶](#section-a.3-5){.pilcrow}

::: {#section-a.3-6 .artwork .art-text .alignLeft}
    sample = 2cd0991cd25b0aac406a5816b6394100
    mask   = 2ec0d8356a
    header = cf000000010008f067a5502a4262b5004075c0d9

[¶](#section-a.3-6){.pilcrow}
:::

The final protected packet is then:[¶](#section-a.3-7){.pilcrow}

::: {#section-a.3-8 .artwork .art-text .alignLeft}
    cf000000010008f067a5502a4262b500 4075c0d95a482cd0991cd25b0aac406a
    5816b6394100f37a1c69797554780bb3 8cc5a99f5ede4cf73c3ec2493a1839b3
    dbcba3f6ea46c5b7684df3548e7ddeb9 c3bf9c73cc3f3bded74b562bfb19fb84
    022f8ef4cdd93795d77d06edbb7aaf2f 58891850abbdca3d20398c276456cbc4
    2158407dd074ee

[¶](#section-a.3-8){.pilcrow}
:::
:::
:::

::: {#retry}
::: {#section-a.4 .section}
## [A.4.](#section-a.4){.section-number .selfRef} [Retry](#name-retry){.section-name .selfRef} {#name-retry}

This shows a Retry packet that might be sent in response to the Initial
packet in [Appendix A.2](#sample-client-initial){.xref}. The integrity
check includes the client-chosen connection ID value of
0x8394c8f03e515708, but that value is not included in the final Retry
packet:[¶](#section-a.4-1){.pilcrow}

::: {#section-a.4-2 .artwork .art-text .alignLeft}
    ff000000010008f067a5502a4262b574 6f6b656e04a265ba2eff4d829058fb3f
    0f2496ba

[¶](#section-a.4-2){.pilcrow}
:::
:::
:::

::: {#chacha20-poly1305-short-header-packet}
::: {#section-a.5 .section}
## [A.5.](#section-a.5){.section-number .selfRef} [ChaCha20-Poly1305 Short Header Packet](#name-chacha20-poly1305-short-hea){.section-name .selfRef} {#name-chacha20-poly1305-short-hea}

This example shows some of the steps required to protect a packet with a
short header. This example uses
AEAD_CHACHA20_POLY1305.[¶](#section-a.5-1){.pilcrow}

In this example, TLS produces an application write secret from which a
server uses HKDF-Expand-Label to produce four values: a key, an IV, a
header protection key, and the secret that will be used after keys are
updated (this last value is not used further in this
example).[¶](#section-a.5-2){.pilcrow}

::: {#section-a.5-3 .artwork .art-text .alignLeft}
    secret
        = 9ac312a7f877468ebe69422748ad00a1
          5443f18203a07d6060f688f30f21632b

    key = HKDF-Expand-Label(secret, "quic key", "", 32)
        = c6d98ff3441c3fe1b2182094f69caa2e
          d4b716b65488960a7a984979fb23e1c8

    iv  = HKDF-Expand-Label(secret, "quic iv", "", 12)
        = e0459b3474bdd0e44a41c144

    hp  = HKDF-Expand-Label(secret, "quic hp", "", 32)
        = 25a282b9e82f06f21f488917a4fc8f1b
          73573685608597d0efcb076b0ab7a7a4

    ku  = HKDF-Expand-Label(secret, "quic ku", "", 32)
        = 1223504755036d556342ee9361d25342
          1a826c9ecdf3c7148684b36b714881f9

[¶](#section-a.5-3){.pilcrow}
:::

The following shows the steps involved in protecting a minimal packet
with an empty Destination Connection ID. This packet contains a single
PING frame (that is, a payload of just 0x01) and has a packet number of
654360564. In this example, using a packet number of length 3 (that is,
49140 is encoded) avoids having to pad the payload of the packet;
PADDING frames would be needed if the packet number is encoded on fewer
bytes.[¶](#section-a.5-4){.pilcrow}

::: {#section-a.5-5 .artwork .art-text .alignLeft}
    pn                 = 654360564 (decimal)
    nonce              = e0459b3474bdd0e46d417eb0
    unprotected header = 4200bff4
    payload plaintext  = 01
    payload ciphertext = 655e5cd55c41f69080575d7999c25a5bfb

[¶](#section-a.5-5){.pilcrow}
:::

The resulting ciphertext is the minimum size possible. One byte is
skipped to produce the sample for header
protection.[¶](#section-a.5-6){.pilcrow}

::: {#section-a.5-7 .artwork .art-text .alignLeft}
    sample = 5e5cd55c41f69080575d7999c25a5bfb
    mask   = aefefe7d03
    header = 4cfe4189

[¶](#section-a.5-7){.pilcrow}
:::

The protected packet is the smallest possible packet size of 21
bytes.[¶](#section-a.5-8){.pilcrow}

::: {#section-a.5-9 .artwork .art-text .alignLeft}
    packet = 4cfe4189655e5cd55c41f69080575d7999c25a5bfb

[¶](#section-a.5-9){.pilcrow}
:::
:::
:::
:::
:::

::: {#aead-analysis}
::: {#section-appendix.b .section}
## [Appendix B.](#section-appendix.b){.section-number .selfRef} [AEAD Algorithm Analysis](#name-aead-algorithm-analysis){.section-name .selfRef} {#name-aead-algorithm-analysis}

This section documents analyses used in deriving AEAD algorithm limits
for AEAD_AES_128_GCM, AEAD_AES_128_CCM, and AEAD_AES_256_GCM. The
analyses that follow use symbols for multiplication (\*), division (/),
and exponentiation (\^), plus parentheses for establishing precedence.
The following symbols are also used:[¶](#section-appendix.b-1){.pilcrow}

[]{.break}

t:

:   The size of the authentication tag in bits. For these ciphers, t is
    128.[¶](#section-appendix.b-2.2.1){.pilcrow}

:   

n:

:   The size of the block function in bits. For these ciphers, n is
    128.[¶](#section-appendix.b-2.4.1){.pilcrow}

:   

k:

:   The size of the key in bits. This is 128 for AEAD_AES_128_GCM and
    AEAD_AES_128_CCM; 256 for
    AEAD_AES_256_GCM.[¶](#section-appendix.b-2.6.1){.pilcrow}

:   

l:

:   The number of blocks in each packet (see
    below).[¶](#section-appendix.b-2.8.1){.pilcrow}

:   

q:

:   The number of genuine packets created and protected by endpoints.
    This value is the bound on the number of packets that can be
    protected before updating
    keys.[¶](#section-appendix.b-2.10.1){.pilcrow}

:   

v:

:   The number of forged packets that endpoints will accept. This value
    is the bound on the number of forged packets that an endpoint can
    reject before updating
    keys.[¶](#section-appendix.b-2.12.1){.pilcrow}

:   

o:

:   The amount of offline ideal cipher queries made by an
    adversary.[¶](#section-appendix.b-2.14.1){.pilcrow}

:   

The analyses that follow rely on a count of the number of block
operations involved in producing each message. This analysis is
performed for packets of size up to 2^11^ (l = 2^7^) and 2^16^ (l =
2^12^). A size of 2^11^ is expected to be a limit that matches common
deployment patterns, whereas the 2^16^ is the maximum possible size of a
QUIC packet. Only endpoints that strictly limit packet size can use the
larger confidentiality and integrity limits that are derived using the
smaller packet size.[¶](#section-appendix.b-3){.pilcrow}

For AEAD_AES_128_GCM and AEAD_AES_256_GCM, the message length (l) is the
length of the associated data in blocks plus the length of the plaintext
in blocks.[¶](#section-appendix.b-4){.pilcrow}

For AEAD_AES_128_CCM, the total number of block cipher operations is the
sum of the following: the length of the associated data in blocks, the
length of the ciphertext in blocks, the length of the plaintext in
blocks, plus 1. In this analysis, this is simplified to a value of twice
the length of the packet in blocks (that is, `2l = 28` for packets that
are limited to 2^11^ bytes, or `2l = 213` otherwise). This
simplification is based on the packet containing all of the associated
data and ciphertext. This results in a one to three block overestimation
of the number of operations per
packet.[¶](#section-appendix.b-5){.pilcrow}

::: {#gcm-bounds}
::: {#section-b.1 .section}
## [B.1.](#section-b.1){.section-number .selfRef} [Analysis of AEAD_AES_128_GCM and AEAD_AES_256_GCM Usage Limits](#name-analysis-of-aead_aes_128_gc){.section-name .selfRef} {#name-analysis-of-aead_aes_128_gc}

\[[GCM-MU](#GCM-MU){.xref}\] specifies concrete bounds for
AEAD_AES_128_GCM and AEAD_AES_256_GCM as used in TLS 1.3 and QUIC. This
section documents this analysis using several simplifying
assumptions:[¶](#section-b.1-1){.pilcrow}

-   [The number of ciphertext blocks an attacker uses in forgery
    attempts is bounded by v \* l, which is the number of forgery
    attempts multiplied by the size of each packet (in
    blocks).[¶](#section-b.1-2.1){.pilcrow}]{#section-b.1-2.1}
-   [The amount of offline work done by an attacker does not dominate
    other factors in the
    analysis.[¶](#section-b.1-2.2){.pilcrow}]{#section-b.1-2.2}

The bounds in \[[GCM-MU](#GCM-MU){.xref}\] are tighter and more complete
than those used in \[[AEBounds](#AEBounds){.xref}\], which allows for
larger limits than those described in
\[[TLS13](#TLS13){.xref}\].[¶](#section-b.1-3){.pilcrow}

::: {#confidentiality-limit}
::: {#section-b.1.1 .section}
### [B.1.1.](#section-b.1.1){.section-number .selfRef} [Confidentiality Limit](#name-confidentiality-limit){.section-name .selfRef} {#name-confidentiality-limit}

For confidentiality, Theorem (4.3) in \[[GCM-MU](#GCM-MU){.xref}\]
establishes that, for a single user that does not repeat nonces, the
dominant term in determining the distinguishing advantage between a real
and random AEAD algorithm gained by an attacker
is:[¶](#section-b.1.1-1){.pilcrow}

::: {#section-b.1.1-2 .artwork .art-text .alignLeft}
    2 * (q * l)^2 / 2^n

[¶](#section-b.1.1-2){.pilcrow}
:::

For a target advantage of 2^-57^, this results in the
relation:[¶](#section-b.1.1-3){.pilcrow}

::: {#section-b.1.1-4 .artwork .art-text .alignLeft}
    q <= 2^35 / l

[¶](#section-b.1.1-4){.pilcrow}
:::

Thus, endpoints that do not send packets larger than 2^11^ bytes cannot
protect more than 2^28^ packets in a single connection without causing
an attacker to gain a more significant advantage than the target of
2^-57^. The limit for endpoints that allow for the packet size to be as
large as 2^16^ is instead 2^23^.[¶](#section-b.1.1-5){.pilcrow}
:::
:::

::: {#integrity-limit}
::: {#section-b.1.2 .section}
### [B.1.2.](#section-b.1.2){.section-number .selfRef} [Integrity Limit](#name-integrity-limit){.section-name .selfRef} {#name-integrity-limit}

For integrity, Theorem (4.3) in \[[GCM-MU](#GCM-MU){.xref}\] establishes
that an attacker gains an advantage in successfully forging a packet of
no more than the following:[¶](#section-b.1.2-1){.pilcrow}

::: {#section-b.1.2-2 .artwork .art-text .alignLeft}
    (1 / 2^(8 * n)) + ((2 * v) / 2^(2 * n))
            + ((2 * o * v) / 2^(k + n)) + (n * (v + (v * l)) / 2^k)

[¶](#section-b.1.2-2){.pilcrow}
:::

The goal is to limit this advantage to 2^-57^. For AEAD_AES_128_GCM, the
fourth term in this inequality dominates the rest, so the others can be
removed without significant effect on the result. This produces the
following approximation:[¶](#section-b.1.2-3){.pilcrow}

::: {#section-b.1.2-4 .artwork .art-text .alignLeft}
    v <= 2^64 / l

[¶](#section-b.1.2-4){.pilcrow}
:::

Endpoints that do not attempt to remove protection from packets larger
than 2^11^ bytes can attempt to remove protection from at most 2^57^
packets. Endpoints that do not restrict the size of processed packets
can attempt to remove protection from at most 2^52^
packets.[¶](#section-b.1.2-5){.pilcrow}

For AEAD_AES_256_GCM, the same term dominates, but the larger value of k
produces the following approximation:[¶](#section-b.1.2-6){.pilcrow}

::: {#section-b.1.2-7 .artwork .art-text .alignLeft}
    v <= 2^192 / l

[¶](#section-b.1.2-7){.pilcrow}
:::

This is substantially larger than the limit for AEAD_AES_128_GCM.
However, this document recommends that the same limit be applied to both
functions as either limit is acceptably
large.[¶](#section-b.1.2-8){.pilcrow}
:::
:::
:::
:::

::: {#ccm-bounds}
::: {#section-b.2 .section}
## [B.2.](#section-b.2){.section-number .selfRef} [Analysis of AEAD_AES_128_CCM Usage Limits](#name-analysis-of-aead_aes_128_cc){.section-name .selfRef} {#name-analysis-of-aead_aes_128_cc}

TLS \[[TLS13](#TLS13){.xref}\] and \[[AEBounds](#AEBounds){.xref}\] do
not specify limits on usage for AEAD_AES_128_CCM. However, any AEAD that
is used with QUIC requires limits on use that ensure that both
confidentiality and integrity are preserved. This section documents that
analysis.[¶](#section-b.2-1){.pilcrow}

\[[CCM-ANALYSIS](#CCM-ANALYSIS){.xref}\] is used as the basis of this
analysis. The results of that analysis are used to derive usage limits
that are based on those chosen in
\[[TLS13](#TLS13){.xref}\].[¶](#section-b.2-2){.pilcrow}

For confidentiality, Theorem 2 in
\[[CCM-ANALYSIS](#CCM-ANALYSIS){.xref}\] establishes that an attacker
gains a distinguishing advantage over an ideal pseudorandom permutation
(PRP) of no more than the following:[¶](#section-b.2-3){.pilcrow}

::: {#section-b.2-4 .artwork .art-text .alignLeft}
    (2l * q)^2 / 2^n

[¶](#section-b.2-4){.pilcrow}
:::

The integrity limit in Theorem 1 in
\[[CCM-ANALYSIS](#CCM-ANALYSIS){.xref}\] provides an attacker a strictly
higher advantage for the same number of messages. As the targets for the
confidentiality advantage and the integrity advantage are the same, only
Theorem 1 needs to be considered.[¶](#section-b.2-5){.pilcrow}

Theorem 1 establishes that an attacker gains an advantage over an ideal
PRP of no more than the following:[¶](#section-b.2-6){.pilcrow}

::: {#section-b.2-7 .artwork .art-text .alignLeft}
    v / 2^t + (2l * (v + q))^2 / 2^n

[¶](#section-b.2-7){.pilcrow}
:::

As `t` and `n` are both 128, the first term is negligible relative to
the second, so that term can be removed without a significant effect on
the result.[¶](#section-b.2-8){.pilcrow}

This produces a relation that combines both encryption and decryption
attempts with the same limit as that produced by the theorem for
confidentiality alone. For a target advantage of 2^-57^, this results in
the following:[¶](#section-b.2-9){.pilcrow}

::: {#section-b.2-10 .artwork .art-text .alignLeft}
    v + q <= 2^34.5 / l

[¶](#section-b.2-10){.pilcrow}
:::

By setting `q = v`, values for both confidentiality and integrity limits
can be produced. Endpoints that limit packets to 2^11^ bytes therefore
have both confidentiality and integrity limits of 2^26.5^ packets.
Endpoints that do not restrict packet size have a limit of
2^21.5^.[¶](#section-b.2-11){.pilcrow}
:::
:::
:::
:::

::: {#contributors}
::: {#section-appendix.c .section}
## [Contributors](#name-contributors){.section-name .selfRef} {#name-contributors}

The IETF QUIC Working Group received an enormous amount of support from
many people. The following people provided substantive contributions to
this document:[¶](#section-appendix.c-1){.pilcrow}

-   ::: {#section-appendix.c-2.1}
    [Adam
    Langley]{.contact-name}[¶](#section-appendix.c-2.1.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.2}
    [Alessandro
    Ghedini]{.contact-name}[¶](#section-appendix.c-2.2.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.3}
    [Christian
    Huitema]{.contact-name}[¶](#section-appendix.c-2.3.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.4}
    [Christopher
    Wood]{.contact-name}[¶](#section-appendix.c-2.4.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.5}
    [David
    Schinazi]{.contact-name}[¶](#section-appendix.c-2.5.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.6}
    [Dragana
    Damjanovic]{.contact-name}[¶](#section-appendix.c-2.6.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.7}
    [Eric
    Rescorla]{.contact-name}[¶](#section-appendix.c-2.7.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.8}
    [Felix
    Günther]{.contact-name}[¶](#section-appendix.c-2.8.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.9}
    [Ian Swett]{.contact-name}[¶](#section-appendix.c-2.9.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.10}
    [Jana
    Iyengar]{.contact-name}[¶](#section-appendix.c-2.10.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.11}
    [[奥 一穂]{.non-ascii} ([Kazuho
    Oku]{.ascii})]{.contact-name}[¶](#section-appendix.c-2.11.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.12}
    [Marten
    Seemann]{.contact-name}[¶](#section-appendix.c-2.12.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.13}
    [Martin
    Duke]{.contact-name}[¶](#section-appendix.c-2.13.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.14}
    [Mike
    Bishop]{.contact-name}[¶](#section-appendix.c-2.14.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.15}
    [Mikkel Fahnøe
    Jørgensen]{.contact-name}[¶](#section-appendix.c-2.15.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.16}
    [Nick Banks]{.contact-name}[¶](#section-appendix.c-2.16.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.17}
    [Nick
    Harper]{.contact-name}[¶](#section-appendix.c-2.17.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.18}
    [Roberto
    Peon]{.contact-name}[¶](#section-appendix.c-2.18.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.19}
    [Rui Paulo]{.contact-name}[¶](#section-appendix.c-2.19.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.20}
    [Ryan
    Hamilton]{.contact-name}[¶](#section-appendix.c-2.20.1){.pilcrow}
    :::

-   ::: {#section-appendix.c-2.21}
    [Victor
    Vasiliev]{.contact-name}[¶](#section-appendix.c-2.21.1){.pilcrow}
    :::
:::
:::

::: {#authors-addresses}
::: {#section-appendix.d .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Martin Thomson ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Mozilla]{.org}
:::

::: email
Email: <mt@lowentropy.net>
:::

::: {.left dir="auto"}
[Sean Turner ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[sn3rd]{.org}
:::

::: email
Email: <sean@sn3rd.com>
:::
:::
:::
