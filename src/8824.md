  RFC 8824           SCHC for CoAP     June 2021
  ------------------ ----------------- -----------
  Minaburo, et al.   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8824](https://www.rfc-editor.org/rfc/rfc8824){.eref}

Category:
:   Standards Track

Published:
:   June 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    A. Minaburo
    :::

    ::: org
    Acklio
    :::
    :::

    ::: author
    ::: author-name
    L. Toutain
    :::

    ::: org
    IMT Atlantique
    :::
    :::

    ::: author
    ::: author-name
    R. Andreasen
    :::

    ::: org
    Universidad de Buenos Aires
    :::
    :::
:::

# RFC 8824 {#rfcnum}

# Static Context Header Compression (SCHC) for the Constrained Application Protocol (CoAP) {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document defines how to compress Constrained Application Protocol
(CoAP) headers using the Static Context Header Compression and
fragmentation (SCHC) framework. SCHC defines a header compression
mechanism adapted for Constrained Devices. SCHC uses a static
description of the header to reduce the header\'s redundancy and size.
While RFC 8724 describes the SCHC compression and fragmentation
framework, and its application for IPv6/UDP headers, this document
applies SCHC to CoAP headers. The CoAP header structure differs from
IPv6 and UDP, since CoAP uses a flexible header with a variable number
of options, themselves of variable length. The CoAP message format is
asymmetric: the request messages have a header format different from the
format in the response messages. This specification gives guidance on
applying SCHC to flexible headers and how to leverage the asymmetry for
more efficient compression Rules.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8824>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Terminology](#name-terminology){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [SCHC Applicability to
    CoAP](#name-schc-applicability-to-coap){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [CoAP Headers Compressed with
    SCHC](#name-coap-headers-compressed-wit){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Differences between CoAP and
        UDP/IP Compression](#name-differences-between-coap-an){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Compression of CoAP Header
    Fields](#name-compression-of-coap-header-){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [CoAP Version
        Field](#name-coap-version-field){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [CoAP Type
        Field](#name-coap-type-field){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [CoAP Code
        Field](#name-coap-code-field){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [CoAP Message ID
        Field](#name-coap-message-id-field){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [CoAP Token
        Fields](#name-coap-token-fields){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [CoAP Options](#name-coap-options){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [CoAP Content and Accept
        Options](#name-coap-content-and-accept-opt){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [CoAP Option Max-Age, Uri-Host, and
        Uri-Port Fields](#name-coap-option-max-age-uri-hos){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [CoAP Option Uri-Path and Uri-Query
        Fields](#name-coap-option-uri-path-and-ur){.xref}

        -   ::: {#section-toc.1-1.5.2.3.2.1}
            [5.3.1](#section-5.3.1){.xref}.  [Variable Number of Path or
            Query Elements](#name-variable-number-of-path-or-){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [CoAP Option Size1, Size2,
        Proxy-URI, and Proxy-Scheme
        Fields](#name-coap-option-size1-size2-pro){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [CoAP Option ETag, If-Match,
        If-None-Match, Location-Path, and Location-Query
        Fields](#name-coap-option-etag-if-match-i){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [SCHC Compression of CoAP
    Extensions](#name-schc-compression-of-coap-ex){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Block](#name-block){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Observe](#name-observe){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [No-Response](#name-no-response){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [OSCORE](#name-oscore){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Examples of CoAP Header
    Compression](#name-examples-of-coap-header-com){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Mandatory Header with CON
        Message](#name-mandatory-header-with-con-m){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [OSCORE
        Compression](#name-oscore-compression){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Example OSCORE
        Compression](#name-example-oscore-compression){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Normative
    References](#name-normative-references){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [](#appendix-A){.xref}[Acknowledgements](#name-acknowledgements){.xref}
    :::

-   ::: {#section-toc.1-1.12}
    [](#appendix-B){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#Introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The Constrained Application Protocol (CoAP)
\[[RFC7252](#RFC7252){.xref}\] is a command/response protocol designed
for microcontrollers with small RAM and ROM and optimized for services
based on REST (Representational State Transfer). Although the
Constrained Devices are a leading factor in the design of CoAP, a CoAP
header\'s size is still too large for LPWANs (Low-Power Wide-Area
Networks). Static Context Header Compression and fragmentation (SCHC)
over CoAP headers is required to increase performance or to use CoAP
over LPWAN technologies.[¶](#section-1-1){.pilcrow}

\[[RFC8724](#RFC8724){.xref}\] defines the SCHC framework, which
includes a header compression mechanism for LPWANs that is based on a
static context. [Section
5](https://www.rfc-editor.org/rfc/rfc8724#section-5){.relref} of
\[[RFC8724](#RFC8724){.xref}\] explains where compression and
decompression occur in the architecture. The SCHC compression scheme
assumes as a prerequisite that both endpoints know the static context
before transmission. The way the context is configured, provisioned, or
exchanged is out of this document\'s scope.[¶](#section-1-2){.pilcrow}

CoAP is an application protocol, so CoAP compression requires installing
common Rules between the two SCHC instances. SCHC compression may apply
at two different levels: at IP and UDP in the LPWAN and another at the
application level for CoAP. These two compression techniques may be
independent. Both follow the same principle as that described in
\[[RFC8724](#RFC8724){.xref}\]. As different entities manage the CoAP
compression process at different levels, the SCHC Rules driving the
compression/decompression are also different.
\[[RFC8724](#RFC8724){.xref}\] describes how to use SCHC for IP and UDP
headers. This document specifies how to apply SCHC compression to CoAP
headers.[¶](#section-1-3){.pilcrow}

SCHC compresses and decompresses headers based on common contexts
between Devices. The SCHC context includes multiple Rules. Each Rule can
match the header fields to specific values or ranges of values. If a
Rule matches, the matched header fields are replaced by the RuleID and
the Compression Residue that contains the residual bits of the
compression. Thus, different Rules may correspond to different protocol
headers in the packet that a Device expects to send or
receive.[¶](#section-1-4){.pilcrow}

A Rule describes the packets\' entire header with an ordered list of
Field Descriptors; see [Section
7](https://www.rfc-editor.org/rfc/rfc8724#section-7){.relref} of
\[[RFC8724](#RFC8724){.xref}\]. Thereby, each description contains the
Field ID (FID), Field Length (FL), and Field Position (FP), as well as a
Direction Indicator (DI) (upstream, downstream, and bidirectional) and
some associated Target Values (TVs). The DI is used for compression to
give the best TV to the FID when these values differ in their
transmission direction. So, a field may be described several
times.[¶](#section-1-5){.pilcrow}

A Matching Operator (MO) is associated with each header Field
Descriptor. The Rule is selected if all the MOs fit the TVs for all
fields of the incoming header. A Rule cannot be selected if the message
contains a field that is unknown to the SCHC
compressor.[¶](#section-1-6){.pilcrow}

In that case, a Compression/Decompression Action (CDA) associated with
each field gives the method to compress and decompress each field.
Compression mainly results in one of four
actions:[¶](#section-1-7){.pilcrow}

-   [send the field value
    (value-sent),[¶](#section-1-8.1){.pilcrow}]{#section-1-8.1}
-   [send nothing
    (not-sent),[¶](#section-1-8.2){.pilcrow}]{#section-1-8.2}
-   [send some Least Significant Bits (LSBs) of the field,
    or[¶](#section-1-8.3){.pilcrow}]{#section-1-8.3}
-   [send an index
    (mapping-sent).[¶](#section-1-8.4){.pilcrow}]{#section-1-8.4}

After applying the compression, there may be some bits to be sent. These
values are called \"Compression Residue\".[¶](#section-1-9){.pilcrow}

SCHC is a general mechanism applied to different protocols, with the
exact Rules to be used depending on the protocol and the application.
[Section 10](https://www.rfc-editor.org/rfc/rfc8724#section-10){.relref}
of \[[RFC8724](#RFC8724){.xref}\] describes the compression scheme for
IPv6 and UDP headers. This document targets CoAP header compression
using SCHC.[¶](#section-1-10){.pilcrow}

::: {#terminology}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-1){.pilcrow}
:::
:::
:::
:::

::: {#schc-applicability-to-coap}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [SCHC Applicability to CoAP](#name-schc-applicability-to-coap){.section-name .selfRef} {#name-schc-applicability-to-coap}

SCHC compression for CoAP headers [MAY]{.bcp14} be done in conjunction
with the lower layers (IPv6/UDP) or independently. The SCHC adaptation
layers, described in [Section
5](https://www.rfc-editor.org/rfc/rfc8724#section-5){.relref} of
\[[RFC8724](#RFC8724){.xref}\], may be used as shown in
Figures [1](#Fig-SCHCCOAP1){.xref}, [2](#Fig-SCHCCOAP2){.xref}, and
[3](#Fig-SCHCCOAP3){.xref}.[¶](#section-2-1){.pilcrow}

In the first example, [Figure 1](#Fig-SCHCCOAP1){.xref}, a Rule
compresses the complete header stack from IPv6 to CoAP. In this case,
the Device and the Network Gateway (NGW) perform SCHC C/D (SCHC
Compression/Decompression; see \[[RFC8724](#RFC8724){.xref}\]). The
application communicating with the Device does not implement SCHC
C/D.[¶](#section-2-2){.pilcrow}

[]{#name-compression-decompression-a}

::: {#Fig-SCHCCOAP1}
::: {#section-2-3.1 .artwork .art-text .alignLeft}
          (Device)            (NGW)                              (App)

          +--------+                                           +--------+
          |  CoAP  |                                           |  CoAP  |
          +--------+                                           +--------+
          |  UDP   |                                           |  UDP   |
          +--------+     +----------------+                    +--------+
          |  IPv6  |     |      IPv6      |                    |  IPv6  |
          +--------+     +--------+-------+                    +--------+
          |  SCHC  |     |  SCHC  |       |                    |        |
          +--------+     +--------+       +                    +        +
          |  LPWAN |     | LPWAN  |       |                    |        |
          +--------+     +--------+-------+                    +--------+
              ((((LPWAN))))             ------   Internet  ------
:::

[Figure 1](#figure-1){.selfRef}: [Compression/Decompression at the LPWAN
Boundary](#name-compression-decompression-a){.selfRef}
:::

[Figure 1](#Fig-SCHCCOAP1){.xref} shows the use of SCHC header
compression above Layer 2 in the Device and the NGW. The SCHC layer
receives non-encrypted packets and can apply compression Rules to all
the headers in the stack. On the other end, the NGW receives the SCHC
packet and reconstructs the headers using the Rule and the Compression
Residue. After the decompression, the NGW forwards the IPv6 packet
toward the destination. The same process applies in the other direction
when a non-encrypted packet arrives at the NGW. Thanks to the IP
forwarding based on the IPv6 prefix, the NGW identifies the Device and
compresses headers using the Device\'s Rules.[¶](#section-2-4){.pilcrow}

In the second example, [Figure 2](#Fig-SCHCCOAP2){.xref}, SCHC
compression is applied in the CoAP layer, compressing the CoAP header
independently of the other layers. The RuleID, Compression Residue, and
CoAP payload are encrypted using a mechanism such as DTLS. Only the
other end (App) can decipher the information. If needed, layers below
use SCHC to compress the header as defined in
\[[RFC8724](#RFC8724){.xref}\] (represented by dotted lines in the
figure).[¶](#section-2-5){.pilcrow}

This use case needs an end-to-end context initialization between the
Device and the application. The context initialization is out of scope
for this document.[¶](#section-2-6){.pilcrow}

[]{#name-standalone-coap-end-to-end-}

::: {#Fig-SCHCCOAP2}
::: {#section-2-7.1 .artwork .art-text .alignLeft}
          (Device)            (NGW)                               (App)

          +--------+                                           +--------+
          |  CoAP  |                                           |  CoAP  |
          +--------+                                           +--------+
          |  SCHC  |                                           |  SCHC  |
          +--------+                                           +--------+
          |  DTLS  |                                           |  DTLS  |
          +--------+                                           +--------+
          .  udp   .                                           .  udp   .
          ..........     ..................                    ..........
          .  ipv6  .     .      ipv6      .                    .  ipv6  .
          ..........     ..................                    ..........
          .  schc  .     .  schc  .       .                    .        .
          ..........     ..........       .                    .        .
          .  lpwan .     . lpwan  .       .                    .        .
          ..........     ..................                    ..........
              ((((LPWAN))))             ------   Internet  ------
:::

[Figure 2](#figure-2){.selfRef}: [Standalone CoAP End-to-End
Compression/Decompression](#name-standalone-coap-end-to-end-){.selfRef}
:::

The third example, [Figure 3](#Fig-SCHCCOAP3){.xref}, shows the use of
Object Security for Constrained RESTful Environments (OSCORE)
\[[RFC8613](#RFC8613){.xref}\]. In this case, SCHC needs two Rules to
compress the CoAP header. A first Rule focuses on the Inner header. The
result of this first compression is encrypted using the OSCORE
mechanism. Then, a second Rule compresses the Outer header, including
the OSCORE options.[¶](#section-2-8){.pilcrow}

[]{#name-oscore-compression-decompre}

::: {#Fig-SCHCCOAP3}
::: {#section-2-9.1 .artwork .art-text .alignLeft}
          (Device)            (NGW)                              (App)

          +--------+                                           +--------+
          |  CoAP  |                                           |  CoAP  |
          |  Inner |                                           |  Inner |
          +--------+                                           +--------+
          |  SCHC  |                                           |  SCHC  |
          |  Inner |                                           |  Inner |
          +--------+                                           +--------+
          |  CoAP  |                                           |  CoAP  |
          |  Outer |                                           |  Outer |
          +--------+                                           +--------+
          |  SCHC  |                                           |  SCHC  |
          |  Outer |                                           |  Outer |
          +--------+                                           +--------+
          .  udp   .                                           .  udp   .
          ..........     ..................                    ..........
          .  ipv6  .     .      ipv6      .                    .  ipv6  .
          ..........     ..................                    ..........
          .  schc  .     .  schc  .       .                    .        .
          ..........     ..........       .                    .        .
          .  lpwan .     . lpwan  .       .                    .        .
          ..........     ..................                    ..........
              ((((LPWAN))))             ------   Internet  ------
:::

[Figure 3](#figure-3){.selfRef}: [OSCORE
Compression/Decompression](#name-oscore-compression-decompre){.selfRef}
:::

In the case of several SCHC instances, as shown in
Figures [2](#Fig-SCHCCOAP2){.xref} and [3](#Fig-SCHCCOAP3){.xref}, the
Rules may come from different provisioning
domains.[¶](#section-2-10){.pilcrow}

This document focuses on CoAP compression, as represented by the dashed
boxes in the previous figures.[¶](#section-2-11){.pilcrow}
:::
:::

::: {#coap-headers-compressed-with-schc}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [CoAP Headers Compressed with SCHC](#name-coap-headers-compressed-wit){.section-name .selfRef} {#name-coap-headers-compressed-wit}

The use of SCHC over the CoAP header applies the same description and
compression/decompression techniques as the technique used for IP and
UDP, as explained in \[[RFC8724](#RFC8724){.xref}\]. For CoAP, the SCHC
Rules description uses the direction information to optimize the
compression by reducing the number of Rules needed to compress headers.
The Field Descriptor [MAY]{.bcp14} define both request/response headers
and TVs in the same Rule, using the DI to indicate the header
type.[¶](#section-3-1){.pilcrow}

As for other header compression protocols, when the compressor does not
find a correct Rule to compress the header, the packet [MUST]{.bcp14} be
sent uncompressed using the RuleID dedicated to this purpose, and where
the Compression Residue is the complete header of the packet. See
[Section 6](https://www.rfc-editor.org/rfc/rfc8724#section-6){.relref}
of \[[RFC8724](#RFC8724){.xref}\].[¶](#section-3-2){.pilcrow}

::: {#differences-between-coap-and-udpip-compression}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Differences between CoAP and UDP/IP Compression](#name-differences-between-coap-an){.section-name .selfRef} {#name-differences-between-coap-an}

CoAP compression differs from IPv6 and UDP compression in the following
aspects:[¶](#section-3.1-1){.pilcrow}

-   ::: {#section-3.1-2.1}
    The CoAP message format is asymmetric; the headers are different for
    a request or a response. For example, the Uri-Path option is
    mandatory in the request, and it might not be present in the
    response. A request might contain an Accept option, and the response
    might include a Content-Format option. In comparison, the IPv6 and
    UDP returning path swaps the value of some fields in the header.
    However, all the directions have the same fields (e.g., source and
    destination address fields).[¶](#section-3.1-2.1.1){.pilcrow}

    \[[RFC8724](#RFC8724){.xref}\] defines the use of a DI in the Field
    Descriptor, which allows a single Rule to process a message header
    differently, depending on the
    direction.[¶](#section-3.1-2.1.2){.pilcrow}
    :::

-   [Even when a field is \"symmetric\" (i.e., found in both
    directions), the values carried in each direction are different. The
    compression may use a \"match-mapping\" MO to limit the range of
    expected values in a particular direction and reduce the Compression
    Residue\'s size. Through the DI, a Field Descriptor in the Rules
    splits the possible field value into two parts, one for each
    direction. For instance, if a client sends only Confirmable (CON)
    requests \[[RFC7252](#RFC7252){.xref}\], the Type can be elided by
    compression, and the answer may use one single bit to carry either
    the ACK or Reset (RST) type. The field Code has the same behavior:
    the 0.0X code format value in the request and the Y.ZZ code format
    in the response.[¶](#section-3.1-2.2){.pilcrow}]{#section-3.1-2.2}

-   ::: {#section-3.1-2.3}
    In SCHC, the Rule defines the different header fields\' length, so
    SCHC does not need to send it. In IPv6 and UDP headers, the fields
    have a fixed size, known by definition. On the other hand, some CoAP
    header fields have variable lengths, and the Rule description
    specifies it. For example, in a Uri-Path or Uri-Query, the Token
    size may vary from 0 to 8 bytes, and the CoAP options use the
    Type-Length-Value encoding format.[¶](#section-3.1-2.3.1){.pilcrow}

    When doing SCHC compression of a variable-length field, [Section
    7.4.2](https://www.rfc-editor.org/rfc/rfc8724#section-7.4.2){.relref}
    of \[[RFC8724](#RFC8724){.xref}\] offers the option of defining a
    function for the Field Length in the Field Descriptor to know the
    length before compression. If the Field Length is unknown, the Rule
    will set it as a variable, and SCHC will send the compressed
    field\'s length in the Compression
    Residue.[¶](#section-3.1-2.3.2){.pilcrow}
    :::

-   [A field can appear several times in the CoAP headers. It is found
    typically for elements of a URI (path or queries). The SCHC
    specification \[[RFC8724](#RFC8724){.xref}\] allows a FID to appear
    several times in the Rule and uses the Field Position (FP) to
    identify the correct instance, thereby removing the MO\'s
    ambiguity.[¶](#section-3.1-2.4){.pilcrow}]{#section-3.1-2.4}

-   [Field Lengths defined in CoAP can be too large when it comes to
    LPWAN traffic constraints. For instance, this is particularly true
    for the Message ID field and the Token field. SCHC uses different
    MOs to perform the compression. See [Section
    7.4](https://www.rfc-editor.org/rfc/rfc8724#section-7.4){.relref} of
    \[[RFC8724](#RFC8724){.xref}\]. In this case, SCHC can apply the
    Most Significant Bits (MSBs) MO to reduce the information carried on
    LPWANs.[¶](#section-3.1-2.5){.pilcrow}]{#section-3.1-2.5}
:::
:::
:::
:::

::: {#CoAPcomp}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Compression of CoAP Header Fields](#name-compression-of-coap-header-){.section-name .selfRef} {#name-compression-of-coap-header-}

This section discusses the compression of the different CoAP header
fields. CoAP compression with SCHC follows the information provided in
[Section
7.1](https://www.rfc-editor.org/rfc/rfc8724#section-7.1){.relref} of
\[[RFC8724](#RFC8724){.xref}\].[¶](#section-4-1){.pilcrow}

::: {#coap-version-field}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [CoAP Version Field](#name-coap-version-field){.section-name .selfRef} {#name-coap-version-field}

The CoAP version is bidirectional and [MUST]{.bcp14} be elided during
SCHC compression, since it always contains the same value. In the
future, or if a new version of CoAP is defined, new Rules will be needed
to avoid ambiguities between versions.[¶](#section-4.1-1){.pilcrow}
:::
:::

::: {#coap-type-field}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [CoAP Type Field](#name-coap-type-field){.section-name .selfRef} {#name-coap-type-field}

CoAP \[[RFC7252](#RFC7252){.xref}\] has four types of messages: two
requests (CON, NON), one response (ACK), and one empty message
(RST).[¶](#section-4.2-1){.pilcrow}

The SCHC compression scheme [SHOULD]{.bcp14} elide this field if, for
instance, a client is sending only Non-confirmable (NON) messages or
only CON messages. For the RST message, SCHC may use a dedicated Rule.
For other usages, SCHC can use a \"match-mapping\"
MO.[¶](#section-4.2-2){.pilcrow}
:::
:::

::: {#coap-code-field}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [CoAP Code Field](#name-coap-code-field){.section-name .selfRef} {#name-coap-code-field}

The Code field, defined in an IANA registry
\[[RFC7252](#RFC7252){.xref}\], indicates the Request Method used in
CoAP. The compression of the CoAP Code field follows the same principle
as that of the CoAP Type field. If the Device plays a specific role,
SCHC may split the code values into two Field Descriptors: (1) the
request codes with the 0 class and (2) the response values. SCHC will
use the DI to identify the correct value in the
packet.[¶](#section-4.3-1){.pilcrow}

If the Device only implements a CoAP client, SCHC compression may reduce
the request code to the set of requests the client can
process.[¶](#section-4.3-2){.pilcrow}

For known values, SCHC can use a \"match-mapping\" MO. If SCHC cannot
compress the Code field, it will send the values in the Compression
Residue.[¶](#section-4.3-3){.pilcrow}
:::
:::

::: {#coap-message-id-field}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [CoAP Message ID Field](#name-coap-message-id-field){.section-name .selfRef} {#name-coap-message-id-field}

SCHC can compress the Message ID field with the \"MSB\" MO and the
\"LSB\" CDA. See [Section
7.4](https://www.rfc-editor.org/rfc/rfc8724#section-7.4){.relref} of
\[[RFC8724](#RFC8724){.xref}\].[¶](#section-4.4-1){.pilcrow}
:::
:::

::: {#coap-token-fields}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [CoAP Token Fields](#name-coap-token-fields){.section-name .selfRef} {#name-coap-token-fields}

CoAP defines the Token using two CoAP fields: Token Length in the
mandatory header and Token Value directly following the mandatory CoAP
header.[¶](#section-4.5-1){.pilcrow}

SCHC processes the Token Length as it would any header field. If the
value does not change, the size can be stored in the TV and elided
during the transmission. Otherwise, SCHC will send the Token Length in
the Compression Residue.[¶](#section-4.5-2){.pilcrow}

For the Token Value, SCHC [MUST NOT]{.bcp14} send it as variable-length
data in the Compression Residue, to avoid ambiguity with the Token
Length. Therefore, SCHC [MUST]{.bcp14} use the Token Length value to
define the size of the Compression Residue. SCHC designates a specific
function, \"tkl\", that the Rule [MUST]{.bcp14} use to complete the
Field Descriptor. During the decompression, this function returns the
value contained in the Token Length field.[¶](#section-4.5-3){.pilcrow}
:::
:::
:::
:::

::: {#coap-options}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [CoAP Options](#name-coap-options){.section-name .selfRef} {#name-coap-options}

CoAP defines options placed after the basic header, ordered by option
number; see \[[RFC7252](#RFC7252){.xref}\]. Each Option instance in a
message uses the format Delta-Type (D-T), Length (L), Value (V). The
SCHC Rule builds the description of the option by using the
following:[¶](#section-5-1){.pilcrow}

-   [in the FID: the option number built from the
    D-T;[¶](#section-5-2.1){.pilcrow}]{#section-5-2.1}
-   [in the TV: the option value;
    and[¶](#section-5-2.2){.pilcrow}]{#section-5-2.2}
-   [for the Option Length: the information provided in
    Sections [7.4.1](https://www.rfc-editor.org/rfc/rfc8724#section-7.4.1){.relref}
    and
    [7.4.2](https://www.rfc-editor.org/rfc/rfc8724#section-7.4.2){.relref}
    of
    \[[RFC8724](#RFC8724){.xref}\].[¶](#section-5-2.3){.pilcrow}]{#section-5-2.3}

When the Option Length has a well-known size, the Rule may keep the
length value. Therefore, SCHC compression does not send it. Otherwise,
SCHC compression carries the length of the Compression Residue, in
addition to the Compression Residue value.[¶](#section-5-3){.pilcrow}

CoAP requests and responses do not include the same options. So,
compression Rules may reflect this asymmetry by tagging the
DI.[¶](#section-5-4){.pilcrow}

Note that length coding differs between CoAP options and SCHC variable
size Compression Residue.[¶](#section-5-5){.pilcrow}

The following sections present how SCHC compresses some specific CoAP
options.[¶](#section-5-6){.pilcrow}

If CoAP introduces a new option, the SCHC Rules [MAY]{.bcp14} be
updated, and the new FID description [MUST]{.bcp14} be assigned to allow
its compression. Otherwise, if no Rule describes this new option, SCHC
compression is not achieved, and SCHC sends the CoAP header without
compression.[¶](#section-5-7){.pilcrow}

::: {#coap-content-and-accept-options}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [CoAP Content and Accept Options](#name-coap-content-and-accept-opt){.section-name .selfRef} {#name-coap-content-and-accept-opt}

If the client expects a single value, it can be stored in the TV and
elided during the transmission. Otherwise, if the client expects several
possible values, a \"match-mapping\" MO [SHOULD]{.bcp14} be used to
limit the Compression Residue\'s size. If not, SCHC has to send the
option value in the Compression Residue (fixed or variable
length).[¶](#section-5.1-1){.pilcrow}
:::
:::

::: {#coap-option-max-age-uri-host-and-uri-port-fields}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [CoAP Option Max-Age, Uri-Host, and Uri-Port Fields](#name-coap-option-max-age-uri-hos){.section-name .selfRef} {#name-coap-option-max-age-uri-hos}

SCHC compresses these three fields in the same way. When the values of
these options are known, SCHC can elide these fields. If the option uses
well-known values, SCHC can use a \"match-mapping\" MO. Otherwise, SCHC
will use the \"value-sent\" MO, and the Compression Residue will send
these options\' values.[¶](#section-5.2-1){.pilcrow}
:::
:::

::: {#coap-option-uri-path-and-uri-query-fields}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [CoAP Option Uri-Path and Uri-Query Fields](#name-coap-option-uri-path-and-ur){.section-name .selfRef} {#name-coap-option-uri-path-and-ur}

The Uri-Path and Uri-Query fields are repeatable options; this means
that in the CoAP header, they may appear several times with different
values. The SCHC Rule description uses the FP to distinguish the
different instances in the path.[¶](#section-5.3-1){.pilcrow}

To compress repeatable field values, SCHC may use a \"match-mapping\" MO
to reduce the size of variable paths or queries. In these cases, to
optimize the compression, several elements can be regrouped into a
single entry. The numbering of elements does not change, and the first
matching element sets the MO comparison.[¶](#section-5.3-2){.pilcrow}

In [Table 1](#Table-complex-path){.xref}, SCHC can use a single bit in
the Compression Residue to code one of the two paths. If regrouping were
not allowed, 2 bits in the Compression Residue would be needed. SCHC
sends the third path element as a variable size in the Compression
Residue.[¶](#section-5.3-3){.pilcrow}

[]{#name-complex-path-example}

::: {#Table-complex-path}
  ------------------------------------------------------------------------------------
  Field      FL         FP         DI         TV             MO         CDA
  ---------- ---------- ---------- ---------- -------------- ---------- --------------
  Uri-Path              1          Up         \[\"/a/b\",\   match-\    mapping-sent
                                              \"/c/d\"\]     mapping    

  Uri-Path   var        3          Up                        ignore     value-sent
  ------------------------------------------------------------------------------------

  : [Table 1](#table-1){.selfRef}: [Complex Path
  Example](#name-complex-path-example){.selfRef}
:::

The length of Uri-Path and Uri-Query may be known when the Rule is
defined. In any case, SCHC [MUST]{.bcp14} set the Field Length to a
variable value. The Compression Residue size is expressed in
bytes.[¶](#section-5.3-5){.pilcrow}

SCHC compression can use the MSB MO to a Uri-Path or Uri-Query element.
However, attention to the length is important because the MSB value is
in bits, and the size [MUST]{.bcp14} always be a multiple of 8
bits.[¶](#section-5.3-6){.pilcrow}

The length sent at the beginning of a variable-length Compression
Residue indicates the LSB\'s size in bytes.[¶](#section-5.3-7){.pilcrow}

For instance, for a CORECONF path /c/X6?k=eth0, the Rule description can
be as follows ([Table
2](#Table-CoMicompress){.xref}):[¶](#section-5.3-8){.pilcrow}

[]{#name-coreconf-uri-compression}

::: {#Table-CoMicompress}
  Field       FL    FP   DI   TV       MO        CDA
  ----------- ----- ---- ---- -------- --------- ------------
  Uri-Path          1    Up   \"c\"    equal     not-sent
  Uri-Path    var   2    Up            ignore    value-sent
  Uri-Query   var   1    Up   \"k=\"   MSB(16)   LSB

  : [Table 2](#table-2){.selfRef}: [CORECONF URI
  Compression](#name-coreconf-uri-compression){.selfRef}
:::

[Table 2](#Table-CoMicompress){.xref} shows the Rule description for a
Uri-Path and a Uri-Query. SCHC compresses the first part of the Uri-Path
with a \"not-sent\" CDA. SCHC will send the second element of the
Uri-Path with the length (i.e., 0x2 \"X6\") followed by the query option
(i.e., 0x4 \"eth0\").[¶](#section-5.3-10){.pilcrow}

::: {#variable-number-of-path-or-query-elements}
::: {#section-5.3.1 .section}
#### [5.3.1.](#section-5.3.1){.section-number .selfRef} [Variable Number of Path or Query Elements](#name-variable-number-of-path-or-){.section-name .selfRef} {#name-variable-number-of-path-or-}

SCHC fixed the number of Uri-Path or Uri-Query elements in a Rule at the
Rule creation time. If the number varies, SCHC [SHOULD]{.bcp14}
either[¶](#section-5.3.1-1){.pilcrow}

-   [create several Rules to cover all possibilities
    or[¶](#section-5.3.1-2.1){.pilcrow}]{#section-5.3.1-2.1}
-   [create a Rule that defines several entries for Uri-Path to cover
    the longest path and send a Compression Residue with a length of 0
    to indicate that a Uri-Path entry is
    empty.[¶](#section-5.3.1-2.2){.pilcrow}]{#section-5.3.1-2.2}

However, this adds 4 bits to the variable Compression Residue size. See
[Section
7.4.2](https://www.rfc-editor.org/rfc/rfc8724#section-7.4.2){.relref} of
\[[RFC8724](#RFC8724){.xref}\].[¶](#section-5.3.1-3){.pilcrow}
:::
:::
:::
:::

::: {#coap-option-size1-size2-proxy-uri-and-proxy-scheme-fields}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [CoAP Option Size1, Size2, Proxy-URI, and Proxy-Scheme Fields](#name-coap-option-size1-size2-pro){.section-name .selfRef} {#name-coap-option-size1-size2-pro}

The SCHC Rule description [MAY]{.bcp14} define sending some field values
by setting the TV to \"not-sent\", the MO to \"ignore\", and the CDA to
\"value-sent\". A Rule [MAY]{.bcp14} also use a \"match-mapping\" MO
when there are different options for the same FID. Otherwise, the Rule
sets the TV to the value, the MO to \"equal\", and the CDA to
\"not-sent\".[¶](#section-5.4-1){.pilcrow}
:::
:::

::: {#coap-option-etag-if-match-if-none-match-location-path-and-location-query-fields}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [CoAP Option ETag, If-Match, If-None-Match, Location-Path, and Location-Query Fields](#name-coap-option-etag-if-match-i){.section-name .selfRef} {#name-coap-option-etag-if-match-i}

A Rule entry cannot store these fields\' values. The Rule description
[MUST]{.bcp14} always send these values in the Compression
Residue.[¶](#section-5.5-1){.pilcrow}
:::
:::
:::
:::

::: {#schc-compression-of-coap-extension-rfcs}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [SCHC Compression of CoAP Extensions](#name-schc-compression-of-coap-ex){.section-name .selfRef} {#name-schc-compression-of-coap-ex}

::: {#block}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Block](#name-block){.section-name .selfRef} {#name-block}

When a packet uses a Block option \[[RFC7959](#RFC7959){.xref}\], SCHC
compression [MUST]{.bcp14} send its content in the Compression Residue.
The SCHC Rule describes an empty TV with the MO set to \"ignore\" and
the CDA set to \"value-sent\". The Block option allows fragmentation at
the CoAP level that is compatible with SCHC fragmentation. Both
fragmentation mechanisms are complementary, and the node may use them
for the same packet as needed.[¶](#section-6.1-1){.pilcrow}
:::
:::

::: {#observe}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Observe](#name-observe){.section-name .selfRef} {#name-observe}

\[[RFC7641](#RFC7641){.xref}\] defines the Observe Option. The SCHC Rule
description will not define the TV but will set the MO to \"ignore\" and
the CDA to \"value-sent\". SCHC does not limit the maximum size for this
option (3 bytes). To reduce the transmission size, either the Device
implementation [MAY]{.bcp14} limit the delta between two consecutive
values or a proxy can modify the increment.[¶](#section-6.2-1){.pilcrow}

Since the Observe Option [MAY]{.bcp14} use a RST message to inform a
server that the client does not require the Observe response, a specific
SCHC Rule [SHOULD]{.bcp14} exist to allow the message\'s compression
with the RST type.[¶](#section-6.2-2){.pilcrow}
:::
:::

::: {#no-response}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [No-Response](#name-no-response){.section-name .selfRef} {#name-no-response}

\[[RFC7967](#RFC7967){.xref}\] defines a No-Response option limiting the
responses made by a server to a request. Different behaviors exist while
using this option to limit the responses made by a server to a request.
If both ends know the value, then the SCHC Rule will describe a TV to
this value, with the MO set to \"equal\" and the CDA set to
\"not-sent\".[¶](#section-6.3-1){.pilcrow}

Otherwise, if the value is changing over time, the SCHC Rule will set
the MO to \"ignore\" and the CDA to \"value-sent\". The Rule may also
use a \"match-mapping\" MO to compress this
option.[¶](#section-6.3-2){.pilcrow}
:::
:::

::: {#Sec-OSCORE}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [OSCORE](#name-oscore){.section-name .selfRef} {#name-oscore}

OSCORE \[[RFC8613](#RFC8613){.xref}\] defines end-to-end protection for
CoAP messages. This section describes how SCHC Rules can be applied to
compress OSCORE-protected messages.[¶](#section-6.4-1){.pilcrow}

[Figure 4](#Fig-OSCORE-Option){.xref} shows the OSCORE option value
encoding defined in [Section
6.1](https://www.rfc-editor.org/rfc/rfc8613#section-6.1){.relref} of
\[[RFC8613](#RFC8613){.xref}\], where the first byte specifies the
content of the OSCORE options using flags. The three most significant
bits of this byte are reserved and always set to 0. Bit h, when set,
indicates the presence of the kid context field in the option. Bit k,
when set, indicates the presence of a kid field. The three least
significant bits, n, indicate the length of the piv (Partial
Initialization Vector) field in bytes. When n = 0, no piv is
present.[¶](#section-6.4-2){.pilcrow}

[]{#name-oscore-option}

::: {#Fig-OSCORE-Option}
::: {#section-6.4-3.1 .artwork .art-text .alignLeft}
          0 1 2 3 4 5 6 7 <--------- n bytes ------------->
         +-+-+-+-+-+-+-+-+---------------------------------
         |0 0 0|h|k|  n  |      Partial IV (if any) ...
         +-+-+-+-+-+-+-+-+---------------------------------
         |               |                                |
         |<--  CoAP   -->|<------ CoAP OSCORE_piv ------> |
            OSCORE_flags

          <- 1 byte -> <------ s bytes ----->
         +------------+----------------------+-----------------------+
         | s (if any) | kid context (if any) | kid (if any)      ... |
         +------------+----------------------+-----------------------+
         |                                   |                       |
         | <------ CoAP OSCORE_kidctx ------>|<-- CoAP OSCORE_kid -->|
:::

[Figure 4](#figure-4){.selfRef}: [OSCORE
Option](#name-oscore-option){.selfRef}
:::

The flag byte is followed by the piv field, the kid context field, and
the kid field, in that order, and, if present, the kid context field\'s
length (in bytes) is encoded in the first byte, denoted by
\"s\".[¶](#section-6.4-4){.pilcrow}

To better perform OSCORE SCHC compression, the Rule description needs to
identify the OSCORE option and the fields it contains. Conceptually, it
discerns up to four distinct pieces of information within the OSCORE
option: the flag bits, the piv, the kid context, and the kid. The SCHC
Rule splits the OSCORE option into four Field Descriptors in order to
compress them:[¶](#section-6.4-5){.pilcrow}

-   [CoAP OSCORE_flags[¶](#section-6.4-6.1){.pilcrow}]{#section-6.4-6.1}
-   [CoAP OSCORE_piv[¶](#section-6.4-6.2){.pilcrow}]{#section-6.4-6.2}
-   [CoAP
    OSCORE_kidctx[¶](#section-6.4-6.3){.pilcrow}]{#section-6.4-6.3}
-   [CoAP OSCORE_kid[¶](#section-6.4-6.4){.pilcrow}]{#section-6.4-6.4}

[Figure 4](#Fig-OSCORE-Option){.xref} shows the OSCORE option format
with those four fields superimposed on it. Note that the CoAP
OSCORE_kidctx field directly includes the size octet,
s.[¶](#section-6.4-7){.pilcrow}
:::
:::
:::
:::

::: {#examples-of-coap-header-compression}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Examples of CoAP Header Compression](#name-examples-of-coap-header-com){.section-name .selfRef} {#name-examples-of-coap-header-com}

::: {#mandatory-header-with-con-message}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Mandatory Header with CON Message](#name-mandatory-header-with-con-m){.section-name .selfRef} {#name-mandatory-header-with-con-m}

In this first scenario, the SCHC compressor on the NGW side receives a
POST message from an Internet client, which is immediately acknowledged
by the Device. [Table 3](#Table-CoAP-header-1){.xref} describes the SCHC
Rule descriptions for this scenario.[¶](#section-7.1-1){.pilcrow}

[]{#name-coap-context-to-compress-he}

::: {#Table-CoAP-header-1}
  -------------------------------------------------------------------------------------------
  RuleID 1                                                                         
  ---------- -------- -------- -------- ---------- --------------- --------------- ----------
  Field      FL       FP       DI       TV         MO              CDA             Sent
                                                                                   \[bits\]

  CoAP       2        1        Bi       01         equal           not-sent        
  version                                                                          

  CoAP Type  2        1        Dw       CON        equal           not-sent        

  CoAP Type  2        1        Up       \[ACK,\    match-mapping   matching-sent   T
                                        RST\]                                      

  CoAP TKL   4        1        Bi       0          equal           not-sent        

  CoAP Code  8        1        Bi       \[0.00,\   match-mapping   matching-sent   CC CCC
                                        \...\                                      
                                        5.05\]                                     

  CoAP MID   16       1        Bi       0000       MSB(7)          LSB             MID

  CoAP       var      1        Dw       path       equal 1         not-sent        
  Uri-Path                                                                         
  -------------------------------------------------------------------------------------------

  : [Table 3](#table-3){.selfRef}: [CoAP Context to Compress Header
  without Token](#name-coap-context-to-compress-he){.selfRef}
:::

In this example, SCHC compression elides the version and Token Length
fields. The 25 Method and Response Codes defined in
\[[RFC7252](#RFC7252){.xref}\] have been shrunk to 5 bits using a
\"match-mapping\" MO. The Uri-Path contains a single element indicated
in the TV and elided with the CDA
\"not-sent\".[¶](#section-7.1-3){.pilcrow}

SCHC compression reduces the header, sending only the Type, a mapped
code, and the least significant bits of the Message ID (9 bits in the
example above).[¶](#section-7.1-4){.pilcrow}

Note that a client located in an Application Server sending a request to
a server located in the Device may not be compressed through this Rule,
since the MID might not start with 7 bits equal to 0. A CoAP proxy
placed before SCHC C/D can rewrite the Message ID to fit the value and
match the Rule.[¶](#section-7.1-5){.pilcrow}
:::
:::

::: {#Sec-OSCORE-Examples}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [OSCORE Compression](#name-oscore-compression){.section-name .selfRef} {#name-oscore-compression}

OSCORE aims to solve the problem of end-to-end encryption for CoAP
messages. Therefore, the goal is to hide the message as much as possible
while still enabling proxy operation.[¶](#section-7.2-1){.pilcrow}

Conceptually, this is achieved by splitting the CoAP message into an
Inner Plaintext and Outer OSCORE message. The Inner Plaintext contains
sensitive information that is not necessary for proxy operation.
However, it is part of the message that can be encrypted until it
reaches its end destination. The Outer Message acts as a shell matching
the regular CoAP message format and includes all options and information
needed for proxy operation and caching. [Figure
5](#Fig-inner-outer){.xref} below illustrates this
analysis.[¶](#section-7.2-2){.pilcrow}

CoAP arranges the options into one of three classes, each granted a
specific type of protection by the
protocol:[¶](#section-7.2-3){.pilcrow}

[]{.break}

Class E:
:   Encrypted options moved to the Inner
    Plaintext.[¶](#section-7.2-4.2){.pilcrow}
:   

Class I:
:   Integrity-protected options included in the Additional Authenticated
    Data (AAD) for the encryption of the Plaintext but otherwise left
    untouched in the Outer Message.[¶](#section-7.2-4.4){.pilcrow}
:   

Class U:
:   Unprotected options left untouched in the Outer
    Message.[¶](#section-7.2-4.6){.pilcrow}
:   

These classes point out that the Outer option contains the OSCORE option
and that the message is OSCORE protected; this option carries the
information necessary to retrieve the Security Context. The endpoint
will use this Security Context to decrypt the message
correctly.[¶](#section-7.2-5){.pilcrow}

[]{#name-coap-packet-split-into-osco}

::: {#Fig-inner-outer}
::: {#section-7.2-6.1 .artwork .art-text .alignLeft}
                          Original CoAP Packet
                       +-+-+---+-------+---------------+
                       |v|t|TKL| code  | Message ID    |
                       +-+-+---+-------+---------------+....+
                       | Token                              |
                       +-------------------------------.....+
                       | Options (IEU)            |
                       .                          .
                       .                          .
                       +------+-------------------+
                       | 0xFF |
                       +------+------------------------+
                       |                               |
                       |     Payload                   |
                       |                               |
                       +-------------------------------+
                              /                \
                             /                  \
                            /                    \
                           /                      \
         Outer Header     v                        v  Plaintext
      +-+-+---+--------+---------------+          +-------+
      |v|t|TKL|new code| Message ID    |          | code  |
      +-+-+---+--------+---------------+....+     +-------+-----......+
      | Token                               |     | Options (E)       |
      +--------------------------------.....+     +-------+------.....+
      | Options (IU)             |                | 0xFF  |
      .                          .                +-------+-----------+
      . OSCORE Option            .                |                   |
      +------+-------------------+                | Payload           |
      | 0xFF |                                    |                   |
      +------+                                    +-------------------+
:::

[Figure 5](#figure-5){.selfRef}: [CoAP Packet Split into OSCORE Outer
Header and Plaintext](#name-coap-packet-split-into-osco){.selfRef}
:::

[Figure 5](#Fig-inner-outer){.xref} shows the packet format for the
OSCORE Outer header and Plaintext.[¶](#section-7.2-7){.pilcrow}

In the Outer header, the original header code is hidden and replaced by
a default dummy value. As seen in
Sections [4.1.3.5](https://www.rfc-editor.org/rfc/rfc8613#section-4.1.3.5){.relref}
and [4.2](https://www.rfc-editor.org/rfc/rfc8613#section-4.2){.relref}
of \[[RFC8613](#RFC8613){.xref}\], the message code is replaced by POST
for requests and Changed for responses when CoAP is not using the
Observe Option. If CoAP uses Observe, the OSCORE message code is
replaced by FETCH for requests and Content for
responses.[¶](#section-7.2-8){.pilcrow}

The first byte of the Plaintext contains the original packet code,
followed by the message code, the class E options, and, if present, the
original message payload preceded by its payload
marker.[¶](#section-7.2-9){.pilcrow}

An Authenticated Encryption with Associated Data (AEAD) algorithm now
encrypts the Plaintext. This integrity-protects the Security Context
parameters and, eventually, any class I options from the Outer header.
The resulting ciphertext becomes the new payload of the OSCORE message,
as illustrated in [Figure
6](#Fig-full-oscore){.xref}.[¶](#section-7.2-10){.pilcrow}

As defined in \[[RFC5116](#RFC5116){.xref}\], this ciphertext is the
encrypted Plaintext\'s concatenation of the Authentication Tag. Note
that Inner Compression only affects the Plaintext before encryption. The
Authentication Tag, fixed in length and uncompressed, is considered part
of the cost of protection.[¶](#section-7.2-11){.pilcrow}

[]{#name-oscore-message}

::: {#Fig-full-oscore}
::: {#section-7.2-12.1 .artwork .art-text .alignLeft}
         Outer Header
      +-+-+---+--------+---------------+
      |v|t|TKL|new code| Message ID    |
      +-+-+---+--------+---------------+....+
      | Token                               |
      +--------------------------------.....+
      | Options (IU)             |
      .                          .
      . OSCORE Option            .
      +------+-------------------+
      | 0xFF |
      +------+---------------------------+
      |                                  |
      | Ciphertext: Encrypted Inner      |
      |             Header and Payload   |
      |             + Authentication Tag |
      |                                  |
      +----------------------------------+
:::

[Figure 6](#figure-6){.selfRef}: [OSCORE
Message](#name-oscore-message){.selfRef}
:::

The SCHC compression scheme consists of compressing both the Plaintext
before encryption and the resulting OSCORE message after encryption; see
[Figure
7](#Fig-OSCORE-Compression){.xref}.[¶](#section-7.2-13){.pilcrow}

The OSCORE message translates into a segmented process where SCHC
compression is applied independently in two stages, each with its
corresponding set of Rules, with the Inner SCHC Rules and the Outer SCHC
Rules. This way, compression is applied to all fields of the original
CoAP message.[¶](#section-7.2-14){.pilcrow}

[]{#name-oscore-compression-diagram}

::: {#Fig-OSCORE-Compression}
::: {#section-7.2-15.1 .artwork .art-text .alignLeft}
         Outer Message                             OSCORE Plaintext
      +-+-+---+--------+---------------+          +-------+
      |v|t|TKL|new code| Message ID    |          | code  |
      +-+-+---+--------+---------------+....+     +-------+-----......+
      | Token                               |     | Options (E)       |
      +--------------------------------.....+     +-------+------.....+
      | Options (IU)             |                | 0xFF  |
      .                          .                +-------+-----------+
      . OSCORE Option            .                |                   |
      +------+-------------------+                | Payload           |
      | 0xFF |                                    |                   |
      +------+------------+                       +-------------------+
      |  Ciphertext       |<---------\                      |
      |                   |          |                      v
      +-------------------+          |             +-----------------+
              |                      |             |   Inner SCHC    |
              v                      |             |   Compression   |
        +-----------------+          |             +-----------------+
        |   Outer SCHC    |          |                     |
        |   Compression   |          |                     v
        +-----------------+          |             +-------+
              |                      |             |RuleID |
              v                      |             +-------+-----------+
        +--------+             +------------+      |Compression Residue|
        |RuleID' |             | Encryption | <--  +----------+--------+
        +--------+-----------+ +------------+      |                   |
        |Compression Residue'|                     | Payload           |
        +-----------+--------+                     |                   |
        |  Ciphertext        |                     +-------------------+
        |                    |
        +--------------------+
:::

[Figure 7](#figure-7){.selfRef}: [OSCORE Compression
Diagram](#name-oscore-compression-diagram){.selfRef}
:::

Note that since the corresponding endpoint can only decrypt the Inner
part of the message, this endpoint will also have to implement Inner
SCHC Compression/Decompression.[¶](#section-7.2-16){.pilcrow}
:::
:::

::: {#example-oscore-compression}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Example OSCORE Compression](#name-example-oscore-compression){.section-name .selfRef} {#name-example-oscore-compression}

This section gives an example with a GET request and its consequent
Content response from a Device-based CoAP client to a cloud-based CoAP
server. The example also describes a possible set of Rules for Inner
SCHC Compression and Outer SCHC Compression. A dump of the results and a
contrast between SCHC + OSCORE performance with SCHC + CoAP performance
are also listed. This example gives an approximation of the cost of
security with SCHC-OSCORE.[¶](#section-7.3-1){.pilcrow}

Our first CoAP message is the GET request in [Figure
8](#Fig-GET-temp){.xref}.[¶](#section-7.3-2){.pilcrow}

[]{#name-coap-get-request}

::: {#Fig-GET-temp}
::: {#section-7.3-3.1 .artwork .art-text .alignLeft}
    Original message:
    =================
    0x4101000182bb74656d7065726174757265

    Header:
    0x4101
    01   Ver
      00   CON
        0001   TKL
            00000001   Request Code 1 "GET"

    0x0001 = mid
    0x82 = token

    Options:
    0xbb74656d7065726174757265
    Option 11: URI_PATH
    Value = temperature

    Original message length:   17 bytes
:::

[Figure 8](#figure-8){.selfRef}: [CoAP GET
Request](#name-coap-get-request){.selfRef}
:::

Its corresponding response is the Content response in [Figure
9](#Fig-CONTENT-temp){.xref}.[¶](#section-7.3-4){.pilcrow}

[]{#name-coap-content-response}

::: {#Fig-CONTENT-temp}
::: {#section-7.3-5.1 .artwork .art-text .alignLeft}
    Original message:
    =================
    0x6145000182ff32332043

    Header:
    0x6145
    01   Ver
      10   ACK
        0001   TKL
            01000101 Successful Response Code 69 "2.05 Content"

    0x0001 = mid
    0x82 = token

    0xFF  Payload marker
    Payload:
    0x32332043

    Original message length:   10 bytes
:::

[Figure 9](#figure-9){.selfRef}: [CoAP Content
Response](#name-coap-content-response){.selfRef}
:::

The SCHC Rules for the Inner Compression include all fields already
present in a regular CoAP message. The methods described in [Section
4](#CoAPcomp){.xref} apply to these fields. [Table
4](#Table-Inner-Rules){.xref} provides an
example.[¶](#section-7.3-6){.pilcrow}

[]{#name-inner-schc-rule}

::: {#Table-Inner-Rules}
  RuleID 0                                                                    
  --------------- ---- ---- ---- ------------- --------------- -------------- ---------------
  Field           FL   FP   DI   TV            MO              CDA            Sent \[bits\]
  CoAP Code       8    1    Up   1             equal           not-sent       
  CoAP Code       8    1    Dw   \[69,132\]    match-mapping   mapping-sent   c
  CoAP Uri-Path        1    Up   temperature   equal           not-sent       

  : [Table 4](#table-4){.selfRef}: [Inner SCHC
  Rule](#name-inner-schc-rule){.selfRef}
:::

[Figure 10](#Fig-Inner-Compression-GET){.xref} shows the Plaintext
obtained for the example GET request. The packet follows the process of
Inner Compression and encryption until the payload. The Outer OSCORE
message adds the result of the Inner
process.[¶](#section-7.3-8){.pilcrow}

[]{#name-plaintext-compression-and-e}

::: {#Fig-Inner-Compression-GET}
::: {#section-7.3-9.1 .artwork .art-text .alignLeft}
       ________________________________________________________
      |                                                        |
      | OSCORE Plaintext                                       |
      |                                                        |
      | 0x01bb74656d7065726174757265  (13 bytes)               |
      |                                                        |
      | 0x01 Request Code GET                                  |
      |                                                        |
      |      bb74656d7065726174757265 Option 11: URI_PATH      |
      |                               Value = temperature      |
      |________________________________________________________|

                                  |
                                  |
                                  | Inner SCHC Compression
                                  |
                                  v
                    _________________________________
                   |                                 |
                   | Compressed Plaintext            |
                   |                                 |
                   | 0x00                            |
                   |                                 |
                   | RuleID = 0x00 (1 byte)          |
                   | (No Compression Residue)        |
                   |_________________________________|

                                  |
                                  | AEAD Encryption
                                  |  (piv = 0x04)
                                  v
             _________________________________________________
            |                                                 |
            |  encrypted_plaintext = 0xa2 (1 byte)            |
            |  tag = 0xc54fe1b434297b62 (8 bytes)             |
            |                                                 |
            |  ciphertext = 0xa2c54fe1b434297b62 (9 bytes)    |
            |_________________________________________________|
:::

[Figure 10](#figure-10){.selfRef}: [Plaintext Compression and Encryption
for GET Request](#name-plaintext-compression-and-e){.selfRef}
:::

In this case, the original message has no payload, and its resulting
Plaintext is compressed up to only 1 byte (the size of the RuleID). The
AEAD algorithm preserves this length in its first output and yields a
fixed-size tag. SCHC cannot compress the tag, and the OSCORE message
must include it without compression. The use of integrity protection
translates into an overhead in total message length, limiting the amount
of compression that can be achieved and playing into the cost of adding
security to the exchange.[¶](#section-7.3-10){.pilcrow}

[Figure 11](#Fig-Inner-Compression-CONTENT){.xref} shows the process for
the example Content response. The Compression Residue is 1 bit long.
Note that since SCHC adds padding after the payload, this misalignment
causes the hexadecimal code from the payload to differ from the
original, even if SCHC cannot compress the tag. The overhead for the tag
bytes limits SCHC\'s performance but brings security to the
transmission.[¶](#section-7.3-11){.pilcrow}

[]{#name-plaintext-compression-and-en}

::: {#Fig-Inner-Compression-CONTENT}
::: {#section-7.3-12.1 .artwork .art-text .alignLeft}
       ________________________________________________________
      |                                                        |
      | OSCORE Plaintext                                       |
      |                                                        |
      | 0x45ff32332043  (6 bytes)                              |
      |                                                        |
      | 0x45 Successful Response Code 69 "2.05 Content"        |
      |                                                        |
      |     ff Payload marker                                  |
      |                                                        |
      |       32332043 Payload                                 |
      |________________________________________________________|

                                  |
                                  |
                                  | Inner SCHC Compression
                                  |
                                  v
          _________________________________________________
         |                                                 |
         | Compressed Plaintext                            |
         |                                                 |
         | 0x001919902180 (6 bytes)                        |
         |                                                 |
         |   00 RuleID                                     |
         |                                                 |
         |  0b0 (1 bit match-mapping Compression Residue)  |
         |       0x32332043 >> 1 (shifted payload)         |
         |                        0b0000000 Padding        |
         |_________________________________________________|

                                  |
                                  | AEAD Encryption
                                  |  (piv = 0x04)
                                  v
         _________________________________________________________
        |                                                         |
        |  encrypted_plaintext = 0x10c6d7c26cc1 (6 bytes)         |
        |  tag = 0xe9aef3f2461e0c29 (8 bytes)                     |
        |                                                         |
        |  ciphertext = 0x10c6d7c26cc1e9aef3f2461e0c29 (14 bytes) |
        |_________________________________________________________|
:::

[Figure 11](#figure-11){.selfRef}: [Plaintext Compression and Encryption
for Content Response](#name-plaintext-compression-and-en){.selfRef}
:::

The Outer SCHC Rule ([Table 5](#Table-Outer-Rule){.xref}) must process
the OSCORE options fields.
Figures [12](#Fig-Protected-Compressed-GET){.xref} and
[13](#Fig-Protected-Compressed-CONTENT){.xref} show a dump of the OSCORE
messages generated from the example messages. They include the Inner
Compressed ciphertext in the payload. These are the messages that have
to be compressed via the Outer SCHC Compression
scheme.[¶](#section-7.3-13){.pilcrow}

[Table 5](#Table-Outer-Rule){.xref} shows a possible set of Outer Rule
items to compress the Outer header.[¶](#section-7.3-14){.pilcrow}

[]{#name-outer-schc-rule}

::: {#Table-Outer-Rule}
  RuleID 0                                                                   
  -------------------- ----- ---- ---- ---------------- --------- ---------- ---------------
  Field                FL    FP   DI   TV               MO        CDA        Sent \[bits\]
  CoAP version         2     1    Bi   01               equal     not-sent   
  CoAP Type            2     1    Up   0                equal     not-sent   
  CoAP Type            2     1    Dw   2                equal     not-sent   
  CoAP TKL             4     1    Bi   1                equal     not-sent   
  CoAP Code            8     1    Up   2                equal     not-sent   
  CoAP Code            8     1    Dw   68               equal     not-sent   
  CoAP MID             16    1    Bi   0000             MSB(12)   LSB        MMMM
  CoAP Token           tkl   1    Bi   0x80             MSB(5)    LSB        TTT
  CoAP OSCORE_flags    8     1    Up   0x09             equal     not-sent   
  CoAP OSCORE_piv      var   1    Up   0x00             MSB(4)    LSB        PPPP
  CoAP OSCORE_kid      var   1    Up   0x636c69656e70   MSB(52)   LSB        KKKK
  CoAP OSCORE_kidctx   var   1    Bi   b\'\'            equal     not-sent   
  CoAP OSCORE_flags    8     1    Dw   b\'\'            equal     not-sent   
  CoAP OSCORE_piv      var   1    Dw   b\'\'            equal     not-sent   
  CoAP OSCORE_kid      var   1    Dw   b\'\'            equal     not-sent   

  : [Table 5](#table-5){.selfRef}: [Outer SCHC
  Rule](#name-outer-schc-rule){.selfRef}
:::

[]{#name-protected-and-inner-schc-co}

::: {#Fig-Protected-Compressed-GET}
::: {#section-7.3-16.1 .artwork .art-text .alignLeft}
    Protected message:
    ==================
    0x4102000182d8080904636c69656e74ffa2c54fe1b434297b62
    (25 bytes)

    Header:
    0x4102
    01   Ver
      00   CON
        0001   TKL
            00000010   Request Code 2 "POST"

    0x0001 = mid
    0x82 = token

    Options:
    0xd8080904636c69656e74 (10 bytes)
    Option 21: OBJECT_SECURITY
    Value = 0x0904636c69656e74
              09 = 000 0 1 001 flag byte
                       h k  n
                04 piv
                  636c69656e74 kid

    0xFF  Payload marker
    Payload:
    0xa2c54fe1b434297b62 (9 bytes)
:::

[Figure 12](#figure-12){.selfRef}: [Protected and Inner SCHC Compressed
GET Request](#name-protected-and-inner-schc-co){.selfRef}
:::

[]{#name-protected-and-inner-schc-com}

::: {#Fig-Protected-Compressed-CONTENT}
::: {#section-7.3-17.1 .artwork .art-text .alignLeft}
    Protected message:
    ==================
    0x6144000182d008ff10c6d7c26cc1e9aef3f2461e0c29
    (22 bytes)

    Header:
    0x6144
    01   Ver
      10   ACK
        0001   TKL
            01000100   Successful Response Code 68 "2.04 Changed"

    0x0001 = mid
    0x82 = token

    Options:
    0xd008 (2 bytes)
    Option 21: OBJECT_SECURITY
    Value = b''

    0xFF  Payload marker
    Payload:
    0x10c6d7c26cc1e9aef3f2461e0c29 (14 bytes)
:::

[Figure 13](#figure-13){.selfRef}: [Protected and Inner SCHC Compressed
Content Response](#name-protected-and-inner-schc-com){.selfRef}
:::

For the flag bits, some SCHC compression methods are useful, depending
on the application. The most straightforward alternative is to provide a
fixed value for the flags, combining a MO of \"equal\" and a CDA of
\"not-sent\". This SCHC definition saves most bits but could prevent
flexibility. Otherwise, SCHC could use a \"match-mapping\" MO to choose
from several configurations for the exchange. If not, the SCHC
description may use an \"MSB\" MO to mask off the three hard-coded most
significant bits.[¶](#section-7.3-18){.pilcrow}

Note that fixing a flag bit will limit the choices of CoAP options that
can be used in the exchange, since the values of these choices are
dependent on specific options.[¶](#section-7.3-19){.pilcrow}

The piv field lends itself to having some bits masked off with an
\"MSB\" MO and an \"LSB\" CDA. This SCHC description could be useful in
applications where the message frequency is low, such as LPWAN
technologies. Note that compressing the sequence numbers may reduce the
maximum number of sequence numbers that can be used in an exchange. Once
the sequence number exceeds the maximum value, the OSCORE keys need to
be re-established.[¶](#section-7.3-20){.pilcrow}

The size, s, that is included in the kid context field [MAY]{.bcp14} be
masked off with an \"LSB\" CDA. The rest of the field could have
additional bits masked off or have the whole field fixed with a MO of
\"equal\" and a CDA of \"not-sent\". The same holds for the kid
field.[¶](#section-7.3-21){.pilcrow}

The Outer Rule of [Table 5](#Table-Outer-Rule){.xref} is applied to the
example GET request and Content response.
Figures [14](#Fig-Compressed-GET){.xref} and
[15](#Fig-Compressed-CONTENT){.xref} show the resulting
messages.[¶](#section-7.3-22){.pilcrow}

[]{#name-schc-oscore-compressed-get-}

::: {#Fig-Compressed-GET}
::: {#section-7.3-23.1 .artwork .art-text .alignLeft}
    Compressed message:
    ==================
    0x001489458a9fc3686852f6c4 (12 bytes)
    0x00 RuleID
        1489 Compression Residue
            458a9fc3686852f6c4 Padded payload

    Compression Residue:
    0b 0001 010 0100 0100 (15 bits -> 2 bytes with padding)
        mid tkn piv  kid

    Payload
    0xa2c54fe1b434297b62 (9 bytes)

    Compressed message length: 12 bytes
:::

[Figure 14](#figure-14){.selfRef}: [SCHC-OSCORE Compressed GET
Request](#name-schc-oscore-compressed-get-){.selfRef}
:::

[]{#name-schc-oscore-compressed-cont}

::: {#Fig-Compressed-CONTENT}
::: {#section-7.3-24.1 .artwork .art-text .alignLeft}
    Compressed message:
    ==================
    0x0014218daf84d983d35de7e48c3c1852 (16 bytes)
    0x00 RuleID
        14 Compression Residue
          218daf84d983d35de7e48c3c1852 Padded payload
    Compression Residue:
    0b0001 010 (7 bits -> 1 byte with padding)
      mid  tkn

    Payload
    0x10c6d7c26cc1e9aef3f2461e0c29 (14 bytes)

    Compressed message length: 16 bytes
:::

[Figure 15](#figure-15){.selfRef}: [SCHC-OSCORE Compressed Content
Response](#name-schc-oscore-compressed-cont){.selfRef}
:::

In contrast, comparing these results with what would be obtained by SCHC
compressing the original CoAP messages without protecting them with
OSCORE is done by compressing the CoAP messages according to the SCHC
Rule in [Table
6](#Table-NoOsc-Rule){.xref}.[¶](#section-7.3-25){.pilcrow}

[]{#name-schc-coap-rule-no-oscore}

::: {#Table-NoOsc-Rule}
  RuleID 1                                                                     
  --------------- ----- ---- ---- ------------- --------------- -------------- ---------------
  Field           FL    FP   DI   TV            MO              CDA            Sent \[bits\]
  CoAP version    2     1    Bi   01            equal           not-sent       
  CoAP Type       2     1    Up   0             equal           not-sent       
  CoAP Type       2     1    Dw   2             equal           not-sent       
  CoAP TKL        4     1    Bi   1             equal           not-sent       
  CoAP Code       8     1    Up   2             equal           not-sent       
  CoAP Code       8     1    Dw   \[69,132\]    match-mapping   mapping-sent   C
  CoAP MID        16    1    Bi   0000          MSB(12)         LSB            MMMM
  CoAP Token      tkl   1    Bi   0x80          MSB(5)          LSB            TTT
  CoAP Uri-Path         1    Up   temperature   equal           not-sent       

  : [Table 6](#table-6){.selfRef}: [SCHC-CoAP Rule (No
  OSCORE)](#name-schc-coap-rule-no-oscore){.selfRef}
:::

The Rule in [Table 6](#Table-NoOsc-Rule){.xref} yields the SCHC
compression results as shown in [Figure
16](#Fig-GET-temp-no-oscore){.xref} for the request and [Figure
17](#Fig-CONTENT-temp-no-oscore){.xref} for the
response.[¶](#section-7.3-27){.pilcrow}

[]{#name-coap-get-compressed-without}

::: {#Fig-GET-temp-no-oscore}
::: {#section-7.3-28.1 .artwork .art-text .alignLeft}
    Compressed message:
    ==================
    0x0114
    0x01 = RuleID

    Compression Residue:
    0b00010100 (1 byte)

    Compressed message length: 2 bytes
:::

[Figure 16](#figure-16){.selfRef}: [CoAP GET Compressed without
OSCORE](#name-coap-get-compressed-without){.selfRef}
:::

[]{#name-coap-content-compressed-wit}

::: {#Fig-CONTENT-temp-no-oscore}
::: {#section-7.3-29.1 .artwork .art-text .alignLeft}
    Compressed message:
    ==================
    0x010a32332043
    0x01 = RuleID

    Compression Residue:
    0b00001010 (1 byte)

    Payload
    0x32332043

    Compressed message length: 6 bytes
:::

[Figure 17](#figure-17){.selfRef}: [CoAP Content Compressed without
OSCORE](#name-coap-content-compressed-wit){.selfRef}
:::

As can be seen, the difference between applying SCHC + OSCORE as
compared to regular SCHC + CoAP is about 10
bytes.[¶](#section-7.3-30){.pilcrow}
:::
:::
:::
:::

::: {#iana-considerations}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-8-1){.pilcrow}
:::
:::

::: {#SecConsiderations}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

The use of SCHC header compression for CoAP header fields only affects
the representation of the header information. SCHC header compression
itself does not increase or decrease the overall level of security of
the communication. When the connection does not use a security protocol
(OSCORE, DTLS, etc.), it is necessary to use a Layer 2 security
mechanism to protect the SCHC messages.[¶](#section-9-1){.pilcrow}

If an LPWAN is the Layer 2 technology being used, the SCHC security
considerations discussed in \[[RFC8724](#RFC8724){.xref}\] continue to
apply. When using another Layer 2 protocol, the use of a cryptographic
integrity-protection mechanism to protect the SCHC headers is
[REQUIRED]{.bcp14}. Such cryptographic integrity protection is necessary
in order to continue to provide the properties that
\[[RFC8724](#RFC8724){.xref}\] relies upon.[¶](#section-9-2){.pilcrow}

When SCHC is used with OSCORE, the security considerations discussed in
\[[RFC8613](#RFC8613){.xref}\] continue to
apply.[¶](#section-9-3){.pilcrow}

When SCHC is used with the OSCORE Outer headers, the Initialization
Vector (IV) size in the Compression Residue must be carefully selected.
There is a trade-off between compression efficiency (with a longer
\"MSB\" MO prefix) and the frequency at which the Device must renew its
key material (in order to prevent the IV from expanding to an
uncompressible value). The key-renewal operation itself requires several
message exchanges and requires energy-intensive computation, but the
optimal trade-off will depend on the specifics of the Device and
expected usage patterns.[¶](#section-9-4){.pilcrow}

If an attacker can introduce a corrupted SCHC-compressed packet onto a
link, DoS attacks can be mounted by causing excessive resource
consumption at the decompressor. However, an attacker able to inject
packets at the link layer is also capable of other, potentially more
damaging, attacks.[¶](#section-9-5){.pilcrow}

SCHC compression emits variable-length Compression Residues for some
CoAP fields. In the representation of the compressed header, the length
field that is sent is not the length of the original header field but
rather the length of the Compression Residue that is being transmitted.
If a corrupted packet arrives at the decompressor with a longer or
shorter length than the original compressed representation possessed,
the SCHC decompression procedures will detect an error and drop the
packet.[¶](#section-9-6){.pilcrow}

SCHC header compression Rules [MUST]{.bcp14} remain tightly coupled
between the compressor and the decompressor. If the compression Rules
get out of sync, a Compression Residue might be decompressed differently
at the receiver than the initial message submitted to compression
procedures. Accordingly, any time the context Rules are updated on an
OSCORE endpoint, that endpoint [MUST]{.bcp14} trigger OSCORE key
re-establishment. Similar procedures may be appropriate to signal Rule
updates when other message-protection mechanisms are in
use.[¶](#section-9-7){.pilcrow}
:::
:::

::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC5116\]
:   [McGrew, D.]{.refAuthor}, [\"An Interface and Algorithms for
    Authenticated Encryption\"]{.refTitle}, [RFC 5116]{.seriesInfo},
    [DOI 10.17487/RFC5116]{.seriesInfo}, January 2008,
    \<<https://www.rfc-editor.org/info/rfc5116>\>.
:   

\[RFC7252\]
:   [Shelby, Z.]{.refAuthor}, [Hartke, K.]{.refAuthor}, and [C.
    Bormann]{.refAuthor}, [\"The Constrained Application Protocol
    (CoAP)\"]{.refTitle}, [RFC 7252]{.seriesInfo}, [DOI
    10.17487/RFC7252]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7252>\>.
:   

\[RFC7641\]
:   [Hartke, K.]{.refAuthor}, [\"Observing Resources in the Constrained
    Application Protocol (CoAP)\"]{.refTitle}, [RFC 7641]{.seriesInfo},
    [DOI 10.17487/RFC7641]{.seriesInfo}, September 2015,
    \<<https://www.rfc-editor.org/info/rfc7641>\>.
:   

\[RFC7959\]
:   [Bormann, C.]{.refAuthor} and [Z. Shelby, Ed.]{.refAuthor},
    [\"Block-Wise Transfers in the Constrained Application Protocol
    (CoAP)\"]{.refTitle}, [RFC 7959]{.seriesInfo}, [DOI
    10.17487/RFC7959]{.seriesInfo}, August 2016,
    \<<https://www.rfc-editor.org/info/rfc7959>\>.
:   

\[RFC7967\]
:   [Bhattacharyya, A.]{.refAuthor}, [Bandyopadhyay, S.]{.refAuthor},
    [Pal, A.]{.refAuthor}, and [T. Bose]{.refAuthor}, [\"Constrained
    Application Protocol (CoAP) Option for No Server
    Response\"]{.refTitle}, [RFC 7967]{.seriesInfo}, [DOI
    10.17487/RFC7967]{.seriesInfo}, August 2016,
    \<<https://www.rfc-editor.org/info/rfc7967>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8613\]
:   [Selander, G.]{.refAuthor}, [Mattsson, J.]{.refAuthor},
    [Palombini, F.]{.refAuthor}, and [L. Seitz]{.refAuthor}, [\"Object
    Security for Constrained RESTful Environments
    (OSCORE)\"]{.refTitle}, [RFC 8613]{.seriesInfo}, [DOI
    10.17487/RFC8613]{.seriesInfo}, July 2019,
    \<<https://www.rfc-editor.org/info/rfc8613>\>.
:   

\[RFC8724\]
:   [Minaburo, A.]{.refAuthor}, [Toutain, L.]{.refAuthor},
    [Gomez, C.]{.refAuthor}, [Barthel, D.]{.refAuthor}, and [JC.
    Zúñiga]{.refAuthor}, [\"SCHC: Generic Framework for Static Context
    Header Compression and Fragmentation\"]{.refTitle}, [RFC
    8724]{.seriesInfo}, [DOI 10.17487/RFC8724]{.seriesInfo}, April 2020,
    \<<https://www.rfc-editor.org/info/rfc8724>\>.
:   
:::

::: {#acknowledgements}
::: {#appendix-A .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

The authors would like to thank (in alphabetic order): [Christian
Amsuss]{.contact-name}, [Dominique Barthel]{.contact-name}, [Carsten
Bormann]{.contact-name}, [Theresa Enghardt]{.contact-name}, [Thomas
Fossati]{.contact-name}, [Klaus Hartke]{.contact-name}, [Benjamin
Kaduk]{.contact-name}, [Francesca Palombini]{.contact-name}, [Alexander
Pelov]{.contact-name}, [Göran Selander]{.contact-name}, and [Éric
Vyncke]{.contact-name}.[¶](#appendix-A-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-B .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Ana Minaburo]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Acklio]{.org}
:::

::: {.left dir="auto"}
[1137A avenue des Champs Blancs]{.street-address}
:::

::: {.left dir="auto"}
[35510]{.postal-code} [Cesson-Sevigne Cedex]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <ana@ackl.io>
:::

::: {.left dir="auto"}
[Laurent Toutain]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Institut MINES TELECOM; IMT Atlantique]{.org}
:::

::: {.left dir="auto"}
[CS 17607]{.extended-address}
:::

::: {.left dir="auto"}
[2 rue de la Chataigneraie]{.street-address}
:::

::: {.left dir="auto"}
[35576]{.postal-code} [Cesson-Sevigne Cedex]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <Laurent.Toutain@imt-atlantique.fr>
:::

::: {.left dir="auto"}
[Ricardo Andreasen]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Universidad de Buenos Aires]{.org}
:::

::: {.left dir="auto"}
[Av. Paseo Colon 850]{.street-address}
:::

::: {.left dir="auto"}
[C1063ACV]{.postal-code} [Ciudad Autonoma de Buenos Aires]{.locality}
:::

::: {.left dir="auto"}
[Argentina]{.country-name}
:::

::: email
Email: <randreasen@fi.uba.ar>
:::
:::
:::
