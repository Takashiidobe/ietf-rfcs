  RFC 8723           Double SRTP       April 2020
  ------------------ ----------------- ------------
  Jennings, et al.   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8723](https://www.rfc-editor.org/rfc/rfc8723){.eref}

Category:
:   Standards Track

Published:
:   April 2020

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    C. Jennings
    :::

    ::: org
    Cisco Systems
    :::
    :::

    ::: author
    ::: author-name
    P. Jones
    :::

    ::: org
    Cisco Systems
    :::
    :::

    ::: author
    ::: author-name
    R. Barnes
    :::

    ::: org
    Cisco Systems
    :::
    :::

    ::: author
    ::: author-name
    A.B. Roach
    :::

    ::: org
    Mozilla
    :::
    :::
:::

# RFC 8723 {#rfcnum}

# Double Encryption Procedures for the Secure Real-Time Transport Protocol (SRTP) {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

In some conferencing scenarios, it is desirable for an intermediary to
be able to manipulate some parameters in Real-time Transport Protocol
(RTP) packets, while still providing strong end-to-end security
guarantees. This document defines a cryptographic transform for the
Secure Real-time Transport Protocol (SRTP) that uses two separate but
related cryptographic operations to provide hop-by-hop and end-to-end
security guarantees. Both the end-to-end and hop-by-hop cryptographic
algorithms can utilize an authenticated encryption with associated data
(AEAD) algorithm or take advantage of future SRTP transforms with
different properties.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8723>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Cryptographic
    Context](#name-cryptographic-context){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Key
        Derivation](#name-key-derivation){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Original Header
    Block](#name-original-header-block){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [RTP
    Operations](#name-rtp-operations){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Encrypting a
        Packet](#name-encrypting-a-packet){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Relaying a
        Packet](#name-relaying-a-packet){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Decrypting a
        Packet](#name-decrypting-a-packet){.xref}[¶](#section-toc.1-1.5.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [RTCP
    Operations](#name-rtcp-operations){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Use with Other RTP
    Mechanisms](#name-use-with-other-rtp-mechanis){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [RTP Retransmission
        (RTX)](#name-rtp-retransmission-rtx){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Redundant Audio Data
        (RED)](#name-redundant-audio-data-red){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Forward Error Correction
        (FEC)](#name-forward-error-correction-fe){.xref}[¶](#section-toc.1-1.7.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [DTMF](#name-dtmf){.xref}[¶](#section-toc.1-1.7.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Recommended Inner and Outer Cryptographic
    Algorithms](#name-recommended-inner-and-outer){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}

    -   ::: {#section-toc.1-1.10.2.1}
        [10.1](#section-10.1){.xref}.  [DTLS-SRTP](#name-dtls-srtp){.xref}[¶](#section-toc.1-1.10.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}

    -   ::: {#section-toc.1-1.11.2.1}
        [11.1](#section-11.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.11.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [11.2](#section-11.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.11.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [Appendix A](#section-appendix.a){.xref}.  [Encryption
    Overview](#name-encryption-overview){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.13}
    [](#section-appendix.b){.xref}[Acknowledgments](#name-acknowledgments){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.14}
    [](#section-appendix.c){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Cloud conferencing systems that are based on switched conferencing have
a central Media Distributor (MD) device that receives media from
endpoints and distributes it to other endpoints, but does not need to
interpret or change the media content. For these systems, it is
desirable to have one cryptographic key that enables encryption and
authentication of the media end-to-end while still allowing certain
information in the header of an RTP packet to be changed by the MD. At
the same time, a separate cryptographic key provides integrity and
optional confidentiality for the media flowing between the MD and the
endpoints. The framework document
\[[PRIVATE-MEDIA-FRAMEWORK](#I-D.ietf-perc-private-media-framework){.xref}\]
describes this concept in more detail.[¶](#section-1-1){.pilcrow}

This specification defines a transform for SRTP that uses 1) the AES
Galois/Counter Mode (AES-GCM) algorithm \[[RFC7714](#RFC7714){.xref}\]
to provide encryption and integrity for an RTP packet for the end-to-end
cryptographic key and 2) a hop-by-hop cryptographic encryption and
integrity between the endpoint and the MD. The MD decrypts and checks
integrity of the hop-by-hop security. The MD [MAY]{.bcp14} change some
of the RTP header information that would impact the end-to-end
integrity. In that case, the original value of any RTP header field that
is changed is included in an \"Original Header Block\" that is added to
the packet. The new RTP packet is encrypted with the hop-by-hop
cryptographic algorithm before it is sent. The receiving endpoint
decrypts and checks integrity using the hop-by-hop cryptographic
algorithm and then replaces any parameters the MD changed using the
information in the Original Header Block before decrypting and checking
the end-to-end integrity.[¶](#section-1-2){.pilcrow}

One can think of the double transform as a normal SRTP transform for
encrypting the RTP in a way such that things that only know half of the
key, can decrypt and modify part of the RTP packet but not other parts,
including the media payload.[¶](#section-1-3){.pilcrow}
:::
:::

::: {#terminology}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}

Terms used throughout this document include:[¶](#section-2-2){.pilcrow}

Media Distributor (MD):
:   A device that receives media from endpoints and distributes it to
    other endpoints, but does not need to interpret or change the media
    content (see also
    \[[PRIVATE-MEDIA-FRAMEWORK](#I-D.ietf-perc-private-media-framework){.xref}\]).[¶](#section-2-3.2){.pilcrow}
:   

end-to-end:
:   The path from one endpoint through one or more MDs to the endpoint
    at the other end.[¶](#section-2-3.4){.pilcrow}
:   

hop-by-hop:
:   The path from the endpoint to or from the
    MD.[¶](#section-2-3.6){.pilcrow}
:   

Original Header Block (OHB):
:   An octet string that contains the original values from the RTP
    header that might have been changed by an
    MD.[¶](#section-2-3.8){.pilcrow}
:   
:::
:::

::: {#cryptographic-context}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Cryptographic Context](#name-cryptographic-context){.section-name .selfRef} {#name-cryptographic-context}

This specification uses a cryptographic context with two
parts:[¶](#section-3-1){.pilcrow}

-   [An inner (end-to-end) part that is used by endpoints that originate
    and consume media to ensure the integrity of media end-to-end,
    and[¶](#section-3-2.1){.pilcrow}]{#section-3-2.1}
-   [An outer (hop-by-hop) part that is used between endpoints and MDs
    to ensure the integrity of media over a single hop and to enable an
    MD to modify certain RTP header fields. RTCP is also handled using
    the hop-by-hop cryptographic
    part.[¶](#section-3-2.2){.pilcrow}]{#section-3-2.2}

The [RECOMMENDED]{.bcp14} cipher for the hop-by-hop and end-to-end
algorithms is AES-GCM. Other combinations of SRTP ciphers that support
the procedures in this document can be added to the IANA
registry.[¶](#section-3-3){.pilcrow}

The keys and salt for these algorithms are generated with the following
steps:[¶](#section-3-4){.pilcrow}

-   [Generate key and salt values of the length required for the
    combined inner (end-to-end) and outer (hop-by-hop)
    algorithms.[¶](#section-3-5.1){.pilcrow}]{#section-3-5.1}
-   [Assign the key and salt values generated for the inner (end-to-end)
    algorithm to the first half of the key and the first half of the
    salt for the double
    algorithm.[¶](#section-3-5.2){.pilcrow}]{#section-3-5.2}
-   [Assign the key and salt values for the outer (hop-by-hop) algorithm
    to the second half of the key and second half of the salt for the
    double algorithm. The first half of the key is referred to as the
    inner key while the second half is referred to as the outer key.
    When a key is used by a cryptographic algorithm, the salt that is
    used is the part of the salt generated with that
    key.[¶](#section-3-5.3){.pilcrow}]{#section-3-5.3}
-   [the synchronization source (SSRC) is the same for both the inner
    and outer algorithms as it cannot be
    changed.[¶](#section-3-5.4){.pilcrow}]{#section-3-5.4}
-   [The sequence number (SEQ) and rollover counter (ROC) are tracked
    independently for the inner and outer
    algorithms.[¶](#section-3-5.5){.pilcrow}]{#section-3-5.5}

If the MD is to be able to modify header fields but not decrypt the
payload, then it must have a cryptographic key for the outer algorithm
but not the inner (end-to-end) algorithm. This document does not define
how the MD should be provisioned with this information. One possible way
to provide keying material for the outer (hop-by-hop) algorithm is to
use
\[[DTLS-TUNNEL](#I-D.ietf-perc-dtls-tunnel){.xref}\].[¶](#section-3-6){.pilcrow}

::: {#key-derivation}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Key Derivation](#name-key-derivation){.section-name .selfRef} {#name-key-derivation}

Although SRTP uses a single master key to derive keys for an SRTP
session, this transform requires separate inner and outer keys. In order
to allow the inner and outer keys to be managed independently via the
master key, the transforms defined in this document [MUST]{.bcp14} be
used with the following pseudorandom function (PRF), which preserves the
separation between the two halves of the key. Given a positive integer
`n` representing the desired output length, a master key `k_master`, and
an input `x`:[¶](#section-3.1-1){.pilcrow}

::: {#section-3.1-2 .artwork .art-text .alignCenter}
    PRF_double_n(k_master,x) = PRF_(n/2)(inner(k_master),x) ||
                               PRF_(n/2)(outer(k_master),x)

[¶](#section-3.1-2){.pilcrow}
:::

Here `PRF_double_n(k_master, x)` represents the AES_CM PRF Key
Derivation Function (KDF) (see [Section
4.3.3](https://www.rfc-editor.org/rfc/rfc3711#section-4.3.3){.relref} of
\[[RFC3711](#RFC3711){.xref}\]) for
DOUBLE_AEAD_AES_128_GCM_AEAD_AES_128_GCM algorithm and AES_256_CM_PRF
KDF \[[RFC6188](#RFC6188){.xref}\] for
DOUBLE_AEAD_AES_256_GCM_AEAD_AES_256_GCM algorithm. The term
`inner(k_master)` represents the first half of the key;
`outer(k_master)` represents the second half of the
key.[¶](#section-3.1-3){.pilcrow}
:::
:::
:::
:::

::: {#ohb}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Original Header Block](#name-original-header-block){.section-name .selfRef} {#name-original-header-block}

The OHB contains the original values of any modified RTP header fields.
In the encryption process, the OHB is included in an SRTP packet as
described in [Section 5](#rtp-operations){.xref}. In the decryption
process, the receiving endpoint uses it to reconstruct the original RTP
header so that it can pass the proper additional authenticated data
(AAD) value to the inner transform.[¶](#section-4-1){.pilcrow}

The OHB can reflect modifications to the following fields in an RTP
header: the payload type (PT), the SEQ, and the marker bit. All other
fields in the RTP header [MUST]{.bcp14} remain unmodified; since the OHB
cannot reflect their original values, the receiver will be unable to
verify the end-to-end integrity of the
packet.[¶](#section-4-2){.pilcrow}

The OHB has the following syntax (in ABNF
\[[RFC5234](#RFC5234){.xref}\]):[¶](#section-4-3){.pilcrow}

::: {#section-4-4}
``` {.sourcecode .lang-abnf}
OCTET = %x00-FF

PT = OCTET
SEQ = 2OCTET
Config = OCTET
OHB = [ PT ] [ SEQ ] Config
```

[¶](#section-4-4){.pilcrow}
:::

If present, the PT and SEQ parts of the OHB contain the original payload
type and sequence number fields, respectively. The final \"Config\"
octet of the OHB specifies whether these fields are present, and the
original value of the marker bit (if
necessary):[¶](#section-4-5){.pilcrow}

::: {#section-4-6 .artwork .art-text .alignLeft}
    +-+-+-+-+-+-+-+-+
    |R R R R B M P Q|
    +-+-+-+-+-+-+-+-+

[¶](#section-4-6){.pilcrow}
:::

-   [P: PT is present[¶](#section-4-7.1){.pilcrow}]{#section-4-7.1}
-   [Q: SEQ is present[¶](#section-4-7.2){.pilcrow}]{#section-4-7.2}
-   [M: Marker bit is
    present[¶](#section-4-7.3){.pilcrow}]{#section-4-7.3}
-   [B: Value of marker
    bit[¶](#section-4-7.4){.pilcrow}]{#section-4-7.4}
-   [R: Reserved, [MUST]{.bcp14} be set to
    0[¶](#section-4-7.5){.pilcrow}]{#section-4-7.5}

In particular, an all-zero OHB Config octet (`0x00`) indicates that
there have been no modifications from the original
header.[¶](#section-4-8){.pilcrow}

If the marker bit is not present (M=0), then `B` [MUST]{.bcp14} be set
to zero. That is, if `C` represents the value of the Config octet, then
the masked value `C & 0x0C` [MUST NOT]{.bcp14} have the value
`0x80`.[¶](#section-4-9){.pilcrow}
:::
:::

::: {#rtp-operations}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [RTP Operations](#name-rtp-operations){.section-name .selfRef} {#name-rtp-operations}

As implied by the use of the word \"double\" above, this transform
applies AES-GCM to the SRTP packet twice. This allows media distributors
to be able to modify some header fields while allowing endpoints to
verify the end-to-end integrity of a packet.[¶](#section-5-1){.pilcrow}

The first, \"inner\" application of AES-GCM encrypts the SRTP payload
and protects the integrity of a version of the SRTP header with
extensions truncated. Omitting extensions from the inner integrity check
means that they can be modified by an MD holding only the outer
key.[¶](#section-5-2){.pilcrow}

The second, \"outer\" application of AES-GCM encrypts the ciphertext
produced by the inner encryption (i.e., the encrypted payload and
authentication tag), plus an OHB that expresses any changes made between
the inner and outer transforms.[¶](#section-5-3){.pilcrow}

An MD that has the outer key but not the inner key may modify the header
fields that can be included in the OHB by decrypting, modifying, and
re-encrypting the packet.[¶](#section-5-4){.pilcrow}

::: {#encrypt}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Encrypting a Packet](#name-encrypting-a-packet){.section-name .selfRef} {#name-encrypting-a-packet}

An endpoint encrypts a packet by using the inner (end-to-end)
cryptographic key and then the outer (hop-by-hop) cryptographic key. The
encryption also supports a mode for repair packets that only does the
outer (hop-by-hop) encryption. The processes is as
follows:[¶](#section-5.1-1){.pilcrow}

1.  [Form an RTP packet. If there are any header extensions, they
    [MUST]{.bcp14} use
    \[[RFC8285](#RFC8285){.xref}\].[¶](#section-5.1-2.1){.pilcrow}]{#section-5.1-2.1}

2.  [If the packet is for repair mode data, skip to [step
    6](#step6){.xref}.[¶](#section-5.1-2.2){.pilcrow}]{#section-5.1-2.2}

3.  ::: {#section-5.1-2.3}
    Form a synthetic RTP packet with the following
    contents:[¶](#section-5.1-2.3.1){.pilcrow}

    -   ::: {#section-5.1-2.3.2.1}
        Header: The RTP header of the original packet with the following
        modifications:[¶](#section-5.1-2.3.2.1.1){.pilcrow}

        -   [The X bit is set to
            zero.[¶](#section-5.1-2.3.2.1.2.1){.pilcrow}]{#section-5.1-2.3.2.1.2.1}
        -   [The header is truncated to remove any extensions (i.e.,
            keep only the first 12 + 4 \* CSRC count (CC) bytes of the
            header).[¶](#section-5.1-2.3.2.1.2.2){.pilcrow}]{#section-5.1-2.3.2.1.2.2}
        :::

    -   [Payload: The RTP payload of the original packet (including
        padding when
        present).[¶](#section-5.1-2.3.2.2){.pilcrow}]{#section-5.1-2.3.2.2}
    :::

4.  [Apply the inner cryptographic algorithm to the synthetic RTP packet
    from the previous
    step.[¶](#section-5.1-2.4){.pilcrow}]{#section-5.1-2.4}

5.  [Replace the header of the protected RTP packet with the header of
    the original packet (to restore any header extensions and reset the
    X bit), and append an empty OHB (`0x00`) to the encrypted payload
    (with the authentication tag) obtained from [step
    4](#step4a){.xref}.[¶](#section-5.1-2.5){.pilcrow}]{#section-5.1-2.5}

6.  [Apply the outer cryptographic algorithm to the RTP packet. If
    encrypting RTP header extensions hop-by-hop, then
    \[[RFC6904](#RFC6904){.xref}\] [MUST]{.bcp14} be used when
    encrypting the RTP packet using the outer cryptographic
    key.[¶](#section-5.1-2.6){.pilcrow}]{#section-5.1-2.6}

When using Encrypted Key Transport (EKT)
\[[EKT-SRTP](#I-D.ietf-perc-srtp-ekt-diet){.xref}\], the EKTField comes
after the SRTP packet, exactly like using EKT with any other SRTP
transform.[¶](#section-5.1-3){.pilcrow}
:::
:::

::: {#relay}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Relaying a Packet](#name-relaying-a-packet){.section-name .selfRef} {#name-relaying-a-packet}

The MD has the part of the key for the outer (hop-by-hop) cryptographic
algorithm, but it does not have the part of the key for the inner
(end-to-end) cryptographic algorithm. The cryptographic algorithm and
key used to decrypt a packet and any encrypted RTP header extensions
would be the same as those used in the endpoint\'s outer algorithm and
key.[¶](#section-5.2-1){.pilcrow}

In order to modify a packet, the MD decrypts the received packet,
modifies the packet, updates the OHB with any modifications not already
present in the OHB, and re-encrypts the packet using the outer
(hop-by-hop) cryptographic key before transmitting using the following
steps:[¶](#section-5.2-2){.pilcrow}

1.  [Apply the outer (hop-by-hop) cryptographic algorithm to decrypt the
    packet. If decrypting RTP header extensions hop-by-hop, then
    \[[RFC6904](#RFC6904){.xref}\] [MUST]{.bcp14} be used. Note that the
    RTP payload produced by this decryption operation contains the
    original encrypted payload with the tag from the inner transform and
    the OHB appended.[¶](#section-5.2-3.1){.pilcrow}]{#section-5.2-3.1}

2.  [Make any desired changes to the fields that are allowed to be
    changed, i.e., PT, SEQ, and M. The MD [MAY]{.bcp14} also make
    modifications to header extensions, without the need to reflect
    these changes in the
    OHB.[¶](#section-5.2-3.2){.pilcrow}]{#section-5.2-3.2}

3.  ::: {#section-5.2-3.3}
    Reflect any changes to header fields in the
    OHB:[¶](#section-5.2-3.3.1){.pilcrow}

    -   [If the MD changed a field that is not already in the OHB, then
        it [MUST]{.bcp14} add the original value of the field to the
        OHB. Note that this might result in an increase in the size of
        the
        OHB.[¶](#section-5.2-3.3.2.1){.pilcrow}]{#section-5.2-3.3.2.1}
    -   [If the MD took a field that had previously been modified and
        reset to its original value, then it [SHOULD]{.bcp14} drop the
        corresponding information from the OHB. Note that this might
        result in a decrease in the size of the
        OHB.[¶](#section-5.2-3.3.2.2){.pilcrow}]{#section-5.2-3.3.2.2}
    -   [Otherwise, the MD [MUST NOT]{.bcp14} modify the
        OHB.[¶](#section-5.2-3.3.2.3){.pilcrow}]{#section-5.2-3.3.2.3}
    :::

4.  [Apply the outer (hop-by-hop) cryptographic algorithm to the packet.
    If the RTP sequence number has been modified, SRTP processing
    happens as defined in SRTP and will end up using the new sequence
    number. If encrypting RTP header extensions hop-by-hop, then
    \[[RFC6904](#RFC6904){.xref}\] [MUST]{.bcp14} be
    used.[¶](#section-5.2-3.4){.pilcrow}]{#section-5.2-3.4}

In order to avoid nonce reuse, the cryptographic contexts used in steps
[1](#step1){.xref} and [4](#step4){.xref} [MUST]{.bcp14} use different,
independent master keys. Note that this means that the key used for
decryption by the MD [MUST]{.bcp14} be different from the key used for
re-encryption to the end recipient.[¶](#section-5.2-4){.pilcrow}

Note that if multiple MDs modify the same packet, then the first MD to
alter a given header field is the one that adds it to the OHB. If a
subsequent MD changes the value of a header field that has already been
changed, then the original value will already be in the OHB, so no
update to the OHB is required.[¶](#section-5.2-5){.pilcrow}

An MD that decrypts, modifies, and re-encrypts packets in this way
[MUST]{.bcp14} use an independent key for each recipient, and [MUST
NOT]{.bcp14} re-encrypt the packet using the sender\'s keys. If the MD
decrypts and re-encrypts with the same key and salt, it will result in
the reuse of a (key, nonce) pair, undermining the security of
AES-GCM.[¶](#section-5.2-6){.pilcrow}
:::
:::

::: {#decrypt}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Decrypting a Packet](#name-decrypting-a-packet){.section-name .selfRef} {#name-decrypting-a-packet}

To decrypt a packet, the endpoint first decrypts and verifies using the
outer (hop-by-hop) cryptographic key, then uses the OHB to reconstruct
the original packet, which it decrypts and verifies with the inner
(end-to-end) cryptographic key using the following
steps:[¶](#section-5.3-1){.pilcrow}

1.  [Apply the outer cryptographic algorithm to the packet. If the
    integrity check does not pass, discard the packet. The result of
    this is referred to as the outer SRTP packet. If decrypting RTP
    header extensions hop-by-hop, then \[[RFC6904](#RFC6904){.xref}\]
    [MUST]{.bcp14} be used when decrypting the RTP packet using the
    outer cryptographic
    key.[¶](#section-5.3-2.1){.pilcrow}]{#section-5.3-2.1}

2.  [If the packet is for repair mode data, skip the rest of the steps.
    Note that the packet that results from the repair algorithm will
    still have encrypted data that needs to be decrypted as specified by
    the repair algorithm
    sections.[¶](#section-5.3-2.2){.pilcrow}]{#section-5.3-2.2}

3.  [Remove the inner authentication tag and the OHB from the end of the
    payload of the outer SRTP
    packet.[¶](#section-5.3-2.3){.pilcrow}]{#section-5.3-2.3}

4.  ::: {#section-5.3-2.4}
    Form a new synthetic SRTP packet
    with:[¶](#section-5.3-2.4.1){.pilcrow}

    -   ::: {#section-5.3-2.4.2.1}
        Header = Received header, with the following
        modifications:[¶](#section-5.3-2.4.2.1.1){.pilcrow}

        -   [Header fields replaced with values from OHB (if
            any).[¶](#section-5.3-2.4.2.1.2.1){.pilcrow}]{#section-5.3-2.4.2.1.2.1}
        -   [The X bit is set to
            zero.[¶](#section-5.3-2.4.2.1.2.2){.pilcrow}]{#section-5.3-2.4.2.1.2.2}
        -   [The header is truncated to remove any extensions (i.e.,
            keep only the first 12 + 4 \* CC bytes of the
            header).[¶](#section-5.3-2.4.2.1.2.3){.pilcrow}]{#section-5.3-2.4.2.1.2.3}
        :::

    -   [Payload is the encrypted payload from the outer SRTP packet
        (after the inner tag and OHB have been
        stripped).[¶](#section-5.3-2.4.2.2){.pilcrow}]{#section-5.3-2.4.2.2}

    -   [Authentication tag is the inner authentication tag from the
        outer SRTP
        packet.[¶](#section-5.3-2.4.2.3){.pilcrow}]{#section-5.3-2.4.2.3}
    :::

5.  [Apply the inner cryptographic algorithm to this synthetic SRTP
    packet. Note if the RTP sequence number was changed by the MD, the
    synthetic packet has the original sequence number. If the integrity
    check does not pass, discard the
    packet.[¶](#section-5.3-2.5){.pilcrow}]{#section-5.3-2.5}

Once the packet has been successfully decrypted, the application needs
to be careful about which information it uses to get the correct
behavior. The application [MUST]{.bcp14} use only the information found
in the synthetic SRTP packet and [MUST NOT]{.bcp14} use the other data
that was in the outer SRTP packet with the following
exceptions:[¶](#section-5.3-3){.pilcrow}

-   [The PT from the outer SRTP packet is used for normal matching to
    Session Description Protocol (SDP) and codec
    selection.[¶](#section-5.3-4.1){.pilcrow}]{#section-5.3-4.1}
-   [The sequence number from the outer SRTP packet is used for normal
    RTP ordering.[¶](#section-5.3-4.2){.pilcrow}]{#section-5.3-4.2}

The PT and sequence number from the inner SRTP packet can be used for
collection of various statistics.[¶](#section-5.3-5){.pilcrow}

If the RTP header of the outer packet contains extensions, they
[MAY]{.bcp14} be used. However, because extensions are not protected
end-to-end, implementations [SHOULD]{.bcp14} reject an RTP packet
containing headers that would require end-to-end
protection.[¶](#section-5.3-6){.pilcrow}
:::
:::
:::
:::

::: {#rtcp-operations}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [RTCP Operations](#name-rtcp-operations){.section-name .selfRef} {#name-rtcp-operations}

Unlike RTP, which is encrypted both hop-by-hop and end-to-end using two
separate cryptographic keys, RTCP is encrypted using only the outer
(hop-by-hop) cryptographic key. The procedures for RTCP encryption are
specified in \[[RFC3711](#RFC3711){.xref}\], and this document
introduces no additional steps.[¶](#section-6-1){.pilcrow}
:::
:::

::: {#use-with-other-rtp-mechanisms}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Use with Other RTP Mechanisms](#name-use-with-other-rtp-mechanis){.section-name .selfRef} {#name-use-with-other-rtp-mechanis}

MDs sometimes interact with RTP media packets sent by endpoints, e.g.,
to provide recovery or receive commands via dual-tone multi-frequency
(DTMF) signaling. When media packets are encrypted end-to-end, these
procedures require modification. (End-to-end interactions, including
end-to-end recovery, are not affected by end-to-end
encryption.)[¶](#section-7-1){.pilcrow}

Repair mechanisms, in general, will need to perform recovery on
encrypted packets (double-encrypted when using this transform), since
the MD does not have access to the plaintext of the packet, only an
intermediate, E2E-encrypted form.[¶](#section-7-2){.pilcrow}

When the recovery mechanism calls for the recovery packet itself to be
encrypted, it is encrypted with only the outer, hop-by-hop key. This
allows an MD to generate recovery packets without having access to the
inner, end-to-end keys. However, it also results in recovery packets
being triple-encrypted, twice for the base transform, and once for the
recovery protection.[¶](#section-7-3){.pilcrow}

::: {#rtx}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [RTP Retransmission (RTX)](#name-rtp-retransmission-rtx){.section-name .selfRef} {#name-rtp-retransmission-rtx}

When using RTX \[[RFC4588](#RFC4588){.xref}\] with the double transform,
the cached payloads [MUST]{.bcp14} be the double-encrypted packets,
i.e., the bits that are sent over the wire to the other side. When
encrypting a retransmission packet, it [MUST]{.bcp14} be encrypted like
a packet in repair mode (i.e., with only the hop-by-hop
key).[¶](#section-7.1-1){.pilcrow}

If the MD were to cache the inner, E2E-encrypted payload and retransmit
it with an RTX original sequence number field prepended, then the
modifications to the payload would cause the inner integrity check to
fail at the receiver.[¶](#section-7.1-2){.pilcrow}

A typical RTX receiver would decrypt the packet, undo the RTX
transformation, then process the resulting packet normally by using the
steps in [Section 5.3](#decrypt){.xref}.[¶](#section-7.1-3){.pilcrow}
:::
:::

::: {#red}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Redundant Audio Data (RED)](#name-redundant-audio-data-red){.section-name .selfRef} {#name-redundant-audio-data-red}

When using RED \[[RFC2198](#RFC2198){.xref}\] with the double transform,
the processing at the sender and receiver is the same as when using RED
with any other SRTP transform.[¶](#section-7.2-1){.pilcrow}

The main difference between the double transform and any other transform
is that in an intermediated environment, usage of RED must be
end-to-end. An MD cannot synthesize RED packets, because it lacks access
to the plaintext media payloads that are combined to form a RED
payload.[¶](#section-7.2-2){.pilcrow}

Note that Flexible Forward Error Correction (Flex FEC) may often provide
similar or better repair capabilities compared to RED. For most
applications, Flex FEC is a better choice than RED; in particular, Flex
FEC has modes in which the MD can synthesize recovery
packets.[¶](#section-7.2-3){.pilcrow}
:::
:::

::: {#fec}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Forward Error Correction (FEC)](#name-forward-error-correction-fe){.section-name .selfRef} {#name-forward-error-correction-fe}

When using Flex FEC \[[RFC8627](#RFC8627){.xref}\] with the double
transform, repair packets [MUST]{.bcp14} be constructed by first
double-encrypting the packet, then performing FEC. Processing of repair
packets proceeds in the opposite order, performing FEC recovery and then
decrypting. This ensures that the original media is not revealed to the
MD but, at the same time, allows the MD to repair media. When encrypting
a packet that contains the Flex FEC data, which is already encrypted, it
[MUST]{.bcp14} be encrypted with only the outer, hop-by-hop
transform.[¶](#section-7.3-1){.pilcrow}

The algorithm recommended in
\[[WEBRTC-FEC](#I-D.ietf-rtcweb-fec){.xref}\] for repair of video is
Flex FEC \[[RFC8627](#RFC8627){.xref}\]. Note that for interoperability
with WebRTC, \[[WEBRTC-FEC](#I-D.ietf-rtcweb-fec){.xref}\] recommends
not using additional FEC-only \"m=\" lines in SDP for the repair
packets.[¶](#section-7.3-2){.pilcrow}
:::
:::

::: {#dtmf}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [DTMF](#name-dtmf){.section-name .selfRef} {#name-dtmf}

When DTMF is sent using the mechanism in \[[RFC4733](#RFC4733){.xref}\],
it is end-to-end encrypted; the relay cannot read it, so it cannot be
used to control the relay. Other out-of-band methods to control the
relay need to be used instead.[¶](#section-7.4-1){.pilcrow}
:::
:::
:::
:::

::: {#recommended-inner-and-outer-cryptographic-algorithms}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Recommended Inner and Outer Cryptographic Algorithms](#name-recommended-inner-and-outer){.section-name .selfRef} {#name-recommended-inner-and-outer}

This specification recommends and defines AES-GCM as both the inner and
outer cryptographic algorithms, identified as
DOUBLE_AEAD_AES_128_GCM_AEAD_AES_128_GCM and
DOUBLE_AEAD_AES_256_GCM_AEAD_AES_256_GCM. These algorithms provide for
authenticated encryption and will consume additional processing time
double-encrypting for hop-by-hop and end-to-end. However, the approach
is secure and simple; thus, it is viewed as an acceptable trade-off in
processing efficiency.[¶](#section-8-1){.pilcrow}

Note that names for the cryptographic transforms are of the form
DOUBLE\_(inner algorithm)\_(outer algorithm).[¶](#section-8-2){.pilcrow}

While this document only defines a profile based on AES-GCM, it is
possible for future documents to define further profiles with different
inner and outer algorithms in this same framework. For example, if a new
SRTP transform were defined that encrypts some or all of the RTP header,
it would be reasonable for systems to have the option of using that for
the outer algorithm. Similarly, if a new transform were defined that
provided only integrity, that would also be reasonable to use for the
outer transform as the payload data is already encrypted by the inner
transform.[¶](#section-8-3){.pilcrow}

The AES-GCM cryptographic algorithm introduces an additional 16 octets
to the length of the packet. When using AES-GCM for both the inner and
outer cryptographic algorithms, the total additional length is 32
octets. The OHB will consume an additional 1-4 octets. Packets in repair
mode will carry additional repair data, further increasing their
size.[¶](#section-8-4){.pilcrow}
:::
:::

::: {#sec}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

This SRTP transform provides protection against two classes of attacker:
a network attacker that knows neither the inner nor outer keys and a
malicious MD that knows the outer key. Obviously, it provides no
protections against an attacker that holds both the inner and outer
keys.[¶](#section-9-1){.pilcrow}

The protections with regard to the network are the same as with the
normal SRTP AES-GCM transforms. The major difference is that the double
transforms are designed to work better in a group context. In such
contexts, it is important to note that because these transforms are
symmetric, they do not protect against attacks within the group. Any
member of the group can generate valid SRTP packets for any SSRC in use
by the group.[¶](#section-9-2){.pilcrow}

With regard to a malicious MD, the recipient can verify the integrity of
the base header fields and confidentiality and integrity of the payload.
The recipient has no assurance, however, of the integrity of the header
extensions in the packet.[¶](#section-9-3){.pilcrow}

The main innovation of this transform relative to other SRTP transforms
is that it allows a partly trusted MD to decrypt, modify, and re-encrypt
a packet. When this is done, the cryptographic contexts used for
decryption and re-encryption [MUST]{.bcp14} use different, independent
master keys. If the same context is used, the nonce formation rules for
SRTP will cause the same key and nonce to be used with two different
plaintexts, which substantially degrades the security of
AES-GCM.[¶](#section-9-4){.pilcrow}

In other words, from the perspective of the MD, re-encrypting packets
using this protocol will involve the same cryptographic operations as if
it had established independent AES-GCM crypto contexts with the sender
and the receiver. This property allows the use of an MD that supports
AES-GCM but does not modify any header fields, without requiring any
modification to the MD.[¶](#section-9-5){.pilcrow}
:::
:::

::: {#iana}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

::: {#dtlssrtp}
::: {#section-10.1 .section}
### [10.1.](#section-10.1){.section-number .selfRef} [DTLS-SRTP](#name-dtls-srtp){.section-name .selfRef} {#name-dtls-srtp}

IANA has added the following protection profiles to the \"DTLS-SRTP
Protection Profiles\" registry defined in
\[[RFC5764](#RFC5764){.xref}\].[¶](#section-10.1-1){.pilcrow}

[]{#name-updates-to-the-dtls-srtp-pr}

  Value          Profile                                    Reference
  -------------- ------------------------------------------ -----------
  {0x00, 0x09}   DOUBLE_AEAD_AES_128_GCM_AEAD_AES_128_GCM   RFC 8723
  {0x00, 0x0A}   DOUBLE_AEAD_AES_256_GCM_AEAD_AES_256_GCM   RFC 8723

  : [Table 1](#table-1){.selfRef}: [Updates to the DTLS-SRTP Protection
  Profiles Registry](#name-updates-to-the-dtls-srtp-pr){.selfRef}

The SRTP transform parameters for each of these protection profiles
are:[¶](#section-10.1-3){.pilcrow}

[]{#name-srtp-transform-parameters-f}

  ------------------------------------------ ------------------------------------------------------------
  DOUBLE_AEAD_AES_128_GCM_AEAD_AES_128_GCM   
  cipher:                                    AES_128_GCM then AES_128_GCM
  cipher_key_length:                         256 bits
  cipher_salt_length:                        192 bits
  aead_auth_tag_length:                      256 bits
  auth_function:                             NULL
  auth_key_length:                           N/A
  auth_tag_length:                           N/A
  maximum lifetime:                          at most 2^31^ SRTCP packets and at most 2^48^ SRTP packets
  ------------------------------------------ ------------------------------------------------------------

  : [Table 2](#table-2){.selfRef}: [SRTP Transform Parameters for
  DOUBLE_AEAD_AES_128_GCM_AEAD_AES_128_GCM](#name-srtp-transform-parameters-f){.selfRef}

[]{#name-srtp-transform-parameters-fo}

  ------------------------------------------ ------------------------------------------------------------
  DOUBLE_AEAD_AES_256_GCM_AEAD_AES_256_GCM   
  cipher:                                    AES_256_GCM then AES_256_GCM
  cipher_key_length:                         512 bits
  cipher_salt_length:                        192 bits
  aead_auth_tag_length:                      256 bits
  auth_function:                             NULL
  auth_key_length:                           N/A
  auth_tag_length:                           N/A
  maximum lifetime:                          at most 2^31^ SRTCP packets and at most 2^48^ SRTP packets
  ------------------------------------------ ------------------------------------------------------------

  : [Table 3](#table-3){.selfRef}: [SRTP Transform Parameters for
  DOUBLE_AEAD_AES_256_GCM_AEAD_AES_256_GCM](#name-srtp-transform-parameters-fo){.selfRef}

The first half of the key and salt is used for the inner (end-to-end)
algorithm and the second half is used for the outer (hop-by-hop)
algorithm.[¶](#section-10.1-6){.pilcrow}
:::
:::
:::
:::

::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-11.1 .section}
### [11.1.](#section-11.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC3711\]
:   [Baugher, M.]{.refAuthor}[, McGrew, D.]{.refAuthor}[,
    Naslund, M.]{.refAuthor}[, Carrara, E.]{.refAuthor}[, and K.
    Norrman]{.refAuthor}, [\"The Secure Real-time Transport Protocol
    (SRTP)\"]{.refTitle}, [RFC 3711]{.seriesInfo}, [DOI
    10.17487/RFC3711]{.seriesInfo}, March 2004,
    \<<https://www.rfc-editor.org/info/rfc3711>\>.
:   

\[RFC5764\]
:   [McGrew, D.]{.refAuthor}[ and E. Rescorla]{.refAuthor}, [\"Datagram
    Transport Layer Security (DTLS) Extension to Establish Keys for the
    Secure Real-time Transport Protocol (SRTP)\"]{.refTitle}, [RFC
    5764]{.seriesInfo}, [DOI 10.17487/RFC5764]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5764>\>.
:   

\[RFC6188\]
:   [McGrew, D.]{.refAuthor}, [\"The Use of AES-192 and AES-256 in
    Secure RTP\"]{.refTitle}, [RFC 6188]{.seriesInfo}, [DOI
    10.17487/RFC6188]{.seriesInfo}, March 2011,
    \<<https://www.rfc-editor.org/info/rfc6188>\>.
:   

\[RFC6904\]
:   [Lennox, J.]{.refAuthor}, [\"Encryption of Header Extensions in the
    Secure Real-time Transport Protocol (SRTP)\"]{.refTitle}, [RFC
    6904]{.seriesInfo}, [DOI 10.17487/RFC6904]{.seriesInfo}, April 2013,
    \<<https://www.rfc-editor.org/info/rfc6904>\>.
:   

\[RFC7714\]
:   [McGrew, D.]{.refAuthor}[ and K. Igoe]{.refAuthor}, [\"AES-GCM
    Authenticated Encryption in the Secure Real-time Transport Protocol
    (SRTP)\"]{.refTitle}, [RFC 7714]{.seriesInfo}, [DOI
    10.17487/RFC7714]{.seriesInfo}, December 2015,
    \<<https://www.rfc-editor.org/info/rfc7714>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8285\]
:   [Singer, D.]{.refAuthor}[, Desineni, H.]{.refAuthor}[, and R. Even,
    Ed.]{.refAuthor}, [\"A General Mechanism for RTP Header
    Extensions\"]{.refTitle}, [RFC 8285]{.seriesInfo}, [DOI
    10.17487/RFC8285]{.seriesInfo}, October 2017,
    \<<https://www.rfc-editor.org/info/rfc8285>\>.
:   
:::

::: {#section-11.2 .section}
### [11.2.](#section-11.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[DTLS-TUNNEL\]
:   [Jones, P.]{.refAuthor}[, Ellenbogen, P.]{.refAuthor}[, and N.
    Ohlmeier]{.refAuthor}, [\"DTLS Tunnel between a Media Distributor
    and Key Distributor to Facilitate Key Exchange\"]{.refTitle}, [Work
    in Progress]{.refContent}, [Internet-Draft,
    draft-ietf-perc-dtls-tunnel-06]{.seriesInfo}, 16 October 2019,
    \<<https://tools.ietf.org/html/draft-ietf-perc-dtls-tunnel-06>\>.
:   

\[EKT-SRTP\]
:   [Jennings, C.]{.refAuthor}[, Mattsson, J.]{.refAuthor}[,
    McGrew, D.]{.refAuthor}[, Wing, D.]{.refAuthor}[, and F.
    Andreasen]{.refAuthor}, [\"Encrypted Key Transport for DTLS and
    Secure RTP\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-perc-srtp-ekt-diet-10]{.seriesInfo}, 8
    July 2019,
    \<<https://tools.ietf.org/html/draft-ietf-perc-srtp-ekt-diet-10>\>.
:   

\[PRIVATE-MEDIA-FRAMEWORK\]
:   [Jones, P.]{.refAuthor}[, Benham, D.]{.refAuthor}[, and C.
    Groves]{.refAuthor}, [\"A Solution Framework for Private Media in
    Privacy Enhanced RTP Conferencing (PERC)\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-perc-private-media-framework-12]{.seriesInfo}, 5 June
    2019,
    \<<https://tools.ietf.org/html/draft-ietf-perc-private-media-framework-12>\>.
:   

\[RFC2198\]
:   [Perkins, C.]{.refAuthor}[, Kouvelas, I.]{.refAuthor}[,
    Hodson, O.]{.refAuthor}[, Hardman, V.]{.refAuthor}[,
    Handley, M.]{.refAuthor}[, Bolot, J.C.]{.refAuthor}[,
    Vega-Garcia, A.]{.refAuthor}[, and S. Fosse-Parisis]{.refAuthor},
    [\"RTP Payload for Redundant Audio Data\"]{.refTitle}, [RFC
    2198]{.seriesInfo}, [DOI 10.17487/RFC2198]{.seriesInfo}, September
    1997, \<<https://www.rfc-editor.org/info/rfc2198>\>.
:   

\[RFC4588\]
:   [Rey, J.]{.refAuthor}[, Leon, D.]{.refAuthor}[,
    Miyazaki, A.]{.refAuthor}[, Varsa, V.]{.refAuthor}[, and R.
    Hakenberg]{.refAuthor}, [\"RTP Retransmission Payload
    Format\"]{.refTitle}, [RFC 4588]{.seriesInfo}, [DOI
    10.17487/RFC4588]{.seriesInfo}, July 2006,
    \<<https://www.rfc-editor.org/info/rfc4588>\>.
:   

\[RFC4733\]
:   [Schulzrinne, H.]{.refAuthor}[ and T. Taylor]{.refAuthor}, [\"RTP
    Payload for DTMF Digits, Telephony Tones, and Telephony
    Signals\"]{.refTitle}, [RFC 4733]{.seriesInfo}, [DOI
    10.17487/RFC4733]{.seriesInfo}, December 2006,
    \<<https://www.rfc-editor.org/info/rfc4733>\>.
:   

\[RFC5234\]
:   [Crocker, D., Ed.]{.refAuthor}[ and P. Overell]{.refAuthor},
    [\"Augmented BNF for Syntax Specifications: ABNF\"]{.refTitle}, [STD
    68]{.seriesInfo}, [RFC 5234]{.seriesInfo}, [DOI
    10.17487/RFC5234]{.seriesInfo}, January 2008,
    \<<https://www.rfc-editor.org/info/rfc5234>\>.
:   

\[RFC8627\]
:   [Zanaty, M.]{.refAuthor}[, Singh, V.]{.refAuthor}[,
    Begen, A.]{.refAuthor}[, and G. Mandyam]{.refAuthor}, [\"RTP Payload
    Format for Flexible Forward Error Correction (FEC)\"]{.refTitle},
    [RFC 8627]{.seriesInfo}, [DOI 10.17487/RFC8627]{.seriesInfo}, July
    2019, \<<https://www.rfc-editor.org/info/rfc8627>\>.
:   

\[WEBRTC-FEC\]
:   [Uberti, J.]{.refAuthor}, [\"WebRTC Forward Error Correction
    Requirements\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-rtcweb-fec-10]{.seriesInfo}, 16 July
    2019, \<<https://tools.ietf.org/html/draft-ietf-rtcweb-fec-10>\>.
:   
:::
:::

::: {#encryption-overview}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Encryption Overview](#name-encryption-overview){.section-name .selfRef} {#name-encryption-overview}

The following figures show a double-encrypted SRTP packet. The sides
indicate the parts of the packet that are encrypted and authenticated by
the hop-by-hop and end-to-end
operations.[¶](#section-appendix.a-1){.pilcrow}

::: {#section-appendix.a-2 .artwork .art-text .alignLeft .art-ascii-art}
         0                   1                   2                   3
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |V=2|P|X|  CC   |M|     PT      |       sequence number         |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |                           timestamp                           |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |           synchronization source (SSRC) identifier            |
        +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
        |            contributing source (CSRC) identifiers             |
        |                               ....                            |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |                    RTP extension (OPTIONAL) ...               |
    +>+>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    O I |                          payload ...                          |
    O I |                               +-------------------------------+
    O I |                               | RTP padding   | RTP pad count |
    O +>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    O | |                    E2E authentication tag                     |
    O | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    O | |                            OHB ...                            |
    +>| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | | |                    HBH authentication tag                     |
    | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | |
    | +- E2E Encrypted Portion
    |
    +--- HBH Encrypted Portion

[¶](#section-appendix.a-2){.pilcrow}
:::

::: {#section-appendix.a-3 .artwork .art-text .alignLeft .art-ascii-art}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+<+
    |V=2|P|X|  CC   |M|     PT      |       sequence number         | I O
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ I O
    |                           timestamp                           | I O
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ I O
    |           synchronization source (SSRC) identifier            | I O
    +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ I O
    |            contributing source (CSRC) identifiers             | I O
    |                               ....                            | I O
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+ O
    |                    RTP extension (OPTIONAL) ...               | | O
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+ O
    |                           payload ...                         | I O
    |                               +-------------------------------+ I O
    |                               | RTP padding   | RTP pad count | I O
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+ O
    |                    E2E authentication tag                     | | O
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | O
    |                            OHB ...                            | | O
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |<+
    |                    HBH authentication tag                     | | |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | |
                                                                      | |
                                         E2E Authenticated Portion ---+ |
                                                                        |
                                         HBH Authenticated Portion -----+

[¶](#section-appendix.a-3){.pilcrow}
:::
:::
:::

::: {#acknowledgments}
::: {#section-appendix.b .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

Thank you to [Alex Gouaillard]{.contact-name}, [David
Benham]{.contact-name}, [Magnus Westerlund]{.contact-name}, [Nils
Ohlmeier]{.contact-name}, [Roni Even]{.contact-name}, and [Suhas
Nandakumar]{.contact-name} for reviews and improvements to this
specification. In addition, thank you to [Sergio Garcia
Murillo]{.contact-name}, who proposed the change of transporting the OHB
information in the RTP payload instead of the RTP
header.[¶](#section-appendix.b-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.c .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Cullen Jennings]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Cisco Systems]{.org}
:::

::: email
Email: <fluffy@iii.ca>
:::

::: {.left dir="auto"}
[Paul E. Jones]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Cisco Systems]{.org}
:::

::: email
Email: <paulej@packetizer.com>
:::

::: {.left dir="auto"}
[Richard Barnes]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Cisco Systems]{.org}
:::

::: email
Email: <rlb@ipv.sx>
:::

::: {.left dir="auto"}
[Adam Roach]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Mozilla]{.org}
:::

::: email
Email: <adam@nostrum.com>
:::
:::
:::
