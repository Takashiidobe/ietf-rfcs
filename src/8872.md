  RFC 8872             Guidelines for Multiplexing in RTP   January 2021
  -------------------- ------------------------------------ --------------
  Westerlund, et al.   Informational                        \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8872](https://www.rfc-editor.org/rfc/rfc8872){.eref}

Category:
:   Informational

Published:
:   January 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    M. Westerlund
    :::

    ::: org
    Ericsson
    :::
    :::

    ::: author
    ::: author-name
    B. Burman
    :::

    ::: org
    Ericsson
    :::
    :::

    ::: author
    ::: author-name
    C. Perkins
    :::

    ::: org
    University of Glasgow
    :::
    :::

    ::: author
    ::: author-name
    H. Alvestrand
    :::

    ::: org
    Google
    :::
    :::

    ::: author
    ::: author-name
    R. Even
    :::
    :::
:::

# RFC 8872 {#rfcnum}

# Guidelines for Using the Multiplexing Features of RTP to Support Multiple Media Streams {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

The Real-time Transport Protocol (RTP) is a flexible protocol that can
be used in a wide range of applications, networks, and system
topologies. That flexibility makes for wide applicability but can
complicate the application design process. One particular design
question that has received much attention is how to support multiple
media streams in RTP. This memo discusses the available options and
design trade-offs, and provides guidelines on how to use the
multiplexing features of RTP to support multiple media
streams.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for informational
purposes.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Not all documents approved
by the IESG are candidates for any level of Internet Standard; see
Section 2 of RFC 7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8872>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Definitions](#name-definitions){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.2.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [Focus of This
        Document](#name-focus-of-this-document){.xref}[¶](#section-toc.1-1.2.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [RTP Multiplexing
    Overview](#name-rtp-multiplexing-overview){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Reasons for Multiplexing and
        Grouping RTP
        Streams](#name-reasons-for-multiplexing-an){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [RTP Multiplexing
        Points](#name-rtp-multiplexing-points){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.3.2.2.2.1}
            [3.2.1](#section-3.2.1){.xref}.  [RTP
            Session](#name-rtp-session){.xref}[¶](#section-toc.1-1.3.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.2}
            [3.2.2](#section-3.2.2){.xref}.  [Synchronization Source
            (SSRC)](#name-synchronization-source-ssrc){.xref}[¶](#section-toc.1-1.3.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.3}
            [3.2.3](#section-3.2.3){.xref}.  [Contributing Source
            (CSRC)](#name-contributing-source-csrc){.xref}[¶](#section-toc.1-1.3.2.2.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.4}
            [3.2.4](#section-3.2.4){.xref}.  [RTP Payload
            Type](#name-rtp-payload-type){.xref}[¶](#section-toc.1-1.3.2.2.2.4.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Issues Related to RTP
        Topologies](#name-issues-related-to-rtp-topol){.xref}[¶](#section-toc.1-1.3.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [Issues Related to RTP and
        RTCP](#name-issues-related-to-rtp-and-r){.xref}[¶](#section-toc.1-1.3.2.4.1){.pilcrow}

        -   ::: {#section-toc.1-1.3.2.4.2.1}
            [3.4.1](#section-3.4.1){.xref}.  [The RTP
            Specification](#name-the-rtp-specification){.xref}[¶](#section-toc.1-1.3.2.4.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.4.2.2}
            [3.4.2](#section-3.4.2){.xref}.  [Multiple SSRCs in a
            Session](#name-multiple-ssrcs-in-a-session){.xref}[¶](#section-toc.1-1.3.2.4.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.4.2.3}
            [3.4.3](#section-3.4.3){.xref}.  [Binding Related
            Sources](#name-binding-related-sources){.xref}[¶](#section-toc.1-1.3.2.4.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.4.2.4}
            [3.4.4](#section-3.4.4){.xref}.  [Forward Error
            Correction](#name-forward-error-correction){.xref}[¶](#section-toc.1-1.3.2.4.2.4.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Considerations for RTP
    Multiplexing](#name-considerations-for-rtp-mult){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Interworking
        Considerations](#name-interworking-considerations){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.4.2.1.2.1}
            [4.1.1](#section-4.1.1){.xref}.  [Application
            Interworking](#name-application-interworking){.xref}[¶](#section-toc.1-1.4.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.2}
            [4.1.2](#section-4.1.2){.xref}.  [RTP Translator
            Interworking](#name-rtp-translator-interworking){.xref}[¶](#section-toc.1-1.4.2.1.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.3}
            [4.1.3](#section-4.1.3){.xref}.  [Gateway
            Interworking](#name-gateway-interworking){.xref}[¶](#section-toc.1-1.4.2.1.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.4}
            [4.1.4](#section-4.1.4){.xref}.  [Legacy Considerations for
            Multiple
            SSRCs](#name-legacy-considerations-for-m){.xref}[¶](#section-toc.1-1.4.2.1.2.4.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Network
        Considerations](#name-network-considerations){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.4.2.2.2.1}
            [4.2.1](#section-4.2.1){.xref}.  [Quality of
            Service](#name-quality-of-service){.xref}[¶](#section-toc.1-1.4.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.2}
            [4.2.2](#section-4.2.2){.xref}.  [NAT and Firewall
            Traversal](#name-nat-and-firewall-traversal){.xref}[¶](#section-toc.1-1.4.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.3}
            [4.2.3](#section-4.2.3){.xref}.  [Multicast](#name-multicast){.xref}[¶](#section-toc.1-1.4.2.2.2.3.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Security and Key-Management
        Considerations](#name-security-and-key-management){.xref}[¶](#section-toc.1-1.4.2.3.1){.pilcrow}

        -   ::: {#section-toc.1-1.4.2.3.2.1}
            [4.3.1](#section-4.3.1){.xref}.  [Security Context
            Scope](#name-security-context-scope){.xref}[¶](#section-toc.1-1.4.2.3.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.2}
            [4.3.2](#section-4.3.2){.xref}.  [Key Management for
            Multi-party
            Sessions](#name-key-management-for-multi-pa){.xref}[¶](#section-toc.1-1.4.2.3.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.3}
            [4.3.3](#section-4.3.3){.xref}.  [Complexity
            Implications](#name-complexity-implications){.xref}[¶](#section-toc.1-1.4.2.3.2.3.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [RTP Multiplexing Design
    Choices](#name-rtp-multiplexing-design-cho){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Multiple Media Types in One
        Session](#name-multiple-media-types-in-one){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Multiple SSRCs of the Same Media
        Type](#name-multiple-ssrcs-of-the-same-){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Multiple Sessions for One Media
        Type](#name-multiple-sessions-for-one-m){.xref}[¶](#section-toc.1-1.5.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [Single SSRC per
        Endpoint](#name-single-ssrc-per-endpoint){.xref}[¶](#section-toc.1-1.5.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [Summary](#name-summary){.xref}[¶](#section-toc.1-1.5.2.5.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Guidelines](#name-guidelines){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [References](#name-references){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.9.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.9.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [Appendix A](#section-appendix.a){.xref}.  [Dismissing Payload Type
    Multiplexing](#name-dismissing-payload-type-mul){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [Appendix B](#section-appendix.b){.xref}.  [Signaling
    Considerations](#name-signaling-considerations){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}

    -   ::: {#section-toc.1-1.11.2.1}
        [B.1](#section-b.1){.xref}.  [Session-Oriented
        Properties](#name-session-oriented-properties){.xref}[¶](#section-toc.1-1.11.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [B.2](#section-b.2){.xref}.  [SDP Prevents Multiple Media
        Types](#name-sdp-prevents-multiple-media){.xref}[¶](#section-toc.1-1.11.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.11.2.3}
        [B.3](#section-b.3){.xref}.  [Signaling RTP Stream
        Usage](#name-signaling-rtp-stream-usage){.xref}[¶](#section-toc.1-1.11.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [](#section-appendix.c){.xref}[Acknowledgments](#name-acknowledgments){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.13}
    [](#section-appendix.d){.xref}[Contributors](#name-contributors){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.14}
    [](#section-appendix.e){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::
:::
:::

::: {#sect-1}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The Real-time Transport Protocol (RTP) \[[RFC3550](#RFC3550){.xref}\] is
a commonly used protocol for real-time media transport. It is a protocol
that provides great flexibility and can support a large set of different
applications. From the beginning, RTP was designed for multiple
participants in a communication session. It supports many topology
paradigms and usages, as defined in \[[RFC7667](#RFC7667){.xref}\]. RTP
has several multiplexing points designed for different purposes; these
points enable support of multiple RTP streams and switching between
different encoding or packetization techniques for the media. By using
multiple RTP sessions, sets of RTP streams can be structured for
efficient processing or identification. Thus, to meet an application\'s
needs, an RTP application designer needs to understand how best to use
the RTP session, the RTP stream identifier (synchronization source
(SSRC)), and the RTP payload type.[¶](#section-1-1){.pilcrow}

There has been increased interest in more-advanced usage of RTP. For
example, multiple RTP streams can be used when a single endpoint has
multiple media sources (like multiple cameras or microphones) from which
streams of media need to be sent simultaneously. Consequently, questions
are raised regarding the most appropriate RTP usage. The limitations in
some implementations, RTP/RTCP extensions, and signaling have also been
exposed. This document aims to clarify the usefulness of some
functionalities in RTP that, hopefully, will result in future
implementations that are more complete.[¶](#section-1-2){.pilcrow}

The purpose of this document is to provide clear information about the
possibilities of RTP when it comes to multiplexing. The RTP application
designer needs to understand the implications arising from a particular
usage of the RTP multiplexing points. This document provides some
guidelines and recommends against some usages as being unsuitable, in
general or for particular purposes.[¶](#section-1-3){.pilcrow}

This document starts with some definitions and then goes into existing
RTP functionalities around multiplexing. Both the desired behavior and
the implications of a particular behavior depend on which topologies are
used; therefore, this topic requires some consideration. We then discuss
some choices regarding multiplexing behavior and the impacts of those
choices. Some designs of RTP usage are also discussed. Finally, some
guidelines and examples are provided.[¶](#section-1-4){.pilcrow}
:::
:::

::: {#sect-2}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Definitions](#name-definitions){.section-name .selfRef} {#name-definitions}

::: {#sect-2.1}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The definitions in [Section
3](https://www.rfc-editor.org/rfc/rfc3550#section-3){.relref} of
\[[RFC3550](#RFC3550){.xref}\] are referenced
normatively.[¶](#section-2.1-1){.pilcrow}

The taxonomy defined in \[[RFC7656](#RFC7656){.xref}\] is referenced
normatively.[¶](#section-2.1-2){.pilcrow}

The following terms and abbreviations are used in this
document:[¶](#section-2.1-3){.pilcrow}

[]{.break}

Multi-party:
:   Communication that includes multiple endpoints. In this document,
    \"multi-party\" will be used to refer to scenarios where more than
    two endpoints communicate.[¶](#section-2.1-4.2){.pilcrow}
:   

Multiplexing:
:   An operation that takes multiple entities as input, aggregating them
    onto some common resource while keeping the individual entities
    addressable such that they can later be fully and unambiguously
    separated (demultiplexed) again.[¶](#section-2.1-4.4){.pilcrow}
:   

RTP Receiver:
:   An endpoint or middlebox receiving RTP streams and RTCP messages. It
    uses at least one SSRC to send RTCP messages. An RTP receiver may
    also be an RTP sender.[¶](#section-2.1-4.6){.pilcrow}
:   

RTP Sender:
:   An endpoint sending one or more RTP streams but also sending RTCP
    messages.[¶](#section-2.1-4.8){.pilcrow}
:   

RTP Session Group:
:   One or more RTP sessions that are used together to perform some
    function. Examples include multiple RTP sessions used to carry
    different layers of a layered encoding. In an RTP Session Group,
    CNAMEs are assumed to be valid across all RTP sessions and designate
    synchronization contexts that can cross RTP sessions; i.e., SSRCs
    that map to a common CNAME can be assumed to have RTCP Sender Report
    (SR) timing information derived from a common clock such that they
    can be synchronized for playout.[¶](#section-2.1-4.10){.pilcrow}
:   

Signaling:
:   The process of configuring endpoints to participate in one or more
    RTP sessions.[¶](#section-2.1-4.12){.pilcrow}
:   

Note: The above definitions of \"RTP receiver\" and \"RTP sender\" are
consistent with the usage in
\[[RFC3550](#RFC3550){.xref}\].[¶](#section-2.1-5.1){.pilcrow}
:::
:::

::: {#sect-2.2}
::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [Focus of This Document](#name-focus-of-this-document){.section-name .selfRef} {#name-focus-of-this-document}

This document is focused on issues that affect RTP. Thus, issues that
involve signaling protocols \-- such as whether SIP
\[[RFC3261](#RFC3261){.xref}\], Jingle \[[JINGLE](#JINGLE){.xref}\], or
some other protocol is in use for session configuration; the particular
syntaxes used to define RTP session properties; or the constraints
imposed by particular choices in the signaling protocols \-- are
mentioned only as examples in order to describe the RTP issues more
precisely.[¶](#section-2.2-1){.pilcrow}

This document assumes that the applications will use RTCP. While there
are applications that don\'t send RTCP, they do not conform to the RTP
specification and thus can be regarded as reusing the RTP packet format
but not implementing RTP.[¶](#section-2.2-2){.pilcrow}
:::
:::
:::
:::

::: {#sect-3}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [RTP Multiplexing Overview](#name-rtp-multiplexing-overview){.section-name .selfRef} {#name-rtp-multiplexing-overview}

::: {#sect-3.1}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Reasons for Multiplexing and Grouping RTP Streams](#name-reasons-for-multiplexing-an){.section-name .selfRef} {#name-reasons-for-multiplexing-an}

There are several reasons why an endpoint might choose to send multiple
media streams. In the discussion below, please keep in mind that the
reasons for having multiple RTP streams vary and include, but are not
limited to, the following:[¶](#section-3.1-1){.pilcrow}

-   [There might be multiple media
    sources.[¶](#section-3.1-2.1){.pilcrow}]{#section-3.1-2.1}

-   ::: {#section-3.1-2.2}
    Multiple RTP streams might be needed to represent one media source,
    for example:[¶](#section-3.1-2.2.1){.pilcrow}

    -   [To carry different layers of a scalable encoding of a media
        source[¶](#section-3.1-2.2.2.1){.pilcrow}]{#section-3.1-2.2.2.1}
    -   [Alternative encodings during simulcast, using different codecs
        for the same audio
        stream[¶](#section-3.1-2.2.2.2){.pilcrow}]{#section-3.1-2.2.2.2}
    -   [Alternative formats during simulcast, multiple resolutions of
        the same video
        stream[¶](#section-3.1-2.2.2.3){.pilcrow}]{#section-3.1-2.2.2.3}
    :::

-   [A retransmission stream might repeat some parts of the content of
    another RTP
    stream.[¶](#section-3.1-2.3){.pilcrow}]{#section-3.1-2.3}

-   [A Forward Error Correction (FEC) stream might provide material that
    can be used to repair another RTP
    stream.[¶](#section-3.1-2.4){.pilcrow}]{#section-3.1-2.4}

For each of these reasons, it is necessary to decide whether each
additional RTP stream is sent within the same RTP session as the other
RTP streams or it is necessary to use additional RTP sessions to group
the RTP streams. For a combination of reasons, the suitable choice for
one situation might not be the suitable choice for another situation.
The choice is easiest when multiplexing multiple media sources of the
same media type. However, all reasons warrant discussion and
clarification regarding how to deal with them. As the discussion below
will show, a single solution does not suit all purposes. To utilize RTP
well and as efficiently as possible, both are needed. The real issue is
knowing when to create multiple RTP sessions versus when to send
multiple RTP streams in a single RTP
session.[¶](#section-3.1-3){.pilcrow}
:::
:::

::: {#sect-3.2}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [RTP Multiplexing Points](#name-rtp-multiplexing-points){.section-name .selfRef} {#name-rtp-multiplexing-points}

This section describes the multiplexing points present in RTP that can
be used to distinguish RTP streams and groups of RTP streams. [Figure
1](#ref-rtp-demultiplexing-process){.xref} outlines the process of
demultiplexing incoming RTP streams, starting with one or more sockets
representing the reception of one or more transport flows, e.g., based
on the UDP destination port. It also demultiplexes RTP/RTCP from any
other protocols, such as Session Traversal Utilities for NAT (STUN)
\[[RFC5389](#RFC5389){.xref}\] and DTLS-SRTP
\[[RFC5764](#RFC5764){.xref}\] on the same transport as described in
\[[RFC7983](#RFC7983){.xref}\]. The Processing and Buffering (PB) step
in [Figure 1](#ref-rtp-demultiplexing-process){.xref} terminates
RTP/RTCP and prepares the RTP payload for input to the
decoder.[¶](#section-3.2-1){.pilcrow}

[]{#name-rtp-demultiplexing-process}

::: {#ref-rtp-demultiplexing-process}
::: {#section-3.2-2.1 .artwork .art-text .alignLeft}
                       |   |   |
                       |   |   | packets
            +--        v   v   v
            |        +------------+
            |        |  Socket(s) |   Transport Protocol Demultiplexing
            |        +------------+
            |            ||  ||
       RTP  |       RTP/ ||  |+-----> DTLS (SRTP keying, SCTP, etc.)
    Session |       RTCP ||  +------> STUN (multiplexed using same port)
            +--          ||
            +--          ||
            |      ++(split by SSRC)-++---> Identify SSRC collision
            |      ||    ||    ||    ||
            | (associate with signaling by MID/RID)
            |      vv    vv    vv    vv
      RTP   |     +--+  +--+  +--+  +--+ Jitter buffer,
    Streams |     |PB|  |PB|  |PB|  |PB| process RTCP, etc.
            |     +--+  +--+  +--+  +--+
            +--     |    |      |    |
              (select decoder based on payload type (PT))
            +--     |   /       |  /
            |       +-----+     | /
            |         /   |     |/
    Payload |        v    v     v
    Formats |     +---+ +---+ +---+
            |     |Dec| |Dec| |Dec| Decoders
            |     +---+ +---+ +---+
            +--
:::

[Figure 1](#figure-1){.selfRef}: [RTP Demultiplexing
Process](#name-rtp-demultiplexing-process){.selfRef}
:::

::: {#sect-3.2.1}
::: {#section-3.2.1 .section}
#### [3.2.1.](#section-3.2.1){.section-number .selfRef} [RTP Session](#name-rtp-session){.section-name .selfRef} {#name-rtp-session}

An RTP session is the highest semantic layer in RTP and represents an
association between a group of communicating endpoints. RTP does not
contain a session identifier, yet different RTP sessions must be
possible to identify both across a set of different endpoints and from
the perspective of a single endpoint.[¶](#section-3.2.1-1){.pilcrow}

For RTP session separation across endpoints, the set of participants
that form an RTP session is defined as those that share a single SSRC
space \[[RFC3550](#RFC3550){.xref}\]. That is, if a group of
participants are each aware of the SSRC identifiers belonging to the
other participants, then those participants are in a single RTP session.
A participant can become aware of an SSRC identifier by receiving an RTP
packet containing the identifier in the SSRC field or contributing
source (CSRC) list, by receiving an RTCP packet listing it in an SSRC
field, or through signaling (e.g., the Session Description Protocol
(SDP) \[[RFC4566](#RFC4566){.xref}\] \"a=ssrc:\" attribute
\[[RFC5576](#RFC5576){.xref}\]). Thus, the scope of an RTP session is
determined by the participants\' network interconnection topology, in
combination with RTP and RTCP forwarding strategies deployed by the
endpoints and any middleboxes, and by the
signaling.[¶](#section-3.2.1-2){.pilcrow}

For RTP session separation within a single endpoint, RTP relies on the
underlying transport layer and the signaling to identify RTP sessions in
a manner that is meaningful to the application. A single endpoint can
have one or more transport flows for the same RTP session, and a single
RTP session can span multiple transport-layer flows even if all
endpoints use a single transport-layer flow per endpoint for that RTP
session. The signaling layer might give RTP sessions an explicit
identifier, or the identification might be implicit based on the
addresses and ports used. Accordingly, a single RTP session can have
multiple associated identifiers, explicit and implicit, belonging to
different contexts. For example, when running RTP on top of UDP/IP, an
endpoint can identify and delimit an RTP session from other RTP sessions
by their UDP source and destination IP addresses and their UDP port
numbers. A single RTP session can be using multiple IP/UDP flows for
receiving and/or sending RTP packets to other endpoints or middleboxes,
even if the endpoint does not have multiple IP addresses. Using multiple
IP addresses only makes it more likely that multiple IP/UDP flows will
be required. Another example is SDP media descriptions (the \"m=\" line
and the subsequent associated lines) that signal the transport flow and
RTP session configuration for the endpoint\'s part of the RTP session.
The SDP grouping framework \[[RFC5888](#RFC5888){.xref}\] allows
labeling of the media descriptions to be used so that RTP Session Groups
can be created. Through the use of [\"Negotiating Media Multiplexing
Using the Session Description Protocol (SDP)\"](#RFC8843){.xref}
\[[RFC8843](#RFC8843){.xref}\], multiple media descriptions become part
of a common RTP session where each media description represents the RTP
streams sent or received for a media
source.[¶](#section-3.2.1-3){.pilcrow}

RTP makes no normative statements about the relationship between
different RTP sessions; however, applications that use more than one RTP
session need to understand how the different RTP sessions that they
create relate to one another.[¶](#section-3.2.1-4){.pilcrow}
:::
:::

::: {#sect-3.2.2}
::: {#section-3.2.2 .section}
#### [3.2.2.](#section-3.2.2){.section-number .selfRef} [Synchronization Source (SSRC)](#name-synchronization-source-ssrc){.section-name .selfRef} {#name-synchronization-source-ssrc}

An SSRC identifies a source of an RTP stream, or an RTP receiver when
sending RTCP. Every endpoint has at least one SSRC identifier, even if
it does not send RTP packets. RTP endpoints that are only RTP receivers
still send RTCP and use their SSRC identifiers in the RTCP packets they
send. An endpoint can have multiple SSRC identifiers if it sends
multiple RTP streams. Endpoints that function as both RTP sender and RTP
receiver use the same SSRC(s) in both
roles.[¶](#section-3.2.2-1){.pilcrow}

The SSRC is a 32-bit identifier. It is present in every RTP and RTCP
packet header and in the payload of some RTCP packet types. It can also
be present in SDP signaling. Unless presignaled, e.g., using the SDP
\"a=ssrc:\" attribute \[[RFC5576](#RFC5576){.xref}\], the SSRC is chosen
at random. It is not dependent on the network address of the endpoint
and is intended to be unique within an RTP session. SSRC collisions can
occur and are handled as specified in \[[RFC3550](#RFC3550){.xref}\] and
\[[RFC5576](#RFC5576){.xref}\], resulting in the SSRC of the colliding
RTP streams or receivers changing. An endpoint that changes its network
transport address during a session has to choose a new SSRC identifier
to avoid being interpreted as a looped source, unless a mechanism
providing a virtual transport (such as Interactive Connectivity
Establishment (ICE) \[[RFC8445](#RFC8445){.xref}\]) abstracts the
changes.[¶](#section-3.2.2-2){.pilcrow}

SSRC identifiers that belong to the same synchronization context (i.e.,
that represent RTP streams that can be synchronized using information in
RTCP SR packets) use identical CNAME chunks in corresponding RTCP source
description (SDES) packets. SDP signaling can also be used to provide
explicit SSRC grouping
\[[RFC5576](#RFC5576){.xref}\].[¶](#section-3.2.2-3){.pilcrow}

In some cases, the same SSRC identifier value is used to relate streams
in two different RTP sessions, such as in RTP retransmission
\[[RFC4588](#RFC4588){.xref}\]. This is to be avoided, since there is no
guarantee that SSRC values are unique across RTP sessions. In the case
of RTP retransmission \[[RFC4588](#RFC4588){.xref}\], it is recommended
to use explicit binding of the source RTP stream and the redundancy
stream, e.g., using the RepairedRtpStreamId RTCP SDES item
\[[RFC8852](#RFC8852){.xref}\]. The RepairedRtpStreamId is a rather
recent mechanism, so one cannot expect older applications to follow this
recommendation.[¶](#section-3.2.2-4){.pilcrow}

Note that the RTP sequence number and RTP timestamp are scoped by the
SSRC and are thus specific per RTP
stream.[¶](#section-3.2.2-5){.pilcrow}

Different types of entities use an SSRC to identify themselves, as
follows:[¶](#section-3.2.2-6){.pilcrow}

-   [A real media source uses the SSRC to identify a \"physical\" media
    source.[¶](#section-3.2.2-7.1){.pilcrow}]{#section-3.2.2-7.1}
-   [A conceptual media source uses the SSRC to identify the result of
    applying some filtering function in a network node \-- for example,
    a filtering function in an RTP mixer that provides the most active
    speaker based on some criteria, or a mix representing a set of other
    sources.[¶](#section-3.2.2-7.2){.pilcrow}]{#section-3.2.2-7.2}
-   [An RTP receiver uses the SSRC to identify itself as the source of
    its RTCP
    reports.[¶](#section-3.2.2-7.3){.pilcrow}]{#section-3.2.2-7.3}

An endpoint that generates more than one media type, e.g., a conference
participant sending both audio and video, need not (and, indeed, should
not) use the same SSRC value across RTP sessions. Using RTCP compound
packets containing the CNAME SDES item is the designated method for
binding an SSRC to a CNAME, effectively cross-correlating SSRCs within
and between RTP sessions as coming from the same endpoint. The main
property attributed to SSRCs associated with the same CNAME is that they
are from a particular synchronization context and can be synchronized at
playback.[¶](#section-3.2.2-8){.pilcrow}

An RTP receiver receiving a previously unseen SSRC value will interpret
it as a new source. It might in fact be a previously existing source
that had to change its SSRC number due to an SSRC conflict. Using the
media identification (MID) extension \[[RFC8843](#RFC8843){.xref}\]
helps to identify which media source the new SSRC represents, and using
the restriction identifier (RID) extension
\[[RFC8851](#RFC8851){.xref}\] helps to identify what encoding or
redundancy stream it represents, even though the SSRC changed. However,
the originator of the previous SSRC ought to have ended the conflicting
source by sending an RTCP BYE for it prior to starting to send with the
new SSRC, making the new SSRC a new
source.[¶](#section-3.2.2-9){.pilcrow}
:::
:::

::: {#sect-3.2.3}
::: {#section-3.2.3 .section}
#### [3.2.3.](#section-3.2.3){.section-number .selfRef} [Contributing Source (CSRC)](#name-contributing-source-csrc){.section-name .selfRef} {#name-contributing-source-csrc}

The CSRC is not a separate identifier. Rather, an SSRC identifier is
listed as a CSRC in the RTP header of a packet generated by an RTP mixer
or video Multipoint Control Unit (MCU) / switch, if the corresponding
SSRC was in the header of one of the packets that contributed to the
output.[¶](#section-3.2.3-1){.pilcrow}

It is not possible, in general, to extract media represented by an
individual CSRC, since it is typically the result of a media merge
(e.g., mix) operation on the individual media streams corresponding to
the CSRC identifiers. The exception is the case where only a single CSRC
is indicated, as this represents the forwarding of an RTP stream that
might have been modified. The RTP header extension ([\"A Real-time
Transport Protocol (RTP) Header Extension for Mixer-to-Client Audio
Level Indication\"](#RFC6465){.xref} \[[RFC6465](#RFC6465){.xref}\])
expands on the receiver\'s information about a packet with a CSRC list.
Due to these restrictions, a CSRC will not be considered a fully
qualified multiplexing point and will be disregarded in the rest of this
document.[¶](#section-3.2.3-2){.pilcrow}
:::
:::

::: {#sect-3.2.4}
::: {#section-3.2.4 .section}
#### [3.2.4.](#section-3.2.4){.section-number .selfRef} [RTP Payload Type](#name-rtp-payload-type){.section-name .selfRef} {#name-rtp-payload-type}

Each RTP stream utilizes one or more RTP payload formats. An RTP payload
format describes how the output of a particular media codec is framed
and encoded into RTP packets. The payload format is identified by the
payload type (PT) field in the RTP packet header. The combination of
SSRC and PT therefore identifies a specific RTP stream in a specific
encoding format. The format definition can be taken from
\[[RFC3551](#RFC3551){.xref}\] for statically allocated payload types
but ought to be explicitly defined in signaling, such as SDP, for both
static and dynamic payload types. The term \"format\" here includes
those aspects described by out-of-band signaling means; in SDP, the term
\"format\" includes media type, RTP timestamp sampling rate, codec,
codec configuration, payload format configurations, and various
robustness mechanisms such as redundant encodings
\[[RFC2198](#RFC2198){.xref}\].[¶](#section-3.2.4-1){.pilcrow}

The RTP payload type is scoped by the sending endpoint within an RTP
session. PT has the same meaning across all RTP streams in an RTP
session. All SSRCs sent from a single endpoint share the same payload
type definitions. The RTP payload type is designed such that only a
single payload type is valid at any instant in time in the RTP stream\'s
timestamp timeline, effectively time-multiplexing different payload
types if any change occurs. The payload type can change on a per-packet
basis for an SSRC \-- for example, a speech codec making use of generic
comfort noise \[[RFC3389](#RFC3389){.xref}\]. If there is a true need to
send multiple payload types for the same SSRC that are valid for the
same instant, then redundant encodings \[[RFC2198](#RFC2198){.xref}\]
can be used. Several additional constraints, other than those mentioned
above, need to be met to enable this usage, one of which is that the
combined payload sizes of the different payload types ought not exceed
the transport MTU.[¶](#section-3.2.4-2){.pilcrow}

Other aspects of using the RTP payload format are described in [\"How to
Write an RTP Payload Format\"](#RFC8088){.xref}
\[[RFC8088](#RFC8088){.xref}\].[¶](#section-3.2.4-3){.pilcrow}

The payload type is not a multiplexing point at the RTP layer (see
[Appendix A](#sect-a){.xref} for a detailed discussion of why using the
payload type as an RTP multiplexing point does not work). The RTP
payload type is, however, used to determine how to consume and decode an
RTP stream. The RTP payload type number is sometimes used to associate
an RTP stream with the signaling, which in general requires that unique
RTP payload type numbers be used in each context. Using MID, e.g., when
bundling \"m=\" sections \[[RFC8843](#RFC8843){.xref}\], can replace the
payload type as a signaling association, and unique RTP payload types
are then no longer required for that
purpose.[¶](#section-3.2.4-4){.pilcrow}
:::
:::
:::
:::

::: {#sect-3.3}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Issues Related to RTP Topologies](#name-issues-related-to-rtp-topol){.section-name .selfRef} {#name-issues-related-to-rtp-topol}

The impact of how RTP multiplexing is performed will in general vary
with how the RTP session participants are interconnected, as described
in [\"RTP Topologies\"](#RFC7667){.xref}
\[[RFC7667](#RFC7667){.xref}\].[¶](#section-3.3-1){.pilcrow}

Even the most basic use case \-- \"Topo-Point-to-Point\" as described in
\[[RFC7667](#RFC7667){.xref}\] \-- raises a number of considerations,
which are discussed in detail in the following sections. They range over
such aspects as the following:[¶](#section-3.3-2){.pilcrow}

-   [Does my communication peer support RTP as defined with multiple
    SSRCs per RTP
    session?[¶](#section-3.3-3.1){.pilcrow}]{#section-3.3-3.1}
-   [Do I need network differentiation in the form of QoS ([Section
    4.2.1](#sect-4.2.1){.xref})?[¶](#section-3.3-3.2){.pilcrow}]{#section-3.3-3.2}
-   [Can the application more easily process and handle the media
    streams if they are in different RTP
    sessions?[¶](#section-3.3-3.3){.pilcrow}]{#section-3.3-3.3}
-   [Do I need to use additional RTP streams for RTP retransmission or
    FEC?[¶](#section-3.3-3.4){.pilcrow}]{#section-3.3-3.4}

For some point-to-multipoint topologies (e.g., Topo-ASM and Topo-SSM
\[[RFC7667](#RFC7667){.xref}\]), multicast is used to interconnect the
session participants. Special considerations (documented in [Section
4.2.3](#sect-4.2.3){.xref}) are then needed, as multicast is a
one-to-many distribution system.[¶](#section-3.3-4){.pilcrow}

Sometimes, an RTP communication session can end up in a situation where
the communicating peers are not compatible, for various
reasons:[¶](#section-3.3-5){.pilcrow}

-   [No common media codec for a media type, thus requiring
    transcoding.[¶](#section-3.3-6.1){.pilcrow}]{#section-3.3-6.1}
-   [Different support for multiple RTP streams and RTP
    sessions.[¶](#section-3.3-6.2){.pilcrow}]{#section-3.3-6.2}
-   [Usage of different media transport protocols (i.e., one peer uses
    RTP, but the other peer uses a different transport
    protocol).[¶](#section-3.3-6.3){.pilcrow}]{#section-3.3-6.3}
-   [Usage of different transport protocols, e.g., UDP, the Datagram
    Congestion Control Protocol (DCCP), or
    TCP.[¶](#section-3.3-6.4){.pilcrow}]{#section-3.3-6.4}
-   [Different security solutions (e.g., IPsec, TLS, DTLS, or the Secure
    Real-time Transport Protocol (SRTP)) with different keying
    mechanisms.[¶](#section-3.3-6.5){.pilcrow}]{#section-3.3-6.5}

These compatibility issues can often be resolved by the inclusion of a
translator between the two peers \-- the Topo-PtP-Translator, as
described in \[[RFC7667](#RFC7667){.xref}\]. The translator\'s main
purpose is to make the peers look compatible to each other. There can
also be reasons other than compatibility for inserting a translator in
the form of a middlebox or gateway \-- for example, a need to monitor
the RTP streams. Beware that changing the stream transport
characteristics in the translator can require a thorough understanding
of aspects ranging from congestion control and media-level adaptations
to application-layer semantics.[¶](#section-3.3-7){.pilcrow}

Within the uses enabled by the RTP standard, the point-to-point topology
can contain one or more RTP sessions with one or more media sources per
session, each having one or more RTP streams per media
source.[¶](#section-3.3-8){.pilcrow}
:::
:::

::: {#sect-3.4}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [Issues Related to RTP and RTCP](#name-issues-related-to-rtp-and-r){.section-name .selfRef} {#name-issues-related-to-rtp-and-r}

Using multiple RTP streams is a well-supported feature of RTP. However,
for most implementers or people writing RTP/RTCP applications or
extensions attempting to apply multiple streams, it can be unclear when
it is most appropriate to add an additional RTP stream in an existing
RTP session and when it is better to use multiple RTP sessions. This
section discusses the various considerations that need to be taken into
account.[¶](#section-3.4-1){.pilcrow}

::: {#sect-3.4.1}
::: {#section-3.4.1 .section}
#### [3.4.1.](#section-3.4.1){.section-number .selfRef} [The RTP Specification](#name-the-rtp-specification){.section-name .selfRef} {#name-the-rtp-specification}

RFC 3550 contains some recommendations and a numbered list ([Section
5.2](https://www.rfc-editor.org/rfc/rfc3550#section-5.2){.relref} of
\[[RFC3550](#RFC3550){.xref}\]) of five arguments regarding different
aspects of RTP multiplexing. Please review [Section
5.2](https://www.rfc-editor.org/rfc/rfc3550#section-5.2){.relref} of
\[[RFC3550](#RFC3550){.xref}\]. Five important aspects are quoted
below.[¶](#section-3.4.1-1){.pilcrow}

1.  ::: {#section-3.4.1-2.1}
    > If, say, two audio streams shared the same RTP session and the
    > same SSRC value, and one were to change encodings and thus acquire
    > a different RTP payload type, there would be no general way of
    > identifying which stream had changed
    > encodings.[¶](#section-3.4.1-2.1.1){.pilcrow}

    This argument advocates the use of different SSRCs for each
    individual RTP stream, as this is fundamental to RTP
    operation.[¶](#section-3.4.1-2.1.2){.pilcrow}
    :::

2.  ::: {#section-3.4.1-2.2}
    > An SSRC is defined to identify a single timing and sequence number
    > space. Interleaving multiple payload types would require different
    > timing spaces if the media clock rates differ and would require
    > different sequence number spaces to tell which payload type
    > suffered packet loss.[¶](#section-3.4.1-2.2.1){.pilcrow}

    This argument advocates against demultiplexing RTP streams within a
    session based only on their RTP payload type numbers; it still
    stands, as can be seen by the extensive list of issues discussed in
    [Appendix A](#sect-a){.xref}.[¶](#section-3.4.1-2.2.2){.pilcrow}
    :::

3.  ::: {#section-3.4.1-2.3}
    > The RTCP sender and receiver reports (see Section 6.4) can only
    > describe one timing and sequence number space per SSRC and do not
    > carry a payload type field.[¶](#section-3.4.1-2.3.1){.pilcrow}

    This argument is yet another argument against payload type
    multiplexing.[¶](#section-3.4.1-2.3.2){.pilcrow}
    :::

4.  ::: {#section-3.4.1-2.4}
    > An RTP mixer would not be able to combine interleaved streams of
    > incompatible media into one
    > stream.[¶](#section-3.4.1-2.4.1){.pilcrow}

    This argument advocates against multiplexing RTP packets that
    require different handling into the same session. In most cases, the
    RTP mixer must embed application logic to handle streams; the
    separation of streams according to stream type is just another piece
    of application logic, which might or might not be appropriate for a
    particular application. One type of application that can mix
    different media sources blindly is the audio-only telephone bridge,
    although the ability to do that comes from the well-defined scenario
    that is aided by the use of a single media type, even though
    individual streams may use incompatible codec types; most other
    types of applications need application-specific logic to perform the
    mix correctly.[¶](#section-3.4.1-2.4.2){.pilcrow}
    :::

5.  ::: {#section-3.4.1-2.5}
    > Carrying multiple media in one RTP session precludes: the use of
    > different network paths or network resource allocations if
    > appropriate; reception of a subset of the media if desired, for
    > example just audio if video would exceed the available bandwidth;
    > and receiver implementations that use separate processes for the
    > different media, whereas using separate RTP sessions permits
    > either single- or multiple-process
    > implementations.[¶](#section-3.4.1-2.5.1.1){.pilcrow}

    This argument discusses network aspects that are described in
    [Section 4.2](#sect-4.2){.xref}. It also goes into aspects of
    implementation, like split component terminals (see [Section
    3.10](https://www.rfc-editor.org/rfc/rfc7667#section-3.10){.relref}
    of \[[RFC7667](#RFC7667){.xref}\]) \-- endpoints where different
    processes or interconnected devices handle different aspects of the
    whole multimedia session.[¶](#section-3.4.1-2.5.2){.pilcrow}
    :::

To summarize, RFC 3550\'s view on multiplexing is to use unique SSRCs
for anything that is its own media/packet stream and use different RTP
sessions for media streams that don\'t share a media type. This document
supports the first point; it is very valid. The latter needs further
discussion, as imposing a single solution on all usages of RTP is
inappropriate. [\"Sending Multiple Types of Media in a Single RTP
Session\"](#RFC8860){.xref} \[[RFC8860](#RFC8860){.xref}\] updates RFC
3550 to allow multiple media types in an RTP session and provides a
detailed analysis of the potential benefits and issues related to having
multiple media types in the same RTP session. Thus,
\[[RFC8860](#RFC8860){.xref}\] provides a wider scope for an RTP session
and considers multiple media types in one RTP session as a possible
choice for the RTP application designer.[¶](#section-3.4.1-3){.pilcrow}
:::
:::

::: {#sect-3.4.2}
::: {#section-3.4.2 .section}
#### [3.4.2.](#section-3.4.2){.section-number .selfRef} [Multiple SSRCs in a Session](#name-multiple-ssrcs-in-a-session){.section-name .selfRef} {#name-multiple-ssrcs-in-a-session}

Using multiple SSRCs at one endpoint in an RTP session requires that
some unclear aspects of the RTP specification be resolved. These items
could potentially lead to some interoperability issues as well as some
potential significant inefficiencies, as further discussed in \"Sending
Multiple RTP Streams in a Single RTP Session\"
\[[RFC8108](#RFC8108){.xref}\]. An RTP application designer should
consider these issues and the application\'s possible impact caused by a
lack of appropriate RTP handling or optimization in the peer
endpoints.[¶](#section-3.4.2-1){.pilcrow}

Using multiple RTP sessions can potentially mitigate application issues
caused by multiple SSRCs in an RTP
session.[¶](#section-3.4.2-2){.pilcrow}
:::
:::

::: {#sect-3.4.3}
::: {#section-3.4.3 .section}
#### [3.4.3.](#section-3.4.3){.section-number .selfRef} [Binding Related Sources](#name-binding-related-sources){.section-name .selfRef} {#name-binding-related-sources}

A common problem in a number of various RTP extensions has been how to
bind related RTP streams together. This issue is common to both using
additional SSRCs and multiple RTP
sessions.[¶](#section-3.4.3-1){.pilcrow}

The solutions can be divided into a few
groups:[¶](#section-3.4.3-2){.pilcrow}

-   [RTP/RTCP
    based[¶](#section-3.4.3-3.1){.pilcrow}]{#section-3.4.3-3.1}
-   [Signaling based, e.g.,
    SDP[¶](#section-3.4.3-3.2){.pilcrow}]{#section-3.4.3-3.2}
-   [Grouping related RTP
    sessions[¶](#section-3.4.3-3.3){.pilcrow}]{#section-3.4.3-3.3}
-   [Grouping SSRCs within an RTP
    session[¶](#section-3.4.3-3.4){.pilcrow}]{#section-3.4.3-3.4}

Most solutions are explicit, but some implicit methods have also been
applied to the problem.[¶](#section-3.4.3-4){.pilcrow}

The SDP-based signaling solutions are:[¶](#section-3.4.3-5){.pilcrow}

[]{.break}

SDP media description grouping:
:   The SDP grouping framework \[[RFC5888](#RFC5888){.xref}\] uses
    various semantics to group any number of media descriptions. SDP
    media description grouping has primarily been used to group RTP
    sessions, but in combination with \[[RFC8843](#RFC8843){.xref}\], it
    can also group multiple media descriptions within a single RTP
    session.[¶](#section-3.4.3-6.2){.pilcrow}
:   

SDP media multiplexing:
:   [\"Negotiating Media Multiplexing Using the Session Description
    Protocol (SDP)\"](#RFC8843){.xref} \[[RFC8843](#RFC8843){.xref}\]
    uses information taken from both SDP and RTCP to associate RTP
    streams to SDP media descriptions. This allows both SDP and RTCP to
    group RTP streams belonging to an SDP media description and group
    multiple SDP media descriptions into a single RTP
    session.[¶](#section-3.4.3-6.4){.pilcrow}
:   

SDP SSRC grouping:
:   [\"Source-Specific Media Attributes in the Session Description
    Protocol (SDP)\"](#RFC5576){.xref} \[[RFC5576](#RFC5576){.xref}\]
    includes a solution for grouping SSRCs in the same way that the
    grouping framework groups media
    descriptions.[¶](#section-3.4.3-6.6){.pilcrow}
:   

The above grouping constructs support many use cases. Those solutions
have shortcomings in cases where the session\'s dynamic properties are
such that it is difficult or a drain on resources to keep the list of
related SSRCs up to date.[¶](#section-3.4.3-7){.pilcrow}

One RTP/RTCP-based grouping solution is to use the RTCP SDES CNAME to
bind related RTP streams to an endpoint or a synchronization context.
For applications with a single RTP stream per type (media, source, or
redundancy stream), the CNAME is sufficient for that purpose,
independent of whether one or more RTP sessions are used. However, some
applications choose not to use a CNAME because of perceived complexity
or a desire not to implement RTCP and instead use the same SSRC value to
bind related RTP streams across multiple RTP sessions. RTP
retransmission \[[RFC4588](#RFC4588){.xref}\], when configured to use
multiple RTP sessions, and generic FEC \[[RFC5109](#RFC5109){.xref}\]
both use the CNAME method to relate the RTP streams, which may work but
might have some downsides in RTP sessions with many participating SSRCs.
It is not recommended to use identical SSRC values across RTP sessions
to relate RTP streams; when an SSRC collision occurs, this will force a
change of that SSRC in all RTP sessions and will thus resynchronize all
of the streams instead of only the single media stream experiencing the
collision.[¶](#section-3.4.3-8){.pilcrow}

Another method for implicitly binding SSRCs is used by RTP
retransmission \[[RFC4588](#RFC4588){.xref}\] when using the same RTP
session as the source RTP stream for retransmissions. A receiver that is
missing a packet issues an RTP retransmission request and then awaits a
new SSRC carrying the RTP retransmission payload, where that SSRC is
from the same CNAME. This limits a requester to having only one
outstanding retransmission request on any new SSRCs per
endpoint.[¶](#section-3.4.3-9){.pilcrow}

[\"RTP Payload Format Restrictions\"](#RFC8851){.xref}
\[[RFC8851](#RFC8851){.xref}\] provides an RTP/RTCP-based mechanism to
unambiguously identify the RTP streams within an RTP session and
restrict the streams\' payload format parameters in a codec-agnostic way
beyond what is provided with the regular payload types. The mapping is
done by specifying an \"a=rid\" value in the SDP offer/answer signaling
and having the corresponding RtpStreamId value as an SDES item and an
RTP header extension \[[RFC8852](#RFC8852){.xref}\]. The RID solution
also includes a solution for binding redundancy RTP streams to their
original source RTP streams, given that those streams use RID
identifiers. The redundancy stream uses the RepairedRtpStreamId SDES
item and RTP header extension to declare the RtpStreamId value of the
source stream to create the binding.[¶](#section-3.4.3-10){.pilcrow}

Experience has shown that an explicit binding between the RTP streams,
agnostic of SSRC values, behaves well. That way, solutions using
multiple RTP streams in a single RTP session and in multiple RTP
sessions will use the same type of
binding.[¶](#section-3.4.3-11){.pilcrow}
:::
:::

::: {#sect-3.4.4}
::: {#section-3.4.4 .section}
#### [3.4.4.](#section-3.4.4){.section-number .selfRef} [Forward Error Correction](#name-forward-error-correction){.section-name .selfRef} {#name-forward-error-correction}

There exist a number of FEC-based schemes designed to mitigate packet
loss in the original streams. Most of the FEC schemes protect a single
source flow. This protection is achieved by transmitting a certain
amount of redundant information that is encoded such that it can repair
one or more instances of packet loss over the set of packets the
redundant information protects. This sequence of redundant information
needs to be transmitted as its own media stream or, in some cases,
instead of the original media stream. Thus, many of these schemes create
a need for binding related flows, as discussed above. Looking at the
history of these schemes, there are schemes using multiple SSRCs and
schemes using multiple RTP sessions, and some schemes that support both
modes of operation.[¶](#section-3.4.4-1){.pilcrow}

Using multiple RTP sessions supports the case where some set of
receivers might not be able to utilize the FEC information. By placing
it in a separate RTP session and if separating RTP sessions at the
transport level, FEC can easily be ignored at the transport level,
without considering any RTP-layer
information.[¶](#section-3.4.4-2){.pilcrow}

In usages involving multicast, sending FEC information in a separate
multicast group allows for similar flexibility. This is especially
useful when receivers see heterogeneous packet loss rates. A receiver
can decide, based on measurement of experienced packet loss rates,
whether to join a multicast group with suitable FEC data repair
capabilities.[¶](#section-3.4.4-3){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#sect-4}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Considerations for RTP Multiplexing](#name-considerations-for-rtp-mult){.section-name .selfRef} {#name-considerations-for-rtp-mult}

::: {#sect-4.1}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Interworking Considerations](#name-interworking-considerations){.section-name .selfRef} {#name-interworking-considerations}

There are several different kinds of interworking, and this section
discusses two: interworking directly between different applications and
the interworking of applications through an RTP translator. The
discussion includes the implications of potentially different RTP
multiplexing point choices and limitations that have to be considered
when working with some legacy applications.[¶](#section-4.1-1){.pilcrow}

::: {#sect-4.1.1}
::: {#section-4.1.1 .section}
#### [4.1.1.](#section-4.1.1){.section-number .selfRef} [Application Interworking](#name-application-interworking){.section-name .selfRef} {#name-application-interworking}

It is not uncommon that applications or services of similar but not
identical usage, especially those intended for interactive
communication, encounter a situation where one wants to interconnect two
or more of these applications.[¶](#section-4.1.1-1){.pilcrow}

In these cases, one ends up in a situation where one might use a gateway
to interconnect applications. This gateway must then either change the
multiplexing structure or adhere to the respective limitations in each
application.[¶](#section-4.1.1-2){.pilcrow}

There are two fundamental approaches to building a gateway: using RTP
translator interworking (RTP bridging), where the gateway acts as an RTP
translator with the two interconnected applications being members of the
same RTP session; or using gateway interworking ([Section
4.1.3](#sect-4.1.3){.xref}) with RTP termination, where there are
independent RTP sessions between each interconnected application and the
gateway.[¶](#section-4.1.1-3){.pilcrow}

For interworking to be feasible, any security solution in use needs to
be compatible and capable of exchanging keys with either the peer or the
gateway under the trust model being used. Secondly, the applications
need to use media streams in a way that makes sense in both
applications.[¶](#section-4.1.1-4){.pilcrow}
:::
:::

::: {#sect-4.1.2}
::: {#section-4.1.2 .section}
#### [4.1.2.](#section-4.1.2){.section-number .selfRef} [RTP Translator Interworking](#name-rtp-translator-interworking){.section-name .selfRef} {#name-rtp-translator-interworking}

From an RTP perspective, the RTP translator approach could work if all
the applications are using the same codecs with the same payload types,
have made the same multiplexing choices, and have the same capabilities
regarding the number of simultaneous RTP streams combined with the same
set of RTP/RTCP extensions being supported. Unfortunately, this might
not always be true.[¶](#section-4.1.2-1){.pilcrow}

When a gateway is implemented via an RTP translator, an important
consideration is if the two applications being interconnected need to
use the same approach to multiplexing. If one side is using RTP session
multiplexing and the other is using SSRC multiplexing with BUNDLE
\[[RFC8843](#RFC8843){.xref}\], it may be possible for the RTP
translator to map the RTP streams between both sides using some method,
e.g., based on the number and order of SDP \"m=\" lines from each side.
There are also challenges related to SSRC collision handling, since,
unless SSRC translation is applied on the RTP translator, there may be a
collision on the SSRC multiplexing side that the RTP session
multiplexing side will not be aware of. Furthermore, if one of the
applications is capable of working in several modes (such as being able
to use additional RTP streams in one RTP session or multiple RTP
sessions at will) and the other one is not, successful interconnection
depends on locking the more flexible application into the operating mode
where interconnection can be successful, even if none of the
participants are using the less flexible application when the RTP
sessions are being created.[¶](#section-4.1.2-2){.pilcrow}
:::
:::

::: {#sect-4.1.3}
::: {#section-4.1.3 .section}
#### [4.1.3.](#section-4.1.3){.section-number .selfRef} [Gateway Interworking](#name-gateway-interworking){.section-name .selfRef} {#name-gateway-interworking}

When one terminates RTP sessions at the gateway, there are certain tasks
that the gateway has to carry out:[¶](#section-4.1.3-1){.pilcrow}

-   [Generating appropriate RTCP reports for all RTP streams (possibly
    based on incoming RTCP reports) originating from SSRCs controlled by
    the gateway.[¶](#section-4.1.3-2.1){.pilcrow}]{#section-4.1.3-2.1}
-   [Handling SSRC collision resolution in each application\'s RTP
    sessions.[¶](#section-4.1.3-2.2){.pilcrow}]{#section-4.1.3-2.2}
-   [Signaling, choosing, and policing appropriate bitrates for each
    session.[¶](#section-4.1.3-2.3){.pilcrow}]{#section-4.1.3-2.3}

For applications that use any security mechanism, e.g., in the form of
SRTP, the gateway needs to be able to decrypt and verify source
integrity of the incoming packets and then re-encrypt, integrity
protect, and sign the packets as the peer in the other application\'s
security context. This is necessary even if all that\'s needed is a
simple remapping of SSRC numbers. If this is done, the gateway also
needs to be a member of the security contexts of both sides and thus a
trusted entity.[¶](#section-4.1.3-3){.pilcrow}

The gateway might also need to apply transcoding (for incompatible codec
types), media-level adaptations that cannot be solved through media
negotiation (such as rescaling for incompatible video size
requirements), suppression of content that is known not to be handled in
the destination application, or the addition or removal of redundancy
coding or scalability layers to fit the needs of the destination
domain.[¶](#section-4.1.3-4){.pilcrow}

From the above, we can see that the gateway needs to have an intimate
knowledge of the application requirements; a gateway is by its nature
application specific and not a commodity
product.[¶](#section-4.1.3-5){.pilcrow}

These gateways might therefore potentially block application evolution
by blocking RTP and RTCP extensions that the applications have been
extended with but that are unknown to the
gateway.[¶](#section-4.1.3-6){.pilcrow}

If one uses a security mechanism like SRTP, the gateway and the
necessary trust in it by the peers pose an additional risk to
communication security. The gateway also incurs additional complexities
in the form of the decrypt-encrypt cycles needed for each forwarded
packet. SRTP, due to its keying structure, also requires that each RTP
session need different master keys, as the use of the same key in two
RTP sessions can, for some ciphers, result in a reuse of a one-time pad
that completely breaks the confidentiality of the
packets.[¶](#section-4.1.3-7){.pilcrow}
:::
:::

::: {#sect-4.1.4}
::: {#section-4.1.4 .section}
#### [4.1.4.](#section-4.1.4){.section-number .selfRef} [Legacy Considerations for Multiple SSRCs](#name-legacy-considerations-for-m){.section-name .selfRef} {#name-legacy-considerations-for-m}

Historically, the most common RTP use cases have been point-to-point
Voice over IP (VoIP) or streaming applications, commonly with no more
than one media source per endpoint and media type (typically audio or
video). Even in conferencing applications, especially voice-only, the
conference focus or bridge provides to each participant a single stream
containing a mix of the other participants. It is also common to have
individual RTP sessions between each endpoint and the RTP mixer, meaning
that the mixer functions as an RTP-terminating
gateway.[¶](#section-4.1.4-1){.pilcrow}

Applications and systems that aren\'t updated to handle multiple streams
following these recommendations can have issues with participating in
RTP sessions containing multiple SSRCs within a single session, such
as:[¶](#section-4.1.4-2){.pilcrow}

1.  [The need to handle more than one stream simultaneously rather than
    replacing an already-existing stream with a new
    one.[¶](#section-4.1.4-3.1){.pilcrow}]{#section-4.1.4-3.1}
2.  [Being capable of decoding multiple streams
    simultaneously.[¶](#section-4.1.4-3.2){.pilcrow}]{#section-4.1.4-3.2}
3.  [Being capable of rendering multiple streams
    simultaneously.[¶](#section-4.1.4-3.3){.pilcrow}]{#section-4.1.4-3.3}

This indicates that gateways attempting to interconnect to this class of
devices have to make sure that only one RTP stream of each media type
gets delivered to the endpoint if it\'s expecting only one and that the
multiplexing format is what the device expects. It is highly unlikely
that RTP translator-based interworking can be made to function
successfully in such a context.[¶](#section-4.1.4-4){.pilcrow}
:::
:::
:::
:::

::: {#sect-4.2}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Network Considerations](#name-network-considerations){.section-name .selfRef} {#name-network-considerations}

The RTP implementer needs to consider that the RTP multiplexing choice
also impacts network-level mechanisms.[¶](#section-4.2-1){.pilcrow}

::: {#sect-4.2.1}
::: {#section-4.2.1 .section}
#### [4.2.1.](#section-4.2.1){.section-number .selfRef} [Quality of Service](#name-quality-of-service){.section-name .selfRef} {#name-quality-of-service}

QoS mechanisms are either flow based or packet marking based. RSVP
\[[RFC2205](#RFC2205){.xref}\] is an example of a flow-based mechanism,
while Diffserv \[[RFC2474](#RFC2474){.xref}\] is an example of a
packet-marking-based mechanism.[¶](#section-4.2.1-1){.pilcrow}

For a flow-based scheme, additional SSRCs will receive the same QoS as
all other RTP streams being part of the same 5-tuple (protocol, source
address, destination address, source port, destination port), which is
the most common selector for flow-based
QoS.[¶](#section-4.2.1-2){.pilcrow}

For a packet-marking-based scheme, the method of multiplexing will not
affect the possibility of using QoS. Different Differentiated Services
Code Points (DSCPs) can be assigned to different packets within a
transport flow (5-tuple) as well as within an RTP stream, assuming the
usage of UDP or other transport protocols that do not have issues with
packet reordering within the transport flow (5-tuple). To avoid
packet-reordering issues, packets belonging to the same RTP flow should
limit their use of DSCPs to packets whose corresponding Per-Hop Behavior
(PHB) do not enable reordering. If the transport protocol being used
assumes in‑order delivery of packets (e.g., TCP and the Stream Control
Transmission Protocol (SCTP)), then a single DSCP should be used. For
more discussion on this topic, see
\[[RFC7657](#RFC7657){.xref}\].[¶](#section-4.2.1-3){.pilcrow}

The method for assigning marking to packets can impact what number of
RTP sessions to choose. If this marking is done using a network ingress
function, it can have issues discriminating the different RTP streams.
The network API on the endpoint also needs to be capable of setting the
marking on a per-packet basis to reach full
functionality.[¶](#section-4.2.1-4){.pilcrow}
:::
:::

::: {#sect-4.2.2}
::: {#section-4.2.2 .section}
#### [4.2.2.](#section-4.2.2){.section-number .selfRef} [NAT and Firewall Traversal](#name-nat-and-firewall-traversal){.section-name .selfRef} {#name-nat-and-firewall-traversal}

In today\'s networks, there exist a large number of middleboxes. Those
that normally have the most impact on RTP are Network Address
Translators (NATs) and Firewalls (FWs).[¶](#section-4.2.2-1){.pilcrow}

Below, we analyze and comment on the impact of requiring more underlying
transport flows in the presence of NATs and
FWs:[¶](#section-4.2.2-2){.pilcrow}

[]{.break}

Endpoint Port Consumption:
:   A given IP address only has 65536 available local ports per
    transport protocol for all consumers of ports that exist on the
    machine. This is normally never an issue for an end-user machine. It
    can become an issue for servers that handle a large number of
    simultaneous streams. However, if the application uses ICE to
    authenticate STUN requests, a server can serve multiple endpoints
    from the same local port and use the whole 5-tuple (source and
    destination address, source and destination port, protocol) as the
    identifier of flows after having securely bound them to the remote
    endpoint address using the STUN request. In theory, the minimum
    number of media server ports needed is the maximum number of
    simultaneous RTP sessions a single endpoint can use. In practice,
    implementations will probably benefit from using more server ports
    to simplify implementation or avoid performance
    bottlenecks.[¶](#section-4.2.2-3.2){.pilcrow}
:   

NAT State:
:   If an endpoint sits behind a NAT, each flow it generates to an
    external address will result in a state that has to be kept in the
    NAT. That state is a limited resource. In home or Small Office⁠/Home
    Office (SOHO) NATs, the most limited resource is memory or
    processing. For large-scale NATs serving many internal endpoints,
    available external ports are likely the scarce resource. Port
    limitations are primarily a problem for larger centralized NATs
    where endpoint-independent mapping requires each flow to use one
    port for the external IP address. This affects the maximum number of
    internal users per external IP address. However, as a comparison, a
    real-time video conference session with audio and video likely uses
    less than 10 UDP flows, compared to certain web applications that
    can use 100+ TCP flows to various servers from a single browser
    instance.[¶](#section-4.2.2-3.4){.pilcrow}
:   

Extra Delay Added by NAT Traversal:
:   Performing the NAT/FW traversal takes a certain amount of time for
    each flow. The best-case scenario for additional NAT/FW traversal
    time after finding the first valid candidate pair following the
    specified ICE procedures is 1.5\*RTT + Ta\*(Additional_Flows-1),
    where Ta is the pacing timer. That assumes a message in one
    direction, immediately followed by a return message in the opposite
    direction to confirm reachability. It isn\'t more, because ICE first
    finds one candidate pair that works, prior to attempting to
    establish multiple flows. Thus, there is no extra time until one has
    found a working candidate pair. Based on that working pair, the
    extra time is needed to establish the additional flows (two or
    three, in most cases) in parallel. However, packet loss causes extra
    delays of at least 500 ms (the minimal retransmission timer for
    ICE).[¶](#section-4.2.2-3.6){.pilcrow}
:   

NAT Traversal Failure Rate:
:   Due to the need to establish more than a single flow through the
    NAT, there is some risk that establishing the first flow will
    succeed but one or more of the additional flows will fail. The risk
    of this happening is hard to quantify but should be fairly low, as
    one flow from the same interfaces has just been successfully
    established. Thus, only such rare events as NAT resource overload,
    selecting particular port numbers that are filtered, etc., ought to
    be reasons for failure.[¶](#section-4.2.2-3.8){.pilcrow}
:   

Deep Packet Inspection and Multiple Streams:
:   FWs differ in how deeply they inspect packets. Previous experience
    using FWs and Session Border Gateways (SBGs) with RTP shows that
    there is a significant risk that the FWs and SBGs will reject RTP
    sessions that use multiple SSRCs.[¶](#section-4.2.2-3.10){.pilcrow}
:   

Using additional RTP streams in the same RTP session and transport flow
does not introduce any additional NAT traversal complexities per RTP
stream. This can be compared with (normally) one or two additional
transport flows per RTP session when using multiple RTP sessions.
Additional lower-layer transport flows will be needed, unless an
explicit demultiplexing layer is added between RTP and the transport
protocol. At the time of this writing, no such mechanism was
defined.[¶](#section-4.2.2-4){.pilcrow}
:::
:::

::: {#sect-4.2.3}
::: {#section-4.2.3 .section}
#### [4.2.3.](#section-4.2.3){.section-number .selfRef} [Multicast](#name-multicast){.section-name .selfRef} {#name-multicast}

Multicast groups provide a powerful tool for a number of real-time
applications, especially those that desire broadcast-like behaviors with
one endpoint transmitting to a large number of receivers, like in IPTV.
An RTP/RTCP extension to better support Source-Specific Multicast (SSM)
\[[RFC5760](#RFC5760){.xref}\] is also available. Many-to-many
communication, which RTP \[[RFC3550](#RFC3550){.xref}\] was originally
built to support, has several limitations in common with
multicast.[¶](#section-4.2.3-1){.pilcrow}

One limitation is that, for any group, sender-side adaptations with the
intent to suit all receivers would have to adapt to the most limited
receiver experiencing the worst conditions among the group participants,
which imposes degradation for all participants. For broadcast-type
applications with a large number of receivers, this is not acceptable.
Instead, various receiver-based solutions are employed to ensure that
the receivers achieve the best possible performance. By using scalable
encoding and placing each scalability layer in a different multicast
group, the receiver can control the amount of traffic it receives. To
have each scalability layer in a different multicast group, one RTP
session per multicast group is used.[¶](#section-4.2.3-2){.pilcrow}

In addition, the transport flow considerations in multicast are a bit
different from unicast; NATs with port translation are not useful in the
multicast environment, meaning that the entire port range of each
multicast address is available for distinguishing between RTP
sessions.[¶](#section-4.2.3-3){.pilcrow}

Thus, when using broadcast applications it appears easiest and most
straightforward to use multiple RTP sessions for sending different media
flows used for adapting to network conditions. It is also common that
streams improving transport robustness are sent in their own multicast
group to allow for interworking with legacy applications or to support
different levels of protection.[¶](#section-4.2.3-4){.pilcrow}

Many-to-many applications have different needs, and the most appropriate
multiplexing choice will depend on how the actual application is
realized. Multicast applications that are capable of using sender-side
congestion control can avoid the use of multiple multicast sessions and
RTP sessions that result from the use of receiver-side congestion
control.[¶](#section-4.2.3-5){.pilcrow}

The properties of a broadcast application using RTP multicast are as
follows:[¶](#section-4.2.3-6){.pilcrow}

1.  [The application uses a group of RTP sessions \-- not just one. Each
    endpoint will need to be a member of a number of RTP sessions in
    order to perform
    well.[¶](#section-4.2.3-7.1){.pilcrow}]{#section-4.2.3-7.1}
2.  [Within each RTP session, the number of RTP receivers is likely to
    be much larger than the number of RTP
    senders.[¶](#section-4.2.3-7.2){.pilcrow}]{#section-4.2.3-7.2}
3.  [The application needs signaling functions to identify the
    relationships between RTP
    sessions.[¶](#section-4.2.3-7.3){.pilcrow}]{#section-4.2.3-7.3}
4.  [The application needs signaling or RTP/RTCP functions to identify
    the relationships between SSRCs in different RTP sessions when more
    complex relations than those that can be expressed by the CNAME
    exist.[¶](#section-4.2.3-7.4){.pilcrow}]{#section-4.2.3-7.4}

Both broadcast and many-to-many multicast applications share a signaling
requirement; all of the participants need the same RTP and payload type
configuration. Otherwise, A could, for example, be using payload type 97
as the video codec H.264 while B thinks it is MPEG-2. SDP offer/answer
\[[RFC3264](#RFC3264){.xref}\] is not appropriate for ensuring this
property in a broadcast/multicast context. The signaling aspects of
broadcast/multicast are not explored further in this
memo.[¶](#section-4.2.3-8){.pilcrow}

Security solutions for this type of group communication are also
challenging. First, the key-management mechanism and the security
protocol need to support group communication. Second, source
authentication requires special solutions. For more discussion on this
topic, please review [\"Options for Securing RTP
Sessions\"](#RFC7201){.xref}
\[[RFC7201](#RFC7201){.xref}\].[¶](#section-4.2.3-9){.pilcrow}
:::
:::
:::
:::

::: {#sect-4.3}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Security and Key-Management Considerations](#name-security-and-key-management){.section-name .selfRef} {#name-security-and-key-management}

When dealing with point-to-point two-member RTP sessions only, there are
few security issues that are relevant to the choice of having one RTP
session or multiple RTP sessions. However, there are a few aspects of
multi-party sessions that might warrant consideration. For general
information regarding possible methods of securing RTP, please review
\[[RFC7201](#RFC7201){.xref}\].[¶](#section-4.3-1){.pilcrow}

::: {#sect-4.3.1}
::: {#section-4.3.1 .section}
#### [4.3.1.](#section-4.3.1){.section-number .selfRef} [Security Context Scope](#name-security-context-scope){.section-name .selfRef} {#name-security-context-scope}

When using SRTP \[[RFC3711](#RFC3711){.xref}\], the security context
scope is important and can be a necessary differentiation in some
applications. As SRTP\'s crypto suites are (so far) built around
symmetric keys, the receiver will need to have the same key as the
sender. As a result, no one in a multi-party session can be certain that
a received packet was really sent by the claimed sender and not by
another party having access to the key. The single SRTP algorithm not
having this property is Timed Efficient Stream Loss-Tolerant
Authentication (TESLA) source authentication
\[[RFC4383](#RFC4383){.xref}\]. However, TESLA adds delay to achieve
source authentication. In most cases, symmetric ciphers provide
sufficient security properties, but in a few cases they can create
issues.[¶](#section-4.3.1-1){.pilcrow}

The first case is when someone leaves a multi-party session and one
wants to ensure that the party that left can no longer access the RTP
streams. This requires that everyone rekey without disclosing the new
keys to the excluded party.[¶](#section-4.3.1-2){.pilcrow}

A second case is when security is used as an enforcing mechanism for
stream access differentiation between different receivers. Take, for
example, a scalable layer or a high-quality simulcast version that only
users paying a premium are allowed to access. The mechanism preventing a
receiver from getting the high-quality stream can be based on the stream
being encrypted with a key that users can\'t access without paying a
premium, using the key-management mechanism to limit access to the
key.[¶](#section-4.3.1-3){.pilcrow}

As specified in \[[RFC3711](#RFC3711){.xref}\], SRTP uses unique keys
per SSRC; however, the original assumption was a single-session master
key from which SSRC-specific RTP and RTCP keys were derived. However,
that assumption was proven incorrect, as the application usage and the
developed key-management mechanisms have chosen many different methods
for ensuring unique keys per SSRC. The key-management functions have
different abilities to establish different sets of keys, normally on a
per-endpoint basis. For example, DTLS-SRTP
\[[RFC5764](#RFC5764){.xref}\] and Security Descriptions
\[[RFC4568](#RFC4568){.xref}\] establish different keys for outgoing and
incoming traffic from an endpoint. This key usage has to be written into
the cryptographic context, possibly associated with different SSRCs.
Thus, limitations do exist, depending on the chosen key-management
method and due to the integration of particular implementations of the
key-management method and SRTP.[¶](#section-4.3.1-4){.pilcrow}
:::
:::

::: {#sect-4.3.2}
::: {#section-4.3.2 .section}
#### [4.3.2.](#section-4.3.2){.section-number .selfRef} [Key Management for Multi-party Sessions](#name-key-management-for-multi-pa){.section-name .selfRef} {#name-key-management-for-multi-pa}

The capabilities of the key-management method combined with the RTP
multiplexing choices affect the resulting security properties, control
over the secured media, and who has access to
it.[¶](#section-4.3.2-1){.pilcrow}

Multi-party sessions contain at least one RTP stream from each active
participant. Depending on the multi-party topology
\[[RFC7667](#RFC7667){.xref}\], each participant can both send and
receive multiple RTP streams. Transport translator-based sessions
(Topo-Trn-Translator) and multicast sessions (Topo-ASM) can use neither
Security Descriptions \[[RFC4568](#RFC4568){.xref}\] nor DTLS-SRTP
\[[RFC5764](#RFC5764){.xref}\] without an extension, because each
endpoint provides its own set of keys. In centralized conferences, the
signaling counterpart is a conference server, and the transport
translator is the media-plane unicast counterpart (to which DTLS
messages would be sent). Thus, an extension like Encrypted Key Transport
\[[RFC8870](#RFC8870){.xref}\] or a solution based on Multimedia
Internet KEYing (MIKEY) \[[RFC3830](#RFC3830){.xref}\] that allows for
keying all session participants with the same master key is
needed.[¶](#section-4.3.2-2){.pilcrow}

Privacy-Enhanced RTP Conferencing (PERC) also enables a different trust
model with semi-trusted media-switching RTP middleboxes
\[[RFC8871](#RFC8871){.xref}\].[¶](#section-4.3.2-3){.pilcrow}
:::
:::

::: {#sect-4.3.3}
::: {#section-4.3.3 .section}
#### [4.3.3.](#section-4.3.3){.section-number .selfRef} [Complexity Implications](#name-complexity-implications){.section-name .selfRef} {#name-complexity-implications}

There can be complex interactions between the choice of multiplexing and
topology and the security functions. This becomes especially evident in
RTP topologies having any type of middlebox that processes or modifies
RTP/RTCP packets. While the overhead of an RTP translator or mixer
rewriting an SSRC value in the RTP packet of an unencrypted session is
low, the cost is higher when using cryptographic security functions. For
example, if using SRTP \[[RFC3711](#RFC3711){.xref}\], the actual
security context and exact crypto key are determined by the SSRC field
value. If one changes the SSRC value, the encryption and authentication
must use another key. Thus, changing the SSRC value implies a decryption
using the old SSRC and its security context, followed by an encryption
using the new one.[¶](#section-4.3.3-1){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#sect-5}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [RTP Multiplexing Design Choices](#name-rtp-multiplexing-design-cho){.section-name .selfRef} {#name-rtp-multiplexing-design-cho}

This section discusses how some RTP multiplexing design choices can be
used in applications to achieve certain goals and summarizes the
implications of such choices. The benefits and downsides of each design
are also discussed.[¶](#section-5-1){.pilcrow}

::: {#sect-5.1}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Multiple Media Types in One Session](#name-multiple-media-types-in-one){.section-name .selfRef} {#name-multiple-media-types-in-one}

This design uses a single RTP session for multiple different media
types, like audio and video, and possibly also transport robustness
mechanisms like FEC or retransmission. An endpoint can send zero, one,
or multiple media sources per media type, resulting in a number of RTP
streams of various media types for both source and redundancy
streams.[¶](#section-5.1-1){.pilcrow}

Advantages:[¶](#section-5.1-2){.pilcrow}

1.  ::: {#section-5.1-3.1}
    Only a single RTP session is used, which
    implies:[¶](#section-5.1-3.1.1){.pilcrow}

    -   [Minimal need to keep NAT/FW
        state.[¶](#section-5.1-3.1.2.1){.pilcrow}]{#section-5.1-3.1.2.1}
    -   [Minimal NAT/FW traversal
        cost.[¶](#section-5.1-3.1.2.2){.pilcrow}]{#section-5.1-3.1.2.2}
    -   [Fate-sharing for all media
        flows.[¶](#section-5.1-3.1.2.3){.pilcrow}]{#section-5.1-3.1.2.3}
    -   [Minimal overhead for security association
        establishment.[¶](#section-5.1-3.1.2.4){.pilcrow}]{#section-5.1-3.1.2.4}
    :::

2.  [Dynamic allocation of RTP streams can be handled almost entirely at
    the RTP level. The extent to which this allocation can be kept at
    the RTP level depends on the application\'s needs for an explicit
    indication of stream usage and in how timely a fashion that
    information can be
    signaled.[¶](#section-5.1-3.2){.pilcrow}]{#section-5.1-3.2}

Disadvantages:[¶](#section-5.1-4){.pilcrow}

1.  [It is less suitable for interworking with other applications that
    use individual RTP sessions per media type or multiple sessions for
    a single media type, due to the risk of SSRC collisions and thus a
    potential need for SSRC
    translation.[¶](#section-5.1-5.1){.pilcrow}]{#section-5.1-5.1}
2.  [Negotiation of individual bandwidths for the different media types
    is currently only possible in SDP when using RID
    \[[RFC8851](#RFC8851){.xref}\].[¶](#section-5.1-5.2){.pilcrow}]{#section-5.1-5.2}
3.  [It is not suitable for split component terminals (see [Section
    3.10](https://www.rfc-editor.org/rfc/rfc7667#section-3.10){.relref}
    of
    \[[RFC7667](#RFC7667){.xref}\]).[¶](#section-5.1-5.3){.pilcrow}]{#section-5.1-5.3}
4.  [Flow-based QoS cannot be used to provide separate treatment of RTP
    streams compared to others in the single RTP
    session.[¶](#section-5.1-5.4){.pilcrow}]{#section-5.1-5.4}
5.  [If there is significant asymmetry between the RTP streams\' RTCP
    reporting needs, there are some challenges related to configuration
    and usage to avoid wasting RTCP reporting on the RTP stream that
    does not need such frequent
    reporting.[¶](#section-5.1-5.5){.pilcrow}]{#section-5.1-5.5}
6.  [It is not suitable for applications where some receivers like to
    receive only a subset of the RTP streams, especially if multicast or
    a transport translator is being
    used.[¶](#section-5.1-5.6){.pilcrow}]{#section-5.1-5.6}
7.  [There are some additional concerns regarding legacy implementations
    that do not support the RTP specification fully when it comes to
    handling multiple SSRCs per endpoint, as multiple simultaneous media
    types are sent as separate SSRCs in the same RTP
    session.[¶](#section-5.1-5.7){.pilcrow}]{#section-5.1-5.7}
8.  [If the applications need finer control over which session
    participants are included in different sets of security
    associations, most key-management mechanisms will have difficulties
    establishing such a
    session.[¶](#section-5.1-5.8){.pilcrow}]{#section-5.1-5.8}
:::
:::

::: {#sect-5.2}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Multiple SSRCs of the Same Media Type](#name-multiple-ssrcs-of-the-same-){.section-name .selfRef} {#name-multiple-ssrcs-of-the-same-}

In this design, each RTP session serves only a single media type. The
RTP session can contain multiple RTP streams, from either a single
endpoint or multiple endpoints. This commonly creates a low number of
RTP sessions, typically only one for audio and one for video, with a
corresponding need for two listening ports when using RTP/RTCP
multiplexing
\[[RFC5761](#RFC5761){.xref}\].[¶](#section-5.2-1){.pilcrow}

Advantages:[¶](#section-5.2-2){.pilcrow}

1.  [It works well with split component terminals (see [Section
    3.10](https://www.rfc-editor.org/rfc/rfc7667#section-3.10){.relref}
    of \[[RFC7667](#RFC7667){.xref}\]) where the split is per media
    type.[¶](#section-5.2-3.1){.pilcrow}]{#section-5.2-3.1}
2.  [It enables flow-based QoS with different prioritization levels
    between media
    types.[¶](#section-5.2-3.2){.pilcrow}]{#section-5.2-3.2}
3.  [For applications with dynamic usage of RTP streams (i.e., streams
    are frequently added and removed), having much of the state
    associated with the RTP session rather than per individual SSRC can
    avoid the need for in-session signaling of meta-information about
    each SSRC. In simple cases, this allows for unsignaled RTP streams
    where session-level information and an RTCP SDES item (e.g., CNAME)
    are sufficient. In the more complex cases where more source-specific
    metadata needs to be signaled, the SSRC can be associated with an
    intermediate identifier, e.g., the MID conveyed as an SDES item as
    defined in [Section
    15](https://www.rfc-editor.org/rfc/rfc8843#section-15){.relref} of
    \[[RFC8843](#RFC8843){.xref}\].[¶](#section-5.2-3.3){.pilcrow}]{#section-5.2-3.3}
4.  [The overhead of security association establishment is
    low.[¶](#section-5.2-3.4){.pilcrow}]{#section-5.2-3.4}

Disadvantages:[¶](#section-5.2-4){.pilcrow}

1.  ::: {#section-5.2-5.1}
    A slightly higher number of RTP sessions are needed, compared to
    multiple media types in one session ([Section
    5.1](#sect-5.1){.xref}). This implies the
    following:[¶](#section-5.2-5.1.1){.pilcrow}

    -   [More NAT/FW state is
        needed.[¶](#section-5.2-5.1.2.1){.pilcrow}]{#section-5.2-5.1.2.1}
    -   [The cost of NAT/FW traversal is increased in terms of both
        processing and
        delay.[¶](#section-5.2-5.1.2.2){.pilcrow}]{#section-5.2-5.1.2.2}
    :::

2.  [There is some potential for concern regarding legacy
    implementations that don\'t support the RTP specification fully when
    it comes to handling multiple SSRCs per
    endpoint.[¶](#section-5.2-5.2){.pilcrow}]{#section-5.2-5.2}

3.  [It is not possible to control security associations for sets of RTP
    streams within the same media type with today\'s key-management
    mechanisms, unless these are split into different RTP sessions
    ([Section
    5.3](#sect-5.3){.xref}).[¶](#section-5.2-5.3){.pilcrow}]{#section-5.2-5.3}

For RTP applications where all RTP streams of the same media type share
the same usage, this structure provides efficiency gains in the amount
of network state used and provides more fate-sharing with other media
flows of the same type. At the same time, it still maintains almost all
functionalities for the negotiation signaling of properties per
individual media type and also enables flow-based QoS prioritization
between media types. It handles multi-party sessions well, independently
of multicast or centralized transport distribution, as additional
sources can dynamically enter and leave the
session.[¶](#section-5.2-6){.pilcrow}
:::
:::

::: {#sect-5.3}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Multiple Sessions for One Media Type](#name-multiple-sessions-for-one-m){.section-name .selfRef} {#name-multiple-sessions-for-one-m}

This design goes one step further than the design discussed in [Section
5.2](#sect-5.2){.xref} by also using multiple RTP sessions for a single
media type. The main reason for going in this direction is that the RTP
application needs separation of the RTP streams according to their
usage, such as, for example, scalability over multicast, simulcast, the
need for extended QoS prioritization, or the need for fine-grained
signaling using RTP session-focused signaling
tools.[¶](#section-5.3-1){.pilcrow}

Advantages:[¶](#section-5.3-2){.pilcrow}

1.  [This design is more suitable for multicast usage where receivers
    can individually select which RTP sessions they want to participate
    in, assuming that each RTP session has its own multicast
    group.[¶](#section-5.3-3.1){.pilcrow}]{#section-5.3-3.1}
2.  [When multiple different usages exist, the application can indicate
    its usage of the RTP streams at the RTP session
    level.[¶](#section-5.3-3.2){.pilcrow}]{#section-5.3-3.2}
3.  [There is less need for SSRC-specific explicit signaling for each
    media stream and thus a reduced need for explicit and timely
    signaling when RTP streams are added or
    removed.[¶](#section-5.3-3.3){.pilcrow}]{#section-5.3-3.3}
4.  [It enables detailed QoS prioritization for flow-based
    mechanisms.[¶](#section-5.3-3.4){.pilcrow}]{#section-5.3-3.4}
5.  [It works well with split component terminals (see [Section
    3.10](https://www.rfc-editor.org/rfc/rfc7667#section-3.10){.relref}
    of
    \[[RFC7667](#RFC7667){.xref}\]).[¶](#section-5.3-3.5){.pilcrow}]{#section-5.3-3.5}
6.  [The scope for who is included in a security association can be
    structured around the different RTP sessions, thus enabling such
    functionality with existing key-management
    mechanisms.[¶](#section-5.3-3.6){.pilcrow}]{#section-5.3-3.6}

Disadvantages:[¶](#section-5.3-4){.pilcrow}

1.  [There is an increased amount of session configuration state
    compared to multiple SSRCs of the same media type ([Section
    5.2](#sect-5.2){.xref}), due to the increased amount of RTP
    sessions.[¶](#section-5.3-5.1){.pilcrow}]{#section-5.3-5.1}
2.  [For RTP streams that are part of scalability, simulcast, or
    transport robustness, a method for binding sources across multiple
    RTP sessions is
    needed.[¶](#section-5.3-5.2){.pilcrow}]{#section-5.3-5.2}
3.  [There is some potential for concern regarding legacy
    implementations that don\'t support the RTP specification fully when
    it comes to handling multiple SSRCs per
    endpoint.[¶](#section-5.3-5.3){.pilcrow}]{#section-5.3-5.3}
4.  [The overhead of security association establishment is higher, due
    to the increased number of RTP
    sessions.[¶](#section-5.3-5.4){.pilcrow}]{#section-5.3-5.4}
5.  [If the applications need finer control over which participants in a
    given RTP session are included in different sets of security
    associations, most of today\'s key-management mechanisms will have
    difficulties establishing such a
    session.[¶](#section-5.3-5.5){.pilcrow}]{#section-5.3-5.5}

For more-complex RTP applications that have several different usages for
RTP streams of the same media type or that use scalability or simulcast,
this solution can enable those functions, at the cost of increased
overhead associated with the additional sessions. This type of structure
is suitable for more-advanced applications as well as multicast-based
applications requiring differentiation to different
participants.[¶](#section-5.3-6){.pilcrow}
:::
:::

::: {#sect-5.4}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [Single SSRC per Endpoint](#name-single-ssrc-per-endpoint){.section-name .selfRef} {#name-single-ssrc-per-endpoint}

In this design, each endpoint in a point-to-point session has only a
single SSRC; thus, the RTP session contains only two SSRCs \-- one local
and one remote. This session can be used either unidirectionally (i.e.,
one SSRC sends an RTP stream that is received by the other SSRC) or
bidirectionally (i.e., the two SSRCs both send an RTP stream and receive
the RTP stream sent by the other endpoint). If the application needs
additional media flows between the endpoints, it will have to establish
additional RTP sessions.[¶](#section-5.4-1){.pilcrow}

Advantages:[¶](#section-5.4-2){.pilcrow}

1.  [This design has great potential for interoperability with legacy
    applications, as it will not tax any RTP stack
    implementations.[¶](#section-5.4-3.1){.pilcrow}]{#section-5.4-3.1}
2.  [The signaling system makes it possible to negotiate and describe
    the exact formats and bitrates for each RTP stream, especially using
    today\'s tools in
    SDP.[¶](#section-5.4-3.2){.pilcrow}]{#section-5.4-3.2}
3.  [It is possible to control security associations per RTP stream with
    current key-management functions, since each RTP stream is directly
    related to an RTP session and the most commonly used keying
    mechanisms operate on a per-session
    basis.[¶](#section-5.4-3.3){.pilcrow}]{#section-5.4-3.3}

Disadvantages:[¶](#section-5.4-4){.pilcrow}

1.  [The amount of NAT/FW state grows linearly with the number of RTP
    streams.[¶](#section-5.4-5.1){.pilcrow}]{#section-5.4-5.1}
2.  [NAT/FW traversal increases delay and resource
    consumption.[¶](#section-5.4-5.2){.pilcrow}]{#section-5.4-5.2}
3.  [There are likely more signaling message and signaling processing
    requirements due to the increased amount of session-related
    information.[¶](#section-5.4-5.3){.pilcrow}]{#section-5.4-5.3}
4.  [There is higher potential for a single RTP stream to fail during
    transport between the endpoints, due to the need for a separate
    NAT/FW traversal for every RTP stream, since there is only one
    stream per
    session.[¶](#section-5.4-5.4){.pilcrow}]{#section-5.4-5.4}
5.  [The amount of explicit state for relating RTP streams grows,
    depending on how the application relates RTP
    streams.[¶](#section-5.4-5.5){.pilcrow}]{#section-5.4-5.5}
6.  [Port consumption might become a problem for centralized services,
    where the central node\'s port or 5-tuple filter consumption grows
    rapidly with the number of
    sessions.[¶](#section-5.4-5.6){.pilcrow}]{#section-5.4-5.6}
7.  [For applications where RTP stream usage is highly dynamic, i.e.,
    entities frequently enter and leave sessions, the amount of
    signaling can become high. Issues can also arise from the need for
    timely establishment of additional RTP
    sessions.[¶](#section-5.4-5.7){.pilcrow}]{#section-5.4-5.7}
8.  [If, against the recommendation in \[[RFC3550](#RFC3550){.xref}\],
    the same SSRC value is reused in multiple RTP sessions rather than
    being randomly chosen, interworking with applications that use a
    different multiplexing structure will require SSRC
    translation.[¶](#section-5.4-5.8){.pilcrow}]{#section-5.4-5.8}

RTP applications with a strong need to interwork with legacy RTP
applications can potentially benefit from this structure. However, a
large number of media descriptions in SDP can also run into issues with
existing implementations. For any application needing a larger number of
media flows, the overhead can become very significant. This structure is
also not suitable for non-mixed multi-party sessions, as any given RTP
stream from each participant, although having the same usage in the
application, needs its own RTP session. In addition, the dynamic
behavior that can arise in multi-party applications can tax the
signaling system and make timely media establishment more
difficult.[¶](#section-5.4-6){.pilcrow}
:::
:::

::: {#sect-5.5}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [Summary](#name-summary){.section-name .selfRef} {#name-summary}

Both the \"single SSRC per endpoint\" ([Section 5.4](#sect-5.4){.xref})
and \"multiple media types in one session\" ([Section
5.1](#sect-5.1){.xref}) cases require full explicit signaling of the
media stream relationships. However, they operate on two different
levels, where the first primarily enables session-level binding and the
second needs SSRC-level binding. From another perspective, the two
solutions are the two extremes when it comes to the number of RTP
sessions needed.[¶](#section-5.5-1){.pilcrow}

The two other designs \-- multiple SSRCs of the same media type
([Section 5.2](#sect-5.2){.xref}) and multiple sessions for one media
type ([Section 5.3](#sect-5.3){.xref}) \-- are two examples that
primarily allow for some implicit mapping of the role or usage of the
RTP streams based on which RTP session they appear in. Thus, they
potentially allow for less signaling and, in particular, reduce the need
for real-time signaling in sessions with a dynamically changing number
of RTP streams. They also represent points between the first two designs
when it comes to the amount of RTP sessions established, i.e., they
represent an attempt to balance the amount of RTP sessions with the
functionality the communication session provides at both the network
level and the signaling level.[¶](#section-5.5-2){.pilcrow}
:::
:::
:::
:::

::: {#sect-6}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Guidelines](#name-guidelines){.section-name .selfRef} {#name-guidelines}

This section contains a number of multi-stream guidelines for
implementers, system designers, and specification
writers.[¶](#section-6-1){.pilcrow}

[]{.break}

Do not require the use of the same SSRC value across RTP sessions:
:   As discussed in [Section 3.4.3](#sect-3.4.3){.xref}, there are
    downsides to using the same SSRC in multiple RTP sessions as a
    mechanism to bind related RTP streams together. It is instead
    recommended to use a mechanism to explicitly signal the
    relationship, in either RTP⁠/RTCP or the signaling mechanism used to
    establish the RTP session(s).[¶](#section-6-2.2){.pilcrow}
:   

Use additional RTP streams for additional media sources:
:   In the cases where an RTP endpoint needs to transmit additional RTP
    streams of the same media type in the application, with the same
    processing requirements at the network and RTP layers, it is
    suggested to send them in the same RTP session. For example, in the
    case of a telepresence room where there are three cameras and each
    camera captures two persons sitting at the table, we suggest that
    each camera send its own RTP stream within a single RTP
    session.[¶](#section-6-2.4){.pilcrow}
:   

Use additional RTP sessions for streams with different requirements:
:   When RTP streams have different processing requirements from the
    network or the RTP layer at the endpoints, it is suggested that the
    different types of streams be put in different RTP sessions. This
    includes the case where different participants want different
    subsets of the set of RTP streams.[¶](#section-6-2.6){.pilcrow}
:   

Use grouping when using multiple RTP sessions:
:   When using multiple RTP session solutions, it is suggested to
    explicitly group the involved RTP sessions when needed using a
    signaling mechanism \-- for example, see [\"The Session Description
    Protocol (SDP) Grouping Framework\"](#RFC5888){.xref}
    \[[RFC5888](#RFC5888){.xref}\] \-- using some appropriate grouping
    semantics.[¶](#section-6-2.8){.pilcrow}
:   

Ensure that RTP/RTCP extensions support multiple RTP streams as well as multiple RTP sessions:
:   When defining an RTP or RTCP extension, the creator needs to
    consider if this extension is applicable for use with additional
    SSRCs and multiple RTP sessions. Any extension intended to be
    generic must support both. Extensions that are not as generally
    applicable will have to consider whether interoperability is better
    served by defining a single solution or providing both
    options.[¶](#section-6-2.10){.pilcrow}
:   

Provide adequate extensions for transport support:
:   When defining new RTP/RTCP extensions intended for transport
    support, like the retransmission or FEC mechanisms, they must
    include support for both multiple RTP streams in the same RTP
    session and multiple RTP sessions, such that application developers
    can choose freely from the set of mechanisms without concerning
    themselves with which of the multiplexing choices a particular
    solution supports.[¶](#section-6-2.12){.pilcrow}
:   
:::
:::

::: {#sect-8}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-7-1){.pilcrow}
:::
:::

::: {#sect-9}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

The security considerations discussed in the RTP specification
\[[RFC3550](#RFC3550){.xref}\]; any applicable RTP profile
\[[RFC3551](#RFC3551){.xref}\] \[[RFC4585](#RFC4585){.xref}\]
\[[RFC3711](#RFC3711){.xref}\]; and the extensions for sending multiple
media types in a single RTP session \[[RFC8860](#RFC8860){.xref}\], RID
\[[RFC8851](#RFC8851){.xref}\], BUNDLE \[[RFC8843](#RFC8843){.xref}\],
\[[RFC5760](#RFC5760){.xref}\], and \[[RFC5761](#RFC5761){.xref}\] apply
if selected and thus need to be considered in the
evaluation.[¶](#section-8-1){.pilcrow}

[Section 4.3](#sect-4.3){.xref} discusses the security implications of
choosing multiple SSRCs vs. multiple RTP
sessions.[¶](#section-8-2){.pilcrow}
:::
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC3550\]
:   [Schulzrinne, H.]{.refAuthor}[, Casner, S.]{.refAuthor}[,
    Frederick, R.]{.refAuthor}[, and V. Jacobson]{.refAuthor}, [\"RTP: A
    Transport Protocol for Real-Time Applications\"]{.refTitle}, [STD
    64]{.seriesInfo}, [RFC 3550]{.seriesInfo}, [DOI
    10.17487/RFC3550]{.seriesInfo}, July 2003,
    \<<https://www.rfc-editor.org/info/rfc3550>\>.
:   

\[RFC3551\]
:   [Schulzrinne, H.]{.refAuthor}[ and S. Casner]{.refAuthor}, [\"RTP
    Profile for Audio and Video Conferences with Minimal
    Control\"]{.refTitle}, [STD 65]{.seriesInfo}, [RFC
    3551]{.seriesInfo}, [DOI 10.17487/RFC3551]{.seriesInfo}, July 2003,
    \<<https://www.rfc-editor.org/info/rfc3551>\>.
:   

\[RFC3711\]
:   [Baugher, M.]{.refAuthor}[, McGrew, D.]{.refAuthor}[,
    Naslund, M.]{.refAuthor}[, Carrara, E.]{.refAuthor}[, and K.
    Norrman]{.refAuthor}, [\"The Secure Real-time Transport Protocol
    (SRTP)\"]{.refTitle}, [RFC 3711]{.seriesInfo}, [DOI
    10.17487/RFC3711]{.seriesInfo}, March 2004,
    \<<https://www.rfc-editor.org/info/rfc3711>\>.
:   

\[RFC4585\]
:   [Ott, J.]{.refAuthor}[, Wenger, S.]{.refAuthor}[,
    Sato, N.]{.refAuthor}[, Burmeister, C.]{.refAuthor}[, and J.
    Rey]{.refAuthor}, [\"Extended RTP Profile for Real-time Transport
    Control Protocol (RTCP)-Based Feedback (RTP/AVPF)\"]{.refTitle},
    [RFC 4585]{.seriesInfo}, [DOI 10.17487/RFC4585]{.seriesInfo}, July
    2006, \<<https://www.rfc-editor.org/info/rfc4585>\>.
:   

\[RFC5576\]
:   [Lennox, J.]{.refAuthor}[, Ott, J.]{.refAuthor}[, and T.
    Schierl]{.refAuthor}, [\"Source-Specific Media Attributes in the
    Session Description Protocol (SDP)\"]{.refTitle}, [RFC
    5576]{.seriesInfo}, [DOI 10.17487/RFC5576]{.seriesInfo}, June 2009,
    \<<https://www.rfc-editor.org/info/rfc5576>\>.
:   

\[RFC5760\]
:   [Ott, J.]{.refAuthor}[, Chesterfield, J.]{.refAuthor}[, and E.
    Schooler]{.refAuthor}, [\"RTP Control Protocol (RTCP) Extensions for
    Single-Source Multicast Sessions with Unicast
    Feedback\"]{.refTitle}, [RFC 5760]{.seriesInfo}, [DOI
    10.17487/RFC5760]{.seriesInfo}, February 2010,
    \<<https://www.rfc-editor.org/info/rfc5760>\>.
:   

\[RFC5761\]
:   [Perkins, C.]{.refAuthor}[ and M. Westerlund]{.refAuthor},
    [\"Multiplexing RTP Data and Control Packets on a Single
    Port\"]{.refTitle}, [RFC 5761]{.seriesInfo}, [DOI
    10.17487/RFC5761]{.seriesInfo}, April 2010,
    \<<https://www.rfc-editor.org/info/rfc5761>\>.
:   

\[RFC7656\]
:   [Lennox, J.]{.refAuthor}[, Gross, K.]{.refAuthor}[,
    Nandakumar, S.]{.refAuthor}[, Salgueiro, G.]{.refAuthor}[, and B.
    Burman, Ed.]{.refAuthor}, [\"A Taxonomy of Semantics and Mechanisms
    for Real-Time Transport Protocol (RTP) Sources\"]{.refTitle}, [RFC
    7656]{.seriesInfo}, [DOI 10.17487/RFC7656]{.seriesInfo}, November
    2015, \<<https://www.rfc-editor.org/info/rfc7656>\>.
:   

\[RFC7667\]
:   [Westerlund, M.]{.refAuthor}[ and S. Wenger]{.refAuthor}, [\"RTP
    Topologies\"]{.refTitle}, [RFC 7667]{.seriesInfo}, [DOI
    10.17487/RFC7667]{.seriesInfo}, November 2015,
    \<<https://www.rfc-editor.org/info/rfc7667>\>.
:   

\[RFC8843\]
:   [Holmberg, C.]{.refAuthor}[, Alvestrand, H.]{.refAuthor}[, and C.
    Jennings]{.refAuthor}, [\"Negotiating Media Multiplexing Using the
    Session Description Protocol (SDP)\"]{.refTitle}, [RFC
    8843]{.seriesInfo}, [DOI 10.17487/RFC8843]{.seriesInfo}, January
    2021, \<<https://www.rfc-editor.org/info/rfc8843>\>.
:   

\[RFC8851\]
:   [Roach, A.B., Ed.]{.refAuthor}, [\"RTP Payload Format
    Restrictions\"]{.refTitle}, [RFC 8851]{.seriesInfo}, [DOI
    10.17487/RFC8851]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8851>\>.
:   

\[RFC8852\]
:   [Roach, A.B.]{.refAuthor}[, Nandakumar, S.]{.refAuthor}[, and P.
    Thatcher]{.refAuthor}, [\"RTP Stream Identifier Source Description
    (SDES)\"]{.refTitle}, [RFC 8852]{.seriesInfo}, [DOI
    10.17487/RFC8852]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8852>\>.
:   

\[RFC8860\]
:   [Westerlund, M.]{.refAuthor}[, Perkins, C.]{.refAuthor}[, and J.
    Lennox]{.refAuthor}, [\"Sending Multiple Types of Media in a Single
    RTP Session\"]{.refTitle}, [RFC 8860]{.seriesInfo}, [DOI
    10.17487/RFC8860]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8860>\>.
:   

\[RFC8870\]
:   [Jennings, C.]{.refAuthor}[, Mattsson, J.]{.refAuthor}[,
    McGrew, D.]{.refAuthor}[, Wing, D.]{.refAuthor}[, and F.
    Andreasen]{.refAuthor}, [\"Encrypted Key Transport for DTLS and
    Secure RTP\"]{.refTitle}, [RFC 8870]{.seriesInfo}, [DOI
    10.17487/RFC8870]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8870>\>.
:   
:::

::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[JINGLE\]
:   [Ludwig, S.]{.refAuthor}[, Beda, J.]{.refAuthor}[,
    Saint-Andre, P.]{.refAuthor}[, McQueen, R.]{.refAuthor}[,
    Egan, S.]{.refAuthor}[, and J. Hildebrand]{.refAuthor}, [\"XEP-0166:
    Jingle\"]{.refTitle}, September 2018,
    \<<https://xmpp.org/extensions/xep-0166.html>\>.
:   

\[RFC2198\]
:   [Perkins, C.]{.refAuthor}[, Kouvelas, I.]{.refAuthor}[,
    Hodson, O.]{.refAuthor}[, Hardman, V.]{.refAuthor}[,
    Handley, M.]{.refAuthor}[, Bolot, J.C.]{.refAuthor}[,
    Vega-Garcia, A.]{.refAuthor}[, and S. Fosse-Parisis]{.refAuthor},
    [\"RTP Payload for Redundant Audio Data\"]{.refTitle}, [RFC
    2198]{.seriesInfo}, [DOI 10.17487/RFC2198]{.seriesInfo}, September
    1997, \<<https://www.rfc-editor.org/info/rfc2198>\>.
:   

\[RFC2205\]
:   [Braden, R., Ed.]{.refAuthor}[, Zhang, L.]{.refAuthor}[,
    Berson, S.]{.refAuthor}[, Herzog, S.]{.refAuthor}[, and S.
    Jamin]{.refAuthor}, [\"Resource ReSerVation Protocol (RSVP) \--
    Version 1 Functional Specification\"]{.refTitle}, [RFC
    2205]{.seriesInfo}, [DOI 10.17487/RFC2205]{.seriesInfo}, September
    1997, \<<https://www.rfc-editor.org/info/rfc2205>\>.
:   

\[RFC2474\]
:   [Nichols, K.]{.refAuthor}[, Blake, S.]{.refAuthor}[,
    Baker, F.]{.refAuthor}[, and D. Black]{.refAuthor}, [\"Definition of
    the Differentiated Services Field (DS Field) in the IPv4 and IPv6
    Headers\"]{.refTitle}, [RFC 2474]{.seriesInfo}, [DOI
    10.17487/RFC2474]{.seriesInfo}, December 1998,
    \<<https://www.rfc-editor.org/info/rfc2474>\>.
:   

\[RFC2974\]
:   [Handley, M.]{.refAuthor}[, Perkins, C.]{.refAuthor}[, and E.
    Whelan]{.refAuthor}, [\"Session Announcement Protocol\"]{.refTitle},
    [RFC 2974]{.seriesInfo}, [DOI 10.17487/RFC2974]{.seriesInfo},
    October 2000, \<<https://www.rfc-editor.org/info/rfc2974>\>.
:   

\[RFC3261\]
:   [Rosenberg, J.]{.refAuthor}[, Schulzrinne, H.]{.refAuthor}[,
    Camarillo, G.]{.refAuthor}[, Johnston, A.]{.refAuthor}[,
    Peterson, J.]{.refAuthor}[, Sparks, R.]{.refAuthor}[,
    Handley, M.]{.refAuthor}[, and E. Schooler]{.refAuthor}, [\"SIP:
    Session Initiation Protocol\"]{.refTitle}, [RFC 3261]{.seriesInfo},
    [DOI 10.17487/RFC3261]{.seriesInfo}, June 2002,
    \<<https://www.rfc-editor.org/info/rfc3261>\>.
:   

\[RFC3264\]
:   [Rosenberg, J.]{.refAuthor}[ and H. Schulzrinne]{.refAuthor}, [\"An
    Offer/Answer Model with Session Description Protocol
    (SDP)\"]{.refTitle}, [RFC 3264]{.seriesInfo}, [DOI
    10.17487/RFC3264]{.seriesInfo}, June 2002,
    \<<https://www.rfc-editor.org/info/rfc3264>\>.
:   

\[RFC3389\]
:   [Zopf, R.]{.refAuthor}, [\"Real-time Transport Protocol (RTP)
    Payload for Comfort Noise (CN)\"]{.refTitle}, [RFC
    3389]{.seriesInfo}, [DOI 10.17487/RFC3389]{.seriesInfo}, September
    2002, \<<https://www.rfc-editor.org/info/rfc3389>\>.
:   

\[RFC3830\]
:   [Arkko, J.]{.refAuthor}[, Carrara, E.]{.refAuthor}[,
    Lindholm, F.]{.refAuthor}[, Naslund, M.]{.refAuthor}[, and K.
    Norrman]{.refAuthor}, [\"MIKEY: Multimedia Internet
    KEYing\"]{.refTitle}, [RFC 3830]{.seriesInfo}, [DOI
    10.17487/RFC3830]{.seriesInfo}, August 2004,
    \<<https://www.rfc-editor.org/info/rfc3830>\>.
:   

\[RFC4103\]
:   [Hellstrom, G.]{.refAuthor}[ and P. Jones]{.refAuthor}, [\"RTP
    Payload for Text Conversation\"]{.refTitle}, [RFC
    4103]{.seriesInfo}, [DOI 10.17487/RFC4103]{.seriesInfo}, June 2005,
    \<<https://www.rfc-editor.org/info/rfc4103>\>.
:   

\[RFC4383\]
:   [Baugher, M.]{.refAuthor}[ and E. Carrara]{.refAuthor}, [\"The Use
    of Timed Efficient Stream Loss-Tolerant Authentication (TESLA) in
    the Secure Real-time Transport Protocol (SRTP)\"]{.refTitle}, [RFC
    4383]{.seriesInfo}, [DOI 10.17487/RFC4383]{.seriesInfo}, February
    2006, \<<https://www.rfc-editor.org/info/rfc4383>\>.
:   

\[RFC4566\]
:   [Handley, M.]{.refAuthor}[, Jacobson, V.]{.refAuthor}[, and C.
    Perkins]{.refAuthor}, [\"SDP: Session Description
    Protocol\"]{.refTitle}, [RFC 4566]{.seriesInfo}, [DOI
    10.17487/RFC4566]{.seriesInfo}, July 2006,
    \<<https://www.rfc-editor.org/info/rfc4566>\>.
:   

\[RFC4568\]
:   [Andreasen, F.]{.refAuthor}[, Baugher, M.]{.refAuthor}[, and D.
    Wing]{.refAuthor}, [\"Session Description Protocol (SDP) Security
    Descriptions for Media Streams\"]{.refTitle}, [RFC
    4568]{.seriesInfo}, [DOI 10.17487/RFC4568]{.seriesInfo}, July 2006,
    \<<https://www.rfc-editor.org/info/rfc4568>\>.
:   

\[RFC4588\]
:   [Rey, J.]{.refAuthor}[, Leon, D.]{.refAuthor}[,
    Miyazaki, A.]{.refAuthor}[, Varsa, V.]{.refAuthor}[, and R.
    Hakenberg]{.refAuthor}, [\"RTP Retransmission Payload
    Format\"]{.refTitle}, [RFC 4588]{.seriesInfo}, [DOI
    10.17487/RFC4588]{.seriesInfo}, July 2006,
    \<<https://www.rfc-editor.org/info/rfc4588>\>.
:   

\[RFC5104\]
:   [Wenger, S.]{.refAuthor}[, Chandra, U.]{.refAuthor}[,
    Westerlund, M.]{.refAuthor}[, and B. Burman]{.refAuthor}, [\"Codec
    Control Messages in the RTP Audio-Visual Profile with Feedback
    (AVPF)\"]{.refTitle}, [RFC 5104]{.seriesInfo}, [DOI
    10.17487/RFC5104]{.seriesInfo}, February 2008,
    \<<https://www.rfc-editor.org/info/rfc5104>\>.
:   

\[RFC5109\]
:   [Li, A., Ed.]{.refAuthor}, [\"RTP Payload Format for Generic Forward
    Error Correction\"]{.refTitle}, [RFC 5109]{.seriesInfo}, [DOI
    10.17487/RFC5109]{.seriesInfo}, December 2007,
    \<<https://www.rfc-editor.org/info/rfc5109>\>.
:   

\[RFC5389\]
:   [Rosenberg, J.]{.refAuthor}[, Mahy, R.]{.refAuthor}[,
    Matthews, P.]{.refAuthor}[, and D. Wing]{.refAuthor}, [\"Session
    Traversal Utilities for NAT (STUN)\"]{.refTitle}, [RFC
    5389]{.seriesInfo}, [DOI 10.17487/RFC5389]{.seriesInfo}, October
    2008, \<<https://www.rfc-editor.org/info/rfc5389>\>.
:   

\[RFC5764\]
:   [McGrew, D.]{.refAuthor}[ and E. Rescorla]{.refAuthor}, [\"Datagram
    Transport Layer Security (DTLS) Extension to Establish Keys for the
    Secure Real-time Transport Protocol (SRTP)\"]{.refTitle}, [RFC
    5764]{.seriesInfo}, [DOI 10.17487/RFC5764]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5764>\>.
:   

\[RFC5888\]
:   [Camarillo, G.]{.refAuthor}[ and H. Schulzrinne]{.refAuthor}, [\"The
    Session Description Protocol (SDP) Grouping Framework\"]{.refTitle},
    [RFC 5888]{.seriesInfo}, [DOI 10.17487/RFC5888]{.seriesInfo}, June
    2010, \<<https://www.rfc-editor.org/info/rfc5888>\>.
:   

\[RFC6465\]
:   [Ivov, E., Ed.]{.refAuthor}[, Marocco, E., Ed.]{.refAuthor}[, and J.
    Lennox]{.refAuthor}, [\"A Real-time Transport Protocol (RTP) Header
    Extension for Mixer-to-Client Audio Level Indication\"]{.refTitle},
    [RFC 6465]{.seriesInfo}, [DOI 10.17487/RFC6465]{.seriesInfo},
    December 2011, \<<https://www.rfc-editor.org/info/rfc6465>\>.
:   

\[RFC7201\]
:   [Westerlund, M.]{.refAuthor}[ and C. Perkins]{.refAuthor},
    [\"Options for Securing RTP Sessions\"]{.refTitle}, [RFC
    7201]{.seriesInfo}, [DOI 10.17487/RFC7201]{.seriesInfo}, April 2014,
    \<<https://www.rfc-editor.org/info/rfc7201>\>.
:   

\[RFC7657\]
:   [Black, D., Ed.]{.refAuthor}[ and P. Jones]{.refAuthor},
    [\"Differentiated Services (Diffserv) and Real-Time
    Communication\"]{.refTitle}, [RFC 7657]{.seriesInfo}, [DOI
    10.17487/RFC7657]{.seriesInfo}, November 2015,
    \<<https://www.rfc-editor.org/info/rfc7657>\>.
:   

\[RFC7826\]
:   [Schulzrinne, H.]{.refAuthor}[, Rao, A.]{.refAuthor}[,
    Lanphier, R.]{.refAuthor}[, Westerlund, M.]{.refAuthor}[, and M.
    Stiemerling, Ed.]{.refAuthor}, [\"Real-Time Streaming Protocol
    Version 2.0\"]{.refTitle}, [RFC 7826]{.seriesInfo}, [DOI
    10.17487/RFC7826]{.seriesInfo}, December 2016,
    \<<https://www.rfc-editor.org/info/rfc7826>\>.
:   

\[RFC7983\]
:   [Petit-Huguenin, M.]{.refAuthor}[ and G. Salgueiro]{.refAuthor},
    [\"Multiplexing Scheme Updates for Secure Real-time Transport
    Protocol (SRTP) Extension for Datagram Transport Layer Security
    (DTLS)\"]{.refTitle}, [RFC 7983]{.seriesInfo}, [DOI
    10.17487/RFC7983]{.seriesInfo}, September 2016,
    \<<https://www.rfc-editor.org/info/rfc7983>\>.
:   

\[RFC8088\]
:   [Westerlund, M.]{.refAuthor}, [\"How to Write an RTP Payload
    Format\"]{.refTitle}, [RFC 8088]{.seriesInfo}, [DOI
    10.17487/RFC8088]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8088>\>.
:   

\[RFC8108\]
:   [Lennox, J.]{.refAuthor}[, Westerlund, M.]{.refAuthor}[,
    Wu, Q.]{.refAuthor}[, and C. Perkins]{.refAuthor}, [\"Sending
    Multiple RTP Streams in a Single RTP Session\"]{.refTitle}, [RFC
    8108]{.seriesInfo}, [DOI 10.17487/RFC8108]{.seriesInfo}, March 2017,
    \<<https://www.rfc-editor.org/info/rfc8108>\>.
:   

\[RFC8445\]
:   [Keranen, A.]{.refAuthor}[, Holmberg, C.]{.refAuthor}[, and J.
    Rosenberg]{.refAuthor}, [\"Interactive Connectivity Establishment
    (ICE): A Protocol for Network Address Translator (NAT)
    Traversal\"]{.refTitle}, [RFC 8445]{.seriesInfo}, [DOI
    10.17487/RFC8445]{.seriesInfo}, July 2018,
    \<<https://www.rfc-editor.org/info/rfc8445>\>.
:   

\[RFC8871\]
:   [Jones, P.]{.refAuthor}[, Benham, D.]{.refAuthor}[, and C.
    Groves]{.refAuthor}, [\"A Solution Framework for Private Media in
    Privacy-Enhanced RTP Conferencing (PERC)\"]{.refTitle}, [RFC
    8871]{.seriesInfo}, [DOI 10.17487/RFC8871]{.seriesInfo}, January
    2021, \<<https://www.rfc-editor.org/info/rfc8871>\>.
:   
:::
:::

::: {#sect-a}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Dismissing Payload Type Multiplexing](#name-dismissing-payload-type-mul){.section-name .selfRef} {#name-dismissing-payload-type-mul}

This section documents a number of reasons why using the payload type as
a multiplexing point is unsuitable for most issues related to multiple
RTP streams. Attempting to use payload type multiplexing beyond its
defined usage has well-known negative effects on RTP, as discussed
below. To use the payload type as the single discriminator for multiple
streams implies that all the different RTP streams are being sent with
the same SSRC, thus using the same timestamp and sequence number space.
The many effects of using payload type multiplexing are as
follows:[¶](#section-appendix.a-1){.pilcrow}

1.  [Constraints are placed on the RTP timestamp rate for the
    multiplexed media. For example, RTP streams that use different RTP
    timestamp rates cannot be combined, as the timestamp values need to
    be consistent across all multiplexed media frames. Thus, streams are
    forced to use the same RTP timestamp rate. When this is not
    possible, payload type multiplexing cannot be
    used.[¶](#section-appendix.a-2.1){.pilcrow}]{#section-appendix.a-2.1}
2.  [Many RTP payload formats can fragment a media object over multiple
    RTP packets, like parts of a video frame. These payload formats need
    to determine the order of the fragments to correctly decode them.
    Thus, it is important to ensure that all fragments related to a
    frame or a similar media object are transmitted in sequence and
    without interruptions within the object. This can be done relatively
    easily on the sender side by ensuring that the fragments of each RTP
    stream are sent in
    sequence.[¶](#section-appendix.a-2.2){.pilcrow}]{#section-appendix.a-2.2}
3.  [Some media formats require uninterrupted sequence number space
    between media parts. These are media formats where any missing RTP
    sequence number will result in decoding failure or invoking a repair
    mechanism within a single media context. The text⁠/t140 payload
    format \[[RFC4103](#RFC4103){.xref}\] is an example of such a
    format. These formats will need a sequence numbering abstraction
    function between RTP and the individual RTP stream before being used
    with payload type
    multiplexing.[¶](#section-appendix.a-2.3){.pilcrow}]{#section-appendix.a-2.3}
4.  [Sending multiple media streams in the same sequence number space
    makes it impossible to determine which media stream lost a packet.
    Such a scenario causes difficulties, since the receiver cannot
    determine to which stream it should apply packet-loss concealment or
    other stream-specific loss-mitigation
    mechanisms.[¶](#section-appendix.a-2.4){.pilcrow}]{#section-appendix.a-2.4}
5.  [If RTP retransmission \[[RFC4588](#RFC4588){.xref}\] is used and
    packet loss occurs, it is possible to ask for the missing packet(s)
    by SSRC and sequence number \-- not by payload type. If only some of
    the payload type multiplexed streams are of interest, there is no
    way to tell which missing packet or packets belong to the stream or
    streams of interest, and all lost packets need to be requested,
    wasting
    bandwidth.[¶](#section-appendix.a-2.5){.pilcrow}]{#section-appendix.a-2.5}
6.  [The current RTCP feedback mechanisms are built around providing
    feedback on RTP streams based on stream ID (SSRC), packet (sequence
    numbers), and time interval (RTP timestamps). There is almost never
    a field to indicate which payload type is reported, so sending
    feedback for a specific RTP payload type is difficult without
    extending existing RTCP
    reporting.[¶](#section-appendix.a-2.6){.pilcrow}]{#section-appendix.a-2.6}
7.  [The current RTCP media control messages specification
    \[[RFC5104](#RFC5104){.xref}\] is oriented around controlling
    particular media flows, i.e., requests are done by addressing a
    particular SSRC. Such mechanisms would need to be redefined to
    support payload type
    multiplexing.[¶](#section-appendix.a-2.7){.pilcrow}]{#section-appendix.a-2.7}
8.  [The number of payload types is inherently limited. Accordingly,
    using payload type multiplexing limits the number of streams that
    can be multiplexed and does not scale. This limitation is
    exacerbated if one uses solutions like RTP and RTCP multiplexing
    \[[RFC5761](#RFC5761){.xref}\] where a number of payload types are
    blocked due to the overlap between RTP and
    RTCP.[¶](#section-appendix.a-2.8){.pilcrow}]{#section-appendix.a-2.8}
9.  [At times, there is a need to group multiplexed streams. This is
    currently possible for RTP sessions and SSRCs, but there is no
    defined way to group payload
    types.[¶](#section-appendix.a-2.9){.pilcrow}]{#section-appendix.a-2.9}
10. [It is currently not possible to signal bandwidth requirements per
    RTP stream when using payload type
    multiplexing.[¶](#section-appendix.a-2.10){.pilcrow}]{#section-appendix.a-2.10}
11. [Most existing SDP media-level attributes cannot be applied on a
    per-payload-type basis and would require redefinition in that
    context.[¶](#section-appendix.a-2.11){.pilcrow}]{#section-appendix.a-2.11}
12. [A legacy endpoint that does not understand the indication that
    different RTP payload types are different RTP streams might be
    slightly confused by the large amount of possibly overlapping or
    identically defined RTP payload
    types.[¶](#section-appendix.a-2.12){.pilcrow}]{#section-appendix.a-2.12}
:::
:::

::: {#sect-b}
::: {#section-appendix.b .section}
## [Appendix B.](#section-appendix.b){.section-number .selfRef} [Signaling Considerations](#name-signaling-considerations){.section-name .selfRef} {#name-signaling-considerations}

Signaling is not an architectural consideration for RTP itself, so this
discussion has been moved to an appendix. However, it is extremely
important for anyone building complete applications, so it is deserving
of discussion.[¶](#section-appendix.b-1){.pilcrow}

We document some issues here that need to be addressed when using some
form of signaling to establish RTP sessions. These issues cannot be
addressed by simply tweaking, extending, or profiling RTP; rather, they
require a dedicated and in-depth look at the signaling primitives that
set up the RTP sessions.[¶](#section-appendix.b-2){.pilcrow}

There exist various signaling solutions for establishing RTP sessions.
Many are based on SDP \[[RFC4566](#RFC4566){.xref}\]; however, SDP
functionality is also dependent on the signaling protocols carrying the
SDP. The Real-Time Streaming Protocol (RTSP)
\[[RFC7826](#RFC7826){.xref}\] and the Session Announcement Protocol
(SAP) \[[RFC2974](#RFC2974){.xref}\] both use SDP in a declarative
fashion, while SIP \[[RFC3261](#RFC3261){.xref}\] uses SDP with the
additional definition of offer/answer \[[RFC3264](#RFC3264){.xref}\].
The impact on signaling, and especially on SDP, needs to be considered,
as it can greatly affect how to deploy a certain multiplexing point
choice.[¶](#section-appendix.b-3){.pilcrow}

::: {#sect-b.1}
::: {#section-b.1 .section}
## [B.1.](#section-b.1){.section-number .selfRef} [Session-Oriented Properties](#name-session-oriented-properties){.section-name .selfRef} {#name-session-oriented-properties}

One aspect of existing signaling protocols is that they are focused on
RTP sessions or, in the case of SDP, the concept of media descriptions.
A number of things are signaled at the media description level, but
those are not necessarily strictly bound to an RTP session and could be
of interest for signaling, especially for a particular RTP stream (SSRC)
within the session. The following properties have been identified as
being potentially useful for signaling, and not only at the RTP session
level:[¶](#section-b.1-1){.pilcrow}

-   [Bitrate and/or bandwidth can be specified today only as an
    aggregate limit, or as a common \"any RTP stream\" limit, unless
    either codec-specific bandwidth limiting or RTCP signaling using
    Temporary Maximum Media Stream Bit Rate Request (TMMBR) messages
    \[[RFC5104](#RFC5104){.xref}\] is
    used.[¶](#section-b.1-2.1){.pilcrow}]{#section-b.1-2.1}
-   [Which SSRC will use which RTP payload type (this information will
    be visible in the first media packet but is sometimes useful to have
    before the packet
    arrives).[¶](#section-b.1-2.2){.pilcrow}]{#section-b.1-2.2}

Some of these issues are clearly SDP\'s problem rather than RTP
limitations. However, if the aim is to deploy a solution that uses
several SSRCs and contains several sets of RTP streams with different
properties (encoding/packetization parameters, bitrate, etc.), putting
each set in a different RTP session would directly enable negotiation of
the parameters for each set. If insisting on additional SSRCs only, a
number of signaling extensions are needed to clarify that there are
multiple sets of RTP streams with different properties and that they in
fact need to be kept different, since a single set will not satisfy the
application\'s requirements.[¶](#section-b.1-3){.pilcrow}

For some parameters, such as RTP payload type, resolution, and frame
rate, an SSRC-linked mechanism has been proposed in
\[[RFC8851](#RFC8851){.xref}\].[¶](#section-b.1-4){.pilcrow}
:::
:::

::: {#sect-b.2}
::: {#section-b.2 .section}
## [B.2.](#section-b.2){.section-number .selfRef} [SDP Prevents Multiple Media Types](#name-sdp-prevents-multiple-media){.section-name .selfRef} {#name-sdp-prevents-multiple-media}

SDP uses the \"m=\" line to both delineate an RTP session and specify
the top-level media type: audio, video, text, image, application. This
media type is used as the top-level media type for identifying the
actual payload format and is bound to a particular payload type using
the \"a=rtpmap:\" attribute. This binding has to be loosened in order to
use SDP to describe RTP sessions containing multiple top-level media
types.[¶](#section-b.2-1){.pilcrow}

\[[RFC8843](#RFC8843){.xref}\] describes how to let multiple SDP media
descriptions use a single underlying transport in SDP, which allows the
definition of one RTP session with different top-level media
types.[¶](#section-b.2-2){.pilcrow}
:::
:::

::: {#sect-b.3}
::: {#section-b.3 .section}
## [B.3.](#section-b.3){.section-number .selfRef} [Signaling RTP Stream Usage](#name-signaling-rtp-stream-usage){.section-name .selfRef} {#name-signaling-rtp-stream-usage}

RTP streams being transported in RTP have a particular usage in an RTP
application. In many applications to date, this usage of the RTP stream
is implicitly signaled. For example, an application might choose to take
all incoming audio RTP streams, mix them, and play them out. However, in
more-advanced applications that use multiple RTP streams, there will be
more than a single usage or purpose among the set of RTP streams being
sent or received. RTP applications will need to somehow signal this
usage. The signaling that is used will have to identify the RTP streams
affected by their RTP-level identifiers, which means that they have to
be identified by either their session or their SSRC +
session.[¶](#section-b.3-1){.pilcrow}

In some applications, the receiver cannot utilize the RTP stream at all
before it has received the signaling message describing the RTP stream
and its usage. In other applications, there exists a default handling
method that is appropriate.[¶](#section-b.3-2){.pilcrow}

If all RTP streams in an RTP session are to be treated in the same way,
identifying the session is enough. If SSRCs in a session are to be
treated differently, signaling needs to identify both the session and
the SSRC.[¶](#section-b.3-3){.pilcrow}

If this signaling affects how any RTP central node, like an RTP mixer or
translator that selects, mixes, or processes streams, treats the
streams, the node will also need to receive the same signaling to know
how to treat RTP streams with different usages in the right
fashion.[¶](#section-b.3-4){.pilcrow}
:::
:::
:::
:::

::: {#section-appendix.c .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

The authors would like to acknowledge and thank [Cullen
Jennings]{.contact-name}, [Dale R. Worley]{.contact-name}, [Huang Yihong
(Rachel)]{.contact-name}, [Benjamin Kaduk]{.contact-name}, [Mirja
Kühlewind]{.contact-name}, and [Vijay Gurbani]{.contact-name} for review
and comments.[¶](#section-appendix.c-1){.pilcrow}
:::

::: {#section-appendix.d .section}
## [Contributors](#name-contributors){.section-name .selfRef} {#name-contributors}

[Hui Zheng (Marvin)]{.contact-name} contributed to WG draft versions -04
and -05 of the document.[¶](#section-appendix.d-1){.pilcrow}
:::

::: {#authors-addresses}
::: {#section-appendix.e .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Magnus Westerlund]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Ericsson]{.org}
:::

::: {.left dir="auto"}
[Torshamnsgatan 23]{.street-address}
:::

::: {.left dir="auto"}
SE-[164 80]{.postal-code} [Kista]{.locality}
:::

::: {.left dir="auto"}
[Sweden]{.country-name}
:::

::: email
Email: <magnus.westerlund@ericsson.com>
:::

::: {.left dir="auto"}
[Bo Burman]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Ericsson]{.org}
:::

::: {.left dir="auto"}
[Gronlandsgatan 31]{.street-address}
:::

::: {.left dir="auto"}
SE-[164 60]{.postal-code} [Kista]{.locality}
:::

::: {.left dir="auto"}
[Sweden]{.country-name}
:::

::: email
Email: <bo.burman@ericsson.com>
:::

::: {.left dir="auto"}
[Colin Perkins]{.fn .nameRole}
:::

::: {.left dir="auto"}
[University of Glasgow]{.org}
:::

::: {.left dir="auto"}
[School of Computing Science]{.extended-address}
:::

::: {.left dir="auto"}
[Glasgow]{.locality}
:::

::: {.left dir="auto"}
[G12 8QQ]{.postal-code}
:::

::: {.left dir="auto"}
[United Kingdom]{.country-name}
:::

::: email
Email: <csp@csperkins.org>
:::

::: {.left dir="auto"}
[Harald Tveit Alvestrand]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google]{.org}
:::

::: {.left dir="auto"}
[Kungsbron 2]{.street-address}
:::

::: {.left dir="auto"}
SE-[11122]{.postal-code} [Stockholm]{.locality}
:::

::: {.left dir="auto"}
[Sweden]{.country-name}
:::

::: email
Email: <harald@alvestrand.no>
:::

::: {.left dir="auto"}
[Roni Even]{.fn .nameRole}
:::

::: email
Email: <ron.even.tlv@gmail.com>
:::
:::
:::
