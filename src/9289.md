  RFC 9289            RPC-With-TLS      September 2022
  ------------------- ----------------- ----------------
  Myklebust & Lever   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9289](https://www.rfc-editor.org/rfc/rfc9289){.eref}

Updates:
:   [5531](https://www.rfc-editor.org/rfc/rfc5531){.eref}

Category:
:   Standards Track

Published:
:   September 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    T. Myklebust
    :::

    ::: org
    Hammerspace
    :::
    :::

    ::: author
    ::: author-name
    C. Lever, [Ed.]{.editor}
    :::

    ::: org
    Oracle
    :::
    :::
:::

# RFC 9289 {#rfcnum}

# Towards Remote Procedure Call Encryption by Default {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes a mechanism that, through the use of
opportunistic Transport Layer Security (TLS), enables encryption of
Remote Procedure Call (RPC) transactions while they are in transit. The
proposed mechanism interoperates with Open Network Computing (ONC) RPC
implementations that do not support it. This document updates RFC
5531.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9289>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Requirements
    Language](#name-requirements-language){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Terminology](#name-terminology){.xref}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [RPC-with-TLS in
    Operation](#name-rpc-with-tls-in-operation){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Discovering Server-Side TLS
        Support](#name-discovering-server-side-tls){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Authentication](#name-authentication){.xref}

        -   ::: {#section-toc.1-1.4.2.2.2.1}
            [4.2.1](#section-4.2.1){.xref}.  [Using TLS with
            RPCSEC_GSS](#name-using-tls-with-rpcsec_gss){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [TLS
    Requirements](#name-tls-requirements){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Base Transport
        Considerations](#name-base-transport-consideratio){.xref}

        -   ::: {#section-toc.1-1.5.2.1.2.1}
            [5.1.1](#section-5.1.1){.xref}.  [Protected Operation on
            TCP](#name-protected-operation-on-tcp){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.2}
            [5.1.2](#section-5.1.2){.xref}.  [Protected Operation on
            UDP](#name-protected-operation-on-udp){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.3}
            [5.1.3](#section-5.1.3){.xref}.  [Protected Operation on
            Other Transports](#name-protected-operation-on-othe){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [TLS Peer
        Authentication](#name-tls-peer-authentication){.xref}

        -   ::: {#section-toc.1-1.5.2.2.2.1}
            [5.2.1](#section-5.2.1){.xref}.  [X.509 Certificates Using
            PKIX Trust](#name-x509-certificates-using-pki){.xref}

            -   ::: {#section-toc.1-1.5.2.2.2.1.2.1}
                [5.2.1.1](#section-5.2.1.1){.xref}.  [Extended Key Usage
                Values](#name-extended-key-usage-values){.xref}
                :::
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.2}
            [5.2.2](#section-5.2.2){.xref}.  [Pre-shared
            Keys](#name-pre-shared-keys){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [The Limitations of Opportunistic
        Security](#name-the-limitations-of-opportun){.xref}

        -   ::: {#section-toc.1-1.6.2.1.2.1}
            [6.1.1](#section-6.1.1){.xref}.  [STRIPTLS
            Attacks](#name-striptls-attacks){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.1.2.2}
            [6.1.2](#section-6.1.2){.xref}.  [Privacy Leakage before
            Session
            Establishment](#name-privacy-leakage-before-sess){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [TLS Identity Management on
        Clients](#name-tls-identity-management-on-){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Security Considerations for
        AUTH_SYS on TLS](#name-security-considerations-for){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [Best Security Policy
        Practices](#name-best-security-policy-practi){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [RPC Authentication
        Flavor](#name-rpc-authentication-flavor){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [ALPN Identifier for
        SunRPC](#name-alpn-identifier-for-sunrpc){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Object Identifier for PKIX
        Extended Key Usage](#name-object-identifier-for-pkix-){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [Object Identifier for ASN.1
        Module](#name-object-identifier-for-asn1-){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [Appendix A](#appendix-A){.xref}.  [Known Weaknesses of the AUTH_SYS
    Authentication Flavor](#name-known-weaknesses-of-the-aut){.xref}
    :::

-   ::: {#section-toc.1-1.10}
    [Appendix B](#appendix-B){.xref}.  [ASN.1
    Module](#name-asn1-module){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [](#appendix-C){.xref}[Acknowledgments](#name-acknowledgments){.xref}
    :::

-   ::: {#section-toc.1-1.12}
    [](#appendix-D){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#section_8F035331-8EB8-4FBC-973A-673FBA5FE952}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

In 2014 the IETF published a document entitled \"Pervasive Monitoring Is
an Attack\" \[[RFC7258](#RFC7258){.xref}\], which recognized that
unauthorized observation of network traffic had become widespread and
was a subversive threat to all who make use of the Internet at large. It
strongly recommended that newly defined Internet protocols should make a
genuine effort to mitigate monitoring attacks. Typically, this
mitigation includes encrypting data in
transit.[¶](#section-1-1){.pilcrow}

The Remote Procedure Call version 2 protocol has been a Proposed
Standard for three decades (see \[[RFC5531](#RFC5531){.xref}\] and its
antecedents). Over twenty years ago, Eisler et al. first introduced
RPCSEC_GSS as an in-transit encryption mechanism for RPC
\[[RFC2203](#RFC2203){.xref}\]. However, experience has shown that
RPCSEC_GSS with in-transit encryption can be challenging to use in
practice due to the following:[¶](#section-1-2){.pilcrow}

-   [Parts of each RPC header remain in cleartext, constituting a loss
    of metadata
    confidentiality.[¶](#section-1-3.1){.pilcrow}]{#section-1-3.1}
-   [Offloading the Generic Security Service (GSS) privacy service is
    not practical in large multi-user deployments since each message is
    encrypted using a key based on the issuing RPC
    user.[¶](#section-1-3.2){.pilcrow}]{#section-1-3.2}

However strong GSS-provided confidentiality is, it cannot provide any
security if the challenges of using it result in choosing not to deploy
it at all.[¶](#section-1-4){.pilcrow}

Moreover, the use of AUTH_SYS remains common despite the adverse effects
that acceptance of User Identifiers (UIDs) and Group Identifiers (GIDs)
from unauthenticated clients brings with it. Continued use is in part
because:[¶](#section-1-5){.pilcrow}

-   [Per-client deployment and administrative costs for the only
    well-defined alternative to AUTH_SYS are expensive at scale. For
    instance, administrators must provide keying material for each RPC
    client, including transient
    clients.[¶](#section-1-6.1){.pilcrow}]{#section-1-6.1}
-   [GSS host identity management and user identity management typically
    must be enforced in the same security realm. However, cloud
    providers, for instance, might prefer to remain authoritative for
    host identity but allow tenants to manage user identities within
    their private
    networks.[¶](#section-1-6.2){.pilcrow}]{#section-1-6.2}

In view of the challenges with the currently available mechanisms for
authenticating and protecting the confidentiality of RPC transactions,
this document specifies a transport-layer security mechanism that
complements the existing ones. The TLS \[[RFC8446](#RFC8446){.xref}\]
and Datagram Transport Layer Security (DTLS)
\[[RFC9147](#RFC9147){.xref}\] protocols are well-established Internet
building blocks that protect many standard Internet protocols such as
the Hypertext Transfer Protocol (HTTP)
\[[RFC9110](#RFC9110){.xref}\].[¶](#section-1-7){.pilcrow}

Encrypting at the RPC transport layer accords several significant
benefits:[¶](#section-1-8){.pilcrow}

[]{.break}

Encryption by Default:
:   Transport encryption can be enabled without additional
    administrative tasks such as identifying client systems to a trust
    authority and providing each with keying
    material.[¶](#section-1-9.2){.pilcrow}
:   

Encryption Offload:
:   Hardware support for the GSS privacy service has not appeared in the
    marketplace. However, the use of a well-established transport
    encryption mechanism that is employed by other ubiquitous network
    protocols makes it more likely that encryption offload for RPC is
    practicable.[¶](#section-1-9.4){.pilcrow}
:   

Securing AUTH_SYS:
:   Most critically, transport encryption can significantly reduce
    several security issues inherent in the current widespread use of
    AUTH_SYS (i.e., acceptance of UIDs and GIDs generated by an
    unauthenticated client).[¶](#section-1-9.6){.pilcrow}
:   

Decoupled User and Host Identities:
:   TLS can be used to authenticate peer hosts while other security
    mechanisms can handle user
    authentication.[¶](#section-1-9.8){.pilcrow}
:   

Compatibility:
:   The imposition of encryption at the transport layer protects any
    upper-layer protocol that employs RPC, without alteration of the
    upper-layer protocol.[¶](#section-1-9.10){.pilcrow}
:   

Further, [Section
6](#section_2AE49383-E6B2-4830-8407-995FEBF727F2){.xref} of the current
document defines policies in line with \[[RFC7435](#RFC7435){.xref}\]
that enable RPC-with-TLS to be deployed opportunistically in
environments that contain RPC implementations that do not support TLS.
However, specifications for RPC-based upper-layer protocols should
choose to require even stricter policies that guarantee encryption and
host authentication are used for all RPC transactions to mitigate
against pervasive monitoring attacks \[[RFC7258](#RFC7258){.xref}\].
Enforcing the use of RPC-with-TLS is of particular importance for
existing upper-layer protocols whose security infrastructure is
weak.[¶](#section-1-10){.pilcrow}

The protocol specification in the current document assumes that support
for ONC RPC \[[RFC5531](#RFC5531){.xref}\], TLS
\[[RFC8446](#RFC8446){.xref}\], PKIX \[[RFC5280](#RFC5280){.xref}\],
DNSSEC/DNS-Based Authentication of Named Entities (DANE)
\[[RFC6698](#RFC6698){.xref}\], and optionally RPCSEC_GSS
\[[RFC2203](#RFC2203){.xref}\] is available within the platform where
RPC-with-TLS support is to be added.[¶](#section-1-11){.pilcrow}
:::
:::

::: {#section_024237C9-5504-49B4-A2D3-2D2A5EFBB967}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Requirements Language](#name-requirements-language){.section-name .selfRef} {#name-requirements-language}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}
:::
:::

::: {#section_0EB1100E-DAA8-4B2C-98AE-94258CFDCB1B}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

This document adopts the terminology introduced in [Section
3](https://www.rfc-editor.org/rfc/rfc6973#section-3){.relref} of
\[[RFC6973](#RFC6973){.xref}\] and assumes a working knowledge of the
RPC version 2 protocol \[[RFC5531](#RFC5531){.xref}\] and the TLS
version 1.3 protocol
\[[RFC8446](#RFC8446){.xref}\].[¶](#section-3-1){.pilcrow}

Note also that the NFS community long ago adopted the use of the term
\"privacy\" from documents such as \[[RFC2203](#RFC2203){.xref}\]. In
the current document, the authors use the term \"privacy\" only when
referring specifically to the historic GSS privacy service defined in
\[[RFC2203](#RFC2203){.xref}\]. Otherwise, the authors use the term
\"confidentiality\", following the practices of contemporary security
communities.[¶](#section-3-2){.pilcrow}

We adhere to the convention that a \"client\" is a network host that
actively initiates an association, and a \"server\" is a network host
that passively accepts an association
request.[¶](#section-3-3){.pilcrow}

RPC documentation historically refers to the authentication of a
connecting host as \"machine authentication\" or \"host
authentication\". TLS documentation refers to the same as \"peer
authentication\". In the current document, there is little distinction
between these terms.[¶](#section-3-4){.pilcrow}

The term \"user authentication\" in the current document refers
specifically to the RPC caller\'s credential, provided in the \"cred\"
and \"verf\" fields in each RPC Call.[¶](#section-3-5){.pilcrow}
:::
:::

::: {#section_EC3FEED5-1DE0-454B-9AB3-CE47BA901583}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [RPC-with-TLS in Operation](#name-rpc-with-tls-in-operation){.section-name .selfRef} {#name-rpc-with-tls-in-operation}

::: {#section_0A03673B-14BA-4228-8A8A-F76AA318CA73}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Discovering Server-Side TLS Support](#name-discovering-server-side-tls){.section-name .selfRef} {#name-discovering-server-side-tls}

The mechanism described in the current document interoperates fully with
RPC implementations that do not support RPC-with-TLS. When an
RPC-with-TLS-enabled peer encounters a peer that does not support
RPC-with-TLS, policy settings on the RPC-with-TLS-enabled peer determine
whether RPC operation continues without the use of TLS or is
discontinued altogether.[¶](#section-4.1-1){.pilcrow}

To achieve this interoperability, we introduce a new RPC authentication
flavor called AUTH_TLS. The AUTH_TLS authentication flavor signals that
the client wants to initiate TLS negotiation if the server supports it.
Except for the modifications described in this section, the RPC protocol
is unaware of security encapsulation at the transport layer. The value
of AUTH_TLS is defined in [Section
7.1](#section_2CD51855-CE40-4B8D-A220-F211C477964F){.xref}.[¶](#section-4.1-2){.pilcrow}

An RPC client begins its communication with an RPC server by selecting a
transport and destination port. The choice of transport and port is
typically based on the RPC program that is to be used. The RPC client
might query the RPC server\'s RPCBIND service to make this selection
(The RPCBIND service is described in \[[RFC1833](#RFC1833){.xref}\]).
The mechanism described in the current document does not support RPC
transports other than TCP and UDP. In all cases, an RPC server
[MUST]{.bcp14} listen on the same ports for (D)TLS-protected RPC
programs as the ports used when (D)TLS is not
available.[¶](#section-4.1-3){.pilcrow}

To protect RPC traffic to a TCP port, the RPC client opens a TCP
connection to that port and sends a NULL RPC procedure with an
auth_flavor of AUTH_TLS on that connection. To protect RPC traffic to a
UDP port, the RPC client sends a UDP datagram to that port containing a
NULL RPC procedure with an auth_flavor of AUTH_TLS. The client
constructs this RPC procedure as follows:[¶](#section-4.1-4){.pilcrow}

-   [The length of the opaque data constituting the credential sent in
    the RPC Call message [MUST]{.bcp14} be
    zero.[¶](#section-4.1-5.1){.pilcrow}]{#section-4.1-5.1}
-   [The verifier accompanying the credential [MUST]{.bcp14} be an
    AUTH_NONE verifier of length
    zero.[¶](#section-4.1-5.2){.pilcrow}]{#section-4.1-5.2}
-   [The flavor value of the verifier in the RPC Reply message received
    from the server [MUST]{.bcp14} be
    AUTH_NONE.[¶](#section-4.1-5.3){.pilcrow}]{#section-4.1-5.3}
-   [The length of the verifier\'s body field is
    eight.[¶](#section-4.1-5.4){.pilcrow}]{#section-4.1-5.4}
-   [The bytes of the verifier\'s body field encode the ASCII characters
    \"STARTTLS\" as a fixed-length
    opaque.[¶](#section-4.1-5.5){.pilcrow}]{#section-4.1-5.5}

The RPC server signals its corresponding support for RPC-with-TLS by
replying with a reply_stat of MSG_ACCEPTED and an AUTH_NONE verifier
containing the \"STARTTLS\" token. The client [SHOULD]{.bcp14} proceed
with TLS session establishment, even if the Reply\'s accept_stat is not
SUCCESS. If the AUTH_TLS probe was done via TCP, the RPC client
[MUST]{.bcp14} send the \"ClientHello\" message on the same connection.
If the AUTH_TLS probe was done via UDP, the RPC client [MUST]{.bcp14}
send the \"ClientHello\" message to the same UDP destination
port.[¶](#section-4.1-6){.pilcrow}

Conversely, if the Reply\'s reply_stat is not MSG_ACCEPTED, if its
verifier flavor is not AUTH_NONE, or if its verifier does not contain
the \"STARTTLS\" token, the RPC client [MUST NOT]{.bcp14} send a
\"ClientHello\" message. RPC operation may continue, depending on local
policy, but without confidentiality, integrity, or peer authentication
protection from (D)TLS.[¶](#section-4.1-7){.pilcrow}

If, after a successful RPC AUTH_TLS probe, the subsequent (D)TLS
handshake should fail for any reason, the RPC client reports this
failure to the upper-layer application the same way it reports an
AUTH_ERROR rejection from the RPC server.[¶](#section-4.1-8){.pilcrow}

If an RPC client uses the AUTH_TLS authentication flavor on any
procedure other than the NULL procedure, or an RPC client sends an RPC
AUTH_TLS probe within an existing (D)TLS session, the RPC server
[MUST]{.bcp14} reject that RPC Call by returning a reply_stat of
MSG_DENIED with a reject_stat of AUTH_ERROR and an auth_stat of
AUTH_BADCRED.[¶](#section-4.1-9){.pilcrow}

Once the TLS session handshake is complete, the RPC client and server
have established a secure channel for exchanging RPC transactions. A
successful AUTH_TLS probe on one particular port/transport tuple does
not imply that RPC-with-TLS is available on that same server using a
different port/transport tuple, nor does it imply that RPC-with-TLS will
be available in the future using the successfully probed
port.[¶](#section-4.1-10){.pilcrow}
:::
:::

::: {#section_6EDEF553-C95A-47D7-ABBA-0B537FE3A959}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Authentication](#name-authentication){.section-name .selfRef} {#name-authentication}

There is some overlap between the authentication capabilities of RPC and
TLS. The goal of interoperability with implementations that do not
support TLS requires limiting the combinations that are allowed and
precisely specifying the role that each layer
plays.[¶](#section-4.2-1){.pilcrow}

Each RPC server that supports RPC-with-TLS [MUST]{.bcp14} possess a
unique global identity (e.g., a certificate that is signed by a
well-known trust anchor). Such an RPC server [MUST]{.bcp14} request a
TLS peer identity from each client upon first contact. There are two
different modes of client deployment:[¶](#section-4.2-2){.pilcrow}

[]{.break}

Server-Only Host Authentication
:   In this type of deployment, the client can authenticate the server
    host using the presented server peer TLS identity, but the server
    cannot authenticate the client. In this situation, RPC-with-TLS
    clients are anonymous. They present no globally unique identifier to
    the server peer.[¶](#section-4.2-3.2){.pilcrow}
:   

Mutual Host Authentication
:   In this type of deployment, the client possesses an identity that is
    backed by a trusted entity (e.g., a pre-shared key or a certificate
    validated with a certification path). As part of the TLS handshake,
    both peers authenticate using the presented TLS identities. If
    authentication of either peer fails, or if authorization based on
    those identities blocks access to the server, the peers
    [MUST]{.bcp14} reject the association. Further explanation appears
    in [Section
    5.2](#section_936921ED-67BB-46BF-B316-6740E07F6652){.xref}.[¶](#section-4.2-3.4){.pilcrow}
:   

In either of these modes, RPC user authentication is not affected by the
use of transport layer security. When a client presents a TLS peer
identity to an RPC server, the protocol extension described in the
current document provides no way for the server to know whether that
identity represents one RPC user on that client or is shared amongst
many RPC users. Therefore, a server implementation cannot utilize the
remote TLS peer identity to authenticate RPC
users.[¶](#section-4.2-4){.pilcrow}

::: {#section_12D92596-F310-48C8-A4E0-B6CA038524E5}
::: {#section-4.2.1 .section}
#### [4.2.1.](#section-4.2.1){.section-number .selfRef} [Using TLS with RPCSEC_GSS](#name-using-tls-with-rpcsec_gss){.section-name .selfRef} {#name-using-tls-with-rpcsec_gss}

To use GSS, an RPC server has to possess a GSS service principal. On a
TLS session, GSS mutual (peer) authentication occurs as usual, but only
after a TLS session has been established for communication.
Authentication of RPCSEC_GSS users is unchanged by the use of
TLS.[¶](#section-4.2.1-1){.pilcrow}

RPCSEC_GSS can also perform per-request integrity or confidentiality
protection. When operating over a TLS session, these GSS services become
largely redundant. An RPC implementation capable of concurrently using
TLS and RPCSEC_GSS [MUST]{.bcp14} use Generic Security Service
Application Program Interface (GSS-API) channel binding, as defined in
\[[RFC5056](#RFC5056){.xref}\], to determine when an underlying
transport provides a sufficient degree of confidentiality. RPC-with-TLS
implementations [MUST]{.bcp14} provide the \"tls-exporter\" channel
binding type, as defined in
\[[RFC9266](#RFC9266){.xref}\].[¶](#section-4.2.1-2){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#section_D93526DA-7B9D-419B-BE84-4AD8DA48577E}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [TLS Requirements](#name-tls-requirements){.section-name .selfRef} {#name-tls-requirements}

When peers negotiate a TLS session that is to transport RPC, the
following restrictions apply:[¶](#section-5-1){.pilcrow}

-   [Implementations [MUST NOT]{.bcp14} negotiate TLS versions prior to
    1.3 (for TLS \[[RFC8446](#RFC8446){.xref}\] or DTLS
    \[[RFC9147](#RFC9147){.xref}\], respectively). Support for
    mandatory-to-implement cipher suites for the negotiated TLS version
    is [REQUIRED]{.bcp14}.[¶](#section-5-2.1){.pilcrow}]{#section-5-2.1}
-   [Implementations [MUST]{.bcp14} conform to the recommendations for
    TLS usage specified in BCP 195 \[[RFC7525](#RFC7525){.xref}\].
    Although RFC 7525 permits the use of TLS 1.2, the requirement to use
    TLS 1.3 or later for RPC-with-TLS takes precedence. Further, because
    TLS 1.3 ciphers are qualitatively different than cipher suites in
    previous versions of TLS, and RFC 7525 predates TLS 1.3, the cipher
    suite recommendations in RFC 7525 do not apply to RPC-with-(D)TLS. A
    strict TLS mode for RPC-with-TLS that protects against STRIPTLS
    attacks is discussed in detail in [Section
    6.1.1](#section_8894BDD2-0E0B-47A3-A2CB-70E4D93B55B0){.xref}.[¶](#section-5-2.2){.pilcrow}]{#section-5-2.2}
-   [Implementations [MUST]{.bcp14} support certificate-based mutual
    authentication. Support for Pre-Shared Key (PSK) mutual
    authentication is [OPTIONAL]{.bcp14}; see [Section
    5.2.2](#section_6DA9ED5F-BAD9-4126-95B7-E2331655A01E){.xref} for
    further details.[¶](#section-5-2.3){.pilcrow}]{#section-5-2.3}
-   [Negotiation of a cipher suite providing confidentiality as well as
    integrity protection is
    [REQUIRED]{.bcp14}.[¶](#section-5-2.4){.pilcrow}]{#section-5-2.4}

Client implementations [MUST]{.bcp14} include the
\"application_layer_protocol_negotiation(16)\" extension
\[[RFC7301](#RFC7301){.xref}\] in their \"ClientHello\" message and
[MUST]{.bcp14} include the protocol identifier defined in [Section
7.2](#section_58905D7A-06B1-4469-964A-DAC607DAC500){.xref} in that
message\'s ProtocolNameList value.[¶](#section-5-3){.pilcrow}

Similarly, in response to the \"ClientHello\" message, server
implementations [MUST]{.bcp14} include the
\"application_layer_protocol_negotiation(16)\" extension
\[[RFC7301](#RFC7301){.xref}\] in their \"ServerHello\" message and
[MUST]{.bcp14} include only the protocol identifier defined in [Section
7.2](#section_58905D7A-06B1-4469-964A-DAC607DAC500){.xref} in that
message\'s ProtocolNameList value.[¶](#section-5-4){.pilcrow}

If the server responds incorrectly (for instance, if the \"ServerHello\"
message does not conform to the above requirements), the client [MUST
NOT]{.bcp14} establish a TLS session for use with RPC on this
connection. See \[[RFC7301](#RFC7301){.xref}\] for further details about
how to form these messages properly.[¶](#section-5-5){.pilcrow}

::: {#section_CC204592-F561-49BD-B1C9-DE0FF7F0E7AB}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Base Transport Considerations](#name-base-transport-consideratio){.section-name .selfRef} {#name-base-transport-consideratio}

There is frequently a strong association between an RPC program and a
particular destination port number. The use of TLS or DTLS does not
change that association. Thus, it is frequently, though not always, the
case that a single TLS session carries traffic for only one RPC
program.[¶](#section-5.1-1){.pilcrow}

::: {#section_74B43C7E-5ADC-4FBD-B4EA-FF8F470994A8}
::: {#section-5.1.1 .section}
#### [5.1.1.](#section-5.1.1){.section-number .selfRef} [Protected Operation on TCP](#name-protected-operation-on-tcp){.section-name .selfRef} {#name-protected-operation-on-tcp}

The use of the TLS protocol \[[RFC8446](#RFC8446){.xref}\] protects RPC
on TCP connections. Typically, once an RPC client completes the TCP
handshake, it uses the mechanism described in [Section
4.1](#section_0A03673B-14BA-4228-8A8A-F76AA318CA73){.xref} to discover
RPC-with-TLS support for that RPC program on that connection. Until an
AUTH_TLS probe is done on a connection, the RPC server treats all
traffic as RPC messages. If spurious traffic appears on a TCP connection
between the initial cleartext AUTH_TLS probe and the TLS session
handshake, receivers [MUST]{.bcp14} discard that data without response
and then [SHOULD]{.bcp14} drop the
connection.[¶](#section-5.1.1-1){.pilcrow}

The protocol convention specified in the current document assumes there
can be no more than one concurrent TLS session per TCP connection. This
is true of current generations of TLS, but might be different in a
future version of TLS.[¶](#section-5.1.1-2){.pilcrow}

Once a TLS session is established on a TCP connection, no further
cleartext communication can occur on that connection until the session
is terminated. The use of TLS does not alter RPC record framing used on
TCP transports.[¶](#section-5.1.1-3){.pilcrow}

Furthermore, if an RPC server responds with PROG_UNAVAIL to an RPC Call
within an established TLS session, that does not imply that RPC server
will subsequently reject the same RPC program on a different TCP
connection.[¶](#section-5.1.1-4){.pilcrow}

Reverse-direction operation occurs only on connected transports such as
TCP (see [Section
2](https://www.rfc-editor.org/rfc/rfc8167#section-2){.relref} of
\[[RFC8167](#RFC8167){.xref}\]). To protect reverse-direction RPC
operations, the RPC server does not establish a separate TLS session on
the TCP connection but instead uses the existing TLS session on that
connection to protect these operations.[¶](#section-5.1.1-5){.pilcrow}

When operation is complete, an RPC peer terminates a TLS session by
sending a TLS closure alert. It may then close the TCP
connection.[¶](#section-5.1.1-6){.pilcrow}
:::
:::

::: {#section_B8BF600E-96DC-4C82-AADF-D593826E9B75}
::: {#section-5.1.2 .section}
#### [5.1.2.](#section-5.1.2){.section-number .selfRef} [Protected Operation on UDP](#name-protected-operation-on-udp){.section-name .selfRef} {#name-protected-operation-on-udp}

The use of the DTLS protocol \[[RFC9147](#RFC9147){.xref}\] protects RPC
carried in UDP datagrams. As soon as a client initializes a UDP socket
for use with an RPC service, it uses the mechanism described in [Section
4.1](#section_0A03673B-14BA-4228-8A8A-F76AA318CA73){.xref} to discover
RPC-with-DTLS support for that RPC program on that port. If spurious
traffic appears on a 5-tuple between the initial cleartext AUTH_TLS
probe and the DTLS association handshake, receivers [MUST]{.bcp14}
discard that traffic without response.[¶](#section-5.1.2-1){.pilcrow}

Using DTLS does not introduce reliable or in-order semantics to RPC on
UDP. The use of DTLS record replay protection is [REQUIRED]{.bcp14} when
transporting RPC traffic.[¶](#section-5.1.2-2){.pilcrow}

Each RPC message [MUST]{.bcp14} fit in a single DTLS record. DTLS
encapsulation has overhead, which reduces the Packetization Layer Path
MTU (PLPMTU) and thus the maximum RPC payload size. A possible PLPMTU
discovery mechanism is offered in
\[[RFC8899](#RFC8899){.xref}\].[¶](#section-5.1.2-3){.pilcrow}

The current document does not specify a mechanism that enables a server
to distinguish between DTLS traffic and unprotected RPC traffic directed
to the same port. To make this distinction, each peer matches ingress
datagrams that appear to be DTLS traffic to existing DTLS session state.
A peer treats any datagram that fails the matching process as an RPC
message.[¶](#section-5.1.2-4){.pilcrow}

Multihomed RPC clients and servers may send protected RPC messages via
network interfaces that were not involved in the handshake that
established the DTLS session. Therefore, when protecting RPC traffic,
each DTLS handshake [MUST]{.bcp14} include the \"connection_id(54)\"
extension described in [Section
9](https://www.rfc-editor.org/rfc/rfc9147#section-9){.relref} of
\[[RFC9147](#RFC9147){.xref}\], and RPC-with-DTLS peer endpoints
[MUST]{.bcp14} provide a ConnectionID with a nonzero length. Endpoints
implementing RPC programs that expect a significant number of concurrent
clients [SHOULD]{.bcp14} employ ConnectionIDs of at least 4 bytes in
length.[¶](#section-5.1.2-5){.pilcrow}

Sending a TLS closure alert terminates a DTLS session. Because neither
DTLS nor UDP provide in-order delivery, after session closure there can
be ambiguity as to whether a datagram should be interpreted as DTLS
protected or not. Therefore, receivers [MUST]{.bcp14} discard datagrams
exchanged using the same 5-tuple that just terminated the DTLS session
for a sufficient length of time to ensure that retransmissions have
ceased and packets already in the network have been delivered. In the
absence of more specific data, a period of 60 seconds is expected to
suffice.[¶](#section-5.1.2-6){.pilcrow}
:::
:::

::: {#section_BFCC24B1-E6D4-4ABC-A5F3-B71E8E96878F}
::: {#section-5.1.3 .section}
#### [5.1.3.](#section-5.1.3){.section-number .selfRef} [Protected Operation on Other Transports](#name-protected-operation-on-othe){.section-name .selfRef} {#name-protected-operation-on-othe}

Transports that provide intrinsic TLS-level security (e.g., QUIC) need
to be addressed separately from the current document. In such cases, the
use of TLS is not opportunistic as it can be for TCP or
UDP.[¶](#section-5.1.3-1){.pilcrow}

RPC-over-RDMA can make use of transport layer security below the RDMA
transport layer \[[RFC8166](#RFC8166){.xref}\]. The exact mechanism is
not within the scope of the current document. Because there might not be
other provisions to exchange client and server certificates,
authentication material exchange needs to be provided by facilities
within a future version of the RPC-over-RDMA transport
protocol.[¶](#section-5.1.3-2){.pilcrow}
:::
:::
:::
:::

::: {#section_936921ED-67BB-46BF-B316-6740E07F6652}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [TLS Peer Authentication](#name-tls-peer-authentication){.section-name .selfRef} {#name-tls-peer-authentication}

TLS can perform peer authentication using any of the following
mechanisms.[¶](#section-5.2-1){.pilcrow}

::: {#section_7A68F518-2C02-4705-8218-4F13E51372F4}
::: {#section-5.2.1 .section}
#### [5.2.1.](#section-5.2.1){.section-number .selfRef} [X.509 Certificates Using PKIX Trust](#name-x509-certificates-using-pki){.section-name .selfRef} {#name-x509-certificates-using-pki}

X.509 certificates are specified in \[[X.509](#X.509){.xref}\].
\[[RFC5280](#RFC5280){.xref}\] provides a profile of Internet PKI X.509
public key infrastructure. RPC-with-TLS implementations are
[REQUIRED]{.bcp14} to support the PKIX mechanism described in
\[[RFC5280](#RFC5280){.xref}\].[¶](#section-5.2.1-1){.pilcrow}

The rules and guidelines defined in \[[RFC6125](#RFC6125){.xref}\] apply
to RPC-with-TLS certificates with the following
considerations:[¶](#section-5.2.1-2){.pilcrow}

-   [The DNS-ID identifier type is a subjectAltName extension that
    contains a dNSName, as defined in [Section
    4.2.1.6](https://www.rfc-editor.org/rfc/rfc5280#section-4.2.1.6){.relref}
    of \[[RFC5280](#RFC5280){.xref}\]. Support for the DNS-ID identifier
    type is [REQUIRED]{.bcp14} in RPC-with-TLS client and server
    implementations. Certification authorities that issue such
    certificates [MUST]{.bcp14} support the DNS-ID identifier
    type.[¶](#section-5.2.1-3.1){.pilcrow}]{#section-5.2.1-3.1}
-   [To specify the identity of an RPC peer as a domain name, the
    certificate [MUST]{.bcp14} contain a subjectAltName extension that
    contains a dNSName. DNS domain names in RPC-with-TLS certificates
    [MUST NOT]{.bcp14} contain the wildcard character \'\*\' within the
    identifier.[¶](#section-5.2.1-3.2){.pilcrow}]{#section-5.2.1-3.2}
-   [To specify the identity of an RPC peer as a network identifier
    (netid) or a universal network address (uaddr), the certificate
    [MUST]{.bcp14} contain a subjectAltName extension that contains an
    iPAddress.[¶](#section-5.2.1-3.3){.pilcrow}]{#section-5.2.1-3.3}

When validating a server certificate, an RPC-with-TLS client
implementation takes the following into
account:[¶](#section-5.2.1-4){.pilcrow}

-   [Certificate validation [MUST]{.bcp14} include the verification
    rules as per [Section
    6](https://www.rfc-editor.org/rfc/rfc5280#section-6){.relref} of
    \[[RFC5280](#RFC5280){.xref}\] and [Section
    6](https://www.rfc-editor.org/rfc/rfc6125#section-6){.relref} of
    \[[RFC6125](#RFC6125){.xref}\].[¶](#section-5.2.1-5.1){.pilcrow}]{#section-5.2.1-5.1}
-   [Server certificate validation [MUST]{.bcp14} include a check on
    whether the locally configured expected DNS-ID or iPAddress
    subjectAltName of the server that is contacted matches its presented
    certificate.[¶](#section-5.2.1-5.2){.pilcrow}]{#section-5.2.1-5.2}
-   [For RPC services accessed by their netids and uaddrs, the iPAddress
    subjectAltName [MUST]{.bcp14} be present in the certificate and
    [MUST]{.bcp14} exactly match the address represented by the
    universal network
    address.[¶](#section-5.2.1-5.3){.pilcrow}]{#section-5.2.1-5.3}

An RPC client\'s domain name and IP address are often assigned
dynamically; thus, RPC servers cannot rely on those to verify client
certificates. Therefore, when an RPC-with-TLS client presents a
certificate to an RPC-with-TLS server, the server takes the following
into account:[¶](#section-5.2.1-6){.pilcrow}

-   [The server [MUST]{.bcp14} use a procedure conformant to [Section
    6](https://www.rfc-editor.org/rfc/rfc5280#section-6){.relref} of
    \[[RFC5280](#RFC5280){.xref}\] to validate the client certificate\'s
    certification
    path.[¶](#section-5.2.1-7.1){.pilcrow}]{#section-5.2.1-7.1}
-   [The tuple (serial number of the presented certificate; Issuer)
    uniquely identifies the RPC client. The meaning and syntax of these
    fields is defined in [Section
    4](https://www.rfc-editor.org/rfc/rfc5280#section-4){.relref} of
    \[[RFC5280](#RFC5280){.xref}\].[¶](#section-5.2.1-7.2){.pilcrow}]{#section-5.2.1-7.2}

RPC-with-TLS implementations [MAY]{.bcp14} allow the configuration of a
set of additional properties of the certificate to check for a peer\'s
authorization to communicate (e.g., a set of allowed values in
subjectAltName:URI, a set of allowed X.509v3 Certificate Policies, or a
set of extended key usages).[¶](#section-5.2.1-8){.pilcrow}

When the configured set of trust anchors changes (e.g., removal of a
Certification Authority (CA) from the list of trusted CAs; issuance of a
new Certificate Revocation List (CRL) for a given CA), implementations
[SHOULD]{.bcp14} reevaluate the certificate originally presented in the
context of the new configuration and terminate the TLS session if the
certificate is no longer trustworthy.[¶](#section-5.2.1-9){.pilcrow}

::: {#section_685D3F88-94FF-4C91-8CCB-860DBA602B2F}
::: {#section-5.2.1.1 .section}
##### [5.2.1.1.](#section-5.2.1.1){.section-number .selfRef} [Extended Key Usage Values](#name-extended-key-usage-values){.section-name .selfRef} {#name-extended-key-usage-values}

[Section
4.2.1.12](https://www.rfc-editor.org/rfc/rfc5280#section-4.2.1.12){.relref}
of \[[RFC5280](#RFC5280){.xref}\] specifies the extended key usage X.509
certificate extension. This extension, which may appear in end-entity
certificates, indicates one or more purposes for which the certified
public key may be used in addition to or in place of the basic purposes
indicated in the key usage extension.[¶](#section-5.2.1.1-1){.pilcrow}

The current document defines two new KeyPurposeId values: one that
identifies the RPC-with-TLS peer as an RPC client, and one that
identifies the RPC-with-TLS peer as an RPC
server.[¶](#section-5.2.1.1-2){.pilcrow}

The inclusion of the RPC server value (id-kp-rpcTLSServer) indicates
that the certificate has been issued for allowing the holder to process
RPC transactions.[¶](#section-5.2.1.1-3){.pilcrow}

The inclusion of the RPC client value (id-kp-rpcTLSClient) indicates
that the certificate has been issued for allowing the holder to request
RPC transactions.[¶](#section-5.2.1.1-4){.pilcrow}
:::
:::
:::
:::

::: {#section_6DA9ED5F-BAD9-4126-95B7-E2331655A01E}
::: {#section-5.2.2 .section}
#### [5.2.2.](#section-5.2.2){.section-number .selfRef} [Pre-shared Keys](#name-pre-shared-keys){.section-name .selfRef} {#name-pre-shared-keys}

This mechanism is [OPTIONAL]{.bcp14} to implement. In this mode, the RPC
peer can be uniquely identified by keying material that has been shared
out of band (see [Section
2.2](https://www.rfc-editor.org/rfc/rfc8446#section-2.2){.relref} of
\[[RFC8446](#RFC8446){.xref}\]). The PSK Identifier [SHOULD]{.bcp14} be
exposed at the RPC layer.[¶](#section-5.2.2-1){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#section_2AE49383-E6B2-4830-8407-995FEBF727F2}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

One purpose of the mechanism described in the current document is to
protect RPC-based applications against threats to the confidentiality of
RPC transactions and RPC user identities. A taxonomy of these threats
appears in [Section
5](https://www.rfc-editor.org/rfc/rfc6973#section-5){.relref} of
\[[RFC6973](#RFC6973){.xref}\]. Also, [Section
6](https://www.rfc-editor.org/rfc/rfc7525#section-6){.relref} of
\[[RFC7525](#RFC7525){.xref}\] contains a detailed discussion of
technologies used in conjunction with TLS. [Section
8](https://www.rfc-editor.org/rfc/rfc5280#section-8){.relref} of
\[[RFC5280](#RFC5280){.xref}\] covers important considerations about
handling certificate material securely. Implementers should familiarize
themselves with these materials.[¶](#section-6-1){.pilcrow}

Once a TLS session is established, the RPC payload carried on TLS
version 1.3 is forward secure. However, implementers need to be aware
that replay attacks can occur during session establishment. Remedies for
such attacks are discussed in detail in [Section
8](https://www.rfc-editor.org/rfc/rfc8446#section-8){.relref} of
\[[RFC8446](#RFC8446){.xref}\]. Further, the current document does not
provide a profile that defines the use of 0-RTT data (see [Appendix
E.5](https://www.rfc-editor.org/rfc/rfc8446#appendix-E.5){.relref} of
\[[RFC8446](#RFC8446){.xref}\]). Therefore, RPC-with-TLS implementations
[MUST NOT]{.bcp14} use 0-RTT data.[¶](#section-6-2){.pilcrow}

::: {#section_51737BB5-2B65-441E-AD1D-7EBF5123C079}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [The Limitations of Opportunistic Security](#name-the-limitations-of-opportun){.section-name .selfRef} {#name-the-limitations-of-opportun}

Readers can find the definition of Opportunistic Security in
\[[RFC7435](#RFC7435){.xref}\]. A discussion of its underlying
principles appears in Section
[3](https://www.rfc-editor.org/rfc/rfc7435#section-3){.relref} of that
document.[¶](#section-6.1-1){.pilcrow}

The purpose of using an explicitly opportunistic approach is to enable
interoperation with implementations that do not support RPC-with-TLS. A
range of options is allowed by this approach, from \"no peer
authentication or encryption\" to \"server-only authentication with
encryption\" to \"mutual authentication with encryption\". The actual
security level may indeed be selected based on policy and without user
intervention.[¶](#section-6.1-2){.pilcrow}

In environments where interoperability is a priority, the security
benefits of TLS are partially or entirely waived. Implementations of the
mechanism described in the current document must take care to accurately
represent to all RPC consumers the level of security that is actually in
effect, and are [REQUIRED]{.bcp14} to provide an audit log of
RPC-with-TLS security mode selection.[¶](#section-6.1-3){.pilcrow}

In all other cases, the adoption, implementation, and deployment of
RPC-based upper-layer protocols that enforce the use of TLS
authentication and encryption (when similar RPCSEC_GSS services are not
in use) is strongly encouraged.[¶](#section-6.1-4){.pilcrow}

::: {#section_8894BDD2-0E0B-47A3-A2CB-70E4D93B55B0}
::: {#section-6.1.1 .section}
#### [6.1.1.](#section-6.1.1){.section-number .selfRef} [STRIPTLS Attacks](#name-striptls-attacks){.section-name .selfRef} {#name-striptls-attacks}

The initial AUTH_TLS probe occurs in cleartext. An on-path attacker can
alter a cleartext handshake to make it appear as though TLS support is
not available on one or both peers. Client implementers can choose from
the following to mitigate STRIPTLS
attacks:[¶](#section-6.1.1-1){.pilcrow}

-   [A TLSA record \[[RFC6698](#RFC6698){.xref}\] can alert clients that
    TLS is expected to work, and provide a binding of a hostname to the
    X.509 identity. If TLS cannot be negotiated or authentication fails,
    the client disconnects and reports the problem. When an
    opportunistic security policy is in place, a client [SHOULD]{.bcp14}
    check for the existence of a TLSA record for the target server
    before initiating an RPC-with-TLS
    association.[¶](#section-6.1.1-2.1){.pilcrow}]{#section-6.1.1-2.1}
-   [Client security policy can require that a TLS session is
    established on every connection. If an attacker spoofs the
    handshake, the client disconnects and reports the problem. This
    policy prevents an attacker from causing the association to fall
    back to cleartext silently. If TLSA records are not available, this
    approach is strongly
    encouraged.[¶](#section-6.1.1-2.2){.pilcrow}]{#section-6.1.1-2.2}
:::
:::

::: {#section_9C03417D-1D3D-4D43-BC43-6F7387736AF7}
::: {#section-6.1.2 .section}
#### [6.1.2.](#section-6.1.2){.section-number .selfRef} [Privacy Leakage before Session Establishment](#name-privacy-leakage-before-sess){.section-name .selfRef} {#name-privacy-leakage-before-sess}

As mentioned earlier, communication between an RPC client and server
appears in the clear on the network prior to the establishment of a TLS
session. This cleartext information usually includes transport
connection handshake exchanges, the RPC NULL procedure probing support
for TLS, and the initial parts of TLS session establishment. [Appendix
C](https://www.rfc-editor.org/rfc/rfc8446#appendix-C){.relref} of
\[[RFC8446](#RFC8446){.xref}\] discusses precautions that can mitigate
exposure during the exchange of connection handshake information and TLS
certificate material that might enable attackers to track the RPC
client. Note that when PSK authentication is used, the PSK identifier is
exposed during the TLS handshake and can be used to track the RPC
client.[¶](#section-6.1.2-1){.pilcrow}

Any RPC traffic that appears on the network before a TLS session has
been established is vulnerable to monitoring or undetected modification.
A secure client implementation limits or prevents any RPC exchanges that
are not protected.[¶](#section-6.1.2-2){.pilcrow}

The exception to this edict is the initial RPC NULL procedure that acts
as a STARTTLS message, which cannot be protected. This RPC NULL
procedure contains no arguments or results, and the AUTH_TLS
authentication flavor it uses does not contain user information, so
there is negligible privacy impact from this
exception.[¶](#section-6.1.2-3){.pilcrow}
:::
:::
:::
:::

::: {#section_B9F8A982-CB0E-40FC-9460-680E89DB0001}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [TLS Identity Management on Clients](#name-tls-identity-management-on-){.section-name .selfRef} {#name-tls-identity-management-on-}

The goal of RPC-with-TLS is to hide the content of RPC requests while
they are in transit. RPC-with-TLS protocol by itself cannot protect
against exposure of a user\'s RPC requests to other users on the same
client.[¶](#section-6.2-1){.pilcrow}

Moreover, client implementations are free to transmit RPC requests for
more than one RPC user using the same TLS session. Depending on the
details of the client RPC implementation, this means that the client\'s
TLS credentials are potentially visible to every RPC user that shares a
TLS session. Privileged users may also be able to access this TLS
identity.[¶](#section-6.2-2){.pilcrow}

As a result, client implementations need to carefully segregate TLS
credentials so that local access to it is restricted to only the local
users that are authorized to perform operations on the remote RPC
server.[¶](#section-6.2-3){.pilcrow}
:::
:::

::: {#section_552B02A0-F19E-4B46-809C-672A6AE931A1}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Security Considerations for AUTH_SYS on TLS](#name-security-considerations-for){.section-name .selfRef} {#name-security-considerations-for}

Using a TLS-protected transport when the AUTH_SYS authentication flavor
is in use addresses several longstanding weaknesses in AUTH_SYS (as
detailed in [Appendix
A](#section_C7FB9DB5-5F4F-45AD-8BF7-74FFCA08BEBB){.xref}). TLS augments
AUTH_SYS by providing both integrity protection and confidentiality that
AUTH_SYS lacks. TLS protects data payloads, RPC headers, and user
identities against monitoring and alteration while in
transit.[¶](#section-6.3-1){.pilcrow}

TLS guards against in-transit insertion and deletion of RPC messages,
thus ensuring the integrity of the message stream between RPC client and
server. DTLS does not provide full message stream protection, but it
does enable receivers to reject nonparticipant messages. In particular,
transport-layer encryption plus peer authentication protects receiving
eXternal Data Representation (XDR) decoders from deserializing untrusted
data, a common coding vulnerability. However, these decoders would still
be exposed to untrusted input in the case of the compromise of a trusted
peer or Certification Authority.[¶](#section-6.3-2){.pilcrow}

The use of TLS enables strong authentication of the communicating RPC
peers, providing a degree of non-repudiation. When AUTH_SYS is used with
TLS, but the RPC client is unauthenticated, the RPC server still acts on
RPC requests for which there is no trustworthy authentication.
In-transit traffic is protected, but the RPC client itself can still
misrepresent user identity without server detection. TLS without
authentication is an improvement from AUTH_SYS without encryption, but
it leaves a critical security exposure.[¶](#section-6.3-3){.pilcrow}

In light of the above, when AUTH_SYS is used, the use of a TLS mutual
authentication mechanism is [RECOMMENDED]{.bcp14} to prove that the RPC
client is known to the RPC server. The server can then determine whether
the UIDs and GIDs in AUTH_SYS requests from that client can be accepted,
based on the authenticated identity of the
client.[¶](#section-6.3-4){.pilcrow}

The use of TLS does not enable RPC clients to detect compromise that
leads to the impersonation of RPC users. Also, there continues to be a
requirement that the mapping of 32-bit user and group ID values to user
identities is the same on both the RPC client and
server.[¶](#section-6.3-5){.pilcrow}
:::
:::

::: {#section_55D006D3-8CA6-4D7F-AF0D-BFB0FFEF7595}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [Best Security Policy Practices](#name-best-security-policy-practi){.section-name .selfRef} {#name-best-security-policy-practi}

RPC-with-TLS implementations and deployments are strongly encouraged to
adhere to the following policies to achieve the strongest possible
security with RPC-with-TLS.[¶](#section-6.4-1){.pilcrow}

-   [When using AUTH_NULL or AUTH_SYS, both peers are
    [RECOMMENDED]{.bcp14} to have DNSSEC TLSA records, keys with which
    to perform mutual peer authentication using one of the methods
    described in [Section
    5.2](#section_936921ED-67BB-46BF-B316-6740E07F6652){.xref}, and a
    security policy that requires mutual peer authentication and
    rejection of a connection when host authentication
    fails.[¶](#section-6.4-2.1){.pilcrow}]{#section-6.4-2.1}
-   [RPCSEC_GSS provides integrity and privacy services that are largely
    redundant when TLS is in use. These services [SHOULD]{.bcp14} be
    disabled in that
    case.[¶](#section-6.4-2.2){.pilcrow}]{#section-6.4-2.2}
:::
:::
:::
:::

::: {#section_7B126473-2A13-453B-9BCA-66BC11B7B018}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

::: {#section_2CD51855-CE40-4B8D-A220-F211C477964F}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [RPC Authentication Flavor](#name-rpc-authentication-flavor){.section-name .selfRef} {#name-rpc-authentication-flavor}

Following [Appendix
B](https://www.rfc-editor.org/rfc/rfc5531#appendix-B){.relref} of
\[[RFC5531](#RFC5531){.xref}\], an entry has been added to the \"RPC
Authentication Flavor Numbers\" registry. The purpose of the new
authentication flavor is to signal the use of TLS with RPC. This new
flavor is not a pseudo-flavor.[¶](#section-7.1-1){.pilcrow}

The fields in the new entry have been assigned as
follows:[¶](#section-7.1-2){.pilcrow}

[]{.break}

Identifier String:
:   AUTH_TLS[¶](#section-7.1-3.2){.pilcrow}
:   

Flavor Name:
:   TLS[¶](#section-7.1-3.4){.pilcrow}
:   

Value:
:   7[¶](#section-7.1-3.6){.pilcrow}
:   

Description:
:   Indicates support for RPC-with-TLS[¶](#section-7.1-3.8){.pilcrow}
:   

Reference:
:   RFC 9289[¶](#section-7.1-3.10){.pilcrow}
:   
:::
:::

::: {#section_58905D7A-06B1-4469-964A-DAC607DAC500}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [ALPN Identifier for SunRPC](#name-alpn-identifier-for-sunrpc){.section-name .selfRef} {#name-alpn-identifier-for-sunrpc}

Following [Section
6](https://www.rfc-editor.org/rfc/rfc7301#section-6){.relref} of
\[[RFC7301](#RFC7301){.xref}\], the following value has been allocated
in the \"TLS Application-Layer Protocol Negotiation (ALPN) Protocol
IDs\" registry. The \"sunrpc\" string identifies SunRPC when used over
TLS.[¶](#section-7.2-1){.pilcrow}

[]{.break}

Protocol:
:   SunRPC[¶](#section-7.2-2.2){.pilcrow}
:   

Identification Sequence:
:   0x73 0x75 0x6e 0x72 0x70 0x63
    (\"sunrpc\")[¶](#section-7.2-2.4){.pilcrow}
:   

Reference:
:   RFC 9289[¶](#section-7.2-2.6){.pilcrow}
:   
:::
:::

::: {#section_62E5E930-706A-4216-9A32-D7AC5952A507}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Object Identifier for PKIX Extended Key Usage](#name-object-identifier-for-pkix-){.section-name .selfRef} {#name-object-identifier-for-pkix-}

Per the Specification Required policy defined in [Section
4.6](https://www.rfc-editor.org/rfc/rfc8126#section-4.6){.relref} of
\[[RFC8126](#RFC8126){.xref}\], the following new values have been
registered in the \"SMI Security for PKIX Extended Key Purpose\"
registry (1.3.6.1.5.5.7.3) (see [Section
5.2.1.1](#section_685D3F88-94FF-4C91-8CCB-860DBA602B2F){.xref} and
[Appendix
B](#section_B08B45C1-1E10-4F7A-935B-1198BAF255C0){.xref}).[¶](#section-7.3-1){.pilcrow}

  Decimal   Description          Reference
  --------- -------------------- -----------
  33        id-kp-rpcTLSClient   RFC 9289
  34        id-kp-rpcTLSServer   RFC 9289

  : [Table 1](#table-1){.selfRef}
:::
:::

::: {#section_1FB29AC3-A737-4822-B396-D33919905567}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [Object Identifier for ASN.1 Module](#name-object-identifier-for-asn1-){.section-name .selfRef} {#name-object-identifier-for-asn1-}

Per the Specification Required policy defined in [Section
4.6](https://www.rfc-editor.org/rfc/rfc8126#section-4.6){.relref} of
\[[RFC8126](#RFC8126){.xref}\], the following new value has been
registered in the \"SMI Security for PKIX Module Identifier\" registry
(1.3.6.1.5.5.7.0) (see [Appendix
B](#section_B08B45C1-1E10-4F7A-935B-1198BAF255C0){.xref}).[¶](#section-7.4-1){.pilcrow}

  Decimal   Description              Reference
  --------- ------------------------ -----------
  105       id-mod-rpcWithTLS-2021   RFC 9289

  : [Table 2](#table-2){.selfRef}
:::
:::
:::
:::

::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC5056\]
:   [Williams, N.]{.refAuthor}, [\"On the Use of Channel Bindings to
    Secure Channels\"]{.refTitle}, [RFC 5056]{.seriesInfo}, [DOI
    10.17487/RFC5056]{.seriesInfo}, November 2007,
    \<<https://www.rfc-editor.org/info/rfc5056>\>.
:   

\[RFC5280\]
:   [Cooper, D.]{.refAuthor}, [Santesson, S.]{.refAuthor},
    [Farrell, S.]{.refAuthor}, [Boeyen, S.]{.refAuthor},
    [Housley, R.]{.refAuthor}, and [W. Polk]{.refAuthor}, [\"Internet
    X.509 Public Key Infrastructure Certificate and Certificate
    Revocation List (CRL) Profile\"]{.refTitle}, [RFC
    5280]{.seriesInfo}, [DOI 10.17487/RFC5280]{.seriesInfo}, May 2008,
    \<<https://www.rfc-editor.org/info/rfc5280>\>.
:   

\[RFC5531\]
:   [Thurlow, R.]{.refAuthor}, [\"RPC: Remote Procedure Call Protocol
    Specification Version 2\"]{.refTitle}, [RFC 5531]{.seriesInfo}, [DOI
    10.17487/RFC5531]{.seriesInfo}, May 2009,
    \<<https://www.rfc-editor.org/info/rfc5531>\>.
:   

\[RFC6125\]
:   [Saint-Andre, P.]{.refAuthor} and [J. Hodges]{.refAuthor},
    [\"Representation and Verification of Domain-Based Application
    Service Identity within Internet Public Key Infrastructure Using
    X.509 (PKIX) Certificates in the Context of Transport Layer Security
    (TLS)\"]{.refTitle}, [RFC 6125]{.seriesInfo}, [DOI
    10.17487/RFC6125]{.seriesInfo}, March 2011,
    \<<https://www.rfc-editor.org/info/rfc6125>\>.
:   

\[RFC7301\]
:   [Friedl, S.]{.refAuthor}, [Popov, A.]{.refAuthor},
    [Langley, A.]{.refAuthor}, and [E. Stephan]{.refAuthor},
    [\"Transport Layer Security (TLS) Application-Layer Protocol
    Negotiation Extension\"]{.refTitle}, [RFC 7301]{.seriesInfo}, [DOI
    10.17487/RFC7301]{.seriesInfo}, July 2014,
    \<<https://www.rfc-editor.org/info/rfc7301>\>.
:   

\[RFC7525\]
:   [Sheffer, Y.]{.refAuthor}, [Holz, R.]{.refAuthor}, and [P.
    Saint-Andre]{.refAuthor}, [\"Recommendations for Secure Use of
    Transport Layer Security (TLS) and Datagram Transport Layer Security
    (DTLS)\"]{.refTitle}, [BCP 195]{.seriesInfo}, [RFC
    7525]{.seriesInfo}, [DOI 10.17487/RFC7525]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7525>\>.
:   

\[RFC8126\]
:   [Cotton, M.]{.refAuthor}, [Leiba, B.]{.refAuthor}, and [T.
    Narten]{.refAuthor}, [\"Guidelines for Writing an IANA
    Considerations Section in RFCs\"]{.refTitle}, [BCP 26]{.seriesInfo},
    [RFC 8126]{.seriesInfo}, [DOI 10.17487/RFC8126]{.seriesInfo}, June
    2017, \<<https://www.rfc-editor.org/info/rfc8126>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8446\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   

\[RFC9147\]
:   [Rescorla, E.]{.refAuthor}, [Tschofenig, H.]{.refAuthor}, and [N.
    Modadugu]{.refAuthor}, [\"The Datagram Transport Layer Security
    (DTLS) Protocol Version 1.3\"]{.refTitle}, [RFC 9147]{.seriesInfo},
    [DOI 10.17487/RFC9147]{.seriesInfo}, April 2022,
    \<<https://www.rfc-editor.org/info/rfc9147>\>.
:   

\[RFC9266\]
:   [Whited, S.]{.refAuthor}, [\"Channel Bindings for TLS
    1.3\"]{.refTitle}, [RFC 9266]{.seriesInfo}, [DOI
    10.17487/RFC9266]{.seriesInfo}, July 2022,
    \<<https://www.rfc-editor.org/info/rfc9266>\>.
:   

\[X.509\]
:   [International Telecommunication Union]{.refAuthor}, [\"Information
    technology - Open Systems Interconnection - The Directory:
    Public-key and attribute certificate frameworks\"]{.refTitle},
    [ISO/IEC 9594-8]{.seriesInfo}, [ITU-T Recommendation
    X.509]{.seriesInfo}, October 2019.
:   

\[X.680\]
:   [ITU-T]{.refAuthor}, [\"Information technology - Abstract Syntax
    Notation One (ASN.1): Specification of basic notation\"]{.refTitle},
    [ITU-T Recommendation X.680]{.seriesInfo}, February 2021,
    \<<https://www.itu.int/rec/T-REC-X.680>\>.
:   

\[X.690\]
:   [ITU-T]{.refAuthor}, [\"Information technology - ASN.1 encoding
    rules: Specification of Basic Encoding Rules (BER), Canonical
    Encoding Rules (CER) and Distinguished Encoding Rules
    (DER)\"]{.refTitle}, [ITU-T Recommendation X.690]{.seriesInfo},
    February 2021, \<<https://www.itu.int/rec/T-REC-X.690>\>.
:   
:::

::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[RFC1833\]
:   [Srinivasan, R.]{.refAuthor}, [\"Binding Protocols for ONC RPC
    Version 2\"]{.refTitle}, [RFC 1833]{.seriesInfo}, [DOI
    10.17487/RFC1833]{.seriesInfo}, August 1995,
    \<<https://www.rfc-editor.org/info/rfc1833>\>.
:   

\[RFC2203\]
:   [Eisler, M.]{.refAuthor}, [Chiu, A.]{.refAuthor}, and [L.
    Ling]{.refAuthor}, [\"RPCSEC_GSS Protocol
    Specification\"]{.refTitle}, [RFC 2203]{.seriesInfo}, [DOI
    10.17487/RFC2203]{.seriesInfo}, September 1997,
    \<<https://www.rfc-editor.org/info/rfc2203>\>.
:   

\[RFC6698\]
:   [Hoffman, P.]{.refAuthor} and [J. Schlyter]{.refAuthor}, [\"The
    DNS-Based Authentication of Named Entities (DANE) Transport Layer
    Security (TLS) Protocol: TLSA\"]{.refTitle}, [RFC
    6698]{.seriesInfo}, [DOI 10.17487/RFC6698]{.seriesInfo}, August
    2012, \<<https://www.rfc-editor.org/info/rfc6698>\>.
:   

\[RFC6973\]
:   [Cooper, A.]{.refAuthor}, [Tschofenig, H.]{.refAuthor},
    [Aboba, B.]{.refAuthor}, [Peterson, J.]{.refAuthor},
    [Morris, J.]{.refAuthor}, [Hansen, M.]{.refAuthor}, and [R.
    Smith]{.refAuthor}, [\"Privacy Considerations for Internet
    Protocols\"]{.refTitle}, [RFC 6973]{.seriesInfo}, [DOI
    10.17487/RFC6973]{.seriesInfo}, July 2013,
    \<<https://www.rfc-editor.org/info/rfc6973>\>.
:   

\[RFC7258\]
:   [Farrell, S.]{.refAuthor} and [H. Tschofenig]{.refAuthor},
    [\"Pervasive Monitoring Is an Attack\"]{.refTitle}, [BCP
    188]{.seriesInfo}, [RFC 7258]{.seriesInfo}, [DOI
    10.17487/RFC7258]{.seriesInfo}, May 2014,
    \<<https://www.rfc-editor.org/info/rfc7258>\>.
:   

\[RFC7435\]
:   [Dukhovni, V.]{.refAuthor}, [\"Opportunistic Security: Some
    Protection Most of the Time\"]{.refTitle}, [RFC 7435]{.seriesInfo},
    [DOI 10.17487/RFC7435]{.seriesInfo}, December 2014,
    \<<https://www.rfc-editor.org/info/rfc7435>\>.
:   

\[RFC8166\]
:   [Lever, C., Ed.]{.refAuthor}, [Simpson, W.]{.refAuthor}, and [T.
    Talpey]{.refAuthor}, [\"Remote Direct Memory Access Transport for
    Remote Procedure Call Version 1\"]{.refTitle}, [RFC
    8166]{.seriesInfo}, [DOI 10.17487/RFC8166]{.seriesInfo}, June 2017,
    \<<https://www.rfc-editor.org/info/rfc8166>\>.
:   

\[RFC8167\]
:   [Lever, C.]{.refAuthor}, [\"Bidirectional Remote Procedure Call on
    RPC-over-RDMA Transports\"]{.refTitle}, [RFC 8167]{.seriesInfo},
    [DOI 10.17487/RFC8167]{.seriesInfo}, June 2017,
    \<<https://www.rfc-editor.org/info/rfc8167>\>.
:   

\[RFC8899\]
:   [Fairhurst, G.]{.refAuthor}, [Jones, T.]{.refAuthor},
    [Tüxen, M.]{.refAuthor}, [Rüngeler, I.]{.refAuthor}, and [T.
    Völker]{.refAuthor}, [\"Packetization Layer Path MTU Discovery for
    Datagram Transports\"]{.refTitle}, [RFC 8899]{.seriesInfo}, [DOI
    10.17487/RFC8899]{.seriesInfo}, September 2020,
    \<<https://www.rfc-editor.org/info/rfc8899>\>.
:   

\[RFC9110\]
:   [Fielding, R., Ed.]{.refAuthor}, [Nottingham, M., Ed.]{.refAuthor},
    and [J. Reschke, Ed.]{.refAuthor}, [\"HTTP Semantics\"]{.refTitle},
    [STD 97]{.seriesInfo}, [RFC 9110]{.seriesInfo}, [DOI
    10.17487/RFC9110]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9110>\>.
:   
:::
:::

::: {#section_C7FB9DB5-5F4F-45AD-8BF7-74FFCA08BEBB}
::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [Known Weaknesses of the AUTH_SYS Authentication Flavor](#name-known-weaknesses-of-the-aut){.section-name .selfRef} {#name-known-weaknesses-of-the-aut}

The ONC RPC protocol, as specified in \[[RFC5531](#RFC5531){.xref}\],
provides several modes of security, commonly referred to as
\"authentication flavors\". Some of these flavors provide much more than
an authentication service. We refer to these as authentication flavors,
security flavors, or simply, flavors. One of the earliest and most basic
flavors is AUTH_SYS, also known as AUTH_UNIX. [Appendix
A](https://www.rfc-editor.org/rfc/rfc5531#appendix-A){.relref} of
\[[RFC5531](#RFC5531){.xref}\] specifies
AUTH_SYS.[¶](#appendix-A-1){.pilcrow}

AUTH_SYS assumes that the RPC client and server both use POSIX-style
user and group identifiers (each user and group can be distinctly
represented as a 32-bit unsigned integer). It also assumes that the
client and server both use the same mapping of user and group to an
integer. One user ID, one primary group ID, and up to 16 supplemental
group IDs are associated with each RPC request. The combination of these
identifies the entity on the client that is making the
request.[¶](#appendix-A-2){.pilcrow}

A string identifies peers (hosts) in each RPC request.
\[[RFC5531](#RFC5531){.xref}\] does not specify any requirements for
this string other than that it is no longer than 255 octets. It does not
have to be the same from request to request. Also, it does not have to
match the DNS hostname of the sending host. For these reasons, even
though most implementations fill in their hostname in this field,
receivers typically ignore its content.[¶](#appendix-A-3){.pilcrow}

[Appendix A](https://www.rfc-editor.org/rfc/rfc5531#appendix-A){.relref}
of \[[RFC5531](#RFC5531){.xref}\] contains a brief explanation of
security considerations:[¶](#appendix-A-4){.pilcrow}

> It should be noted that use of this flavor of authentication does not
> guarantee any security for the users or providers of a service, in
> itself. The authentication provided by this scheme can be considered
> legitimate only when applications using this scheme and the network
> can be secured externally, and privileged transport addresses are used
> for the communicating end-points (an example of this is the use of
> privileged TCP/UDP ports in UNIX systems \-- note that not all systems
> enforce privileged transport address
> mechanisms).[¶](#appendix-A-5){.pilcrow}

It should be clear, therefore, that AUTH_SYS by itself (i.e., without
strong client authentication) offers little to no communication
security:[¶](#appendix-A-6){.pilcrow}

1.  [It does not protect the confidentiality or integrity of RPC
    requests, users, or payloads, relying instead on \"external\"
    security.[¶](#appendix-A-7.1){.pilcrow}]{#appendix-A-7.1}
2.  [It does not provide authentication of RPC peer machines, other than
    inclusion of an unprotected domain
    name.[¶](#appendix-A-7.2){.pilcrow}]{#appendix-A-7.2}
3.  [The use of 32-bit unsigned integers as user and group identifiers
    is problematic because these data types are not cryptographically
    signed or otherwise verified by any authority. In addition, the
    mapping of these integers to users and groups has to be consistent
    amongst a server and its cohort of
    clients.[¶](#appendix-A-7.3){.pilcrow}]{#appendix-A-7.3}
4.  [Because the user and group ID fields are not integrity protected,
    AUTH_SYS does not provide
    non-repudiation.[¶](#appendix-A-7.4){.pilcrow}]{#appendix-A-7.4}
:::
:::

::: {#section_B08B45C1-1E10-4F7A-935B-1198BAF255C0}
::: {#appendix-B .section}
## [Appendix B.](#appendix-B){.section-number .selfRef} [ASN.1 Module](#name-asn1-module){.section-name .selfRef} {#name-asn1-module}

The following module adheres to ASN.1 specifications
\[[X.680](#X.680){.xref}\] and
\[[X.690](#X.690){.xref}\].[¶](#appendix-B-1){.pilcrow}

::: {#appendix-B-2}
``` {.lang-asn.1 .sourcecode}
<CODE BEGINS>


RPCwithTLS-2021
  { iso(1) identified-organization(3) dod(6) internet(1)
  security(5) mechanisms(5) pkix(7) id-mod(0)
  id-mod-rpcWithTLS-2021(105) }

DEFINITIONS IMPLICIT TAGS ::=
BEGIN

-- OID Arc

id-kp OBJECT IDENTIFIER ::=
  { iso(1) identified-organization(3) dod(6) internet(1)
    security(5) mechanisms(5) pkix(7) kp(3) }

-- Extended Key Usage Values

id-kp-rpcTLSClient OBJECT IDENTIFIER ::= { id-kp 33 }
id-kp-rpcTLSServer OBJECT IDENTIFIER ::= { id-kp 34 }

END


<CODE ENDS>
```

[¶](#appendix-B-2){.pilcrow}
:::
:::
:::

::: {#section_4959412F-37AD-42B8-9169-D477148F81A8}
::: {#appendix-C .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

Special mention goes to [Charles Fisher]{.contact-name}, author of
[\"Encrypting NFSv4 with Stunnel
TLS\"](https://www.linuxjournal.com/content/encrypting-nfsv4-stunnel-tls).
His article inspired the mechanism described in the current
document.[¶](#appendix-C-1){.pilcrow}

Many thanks to [Benjamin Coddington]{.contact-name}, [Tigran
Mkrtchyan]{.contact-name}, and [Rick Macklem]{.contact-name} for their
work on prototype implementations and feedback on the current document.
Also, thanks to [Benjamin Kaduk]{.contact-name} for his expert guidance
on the use of PKIX and TLS and to [Russ Housley]{.contact-name} for his
ASN.1 expertise and for providing other proper finishing touches. In
addition, the authors thank the other members of the IESG for their
astute review comments. These contributors made this a significantly
better document.[¶](#appendix-C-2){.pilcrow}

Thanks to [Derrell Piper]{.contact-name} for numerous suggestions that
improved both this simple mechanism and the current document\'s
security-related discussion.[¶](#appendix-C-3){.pilcrow}

Many thanks to Transport Area Director [Magnus
Westerlund]{.contact-name} for his sharp questions and careful reading
of the final revisions of the current document. The text of [Section
5.1.2](#section_B8BF600E-96DC-4C82-AADF-D593826E9B75){.xref} is mostly
his contribution.[¶](#appendix-C-4){.pilcrow}

The authors are additionally grateful to [Bill Baker]{.contact-name},
[David Black]{.contact-name}, [Alan DeKok]{.contact-name}, [Lars
Eggert]{.contact-name}, [Olga Kornievskaia]{.contact-name}, [Greg
Marsden]{.contact-name}, [Alex McDonald]{.contact-name}, [Justin Mazzola
Paluska]{.contact-name}, [Tom Talpey]{.contact-name}, [Martin
Thomson]{.contact-name}, and [Nico Williams]{.contact-name} for their
input and support of this work.[¶](#appendix-C-5){.pilcrow}

Finally, special thanks to NFSV4 Working Group Chair and document
shepherd [David Noveck]{.contact-name}, NFSV4 Working Group Chairs
[Spencer Shepler]{.contact-name} and [Brian Pawlowski]{.contact-name},
and NFSV4 Working Group Secretary [Thomas Haynes]{.contact-name} for
their guidance and oversight.[¶](#appendix-C-6){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-D .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Trond Myklebust]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Hammerspace Inc.]{.org}
:::

::: {.left dir="auto"}
[4300 El Camino Real, Suite 105]{.street-address}
:::

::: {.left dir="auto"}
[Los Altos]{.locality}, [CA]{.region} [94022]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <trond.myklebust@hammerspace.com>
:::

::: {.left dir="auto"}
[Charles Lever ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Oracle Corporation]{.org}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <chuck.lever@oracle.com>
:::
:::
:::
