  RFC 8764              Apple\'s DNS LLQ   June 2020
  --------------------- ------------------ -----------
  Cheshire & Krochmal   Informational      \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Independent Submission

RFC:
:   [8764](https://www.rfc-editor.org/rfc/rfc8764){.eref}

Category:
:   Informational

Published:
:   June 2020

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    S. Cheshire
    :::

    ::: org
    Apple Inc.
    :::
    :::

    ::: author
    ::: author-name
    M. Krochmal
    :::

    ::: org
    Apple Inc.
    :::
    :::
:::

# RFC 8764 {#rfcnum}

# Apple\'s DNS Long-Lived Queries Protocol {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

Apple\'s DNS Long-Lived Queries (LLQ) is a mechanism for extending the
DNS protocol to support change notification, thus allowing clients to
learn about changes to DNS data without polling the server. From 2005
onwards, LLQ was implemented in Apple products including Mac OS X,
Bonjour for Windows, and AirPort wireless base stations. In 2020, the
LLQ protocol was superseded by the IETF Standards Track RFC 8765, \"DNS
Push Notifications\", which builds on experience gained with the LLQ
protocol to create a superior
replacement.[¶](#section-abstract-1){.pilcrow}

The existing LLQ protocol deployed and used from 2005 to 2020 is
documented here to give background regarding the operational experience
that informed the development of DNS Push Notifications, and to help
facilitate a smooth transition from LLQ to DNS Push
Notifications.[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for informational
purposes.[¶](#section-boilerplate.1-1){.pilcrow}

This is a contribution to the RFC Series, independently of any other RFC
stream. The RFC Editor has chosen to publish this document at its
discretion and makes no statement about its value for implementation or
deployment. Documents approved for publication by the RFC Editor are not
candidates for any level of Internet Standard; see Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8764>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Transition to DNS Push
        Notifications](#name-transition-to-dns-push-noti){.xref}[¶](#section-toc.1-1.1.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Conventions and Terminology Used in This
    Document](#name-conventions-and-terminology){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Mechanisms](#name-mechanisms){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Assigned
        Numbers](#name-assigned-numbers){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Opt-RR
        Format](#name-opt-rr-format){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [LLQ Address and Port
    Identification](#name-llq-address-and-port-identi){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [LLQ
    Setup](#name-llq-setup){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Setup Message
        Retransmission](#name-setup-message-retransmissio){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [LLQ Setup Four-Way
        Handshake](#name-llq-setup-four-way-handshak){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.5.2.2.2.1}
            [5.2.1](#section-5.2.1){.xref}.  [Setup
            Request](#name-setup-request){.xref}[¶](#section-toc.1-1.5.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.2}
            [5.2.2](#section-5.2.2){.xref}.  [Setup
            Challenge](#name-setup-challenge){.xref}[¶](#section-toc.1-1.5.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.3}
            [5.2.3](#section-5.2.3){.xref}.  [Challenge
            Response](#name-challenge-response){.xref}[¶](#section-toc.1-1.5.2.2.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.4}
            [5.2.4](#section-5.2.4){.xref}.  [ACK +
            Answers](#name-ack-answers){.xref}[¶](#section-toc.1-1.5.2.2.2.4.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Resource Record
        TTLs](#name-resource-record-ttls){.xref}[¶](#section-toc.1-1.5.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Event
    Responses](#name-event-responses){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Add
        Events](#name-add-events){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Remove
        Events](#name-remove-events){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Gratuitous Response
        Acknowledgments](#name-gratuitous-response-acknowl){.xref}[¶](#section-toc.1-1.6.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [LLQ Lease-Life
    Expiration](#name-llq-lease-life-expiration){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Refresh
        Request](#name-refresh-request){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [LLQ Refresh
        Acknowledgment](#name-llq-refresh-acknowledgment){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Server
        DoS](#name-server-dos){.xref}[¶](#section-toc.1-1.8.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Client Packet
        Storms](#name-client-packet-storms){.xref}[¶](#section-toc.1-1.8.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [8.3](#section-8.3){.xref}.  [Spoofing](#name-spoofing){.xref}[¶](#section-toc.1-1.8.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}

    -   ::: {#section-toc.1-1.10.2.1}
        [10.1](#section-10.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.10.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [10.2](#section-10.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.10.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [Appendix A](#section-appendix.a){.xref}.  [Problems with the LLQ
    Protocol](#name-problems-with-the-llq-proto){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.12}
    [](#section-appendix.b){.xref}[Acknowledgments](#name-acknowledgments){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.13}
    [](#section-appendix.c){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

In dynamic environments, DNS-based Service Discovery
\[[RFC6763](#RFC6763){.xref}\] benefits significantly from clients being
able to learn about changes to DNS information via a mechanism that is
both more timely and more efficient than simple polling. Such a
mechanism enables \"live browses\" that (a) learn when a new instance of
a service appears, (b) learn when an existing service instance
disappears from the network, and (c) allows clients to monitor status
changes to a service instance (e.g., printer ink levels). Multicast DNS
\[[RFC6762](#RFC6762){.xref}\] supports this natively. When a device on
the network publishes or deletes Multicast DNS records, these changes
are multicast to other hosts on the network. Those hosts deliver the
change notifications to interested clients (applications running on that
host). Hosts also send occasional queries to the network, in case
gratuitous announcements are not received due to packet loss, and to
detect records lost due to their publishers crashing or having become
disconnected from the network.[¶](#section-1-1){.pilcrow}

This document defines an Apple extension to unicast DNS that enables a
client to issue long-lived queries that allow a unicast DNS server to
notify clients about changes to DNS data. This is a more scalable and
practical solution than can be achieved by polling of the name server,
because a low polling rate could leave the client with stale
information, while a high polling rate would have an adverse impact on
the network and server.[¶](#section-1-2){.pilcrow}

The mechanism defined in this document is now being replaced by DNS Push
Notifications \[[RFC8765](#RFC8765){.xref}\] as explained in [Section
1.1](#trans){.xref}.[¶](#section-1-3){.pilcrow}

::: {#trans}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Transition to DNS Push Notifications](#name-transition-to-dns-push-noti){.section-name .selfRef} {#name-transition-to-dns-push-noti}

The LLQ protocol enjoyed over a decade of useful operation, enabling
timely live updates for the service discovery user interface in Apple\'s
Back to My Mac \[[RFC6281](#RFC6281){.xref}\]
service.[¶](#section-1.1-1){.pilcrow}

However, some problems were discovered, as described in [Appendix
A](#problems){.xref}. This operational experience with LLQ informed the
design of its IETF Standards Track successor, DNS Push Notifications
\[[RFC8765](#RFC8765){.xref}\]. Since no further work is being done on
the LLQ protocol, this LLQ specification will not be updated to remedy
these problems.[¶](#section-1.1-2){.pilcrow}

All existing LLQ implementations are [RECOMMENDED]{.bcp14} to migrate to
using DNS Push Notifications instead.[¶](#section-1.1-3){.pilcrow}

Existing LLQ servers are [RECOMMENDED]{.bcp14} to implement and support
DNS Push Notifications so that clients can begin migrating to the newer
protocol.[¶](#section-1.1-4){.pilcrow}

Existing LLQ clients are [RECOMMENDED]{.bcp14} to query for the
`_dns‑push‑tls._tcp.<zone>` SRV record first, and then only if DNS Push
Notifications fail, fall back to query for `_dns‑llq._udp.<zone>`
instead. Use of the `_dns‑llq._udp.<zone>` SRV record is described in
[Section 4](#address-port){.xref}.[¶](#section-1.1-5){.pilcrow}

This will cause clients to prefer the newer protocol when possible. It
is [RECOMMENDED]{.bcp14} that clients always attempt DNS Push
Notifications first for every new request, and only if that fails, then
fall back to using LLQ. Clients [SHOULD NOT]{.bcp14} record that a given
server only speaks LLQ and subsequently default to LLQ for that server,
since server software gets updated and even a server that speaks only
LLQ today may be updated to support DNS Push Notifications
tomorrow.[¶](#section-1.1-6){.pilcrow}

New client and server implementations are [RECOMMENDED]{.bcp14} to
support only DNS Push Notifications.[¶](#section-1.1-7){.pilcrow}
:::
:::
:::
:::

::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Conventions and Terminology Used in This Document](#name-conventions-and-terminology){.section-name .selfRef} {#name-conventions-and-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}
:::

::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Mechanisms](#name-mechanisms){.section-name .selfRef} {#name-mechanisms}

DNS Long-Lived Queries (LLQ) are implemented using the standard DNS
message format \[[RFC1035](#RFC1035){.xref}\] in conjunction with an
EDNS(0) OPT pseudo‑RR \[[RFC6891](#RFC6891){.xref}\] with a new
OPTION‑CODE and OPTION‑DATA format specified here. Encoding the LLQ
request in an OPT pseudo‑RR allows for implementation of LLQ with
minimal modification to a name server\'s front end. If a DNS query
containing an LLQ option is sent to a server that does not implement
LLQ, a server that complies with the EDNS(0) specification
\[[RFC6891](#RFC6891){.xref}\] will silently ignore the unrecognized
option and answer the request as a normal DNS query without establishing
any long-lived state and without returning an LLQ option in its
response. If a DNS query containing an LLQ option is sent to a server
that does not implement EDNS(0) at all, the server may silently ignore
the EDNS(0) OPT pseudo‑RR or it may return a nonzero RCODE. However, in
practice, this issue is mostly theoretical, since having a zone\'s
\_dns‑llq.\_udp.\<zone> SRV record target a host that does not implement
LLQ is a configuration error.[¶](#section-3-1){.pilcrow}

Note that this protocol is designed for data set sizes of a few dozen
resource records at most and change rates no more than once every 10
seconds on average. Data sets that frequently exceed a single IP packet,
or that experience a rapid change rate, may have undesirable performance
implications.[¶](#section-3-2){.pilcrow}

::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Assigned Numbers](#name-assigned-numbers){.section-name .selfRef} {#name-assigned-numbers}

This section describes constants used in this
document.[¶](#section-3.1-1){.pilcrow}

-   ::: {#section-3.1-2.1}
    EDNS(0) OPTION‑CODE (recorded with
    IANA):[¶](#section-3.1-2.1.1){.pilcrow}

    -   ::: {#section-3.1-2.1.2.1}

        LLQ
        :   1[¶](#section-3.1-2.1.2.1.1.2){.pilcrow}
        :   
        :::
    :::

-   [LLQ‑PORT 5352 (recorded with
    IANA)[¶](#section-3.1-2.2){.pilcrow}]{#section-3.1-2.2}

-   ::: {#section-3.1-2.3}
    LLQ Opcodes (specific to this LLQ EDNS(0)
    Option):[¶](#section-3.1-2.3.1){.pilcrow}

    -   ::: {#section-3.1-2.3.2.1}

        LLQ‑SETUP
        :   1[¶](#section-3.1-2.3.2.1.1.2){.pilcrow}
        :   

        LLQ‑REFRESH
        :   2[¶](#section-3.1-2.3.2.1.1.4){.pilcrow}
        :   

        LLQ‑EVENT
        :   3[¶](#section-3.1-2.3.2.1.1.6){.pilcrow}
        :   
        :::
    :::

-   ::: {#section-3.1-2.4}
    LLQ Error Codes (specific to this LLQ EDNS(0)
    Option):[¶](#section-3.1-2.4.1){.pilcrow}

    -   ::: {#section-3.1-2.4.2.1}

        NO-ERROR
        :   0[¶](#section-3.1-2.4.2.1.1.2){.pilcrow}
        :   

        SERV-FULL
        :   1[¶](#section-3.1-2.4.2.1.1.4){.pilcrow}
        :   

        STATIC
        :   2[¶](#section-3.1-2.4.2.1.1.6){.pilcrow}
        :   

        FORMAT-ERR
        :   3[¶](#section-3.1-2.4.2.1.1.8){.pilcrow}
        :   

        NO-SUCH-LLQ
        :   4[¶](#section-3.1-2.4.2.1.1.10){.pilcrow}
        :   

        BAD-VERS
        :   5[¶](#section-3.1-2.4.2.1.1.12){.pilcrow}
        :   

        UNKNOWN-ERR
        :   6[¶](#section-3.1-2.4.2.1.1.14){.pilcrow}
        :   
        :::
    :::
:::

::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Opt-RR Format](#name-opt-rr-format){.section-name .selfRef} {#name-opt-rr-format}

As required by the EDNS(0) specification \[[RFC6891](#RFC6891){.xref}\],
all OPT pseudo‑RRs used in LLQs are formatted as
follows:[¶](#section-3.2-1){.pilcrow}

[]{#name-opt-rrs-used-in-llqs}

::: {#OPT-RRs}
  Field Name   Field Type     Description
  ------------ -------------- -------------------------
  NAME         domain name    MUST be 0 (root domain)
  TYPE         u_int16_t      OPT (41)
  CLASS        u_int16_t      0\*
  TTL          u_int32_t      0
  RDLEN        u_int16_t      length of all RDATA
  RDATA        octet stream   (see below)

  : [Table 1](#table-1){.selfRef}: [OPT-RRs Used in
  LLQs](#name-opt-rrs-used-in-llqs){.selfRef}
:::

\* The CLASS field indicates, as per the EDNS(0) specification
\[[RFC6891](#RFC6891){.xref}\], the sender\'s UDP payload size. However,
clients and servers are not required to determine their reassembly
buffer size, path MTU, etc., to support LLQ. Thus, the sender of an LLQ
Request or Response [MAY]{.bcp14} set the CLASS field to 0. The
recipient [MUST]{.bcp14} ignore the class field if it is set to
0.[¶](#section-3.2-3){.pilcrow}

The RDATA of an EDNS(0) OPT pseudo‑RR consists of zero or more options
of the form { OPTION‑CODE, OPTION‑LENGTH, OPTION‑DATA } packed together,
with the RDLEN field set accordingly to indicate the total size. An LLQ
OPTION is illustrated below. An EDNS(0) OPT pseudo‑RR may contain zero
or more LLQ OPTIONS in addition to zero or more other EDNS(0)
options.[¶](#section-3.2-4){.pilcrow}

[]{#name-llq-option}

::: {#LLQ-OPT-FORMAT}
  Field Name      Field Type   Description
  --------------- ------------ ----------------------------------------------
  OPTION-CODE     u_int16_t    LLQ (1)
  OPTION-LENGTH   u_int16_t    Length of following fields (18)
  LLQ-VERSION     u_int16_t    Version of LLQ protocol implemented
  LLQ-OPCODE      u_int16_t    Identifies LLQ operation
  LLQ-ERROR       u_int16_t    Identifies LLQ errors
  LLQ-ID          u_int64_t    Identifier for an LLQ
  LLQ-LEASE       u_int32_t    Requested or granted life of LLQ, in seconds

  : [Table 2](#table-2){.selfRef}: [LLQ
  OPTION](#name-llq-option){.selfRef}
:::

The size and meaning of the OPTION‑CODE and OPTION‑LENGTH fields are as
described in the EDNS(0) specification \[[RFC6891](#RFC6891){.xref}\].
The remainder of the fields comprise the OPTION‑DATA of the EDNS(0) LLQ
OPTION. Since for LLQ the OPTION‑DATA is a fixed size, in EDNS(0) LLQ
OPTIONS the OPTION‑LENGTH field always has the value
18.[¶](#section-3.2-6){.pilcrow}

In keeping with Internet convention, all multi-byte numeric quantities
(u_int16_t, u_int32_t, and u_int64_t) are represented in big endian byte
order (most significant byte first).[¶](#section-3.2-7){.pilcrow}
:::
:::

::: {#address-port}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [LLQ Address and Port Identification](#name-llq-address-and-port-identi){.section-name .selfRef} {#name-llq-address-and-port-identi}

The client requires a mechanism to determine to which server it should
send LLQ operations.[¶](#section-4-1){.pilcrow}

Additionally, some firewalls block direct communication with a name
server on port 53 to avoid spoof responses. However, this direct
communication is necessary for LLQs. Thus, servers [MAY]{.bcp14} listen
for LLQs on a different port (typically 5352). Clients, therefore, also
need a mechanism to determine to which port to send LLQ
operations.[¶](#section-4-2){.pilcrow}

The client determines the server responsible for a given LLQ much as a
client determines to which server to send a DNS dynamic update. The
client begins by sending a standard DNS query for the name of the LLQ,
with type SOA. If the record exists, then the server [MUST]{.bcp14}
answer with that SOA record in the Answer section. If a record of type
SOA with the LLQ name does not exist, then the server [SHOULD]{.bcp14}
include an SOA record for that name\'s zone in the Authority section.
For example, a query for \"\_ftp.\_tcp.example.com\" with type SOA, when
there is no SOA record with that name, might return an SOA record named
\"example.com\" in the Authority section. If the named SOA record does
not exist and the server fails to include the enclosing SOA record in
the Authority section, the client strips the leading label from the name
and tries again, repeating until an answer is
received.[¶](#section-4-3){.pilcrow}

This iterative zone apex discovery algorithm is described in more detail
in the DNS Push Notifications specification
\[[RFC8765](#RFC8765){.xref}\].[¶](#section-4-4){.pilcrow}

Upon learning the zone apex (SOA), the client then constructs and sends
an SRV query for the name, \"\_dns‑llq.\_udp.\<zone>\",
e.g., \"\_dns‑llq.\_udp.example.com\".[¶](#section-4-5){.pilcrow}

An authoritative server for a zone implementing LLQ [MUST]{.bcp14}
answer with an SRV record \[[RFC2782](#RFC2782){.xref}\] for this name.
The SRV RDATA is as follows:[¶](#section-4-6){.pilcrow}

[]{#name-srv-rdata}

::: {#SRV-RDATA}
  ---------- ------------------------------------------------------
  PRIORITY   typically 0
  WEIGHT     typically 0
  PORT       typically 53 or 5352
  TARGET     name of server providing LLQs for the requested zone
  ---------- ------------------------------------------------------

  : [Table 3](#table-3){.selfRef}: [SRV
  RDATA](#name-srv-rdata){.selfRef}
:::

The server [SHOULD]{.bcp14} include the address record(s) for the target
host in the Additional section of the
response.[¶](#section-4-8){.pilcrow}

If the server does not include the target host\'s address record(s) in
the Additional section, the client [SHOULD]{.bcp14} query explicitly for
the address record(s) with the name of the SRV
target.[¶](#section-4-9){.pilcrow}

The client [MUST]{.bcp14} send all LLQ requests, refreshes, and
acknowledgments to the name server specified in the SRV target, at the
address contained in the address record for that target. Note that the
queries described in this section (including those for SOA and SRV
records) [MAY]{.bcp14} be sent to an intermediate DNS recursive resolver
\-- they need not be sent directly to the name
server.[¶](#section-4-10){.pilcrow}

If, on issuing the SRV query, the client receives a negative response
indicating that the SRV record does not exist, the client
[SHOULD]{.bcp14} conclude that the zone does not support LLQ. The client
then [SHOULD NOT]{.bcp14} send an LLQ request for the desired name,
instead utilizing the behavior for LLQ-unaware servers described in
[Section 5](#llq-setup){.xref}, \"[LLQ
Setup](#llq-setup){.xref}\".[¶](#section-4-11){.pilcrow}

Servers should send all messages to the source address and port of the
LLQ setup message received from the client.[¶](#section-4-12){.pilcrow}
:::
:::

::: {#llq-setup}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [LLQ Setup](#name-llq-setup){.section-name .selfRef} {#name-llq-setup}

An LLQ is initiated by a client and is completed via a four-way
handshake. This handshake provides resilience to packet loss,
demonstrates client reachability, and reduces denial-of-service attack
opportunities (see [Section 8](#security-considerations){.xref},
\"[Security
Considerations](#security-considerations){.xref}\").[¶](#section-5-1){.pilcrow}

::: {#setup-message-retransmission}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Setup Message Retransmission](#name-setup-message-retransmissio){.section-name .selfRef} {#name-setup-message-retransmissio}

LLQ Setup Requests and Responses sent by the client [SHOULD]{.bcp14} be
retransmitted if no acknowledgments are received. The client
[SHOULD]{.bcp14} retry up to two more times (for a total of 3 attempts)
before considering the server down or unreachable. The client
[MUST]{.bcp14} wait at least 2 seconds before the first retransmission
and 4 seconds between the first and second retransmissions. The client
[SHOULD]{.bcp14} listen for a response for at least 8 seconds after the
3rd attempt before considering the server down or unreachable. Upon
determining a server to be down, a client [MAY]{.bcp14} periodically
attempt to re-initiate an LLQ setup at a rate of not more than once per
hour.[¶](#section-5.1-1){.pilcrow}

Servers [MUST NOT]{.bcp14} retransmit acknowledgments that do not
generate responses from the client. Retransmission in setup is client
driven, freeing servers from maintaining timers for incomplete LLQ
setups. If servers receive duplicate messages from clients (perhaps due
to the loss of the server\'s responses mid-flight), the server
[MUST]{.bcp14} resend its reply (possibly modifying the LLQ‑LEASE as
described in [Section 5.2.4](#ack-answers){.xref}, \"[ACK +
Answers](#ack-answers){.xref}\").[¶](#section-5.1-2){.pilcrow}

Servers [MUST NOT]{.bcp14} garbage collect LLQs that fail to complete
the four-way handshake until the initially granted LLQ‑LEASE has
elapsed.[¶](#section-5.1-3){.pilcrow}
:::
:::

::: {#four-way-handshake}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [LLQ Setup Four-Way Handshake](#name-llq-setup-four-way-handshak){.section-name .selfRef} {#name-llq-setup-four-way-handshak}

The four phases of the handshake include:[¶](#section-5.2-1){.pilcrow}

-   ::: {#section-5.2-2.1}

    1\) Setup Request
    :   client to server, identifies LLQ(s)
        requested[¶](#section-5.2-2.1.1.2){.pilcrow}
    :   

    2\) Setup Challenge
    :   server to client, provides unique identifiers for successful
        requested LLQs, and error(s) for unsuccessful requested
        LLQs.[¶](#section-5.2-2.1.1.4){.pilcrow}
    :   

    3\) Challenge Response
    :   client to server, echoes identifier(s), demonstrating client\'s
        reachability and willingness to
        participate[¶](#section-5.2-2.1.1.6){.pilcrow}
    :   

    4\) ACK + Answers
    :   server to client, confirms setup and provides initial
        answers[¶](#section-5.2-2.1.1.8){.pilcrow}
    :   
    :::

::: {#setup-request}
::: {#section-5.2.1 .section}
#### [5.2.1.](#section-5.2.1){.section-number .selfRef} [Setup Request](#name-setup-request){.section-name .selfRef} {#name-setup-request}

A request for an LLQ is formatted like a standard DNS query but with an
OPT pseudo‑RR containing LLQ metadata in its Additional section. LLQ
Setup Requests are identified by the LLQ‑SETUP opcode and a zero‑valued
LLQ‑ID.[¶](#section-5.2.1-1){.pilcrow}

The request [MAY]{.bcp14} contain multiple questions to set up multiple
LLQs. A Setup Request consisting of multiple questions [MUST]{.bcp14}
contain multiple LLQ OPTIONS, one per question, with the LLQ OPTIONS in
the same order as the questions they correspond to (i.e., the first LLQ
OPTION corresponds to the first question, the second LLQ OPTION
corresponds to the second question, etc.). If requesting multiple LLQs,
clients [SHOULD]{.bcp14} request the same LLQ‑LEASE for each LLQ.
Requests over UDP [MUST NOT]{.bcp14} contain multiple questions if doing
so would cause the message to exceed a single IP
packet.[¶](#section-5.2.1-2){.pilcrow}

A client [MUST NOT]{.bcp14} request multiple identical LLQs (i.e.,
containing the same qname/type/class) from the same source IP address
and port. This requirement is to avoid unnecessary load on servers. In
the case of multiple independent client implementations that may run on
the same device without knowledge of each other, it is allowable if they
by chance send LLQ requests for the same qname/type/class. These
independent implementations on the same client will be using different
source ports. Likewise, to the server, multiple independent clients
behind the same NAT gateway will appear as if they were multiple
independent clients using different ports on the same host, and this is
also allowable.[¶](#section-5.2.1-3){.pilcrow}

The query [MUST NOT]{.bcp14} be for record type ANY (255), class ANY
(255), or class NONE (0).[¶](#section-5.2.1-4){.pilcrow}

[]{#name-setup-request-llq-option-fo}

::: {#OPT-RR-LLQ}
  Field Name      Field Type   Description
  --------------- ------------ ------------------------------------------------------
  OPTION-CODE     u_int16_t    LLQ (1)
  OPTION-LENGTH   u_int16_t    Length of following fields (18)
  LLQ-VERSION     u_int16_t    Version of LLQ protocol implemented by requester (1)
  LLQ-OPCODE      u_int16_t    LLQ-SETUP (1)
  LLQ-ERROR       u_int16_t    NO-ERROR (0)
  LLQ-ID          u_int64_t    0
  LLQ-LEASE       u_int32_t    Desired life of LLQ request

  : [Table 4](#table-4){.selfRef}: [Setup Request LLQ OPTION
  Format](#name-setup-request-llq-option-fo){.selfRef}
:::

The Setup Request LLQ OPTION [MUST]{.bcp14} be repeated once for each
additional query in the Question section.[¶](#section-5.2.1-6){.pilcrow}
:::
:::

::: {#setup-challenge}
::: {#section-5.2.2 .section}
#### [5.2.2.](#section-5.2.2){.section-number .selfRef} [Setup Challenge](#name-setup-challenge){.section-name .selfRef} {#name-setup-challenge}

Upon receiving an LLQ Setup Request, a server implementing LLQs will
send a Setup Challenge to the requester (client). An LLQ Setup Challenge
is a DNS response, with the DNS message ID matching that of the Setup
Request, and with all questions contained in the Setup Request present
in the Question section of the response. Additionally, the challenge
contains a single OPT pseudo‑RR with an LLQ OPTION for each LLQ request,
indicating the success or failure of each request. The LLQ OPTIONS
[MUST]{.bcp14} be in the same order as the questions they correspond to.
Note that in a Setup Request containing multiple questions, some LLQs
may succeed while others may fail.[¶](#section-5.2.2-1){.pilcrow}

[]{#name-setup-challenge-llq-option-}

::: {#CHALLENGE-OPT-RR-DATA}
  Field Name      Field Type   Description
  --------------- ------------ ---------------------------------------------------
  OPTION-CODE     u_int16_t    LLQ (1)
  OPTION-LENGTH   u_int16_t    Length of following fields (18)
  LLQ-VERSION     u_int16_t    Version of LLQ protocol implemented in server (1)
  LLQ-OPCODE      u_int16_t    LLQ-SETUP (1)
  LLQ-ERROR       u_int16_t    \[As Appropriate\]
  LLQ-ID          u_int64_t    \[As Appropriate\]
  LLQ-LEASE       u_int32_t    \[As Appropriate\]

  : [Table 5](#table-5){.selfRef}: [Setup Challenge LLQ OPTION
  Format](#name-setup-challenge-llq-option-){.selfRef}
:::

The Setup Challenge LLQ OPTION [MUST]{.bcp14} be repeated once for each
query in the Questions section of the Setup Challenge. Further details
for LLQ‑ERROR, LLQ‑ID and LLQ‑LEASE are given
below.[¶](#section-5.2.2-3){.pilcrow}

LLQ‑ERROR:[¶](#section-5.2.2-4){.pilcrow}

-   ::: {#section-5.2.2-5.1}

    NO-ERROR:
    :   The LLQ Setup Request was
        successful.[¶](#section-5.2.2-5.1.1.2){.pilcrow}
    :   

    FORMAT-ERR:
    :   The LLQ was improperly formatted. Note that if the rest of the
        DNS message is properly formatted, the DNS header error code
        [MUST NOT]{.bcp14} include a format error code, since to do so
        would cause ambiguity between the case where a client sends a
        valid LLQ Setup Request to a server that does not understand LLQ
        and the case where a client sends a malformed LLQ Setup Request
        to a server that does understand
        LLQ.[¶](#section-5.2.2-5.1.1.4){.pilcrow}
    :   

    SERV-FULL:
    :   The server cannot grant the LLQ request because it is overloaded
        or the request exceeds the server\'s rate limit (see [Section
        8](#security-considerations){.xref}, [Security
        Considerations](#security-considerations){.xref}). Upon
        returning this error, the server [MUST]{.bcp14} include in the
        LLQ-LEASE field a time interval, in seconds, after which the
        client may retry the LLQ
        Setup.[¶](#section-5.2.2-5.1.1.6){.pilcrow}
    :   

    STATIC:
    :   The data for this name and type is not expected to change
        frequently, and the server, therefore, does not support the
        requested LLQ. The client [MUST]{.bcp14} honor the resource
        record TTLs returned and [MUST NOT]{.bcp14} poll sooner than
        indicated by those TTLs, nor should it retry the LLQ Setup for
        this name and type.[¶](#section-5.2.2-5.1.1.8){.pilcrow}
    :   

    BAD-VERS:
    :   The protocol version specified in the client\'s Setup Request is
        not supported by the
        server.[¶](#section-5.2.2-5.1.1.10){.pilcrow}
    :   

    UNKNOWN-ERR:
    :   The LLQ was not granted for some other reason not covered by the
        preceding error code
        values.[¶](#section-5.2.2-5.1.1.12){.pilcrow}
    :   
    :::

LLQ‑ID:
:   On success, a random number generated by the server that is unique
    on the server for the requested name/type/class. The LLQ‑ID
    [SHOULD]{.bcp14} be an unpredictable random number. A possible
    method of allocating LLQ‑IDs with minimal bookkeeping would be to
    store the time, in seconds since the Epoch, in the high 32 bits of
    the field, and a cryptographically generated 32-bit random integer
    in the low 32 bits.[¶](#section-5.2.2-6.2){.pilcrow}
:   

:   On error, the LLQ‑ID is set to 0.[¶](#section-5.2.2-6.4){.pilcrow}
:   

LLQ‑LEASE:
:   On success, the actual life of the LLQ, in seconds. Value may be
    greater than, less than, or equal to the value requested by the
    client, as per the server administrator\'s policy. The server
    [MAY]{.bcp14} discard the LLQ after this LLQ‑LEASE expires unless
    the LLQ has been renewed by the client (see [Section
    7](#LLQ-LLE){.xref}, \"[LLQ Lease-Life
    Expiration](#LLQ-LLE){.xref}\"). The server [MUST NOT]{.bcp14}
    generate events (see [Section 6](#event-responses){.xref}, \"[Event
    Responses](#event-responses){.xref}\") for expired
    LLQs.[¶](#section-5.2.2-6.6){.pilcrow}
:   

:   On SERV‑FULL error, LLQ‑LEASE [MUST]{.bcp14} be set to a time
    interval, in seconds, after which the client may retry the LLQ
    Setup.[¶](#section-5.2.2-6.8){.pilcrow}
:   

:   On other errors, the LLQ‑LEASE [MUST]{.bcp14} be set to
    0.[¶](#section-5.2.2-6.10){.pilcrow}
:   
:::
:::

::: {#challenge-response}
::: {#section-5.2.3 .section}
#### [5.2.3.](#section-5.2.3){.section-number .selfRef} [Challenge Response](#name-challenge-response){.section-name .selfRef} {#name-challenge-response}

Upon issuing a Setup Request, a client listens for a Setup Challenge
([Section 5.2.2](#setup-challenge){.xref}) retransmitting the Setup
Request as necessary ([Section
5.1](#setup-message-retransmission){.xref}). After receiving a
successful Setup Challenge, the client [SHOULD]{.bcp14} send a Challenge
Response to the server. This Challenge Response is a DNS request with
questions as in the Setup Request and Setup Challenge, and a single OPT
pseudo‑RR in the Additional section, with the LLQ OPTIONS corresponding
to the LLQ OPTIONS contained in the Setup Challenge (i.e., echoing, for
each LLQ OPTION, the random LLQ‑ID and the granted LLQ‑LEASE). If the
Challenge Response contains multiple questions, the first question
[MUST]{.bcp14} correspond to the first LLQ OPTION,
etc.[¶](#section-5.2.3-1){.pilcrow}

If the Setup Request for a particular LLQ fails with a STATIC error, the
client [MUST NOT]{.bcp14} poll the server for that LLQ. The client
[SHOULD]{.bcp14} honor the resource record TTLs contained in the
response.[¶](#section-5.2.3-2){.pilcrow}

If a Setup Request fails with a SERV‑FULL error, the client
[MAY]{.bcp14} retry the LLQ Setup Request ([Section
5.2.1](#setup-request){.xref}) after the time indicated in the LLQ‑LEASE
field.[¶](#section-5.2.3-3){.pilcrow}

If the Setup Request fails with an error other than STATIC or SERV‑FULL,
or the server is determined not to support LLQ (i.e., the client
receives a DNS response with a nonzero RCODE, or a DNS response
containing no LLQ option), the client [MAY]{.bcp14} poll the server
periodically with standard DNS queries, inferring Add and Remove Events
(see [Section 6](#event-responses){.xref}, \"Event Responses\") by
comparing answers to these queries. The client [SHOULD NOT]{.bcp14} poll
more than once every 15 minutes for a given query. The client [MUST
NOT]{.bcp14} poll if it receives a STATIC error code in the
acknowledgment.[¶](#section-5.2.3-4){.pilcrow}
:::
:::

::: {#ack-answers}
::: {#section-5.2.4 .section}
#### [5.2.4.](#section-5.2.4){.section-number .selfRef} [ACK + Answers](#name-ack-answers){.section-name .selfRef} {#name-ack-answers}

Upon receiving a correct Challenge Response, a server [MUST]{.bcp14}
return an acknowledgment, completing the LLQ setup, and provide all
current answers to the question(s).[¶](#section-5.2.4-1){.pilcrow}

To acknowledge a successful Challenge Response, i.e., a Challenge
Response in which the LLQ‑ID and LLQ‑LEASE echoed by the client match
the values issued by the server, the server [MUST]{.bcp14} send a DNS
response containing all available answers to the question(s) contained
in the original Setup Request, along with all additional resource
records appropriate for those answers in the Additional section. The
Additional section also contains LLQ OPTIONS formatted as
follows:[¶](#section-5.2.4-2){.pilcrow}

[]{#name-successful-ack-answers-llq-}

::: {#SUCCESSFUL-ACK-ANSWERS-OPT-RR-RDATA}
  Field Name      Field Type   Description
  --------------- ------------ -----------------------------------------------------
  OPTION-CODE     u_int16_t    LLQ (1)
  OPTION-LENGTH   u_int16_t    Length of following fields (18)
  LLQ-VERSION     u_int16_t    Version of LLQ protocol implemented in server (1)
  LLQ-OPCODE      u_int16_t    LLQ-SETUP (1)
  LLQ-ERROR       u_int16_t    NO-ERROR (0)
  LLQ-ID          u_int64_t    Originally granted ID, echoed in client\'s Response
  LLQ-LEASE       u_int32_t    Remaining life of LLQ, in seconds

  : [Table 6](#table-6){.selfRef}: [Successful ACK + Answers LLQ OPTION
  Format](#name-successful-ack-answers-llq-){.selfRef}
:::

If there is a significant delay in receiving a Challenge Response, or
multiple Challenge Responses are issued (possibly because they were lost
en route to the client, causing the client to resend the Challenge
Response), the server [MAY]{.bcp14} decrement the LLQ‑LEASE by the time
elapsed since the Setup Challenge was initially
issued.[¶](#section-5.2.4-4){.pilcrow}

If the setup is completed over UDP and all initially available answers
to the question(s), additional records, and the OPT pseudo‑RR do not fit
in a single IP packet, some or all additional records (excluding the OPT
pseudo‑RR) [MUST]{.bcp14} be omitted. If, after omission of all
additional records, the answers still do not fit in a single message,
answers [MUST]{.bcp14} be removed until the message fits in a single IP
packet. These answers not delivered in the ACK + Answers [MUST]{.bcp14}
be delivered without undue delay to the client via Add Events ([Section
6](#event-responses){.xref}, \"[Event
Responses](#event-responses){.xref}\").[¶](#section-5.2.4-5){.pilcrow}
:::
:::
:::
:::

::: {#resource-record-ttls}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Resource Record TTLs](#name-resource-record-ttls){.section-name .selfRef} {#name-resource-record-ttls}

The TTLs of resource records contained in answers to successful LLQs
[SHOULD]{.bcp14} be ignored by the client. The client [MAY]{.bcp14}
cache LLQ answers until the client receives a gratuitous announcement
(see [Section 6](#event-responses){.xref}, \"[Event
Responses](#event-responses){.xref}\") indicating that the answer to the
LLQ has changed. The client [SHOULD NOT]{.bcp14} cache answers after the
LLQs LLQ‑LEASE expires without being refreshed (see [Section
7](#LLQ-LLE){.xref}, \"LLQ Lease-Life Expiration\"). If an LLQ request
fails, the client [SHOULD NOT]{.bcp14} cache answers for a period longer
than the client\'s polling interval.[¶](#section-5.3-1){.pilcrow}

Note that resource records intended specifically to be transmitted via
LLQs (e.g., DNS-based Service Discovery resource records) may have
unusually short TTLs. This is because it is assumed that the records may
change frequently, and that a client\'s cache coherence will be
maintained via the LLQ and gratuitous responses. Short TTLs prevent
stale information from residing in intermediate DNS recursive resolvers
that are not LLQ aware.[¶](#section-5.3-2){.pilcrow}

TTLs of resource records included in the Additional section of an LLQ
response (which do not directly answer the LLQ) [SHOULD]{.bcp14} be
honored by the client.[¶](#section-5.3-3){.pilcrow}
:::
:::
:::
:::

::: {#event-responses}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Event Responses](#name-event-responses){.section-name .selfRef} {#name-event-responses}

When a change (\"event\") occurs to a name server\'s zone, the server
[MUST]{.bcp14} check if the new or deleted resource records answer any
LLQs. If so, the changes [MUST]{.bcp14} be communicated to the LLQ
requesters in the form of a gratuitous DNS response sent to the client,
with the relevant question(s) in the Question section, and the
corresponding answers in the Answer section. The response also includes
an OPT pseudo‑RR in the Additional section. This OPT pseudo‑RR contains,
in its RDATA, an LLQ OPTION for each LLQ being answered in the message.
Each LLQ OPTION must include the LLQ‑ID. This reduces the potential for
spoof events being sent to a client.[¶](#section-6-1){.pilcrow}

[]{#name-event-response-llq-option-f}

::: {#EVENT-RESPONSE-OPT-RR-RDATA}
  Field Name      Field Type   Description
  --------------- ------------ ---------------------------------------------------
  OPTION-CODE     u_int16_t    LLQ (1)
  OPTION-LENGTH   u_int16_t    Length of following fields (18)
  LLQ-VERSION     u_int16_t    Version of LLQ protocol implemented in server (1)
  LLQ-OPCODE      u_int16_t    LLQ-EVENT (3)
  LLQ-ERROR       u_int16_t    NO-ERROR (0)
  LLQ-ID          u_int64_t    \[As Appropriate\]
  LLQ-LEASE       u_int32_t    0

  : [Table 7](#table-7){.selfRef}: [Event Response LLQ OPTION
  Format](#name-event-response-llq-option-f){.selfRef}
:::

Gratuitous responses for a single LLQ [MAY]{.bcp14} be batched such that
multiple changes are communicated in a single message. Responses [MUST
NOT]{.bcp14} be batched if this would cause a message that would
otherwise fit in a single IP packet to be truncated. While responses
[MAY]{.bcp14} be deferred to provide opportunities for batching,
responses [SHOULD NOT]{.bcp14} be delayed, for purposes of batching, for
more than 30 seconds, as this would cause an unacceptable latency for
the client.[¶](#section-6-3){.pilcrow}

After sending a gratuitous response, the server [MUST]{.bcp14} listen
for an acknowledgment from the client. If the client does not respond,
the server [MUST]{.bcp14} resend the response. The server [MUST]{.bcp14}
resend two times (for a total of 3 transmissions), after which the
server [MUST]{.bcp14} consider the client to be unreachable and delete
its LLQ. The server [MUST]{.bcp14} listen for 2 seconds before resending
the response, 4 more seconds before resending again, and must wait an
additional 8 seconds after the 3rd transmission before terminating the
LLQ.[¶](#section-6-4){.pilcrow}

The DNS message header of the response [SHOULD]{.bcp14} include an
unpredictable random number in the DNS message ID field, which is to be
echoed in the client\'s acknowledgment.[¶](#section-6-5){.pilcrow}

::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Add Events](#name-add-events){.section-name .selfRef} {#name-add-events}

Add Events occur when a new resource record appears, usually as the
result of a dynamic update \[[RFC2136](#RFC2136){.xref}\], that answers
an LLQ. This record must be sent in the Answer section of the event to
the client. Records that normally accompany this record in responses
[MAY]{.bcp14} be included in the Additional section as per truncation
restrictions described above.[¶](#section-6.1-1){.pilcrow}
:::

::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Remove Events](#name-remove-events){.section-name .selfRef} {#name-remove-events}

Remove Events occur when a resource record previously sent to a client,
either in an initial response or in an Add Event, becomes invalid
(normally as a result of being removed via a dynamic update). The
deleted resource record is sent in the Answer section of the event to
the client. The resource record TTL is set to -1, indicating that the
record has been removed.[¶](#section-6.2-1){.pilcrow}
:::

::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Gratuitous Response Acknowledgments](#name-gratuitous-response-acknowl){.section-name .selfRef} {#name-gratuitous-response-acknowl}

Upon receiving a gratuitous response (\"event\"), the client
[MUST]{.bcp14} send an acknowledgment to the server. This acknowledgment
is a DNS response echoing the OPT pseudo‑RR contained in the event, with
the message ID of the gratuitous response echoed in the message header.
The acknowledgment [MUST]{.bcp14} be sent to the source IP address and
port from which the event originated.[¶](#section-6.3-1){.pilcrow}
:::
:::
:::

::: {#LLQ-LLE}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [LLQ Lease-Life Expiration](#name-llq-lease-life-expiration){.section-name .selfRef} {#name-llq-lease-life-expiration}

::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Refresh Request](#name-refresh-request){.section-name .selfRef} {#name-refresh-request}

If the client desires to maintain the LLQ beyond the duration specified
in the LLQ‑LEASE field of the ACK + Answers ([Section
5.2.4](#ack-answers){.xref}), the client [MUST]{.bcp14} send a Refresh
Request. A Refresh Request is identical to an LLQ Challenge Response
([Section 5.2.3](#challenge-response){.xref}) but with the LLQ‑OPCODE
set to LLQ‑REFRESH. Unlike a Challenge Response, a Refresh Request
returns no answers.[¶](#section-7.1-1){.pilcrow}

The client [SHOULD]{.bcp14} refresh an LLQ when 80% of its LLQ‑LEASE has
elapsed.[¶](#section-7.1-2){.pilcrow}

As a means of reducing network traffic, when constructing refresh
messages the client [SHOULD]{.bcp14} include all LLQs established with a
given server, even those not yet close to expiration. However, at least
one LLQ [MUST]{.bcp14} have elapsed at least 80% of its original
LLQ‑LEASE. The client [MUST NOT]{.bcp14} include additional LLQs if
doing so would cause the message to no longer fit in a single IP packet.
In this case, the LLQs furthest from expiration should be omitted such
that the message fits in a single IP packet. (These LLQs
[SHOULD]{.bcp14} be refreshed in a separate message when 80% of one or
more of their lease lives have elapsed.) When refreshing multiple LLQs
simultaneously, the message contains multiple questions and a single OPT
pseudo‑RR with multiple LLQ OPTIONS, one per question, with the LLQ
OPTIONS in the same order as the questions they correspond
to.[¶](#section-7.1-3){.pilcrow}

The client [SHOULD]{.bcp14} specify the original LLQ‑LEASE granted in
the LLQ response as the desired LLQ‑LEASE in the Refresh Request. If
refreshing multiple LLQs simultaneously, the client [SHOULD]{.bcp14}
request the same LLQ‑LEASE for all LLQs being refreshed (with the
exception of termination requests; see
below).[¶](#section-7.1-4){.pilcrow}

To terminate an LLQ prior to its scheduled expiration (for instance,
when the client terminates a DNS-based Service Discovery browse
operation or when a client is about to go to sleep or shut down), the
client specifies an LLQ‑LEASE value of 0.[¶](#section-7.1-5){.pilcrow}

The client [MUST]{.bcp14} listen for an acknowledgment from the server.
The client [MAY]{.bcp14} retry up to two more times (for a total of 3
attempts) before considering the server down or unreachable. The client
[MUST NOT]{.bcp14} retry a first time before 90% of the LLQ‑LEASE has
expired and [MUST NOT]{.bcp14} retry again before 95% of the LLQ‑LEASE
has expired. If the server is determined to be down, the client
[MAY]{.bcp14} periodically attempt to re-establish the LLQ via an LLQ
Setup Request message. The client [MUST NOT]{.bcp14} attempt the LLQ
Setup Request more than once per hour.[¶](#section-7.1-6){.pilcrow}
:::

::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [LLQ Refresh Acknowledgment](#name-llq-refresh-acknowledgment){.section-name .selfRef} {#name-llq-refresh-acknowledgment}

Upon receiving an LLQ Refresh message, a server [MUST]{.bcp14} send an
acknowledgment of the Refresh. This acknowledgment is formatted like the
\"ACK + Answers\" message described in [Section
5.2.4](#ack-answers){.xref}, but with the following
variations:[¶](#section-7.2-1){.pilcrow}

-   ::: {#section-7.2-2.1}
    It contains no answers.[¶](#section-7.2-2.1.1){.pilcrow}
    :::

-   ::: {#section-7.2-2.2}
    The LLQ‑OPCODE is set to
    LLQ‑REFRESH.[¶](#section-7.2-2.2.1){.pilcrow}
    :::

-   ::: {#section-7.2-2.3}
    NO‑SUCH‑LLQ [MUST]{.bcp14} be returned as an error code if the
    client attempts to refresh an expired or non-existent LLQ (as
    determined by the LLQ‑ID in the
    request).[¶](#section-7.2-2.3.1){.pilcrow}
    :::

-   ::: {#section-7.2-2.4}
    The LLQ‑ID in the acknowledgment is set to the LLQ‑ID in the
    request.[¶](#section-7.2-2.4.1){.pilcrow}
    :::
:::
:::
:::

::: {#security-considerations}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

In datagram-based protocols (i.e., protocols running over UDP, or
directly over IP, or similar), servers may be susceptible to
denial-of-service (DoS) attacks, and clients may be subjected to packet
storms. Carefully designed mechanisms are needed to limit potential for
these attacks.[¶](#section-8-1){.pilcrow}

Note: This section contains no new protocol elements \-- it serves only
to explain the rationale behind protocol elements described above as
they relate to security.[¶](#section-8-2){.pilcrow}

::: {#server-dos}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Server DoS](#name-server-dos){.section-name .selfRef} {#name-server-dos}

LLQs require that servers be stateful, maintaining entries for each LLQ
over a potentially long period of time. If unbounded in quantity, these
entries may overload the server. By returning SERV‑FULL in Setup
Challenges, the server may limit the maximum number of LLQs it
maintains. Additionally, the server may return SERV‑FULL to limit the
number of LLQs requested for a single name and type, or by a single
client. This throttling may be in the form of a hard limit, or,
preferably, by token-bucket rate limiting. Such rate limiting should
occur rarely in normal use and is intended to prevent DoS attacks \--
thus, it is not built into the protocol explicitly but is instead
implemented at the discretion of an administrator via the SERV‑FULL
error and the LLQ‑LEASE field to indicate a retry time to the
client.[¶](#section-8.1-1){.pilcrow}
:::
:::

::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Client Packet Storms](#name-client-packet-storms){.section-name .selfRef} {#name-client-packet-storms}

In addition to protecting the server from DoS attacks, the LLQ protocol
limits the ability of a malicious host to cause the server to flood a
client with packets. This is achieved via the four-way handshake upon
setup, demonstrating reachability and willingness of the client to
participate, and by requiring that gratuitous responses be ACK\'d by the
client.[¶](#section-8.2-1){.pilcrow}

Additionally, rate limiting by LLQ client address, as described in
[Section 8.1](#server-dos){.xref}, serves to limit the number of packets
that can be delivered to an unsuspecting
client.[¶](#section-8.2-2){.pilcrow}
:::

::: {#section-8.3 .section}
### [8.3.](#section-8.3){.section-number .selfRef} [Spoofing](#name-spoofing){.section-name .selfRef} {#name-spoofing}

A large random ID greatly reduces the risk of an off-path attacker
sending spoof packets to the client (containing spoof events) or to the
server (containing phony requests or
refreshes).[¶](#section-8.3-1){.pilcrow}
:::
:::
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

The EDNS(0) OPTION CODE 1 has already been assigned for this DNS
extension. IANA has updated the record in the \"DNS EDNS0 Option Codes
(OPT)\" registry from \"On-hold\" to \"Optional\" and has set the
reference to this document.[¶](#section-9-1){.pilcrow}

TCP and UDP ports 5352 have already been assigned for LLQ. IANA has
added a reference to this document.[¶](#section-9-2){.pilcrow}
:::

::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-10.1 .section}
### [10.1.](#section-10.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC1035\]
:   [Mockapetris, P.]{.refAuthor}, [\"Domain names - implementation and
    specification\"]{.refTitle}, [STD 13]{.seriesInfo}, [RFC
    1035]{.seriesInfo}, [DOI 10.17487/RFC1035]{.seriesInfo}, November
    1987, \<<https://www.rfc-editor.org/info/rfc1035>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC2782\]
:   [Gulbrandsen, A.]{.refAuthor}[, Vixie, P.]{.refAuthor}[, and L.
    Esibov]{.refAuthor}, [\"A DNS RR for specifying the location of
    services (DNS SRV)\"]{.refTitle}, [RFC 2782]{.seriesInfo}, [DOI
    10.17487/RFC2782]{.seriesInfo}, February 2000,
    \<<https://www.rfc-editor.org/info/rfc2782>\>.
:   

\[RFC6891\]
:   [Damas, J.]{.refAuthor}[, Graff, M.]{.refAuthor}[, and P.
    Vixie]{.refAuthor}, [\"Extension Mechanisms for DNS
    (EDNS(0))\"]{.refTitle}, [STD 75]{.seriesInfo}, [RFC
    6891]{.seriesInfo}, [DOI 10.17487/RFC6891]{.seriesInfo}, April 2013,
    \<<https://www.rfc-editor.org/info/rfc6891>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8765\]
:   [Pusateri, T.]{.refAuthor}[ and S. Cheshire]{.refAuthor}, [\"DNS
    Push Notifications\"]{.refTitle}, [RFC 8765]{.seriesInfo}, [DOI
    10.17487/RFC8765]{.seriesInfo}, June 2020,
    \<<https://www.rfc-editor.org/info/rfc8765>\>.
:   
:::

::: {#section-10.2 .section}
### [10.2.](#section-10.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[RFC2136\]
:   [Vixie, P., Ed.]{.refAuthor}[, Thomson, S.]{.refAuthor}[,
    Rekhter, Y.]{.refAuthor}[, and J. Bound]{.refAuthor}, [\"Dynamic
    Updates in the Domain Name System (DNS UPDATE)\"]{.refTitle}, [RFC
    2136]{.seriesInfo}, [DOI 10.17487/RFC2136]{.seriesInfo}, April 1997,
    \<<https://www.rfc-editor.org/info/rfc2136>\>.
:   

\[RFC4787\]
:   [Audet, F., Ed.]{.refAuthor}[ and C. Jennings]{.refAuthor},
    [\"Network Address Translation (NAT) Behavioral Requirements for
    Unicast UDP\"]{.refTitle}, [BCP 127]{.seriesInfo}, [RFC
    4787]{.seriesInfo}, [DOI 10.17487/RFC4787]{.seriesInfo}, January
    2007, \<<https://www.rfc-editor.org/info/rfc4787>\>.
:   

\[RFC4953\]
:   [Touch, J.]{.refAuthor}, [\"Defending TCP Against Spoofing
    Attacks\"]{.refTitle}, [RFC 4953]{.seriesInfo}, [DOI
    10.17487/RFC4953]{.seriesInfo}, July 2007,
    \<<https://www.rfc-editor.org/info/rfc4953>\>.
:   

\[RFC5382\]
:   [Guha, S., Ed.]{.refAuthor}[, Biswas, K.]{.refAuthor}[,
    Ford, B.]{.refAuthor}[, Sivakumar, S.]{.refAuthor}[, and P.
    Srisuresh]{.refAuthor}, [\"NAT Behavioral Requirements for
    TCP\"]{.refTitle}, [BCP 142]{.seriesInfo}, [RFC 5382]{.seriesInfo},
    [DOI 10.17487/RFC5382]{.seriesInfo}, October 2008,
    \<<https://www.rfc-editor.org/info/rfc5382>\>.
:   

\[RFC6281\]
:   [Cheshire, S.]{.refAuthor}[, Zhu, Z.]{.refAuthor}[,
    Wakikawa, R.]{.refAuthor}[, and L. Zhang]{.refAuthor},
    [\"Understanding Apple\'s Back to My Mac (BTMM)
    Service\"]{.refTitle}, [RFC 6281]{.seriesInfo}, [DOI
    10.17487/RFC6281]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6281>\>.
:   

\[RFC6762\]
:   [Cheshire, S.]{.refAuthor}[ and M. Krochmal]{.refAuthor},
    [\"Multicast DNS\"]{.refTitle}, [RFC 6762]{.seriesInfo}, [DOI
    10.17487/RFC6762]{.seriesInfo}, February 2013,
    \<<https://www.rfc-editor.org/info/rfc6762>\>.
:   

\[RFC6763\]
:   [Cheshire, S.]{.refAuthor}[ and M. Krochmal]{.refAuthor},
    [\"DNS-Based Service Discovery\"]{.refTitle}, [RFC
    6763]{.seriesInfo}, [DOI 10.17487/RFC6763]{.seriesInfo}, February
    2013, \<<https://www.rfc-editor.org/info/rfc6763>\>.
:   

\[RFC6886\]
:   [Cheshire, S.]{.refAuthor}[ and M. Krochmal]{.refAuthor}, [\"NAT
    Port Mapping Protocol (NAT-PMP)\"]{.refTitle}, [RFC
    6886]{.seriesInfo}, [DOI 10.17487/RFC6886]{.seriesInfo}, April 2013,
    \<<https://www.rfc-editor.org/info/rfc6886>\>.
:   

\[RFC6887\]
:   [Wing, D., Ed.]{.refAuthor}[, Cheshire, S.]{.refAuthor}[,
    Boucadair, M.]{.refAuthor}[, Penno, R.]{.refAuthor}[, and P.
    Selkirk]{.refAuthor}, [\"Port Control Protocol (PCP)\"]{.refTitle},
    [RFC 6887]{.seriesInfo}, [DOI 10.17487/RFC6887]{.seriesInfo}, April
    2013, \<<https://www.rfc-editor.org/info/rfc6887>\>.
:   

\[RFC7857\]
:   [Penno, R.]{.refAuthor}[, Perreault, S.]{.refAuthor}[, Boucadair,
    M., Ed.]{.refAuthor}[, Sivakumar, S.]{.refAuthor}[, and K.
    Naito]{.refAuthor}, [\"Updates to Network Address Translation (NAT)
    Behavioral Requirements\"]{.refTitle}, [BCP 127]{.seriesInfo}, [RFC
    7857]{.seriesInfo}, [DOI 10.17487/RFC7857]{.seriesInfo}, April 2016,
    \<<https://www.rfc-editor.org/info/rfc7857>\>.
:   

\[RFC8490\]
:   [Bellis, R.]{.refAuthor}[, Cheshire, S.]{.refAuthor}[,
    Dickinson, J.]{.refAuthor}[, Dickinson, S.]{.refAuthor}[,
    Lemon, T.]{.refAuthor}[, and T. Pusateri]{.refAuthor}, [\"DNS
    Stateful Operations\"]{.refTitle}, [RFC 8490]{.seriesInfo}, [DOI
    10.17487/RFC8490]{.seriesInfo}, March 2019,
    \<<https://www.rfc-editor.org/info/rfc8490>\>.
:   

\[SYN\]
:   [Eddy, W.]{.refAuthor}, [\"Defenses Against TCP SYN Flooding
    Attacks\"]{.refTitle}, [Volume 9]{.seriesInfo}, [Number
    4]{.seriesInfo}, [The Internet Protocol Journal, Cisco
    Systems]{.seriesInfo}, December 2006,
    \<<https://www.cisco.com/web/about/ac123/ac147/archived_issues/ipj_9-4/ipj_9-4.pdf>\>.
:   
:::
:::

::: {#problems}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Problems with the LLQ Protocol](#name-problems-with-the-llq-proto){.section-name .selfRef} {#name-problems-with-the-llq-proto}

In the course of using LLQ since 2005, some problems were discovered.
Since no further work is being done on the LLQ protocol, this LLQ
specification will not be updated to remedy these
problems.[¶](#section-appendix.a-1){.pilcrow}

LLQ\'s IETF Standards Track successor, \"DNS Push Notifications\"
\[[RFC8765](#RFC8765){.xref}\], does not suffer from these problems, so
all existing LLQ implementations are [RECOMMENDED]{.bcp14} to migrate to
using DNS Push Notifications, and all new implementations are
[RECOMMENDED]{.bcp14} to implement DNS Push Notifications instead of
LLQ.[¶](#section-appendix.a-2){.pilcrow}

Known problems with LLQ are documented here as a cautionary tale about
the challenges of building an application protocol directly using
datagrams (like IP or UDP) without the benefit of a mature and
thoroughly reviewed intervening transport layer (such as TCP or
QUIC).[¶](#section-appendix.a-3){.pilcrow}

An LLQ \"Setup Challenge\" message from server to client is identical to
an LLQ \"ACK + Answers\" message from server to client when there are no
current answers for the query. If there is packet loss, retransmission,
and duplication in the network, then a duplicated \"Setup Challenge\"
message arriving late at the client would look like an \"ACK + Answers\"
message with no answers, causing the client to clear its cache of any
records matching the query.[¶](#section-appendix.a-4){.pilcrow}

[Section 5.1](#setup-message-retransmission){.xref} of this LLQ
specification states, \"Servers [MUST NOT]{.bcp14} garbage collect LLQs
that fail to complete the four-way handshake until the initially granted
LLQ-LEASE has elapsed.\" This is probably a mistake since it exposes LLQ
servers to an easy resource-exhaustion denial-of-service attack. LLQ\'s
replacement, DNS Push Notifications \[[RFC8765](#RFC8765){.xref}\], is
built using DNS Stateful Operations \[[RFC8490](#RFC8490){.xref}\],
which uses TLS over TCP; a benefit of building on TCP is that there are
already established industry best practices to guard against SYN
flooding and similar attacks \[[SYN](#SYN){.xref}\]
\[[RFC4953](#RFC4953){.xref}\].[¶](#section-appendix.a-5){.pilcrow}

The attempts here to pack multiple questions into a single UDP/IP packet
for efficiency are awkward and lead to error-prone programming to deal
with cases where some requests in a packet succeed and other requests in
the same packet fail. Fully specifying the correct handling in all
possible cases would be a lot of work to document, a lot of work to
implement, and even more work to thoroughly test. DNS Push Notifications
\[[RFC8765](#RFC8765){.xref}\] avoids this problem by using an
underlying stream protocol (TLS/TCP) to deal with packing small multiple
messages into larger IP packets for
efficiency.[¶](#section-appendix.a-6){.pilcrow}

In some cases, initial LLQ answers are delivered in the \"ACK +
Answers\" message, and in other cases, such as when all the initial
answers will not fit in a single IP packet, some of the initial answers
are delivered in a subsequent \"Add Event\" message. Having two
different ways to accomplish the same thing increases the possibility
for programming errors. DNS Push Notifications
\[[RFC8765](#RFC8765){.xref}\] corrects this error by having only one
single consistent way to deliver
results.[¶](#section-appendix.a-7){.pilcrow}

LLQ is built using UDP, and because UDP has no standardized way of
indicating the start and end of a session, firewalls and NAT gateways
tend to be fairly aggressive about recycling UDP mappings that they
believe to be disused \[[RFC4787](#RFC4787){.xref}\]
\[[RFC5382](#RFC5382){.xref}\] \[[RFC7857](#RFC7857){.xref}\]. Using a
high keepalive traffic rate to maintain firewall or NAT mapping state
could remedy this but would largely defeat the purpose of using LLQ in
the first place, which is to provide efficient change notification
without wasteful polling. Because of this, existing LLQ clients use the
NAT Port Mapping Protocol (NAT-PMP) \[[RFC6886](#RFC6886){.xref}\]
and/or Port Control Protocol (PCP) \[[RFC6887](#RFC6887){.xref}\] to
establish longer port mapping lifetimes. This solves the problem but
adds extra complexity and doesn\'t work with firewalls and NAT gateways
that don\'t support NAT-PMP or PCP. By using TCP instead of UDP, the DNS
Push Notifications protocol benefits from better longevity of sessions
through firewalls and NAT gateways that don\'t support NAT-PMP or
PCP.[¶](#section-appendix.a-8){.pilcrow}
:::
:::

::: {#section-appendix.b .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

The concepts described in this document were originally explored,
developed, and implemented with help from [Chris Sharp]{.contact-name}
and [Roger Pantos]{.contact-name}.[¶](#section-appendix.b-1){.pilcrow}

[Kiren Sekar]{.contact-name} made significant contributions to the first
draft of this document and he wrote much of the code for the
implementation of LLQ that shipped in Mac OS X 10.4 Tiger in April
2005.[¶](#section-appendix.b-2){.pilcrow}

Thanks to Independent Stream Editor [Adrian Farrel]{.contact-name} for
his support and assistance in the publication of this
RFC.[¶](#section-appendix.b-3){.pilcrow}
:::

::: {#authors-addresses}
::: {#section-appendix.c .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Stuart Cheshire]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Apple Inc.]{.org}
:::

::: {.left dir="auto"}
[One Apple Park Way]{.street-address}
:::

::: {.left dir="auto"}
[Cupertino]{.locality}, [CA]{.region} [95014]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: tel
Phone: [+1 (408) 996-1010](tel:+1%20(408)%20996-1010){.tel}
:::

::: email
Email: <cheshire@apple.com>
:::

::: {.left dir="auto"}
[Marc Krochmal]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Apple Inc.]{.org}
:::

::: {.left dir="auto"}
[One Apple Park Way]{.street-address}
:::

::: {.left dir="auto"}
[Cupertino]{.locality}, [CA]{.region} [95014]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: tel
Phone: [+1 (408) 996-1010](tel:+1%20(408)%20996-1010){.tel}
:::

::: email
Email: <marc@apple.com>
:::
:::
:::
