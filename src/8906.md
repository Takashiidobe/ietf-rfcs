  RFC 8906           Failure to Communicate   September 2020
  ------------------ ------------------------ ----------------
  Andrews & Bellis   Best Current Practice    \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8906](https://www.rfc-editor.org/rfc/rfc8906){.eref}

BCP:
:   231

Category:
:   Best Current Practice

Published:
:   September 2020

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    M. Andrews
    :::

    ::: org
    ISC
    :::
    :::

    ::: author
    ::: author-name
    R. Bellis
    :::

    ::: org
    ISC
    :::
    :::
:::

# RFC 8906 {#rfcnum}

# A Common Operational Problem in DNS Servers: Failure to Communicate {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

The DNS is a query/response protocol. Failing to respond to queries, or
responding incorrectly, causes both immediate operational problems and
long-term problems with protocol
development.[¶](#section-abstract-1){.pilcrow}

This document identifies a number of common kinds of queries to which
some servers either fail to respond or respond incorrectly. This
document also suggests procedures for zone operators to apply to
identify and remediate the problem.[¶](#section-abstract-2){.pilcrow}

The document does not look at the DNS data itself, just the structure of
the responses.[¶](#section-abstract-3){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This memo documents an Internet Best Current
Practice.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on BCPs
is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8906>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Consequences](#name-consequences){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Common Kinds of Queries That Result in No
    or Bad
    Responses](#name-common-kinds-of-queries-tha){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Basic DNS
        Queries](#name-basic-dns-queries){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.3.2.1.2.1}
            [3.1.1](#section-3.1.1){.xref}.  [Zone
            Existence](#name-zone-existence){.xref}[¶](#section-toc.1-1.3.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.1.2.2}
            [3.1.2](#section-3.1.2){.xref}.  [Unknown/Unsupported Type
            Queries](#name-unknown-unsupported-type-qu){.xref}[¶](#section-toc.1-1.3.2.1.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.1.2.3}
            [3.1.3](#section-3.1.3){.xref}.  [DNS
            Flags](#name-dns-flags){.xref}[¶](#section-toc.1-1.3.2.1.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.1.2.4}
            [3.1.4](#section-3.1.4){.xref}.  [Unknown DNS
            Opcodes](#name-unknown-dns-opcodes){.xref}[¶](#section-toc.1-1.3.2.1.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.1.2.5}
            [3.1.5](#section-3.1.5){.xref}.  [TCP
            Queries](#name-tcp-queries){.xref}[¶](#section-toc.1-1.3.2.1.2.5.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [EDNS
        Queries](#name-edns-queries){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.3.2.2.2.1}
            [3.2.1](#section-3.2.1){.xref}.  [EDNS Queries: Version
            Independent](#name-edns-queries-version-indepe){.xref}[¶](#section-toc.1-1.3.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.2}
            [3.2.2](#section-3.2.2){.xref}.  [EDNS Queries: Version
            Specific](#name-edns-queries-version-specif){.xref}[¶](#section-toc.1-1.3.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.3}
            [3.2.3](#section-3.2.3){.xref}.  [EDNS
            Options](#name-edns-options){.xref}[¶](#section-toc.1-1.3.2.2.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.4}
            [3.2.4](#section-3.2.4){.xref}.  [EDNS
            Flags](#name-edns-flags){.xref}[¶](#section-toc.1-1.3.2.2.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.5}
            [3.2.5](#section-3.2.5){.xref}.  [Truncated EDNS
            Responses](#name-truncated-edns-responses){.xref}[¶](#section-toc.1-1.3.2.2.2.5.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.6}
            [3.2.6](#section-3.2.6){.xref}.  [DO=1
            Handling](#name-do1-handling){.xref}[¶](#section-toc.1-1.3.2.2.2.6.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.7}
            [3.2.7](#section-3.2.7){.xref}.  [EDNS over
            TCP](#name-edns-over-tcp){.xref}[¶](#section-toc.1-1.3.2.2.2.7.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Firewalls and Load
    Balancers](#name-firewalls-and-load-balancer){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Packet Scrubbing
    Services](#name-packet-scrubbing-services){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Whole Answer
    Caches](#name-whole-answer-caches){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Response Code
    Selection](#name-response-code-selection){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Testing](#name-testing){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Testing: Basic
        DNS](#name-testing-basic-dns){.xref}[¶](#section-toc.1-1.8.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.8.2.1.2.1}
            [8.1.1](#section-8.1.1){.xref}.  [Is the server configured
            for the
            zone?](#name-is-the-server-configured-fo){.xref}[¶](#section-toc.1-1.8.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.1.2.2}
            [8.1.2](#section-8.1.2){.xref}.  [Testing Unknown
            Types](#name-testing-unknown-types){.xref}[¶](#section-toc.1-1.8.2.1.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.1.2.3}
            [8.1.3](#section-8.1.3){.xref}.  [Testing Header
            Bits](#name-testing-header-bits){.xref}[¶](#section-toc.1-1.8.2.1.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.1.2.4}
            [8.1.4](#section-8.1.4){.xref}.  [Testing Unknown
            Opcodes](#name-testing-unknown-opcodes){.xref}[¶](#section-toc.1-1.8.2.1.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.1.2.5}
            [8.1.5](#section-8.1.5){.xref}.  [Testing
            TCP](#name-testing-tcp){.xref}[¶](#section-toc.1-1.8.2.1.2.5.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Testing: Extended
        DNS](#name-testing-extended-dns){.xref}[¶](#section-toc.1-1.8.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.8.2.2.2.1}
            [8.2.1](#section-8.2.1){.xref}.  [Testing Minimal
            EDNS](#name-testing-minimal-edns){.xref}[¶](#section-toc.1-1.8.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.2.2.2}
            [8.2.2](#section-8.2.2){.xref}.  [Testing EDNS Version
            Negotiation](#name-testing-edns-version-negoti){.xref}[¶](#section-toc.1-1.8.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.2.2.3}
            [8.2.3](#section-8.2.3){.xref}.  [Testing Unknown EDNS
            Options](#name-testing-unknown-edns-option){.xref}[¶](#section-toc.1-1.8.2.2.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.2.2.4}
            [8.2.4](#section-8.2.4){.xref}.  [Testing Unknown EDNS
            Flags](#name-testing-unknown-edns-flags){.xref}[¶](#section-toc.1-1.8.2.2.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.2.2.5}
            [8.2.5](#section-8.2.5){.xref}.  [Testing EDNS Version
            Negotiation with Unknown EDNS
            Flags](#name-testing-edns-version-negotia){.xref}[¶](#section-toc.1-1.8.2.2.2.5.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.2.2.6}
            [8.2.6](#section-8.2.6){.xref}.  [Testing EDNS Version
            Negotiation with Unknown EDNS
            Options](#name-testing-edns-version-negotiat){.xref}[¶](#section-toc.1-1.8.2.2.2.6.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.2.2.7}
            [8.2.7](#section-8.2.7){.xref}.  [Testing Truncated
            Responses](#name-testing-truncated-responses){.xref}[¶](#section-toc.1-1.8.2.2.2.7.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.2.2.8}
            [8.2.8](#section-8.2.8){.xref}.  [Testing DO=1
            Handling](#name-testing-do1-handling){.xref}[¶](#section-toc.1-1.8.2.2.2.8.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.2.2.9}
            [8.2.9](#section-8.2.9){.xref}.  [Testing EDNS Version
            Negotiation with
            DO=1](#name-testing-edns-version-negotiati){.xref}[¶](#section-toc.1-1.8.2.2.2.9.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.8.2.2.2.10}
            [8.2.10](#section-8.2.10){.xref}. [Testing with Multiple
            Defined EDNS
            Options](#name-testing-with-multiple-defin){.xref}[¶](#section-toc.1-1.8.2.2.2.10.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [8.3](#section-8.3){.xref}.  [When EDNS Is Not
        Supported](#name-when-edns-is-not-supported){.xref}[¶](#section-toc.1-1.8.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Remediation](#name-remediation){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}

    -   ::: {#section-toc.1-1.12.2.1}
        [12.1](#section-12.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.12.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [12.2](#section-12.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.12.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [](#section-appendix.a){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.14}
    [](#section-appendix.b){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::
:::
:::

::: {#intro}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The DNS \[[RFC1034](#RFC1034){.xref}\] \[[RFC1035](#RFC1035){.xref}\] is
a query/response protocol. Failing to respond to queries or responding
incorrectly causes both immediate operational problems and long-term
problems with protocol development.[¶](#section-1-1){.pilcrow}

Failure to respond to a query is indistinguishable from packet loss
without doing an analysis of query-response patterns. Additionally,
failure to respond results in unnecessary queries being made by DNS
clients and introduces delays to the resolution
process.[¶](#section-1-2){.pilcrow}

Due to the inability to distinguish between packet loss and nameservers
or middleboxes dropping Extension Mechanisms for DNS (EDNS)
\[[RFC6891](#RFC6891){.xref}\] queries, packet loss is sometimes
misclassified as lack of EDNS support, which can lead to DNSSEC
validation failures.[¶](#section-1-3){.pilcrow}

The existence of servers that fail to respond to queries results in
developers being hesitant to deploy new standards. Such servers need to
be identified and remediated.[¶](#section-1-4){.pilcrow}

The DNS has response codes that cover almost any conceivable query
response. A nameserver should be able to respond to any conceivable
query using them. There should be no need to drop queries because a
nameserver does not understand them.[¶](#section-1-5){.pilcrow}

Unless a nameserver is under attack, it should respond to all DNS
requests directed to it. When a nameserver is under attack, it may wish
to drop packets. A common attack is to use a nameserver as an amplifier
by sending spoofed packets. This is done because response packets are
bigger than the queries and large amplification factors are available,
especially if EDNS is supported. Limiting the rate of responses is
reasonable when this is occurring, and the client should retry. However,
this only works if legitimate clients are not being forced to guess
whether or not EDNS queries are accepted. As long as there is still a
pool of servers that don\'t respond to EDNS requests, clients have no
way to know if the lack of response is due to packet loss, EDNS packets
not being supported, or rate limiting due to the server being under
attack. Misclassification of server behaviour is unavoidable when rate
limiting is used until the population of servers that fail to respond to
well-formed queries drops to near zero.[¶](#section-1-6){.pilcrow}

Nameservers should respond to queries even if the queried name is not
for any name the server is configured to answer for. Misconfigured
nameservers are a common occurrence in the DNS, and receiving queries
for zones that the server is not configured for is not necessarily an
indication that the server is under attack. Parent zone operators are
advised to regularly check that the delegating NS records are consistent
with those of the delegated zone and to correct them when they are not
([Section
4.2.2](https://www.rfc-editor.org/rfc/rfc1034#section-4.2.2){.relref} of
\[[RFC1034](#RFC1034){.xref}\], Paragraph 3). Doing this regularly
should reduce the instances of broken
delegations.[¶](#section-1-7){.pilcrow}

This document does not try to identify all possible errors nor does it
supply an exhaustive list of tests.[¶](#section-1-8){.pilcrow}
:::
:::

::: {#consequences}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Consequences](#name-consequences){.section-name .selfRef} {#name-consequences}

Failure to follow the guidance in relevant DNS RFCs has multiple adverse
consequences. Some are caused directly by the non-compliant behaviour
and others as a result of workarounds forced on recursive servers.
Addressing known issues now will reduce future interoperability issues
as the DNS protocol continues to evolve and clients make use of newly
introduced DNS features. In particular, the base DNS specification
\[[RFC1034](#RFC1034){.xref}\] \[[RFC1035](#RFC1035){.xref}\] and the
EDNS specification \[[RFC6891](#RFC6891){.xref}\], when implemented,
need to be followed.[¶](#section-2-1){.pilcrow}

Some examples of known consequences include the
following:[¶](#section-2-2){.pilcrow}

-   [The AD (Authenticated Data) bit in a response cannot be trusted to
    mean anything, as some servers incorrectly copy the flag bit from
    the request to the response \[[RFC1035](#RFC1035){.xref}\]
    \[[RFC4035](#RFC4035){.xref}\]. The use of the AD bit in requests is
    defined in
    \[[RFC6840](#RFC6840){.xref}\].[¶](#section-2-3.1){.pilcrow}]{#section-2-3.1}
-   [Widespread non-response to EDNS queries has led to recursive
    servers having to assume that EDNS is not supported and that
    fallback to plain DNS is required, potentially causing DNSSEC
    validation failures.[¶](#section-2-3.2){.pilcrow}]{#section-2-3.2}
-   [Widespread non-response to EDNS options requires recursive servers
    to decide whether to probe to see if it is the specific EDNS option
    or the use of EDNS in general that is causing the non-response. In
    the limited amount of time required to resolve a query before the
    client times out, this is not
    possible.[¶](#section-2-3.3){.pilcrow}]{#section-2-3.3}
-   [Incorrectly returning FORMERR to an EDNS option being present leads
    to the recursive server not being able to determine if the server is
    just broken in the handling of the EDNS option or if it doesn\'t
    support EDNS at all.[¶](#section-2-3.4){.pilcrow}]{#section-2-3.4}
-   [Mishandling of unknown query types has contributed to the
    abandonment of the transition of the SPF
    type.[¶](#section-2-3.5){.pilcrow}]{#section-2-3.5}
-   [Mishandling of unknown query types has slowed up the development of
    DNS-Based Authentication of Named Entities (DANE) and resulted in
    additional rules being specified to reduce the probability of
    interacting with a broken server when making TLSA
    queries.[¶](#section-2-3.6){.pilcrow}]{#section-2-3.6}

The consequences of servers not following the RFCs will only grow if
measures are not put in place to remove non-compliant servers from the
ecosystem. Working around issues due to non-compliance with RFCs is not
sustainable.[¶](#section-2-4){.pilcrow}

Most (if not all) of these consequences could have been avoided if
action had been taken to remove non-compliant servers as soon as people
were aware of them, i.e., to actively seek out broken implementations
and servers and inform their developers and operators that they need to
fix their servers.[¶](#section-2-5){.pilcrow}
:::
:::

::: {#query-kinds}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Common Kinds of Queries That Result in No or Bad Responses](#name-common-kinds-of-queries-tha){.section-name .selfRef} {#name-common-kinds-of-queries-tha}

This section is broken down into Basic DNS requests and EDNS
requests.[¶](#section-3-1){.pilcrow}

::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Basic DNS Queries](#name-basic-dns-queries){.section-name .selfRef} {#name-basic-dns-queries}

::: {#existence}
::: {#section-3.1.1 .section}
#### [3.1.1.](#section-3.1.1){.section-number .selfRef} [Zone Existence](#name-zone-existence){.section-name .selfRef} {#name-zone-existence}

If a zone is delegated to a server, that server should respond to a SOA
query for that zone with an SOA record. Failing to respond at all is
always incorrect, regardless of the configuration of the server.
Responding with anything other than an SOA record in the answer section
indicates a bad delegation.[¶](#section-3.1.1-1){.pilcrow}
:::
:::

::: {#unknown}
::: {#section-3.1.2 .section}
#### [3.1.2.](#section-3.1.2){.section-number .selfRef} [Unknown/Unsupported Type Queries](#name-unknown-unsupported-type-qu){.section-name .selfRef} {#name-unknown-unsupported-type-qu}

Some servers fail to respond to unknown or unsupported types. If a
server receives a query for a type that it doesn\'t recognise, or
doesn\'t implement, it is expected to return the appropriate response as
if it did recognise the type but does not have any data for that type,
i.e., either NOERROR or NXDOMAIN. The exceptions to this are queries for
Meta-RR types, which may return NOTIMP.[¶](#section-3.1.2-1){.pilcrow}
:::
:::

::: {#dns-flags}
::: {#section-3.1.3 .section}
#### [3.1.3.](#section-3.1.3){.section-number .selfRef} [DNS Flags](#name-dns-flags){.section-name .selfRef} {#name-dns-flags}

Some servers fail to respond to DNS queries with various DNS flags set,
regardless of whether they are defined or still reserved. At the time of
writing, there are servers that fail to respond to queries with the AD
flag set to 1 and servers that fail to respond to queries with the last
reserved flag set.[¶](#section-3.1.3-1){.pilcrow}

Servers should respond to such queries. If the server does not know the
meaning of a flag, it must not copy it to the response ([Section
4.1.1](https://www.rfc-editor.org/rfc/rfc1035#section-4.1.1){.relref} of
\[[RFC1035](#RFC1035){.xref}\]). If the server does not understand the
meaning of a request, it should reply with a FORMERR response with
unknown flags set to zero.[¶](#section-3.1.3-2){.pilcrow}

::: {#recursion}
::: {#section-3.1.3.1 .section}
##### [3.1.3.1.](#section-3.1.3.1){.section-number .selfRef} [Recursive Queries](#name-recursive-queries){.section-name .selfRef} {#name-recursive-queries}

A non-recursive server is supposed to respond to recursive queries as if
the Recursion Desired (RD) bit is not set
\[[RFC1034](#RFC1034){.xref}\].[¶](#section-3.1.3.1-1){.pilcrow}
:::
:::
:::
:::

::: {#opcode}
::: {#section-3.1.4 .section}
#### [3.1.4.](#section-3.1.4){.section-number .selfRef} [Unknown DNS Opcodes](#name-unknown-dns-opcodes){.section-name .selfRef} {#name-unknown-dns-opcodes}

The use of previously undefined opcodes is to be expected. Since the DNS
was first defined, two new opcodes have been added, UPDATE and
NOTIFY.[¶](#section-3.1.4-1){.pilcrow}

NOTIMP is the expected rcode to an unknown or unimplemented
opcode.[¶](#section-3.1.4-2){.pilcrow}

NOTE: while new opcodes will most probably use the current layout
structure for the rest of the message, there is no requirement that
anything other than the DNS header
match.[¶](#section-3.1.4-3.1){.pilcrow}
:::
:::

::: {#tcp}
::: {#section-3.1.5 .section}
#### [3.1.5.](#section-3.1.5){.section-number .selfRef} [TCP Queries](#name-tcp-queries){.section-name .selfRef} {#name-tcp-queries}

All DNS servers are supposed to respond to queries over TCP
\[[RFC7766](#RFC7766){.xref}\]. While firewalls should not block TCP
connection attempts, those that do should cleanly terminate the
connection by sending TCP RESET or sending ICMP/ICMPv6 Administratively
Prohibited messages. Dropping TCP connections introduces excessive
delays to the resolution process.[¶](#section-3.1.5-1){.pilcrow}
:::
:::
:::

::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [EDNS Queries](#name-edns-queries){.section-name .selfRef} {#name-edns-queries}

EDNS queries are specified in
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-3.2-1){.pilcrow}

::: {#edns-independent}
::: {#section-3.2.1 .section}
#### [3.2.1.](#section-3.2.1){.section-number .selfRef} [EDNS Queries: Version Independent](#name-edns-queries-version-indepe){.section-name .selfRef} {#name-edns-queries-version-indepe}

Identifying servers that fail to respond to EDNS queries can be done by
first confirming that the server responds to regular DNS queries,
followed by a series of otherwise identical queries using EDNS, then
making the original query again. A series of EDNS queries is needed, as
at least one DNS implementation responds to the first EDNS query with
FORMERR but fails to respond to subsequent queries from the same address
for a period until a regular DNS query is made. The EDNS query should
specify a UDP buffer size of 512 bytes to avoid false classification of
not supporting EDNS due to response packet
size.[¶](#section-3.2.1-1){.pilcrow}

If the server responds to the first and last queries but fails to
respond to most or all of the EDNS queries, it is probably faulty. The
test should be repeated a number of times to eliminate the likelihood of
a false positive due to packet loss.[¶](#section-3.2.1-2){.pilcrow}

Firewalls may also block larger EDNS responses, but there is no easy way
to check authoritative servers to see if the firewall is
misconfigured.[¶](#section-3.2.1-3){.pilcrow}
:::
:::

::: {#edns-specific}
::: {#section-3.2.2 .section}
#### [3.2.2.](#section-3.2.2){.section-number .selfRef} [EDNS Queries: Version Specific](#name-edns-queries-version-specif){.section-name .selfRef} {#name-edns-queries-version-specif}

Some servers respond correctly to EDNS version 0 queries but fail to
respond to EDNS queries with version numbers that are higher than zero.
Servers should respond with BADVERS to EDNS queries with version numbers
that they do not support.[¶](#section-3.2.2-1){.pilcrow}

Some servers respond correctly to EDNS version 0 queries but fail to set
QR=1 when responding to EDNS versions they do not support. Such
responses may be discarded as invalid (as QR is not 1) or treated as
requests (when the source port of the original request was port
53).[¶](#section-3.2.2-2){.pilcrow}
:::
:::

::: {#edns-options}
::: {#section-3.2.3 .section}
#### [3.2.3.](#section-3.2.3){.section-number .selfRef} [EDNS Options](#name-edns-options){.section-name .selfRef} {#name-edns-options}

Some servers fail to respond to EDNS queries with EDNS options set. The
original EDNS specification left this behaviour undefined
\[[RFC2671](#RFC2671){.xref}\], but the correct behaviour was clarified
in \[[RFC6891](#RFC6891){.xref}\]. Unknown EDNS options are supposed to
be ignored by the server.[¶](#section-3.2.3-1){.pilcrow}
:::
:::

::: {#edns-flags}
::: {#section-3.2.4 .section}
#### [3.2.4.](#section-3.2.4){.section-number .selfRef} [EDNS Flags](#name-edns-flags){.section-name .selfRef} {#name-edns-flags}

Some servers fail to respond to EDNS queries with EDNS flags set.
Servers should ignore EDNS flags they do not understand and must not add
them to the response
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-3.2.4-1){.pilcrow}
:::
:::

::: {#truncated-edns}
::: {#section-3.2.5 .section}
#### [3.2.5.](#section-3.2.5){.section-number .selfRef} [Truncated EDNS Responses](#name-truncated-edns-responses){.section-name .selfRef} {#name-truncated-edns-responses}

Some EDNS-aware servers fail to include an OPT record when a truncated
response is sent. An OPT record is supposed to be included in a
truncated response
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-3.2.5-1){.pilcrow}

Some EDNS-aware servers fail to honour the advertised EDNS UDP buffer
size and send oversized responses \[[RFC6891](#RFC6891){.xref}\].
Servers must send UDP responses no larger than the advertised EDNS UDP
buffer size.[¶](#section-3.2.5-2){.pilcrow}
:::
:::

::: {#dobit}
::: {#section-3.2.6 .section}
#### [3.2.6.](#section-3.2.6){.section-number .selfRef} [DO=1 Handling](#name-do1-handling){.section-name .selfRef} {#name-do1-handling}

Some nameservers incorrectly only return an EDNS response when the
DNSSEC OK (DO) bit \[[RFC3225](#RFC3225){.xref}\] is 1 in the query.
Servers that support EDNS should always respond to EDNS requests with
EDNS responses.[¶](#section-3.2.6-1){.pilcrow}

Some nameservers fail to copy the DO bit to the response despite clearly
supporting DNSSEC by returning an RRSIG records to EDNS queries with
DO=1. Nameservers that support DNSSEC are expected to copy the DO bit
from the request to the response.[¶](#section-3.2.6-2){.pilcrow}
:::
:::

::: {#tcp-edns}
::: {#section-3.2.7 .section}
#### [3.2.7.](#section-3.2.7){.section-number .selfRef} [EDNS over TCP](#name-edns-over-tcp){.section-name .selfRef} {#name-edns-over-tcp}

Some EDNS-aware servers incorrectly limit the TCP response sizes to the
advertised UDP response size. This breaks DNS resolution to clients
where the response sizes exceed the advertised UDP response size despite
the server and the client being capable of sending and receiving larger
TCP responses, respectively. It effectively defeats setting TC=1 in UDP
responses.[¶](#section-3.2.7-1){.pilcrow}
:::
:::
:::
:::
:::

::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Firewalls and Load Balancers](#name-firewalls-and-load-balancer){.section-name .selfRef} {#name-firewalls-and-load-balancer}

Firewalls and load balancers can affect the externally visible behaviour
of a nameserver. Tests for conformance should to be done from outside of
any firewall so that the system is tested as a
whole.[¶](#section-4-1){.pilcrow}

Firewalls and load balancers should not drop DNS packets that they
don\'t understand. They should either pass the packets or generate an
appropriate error response.[¶](#section-4-2){.pilcrow}

Requests for unknown query types are normal client behaviour and should
not be construed as an attack. Nameservers have always been expected to
be able to handle such queries.[¶](#section-4-3){.pilcrow}

Requests for unknown query classes are normal client behaviour and
should not be construed as an attack. Nameservers have always been
expected to be able to handle such queries.[¶](#section-4-4){.pilcrow}

Requests with unknown opcodes are normal client behaviour and should not
be construed as an attack. Nameservers have always been expected to be
able to handle such queries.[¶](#section-4-5){.pilcrow}

Requests with unassigned flags set (DNS or EDNS) are expected client
behaviour and should not be construed as an attack. The behaviour for
unassigned flags is to ignore them in the request and to not set them in
the response. Dropping DNS/EDNS packets with unassigned flags makes it
difficult to deploy extensions that make use of them due to the need to
reconfigure and update firewalls.[¶](#section-4-6){.pilcrow}

Requests with unknown EDNS options are expected client behaviour and
should not be construed as an attack. The correct behaviour for unknown
EDNS options is to ignore their presence when constructing a
reply.[¶](#section-4-7){.pilcrow}

Requests with unknown EDNS versions are expected client behaviour and
should not be construed as an attack. The correct behaviour for unknown
EDNS versions is to return BADVERS along with the highest EDNS version
the server supports. Dropping EDNS packets breaks EDNS version
negotiation.[¶](#section-4-8){.pilcrow}

Firewalls should not assume that there will only be a single response
message to a request. There have been proposals to use EDNS to signal
that multiple DNS messages be returned rather than a single UDP message
that is fragmented at the IP layer.[¶](#section-4-9){.pilcrow}

DNS, and EDNS in particular, are designed to allow clients to be able to
use new features against older servers without having to validate every
option. Indiscriminate blocking of messages breaks that
design.[¶](#section-4-10){.pilcrow}

However, there may be times when a nameserver mishandles messages with a
particular flag, EDNS option, EDNS version field, opcode, type or class
field, or combination thereof to the point where the integrity of the
nameserver is compromised. Firewalls should offer the ability to
selectively reject messages using an appropriately constructed response
based on all these fields while awaiting a fix from the nameserver
vendor. Returning FORMERR or REFUSED are two potential error codes to
return.[¶](#section-4-11){.pilcrow}
:::

::: {#scrubbing}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Packet Scrubbing Services](#name-packet-scrubbing-services){.section-name .selfRef} {#name-packet-scrubbing-services}

Packet scrubbing services are used to filter out undesired traffic,
including but not limited to denial-of-service traffic. This is often
done using heuristic analysis of the traffic.[¶](#section-5-1){.pilcrow}

Packet scrubbing services can affect the externally visible behaviour of
a nameserver in a similar way to firewalls. If an operator uses a packet
scrubbing service, they should check that legitimate queries are not
being blocked.[¶](#section-5-2){.pilcrow}

Packet scrubbing services, unlike firewalls, are also turned on and off
in response to denial-of-service attacks. One needs to take care when
choosing a scrubbing service.[¶](#section-5-3){.pilcrow}

Ideally, operators should run these tests against a packet scrubbing
service to ensure that these tests are not seen as attack
vectors.[¶](#section-5-4){.pilcrow}
:::
:::

::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Whole Answer Caches](#name-whole-answer-caches){.section-name .selfRef} {#name-whole-answer-caches}

Whole answer caches take a previously constructed answer and return it
to a subsequent query for the same question. However, they can return
the wrong response if they do not take all of the relevant attributes of
the query into account.[¶](#section-6-1){.pilcrow}

In addition to the standard tuple of \<qname,qtype,qclass>, a
non-exhaustive set of attributes that must be considered include: RD,
AD, CD, OPT record, DO, EDNS buffer size, EDNS version, EDNS options,
and transport.[¶](#section-6-2){.pilcrow}
:::

::: {#response}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Response Code Selection](#name-response-code-selection){.section-name .selfRef} {#name-response-code-selection}

Choosing the correct response code when responding to DNS queries is
important. Response codes should be chosen considering how clients will
handle them.[¶](#section-7-1){.pilcrow}

For unimplemented opcodes, NOTIMP is the expected response code. Note:
newly implemented opcodes may change the message format by extending the
header, changing the structure of the records, etc. Servers are not
expected to be able to parse these and should respond with a response
code of NOTIMP rather than FORMERR (which would be expected if there was
a parse error with a known opcode).[¶](#section-7-2){.pilcrow}

For unimplemented type codes, and in the absence of other errors, the
only valid response is NOERROR if the qname exists and NXDOMAIN
otherwise. For Meta-RRs, NOTIMP may be returned
instead.[¶](#section-7-3){.pilcrow}

If a zone cannot be loaded because it contains unimplemented type codes
that are not encoded as unknown record types according to
\[[RFC3597](#RFC3597){.xref}\], then the expected response is SERVFAIL,
as the whole zone should be rejected ([Section
5.2](https://www.rfc-editor.org/rfc/rfc1035#section-5.2){.relref} of
\[[RFC1035](#RFC1035){.xref}\]). If a zone loads, then [Section
4.3.2](https://www.rfc-editor.org/rfc/rfc1034#section-4.3.2){.relref} of
\[[RFC1034](#RFC1034){.xref}\] applies.[¶](#section-7-4){.pilcrow}

If the server supports EDNS and receives a query with an unsupported
EDNS version, the correct response is BADVERS
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-7-5){.pilcrow}

If the server does not support EDNS at all, FORMERR is the expected
error code. That said, a minimal EDNS server implementation requires
parsing the OPT records and responding with an empty OPT record in the
additional section in most cases. There is no need to interpret any EDNS
options present in the request, as unsupported EDNS options are expected
to be ignored \[[RFC6891](#RFC6891){.xref}\]. Additionally, EDNS flags
can be ignored. The only part of the OPT record that needs to be
examined is the version field to determine if BADVERS needs to be sent
or not.[¶](#section-7-6){.pilcrow}
:::
:::

::: {#testing}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Testing](#name-testing){.section-name .selfRef} {#name-testing}

Testing is divided into two sections: \"Basic DNS\", which all servers
should meet, and \"Extended DNS\", which should be met by all servers
that support EDNS (a server is deemed to support EDNS if it gives a
valid EDNS response to any EDNS query). If a server does not support
EDNS, it should still respond to all the tests, albeit with error
responses.[¶](#section-8-1){.pilcrow}

These tests query for records at the apex of a zone that the server is
nominally configured to serve. All tests should use the same
zone.[¶](#section-8-2){.pilcrow}

It is advisable to run all of the tests below in parallel so as to
minimise the delays due to multiple timeouts when the servers do not
respond. There are 16 queries directed to each nameserver (assuming no
packet loss) testing different aspects of Basic DNS and Extended
DNS.[¶](#section-8-3){.pilcrow}

The tests below use dig from BIND 9.11.0 \[[ISC](#ISC){.xref}\]. Replace
\$zone with the name of the zone being used for testing. Replace
\$server with the name or address of the server being
tested.[¶](#section-8-4){.pilcrow}

When testing, recursive servers set RD=1 and choose a zone name that is
known to exist and is not being served by the recursive server. The root
zone (\".\") is often a good candidate, as it is DNSSEC signed. RD=1,
rather than RD=0, should be present in the responses for all test
involving the opcode QUERY. Non-authoritative answers (AA=0) are
expected when talking to a recursive server. AD=1 is only expected if
the server is validating responses and one or both AD=1 or DO=1 is set
in the request, otherwise AD=0 is expected.[¶](#section-8-5){.pilcrow}

::: {#testing-basic}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Testing: Basic DNS](#name-testing-basic-dns){.section-name .selfRef} {#name-testing-basic-dns}

This first set of tests cover Basic DNS server behaviour and all servers
should pass these tests.[¶](#section-8.1-1){.pilcrow}

::: {#section-8.1.1 .section}
#### [8.1.1.](#section-8.1.1){.section-number .selfRef} [Is the server configured for the zone?](#name-is-the-server-configured-fo){.section-name .selfRef} {#name-is-the-server-configured-fo}

Ask for the SOA record of the configured zone. This query is made with
no DNS flag bits set and without EDNS.[¶](#section-8.1.1-1){.pilcrow}

We expect the SOA record for the zone to be returned in the answer
section, the rcode to be set to NOERROR, and the Authoritative Answer
(AA) and Query/Response (QR) bits to be set in the header; the Recursion
Available (RA) bits may also be set \[[RFC1034](#RFC1034){.xref}\]. We
do not expect an OPT record to be returned
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-8.1.1-2){.pilcrow}

Verify the server is configured for the
zone:[¶](#section-8.1.1-3){.pilcrow}

::: {#section-8.1.1-4}
``` sourcecode
dig +noedns +noad +norec soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: flag: aa to be present
expect: flag: rd to NOT be present
expect: flag: ad to NOT be present
expect: the OPT record to NOT be present
```

[¶](#section-8.1.1-4){.pilcrow}
:::
:::

::: {#section-8.1.2 .section}
#### [8.1.2.](#section-8.1.2){.section-number .selfRef} [Testing Unknown Types](#name-testing-unknown-types){.section-name .selfRef} {#name-testing-unknown-types}

Identifying servers that fail to respond to unknown or unsupported types
can be done by making an initial DNS query for an A record, making a
number of queries for an unallocated type, then making a query for an A
record again. IANA maintains a registry of allocated types
\[[IANA-DNS](#IANA-DNS){.xref}\].[¶](#section-8.1.2-1){.pilcrow}

If the server responds to the first and last queries but fails to
respond to the queries for the unallocated type, it is probably faulty.
The test should be repeated a number of times to eliminate the
likelihood of a false positive due to packet
loss.[¶](#section-8.1.2-2){.pilcrow}

Ask for the TYPE1000 RRset at the configured zone\'s name. This query is
made with no DNS flag bits set and without EDNS. TYPE1000 has been
chosen for this purpose, as IANA is unlikely to allocate this type in
the near future and it is not in a range reserved for private use
\[[RFC6895](#RFC6895){.xref}\]. Any unallocated type code could be
chosen for this test.[¶](#section-8.1.2-3){.pilcrow}

We expect no records to be returned in the answer section, the rcode to
be set to NOERROR, and the AA and QR bits to be set in the header; RA
may also be set \[[RFC1034](#RFC1034){.xref}\]. We do not expect an OPT
record to be returned
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-8.1.2-4){.pilcrow}

Check that queries for an unknown type
work:[¶](#section-8.1.2-5){.pilcrow}

::: {#section-8.1.2-6}
``` sourcecode
dig +noedns +noad +norec type1000 $zone @$server

expect: status: NOERROR
expect: an empty answer section.
expect: flag: aa to be present
expect: flag: rd to NOT be present
expect: flag: ad to NOT be present
expect: the OPT record to NOT be present
```

[¶](#section-8.1.2-6){.pilcrow}
:::
:::

::: {#section-8.1.3 .section}
#### [8.1.3.](#section-8.1.3){.section-number .selfRef} [Testing Header Bits](#name-testing-header-bits){.section-name .selfRef} {#name-testing-header-bits}

::: {#section-8.1.3.1 .section}
##### [8.1.3.1.](#section-8.1.3.1){.section-number .selfRef} [Testing CD=1 Queries](#name-testing-cd1-queries){.section-name .selfRef} {#name-testing-cd1-queries}

Ask for the SOA record of the configured zone. This query is made with
only the CD DNS flag bit set, with all other DNS bits clear, and without
EDNS.[¶](#section-8.1.3.1-1){.pilcrow}

We expect the SOA record for the zone to be returned in the answer
section, the rcode to be set to NOERROR, and the AA and QR bits to be
set in the header. We do not expect an OPT record to be
returned.[¶](#section-8.1.3.1-2){.pilcrow}

If the server supports DNSSEC, CD should be set in the response
\[[RFC4035](#RFC4035){.xref}\]; otherwise, CD should be clear
\[[RFC1034](#RFC1034){.xref}\].[¶](#section-8.1.3.1-3){.pilcrow}

Check that queries with CD=1 work:[¶](#section-8.1.3.1-4){.pilcrow}

::: {#section-8.1.3.1-5}
``` sourcecode
dig +noedns +noad +norec +cd soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: flag: aa to be present
expect: flag: rd to NOT be present
expect: flag: ad to NOT be present
expect: the OPT record to NOT be present
```

[¶](#section-8.1.3.1-5){.pilcrow}
:::
:::

::: {#section-8.1.3.2 .section}
##### [8.1.3.2.](#section-8.1.3.2){.section-number .selfRef} [Testing AD=1 Queries](#name-testing-ad1-queries){.section-name .selfRef} {#name-testing-ad1-queries}

Ask for the SOA record of the configured zone. This query is made with
only the AD DNS flag bit set, with all other DNS bits clear, and without
EDNS.[¶](#section-8.1.3.2-1){.pilcrow}

We expect the SOA record for the zone to be returned in the answer
section, the rcode to be set to NOERROR, and the AA and QR bits to be
set in the header. We do not expect an OPT record to be returned. The
purpose of this query is to detect blocking of queries with the AD bit
present, not the specific value of AD in the
response.[¶](#section-8.1.3.2-2){.pilcrow}

Check that queries with AD=1 work:[¶](#section-8.1.3.2-3){.pilcrow}

::: {#section-8.1.3.2-4}
``` sourcecode
dig +noedns +norec +ad soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: flag: aa to be present
expect: flag: rd to NOT be present
expect: the OPT record to NOT be present
```

[¶](#section-8.1.3.2-4){.pilcrow}
:::

AD use in queries is defined in
\[[RFC6840](#RFC6840){.xref}\].[¶](#section-8.1.3.2-5){.pilcrow}
:::

::: {#section-8.1.3.3 .section}
##### [8.1.3.3.](#section-8.1.3.3){.section-number .selfRef} [Testing Reserved Bit](#name-testing-reserved-bit){.section-name .selfRef} {#name-testing-reserved-bit}

Ask for the SOA record of the configured zone. This query is made with
only the final reserved DNS flag bit set, with all other DNS bits clear,
and without EDNS.[¶](#section-8.1.3.3-1){.pilcrow}

We expect the SOA record for the zone to be returned in the answer
section, the rcode to be set to NOERROR, and the AA and QR bits to be
set in the header; RA may be set. The final reserved bit must not be set
\[[RFC1034](#RFC1034){.xref}\]. We do not expect an OPT record to be
returned
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-8.1.3.3-2){.pilcrow}

Check that queries with the last unassigned DNS header flag work and
that the flag bit is not copied to the
response:[¶](#section-8.1.3.3-3){.pilcrow}

::: {#section-8.1.3.3-4}
``` sourcecode
dig +noedns +noad +norec +zflag soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: MBZ to NOT be in the response (see below)
expect: flag: aa to be present
expect: flag: rd to NOT be present
expect: flag: ad to NOT be present
expect: the OPT record to NOT be present
```

[¶](#section-8.1.3.3-4){.pilcrow}
:::

MBZ (Must Be Zero) is a dig-specific indication that the flag bit has
been incorrectly copied. See [Section
4.1.1](https://www.rfc-editor.org/rfc/rfc1035#section-4.1.1){.relref} of
\[[RFC1035](#RFC1035){.xref}\]:[¶](#section-8.1.3.3-5){.pilcrow}

[]{.break}

\"Z
:   Reserved for future use. Must be zero in all queries and
    responses.\"[¶](#section-8.1.3.3-6.2){.pilcrow}
:   
:::

::: {#section-8.1.3.4 .section}
##### [8.1.3.4.](#section-8.1.3.4){.section-number .selfRef} [Testing Recursive Queries](#name-testing-recursive-queries){.section-name .selfRef} {#name-testing-recursive-queries}

Ask for the SOA record of the configured zone. This query is made with
only the RD DNS flag bit set and without
EDNS.[¶](#section-8.1.3.4-1){.pilcrow}

We expect the SOA record for the zone to be returned in the answer
section, the rcode to be set to NOERROR, and the AA, QR and RD bits to
be set in the header; RA may also be set \[[RFC1034](#RFC1034){.xref}\].
We do not expect an OPT record to be returned
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-8.1.3.4-2){.pilcrow}

Check that recursive queries work:[¶](#section-8.1.3.4-3){.pilcrow}

::: {#section-8.1.3.4-4}
``` sourcecode
dig +noedns +noad +rec soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: flag: aa to be present
expect: flag: rd to be present
expect: flag: ad to NOT be present
expect: the OPT record to NOT be present
```

[¶](#section-8.1.3.4-4){.pilcrow}
:::
:::
:::

::: {#section-8.1.4 .section}
#### [8.1.4.](#section-8.1.4){.section-number .selfRef} [Testing Unknown Opcodes](#name-testing-unknown-opcodes){.section-name .selfRef} {#name-testing-unknown-opcodes}

Construct a DNS message that consists of only a DNS header with opcode
set to 15 (currently not allocated), no DNS header bits set, and empty
question, answer, authority, and additional
sections.[¶](#section-8.1.4-1){.pilcrow}

Check that new opcodes are handled:[¶](#section-8.1.4-2){.pilcrow}

::: {#section-8.1.4-3}
``` sourcecode
dig +noedns +noad +opcode=15 +norec +header-only @$server

expect: status: NOTIMP
expect: opcode: 15
expect: all sections to be empty
expect: flag: aa to NOT be present
expect: flag: rd to NOT be present
expect: flag: ad to NOT be present
expect: the OPT record to NOT be present
```

[¶](#section-8.1.4-3){.pilcrow}
:::
:::

::: {#section-8.1.5 .section}
#### [8.1.5.](#section-8.1.5){.section-number .selfRef} [Testing TCP](#name-testing-tcp){.section-name .selfRef} {#name-testing-tcp}

Whether a server accepts TCP connections can be tested by first checking
that it responds to UDP queries to confirm that it is up and operating,
then attempting the same query over TCP. An additional query should be
made over UDP if the TCP connection attempt fails to confirm that the
server under test is still operating.[¶](#section-8.1.5-1){.pilcrow}

Ask for the SOA record of the configured zone. This query is made with
no DNS flag bits set and without EDNS. This query is to be sent using
TCP.[¶](#section-8.1.5-2){.pilcrow}

We expect the SOA record for the zone to be returned in the answer
section, the rcode to be set to NOERROR, and the AA and QR bits to be
set in the header; RA may also be set \[[RFC1034](#RFC1034){.xref}\]. We
do not expect an OPT record to be returned
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-8.1.5-3){.pilcrow}

Check that TCP queries work:[¶](#section-8.1.5-4){.pilcrow}

::: {#section-8.1.5-5}
``` sourcecode
dig +noedns +noad +norec +tcp soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: flag: aa to be present
expect: flag: rd to NOT be present
expect: flag: ad to NOT be present
expect: the OPT record to NOT be present
```

[¶](#section-8.1.5-5){.pilcrow}
:::

The requirement that TCP be supported is defined in
\[[RFC7766](#RFC7766){.xref}\].[¶](#section-8.1.5-6){.pilcrow}
:::
:::
:::

::: {#testing-edns}
::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Testing: Extended DNS](#name-testing-extended-dns){.section-name .selfRef} {#name-testing-extended-dns}

The next set of tests cover various aspects of EDNS behaviour. If any of
these tests succeed (indicating at least some EDNS support), then all of
them should succeed. There are servers that support EDNS but fail to
handle plain EDNS queries correctly, so a plain EDNS query is not a good
indicator of lack of EDNS support.[¶](#section-8.2-1){.pilcrow}

::: {#section-8.2.1 .section}
#### [8.2.1.](#section-8.2.1){.section-number .selfRef} [Testing Minimal EDNS](#name-testing-minimal-edns){.section-name .selfRef} {#name-testing-minimal-edns}

Ask for the SOA record of the configured zone. This query is made with
no DNS flag bits set. EDNS version 0 is used without any EDNS options or
EDNS flags set.[¶](#section-8.2.1-1){.pilcrow}

We expect the SOA record for the zone to be returned in the answer
section, the rcode to be set to NOERROR, and the AA and QR bits to be
set in the header; RA may also be set \[[RFC1034](#RFC1034){.xref}\]. We
expect an OPT record to be returned. There should be no EDNS flags
present in the response. The EDNS version field should be 0, and there
should be no EDNS options present
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-8.2.1-2){.pilcrow}

Check that plain EDNS queries work:[¶](#section-8.2.1-3){.pilcrow}

::: {#section-8.2.1-4}
``` sourcecode
dig +nocookie +edns=0 +noad +norec soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: an OPT record to be present in the additional section
expect: EDNS Version 0 in response
expect: flag: aa to be present
expect: flag: ad to NOT be present
```

[¶](#section-8.2.1-4){.pilcrow}
:::

+nocookie disables sending an EDNS COOKIE option, which is otherwise
enabled by default in BIND 9.11.0 (and
later).[¶](#section-8.2.1-5){.pilcrow}
:::

::: {#section-8.2.2 .section}
#### [8.2.2.](#section-8.2.2){.section-number .selfRef} [Testing EDNS Version Negotiation](#name-testing-edns-version-negoti){.section-name .selfRef} {#name-testing-edns-version-negoti}

Ask for the SOA record of a zone the server is nominally configured to
serve. This query is made with no DNS flag bits set. EDNS version 1 is
used without any EDNS options or EDNS flags
set.[¶](#section-8.2.2-1){.pilcrow}

We expect the SOA record for the zone to NOT be returned in the answer
section with the extended rcode set to BADVERS and the QR bit to be set
in the header; RA may also be set \[[RFC1034](#RFC1034){.xref}\]. We
expect an OPT record to be returned. There should be no EDNS flags
present in the response. The EDNS version field should be 0 in the
response, as no other EDNS version has as yet been specified
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-8.2.2-2){.pilcrow}

Check that EDNS version 1 queries work (EDNS
supported):[¶](#section-8.2.2-3){.pilcrow}

::: {#section-8.2.2-4}
``` sourcecode
dig +nocookie +edns=1 +noednsneg +noad +norec soa $zone @$server

expect: status: BADVERS
expect: the SOA record to NOT be present in the answer section
expect: an OPT record to be present in the additional section
expect: EDNS Version 0 in response
expect: flag: aa to NOT be present
expect: flag: ad to NOT be present
```

[¶](#section-8.2.2-4){.pilcrow}
:::

+noednsneg has been set, as dig supports EDNS version negotiation, and
we want to see only the response to the initial EDNS version 1
query.[¶](#section-8.2.2-5){.pilcrow}
:::

::: {#section-8.2.3 .section}
#### [8.2.3.](#section-8.2.3){.section-number .selfRef} [Testing Unknown EDNS Options](#name-testing-unknown-edns-option){.section-name .selfRef} {#name-testing-unknown-edns-option}

Ask for the SOA record of the configured zone. This query is made with
no DNS flag bits set. EDNS version 0 is used without any EDNS flags. An
EDNS option is present with a value that has not yet been assigned by
IANA. We have picked an unassigned code of 100 for the example below.
Any unassigned EDNS option code could have been chosen for this
test.[¶](#section-8.2.3-1){.pilcrow}

We expect the SOA record for the zone to be returned in the answer
section, the rcode to be set to NOERROR, and the AA and QR bits to be
set in the header; RA may also be set \[[RFC1034](#RFC1034){.xref}\]. We
expect an OPT record to be returned. There should be no EDNS flags
present in the response. The EDNS version field should be 0, as EDNS
versions other than 0 are yet to be specified, and there should be no
EDNS options present, as unknown EDNS options are supposed to be ignored
by the server ([Section
6.1.1](https://www.rfc-editor.org/rfc/rfc6891#section-6.1.1){.relref} of
\[[RFC6891](#RFC6891){.xref}\]).[¶](#section-8.2.3-2){.pilcrow}

Check that EDNS queries with an unknown option work (EDNS
supported):[¶](#section-8.2.3-3){.pilcrow}

::: {#section-8.2.3-4}
``` sourcecode
dig +nocookie +edns=0 +noad +norec +ednsopt=100 soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: an OPT record to be present in the additional section
expect: OPT=100 to NOT be present
expect: EDNS Version 0 in response
expect: flag: aa to be present
expect: flag: ad to NOT be present
```

[¶](#section-8.2.3-4){.pilcrow}
:::
:::

::: {#section-8.2.4 .section}
#### [8.2.4.](#section-8.2.4){.section-number .selfRef} [Testing Unknown EDNS Flags](#name-testing-unknown-edns-flags){.section-name .selfRef} {#name-testing-unknown-edns-flags}

Ask for the SOA record of the configured zone. This query is made with
no DNS flag bits set. EDNS version 0 is used without any EDNS options.
An unassigned EDNS flag bit is set (0x40 in this
case).[¶](#section-8.2.4-1){.pilcrow}

We expect the SOA record for the zone to be returned in the answer
section, the rcode to be set to NOERROR, and the AA and QR bits to be
set in the header; RA may also be set \[[RFC1034](#RFC1034){.xref}\]. We
expect an OPT record to be returned. There should be no EDNS flags
present in the response, as unknown EDNS flags are supposed to be
ignored. The EDNS version field should be 0, and there should be no EDNS
options present
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-8.2.4-2){.pilcrow}

Check that EDNS queries with unknown flags work (EDNS
supported):[¶](#section-8.2.4-3){.pilcrow}

::: {#section-8.2.4-4}
``` sourcecode
dig +nocookie +edns=0 +noad +norec +ednsflags=0x40 soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: an OPT record to be present in the additional section
expect: MBZ not to be present
expect: EDNS Version 0 in response
expect: flag: aa to be present
expect: flag: ad to NOT be present
```

[¶](#section-8.2.4-4){.pilcrow}
:::

MBZ (Must Be Zero) is a dig-specific indication that a flag bit has been
incorrectly copied, as per [Section
6.1.4](https://www.rfc-editor.org/rfc/rfc6891#section-6.1.4){.relref} of
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-8.2.4-5){.pilcrow}
:::

::: {#section-8.2.5 .section}
#### [8.2.5.](#section-8.2.5){.section-number .selfRef} [Testing EDNS Version Negotiation with Unknown EDNS Flags](#name-testing-edns-version-negotia){.section-name .selfRef} {#name-testing-edns-version-negotia}

Ask for the SOA record of the configured zone. This query is made with
no DNS flag bits set. EDNS version 1 is used without any EDNS options.
An unassigned EDNS flag bit is set (0x40 in this
case).[¶](#section-8.2.5-1){.pilcrow}

We expect the SOA record for the zone to NOT be returned in the answer
section with the extended rcode set to BADVERS and the QR bit to be set
in the header; RA may also be set \[[RFC1034](#RFC1034){.xref}\]. We
expect an OPT record to be returned. There should be no EDNS flags
present in the response, as unknown EDNS flags are supposed to be
ignored. The EDNS version field should be 0, as EDNS versions other than
0 are yet to be specified, and there should be no EDNS options present
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-8.2.5-2){.pilcrow}

Check that EDNS version 1 queries with unknown flags work (EDNS
supported):[¶](#section-8.2.5-3){.pilcrow}

::: {#section-8.2.5-4}
``` sourcecode
dig +nocookie +edns=1 +noednsneg +noad +norec +ednsflags=0x40 soa \
    $zone @$server

expect: status: BADVERS
expect: SOA record to NOT be present
expect: an OPT record to be present in the additional section
expect: MBZ not to be present
expect: EDNS Version 0 in response
expect: flag: aa to NOT be present
expect: flag: ad to NOT be present
```

[¶](#section-8.2.5-4){.pilcrow}
:::
:::

::: {#section-8.2.6 .section}
#### [8.2.6.](#section-8.2.6){.section-number .selfRef} [Testing EDNS Version Negotiation with Unknown EDNS Options](#name-testing-edns-version-negotiat){.section-name .selfRef} {#name-testing-edns-version-negotiat}

Ask for the SOA record of the configured zone. This query is made with
no DNS flag bits set. EDNS version 1 is used. An unknown EDNS option is
present. We have picked an unassigned code of 100 for the example below.
Any unassigned EDNS option code could have been chosen for this
test.[¶](#section-8.2.6-1){.pilcrow}

We expect the SOA record for the zone to NOT be returned in the answer
section with the extended rcode set to BADVERS and the QR bit to be set
in the header; RA may also be set \[[RFC1034](#RFC1034){.xref}\]. We
expect an OPT record to be returned. There should be no EDNS flags
present in the response. The EDNS version field should be 0, as EDNS
versions other than 0 are yet to be specified, and there should be no
EDNS options present
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-8.2.6-2){.pilcrow}

Check that EDNS version 1 queries with unknown options work (EDNS
supported):[¶](#section-8.2.6-3){.pilcrow}

::: {#section-8.2.6-4}
``` sourcecode
dig +nocookie +edns=1 +noednsneg +noad +norec +ednsopt=100 soa \
    $zone @$server

expect: status: BADVERS
expect: SOA record to NOT be present
expect: an OPT record to be present in the additional section
expect: OPT=100 to NOT be present
expect: EDNS Version 0 in response
expect: flag: aa to NOT be present
expect: flag: ad to NOT be present
```

[¶](#section-8.2.6-4){.pilcrow}
:::
:::

::: {#section-8.2.7 .section}
#### [8.2.7.](#section-8.2.7){.section-number .selfRef} [Testing Truncated Responses](#name-testing-truncated-responses){.section-name .selfRef} {#name-testing-truncated-responses}

Ask for the DNSKEY records of the configured zone, which must be a
DNSSEC signed zone. This query is made with no DNS flag bits set. EDNS
version 0 is used without any EDNS options. The only EDNS flag set is
DO. The EDNS UDP buffer size is set to 512. The intention of this query
is to elicit a truncated response from the server. Most signed DNSKEY
responses are bigger than 512 bytes. This test will not give a valid
result if the zone is not signed.[¶](#section-8.2.7-1){.pilcrow}

We expect a response, the rcode to be set to NOERROR, and the AA and QR
bits to be set. AD may be set in the response if the server supports
DNSSEC; otherwise it should be clear; TC and RA may also be set
\[[RFC1035](#RFC1035){.xref}\] \[[RFC4035](#RFC4035){.xref}\]. We expect
an OPT record to be present in the response. There should be no EDNS
flags other than DO present in the response. The EDNS version field
should be 0, and there should be no EDNS options present
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-8.2.7-2){.pilcrow}

If TC is not set, it is not possible to confirm that the server
correctly adds the OPT record to the truncated responses or
not.[¶](#section-8.2.7-3){.pilcrow}

::: {#section-8.2.7-4}
``` sourcecode
dig +norec +dnssec +bufsize=512 +ignore dnskey $zone @$server
expect: NOERROR
expect: OPT record with version set to 0
```

[¶](#section-8.2.7-4){.pilcrow}
:::
:::

::: {#section-8.2.8 .section}
#### [8.2.8.](#section-8.2.8){.section-number .selfRef} [Testing DO=1 Handling](#name-testing-do1-handling){.section-name .selfRef} {#name-testing-do1-handling}

Ask for the SOA record of the configured zone, which does not need to be
DNSSEC signed. This query is made with no DNS flag bits set. EDNS
version 0 is used without any EDNS options. The only EDNS flag set is
DO.[¶](#section-8.2.8-1){.pilcrow}

We expect the SOA record for the zone to be returned in the answer
section, the rcode to be set to NOERROR, and the AA and QR bits to be
set in the response. AD may be set in the response if the server
supports DNSSEC, otherwise it should be clear; RA may also be set
\[[RFC1034](#RFC1034){.xref}\]. We expect an OPT record to be returned.
There should be no EDNS flags other than DO present in the response,
which should be present if the server supports DNSSEC. The EDNS version
field should be 0, and there should be no EDNS options present
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-8.2.8-2){.pilcrow}

Check that DO=1 queries work (EDNS
supported):[¶](#section-8.2.8-3){.pilcrow}

::: {#section-8.2.8-4}
``` sourcecode
dig +nocookie +edns=0 +noad +norec +dnssec soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: an OPT record to be present in the additional section
expect: DO=1 to be present if an RRSIG is in the response
expect: EDNS Version 0 in response
expect: flag: aa to be present
```

[¶](#section-8.2.8-4){.pilcrow}
:::
:::

::: {#section-8.2.9 .section}
#### [8.2.9.](#section-8.2.9){.section-number .selfRef} [Testing EDNS Version Negotiation with DO=1](#name-testing-edns-version-negotiati){.section-name .selfRef} {#name-testing-edns-version-negotiati}

Ask for the SOA record of the configured zone, which does not need to be
DNSSEC signed. This query is made with no DNS flag bits set. EDNS
version 1 is used without any EDNS options. The only EDNS flag set is
DO.[¶](#section-8.2.9-1){.pilcrow}

We expect the SOA record for the zone NOT to be returned in the answer
section, the extended rcode to be set to BADVERS, and the QR bit to be
set in the header; RA may also be set \[[RFC1034](#RFC1034){.xref}\]. We
expect an OPT record to be returned. There should be no EDNS flags other
than DO present in the response, which should be there if the server
supports DNSSEC. The EDNS version field should be 0, and there should be
no EDNS options present
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-8.2.9-2){.pilcrow}

Check that EDNS version 1, DO=1 queries work (EDNS
supported):[¶](#section-8.2.9-3){.pilcrow}

::: {#section-8.2.9-4}
``` sourcecode
dig +nocookie +edns=1 +noednsneg +noad +norec +dnssec soa \
    $zone @$server

expect: status: BADVERS
expect: SOA record to NOT be present
expect: an OPT record to be present in the additional section
expect: DO=1 to be present if the EDNS version 0 DNSSEC query test
        returned DO=1
expect: EDNS Version 0 in response
expect: flag: aa to NOT be present
```

[¶](#section-8.2.9-4){.pilcrow}
:::
:::

::: {#section-8.2.10 .section}
#### [8.2.10.](#section-8.2.10){.section-number .selfRef} [Testing with Multiple Defined EDNS Options](#name-testing-with-multiple-defin){.section-name .selfRef} {#name-testing-with-multiple-defin}

Ask for the SOA record of the configured zone. This query is made with
no DNS flag bits set. EDNS version 0 is used. A number of defined EDNS
options are present (NSID \[[RFC5001](#RFC5001){.xref}\], DNS COOKIE
\[[RFC7873](#RFC7873){.xref}\], EDNS Client Subnet
\[[RFC7871](#RFC7871){.xref}\], and EDNS Expire
\[[RFC7314](#RFC7314){.xref}\]).[¶](#section-8.2.10-1){.pilcrow}

We expect the SOA record for the zone to be returned in the answer
section, the rcode to be set to NOERROR, and the AA and QR bits to be
set in the header; RA may also be set \[[RFC1034](#RFC1034){.xref}\]. We
expect an OPT record to be returned. There should be no EDNS flags
present in the response. The EDNS version field should be 0. Any of the
requested EDNS options supported by the server and permitted server
configuration may be returned
\[[RFC6891](#RFC6891){.xref}\].[¶](#section-8.2.10-2){.pilcrow}

Check that EDNS queries with multiple defined EDNS options
work:[¶](#section-8.2.10-3){.pilcrow}

::: {#section-8.2.10-4}
``` sourcecode
dig +edns=0 +noad +norec +cookie +nsid +expire +subnet=0.0.0.0/0 \
    soa $zone @$server

expect: status: NOERROR
expect: the SOA record to be present in the answer section
expect: an OPT record to be present in the additional section
expect: EDNS Version 0 in response
expect: flag: aa to be present
expect: flag: ad to NOT be present
```

[¶](#section-8.2.10-4){.pilcrow}
:::
:::
:::
:::

::: {#section-8.3 .section}
### [8.3.](#section-8.3){.section-number .selfRef} [When EDNS Is Not Supported](#name-when-edns-is-not-supported){.section-name .selfRef} {#name-when-edns-is-not-supported}

If EDNS is not supported by the nameserver, we expect a response to each
of the above queries. That response may be a FORMERR error response, or
the OPT record may just be ignored.[¶](#section-8.3-1){.pilcrow}

Some nameservers only return an EDNS response when a particular EDNS
option or flag (e.g., DO=1) is present in the request. This behaviour is
not compliant behaviour and may hide other incorrect behaviour from the
above tests. Retesting with the triggering option/flag present will
expose this misbehaviour.[¶](#section-8.3-2){.pilcrow}
:::
:::
:::

::: {#remediation}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Remediation](#name-remediation){.section-name .selfRef} {#name-remediation}

Nameserver operators are generally expected to test their own
infrastructure for compliance to standards. The above tests should be
run when new systems are brought online and should be repeated
periodically to ensure continued
interoperability.[¶](#section-9-1){.pilcrow}

Domain registrants who do not maintain their own DNS infrastructure are
entitled to a DNS service that conforms to standards and interoperates
well. Registrants who become aware that their DNS operator does not have
a well-maintained or compliant infrastructure should insist that their
service provider correct issues and switch providers if they do
not.[¶](#section-9-2){.pilcrow}

In the event that an operator experiences problems due to the behaviour
of nameservers outside their control, the above tests will help in
narrowing down the precise issue(s), which can then be reported to the
relevant party.[¶](#section-9-3){.pilcrow}

If contact information for the operator of a misbehaving nameserver is
not already known, the following methods of communication could be
considered:[¶](#section-9-4){.pilcrow}

-   [the RNAME of the zone authoritative for the name of the misbehaving
    server[¶](#section-9-5.1){.pilcrow}]{#section-9-5.1}
-   [the RNAME of zones for which the offending server is
    authoritative[¶](#section-9-5.2){.pilcrow}]{#section-9-5.2}
-   [administrative or technical contacts listed in the registration
    information for the parent domain of the name of the misbehaving
    server or for zones for which the nameserver is
    authoritative[¶](#section-9-5.3){.pilcrow}]{#section-9-5.3}
-   [the registrar or registry for such
    zones[¶](#section-9-5.4){.pilcrow}]{#section-9-5.4}
-   [DNS-specific, operational fora (e.g., mailing
    lists)[¶](#section-9-5.5){.pilcrow}]{#section-9-5.5}

Operators of parent zones may wish to regularly test the authoritative
nameservers of their child zones. However, parent operators can have
widely varying capabilities in terms of notification or remediation
depending on whether they have a direct relationship with the child
operator. Many Top-Level Domain (TLD) registries, for example, cannot
directly contact their registrants and may instead need to communicate
through the relevant registrar. In such cases, it may be most efficient
for registrars to take on the responsibility for testing the nameservers
of their registrants, since they have a direct
relationship.[¶](#section-9-6){.pilcrow}

When notification is not effective at correcting problems with a
misbehaving nameserver, parent operators can choose to remove NS record
sets (and glue records below) that refer to the faulty server until the
servers are fixed. This should only be done as a last resort and with
due consideration, as removal of a delegation can have unanticipated
side effects. For example, other parts of the DNS tree may depend on
names below the removed zone cut, and the parent operator may find
themselves responsible for causing new DNS failures to
occur.[¶](#section-9-7){.pilcrow}
:::
:::

::: {#seccon}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

Testing protocol compliance can potentially result in false reports of
attempts to attack services from Intrusion Detection Services and
firewalls. All of the tests are well-formed (though not necessarily
common) DNS queries. None of the tests listed above should cause any
harm to a protocol-compliant server.[¶](#section-10-1){.pilcrow}

Relaxing firewall settings to ensure EDNS compliance could potentially
expose a critical implementation flaw in the nameserver. Nameservers
should be tested for conformance before relaxing firewall
settings.[¶](#section-10-2){.pilcrow}

When removing delegations for non-compliant servers, there can be a
knock-on effect on other zones that require these zones to be
operational for the nameservers addresses to be
resolved.[¶](#section-10-3){.pilcrow}
:::
:::

::: {#iana}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-11-1){.pilcrow}
:::
:::

::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-12.1 .section}
### [12.1.](#section-12.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC1034\]
:   [Mockapetris, P.]{.refAuthor}, [\"Domain names - concepts and
    facilities\"]{.refTitle}, [STD 13]{.seriesInfo}, [RFC
    1034]{.seriesInfo}, [DOI 10.17487/RFC1034]{.seriesInfo}, November
    1987, \<<https://www.rfc-editor.org/info/rfc1034>\>.
:   

\[RFC1035\]
:   [Mockapetris, P.]{.refAuthor}, [\"Domain names - implementation and
    specification\"]{.refTitle}, [STD 13]{.seriesInfo}, [RFC
    1035]{.seriesInfo}, [DOI 10.17487/RFC1035]{.seriesInfo}, November
    1987, \<<https://www.rfc-editor.org/info/rfc1035>\>.
:   

\[RFC3225\]
:   [Conrad, D.]{.refAuthor}, [\"Indicating Resolver Support of
    DNSSEC\"]{.refTitle}, [RFC 3225]{.seriesInfo}, [DOI
    10.17487/RFC3225]{.seriesInfo}, December 2001,
    \<<https://www.rfc-editor.org/info/rfc3225>\>.
:   

\[RFC4035\]
:   [Arends, R.]{.refAuthor}[, Austein, R.]{.refAuthor}[,
    Larson, M.]{.refAuthor}[, Massey, D.]{.refAuthor}[, and S.
    Rose]{.refAuthor}, [\"Protocol Modifications for the DNS Security
    Extensions\"]{.refTitle}, [RFC 4035]{.seriesInfo}, [DOI
    10.17487/RFC4035]{.seriesInfo}, March 2005,
    \<<https://www.rfc-editor.org/info/rfc4035>\>.
:   

\[RFC6840\]
:   [Weiler, S., Ed.]{.refAuthor}[ and D. Blacka, Ed.]{.refAuthor},
    [\"Clarifications and Implementation Notes for DNS Security
    (DNSSEC)\"]{.refTitle}, [RFC 6840]{.seriesInfo}, [DOI
    10.17487/RFC6840]{.seriesInfo}, February 2013,
    \<<https://www.rfc-editor.org/info/rfc6840>\>.
:   

\[RFC6891\]
:   [Damas, J.]{.refAuthor}[, Graff, M.]{.refAuthor}[, and P.
    Vixie]{.refAuthor}, [\"Extension Mechanisms for DNS
    (EDNS(0))\"]{.refTitle}, [STD 75]{.seriesInfo}, [RFC
    6891]{.seriesInfo}, [DOI 10.17487/RFC6891]{.seriesInfo}, April 2013,
    \<<https://www.rfc-editor.org/info/rfc6891>\>.
:   

\[RFC6895\]
:   [Eastlake 3rd, D.]{.refAuthor}, [\"Domain Name System (DNS) IANA
    Considerations\"]{.refTitle}, [BCP 42]{.seriesInfo}, [RFC
    6895]{.seriesInfo}, [DOI 10.17487/RFC6895]{.seriesInfo}, April 2013,
    \<<https://www.rfc-editor.org/info/rfc6895>\>.
:   

\[RFC7766\]
:   [Dickinson, J.]{.refAuthor}[, Dickinson, S.]{.refAuthor}[,
    Bellis, R.]{.refAuthor}[, Mankin, A.]{.refAuthor}[, and D.
    Wessels]{.refAuthor}, [\"DNS Transport over TCP - Implementation
    Requirements\"]{.refTitle}, [RFC 7766]{.seriesInfo}, [DOI
    10.17487/RFC7766]{.seriesInfo}, March 2016,
    \<<https://www.rfc-editor.org/info/rfc7766>\>.
:   
:::

::: {#section-12.2 .section}
### [12.2.](#section-12.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[IANA-DNS\]
:   [IANA]{.refAuthor}, [\"Domain Name System (DNS)
    Parameters\"]{.refTitle},
    \<<https://www.iana.org/assignments/dns-parameters/>\>.
:   

\[ISC\]
:   [\"Internet Systems Consortuim\"]{.refTitle},
    \<<https://www.isc.org/>\>.
:   

\[RFC2671\]
:   [Vixie, P.]{.refAuthor}, [\"Extension Mechanisms for DNS
    (EDNS0)\"]{.refTitle}, [RFC 2671]{.seriesInfo}, [DOI
    10.17487/RFC2671]{.seriesInfo}, August 1999,
    \<<https://www.rfc-editor.org/info/rfc2671>\>.
:   

\[RFC3597\]
:   [Gustafsson, A.]{.refAuthor}, [\"Handling of Unknown DNS Resource
    Record (RR) Types\"]{.refTitle}, [RFC 3597]{.seriesInfo}, [DOI
    10.17487/RFC3597]{.seriesInfo}, September 2003,
    \<<https://www.rfc-editor.org/info/rfc3597>\>.
:   

\[RFC5001\]
:   [Austein, R.]{.refAuthor}, [\"DNS Name Server Identifier (NSID)
    Option\"]{.refTitle}, [RFC 5001]{.seriesInfo}, [DOI
    10.17487/RFC5001]{.seriesInfo}, August 2007,
    \<<https://www.rfc-editor.org/info/rfc5001>\>.
:   

\[RFC7314\]
:   [Andrews, M.]{.refAuthor}, [\"Extension Mechanisms for DNS (EDNS)
    EXPIRE Option\"]{.refTitle}, [RFC 7314]{.seriesInfo}, [DOI
    10.17487/RFC7314]{.seriesInfo}, July 2014,
    \<<https://www.rfc-editor.org/info/rfc7314>\>.
:   

\[RFC7871\]
:   [Contavalli, C.]{.refAuthor}[, van der Gaast, W.]{.refAuthor}[,
    Lawrence, D.]{.refAuthor}[, and W. Kumari]{.refAuthor}, [\"Client
    Subnet in DNS Queries\"]{.refTitle}, [RFC 7871]{.seriesInfo}, [DOI
    10.17487/RFC7871]{.seriesInfo}, May 2016,
    \<<https://www.rfc-editor.org/info/rfc7871>\>.
:   

\[RFC7873\]
:   [Eastlake 3rd, D.]{.refAuthor}[ and M. Andrews]{.refAuthor},
    [\"Domain Name System (DNS) Cookies\"]{.refTitle}, [RFC
    7873]{.seriesInfo}, [DOI 10.17487/RFC7873]{.seriesInfo}, May 2016,
    \<<https://www.rfc-editor.org/info/rfc7873>\>.
:   
:::
:::

::: {#section-appendix.a .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

The contributions of [Matthew Pounsett]{.contact-name} and [Tim
Wicinski]{.contact-name} are gratefully
acknowledged.[¶](#section-appendix.a-1){.pilcrow}
:::

::: {#authors-addresses}
::: {#section-appendix.b .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[M. Andrews]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Internet Systems Consortium]{.org}
:::

::: {.left dir="auto"}
[PO Box 360]{.street-address}
:::

::: {.left dir="auto"}
[Newmarket]{.locality}, [NH]{.region} [03857]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <marka@isc.org>
:::

::: {.left dir="auto"}
[Ray Bellis]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Internet Systems Consortium]{.org}
:::

::: {.left dir="auto"}
[PO Box 360]{.street-address}
:::

::: {.left dir="auto"}
[Newmarket]{.locality}, [NH]{.region} [03857]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <ray@isc.org>
:::
:::
:::
