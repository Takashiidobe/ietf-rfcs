  RFC 9205     Building Protocols with HTTP   June 2022
  ------------ ------------------------------ -----------
  Nottingham   Best Current Practice          \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9205](https://www.rfc-editor.org/rfc/rfc9205){.eref}

BCP:
:   56

Obsoletes:
:   [3205](https://www.rfc-editor.org/rfc/rfc3205){.eref}

Category:
:   Best Current Practice

Published:
:   June 2022

ISSN:
:   2070-1721

Author:

:   ::: author
    ::: author-name
    M. Nottingham
    :::
    :::
:::

# RFC 9205 {#rfcnum}

# Building Protocols with HTTP {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

Applications often use HTTP as a substrate to create HTTP-based APIs.
This document specifies best practices for writing specifications that
use HTTP to define new application protocols. It is written primarily to
guide IETF efforts to define application protocols using HTTP for
deployment on the Internet but might be applicable in other
situations.[¶](#section-abstract-1){.pilcrow}

This document obsoletes RFC 3205.[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This memo documents an Internet Best Current
Practice.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on BCPs
is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9205>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Notational
        Conventions](#name-notational-conventions){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Is HTTP Being
    Used?](#name-is-http-being-used){.xref}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Non-HTTP
        Protocols](#name-non-http-protocols){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [What\'s Important About
    HTTP](#name-whats-important-about-http){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Generic
        Semantics](#name-generic-semantics){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Links](#name-links){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Rich
        Functionality](#name-rich-functionality){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Best Practices for Specifying the Use of
    HTTP](#name-best-practices-for-specifyi){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Specifying the Use of
        HTTP](#name-specifying-the-use-of-http){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Specifying Server
        Behaviour](#name-specifying-server-behaviour){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Specifying Client
        Behaviour](#name-specifying-client-behaviour){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Specifying
        URLs](#name-specifying-urls){.xref}

        -   ::: {#section-toc.1-1.4.2.4.2.1}
            [4.4.1](#section-4.4.1){.xref}.  [Discovering an
            Application\'s
            URLs](#name-discovering-an-applications){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.2}
            [4.4.2](#section-4.4.2){.xref}.  [Considering URI
            Schemes](#name-considering-uri-schemes){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.3}
            [4.4.3](#section-4.4.3){.xref}.  [Choosing Transport
            Ports](#name-choosing-transport-ports){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [Using HTTP
        Methods](#name-using-http-methods){.xref}

        -   ::: {#section-toc.1-1.4.2.5.2.1}
            [4.5.1](#section-4.5.1){.xref}.  [GET](#name-get){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.5.2.2}
            [4.5.2](#section-4.5.2){.xref}.  [OPTIONS](#name-options){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.6}
        [4.6](#section-4.6){.xref}.  [Using HTTP Status
        Codes](#name-using-http-status-codes){.xref}

        -   ::: {#section-toc.1-1.4.2.6.2.1}
            [4.6.1](#section-4.6.1){.xref}.  [Redirection](#name-redirection){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.7}
        [4.7](#section-4.7){.xref}.  [Specifying HTTP Header
        Fields](#name-specifying-http-header-fiel){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.8}
        [4.8](#section-4.8){.xref}.  [Defining Message
        Content](#name-defining-message-content){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.9}
        [4.9](#section-4.9){.xref}.  [Leveraging HTTP
        Caching](#name-leveraging-http-caching){.xref}

        -   ::: {#section-toc.1-1.4.2.9.2.1}
            [4.9.1](#section-4.9.1){.xref}.  [Freshness](#name-freshness){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.9.2.2}
            [4.9.2](#section-4.9.2){.xref}.  [Stale
            Responses](#name-stale-responses){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.9.2.3}
            [4.9.3](#section-4.9.3){.xref}.  [Caching and Application
            Semantics](#name-caching-and-application-sem){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.9.2.4}
            [4.9.4](#section-4.9.4){.xref}.  [Varying Content Based Upon
            the Request](#name-varying-content-based-upon-){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.10}
        [4.10](#section-4.10){.xref}. [Handling Application
        State](#name-handling-application-state){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.11}
        [4.11](#section-4.11){.xref}. [Making Multiple
        Requests](#name-making-multiple-requests){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.12}
        [4.12](#section-4.12){.xref}. [Client
        Authentication](#name-client-authentication){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.13}
        [4.13](#section-4.13){.xref}. [Coexisting with Web
        Browsing](#name-coexisting-with-web-browsin){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.14}
        [4.14](#section-4.14){.xref}. [Maintaining Application
        Boundaries](#name-maintaining-application-bou){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.15}
        [4.15](#section-4.15){.xref}. [Using Server
        Push](#name-using-server-push){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.16}
        [4.16](#section-4.16){.xref}. [Allowing Versioning and
        Evolution](#name-allowing-versioning-and-evo){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Privacy
        Considerations](#name-privacy-considerations){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [Appendix A](#appendix-A){.xref}.  [Changes from RFC
    3205](#name-changes-from-rfc-3205){.xref}
    :::

-   ::: {#section-toc.1-1.9}
    [](#appendix-B){.xref}[Author\'s
    Address](#name-authors-address){.xref}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Applications other than Web browsing often use HTTP
\[[HTTP](#HTTP){.xref}\] as a substrate, a practice sometimes referred
to as creating \"HTTP-based APIs\", \"REST APIs\", or just \"HTTP
APIs\". This is done for a variety of reasons,
including:[¶](#section-1-1){.pilcrow}

-   [familiarity by implementers, specifiers, administrators,
    developers, and users;[¶](#section-1-2.1){.pilcrow}]{#section-1-2.1}
-   [availability of a variety of client, server, and proxy
    implementations;[¶](#section-1-2.2){.pilcrow}]{#section-1-2.2}
-   [ease of use;[¶](#section-1-2.3){.pilcrow}]{#section-1-2.3}
-   [availability of Web
    browsers;[¶](#section-1-2.4){.pilcrow}]{#section-1-2.4}
-   [reuse of existing mechanisms like authentication and
    encryption;[¶](#section-1-2.5){.pilcrow}]{#section-1-2.5}
-   [presence of HTTP servers and clients in target deployments;
    and[¶](#section-1-2.6){.pilcrow}]{#section-1-2.6}
-   [its ability to traverse
    firewalls.[¶](#section-1-2.7){.pilcrow}]{#section-1-2.7}

These protocols are often ad hoc, intended for only deployment by one or
a few servers and consumption by a limited set of clients. As a result,
a body of practices and tools has arisen around defining HTTP-based APIs
that favour these conditions.[¶](#section-1-3){.pilcrow}

However, when such an application has multiple, separate
implementations, is deployed on multiple uncoordinated servers, and is
consumed by diverse clients (as is often the case for HTTP APIs defined
by standards efforts), tools and practices intended for limited
deployment can become unsuitable.[¶](#section-1-4){.pilcrow}

This mismatch is largely because the API\'s clients and servers will
implement and evolve at different paces, leading to a need for
deployments with different features and versions to coexist. As a
result, the designers of HTTP-based APIs intended for such deployments
need to more carefully consider how extensibility of the service will be
handled and how different deployment requirements will be
accommodated.[¶](#section-1-5){.pilcrow}

More generally, an application protocol using HTTP faces a number of
design decisions, including:[¶](#section-1-6){.pilcrow}

-   [Should it define a new URI scheme? Use new
    ports?[¶](#section-1-7.1){.pilcrow}]{#section-1-7.1}
-   [Should it use standard HTTP methods and status codes or define new
    ones?[¶](#section-1-7.2){.pilcrow}]{#section-1-7.2}
-   [How can the maximum value be extracted from the use of
    HTTP?[¶](#section-1-7.3){.pilcrow}]{#section-1-7.3}
-   [How does it coexist with other uses of HTTP \-- especially Web
    browsing?[¶](#section-1-7.4){.pilcrow}]{#section-1-7.4}
-   [How can interoperability problems and \"protocol dead ends\" be
    avoided?[¶](#section-1-7.5){.pilcrow}]{#section-1-7.5}

[Section 2](#used){.xref} defines when this document applies, [Section
3](#overview){.xref} surveys the properties of HTTP that are important
to preserve, and [Section 4](#bp){.xref} contains best practices for the
specification of applications that use HTTP.[¶](#section-1-8){.pilcrow}

It is written primarily to guide IETF efforts to define application
protocols using HTTP for deployment on the Internet but might be
applicable in other situations. Note that the requirements herein do not
necessarily apply to the development of generic HTTP
extensions.[¶](#section-1-9){.pilcrow}

This document obsoletes \[[RFC3205](#RFC3205){.xref}\] to reflect the
experience and developments regarding HTTP in the intervening
time.[¶](#section-1-10){.pilcrow}

::: {#notational-conventions}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Notational Conventions](#name-notational-conventions){.section-name .selfRef} {#name-notational-conventions}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-1){.pilcrow}
:::
:::
:::
:::

::: {#used}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Is HTTP Being Used?](#name-is-http-being-used){.section-name .selfRef} {#name-is-http-being-used}

Different applications have different goals when using HTTP. The
recommendations in this document apply when a specification defines an
application that:[¶](#section-2-1){.pilcrow}

-   [uses the transport port 80 or 443,
    or[¶](#section-2-2.1){.pilcrow}]{#section-2-2.1}
-   [uses the URI scheme \"http\" or \"https\",
    or[¶](#section-2-2.2){.pilcrow}]{#section-2-2.2}
-   [uses an ALPN protocol ID \[[RFC7301](#RFC7301){.xref}\] that
    generically identifies HTTP (e.g., \"http/1.1\", \"h2\", \"h3\"),
    or[¶](#section-2-2.3){.pilcrow}]{#section-2-2.3}
-   [makes registrations in or overall modifications to the IANA
    registries defined for
    HTTP.[¶](#section-2-2.4){.pilcrow}]{#section-2-2.4}

Additionally, when a specification is using HTTP, all of the
requirements of the HTTP protocol suite are in force
(\[[HTTP](#HTTP){.xref}\] in particular but also other specifications
such as the specific version of HTTP in use and any extensions in
use).[¶](#section-2-3){.pilcrow}

Note that this document is intended to apply to applications, not
generic extensions to HTTP. Furthermore, while it is intended for
IETF-specified applications, other standards organisations are
encouraged to adhere to its requirements.[¶](#section-2-4){.pilcrow}

::: {#non-http-protocols}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Non-HTTP Protocols](#name-non-http-protocols){.section-name .selfRef} {#name-non-http-protocols}

An application can rely upon HTTP without meeting the criteria for using
it as defined above. For example, an application might wish to avoid
re-specifying parts of the message format but might change other aspects
of the protocol\'s operation, or it might want to use
application-specific methods.[¶](#section-2.1-1){.pilcrow}

Doing so permits more freedom to modify protocol operations, but at
least a portion of the benefits outlined in [Section
3](#overview){.xref} are lost as most HTTP implementations won\'t be
easily adaptable to these changes. The benefit of mindshare will also be
lost.[¶](#section-2.1-2){.pilcrow}

Such specifications [MUST NOT]{.bcp14} use HTTP\'s URI schemes,
transport ports, ALPN protocol IDs, or IANA registries; rather, they are
encouraged to establish their own.[¶](#section-2.1-3){.pilcrow}
:::
:::
:::
:::

::: {#overview}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [What\'s Important About HTTP](#name-whats-important-about-http){.section-name .selfRef} {#name-whats-important-about-http}

This section examines the characteristics of HTTP that are important to
consider when using HTTP to define an application
protocol.[¶](#section-3-1){.pilcrow}

::: {#generic-semantics}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Generic Semantics](#name-generic-semantics){.section-name .selfRef} {#name-generic-semantics}

Much of the value of HTTP is in its generic semantics \-- that is, the
protocol elements defined by HTTP are potentially applicable to every
resource and are not specific to a particular context.
Application-specific semantics are best expressed in message content and
header fields, not status codes or methods (although status codes and
methods do have generic semantics that relate to application
state).[¶](#section-3.1-1){.pilcrow}

This split between generic and application-specific semantics allows an
HTTP message to be handled by common software (e.g., HTTP servers,
intermediaries, client implementations, and caches) without requiring
those implementations to understand the application in use. It also
allows people to leverage their knowledge of HTTP semantics without
needing specialised knowledge of a particular
application.[¶](#section-3.1-2){.pilcrow}

Therefore, applications that use HTTP [MUST NOT]{.bcp14} redefine,
refine, or overlay the semantics of generic protocol elements such as
methods, status codes, or existing header fields. Instead, they should
focus their specifications on protocol elements that are specific to
that application \-- namely, their HTTP
resources.[¶](#section-3.1-3){.pilcrow}

When writing a specification, it\'s often tempting to specify exactly
how HTTP is to be implemented, supported, and used. However, this can
easily lead to an unintended profile of HTTP behaviour. For example,
it\'s common to see specifications with language like
this:[¶](#section-3.1-4){.pilcrow}

> A POST request MUST result in a 201 (Created)
> response.[¶](#section-3.1-5.1){.pilcrow}

This forms an expectation in the client that the response will always be
201 (Created) when in fact there are a number of reasons why the status
code might differ in a real deployment; for example, there might be a
proxy that requires authentication, or a server-side error, or a
redirection. If the client does not anticipate this, the application\'s
deployment is brittle.[¶](#section-3.1-6){.pilcrow}

See [Section 4.2](#resource){.xref} for more
details.[¶](#section-3.1-7){.pilcrow}
:::
:::

::: {#links}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Links](#name-links){.section-name .selfRef} {#name-links}

Another common practice is assuming that the HTTP server\'s namespace
(or a portion thereof) is exclusively for the use of a single
application. This effectively overlays special, application-specific
semantics onto that space and precludes other applications from using
it.[¶](#section-3.2-1){.pilcrow}

As explained in \[[BCP190](#BCP190){.xref}\], such \"squatting\" on a
part of the URL space by a standard usurps the server\'s authority over
its own resources, can cause deployment issues, and is therefore bad
practice in standards.[¶](#section-3.2-2){.pilcrow}

Instead of statically defining URI components like paths, it is
[RECOMMENDED]{.bcp14} that applications using HTTP define and use links
\[[WEB-LINKING](#WEB-LINKING){.xref}\] to allow flexibility in
deployment.[¶](#section-3.2-3){.pilcrow}

Using runtime links in this fashion has a number of other benefits \--
especially when an application is to have multiple implementations
and/or deployments (as is often the case for those that are
standardised).[¶](#section-3.2-4){.pilcrow}

For example, navigating with a link allows a request to be routed to a
different server without the overhead of a redirection, thereby
supporting deployment across machines well.[¶](#section-3.2-5){.pilcrow}

By using links, it also becomes possible to \"mix and match\" different
applications on the same server. The use of links also offers a natural
mechanism for extensibility, versioning, and capability management
because the document containing the links can also contain information
about their targets.[¶](#section-3.2-6){.pilcrow}

Using links also offers a form of cache invalidation that\'s seen on the
Web; when a resource\'s state changes, the application can change the
affected links so that a fresh copy is always
fetched.[¶](#section-3.2-7){.pilcrow}

See [Section 4.4](#specifying-urls){.xref} for more
details.[¶](#section-3.2-8){.pilcrow}
:::
:::

::: {#rich-functionality}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Rich Functionality](#name-rich-functionality){.section-name .selfRef} {#name-rich-functionality}

HTTP offers a number of features to applications, such
as:[¶](#section-3.3-1){.pilcrow}

-   [Message framing[¶](#section-3.3-2.1){.pilcrow}]{#section-3.3-2.1}
-   [Multiplexing (in HTTP/2 \[[HTTP/2](#HTTP2){.xref}\] and HTTP/3
    \[[HTTP/3](#HTTP3){.xref}\])[¶](#section-3.3-2.2){.pilcrow}]{#section-3.3-2.2}
-   [Integration with
    TLS[¶](#section-3.3-2.3){.pilcrow}]{#section-3.3-2.3}
-   [Support for intermediaries (proxies, gateways, content delivery
    networks (CDNs))[¶](#section-3.3-2.4){.pilcrow}]{#section-3.3-2.4}
-   [Client
    authentication[¶](#section-3.3-2.5){.pilcrow}]{#section-3.3-2.5}
-   [Content negotiation for format, language, and other
    features[¶](#section-3.3-2.6){.pilcrow}]{#section-3.3-2.6}
-   [Caching for server scalability, latency and bandwidth reduction,
    and reliability[¶](#section-3.3-2.7){.pilcrow}]{#section-3.3-2.7}
-   [Granularity of access control (through use of a rich space of
    URLs)[¶](#section-3.3-2.8){.pilcrow}]{#section-3.3-2.8}
-   [Partial content to selectively request part of a
    response[¶](#section-3.3-2.9){.pilcrow}]{#section-3.3-2.9}
-   [The ability to interact with the application easily using a Web
    browser[¶](#section-3.3-2.10){.pilcrow}]{#section-3.3-2.10}

An application that uses HTTP is encouraged to utilise the various
features that the protocol offers so that its users receive the maximum
benefit from those features and so that the application can be deployed
in a variety of situations. This document does not require specific
features to be used since the appropriate design trade-offs are highly
specific to a given situation. However, following the practices in
[Section 4](#bp){.xref} is a good starting
point.[¶](#section-3.3-3){.pilcrow}
:::
:::
:::
:::

::: {#bp}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Best Practices for Specifying the Use of HTTP](#name-best-practices-for-specifyi){.section-name .selfRef} {#name-best-practices-for-specifyi}

This section contains best practices for specifying the use of HTTP by
applications, including practices for specific HTTP protocol
elements.[¶](#section-4-1){.pilcrow}

::: {#specifying-the-use-of-http}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Specifying the Use of HTTP](#name-specifying-the-use-of-http){.section-name .selfRef} {#name-specifying-the-use-of-http}

Specifications should use \[[HTTP](#HTTP){.xref}\] as the primary
reference for HTTP; it is not necessary to reference all of the
specifications in the HTTP suite unless there are specific reasons to do
so (e.g., a particular feature is called
out).[¶](#section-4.1-1){.pilcrow}

Because HTTP is a hop-by-hop protocol, a connection can be handled by
implementations that are not controlled by the application; for example,
proxies, CDNs, firewalls, and so on. Requiring a particular version of
HTTP makes it difficult to use in these situations and harms
interoperability. Therefore, it is [NOT RECOMMENDED]{.bcp14} that
applications using HTTP specify a minimum version of HTTP to be
used.[¶](#section-4.1-2){.pilcrow}

However, if an application\'s deployment benefits from the use of a
particular version of HTTP (for example, HTTP/2\'s multiplexing), this
ought be noted.[¶](#section-4.1-3){.pilcrow}

Applications using HTTP [MUST NOT]{.bcp14} specify a maximum version, to
preserve the protocol\'s ability to evolve.[¶](#section-4.1-4){.pilcrow}

When specifying examples of protocol interactions, applications should
document both the request and response messages with complete header
sections, preferably in HTTP/1.1 format \[[HTTP/1.1](#HTTP11){.xref}\].
For example:[¶](#section-4.1-5){.pilcrow}

::: {#section-4.1-6}
``` {.lang-http-message .sourcecode}
GET /thing HTTP/1.1
Host: example.com
Accept: application/things+json
User-Agent: Foo/1.0
```

[¶](#section-4.1-6){.pilcrow}
:::

::: {#section-4.1-7}
``` {.lang-http-message .sourcecode}
HTTP/1.1 200 OK
Content-Type: application/things+json
Content-Length: 500
Server: Bar/2.2

[content here]
```

[¶](#section-4.1-7){.pilcrow}
:::
:::
:::

::: {#resource}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Specifying Server Behaviour](#name-specifying-server-behaviour){.section-name .selfRef} {#name-specifying-server-behaviour}

The server-side behaviours of an application are most effectively
specified by defining the following protocol
elements:[¶](#section-4.2-1){.pilcrow}

-   [Media types \[[RFC6838](#RFC6838){.xref}\], often based upon a
    format convention such as JSON
    \[[JSON](#JSON){.xref}\];[¶](#section-4.2-2.1){.pilcrow}]{#section-4.2-2.1}
-   [HTTP header fields, per [Section 4.7](#headers){.xref};
    and[¶](#section-4.2-2.2){.pilcrow}]{#section-4.2-2.2}
-   [The behaviour of resources, as identified by link relations
    \[[WEB-LINKING](#WEB-LINKING){.xref}\].[¶](#section-4.2-2.3){.pilcrow}]{#section-4.2-2.3}

An application can define its operation by composing these protocol
elements to define a set of resources that are identified by link
relations and that implement specified behaviours,
including:[¶](#section-4.2-3){.pilcrow}

-   [retrieval of resource state using GET in one or more formats
    identified by media
    type;[¶](#section-4.2-4.1){.pilcrow}]{#section-4.2-4.1}
-   [resource creation or update using POST or PUT, with an
    appropriately identified request content
    format;[¶](#section-4.2-4.2){.pilcrow}]{#section-4.2-4.2}
-   [data processing using POST and identified request and response
    content format(s);
    and[¶](#section-4.2-4.3){.pilcrow}]{#section-4.2-4.3}
-   [Resource deletion using
    DELETE.[¶](#section-4.2-4.4){.pilcrow}]{#section-4.2-4.4}

For example, an application might specify:[¶](#section-4.2-5){.pilcrow}

> Resources linked to with the \"example-widget\" link relation type are
> Widgets. The state of a Widget can be fetched in the
> \"application/example-widget+json\" format, and can be updated by PUT
> to the same link. Widget resources can be
> deleted.[¶](#section-4.2-6.1){.pilcrow}
>
> The Example-Count response header field on Widget representations
> indicates how many Widgets are held by the
> sender.[¶](#section-4.2-6.2){.pilcrow}
>
> The \"application/example-widget+json\" format is a JSON \[RFC8259\]
> format representing the state of a Widget. It contains links to
> related information in the link indicated by the Link header field
> value with the \"example-other-info\" link relation
> type.[¶](#section-4.2-6.3){.pilcrow}

Applications can also specify the use of URI Templates
\[[URI-TEMPLATE](#URI-TEMPLATE){.xref}\] to allow clients to generate
URLs based upon runtime data.[¶](#section-4.2-7){.pilcrow}
:::
:::

::: {#clients}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Specifying Client Behaviour](#name-specifying-client-behaviour){.section-name .selfRef} {#name-specifying-client-behaviour}

An application\'s expectations for client behaviour ought to be closely
aligned with those of Web browsers to avoid interoperability issues when
they are used.[¶](#section-4.3-1){.pilcrow}

One way to do this is to define it in terms of
\[[FETCH](#FETCH){.xref}\] since that is the abstraction that browsers
use for HTTP.[¶](#section-4.3-2){.pilcrow}

Some client behaviours (e.g., automatic redirect handling) and
extensions (e.g., cookies) are not required by HTTP but nevertheless
have become very common. If their use is not explicitly specified by
applications using HTTP, there may be confusion and interoperability
problems. In particular:[¶](#section-4.3-3){.pilcrow}

[]{.break}

Redirect handling:
:   Applications need to specify how redirects are expected to be
    handled; see [Section
    4.6.1](#redirects){.xref}.[¶](#section-4.3-4.2){.pilcrow}
:   

Cookies:
:   Applications using HTTP should explicitly reference the Cookie
    specification \[[COOKIES](#COOKIES){.xref}\] if they are
    required.[¶](#section-4.3-4.4){.pilcrow}
:   

Certificates:
:   Applications using HTTP should specify that TLS certificates are to
    be checked according to [Section
    4.3.4](https://www.rfc-editor.org/rfc/rfc9110#section-4.3.4){.relref}
    of \[[HTTP](#HTTP){.xref}\] when HTTPS is
    used.[¶](#section-4.3-4.6){.pilcrow}
:   

Applications using HTTP should not require that clients statically
support HTTP features that are usually negotiated. For example,
requiring that clients support responses with a certain content coding
(\[[HTTP](#HTTP){.xref}\], [Section
8.4.1](https://www.rfc-editor.org/rfc/rfc9110#section-8.4.1){.relref})
instead of negotiating for it (\[[HTTP](#HTTP){.xref}\], [Section
12.5.3](https://www.rfc-editor.org/rfc/rfc9110#section-12.5.3){.relref})
means that otherwise conformant clients cannot interoperate with the
application. Applications can encourage the implementation of such
features, though.[¶](#section-4.3-5){.pilcrow}
:::
:::

::: {#specifying-urls}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Specifying URLs](#name-specifying-urls){.section-name .selfRef} {#name-specifying-urls}

In HTTP, the resources that clients interact with are identified with
URLs \[[URL](#URL){.xref}\]. As \[[BCP190](#BCP190){.xref}\] explains,
parts of the URL are designed to be under the control of the owner (also
known as the \"authority\") of that server to give them the flexibility
in deployment.[¶](#section-4.4-1){.pilcrow}

This means that in most cases, specifications for applications that use
HTTP won\'t contain fixed application URLs or paths; while it is common
practice for a specification of a single-deployment API to specify the
path prefix \"/app/v1\" (for example), doing so in an IETF specification
is inappropriate.[¶](#section-4.4-2){.pilcrow}

Therefore, the specification writer needs some mechanism to allow
clients to discover an application\'s URLs. Additionally, they need to
specify which URL scheme(s) the application should be used with and
whether to use a dedicated port or to reuse HTTP\'s
port(s).[¶](#section-4.4-3){.pilcrow}

::: {#discovering-an-applications-urls}
::: {#section-4.4.1 .section}
#### [4.4.1.](#section-4.4.1){.section-number .selfRef} [Discovering an Application\'s URLs](#name-discovering-an-applications){.section-name .selfRef} {#name-discovering-an-applications}

Generally, a client will begin interacting with a given application
server by requesting an initial document that contains information about
that particular deployment, potentially including links to other
relevant resources. Doing so ensures that the deployment is as flexible
as possible (potentially spanning multiple servers), allows evolution,
and also gives the application the opportunity to tailor the \"discovery
document\" to the client.[¶](#section-4.4.1-1){.pilcrow}

There are a few common patterns for discovering that initial
URL.[¶](#section-4.4.1-2){.pilcrow}

The most straightforward mechanism for URL discovery is to configure the
client with (or otherwise convey to it) a full URL. This might be done
in a configuration document or through another discovery
mechanism.[¶](#section-4.4.1-3){.pilcrow}

However, if the client only knows the server\'s hostname and the
identity of the application, there needs to be some way to derive the
initial URL from that information.[¶](#section-4.4.1-4){.pilcrow}

An application cannot define a fixed prefix for its URL paths; see
\[[BCP190](#BCP190){.xref}\]. Instead, a specification for such an
application can use one of the following
strategies:[¶](#section-4.4.1-5){.pilcrow}

-   [Register a well-known URI
    \[[WELL-KNOWN-URI](#WELL-KNOWN-URI){.xref}\] as an entry point for
    that application. This provides a fixed path on every potential
    server that will not collide with other
    applications.[¶](#section-4.4.1-6.1){.pilcrow}]{#section-4.4.1-6.1}
-   [Enable the server authority to convey a URI Template
    \[[URI-TEMPLATE](#URI-TEMPLATE){.xref}\] or similar mechanism for
    generating a URL for an entry point. For example, this might be done
    in a configuration document or other
    artefact.[¶](#section-4.4.1-6.2){.pilcrow}]{#section-4.4.1-6.2}

Once the discovery document is located, it can be fetched, cached for
later reuse (if allowed by its metadata), and used to locate other
resources that are relevant to the application using full URIs or URL
Templates.[¶](#section-4.4.1-7){.pilcrow}

In some cases, an application may not wish to use such a discovery
document \-- for example, when communication is very brief or when the
latency concerns of doing so preclude the use of a discovery document.
These situations can be addressed by placing all of the application\'s
resources under a well-known location.[¶](#section-4.4.1-8){.pilcrow}
:::
:::

::: {#scheme}
::: {#section-4.4.2 .section}
#### [4.4.2.](#section-4.4.2){.section-number .selfRef} [Considering URI Schemes](#name-considering-uri-schemes){.section-name .selfRef} {#name-considering-uri-schemes}

Applications that use HTTP will typically employ the \"http\" and/or
\"https\" URI schemes. \"https\" is [RECOMMENDED]{.bcp14} to provide
authentication, integrity, and confidentiality, as well as to mitigate
pervasive monitoring attacks
\[[RFC7258](#RFC7258){.xref}\].[¶](#section-4.4.2-1){.pilcrow}

However, application-specific schemes can also be defined. When defining
a URI scheme for an application using HTTP, there are a number of
trade-offs and caveats to keep in mind:[¶](#section-4.4.2-2){.pilcrow}

-   [Unmodified Web browsers will not support the new scheme. While it
    is possible to register new URI schemes with Web browsers (e.g.,
    registerProtocolHandler() in \[[HTML](#HTML){.xref}\], as well as
    several proprietary approaches), support for these mechanisms is not
    shared by all browsers, and their capabilities
    vary.[¶](#section-4.4.2-3.1){.pilcrow}]{#section-4.4.2-3.1}
-   [Existing non-browser clients, intermediaries, servers, and
    associated software will not recognise the new scheme. For example,
    a client library might fail to dispatch the request, a cache might
    refuse to store the response, and a proxy might fail to forward the
    request.[¶](#section-4.4.2-3.2){.pilcrow}]{#section-4.4.2-3.2}
-   [Because URLs commonly occur in HTTP artefacts and are often
    generated automatically (e.g., in the Location response header
    field), it can be difficult to ensure that the new scheme is used
    consistently.[¶](#section-4.4.2-3.3){.pilcrow}]{#section-4.4.2-3.3}
-   [The resources identified by the new scheme will still be available
    using \"http\" and/or \"https\" URLs. Those URLs can \"leak\" into
    use, which can present security and operability issues. For example,
    using a new scheme to ensure that requests don\'t get sent to a
    \"normal\" Web site is likely to
    fail.[¶](#section-4.4.2-3.4){.pilcrow}]{#section-4.4.2-3.4}
-   [Features that rely upon the URL\'s origin
    \[[RFC6454](#RFC6454){.xref}\], such as the Web\'s same-origin
    policy, will be impacted by a change of
    scheme.[¶](#section-4.4.2-3.5){.pilcrow}]{#section-4.4.2-3.5}
-   [HTTP-specific features such as cookies
    \[[COOKIES](#COOKIES){.xref}\], authentication
    \[[HTTP](#HTTP){.xref}\], caching
    \[[HTTP-CACHING](#HTTP-CACHING){.xref}\], HTTP Strict Transport
    Security (HSTS) \[[RFC6797](#RFC6797){.xref}\], and Cross-Origin
    Resource Sharing (CORS) \[[FETCH](#FETCH){.xref}\] might or might
    not work correctly, depending on how they are defined and
    implemented. Generally, they are designed and implemented with an
    assumption that the URL will always be \"http\" or
    \"https\".[¶](#section-4.4.2-3.6){.pilcrow}]{#section-4.4.2-3.6}
-   [Web features that require a secure context
    \[[SECCTXT](#SECCTXT){.xref}\] will likely treat a new scheme as
    insecure.[¶](#section-4.4.2-3.7){.pilcrow}]{#section-4.4.2-3.7}

See \[[RFC7595](#RFC7595){.xref}\] for more information about minting
new URI schemes.[¶](#section-4.4.2-4){.pilcrow}
:::
:::

::: {#choosing-transport-ports}
::: {#section-4.4.3 .section}
#### [4.4.3.](#section-4.4.3){.section-number .selfRef} [Choosing Transport Ports](#name-choosing-transport-ports){.section-name .selfRef} {#name-choosing-transport-ports}

Applications can use the applicable default port (80 for HTTP, 443 for
HTTPS), or they can be deployed upon other ports. This decision can be
made at deployment time or might be encouraged by the application\'s
specification (e.g., by registering a port for that
application).[¶](#section-4.4.3-1){.pilcrow}

If a non-default port is used, it needs to be reflected in the authority
of all URLs for that resource; the only mechanism for changing a default
port is changing the URI scheme (see [Section
4.4.2](#scheme){.xref}).[¶](#section-4.4.3-2){.pilcrow}

Using a port other than the default has privacy implications (i.e., the
protocol can now be distinguished from other traffic), as well as
operability concerns (as some networks might block or otherwise
interfere with it). Privacy implications (including those stemming from
this distinguishability) should be documented in Security
Considerations.[¶](#section-4.4.3-3){.pilcrow}

See \[[RFC7605](#RFC7605){.xref}\] for further
guidance.[¶](#section-4.4.3-4){.pilcrow}
:::
:::
:::
:::

::: {#using-http-methods}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [Using HTTP Methods](#name-using-http-methods){.section-name .selfRef} {#name-using-http-methods}

Applications that use HTTP [MUST]{.bcp14} confine themselves to using
registered HTTP methods such as GET, POST, PUT, DELETE, and
PATCH.[¶](#section-4.5-1){.pilcrow}

New HTTP methods are rare; they are required to be registered in the
\"HTTP Method Registry\" with IETF Review (see \[[HTTP](#HTTP){.xref}\])
and are also required to be generic. That means that they need to be
potentially applicable to all resources, not just those of one
application.[¶](#section-4.5-2){.pilcrow}

While historically some applications (e.g.,
\[[RFC4791](#RFC4791){.xref}\]) have defined application-specific
methods, \[[HTTP](#HTTP){.xref}\] now forbids
this.[¶](#section-4.5-3){.pilcrow}

When authors believe that a new method is required, they are encouraged
to engage with the HTTP community early (e.g., on the
\<[mailto:ietf-http-wg\@w3.org](mailto:ietf-http-wg@w3.org)\> mailing
list) and document their proposal as a separate HTTP extension rather
than as part of an application\'s
specification.[¶](#section-4.5-4){.pilcrow}

::: {#get}
::: {#section-4.5.1 .section}
#### [4.5.1.](#section-4.5.1){.section-number .selfRef} [GET](#name-get){.section-name .selfRef} {#name-get}

GET is the most common and useful HTTP method; its retrieval semantics
allow caching and side-effect free linking and underlie many of the
benefits of using HTTP.[¶](#section-4.5.1-1){.pilcrow}

Queries can be performed with GET, often using the query component of
the URL; this is a familiar pattern from Web browsing, and the results
can be cached, improving the efficiency of an often expensive process.
In some cases, however, GET might be unwieldy for expressing queries
because of the limited syntax of the URI; in particular, if binary data
forms part of the query terms, it needs to be encoded to conform to the
URI syntax.[¶](#section-4.5.1-2){.pilcrow}

While this is not an issue for short queries, it can become one for
larger query terms or those that need to sustain a high rate of
requests. Additionally, some HTTP implementations limit the size of URLs
they support, although modern HTTP software has much more generous
limits than previously (typically, considerably more than 8000 octets,
as required by \[[HTTP](#HTTP){.xref}\]).[¶](#section-4.5.1-3){.pilcrow}

In these cases, an application using HTTP might consider using POST to
express queries in the request\'s content; doing so avoids encoding
overhead and URL length limits in implementations. However, in doing so,
it should be noted that the benefits of GET such as caching and linking
to query results are lost. Therefore, applications using HTTP that
require support for POST queries ought to consider allowing both
methods.[¶](#section-4.5.1-4){.pilcrow}

Processing of GET requests should not change the application\'s state or
have other side effects that might be significant to the client since
implementations can and do retry HTTP GET requests that fail.
Furthermore, some GET requests protected by TLS early data might be
vulnerable to replay attacks (see \[[RFC8470](#RFC8470){.xref}\]). Note
that this does not include logging and similar functions; see
\[[HTTP](#HTTP){.xref}\], [Section
9.2.1](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.1){.relref}.[¶](#section-4.5.1-5){.pilcrow}

Finally, note that while the generic HTTP syntax allows a GET request
message to contain content, the purpose is to allow message parsers to
be generic; per \[[HTTP](#HTTP){.xref}\], [Section
9.3.1](https://www.rfc-editor.org/rfc/rfc9110#section-9.3.1){.relref},
content in a GET is not recommended, has no meaning, and will be either
ignored or rejected by generic HTTP software (such as intermediaries,
caches, servers, and client libraries).[¶](#section-4.5.1-6){.pilcrow}
:::
:::

::: {#options}
::: {#section-4.5.2 .section}
#### [4.5.2.](#section-4.5.2){.section-number .selfRef} [OPTIONS](#name-options){.section-name .selfRef} {#name-options}

The OPTIONS method was defined for metadata retrieval and is used both
by Web Distributed Authoring and Versioning (WebDAV)
\[[RFC4918](#RFC4918){.xref}\] and CORS \[[FETCH](#FETCH){.xref}\].
Because HTTP-based APIs often need to retrieve metadata about resources,
it is often considered for their use.[¶](#section-4.5.2-1){.pilcrow}

However, OPTIONS does have significant
limitations:[¶](#section-4.5.2-2){.pilcrow}

-   [It isn\'t possible to link to the metadata with a simple URL
    because OPTIONS is not the default
    method.[¶](#section-4.5.2-3.1){.pilcrow}]{#section-4.5.2-3.1}
-   [OPTIONS responses are not cacheable because HTTP caches operate on
    representations of the resource (i.e., GET and HEAD). If OPTIONS
    responses are cached separately, their interactions with the HTTP
    cache expiry, secondary keys, and other mechanisms need to be
    considered.[¶](#section-4.5.2-3.2){.pilcrow}]{#section-4.5.2-3.2}
-   [OPTIONS is \"chatty\" \-- requesting metadata separately increases
    the number of requests needed to interact with the
    application.[¶](#section-4.5.2-3.3){.pilcrow}]{#section-4.5.2-3.3}
-   [Implementation support for OPTIONS is not universal; some servers
    do not expose the ability to respond to OPTIONS requests without
    significant
    effort.[¶](#section-4.5.2-3.4){.pilcrow}]{#section-4.5.2-3.4}

Instead of OPTIONS, one of these alternative approaches might be more
appropriate:[¶](#section-4.5.2-4){.pilcrow}

-   [For server-wide metadata, create a well-known URI
    \[[WELL-KNOWN-URI](#WELL-KNOWN-URI){.xref}\] or use an already
    existing one if appropriate (e.g., host-meta
    \[[RFC6415](#RFC6415){.xref}\]).[¶](#section-4.5.2-5.1){.pilcrow}]{#section-4.5.2-5.1}
-   [For metadata about a specific resource, create a separate resource
    and link to it using a Link response header field or a link
    serialised into the response\'s content. See
    \[[WEB-LINKING](#WEB-LINKING){.xref}\]. Note that the Link header
    field is available on HEAD responses, which is useful if the client
    wants to discover a resource\'s capabilities before they interact
    with it.[¶](#section-4.5.2-5.2){.pilcrow}]{#section-4.5.2-5.2}
:::
:::
:::
:::

::: {#using-http-status-codes}
::: {#section-4.6 .section}
### [4.6.](#section-4.6){.section-number .selfRef} [Using HTTP Status Codes](#name-using-http-status-codes){.section-name .selfRef} {#name-using-http-status-codes}

HTTP status codes convey semantics both for the benefit of generic HTTP
components \-- such as caches, intermediaries, and clients \-- and
applications themselves. However, applications can encounter a number of
pitfalls in their use.[¶](#section-4.6-1){.pilcrow}

First, status codes are often generated by components other than the
application itself. This can happen, for example, when network errors
are encountered; when a captive portal, proxy, or content delivery
network is present; or when a server is overloaded or thinks it is under
attack. They can even be generated by generic client software when
certain error conditions are encountered. As a result, if an application
assigns specific semantics to one of these status codes, a client can be
misled about its state because the status code was generated by a
generic component, not the application
itself.[¶](#section-4.6-2){.pilcrow}

Furthermore, mapping application errors to individual HTTP status codes
one-to-one often leads to a situation where the finite space of
applicable HTTP status codes is exhausted. This, in turn, leads to a
number of bad practices \-- including minting new, application-specific
status codes or using existing status codes even though the link between
their semantics and the application\'s is tenuous at
best.[¶](#section-4.6-3){.pilcrow}

Instead, applications using HTTP should define their errors to use the
most applicable status code, making generous use of the general status
codes (200, 400, and 500) when in doubt. Importantly, they should not
specify a one-to-one relationship between status codes and application
errors, thereby avoiding the exhaustion issue outlined
above.[¶](#section-4.6-4){.pilcrow}

To distinguish between multiple error conditions that are mapped to the
same status code and to avoid the misattribution issue outlined above,
applications using HTTP should convey finer-grained error information in
the response\'s message content and/or header fields.
\[[PROBLEM-DETAILS](#PROBLEM-DETAILS){.xref}\] provides one way to do
so.[¶](#section-4.6-5){.pilcrow}

Because the set of registered HTTP status codes can expand, applications
using HTTP should explicitly point out that clients ought to be able to
handle all applicable status codes gracefully (i.e., falling back to the
generic n00 semantics of a given status code; e.g., 499 can be safely
handled as 400 (Bad Request) by clients that don\'t recognise it). This
is preferable to creating a \"laundry list\" of potential status codes
since such a list won\'t be complete in the foreseeable
future.[¶](#section-4.6-6){.pilcrow}

Applications using HTTP [MUST NOT]{.bcp14} re-specify the semantics of
HTTP status codes, even if it is only by copying their definition. It is
[NOT RECOMMENDED]{.bcp14} they require specific reason phrases to be
used; the reason phrase has no function in HTTP, is not guaranteed to be
preserved by implementations, and is not carried at all in the HTTP/2
\[[HTTP/2](#HTTP2){.xref}\] message format.[¶](#section-4.6-7){.pilcrow}

Applications [MUST]{.bcp14} only use registered HTTP status codes. As
with methods, new HTTP status codes are rare and required (by
\[[HTTP](#HTTP){.xref}\]) to be registered with IETF Review. Similarly,
HTTP status codes are generic; they are required (by
\[[HTTP](#HTTP){.xref}\]) to be potentially applicable to all resources,
not just to those of one application.[¶](#section-4.6-8){.pilcrow}

When authors believe that a new status code is required, they are
encouraged to engage with the HTTP community early (e.g., on the
\<[mailto:ietf-http-wg\@w3.org](mailto:ietf-http-wg@w3.org)\> mailing
list) and document their proposal as a separate HTTP extension, rather
than as part of an application\'s
specification.[¶](#section-4.6-9){.pilcrow}

::: {#redirects}
::: {#section-4.6.1 .section}
#### [4.6.1.](#section-4.6.1){.section-number .selfRef} [Redirection](#name-redirection){.section-name .selfRef} {#name-redirection}

The 3xx series of status codes specified in [Section
15.4](https://www.rfc-editor.org/rfc/rfc9110#section-15.4){.relref} of
\[[HTTP](#HTTP){.xref}\] directs the user agent to another resource to
satisfy the request. The most common of these are 301, 302, 307, and
308, all of which use the Location response header field to indicate
where the client should resend the
request.[¶](#section-4.6.1-1){.pilcrow}

There are two ways that the members of this group of status codes
differ:[¶](#section-4.6.1-2){.pilcrow}

-   [Whether they are permanent or temporary. Permanent redirects can be
    used to update links stored in the client (e.g., bookmarks), whereas
    temporary ones cannot. Note that this has no effect on HTTP caching;
    it is completely
    separate.[¶](#section-4.6.1-3.1){.pilcrow}]{#section-4.6.1-3.1}
-   [Whether they allow the redirected request to change the request
    method from POST to GET. Web browsers generally do change POST to
    GET for 301 and 302; therefore, 308 and 307 were created to allow
    redirection without changing the
    method.[¶](#section-4.6.1-3.2){.pilcrow}]{#section-4.6.1-3.2}

This table summarises their
relationships:[¶](#section-4.6.1-4){.pilcrow}

                                                         Permanent   Temporary
  ------------------------------------------------------ ----------- -----------
  Allows change of the request method from POST to GET   301         302
  Does not allow change of the request method            308         307

  : [Table 1](#table-1){.selfRef}

The 303 (See Other) status code can be used to inform the client that
the result of an operation is available at a different location using
GET.[¶](#section-4.6.1-6){.pilcrow}

As noted in \[[HTTP](#HTTP){.xref}\], a user agent is allowed to
automatically follow a 3xx redirect that has a Location response header
field, even if they don\'t understand the semantics of the specific
status code. However, they aren\'t required to do so; therefore, if an
application using HTTP desires redirects to be automatically followed,
it needs to explicitly specify the circumstances when this is
required.[¶](#section-4.6.1-7){.pilcrow}

Redirects can be cached (when appropriate cache directives are present),
but beyond that, they are not \"sticky\" \-- i.e., redirection of a URI
will not result in the client assuming that similar URIs (e.g., with
different query parameters) will also be
redirected.[¶](#section-4.6.1-8){.pilcrow}

Applications using HTTP are encouraged to specify that 301 and 302
responses change the subsequent request method from POST (but no other
method) to GET to be compatible with browsers. Generally, when a
redirected request is made, its header fields are copied from the
original request. However, they can be modified by various mechanisms;
e.g., sent Authorization (\[[HTTP](#HTTP){.xref}\], [Section
11](https://www.rfc-editor.org/rfc/rfc9110#section-11){.relref}) and
Cookie (\[[COOKIES](#COOKIES){.xref}\]) header fields will change if the
origin (and sometimes path) of the request changes. An application using
HTTP should specify if any request header fields that it defines need to
be modified or removed upon a redirect; however, this behaviour cannot
be relied upon since a generic client (like a browser) will be unaware
of such requirements.[¶](#section-4.6.1-9){.pilcrow}
:::
:::
:::
:::

::: {#headers}
::: {#section-4.7 .section}
### [4.7.](#section-4.7){.section-number .selfRef} [Specifying HTTP Header Fields](#name-specifying-http-header-fiel){.section-name .selfRef} {#name-specifying-http-header-fiel}

Applications often define new HTTP header fields. Typically, using HTTP
header fields is appropriate in a few different
situations:[¶](#section-4.7-1){.pilcrow}

-   [The field is useful to intermediaries (who often wish to avoid
    parsing message content),
    and/or[¶](#section-4.7-2.1){.pilcrow}]{#section-4.7-2.1}
-   [The field is useful to generic HTTP software (e.g., clients,
    servers), and/or[¶](#section-4.7-2.2){.pilcrow}]{#section-4.7-2.2}
-   [It is not possible to include their values in the message content
    (usually because a format does not allow
    it).[¶](#section-4.7-2.3){.pilcrow}]{#section-4.7-2.3}

When the conditions above are not met, it is usually better to convey
application-specific information in other places \-- e.g., the message
content or the URL query string.[¶](#section-4.7-3){.pilcrow}

New header fields [MUST]{.bcp14} be registered, per [Section
16.3](https://www.rfc-editor.org/rfc/rfc9110#section-16.3){.relref} of
\[[HTTP](#HTTP){.xref}\].[¶](#section-4.7-4){.pilcrow}

See [Section
16.3.2](https://www.rfc-editor.org/rfc/rfc9110#section-16.3.2){.relref}
of \[[HTTP](#HTTP){.xref}\] for guidelines to consider when minting new
header fields. \[[STRUCTURED-FIELDS](#STRUCTURED-FIELDS){.xref}\]
provides a common structure for new header fields and avoids many issues
in their parsing and handling; it is [RECOMMENDED]{.bcp14} that new
header fields use it.[¶](#section-4.7-5){.pilcrow}

It is [RECOMMENDED]{.bcp14} that header field names be short (even when
field compression is used, there is an overhead) but appropriately
specific. In particular, if a header field is specific to an
application, an identifier for that application can form a prefix to the
header field name, separated by a hyphen.[¶](#section-4.7-6){.pilcrow}

For example, if the \"example\" application needs to create three header
fields, they might be called \"example-foo\", \"example-bar\", and
\"example-baz\". Note that the primary motivation here is to avoid
consuming more generic field names, not to reserve a portion of the
namespace for the application; see \[[RFC6648](#RFC6648){.xref}\] for
related considerations.[¶](#section-4.7-7){.pilcrow}

The semantics of existing HTTP header fields [MUST NOT]{.bcp14} be
redefined without updating their registration or defining an extension
to them (if allowed). For example, an application using HTTP cannot
specify that the Location header field has a special meaning in a
certain context.[¶](#section-4.7-8){.pilcrow}

See [Section 4.9](#caching){.xref} for the interaction between header
fields and HTTP caching; in particular, request header fields that are
used to choose (per [Section
4.1](https://www.rfc-editor.org/rfc/rfc9111#section-4.1){.relref} of
\[[HTTP-CACHING](#HTTP-CACHING){.xref}\]) a response have impact there
and need to be carefully considered.[¶](#section-4.7-9){.pilcrow}

See [Section 4.10](#state){.xref} for considerations regarding header
fields that carry application state (e.g.,
Cookie).[¶](#section-4.7-10){.pilcrow}
:::
:::

::: {#content}
::: {#section-4.8 .section}
### [4.8.](#section-4.8){.section-number .selfRef} [Defining Message Content](#name-defining-message-content){.section-name .selfRef} {#name-defining-message-content}

Common syntactic conventions for message contents include JSON
\[[JSON](#JSON){.xref}\], XML \[[XML](#XML){.xref}\], and Concise Binary
Object Representation (CBOR) \[[RFC8949](#RFC8949){.xref}\]. Best
practices for their use are out of scope for this
document.[¶](#section-4.8-1){.pilcrow}

Applications should register distinct media types for each format they
define; this makes it possible to identify them unambiguously and
negotiate for their use. See \[[RFC6838](#RFC6838){.xref}\] for more
information.[¶](#section-4.8-2){.pilcrow}
:::
:::

::: {#caching}
::: {#section-4.9 .section}
### [4.9.](#section-4.9){.section-number .selfRef} [Leveraging HTTP Caching](#name-leveraging-http-caching){.section-name .selfRef} {#name-leveraging-http-caching}

HTTP caching \[[HTTP-CACHING](#HTTP-CACHING){.xref}\] is one of the
primary benefits of using HTTP for applications; it provides
scalability, reduces latency, and improves reliability. Furthermore,
HTTP caches are readily available in browsers and other clients,
networks as forward and reverse proxies, content delivery networks, and
as part of server software.[¶](#section-4.9-1){.pilcrow}

Even when an application using HTTP isn\'t designed to take advantage of
caching, it needs to consider how caches will handle its responses to
preserve correct behaviour when one is interposed (whether in the
network, server, client, or intervening
infrastructure).[¶](#section-4.9-2){.pilcrow}

::: {#freshness}
::: {#section-4.9.1 .section}
#### [4.9.1.](#section-4.9.1){.section-number .selfRef} [Freshness](#name-freshness){.section-name .selfRef} {#name-freshness}

Assigning even a short freshness lifetime
(\[[HTTP-CACHING](#HTTP-CACHING){.xref}\], [Section
4.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.2){.relref}) \--
e.g., 5 seconds \-- allows a response to be reused to satisfy multiple
clients and/or a single client making the same request repeatedly. In
general, if it is safe to reuse something, consider assigning a
freshness lifetime.[¶](#section-4.9.1-1){.pilcrow}

The most common method for specifying freshness is the max-age response
directive (\[[HTTP-CACHING](#HTTP-CACHING){.xref}\], [Section
5.2.2.1](https://www.rfc-editor.org/rfc/rfc9111#section-5.2.2.1){.relref}).
The Expires header field (\[[HTTP-CACHING](#HTTP-CACHING){.xref}\],
[Section
5.3](https://www.rfc-editor.org/rfc/rfc9111#section-5.3){.relref}) can
also be used, but it is not necessary; all modern cache implementations
support the Cache-Control header field, and specifying freshness as a
delta is usually more convenient and less
error-prone.[¶](#section-4.9.1-2){.pilcrow}

It is not necessary to add the public response directive
(\[[HTTP-CACHING](#HTTP-CACHING){.xref}\], [Section
5.2.2.9](https://www.rfc-editor.org/rfc/rfc9111#section-5.2.2.9){.relref})
to cache most responses; it is only necessary when it\'s desirable to
store an authenticated response, or when the status code isn\'t
understood by the cache and there isn\'t explicit freshness information
available.[¶](#section-4.9.1-3){.pilcrow}

In some situations, responses without explicit cache freshness
directives will be stored and served using a heuristic freshness
lifetime; see \[[HTTP-CACHING](#HTTP-CACHING){.xref}\], [Section
4.2.2](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.2){.relref}.
As the heuristic is not under the control of the application, it is
generally preferable to set an explicit freshness lifetime or make the
response explicitly uncacheable.[¶](#section-4.9.1-4){.pilcrow}

If caching of a response is not desired, the appropriate cache response
directive is no-store. Other directives are not necessary, and no-store
only needs to be sent in situations where the response might be cached;
see \[[HTTP-CACHING](#HTTP-CACHING){.xref}\], [Section
3](https://www.rfc-editor.org/rfc/rfc9111#section-3){.relref}. Note that
the no-cache directive allows a response to be stored, just not reused
by a cache without validation; it does not prevent caching (despite its
name).[¶](#section-4.9.1-5){.pilcrow}

For example, this response cannot be stored or reused by a
cache:[¶](#section-4.9.1-6){.pilcrow}

::: {#section-4.9.1-7}
``` {.lang-http-message .sourcecode}
HTTP/1.1 200 OK
Content-Type: application/example+xml
Cache-Control: no-store

[content]
```

[¶](#section-4.9.1-7){.pilcrow}
:::
:::
:::

::: {#stale-responses}
::: {#section-4.9.2 .section}
#### [4.9.2.](#section-4.9.2){.section-number .selfRef} [Stale Responses](#name-stale-responses){.section-name .selfRef} {#name-stale-responses}

Authors should understand that stale responses (e.g., with
Cache-Control: max-age=0) can be reused by caches when disconnected from
the origin server; this can be useful for handling network
issues.[¶](#section-4.9.2-1){.pilcrow}

If doing so is not suitable for a given response, the origin should send
the must-revalidate cache directive. See [Section
4.2.4](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.4){.relref} of
\[[HTTP-CACHING](#HTTP-CACHING){.xref}\] and also
\[[RFC5861](#RFC5861){.xref}\] for additional controls over stale
content.[¶](#section-4.9.2-2){.pilcrow}

Stale responses can be refreshed by assigning a validator, saving both
transfer bandwidth and latency for large responses; see [Section
13](https://www.rfc-editor.org/rfc/rfc9110#section-13){.relref} of
\[[HTTP](#HTTP){.xref}\].[¶](#section-4.9.2-3){.pilcrow}
:::
:::

::: {#caching-app-semantics}
::: {#section-4.9.3 .section}
#### [4.9.3.](#section-4.9.3){.section-number .selfRef} [Caching and Application Semantics](#name-caching-and-application-sem){.section-name .selfRef} {#name-caching-and-application-sem}

When an application has a need to express a lifetime that\'s separate
from the freshness lifetime, this should be conveyed separately, either
in the response\'s content or in a separate header field. When this
happens, the relationship between HTTP caching and that lifetime needs
to be carefully considered since the response will be used as long as it
is considered fresh.[¶](#section-4.9.3-1){.pilcrow}

In particular, application authors need to consider how responses that
are not freshly obtained from the origin server should be handled; if
they have a concept like a validity period, this will need to be
calculated considering the age of the response (see
\[[HTTP-CACHING](#HTTP-CACHING){.xref}\], [Section
4.2.3](https://www.rfc-editor.org/rfc/rfc9111#section-4.2.3){.relref}).[¶](#section-4.9.3-2){.pilcrow}

One way to address this is to explicitly specify that responses need to
be fresh upon use.[¶](#section-4.9.3-3){.pilcrow}
:::
:::

::: {#varying-content-based-upon-the-request}
::: {#section-4.9.4 .section}
#### [4.9.4.](#section-4.9.4){.section-number .selfRef} [Varying Content Based Upon the Request](#name-varying-content-based-upon-){.section-name .selfRef} {#name-varying-content-based-upon-}

If an application uses a request header field to change the response\'s
header fields or content, authors should point out that this has
implications for caching; in general, such resources need to either make
their responses uncacheable (e.g., with the no-store cache directive
defined in \[[HTTP-CACHING](#HTTP-CACHING){.xref}\], [Section
5.2.2.5](https://www.rfc-editor.org/rfc/rfc9111#section-5.2.2.5){.relref})
or send the Vary response header field (\[[HTTP](#HTTP){.xref}\],
[Section
12.5.5](https://www.rfc-editor.org/rfc/rfc9110#section-12.5.5){.relref})
on all responses from that resource (including the \"default\"
response).[¶](#section-4.9.4-1){.pilcrow}

For example, this response:[¶](#section-4.9.4-2){.pilcrow}

::: {#section-4.9.4-3}
``` {.lang-http-message .sourcecode}
HTTP/1.1 200 OK
Content-Type: application/example+xml
Cache-Control: max-age=60
ETag: "sa0f8wf20fs0f"
Vary: Accept-Encoding

[content]
```

[¶](#section-4.9.4-3){.pilcrow}
:::

can be stored for 60 seconds by both private and shared caches, can be
revalidated with If-None-Match, and varies on the Accept-Encoding
request header field.[¶](#section-4.9.4-4){.pilcrow}
:::
:::
:::
:::

::: {#state}
::: {#section-4.10 .section}
### [4.10.](#section-4.10){.section-number .selfRef} [Handling Application State](#name-handling-application-state){.section-name .selfRef} {#name-handling-application-state}

Applications can use stateful cookies \[[COOKIES](#COOKIES){.xref}\] to
identify a client and/or store client-specific data to contextualise
requests.[¶](#section-4.10-1){.pilcrow}

When used, it is important to carefully specify the scoping and use of
cookies; if the application exposes sensitive data or capabilities
(e.g., by acting as an ambient authority), exploits are possible.
Mitigations include using a request-specific token to ensure the intent
of the client.[¶](#section-4.10-2){.pilcrow}
:::
:::

::: {#multiplex}
::: {#section-4.11 .section}
### [4.11.](#section-4.11){.section-number .selfRef} [Making Multiple Requests](#name-making-multiple-requests){.section-name .selfRef} {#name-making-multiple-requests}

Clients often need to send multiple requests to perform a
task.[¶](#section-4.11-1){.pilcrow}

In HTTP/1 \[[HTTP/1.1](#HTTP11){.xref}\], parallel requests are most
often supported by opening multiple connections. Application performance
can be impacted when too many simultaneous connections are used because
connections\' congestion control will not be coordinated. Furthermore,
it can be difficult for applications to decide when to issue and which
connection to use for a given request, further impacting
performance.[¶](#section-4.11-2){.pilcrow}

HTTP/2 \[[HTTP/2](#HTTP2){.xref}\] and HTTP/3
\[[HTTP/3](#HTTP3){.xref}\] offer multiplexing to applications, removing
the need to use multiple connections. However, application performance
can still be significantly affected by how the server chooses to
prioritize responses. Depending on the application, it might be best for
the server to determine the priority of responses or for the client to
hint its priorities to the server (see, e.g.,
\[[HTTP-PRIORITY](#HTTP-PRIORITY){.xref}\]).[¶](#section-4.11-3){.pilcrow}

In all versions of HTTP, requests are made independently \-- you can\'t
rely on the relative order of two requests to guarantee their processing
order. This is because they might be sent over a multiplexed protocol by
an intermediary or sent to different origin servers, or the server might
even perform processing in a different order. If two requests need
strict ordering, the only reliable way to ensure the outcome is to issue
the second request when the final response to the first has
begun.[¶](#section-4.11-4){.pilcrow}

Applications [MUST NOT]{.bcp14} make assumptions about the relationship
between separate requests on a single transport connection; doing so
breaks many of the assumptions of HTTP as a stateless protocol and will
cause problems in interoperability, security, operability, and
evolution.[¶](#section-4.11-5){.pilcrow}
:::
:::

::: {#client-auth}
::: {#section-4.12 .section}
### [4.12.](#section-4.12){.section-number .selfRef} [Client Authentication](#name-client-authentication){.section-name .selfRef} {#name-client-authentication}

Applications can use HTTP authentication ([Section
11](https://www.rfc-editor.org/rfc/rfc9110#section-11){.relref} of
\[[HTTP](#HTTP){.xref}\]) to identify clients. Per
\[[RFC7617](#RFC7617){.xref}\], the Basic authentication scheme is not
suitable for protecting sensitive or valuable information unless the
channel is secure (e.g., using the \"https\" URI scheme). Likewise,
\[[RFC7616](#RFC7616){.xref}\] requires the Digest authentication scheme
to be used over a secure channel.[¶](#section-4.12-1){.pilcrow}

With HTTPS, clients might also be authenticated using certificates
\[[RFC8446](#RFC8446){.xref}\], but note that such authentication is
intrinsically scoped to the underlying transport connection. As a
result, a client has no way of knowing whether the authenticated status
was used in preparing the response (though Vary: \* and/or the private
cache directive can provide a partial indication), and the only way to
obtain a specifically unauthenticated response is to open a new
connection.[¶](#section-4.12-2){.pilcrow}

When used, it is important to carefully specify the scoping and use of
authentication; if the application exposes sensitive data or
capabilities (e.g., by acting as an ambient authority; see [Section
8.3](https://www.rfc-editor.org/rfc/rfc6454#section-8.3){.relref} of
\[[RFC6454](#RFC6454){.xref}\]), exploits are possible. Mitigations
include using a request-specific token to ensure the intent of the
client.[¶](#section-4.12-3){.pilcrow}
:::
:::

::: {#browser}
::: {#section-4.13 .section}
### [4.13.](#section-4.13){.section-number .selfRef} [Coexisting with Web Browsing](#name-coexisting-with-web-browsin){.section-name .selfRef} {#name-coexisting-with-web-browsin}

Even if there is not an intent for an application to be used with a Web
browser, its resources will remain available to browsers and other HTTP
clients. This means that all such applications that use HTTP need to
consider how browsers will interact with them, particularly regarding
security.[¶](#section-4.13-1){.pilcrow}

For example, if an application\'s state can be changed using a POST
request, a Web browser can easily be coaxed into cross-site request
forgery (CSRF) from arbitrary Web sites.[¶](#section-4.13-2){.pilcrow}

Or, if an attacker gains control of content returned from the
application\'s resources (for example, part of the request is reflected
in the response, or the response contains external information that the
attacker can change), they can inject code into the browser and access
data and capabilities as if they were the origin \-- a technique known
as a cross-site scripting (XSS) attack.[¶](#section-4.13-3){.pilcrow}

This is only a small sample of the kinds of issues that applications
using HTTP must consider. Generally, the best approach is to actually
consider the application as a Web application, and to follow best
practices for their secure development.[¶](#section-4.13-4){.pilcrow}

A complete enumeration of such practices is out of scope for this
document, but some considerations include:[¶](#section-4.13-5){.pilcrow}

-   [Using an application-specific media type in the Content-Type header
    field, and requiring clients to fail if it is not
    used.[¶](#section-4.13-6.1){.pilcrow}]{#section-4.13-6.1}
-   [Using X-Content-Type-Options: nosniff \[[FETCH](#FETCH){.xref}\] to
    ensure that content under attacker control can\'t be coaxed into a
    form that is interpreted as active content by a Web
    browser.[¶](#section-4.13-6.2){.pilcrow}]{#section-4.13-6.2}
-   [Using Content-Security-Policy \[[CSP](#CSP){.xref}\] to constrain
    the capabilities of active content (i.e., that which can execute
    scripts, such as HTML \[[HTML](#HTML){.xref}\] and PDF), thereby
    mitigating XSS
    attacks.[¶](#section-4.13-6.3){.pilcrow}]{#section-4.13-6.3}
-   [Using Referrer-Policy
    \[[REFERRER-POLICY](#REFERRER-POLICY){.xref}\] to prevent sensitive
    data in URLs from being leaked in the Referer request header
    field.[¶](#section-4.13-6.4){.pilcrow}]{#section-4.13-6.4}
-   [Using the \'HttpOnly\' flag on Cookies to ensure that cookies are
    not exposed to browser scripting languages
    \[[COOKIES](#COOKIES){.xref}\].[¶](#section-4.13-6.5){.pilcrow}]{#section-4.13-6.5}
-   [Avoiding use of compression on any sensitive information (e.g.,
    authentication tokens, passwords), as the scripting environment
    offered by Web browsers allows an attacker to repeatedly probe the
    compression space; if the attacker has access to the network path of
    the communication, they can use this capability to recover that
    information.[¶](#section-4.13-6.6){.pilcrow}]{#section-4.13-6.6}

Depending on how they are intended to be deployed, specifications for
applications using HTTP might require the use of these mechanisms in
specific ways or might merely point them out in Security
Considerations.[¶](#section-4.13-7){.pilcrow}

An example of an HTTP response from an application that does not intend
for its content to be treated as active by browsers might look like
this:[¶](#section-4.13-8){.pilcrow}

::: {#section-4.13-9}
``` {.lang-http-message .sourcecode}
HTTP/1.1 200 OK
Content-Type: application/example+json
X-Content-Type-Options: nosniff
Content-Security-Policy: default-src 'none'
Cache-Control: max-age=3600
Referrer-Policy: no-referrer

[content]
```

[¶](#section-4.13-9){.pilcrow}
:::

If an application has browser compatibility as a goal, client
interaction ought to be defined in terms of \[[FETCH](#FETCH){.xref}\]
since that is the abstraction that browsers use for HTTP; it enforces
many of these best practices.[¶](#section-4.13-10){.pilcrow}
:::
:::

::: {#other-apps}
::: {#section-4.14 .section}
### [4.14.](#section-4.14){.section-number .selfRef} [Maintaining Application Boundaries](#name-maintaining-application-bou){.section-name .selfRef} {#name-maintaining-application-bou}

Because many HTTP capabilities are scoped to the origin
\[[RFC6454](#RFC6454){.xref}\], applications also need to consider how
deployments might interact with other applications (including Web
browsing) that use the same origin server.[¶](#section-4.14-1){.pilcrow}

For example, if cookies \[[COOKIES](#COOKIES){.xref}\] are used to carry
application state, they will be sent with all requests to the origin by
default (unless scoped by path), and the application might receive
cookies from other applications on the origin server. This can lead to
security issues as well as collision in cookie
names.[¶](#section-4.14-2){.pilcrow}

One solution to these issues is to require a dedicated hostname for the
application so that it has a unique origin. However, it is often
desirable to allow multiple applications to be deployed on a single
hostname; doing so provides the most deployment flexibility and enables
them to be \"mixed\" together (see \[[BCP190](#BCP190){.xref}\] for
details).[¶](#section-4.14-3){.pilcrow}

Therefore, applications using HTTP should strive to allow multiple
applications on an origin. Specifically, when specifying the use of
cookies, HTTP authentication realms \[[HTTP](#HTTP){.xref}\], or other
origin-wide HTTP mechanisms, applications using HTTP should not mandate
the use of a particular name but instead let deployments configure them.
Consideration should be given to scoping them to part of the origin,
using their specified mechanisms for doing
so.[¶](#section-4.14-4){.pilcrow}

Modern Web browsers constrain the ability of content from one origin to
access resources from another to avoid leaking private information. As a
result, applications that wish to expose cross-origin data to browsers
will need to implement the CORS protocol; see
\[[FETCH](#FETCH){.xref}\].[¶](#section-4.14-5){.pilcrow}
:::
:::

::: {#server-push}
::: {#section-4.15 .section}
### [4.15.](#section-4.15){.section-number .selfRef} [Using Server Push](#name-using-server-push){.section-name .selfRef} {#name-using-server-push}

HTTP/2 added the ability for servers to \"push\" request/response pairs
to clients in \[[HTTP/2](#HTTP2){.xref}\], [Section
8.4](https://www.rfc-editor.org/rfc/rfc9113#section-8.4){.relref}. While
server push seems like a natural fit for many common application
semantics (e.g., \"fanout\" and publish/subscribe), a few caveats should
be noted:[¶](#section-4.15-1){.pilcrow}

-   [Server push is hop by hop; that is, it is not automatically
    forwarded by intermediaries. As a result, it might not work easily
    (or at all) with proxies, reverse proxies, and content delivery
    networks.[¶](#section-4.15-2.1){.pilcrow}]{#section-4.15-2.1}
-   [Server push can have a negative performance impact on HTTP when
    used incorrectly, particularly if there is contention with resources
    that have actually been requested by the
    client.[¶](#section-4.15-2.2){.pilcrow}]{#section-4.15-2.2}
-   [Server push is implemented differently in different clients,
    especially regarding interaction with HTTP caching, and capabilities
    might vary.[¶](#section-4.15-2.3){.pilcrow}]{#section-4.15-2.3}
-   [APIs for server push are currently unavailable in some
    implementations and vary widely in others. In particular, there is
    no current browser API for
    it.[¶](#section-4.15-2.4){.pilcrow}]{#section-4.15-2.4}
-   [Server push is not supported in HTTP/1.1 or
    HTTP/1.0.[¶](#section-4.15-2.5){.pilcrow}]{#section-4.15-2.5}
-   [Server push does not form part of the \"core\" semantics of HTTP
    and therefore might not be supported by future versions of the
    protocol.[¶](#section-4.15-2.6){.pilcrow}]{#section-4.15-2.6}

Applications wishing to optimise cases where the client can perform work
related to requests before the full response is available (e.g.,
fetching links for things likely to be contained within) might benefit
from using the 103 (Early Hints) status code; see
\[[RFC8297](#RFC8297){.xref}\].[¶](#section-4.15-3){.pilcrow}

Applications using server push directly need to enforce the requirements
regarding authority in \[[HTTP/2](#HTTP2){.xref}\], [Section
8.4](https://www.rfc-editor.org/rfc/rfc9113#section-8.4){.relref} to
avoid cross-origin push attacks.[¶](#section-4.15-4){.pilcrow}
:::
:::

::: {#versioning}
::: {#section-4.16 .section}
### [4.16.](#section-4.16){.section-number .selfRef} [Allowing Versioning and Evolution](#name-allowing-versioning-and-evo){.section-name .selfRef} {#name-allowing-versioning-and-evo}

It\'s often necessary to introduce new features into application
protocols and change existing ones.[¶](#section-4.16-1){.pilcrow}

In HTTP, backwards-incompatible changes can be made using mechanisms
such as:[¶](#section-4.16-2){.pilcrow}

-   [Using a distinct link relation type
    \[[WEB-LINKING](#WEB-LINKING){.xref}\] to identify a URL for a
    resource that implements the new
    functionality.[¶](#section-4.16-3.1){.pilcrow}]{#section-4.16-3.1}
-   [Using a distinct media type \[[RFC6838](#RFC6838){.xref}\] to
    identify formats that enable the new
    functionality.[¶](#section-4.16-3.2){.pilcrow}]{#section-4.16-3.2}
-   [Using a distinct HTTP header field to implement new functionality
    outside the message
    content.[¶](#section-4.16-3.3){.pilcrow}]{#section-4.16-3.3}
:::
:::
:::
:::

::: {#iana-considerations}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-5-1){.pilcrow}
:::
:::

::: {#security-considerations}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

Applications using HTTP are subject to the security considerations of
HTTP itself and any extensions used; \[[HTTP](#HTTP){.xref}\],
\[[HTTP-CACHING](#HTTP-CACHING){.xref}\], and
\[[WEB-LINKING](#WEB-LINKING){.xref}\] are often relevant, amongst
others.[¶](#section-6-1){.pilcrow}

[Section 4.4.2](#scheme){.xref} recommends support for \"https\" URLs
and discourages the use of \"http\" URLs to provide authentication,
integrity, and confidentiality, as well as to mitigate pervasive
monitoring attacks. Many applications using HTTP perform authentication
and authorization with bearer tokens (e.g., in session cookies). If the
transport is unencrypted, an attacker that can eavesdrop upon or modify
HTTP communications can often escalate their privilege to perform
operations on resources.[¶](#section-6-2){.pilcrow}

[Section 4.9.3](#caching-app-semantics){.xref} highlights the potential
for mismatch between HTTP caching and application-specific storage of
responses or information therein.[¶](#section-6-3){.pilcrow}

[Section 4.10](#state){.xref} discusses the impact of using stateful
mechanisms in the protocol as ambient authority and suggests a
mitigation.[¶](#section-6-4){.pilcrow}

[Section 4.13](#browser){.xref} highlights the implications of Web
browsers\' capabilities on applications that use
HTTP.[¶](#section-6-5){.pilcrow}

[Section 4.14](#other-apps){.xref} discusses the issues that arise when
applications are deployed on the same origin as websites (and other
applications).[¶](#section-6-6){.pilcrow}

[Section 4.15](#server-push){.xref} highlights risks of using HTTP/2
server push in a manner other than that
specified.[¶](#section-6-7){.pilcrow}

Applications that use HTTP in a manner that involves modification of
implementations \-- for example, requiring support for a new URI scheme
or a non-standard method \-- risk having those implementations \"fork\"
from their parent HTTP implementations, with the possible result that
they do not benefit from patches and other security improvements
incorporated upstream.[¶](#section-6-8){.pilcrow}

::: {#privacy-considerations}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Privacy Considerations](#name-privacy-considerations){.section-name .selfRef} {#name-privacy-considerations}

HTTP clients can expose a variety of information to servers. Besides
information that\'s explicitly sent as part of an application\'s
operation (for example, names and other user-entered data) and \"on the
wire\" (which is one of the reasons \"https\" is recommended in [Section
4.4.2](#scheme){.xref}), other information can be gathered through less
obvious means \-- often by connecting activities of a user over
time.[¶](#section-6.1-1){.pilcrow}

This includes session information, tracking the client through
fingerprinting, and code execution.[¶](#section-6.1-2){.pilcrow}

Session information includes things like the IP address of the client,
TLS session tickets, Cookies, ETags stored in the client\'s cache, and
other stateful mechanisms. Applications are advised to avoid using
session mechanisms unless they are unavoidable or necessary for
operation, in which case these risks need to be documented. When they
are used, implementations should be encouraged to allow clearing such
state.[¶](#section-6.1-3){.pilcrow}

Fingerprinting uses unique aspects of a client\'s messages and
behaviours to connect disparate requests and connections. For example,
the User-Agent request header field conveys specific information about
the implementation; the Accept-Language request header field conveys the
users\' preferred language. In combination, a number of these markers
can be used to uniquely identify a client, impacting its control over
its data. As a result, applications are advised to specify that clients
should only emit the information they need to function in
requests.[¶](#section-6.1-4){.pilcrow}

Finally, if an application exposes the ability to execute code, great
care needs to be taken since any ability to observe its environment can
be used as an opportunity to both fingerprint the client and to obtain
and manipulate private data (including session information). For
example, access to high-resolution timers (even indirectly) can be used
to profile the underlying hardware, creating a unique identifier for the
system. Applications are advised to avoid allowing the use of mobile
code where possible; when it cannot be avoided, the resulting system\'s
security properties need be carefully
scrutinised.[¶](#section-6.1-5){.pilcrow}
:::
:::
:::
:::

::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[BCP190\]
:   [Nottingham, M.]{.refAuthor}, [\"URI Design and
    Ownership\"]{.refTitle}, [BCP 190]{.seriesInfo}, [RFC
    8820]{.seriesInfo}, [DOI 10.17487/RFC8820]{.seriesInfo}, June 2020,
    \<<https://www.rfc-editor.org/rfc/rfc8820>\>.
:   

\[HTTP\]
:   [Fielding, R., Ed.]{.refAuthor}, [Nottingham, M., Ed.]{.refAuthor},
    and [J. Reschke, Ed.]{.refAuthor}, [\"HTTP Semantics\"]{.refTitle},
    [STD 97]{.seriesInfo}, [RFC 9110]{.seriesInfo}, [DOI
    10.17487/RFC9110]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9110>\>.
:   

\[HTTP-CACHING\]
:   [Fielding, R., Ed.]{.refAuthor}, [Nottingham, M., Ed.]{.refAuthor},
    and [J. Reschke, Ed.]{.refAuthor}, [\"HTTP Caching\"]{.refTitle},
    [STD 98]{.seriesInfo}, [RFC 9111]{.seriesInfo}, [DOI
    10.17487/RFC9111]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9111>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC6454\]
:   [Barth, A.]{.refAuthor}, [\"The Web Origin Concept\"]{.refTitle},
    [RFC 6454]{.seriesInfo}, [DOI 10.17487/RFC6454]{.seriesInfo},
    December 2011, \<<https://www.rfc-editor.org/info/rfc6454>\>.
:   

\[RFC6648\]
:   [Saint-Andre, P.]{.refAuthor}, [Crocker, D.]{.refAuthor}, and [M.
    Nottingham]{.refAuthor}, [\"Deprecating the \"X-\" Prefix and
    Similar Constructs in Application Protocols\"]{.refTitle}, [BCP
    178]{.seriesInfo}, [RFC 6648]{.seriesInfo}, [DOI
    10.17487/RFC6648]{.seriesInfo}, June 2012,
    \<<https://www.rfc-editor.org/info/rfc6648>\>.
:   

\[RFC6838\]
:   [Freed, N.]{.refAuthor}, [Klensin, J.]{.refAuthor}, and [T.
    Hansen]{.refAuthor}, [\"Media Type Specifications and Registration
    Procedures\"]{.refTitle}, [BCP 13]{.seriesInfo}, [RFC
    6838]{.seriesInfo}, [DOI 10.17487/RFC6838]{.seriesInfo}, January
    2013, \<<https://www.rfc-editor.org/info/rfc6838>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[STRUCTURED-FIELDS\]
:   [Nottingham, M.]{.refAuthor} and [P-H. Kamp]{.refAuthor},
    [\"Structured Field Values for HTTP\"]{.refTitle}, [RFC
    8941]{.seriesInfo}, [DOI 10.17487/RFC8941]{.seriesInfo}, February
    2021, \<<https://www.rfc-editor.org/info/rfc8941>\>.
:   

\[URL\]
:   [Berners-Lee, T.]{.refAuthor}, [Fielding, R.]{.refAuthor}, and [L.
    Masinter]{.refAuthor}, [\"Uniform Resource Identifier (URI): Generic
    Syntax\"]{.refTitle}, [STD 66]{.seriesInfo}, [RFC
    3986]{.seriesInfo}, [DOI 10.17487/RFC3986]{.seriesInfo}, January
    2005, \<<https://www.rfc-editor.org/info/rfc3986>\>.
:   

\[WEB-LINKING\]
:   [Nottingham, M.]{.refAuthor}, [\"Web Linking\"]{.refTitle}, [RFC
    8288]{.seriesInfo}, [DOI 10.17487/RFC8288]{.seriesInfo}, October
    2017, \<<https://www.rfc-editor.org/info/rfc8288>\>.
:   

\[WELL-KNOWN-URI\]
:   [Nottingham, M.]{.refAuthor}, [\"Well-Known Uniform Resource
    Identifiers (URIs)\"]{.refTitle}, [RFC 8615]{.seriesInfo}, [DOI
    10.17487/RFC8615]{.seriesInfo}, May 2019,
    \<<https://www.rfc-editor.org/info/rfc8615>\>.
:   
:::

::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[COOKIES\]
:   [Barth, A.]{.refAuthor}, [\"HTTP State Management
    Mechanism\"]{.refTitle}, [RFC 6265]{.seriesInfo}, [DOI
    10.17487/RFC6265]{.seriesInfo}, April 2011,
    \<<https://www.rfc-editor.org/info/rfc6265>\>.
:   

\[CSP\]
:   [West, M.]{.refAuthor}, [\"Content Security Policy Level
    3\"]{.refTitle}, [W3C Working Draft]{.refContent}, June 2021,
    \<<https://www.w3.org/TR/2021/WD-CSP3-20210629>\>.
:   

\[FETCH\]
:   [WHATWG]{.refAuthor}, [\"Fetch - Living Standard\"]{.refTitle},
    \<<https://fetch.spec.whatwg.org>\>.
:   

\[HTML\]
:   [WHATWG]{.refAuthor}, [\"HTML - Living Standard\"]{.refTitle},
    \<<https://html.spec.whatwg.org>\>.
:   

\[HTTP-PRIORITY\]
:   [[奥 一穂]{.non-ascii} ([Oku, K.]{.ascii})]{.refAuthor} and [L.
    Pardue]{.refAuthor}, [\"Extensible Prioritization Scheme for
    HTTP\"]{.refTitle}, [RFC 9218]{.seriesInfo}, [DOI
    10.17487/RFC9218]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9218>\>.
:   

\[HTTP/1.1\]
:   [Fielding, R., Ed.]{.refAuthor}, [Nottingham, M., Ed.]{.refAuthor},
    and [J. Reschke, Ed.]{.refAuthor}, [\"HTTP/1.1\"]{.refTitle}, [STD
    99]{.seriesInfo}, [RFC 9112]{.seriesInfo}, [DOI
    10.17487/RFC9112]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9112>\>.
:   

\[HTTP/2\]
:   [Thomson, M., Ed.]{.refAuthor} and [C. Benfield, Ed.]{.refAuthor},
    [\"HTTP/2\"]{.refTitle}, [RFC 9113]{.seriesInfo}, [DOI
    10.17487/RFC9113]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9113>\>.
:   

\[HTTP/3\]
:   [Bishop, M., Ed.]{.refAuthor}, [\"HTTP/3\"]{.refTitle}, [RFC
    9114]{.seriesInfo}, [DOI 10.17487/RFC9114]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9114>\>.
:   

\[JSON\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The JavaScript Object Notation
    (JSON) Data Interchange Format\"]{.refTitle}, [STD 90]{.seriesInfo},
    [RFC 8259]{.seriesInfo}, [DOI 10.17487/RFC8259]{.seriesInfo},
    December 2017, \<<https://www.rfc-editor.org/info/rfc8259>\>.
:   

\[PROBLEM-DETAILS\]
:   [Nottingham, M.]{.refAuthor} and [E. Wilde]{.refAuthor}, [\"Problem
    Details for HTTP APIs\"]{.refTitle}, [RFC 7807]{.seriesInfo}, [DOI
    10.17487/RFC7807]{.seriesInfo}, March 2016,
    \<<https://www.rfc-editor.org/info/rfc7807>\>.
:   

\[REFERRER-POLICY\]
:   [Eisinger, J.]{.refAuthor} and [E. Stark]{.refAuthor}, [\"Referrer
    Policy\"]{.refTitle}, [W3C Candidate Recommendation
    CR-referrer-policy-20170126]{.refContent}, January 2017,
    \<<https://www.w3.org/TR/2017/CR-referrer-policy-20170126>\>.
:   

\[RFC3205\]
:   [Moore, K.]{.refAuthor}, [\"On the use of HTTP as a
    Substrate\"]{.refTitle}, [BCP 56]{.seriesInfo}, [RFC
    3205]{.seriesInfo}, [DOI 10.17487/RFC3205]{.seriesInfo}, February
    2002, \<<https://www.rfc-editor.org/info/rfc3205>\>.
:   

\[RFC4791\]
:   [Daboo, C.]{.refAuthor}, [Desruisseaux, B.]{.refAuthor}, and [L.
    Dusseault]{.refAuthor}, [\"Calendaring Extensions to WebDAV
    (CalDAV)\"]{.refTitle}, [RFC 4791]{.seriesInfo}, [DOI
    10.17487/RFC4791]{.seriesInfo}, March 2007,
    \<<https://www.rfc-editor.org/info/rfc4791>\>.
:   

\[RFC4918\]
:   [Dusseault, L., Ed.]{.refAuthor}, [\"HTTP Extensions for Web
    Distributed Authoring and Versioning (WebDAV)\"]{.refTitle}, [RFC
    4918]{.seriesInfo}, [DOI 10.17487/RFC4918]{.seriesInfo}, June 2007,
    \<<https://www.rfc-editor.org/info/rfc4918>\>.
:   

\[RFC5861\]
:   [Nottingham, M.]{.refAuthor}, [\"HTTP Cache-Control Extensions for
    Stale Content\"]{.refTitle}, [RFC 5861]{.seriesInfo}, [DOI
    10.17487/RFC5861]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5861>\>.
:   

\[RFC6415\]
:   [Hammer-Lahav, E., Ed.]{.refAuthor} and [B. Cook]{.refAuthor},
    [\"Web Host Metadata\"]{.refTitle}, [RFC 6415]{.seriesInfo}, [DOI
    10.17487/RFC6415]{.seriesInfo}, October 2011,
    \<<https://www.rfc-editor.org/info/rfc6415>\>.
:   

\[RFC6797\]
:   [Hodges, J.]{.refAuthor}, [Jackson, C.]{.refAuthor}, and [A.
    Barth]{.refAuthor}, [\"HTTP Strict Transport Security
    (HSTS)\"]{.refTitle}, [RFC 6797]{.seriesInfo}, [DOI
    10.17487/RFC6797]{.seriesInfo}, November 2012,
    \<<https://www.rfc-editor.org/info/rfc6797>\>.
:   

\[RFC7258\]
:   [Farrell, S.]{.refAuthor} and [H. Tschofenig]{.refAuthor},
    [\"Pervasive Monitoring Is an Attack\"]{.refTitle}, [BCP
    188]{.seriesInfo}, [RFC 7258]{.seriesInfo}, [DOI
    10.17487/RFC7258]{.seriesInfo}, May 2014,
    \<<https://www.rfc-editor.org/info/rfc7258>\>.
:   

\[RFC7301\]
:   [Friedl, S.]{.refAuthor}, [Popov, A.]{.refAuthor},
    [Langley, A.]{.refAuthor}, and [E. Stephan]{.refAuthor},
    [\"Transport Layer Security (TLS) Application-Layer Protocol
    Negotiation Extension\"]{.refTitle}, [RFC 7301]{.seriesInfo}, [DOI
    10.17487/RFC7301]{.seriesInfo}, July 2014,
    \<<https://www.rfc-editor.org/info/rfc7301>\>.
:   

\[RFC7595\]
:   [Thaler, D., Ed.]{.refAuthor}, [Hansen, T.]{.refAuthor}, and [T.
    Hardie]{.refAuthor}, [\"Guidelines and Registration Procedures for
    URI Schemes\"]{.refTitle}, [BCP 35]{.seriesInfo}, [RFC
    7595]{.seriesInfo}, [DOI 10.17487/RFC7595]{.seriesInfo}, June 2015,
    \<<https://www.rfc-editor.org/info/rfc7595>\>.
:   

\[RFC7605\]
:   [Touch, J.]{.refAuthor}, [\"Recommendations on Using Assigned
    Transport Port Numbers\"]{.refTitle}, [BCP 165]{.seriesInfo}, [RFC
    7605]{.seriesInfo}, [DOI 10.17487/RFC7605]{.seriesInfo}, August
    2015, \<<https://www.rfc-editor.org/info/rfc7605>\>.
:   

\[RFC7616\]
:   [Shekh-Yusef, R., Ed.]{.refAuthor}, [Ahrens, D.]{.refAuthor}, and
    [S. Bremer]{.refAuthor}, [\"HTTP Digest Access
    Authentication\"]{.refTitle}, [RFC 7616]{.seriesInfo}, [DOI
    10.17487/RFC7616]{.seriesInfo}, September 2015,
    \<<https://www.rfc-editor.org/info/rfc7616>\>.
:   

\[RFC7617\]
:   [Reschke, J.]{.refAuthor}, [\"The \'Basic\' HTTP Authentication
    Scheme\"]{.refTitle}, [RFC 7617]{.seriesInfo}, [DOI
    10.17487/RFC7617]{.seriesInfo}, September 2015,
    \<<https://www.rfc-editor.org/info/rfc7617>\>.
:   

\[RFC8297\]
:   [Oku, K.]{.refAuthor}, [\"An HTTP Status Code for Indicating
    Hints\"]{.refTitle}, [RFC 8297]{.seriesInfo}, [DOI
    10.17487/RFC8297]{.seriesInfo}, December 2017,
    \<<https://www.rfc-editor.org/info/rfc8297>\>.
:   

\[RFC8446\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   

\[RFC8470\]
:   [Thomson, M.]{.refAuthor}, [Nottingham, M.]{.refAuthor}, and [W.
    Tarreau]{.refAuthor}, [\"Using Early Data in HTTP\"]{.refTitle},
    [RFC 8470]{.seriesInfo}, [DOI 10.17487/RFC8470]{.seriesInfo},
    September 2018, \<<https://www.rfc-editor.org/info/rfc8470>\>.
:   

\[RFC8949\]
:   [Bormann, C.]{.refAuthor} and [P. Hoffman]{.refAuthor}, [\"Concise
    Binary Object Representation (CBOR)\"]{.refTitle}, [STD
    94]{.seriesInfo}, [RFC 8949]{.seriesInfo}, [DOI
    10.17487/RFC8949]{.seriesInfo}, December 2020,
    \<<https://www.rfc-editor.org/info/rfc8949>\>.
:   

\[SECCTXT\]
:   [West, M.]{.refAuthor}, [\"Secure Contexts\"]{.refTitle}, [W3C
    Candidate Recommendation]{.refContent}, September 2021,
    \<<https://www.w3.org/TR/2021/CRD-secure-contexts-20210918>\>.
:   

\[URI-TEMPLATE\]
:   [Gregorio, J.]{.refAuthor}, [Fielding, R.]{.refAuthor},
    [Hadley, M.]{.refAuthor}, [Nottingham, M.]{.refAuthor}, and [D.
    Orchard]{.refAuthor}, [\"URI Template\"]{.refTitle}, [RFC
    6570]{.seriesInfo}, [DOI 10.17487/RFC6570]{.seriesInfo}, March 2012,
    \<<https://www.rfc-editor.org/info/rfc6570>\>.
:   

\[XML\]
:   [Bray, T.]{.refAuthor}, [Paoli, J.]{.refAuthor},
    [Sperberg-McQueen, M.]{.refAuthor}, [Maler, E.]{.refAuthor}, and [F.
    Yergeau]{.refAuthor}, [\"Extensible Markup Language (XML) 1.0 (Fifth
    Edition)\"]{.refTitle}, [W3C Recommendation
    REC-xml-20081126]{.seriesInfo}, November 2008,
    \<<https://www.w3.org/TR/2008/REC-xml-20081126>\>.
:   
:::
:::

::: {#changes-from-rfc-3205}
::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [Changes from RFC 3205](#name-changes-from-rfc-3205){.section-name .selfRef} {#name-changes-from-rfc-3205}

\[[RFC3205](#RFC3205){.xref}\] captured the Best Current Practice in the
early 2000s based on the concerns facing protocol designers at the time.
Use of HTTP has changed considerably since then; as a result, this
document is substantially different. Consequently, the changes are too
numerous to list individually.[¶](#appendix-A-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-B .section}
## [Author\'s Address](#name-authors-address){.section-name .selfRef} {#name-authors-address}

::: {.left dir="auto"}
[Mark Nottingham]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Prahran]{.street-address}
:::

::: {.left dir="auto"}
[Australia]{.country-name}
:::

::: email
Email: <mnot@mnot.net>
:::

::: url
URI: <https://www.mnot.net/>
:::
:::
:::
