  RFC 8831        WebRTC Data Channels   January 2021
  --------------- ---------------------- --------------
  Jesup, et al.   Standards Track        \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8831](https://www.rfc-editor.org/rfc/rfc8831){.eref}

Category:
:   Standards Track

Published:
:   January 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    R. Jesup
    :::

    ::: org
    Mozilla
    :::
    :::

    ::: author
    ::: author-name
    S. Loreto
    :::

    ::: org
    Ericsson
    :::
    :::

    ::: author
    ::: author-name
    M. Tüxen
    :::

    ::: org
    Münster Univ. of Appl. Sciences
    :::
    :::
:::

# RFC 8831 {#rfcnum}

# WebRTC Data Channels {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

The WebRTC framework specifies protocol support for direct, interactive,
rich communication using audio, video, and data between two peers\' web
browsers. This document specifies the non-media data transport aspects
of the WebRTC framework. It provides an architectural overview of how
the Stream Control Transmission Protocol (SCTP) is used in the WebRTC
context as a generic transport service that allows web browsers to
exchange generic data from peer to
peer.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8831>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Conventions](#name-conventions){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Use
    Cases](#name-use-cases){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Use Cases for Unreliable Data
        Channels](#name-use-cases-for-unreliable-da){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Use Cases for Reliable Data
        Channels](#name-use-cases-for-reliable-data){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Requirements](#name-requirements){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [SCTP over DTLS over UDP
    Considerations](#name-sctp-over-dtls-over-udp-con){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [The Usage of SCTP for Data
    Channels](#name-the-usage-of-sctp-for-data-){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [SCTP Protocol
        Considerations](#name-sctp-protocol-consideration){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [SCTP Association
        Management](#name-sctp-association-management){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [SCTP
        Streams](#name-sctp-streams){.xref}[¶](#section-toc.1-1.6.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [Data Channel
        Definition](#name-data-channel-definition){.xref}[¶](#section-toc.1-1.6.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.5}
        [6.5](#section-6.5){.xref}.  [Opening a Data
        Channel](#name-opening-a-data-channel){.xref}[¶](#section-toc.1-1.6.2.5.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.6}
        [6.6](#section-6.6){.xref}.  [Transferring User Data on a Data
        Channel](#name-transferring-user-data-on-a){.xref}[¶](#section-toc.1-1.6.2.6.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.7}
        [6.7](#section-6.7){.xref}.  [Closing a Data
        Channel](#name-closing-a-data-channel){.xref}[¶](#section-toc.1-1.6.2.7.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [References](#name-references){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.9.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.9.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [](#section-appendix.a){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [](#section-appendix.b){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::
:::
:::

::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

In the WebRTC framework, communication between the parties consists of
media (for example, audio and video) and non-media data. Media is sent
using the Secure Real-time Transport Protocol (SRTP) and is not
specified further here. Non-media data is handled by using the Stream
Control Transmission Protocol (SCTP) \[[RFC4960](#RFC4960){.xref}\]
encapsulated in DTLS. DTLS 1.0 is defined in
\[[RFC4347](#RFC4347){.xref}\]; the present latest version, DTLS 1.2, is
defined in \[[RFC6347](#RFC6347){.xref}\]; and an upcoming version, DTLS
1.3, is defined in
\[[TLS-DTLS13](#I-D.ietf-tls-dtls13){.xref}\].[¶](#section-1-1){.pilcrow}

[]{#name-basic-stack-diagram}

::: {#fig-stack}
::: {#section-1-2.1 .artwork .art-text .alignCenter}
    +----------+
    |   SCTP   |
    +----------+
    |   DTLS   |
    +----------+
    | ICE/UDP  |
    +----------+
:::

[Figure 1](#figure-1){.selfRef}: [Basic Stack
Diagram](#name-basic-stack-diagram){.selfRef}
:::

The encapsulation of SCTP over DTLS (see \[[RFC8261](#RFC8261){.xref}\])
over ICE/UDP (see \[[RFC8445](#RFC8445){.xref}\]) provides a NAT
traversal solution together with confidentiality, source authentication,
and integrity-protected transfers. This data transport service operates
in parallel to the SRTP media transports, and all of them can eventually
share a single UDP port number.[¶](#section-1-3){.pilcrow}

SCTP, as specified in \[[RFC4960](#RFC4960){.xref}\] with the partial
reliability extension (PR-SCTP) defined in
\[[RFC3758](#RFC3758){.xref}\] and the additional policies defined in
\[[RFC7496](#RFC7496){.xref}\], provides multiple streams natively with
reliable, and the relevant partially reliable, delivery modes for user
messages. Using the reconfiguration extension defined in
\[[RFC6525](#RFC6525){.xref}\] allows an increase in the number of
streams during the lifetime of an SCTP association and allows individual
SCTP streams to be reset. Using \[[RFC8260](#RFC8260){.xref}\] allows
the interleave of large messages to avoid monopolization and adds
support for prioritizing SCTP streams.[¶](#section-1-4){.pilcrow}

The remainder of this document is organized as follows: Sections
[3](#sec-use-cases){.xref} and [4](#sec-req){.xref} provide use cases
and requirements for both unreliable and reliable peer-to-peer data
channels; [Section 5](#sec-p-a-2){.xref} discusses SCTP over DTLS over
UDP; and [Section 6](#sec-sctp-usage){.xref} specifies how SCTP should
be used by the WebRTC protocol framework for transporting non-media data
between web browsers.[¶](#section-1-5){.pilcrow}
:::

::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Conventions](#name-conventions){.section-name .selfRef} {#name-conventions}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}
:::

::: {#sec-use-cases}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Use Cases](#name-use-cases){.section-name .selfRef} {#name-use-cases}

This section defines use cases specific to data channels. Please note
that this section is informational only.[¶](#section-3-1){.pilcrow}

::: {#sec-use-cases-unreliable}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Use Cases for Unreliable Data Channels](#name-use-cases-for-unreliable-da){.section-name .selfRef} {#name-use-cases-for-unreliable-da}

[]{.break}

U-C 1:
:   A real-time game where position and object state information are
    sent via one or more unreliable data channels. Note that at any
    time, there may not be any SRTP media channels or all SRTP media
    channels may be inactive, and there may also be reliable data
    channels in use.[¶](#section-3.1-1.1){.pilcrow}
:   

U-C 2:
:   Providing non-critical information to a user about the reason for a
    state update in a video chat or conference, such as mute
    state.[¶](#section-3.1-1.2){.pilcrow}
:   
:::
:::

::: {#sec-use-cases-reliable}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Use Cases for Reliable Data Channels](#name-use-cases-for-reliable-data){.section-name .selfRef} {#name-use-cases-for-reliable-data}

[]{.break}

U-C 3:
:   A real-time game where critical state information needs to be
    transferred, such as control information. Such a game may have no
    SRTP media channels, or they may be inactive at any given time or
    may only be added due to in-game
    actions.[¶](#section-3.2-1.1){.pilcrow}
:   

U-C 4:
:   Non-real-time file transfers between people chatting. Note that this
    may involve a large number of files to transfer sequentially or in
    parallel, such as when sharing a folder of images or a directory of
    files.[¶](#section-3.2-1.2){.pilcrow}
:   

U-C 5:
:   Real-time text chat during an audio and/or video call with an
    individual or with multiple people in a
    conference.[¶](#section-3.2-1.3){.pilcrow}
:   

U-C 6:
:   Renegotiation of the configuration of the
    PeerConnection.[¶](#section-3.2-1.4){.pilcrow}
:   

U-C 7:
:   Proxy browsing, where a browser uses data channels of a
    PeerConnection to send and receive HTTP/HTTPS requests and data, for
    example, to avoid local Internet filtering or
    monitoring.[¶](#section-3.2-1.5){.pilcrow}
:   
:::
:::
:::
:::

::: {#sec-req}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Requirements](#name-requirements){.section-name .selfRef} {#name-requirements}

This section lists the requirements for Peer-to-Peer (P2P) data channels
between two browsers. Please note that this section is informational
only.[¶](#section-4-1){.pilcrow}

[]{.break}

Req. 1:
:   Multiple simultaneous data channels must be supported. Note that
    there may be zero or more SRTP media streams in parallel with the
    data channels in the same PeerConnection, and the number and state
    (active/inactive) of these SRTP media streams may change at any
    time.[¶](#section-4-2.1){.pilcrow}
:   

Req. 2:
:   Both reliable and unreliable data channels must be
    supported.[¶](#section-4-2.2){.pilcrow}
:   

Req. 3:
:   Data channels of a PeerConnection must be congestion controlled
    either individually, as a class, or in conjunction with the SRTP
    media streams of the PeerConnection. This ensures that data channels
    don\'t cause congestion problems for these SRTP media streams, and
    that the WebRTC PeerConnection does not cause excessive problems
    when run in parallel with TCP
    connections.[¶](#section-4-2.3){.pilcrow}
:   

Req. 4:
:   The application should be able to provide guidance as to the
    relative priority of each data channel relative to each other and
    relative to the SRTP media streams. This will interact with the
    congestion control algorithms.[¶](#section-4-2.4){.pilcrow}
:   

Req. 5:
:   Data channels must be secured, which allows for confidentiality,
    integrity, and source authentication. See
    \[[RFC8826](#RFC8826){.xref}\] and \[[RFC8827](#RFC8827){.xref}\]
    for detailed information.[¶](#section-4-2.5){.pilcrow}
:   

Req. 6:
:   Data channels must provide message fragmentation support such that
    IP-layer fragmentation can be avoided no matter how large a message
    the JavaScript application passes to be sent. It also must ensure
    that large data channel transfers don\'t unduly delay traffic on
    other data channels.[¶](#section-4-2.6){.pilcrow}
:   

Req. 7:
:   The data channel transport protocol must not encode local IP
    addresses inside its protocol fields; doing so reveals potentially
    private information and leads to failure if the address is depended
    upon.[¶](#section-4-2.7){.pilcrow}
:   

Req. 8:
:   The data channel transport protocol should support unbounded-length
    \"messages\" (i.e., a virtual socket stream) at the application
    layer for such things as image-file-transfer; implementations might
    enforce a reasonable message size
    limit.[¶](#section-4-2.8){.pilcrow}
:   

Req. 9:
:   The data channel transport protocol should avoid IP fragmentation.
    It must support Path MTU (PMTU) discovery and must not rely on ICMP
    or ICMPv6 being generated or being passed back, especially for PMTU
    discovery.[¶](#section-4-2.9){.pilcrow}
:   

Req. 10:
:   It must be possible to implement the protocol stack in the user
    application space.[¶](#section-4-2.10){.pilcrow}
:   
:::
:::

::: {#sec-p-a-2}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [SCTP over DTLS over UDP Considerations](#name-sctp-over-dtls-over-udp-con){.section-name .selfRef} {#name-sctp-over-dtls-over-udp-con}

The important features of SCTP in the WebRTC context are the
following:[¶](#section-5-1){.pilcrow}

-   [Usage of TCP-friendly congestion
    control.[¶](#section-5-2.1){.pilcrow}]{#section-5-2.1}
-   [modifiable congestion control for integration with the SRTP media
    stream congestion
    control.[¶](#section-5-2.2){.pilcrow}]{#section-5-2.2}
-   [Support of multiple unidirectional streams, each providing its own
    notion of ordered message
    delivery.[¶](#section-5-2.3){.pilcrow}]{#section-5-2.3}
-   [Support of ordered and out-of-order message
    delivery.[¶](#section-5-2.4){.pilcrow}]{#section-5-2.4}
-   [Support of arbitrarily large user messages by providing
    fragmentation and
    reassembly.[¶](#section-5-2.5){.pilcrow}]{#section-5-2.5}
-   [Support of PMTU
    discovery.[¶](#section-5-2.6){.pilcrow}]{#section-5-2.6}
-   [Support of reliable or partially reliable message
    transport.[¶](#section-5-2.7){.pilcrow}]{#section-5-2.7}

The WebRTC data channel mechanism does not support SCTP multihoming. The
SCTP layer will simply act as if it were running on a single-homed host,
since that is the abstraction that the DTLS layer (a
connection-oriented, unreliable datagram service)
exposes.[¶](#section-5-3){.pilcrow}

The encapsulation of SCTP over DTLS defined in
\[[RFC8261](#RFC8261){.xref}\] provides confidentiality, source
authentication, and integrity-protected transfers. Using DTLS over UDP
in combination with Interactive Connectivity Establishment (ICE)
\[[RFC8445](#RFC8445){.xref}\] enables middlebox traversal in IPv4- and
IPv6-based networks. SCTP as specified in \[[RFC4960](#RFC4960){.xref}\]
[MUST]{.bcp14} be used in combination with the extension defined in
\[[RFC3758](#RFC3758){.xref}\] and provides the following features for
transporting non-media data between browsers:[¶](#section-5-4){.pilcrow}

-   [Support of multiple unidirectional
    streams.[¶](#section-5-5.1){.pilcrow}]{#section-5-5.1}
-   [Ordered and unordered delivery of user
    messages.[¶](#section-5-5.2){.pilcrow}]{#section-5-5.2}
-   [Reliable and partially reliable transport of user
    messages.[¶](#section-5-5.3){.pilcrow}]{#section-5-5.3}

Each SCTP user message contains a Payload Protocol Identifier (PPID)
that is passed to SCTP by its upper layer on the sending side and
provided to its upper layer on the receiving side. The PPID can be used
to multiplex/demultiplex multiple upper layers over a single SCTP
association. In the WebRTC context, the PPID is used to distinguish
between UTF-8 encoded user data, binary-encoded user data, and the Data
Channel Establishment Protocol (DCEP) defined in
\[[RFC8832](#RFC8832){.xref}\]. Please note that the PPID is not
accessible via the JavaScript API.[¶](#section-5-6){.pilcrow}

The encapsulation of SCTP over DTLS, together with the SCTP features
listed above, satisfies all the requirements listed in [Section
4](#sec-req){.xref}.[¶](#section-5-7){.pilcrow}

The layering of protocols for WebRTC is shown in [Figure
2](#fig-sctp-layering){.xref}.[¶](#section-5-8){.pilcrow}

[]{#name-webrtc-protocol-layers}

::: {#fig-sctp-layering}
::: {#section-5-9.1 .artwork .art-text .alignCenter}
                  +------+------+------+
                  | DCEP | UTF-8|Binary|
                  |      | Data | Data |
                  +------+------+------+
                  |        SCTP        |
    +----------------------------------+
    | STUN | SRTP |        DTLS        |
    +----------------------------------+
    |                ICE               |
    +----------------------------------+
    | UDP1 | UDP2 | UDP3 | ...         |
    +----------------------------------+
:::

[Figure 2](#figure-2){.selfRef}: [WebRTC Protocol
Layers](#name-webrtc-protocol-layers){.selfRef}
:::

This stack (especially in contrast to DTLS over SCTP
\[[RFC6083](#RFC6083){.xref}\] and in combination with SCTP over UDP
\[[RFC6951](#RFC6951){.xref}\]) has been chosen for the following
reasons:[¶](#section-5-10){.pilcrow}

-   [supports the transmission of arbitrarily large user
    messages;[¶](#section-5-11.1){.pilcrow}]{#section-5-11.1}
-   [shares the DTLS connection with the SRTP media channels of the
    PeerConnection; and[¶](#section-5-11.2){.pilcrow}]{#section-5-11.2}
-   [provides privacy for the SCTP control
    information.[¶](#section-5-11.3){.pilcrow}]{#section-5-11.3}

Referring to the protocol stack shown in [Figure
2](#fig-sctp-layering){.xref}:[¶](#section-5-12){.pilcrow}

-   [the usage of DTLS 1.0 over UDP is specified in
    \[[RFC4347](#RFC4347){.xref}\];[¶](#section-5-13.1){.pilcrow}]{#section-5-13.1}
-   [the usage of DTLS 1.2 over UDP in specified in
    \[[RFC6347](#RFC6347){.xref}\];[¶](#section-5-13.2){.pilcrow}]{#section-5-13.2}
-   [the usage of DTLS 1.3 over UDP is specified in an upcoming document
    \[[TLS-DTLS13](#I-D.ietf-tls-dtls13){.xref}\];
    and[¶](#section-5-13.3){.pilcrow}]{#section-5-13.3}
-   [the usage of SCTP on top of DTLS is specified in
    \[[RFC8261](#RFC8261){.xref}\].[¶](#section-5-13.4){.pilcrow}]{#section-5-13.4}

Please note that the demultiplexing Session Traversal Utilities for NAT
(STUN) \[[RFC5389](#RFC5389){.xref}\] vs. SRTP vs. DTLS is done as
described in [Section
5.1.2](https://www.rfc-editor.org/rfc/rfc5764#section-5.1.2){.relref} of
\[[RFC5764](#RFC5764){.xref}\], and SCTP is the only payload of
DTLS.[¶](#section-5-14){.pilcrow}

Since DTLS is typically implemented in user application space, the SCTP
stack also needs to be a user application space
stack.[¶](#section-5-15){.pilcrow}

The ICE/UDP layer can handle IP address changes during a session without
needing interaction with the DTLS and SCTP layers. However, SCTP
[SHOULD]{.bcp14} be notified when an address change has happened. In
this case, SCTP [SHOULD]{.bcp14} retest the Path MTU and reset the
congestion state to the initial state. In the case of window-based
congestion control like the one specified in
\[[RFC4960](#RFC4960){.xref}\], this means setting the congestion window
and slow-start threshold to its initial
values.[¶](#section-5-16){.pilcrow}

Incoming ICMP or ICMPv6 messages can\'t be processed by the SCTP layer,
since there is no way to identify the corresponding association.
Therefore, SCTP [MUST]{.bcp14} support performing Path MTU discovery
without relying on ICMP or ICMPv6 as specified in
\[[RFC4821](#RFC4821){.xref}\] by using probing messages specified in
\[[RFC4820](#RFC4820){.xref}\]. The initial Path MTU at the IP layer
[SHOULD NOT]{.bcp14} exceed 1200 bytes for IPv4 and 1280 bytes for
IPv6.[¶](#section-5-17){.pilcrow}

In general, the lower-layer interface of an SCTP implementation should
be adapted to address the differences between IPv4 and IPv6 (being
connectionless) or DTLS (being connection
oriented).[¶](#section-5-18){.pilcrow}

When the protocol stack shown in [Figure 2](#fig-sctp-layering){.xref}
is used, DTLS protects the complete SCTP packet, so it provides
confidentiality, integrity, and source authentication of the complete
SCTP packet.[¶](#section-5-19){.pilcrow}

SCTP provides congestion control on a per-association basis. This means
that all SCTP streams within a single SCTP association share the same
congestion window. Traffic not being sent over SCTP is not covered by
SCTP congestion control. Using a congestion control different from the
standard one might improve the impact on the parallel SRTP media
streams.[¶](#section-5-20){.pilcrow}

SCTP uses the same port number concept as TCP and UDP. Therefore, an
SCTP association uses two port numbers, one at each SCTP
endpoint.[¶](#section-5-21){.pilcrow}
:::
:::

::: {#sec-sctp-usage}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [The Usage of SCTP for Data Channels](#name-the-usage-of-sctp-for-data-){.section-name .selfRef} {#name-the-usage-of-sctp-for-data-}

::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [SCTP Protocol Considerations](#name-sctp-protocol-consideration){.section-name .selfRef} {#name-sctp-protocol-consideration}

The DTLS encapsulation of SCTP packets as described in
\[[RFC8261](#RFC8261){.xref}\] [MUST]{.bcp14} be
used.[¶](#section-6.1-1){.pilcrow}

This SCTP stack and its upper layer [MUST]{.bcp14} support the usage of
multiple SCTP streams. A user message can be sent ordered or unordered
and with partial or full reliability.[¶](#section-6.1-2){.pilcrow}

The following SCTP protocol extensions are
required:[¶](#section-6.1-3){.pilcrow}

-   [The stream reconfiguration extension defined in
    \[[RFC6525](#RFC6525){.xref}\] [MUST]{.bcp14} be supported. It is
    used for closing
    channels.[¶](#section-6.1-4.1){.pilcrow}]{#section-6.1-4.1}
-   [The dynamic address reconfiguration extension defined in
    \[[RFC5061](#RFC5061){.xref}\] [MUST]{.bcp14} be used to signal the
    support of the stream reset extension defined in
    \[[RFC6525](#RFC6525){.xref}\]. Other features of
    \[[RFC5061](#RFC5061){.xref}\] are
    [OPTIONAL]{.bcp14}.[¶](#section-6.1-4.2){.pilcrow}]{#section-6.1-4.2}
-   [The partial reliability extension defined in
    \[[RFC3758](#RFC3758){.xref}\] [MUST]{.bcp14} be supported. In
    addition to the timed reliability PR-SCTP policy defined in
    \[[RFC3758](#RFC3758){.xref}\], the limited retransmission policy
    defined in \[[RFC7496](#RFC7496){.xref}\] [MUST]{.bcp14} be
    supported. Limiting the number of retransmissions to zero, combined
    with unordered delivery, provides a UDP-like service where each user
    message is sent exactly once and delivered in the order
    received.[¶](#section-6.1-4.3){.pilcrow}]{#section-6.1-4.3}

The support for message interleaving as defined in
\[[RFC8260](#RFC8260){.xref}\] [SHOULD]{.bcp14} be
used.[¶](#section-6.1-5){.pilcrow}
:::

::: {#sec-sctp-management}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [SCTP Association Management](#name-sctp-association-management){.section-name .selfRef} {#name-sctp-association-management}

In the WebRTC context, the SCTP association will be set up when the two
endpoints of the WebRTC PeerConnection agree on opening it, as
negotiated by the JavaScript Session Establishment Protocol (JSEP),
which is typically an exchange of the Session Description Protocol (SDP)
\[[RFC8829](#RFC8829){.xref}\]. It will use the DTLS connection selected
via ICE, and typically this will be shared via BUNDLE or equivalent with
DTLS connections used to key the SRTP media
streams.[¶](#section-6.2-1){.pilcrow}

The number of streams negotiated during SCTP association setup
[SHOULD]{.bcp14} be 65535, which is the maximum number of streams that
can be negotiated during the association
setup.[¶](#section-6.2-2){.pilcrow}

SCTP supports two ways of terminating an SCTP association. The first
method is a graceful one, where a procedure that ensures no messages are
lost during the shutdown of the association is used. The second method
is a non-graceful one, where one side can just abort the
association.[¶](#section-6.2-3){.pilcrow}

Each SCTP endpoint continuously supervises the reachability of its peer
by monitoring the number of retransmissions of user messages and test
messages. In case of excessive retransmissions, the association is
terminated in a non-graceful way.[¶](#section-6.2-4){.pilcrow}

If an SCTP association is closed in a graceful way, all of its data
channels are closed. In case of a non-graceful teardown, all data
channels are also closed, but an error indication [SHOULD]{.bcp14} be
provided if possible.[¶](#section-6.2-5){.pilcrow}
:::
:::

::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [SCTP Streams](#name-sctp-streams){.section-name .selfRef} {#name-sctp-streams}

SCTP defines a stream as a unidirectional logical channel existing
within an SCTP association to another SCTP endpoint. The streams are
used to provide the notion of in-sequence delivery and for multiplexing.
Each user message is sent on a particular stream, either ordered or
unordered. Ordering is preserved only for ordered messages sent on the
same stream.[¶](#section-6.3-1){.pilcrow}
:::

::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [Data Channel Definition](#name-data-channel-definition){.section-name .selfRef} {#name-data-channel-definition}

Data channels are defined such that their accompanying application-level
API can closely mirror the API for WebSockets, which implies
bidirectional streams of data and a textual field called \'label\' used
to identify the meaning of the data
channel.[¶](#section-6.4-1){.pilcrow}

The realization of a data channel is a pair of one incoming stream and
one outgoing SCTP stream having the same SCTP stream identifier. How
these SCTP stream identifiers are selected is protocol and
implementation dependent. This allows a bidirectional
communication.[¶](#section-6.4-2){.pilcrow}

Additionally, each data channel has the following properties in each
direction:[¶](#section-6.4-3){.pilcrow}

-   [reliable or unreliable message transmission: In case of unreliable
    transmissions, the same level of unreliability is used. Note that,
    in SCTP, this is a property of an SCTP user message and not of an
    SCTP stream.[¶](#section-6.4-4.1){.pilcrow}]{#section-6.4-4.1}
-   [in-order or out-of-order message delivery for message sent: Note
    that, in SCTP, this is a property of an SCTP user message and not of
    an SCTP stream.[¶](#section-6.4-4.2){.pilcrow}]{#section-6.4-4.2}
-   [a priority, which is a 2-byte unsigned integer: These priorities
    [MUST]{.bcp14} be interpreted as weighted-fair-queuing scheduling
    priorities per the definition of the corresponding stream scheduler
    supporting interleaving in \[[RFC8260](#RFC8260){.xref}\]. For use
    in WebRTC, the values used [SHOULD]{.bcp14} be one of 128 (\"below
    normal\"), 256 (\"normal\"), 512 (\"high\"), or 1024 (\"extra
    high\").[¶](#section-6.4-4.3){.pilcrow}]{#section-6.4-4.3}
-   [an optional
    label.[¶](#section-6.4-4.4){.pilcrow}]{#section-6.4-4.4}
-   [an optional
    protocol.[¶](#section-6.4-4.5){.pilcrow}]{#section-6.4-4.5}

Note that for a data channel being negotiated with the protocol
specified in \[[RFC8832](#RFC8832){.xref}\], all of the above properties
are the same in both directions.[¶](#section-6.4-5){.pilcrow}
:::

::: {#section-6.5 .section}
### [6.5.](#section-6.5){.section-number .selfRef} [Opening a Data Channel](#name-opening-a-data-channel){.section-name .selfRef} {#name-opening-a-data-channel}

Data channels can be opened by using negotiation within the SCTP
association (called in-band negotiation) or out-of-band negotiation.
Out-of-band negotiation is defined as any method that results in an
agreement as to the parameters of a channel and the creation thereof.
The details are out of scope of this document. Applications using data
channels need to use the negotiation methods consistently on both
endpoints.[¶](#section-6.5-1){.pilcrow}

A simple protocol for in-band negotiation is specified in
\[[RFC8832](#RFC8832){.xref}\].[¶](#section-6.5-2){.pilcrow}

When one side wants to open a channel using out-of-band negotiation, it
picks a stream. Unless otherwise defined or negotiated, the streams are
picked based on the DTLS role (the client picks even stream identifiers,
and the server picks odd stream identifiers). However, the application
is responsible for avoiding collisions with existing streams. If it
attempts to reuse a stream that is part of an existing data channel, the
addition [MUST]{.bcp14} fail. In addition to choosing a stream, the
application [SHOULD]{.bcp14} also determine the options to be used for
sending messages. The application [MUST]{.bcp14} ensure in an
application-specific manner that the application at the peer will also
know the selected stream to be used, as well as the options for sending
data from that side.[¶](#section-6.5-3){.pilcrow}
:::

::: {#section-6.6 .section}
### [6.6.](#section-6.6){.section-number .selfRef} [Transferring User Data on a Data Channel](#name-transferring-user-data-on-a){.section-name .selfRef} {#name-transferring-user-data-on-a}

All data sent on a data channel in both directions [MUST]{.bcp14} be
sent over the underlying stream using the reliability defined when the
data channel was opened, unless the options are changed or per-message
options are specified by a higher level.[¶](#section-6.6-1){.pilcrow}

The message orientation of SCTP is used to preserve the message
boundaries of user messages. Therefore, senders [MUST NOT]{.bcp14} put
more than one application message into an SCTP user message. Unless the
deprecated PPID-based fragmentation and reassembly is used, the sender
[MUST]{.bcp14} include exactly one application message in each SCTP user
message.[¶](#section-6.6-2){.pilcrow}

The SCTP Payload Protocol Identifiers (PPIDs) are used to signal the
interpretation of the \"payload data\". The following PPIDs
[MUST]{.bcp14} be used (see [Section
8](#sec-IANA){.xref}):[¶](#section-6.6-3){.pilcrow}

[]{.break}

WebRTC String:
:   to identify a non-empty JavaScript string encoded in
    UTF-8.[¶](#section-6.6-4.2){.pilcrow}
:   

WebRTC String Empty:
:   to identify an empty JavaScript string encoded in
    UTF-8.[¶](#section-6.6-4.4){.pilcrow}
:   

WebRTC Binary:
:   to identify non-empty JavaScript binary data (ArrayBuffer,
    ArrayBufferView, or Blob).[¶](#section-6.6-4.6){.pilcrow}
:   

WebRTC Binary Empty:
:   to identify empty JavaScript binary data (ArrayBuffer,
    ArrayBufferView, or Blob).[¶](#section-6.6-4.8){.pilcrow}
:   

SCTP does not support the sending of empty user messages. Therefore, if
an empty message has to be sent, the appropriate PPID (WebRTC String
Empty or WebRTC Binary Empty) is used, and the SCTP user message of one
zero byte is sent. When receiving an SCTP user message with one of these
PPIDs, the receiver [MUST]{.bcp14} ignore the SCTP user message and
process it as an empty message.[¶](#section-6.6-5){.pilcrow}

The usage of the PPIDs \"WebRTC String Partial\" and \"WebRTC Binary
Partial\" is deprecated. They were used for a PPID-based fragmentation
and reassembly of user messages belonging to reliable and ordered data
channels.[¶](#section-6.6-6){.pilcrow}

If a message with an unsupported PPID is received or some error
condition related to the received message is detected by the receiver
(for example, illegal ordering), the receiver [SHOULD]{.bcp14} close the
corresponding data channel. This implies in particular that extensions
using additional PPIDs can\'t be used without prior
negotiation.[¶](#section-6.6-7){.pilcrow}

The SCTP base protocol specified in \[[RFC4960](#RFC4960){.xref}\] does
not support the interleaving of user messages. Therefore, sending a
large user message can monopolize the SCTP association. To overcome this
limitation, \[[RFC8260](#RFC8260){.xref}\] defines an extension to
support message interleaving, which [SHOULD]{.bcp14} be used. As long as
message interleaving is not supported, the sender [SHOULD]{.bcp14} limit
the maximum message size to 16 KB to avoid
monopolization.[¶](#section-6.6-8){.pilcrow}

It is recommended that the message size be kept within certain size
bounds, as applications will not be able to support arbitrarily large
single messages. This limit has to be negotiated, for example, by using
\[[RFC8841](#RFC8841){.xref}\].[¶](#section-6.6-9){.pilcrow}

The sender [SHOULD]{.bcp14} disable the Nagle algorithm (see
\[[RFC1122](#RFC1122){.xref}\]) to minimize the
latency.[¶](#section-6.6-10){.pilcrow}
:::

::: {#section-6.7 .section}
### [6.7.](#section-6.7){.section-number .selfRef} [Closing a Data Channel](#name-closing-a-data-channel){.section-name .selfRef} {#name-closing-a-data-channel}

Closing of a data channel [MUST]{.bcp14} be signaled by resetting the
corresponding outgoing streams \[[RFC6525](#RFC6525){.xref}\]. This
means that if one side decides to close the data channel, it resets the
corresponding outgoing stream. When the peer sees that an incoming
stream was reset, it also resets its corresponding outgoing stream. Once
this is completed, the data channel is closed. Resetting a stream sets
the Stream Sequence Numbers (SSNs) of the stream back to \'zero\' with a
corresponding notification to the application layer that the reset has
been performed. Streams are available for reuse after a reset has been
performed.[¶](#section-6.7-1){.pilcrow}

\[[RFC6525](#RFC6525){.xref}\] also guarantees that all the messages are
delivered (or abandoned) before the stream is
reset.[¶](#section-6.7-2){.pilcrow}
:::
:::
:::

::: {#sec-security}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

This document does not add any additional considerations to the ones
given in \[[RFC8826](#RFC8826){.xref}\] and
\[[RFC8827](#RFC8827){.xref}\].[¶](#section-7-1){.pilcrow}

It should be noted that a receiver must be prepared for a sender that
tries to send arbitrarily large messages.[¶](#section-7-2){.pilcrow}
:::
:::

::: {#sec-IANA}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document uses six already registered SCTP Payload Protocol
Identifiers (PPIDs): \"DOMString Last\", \"Binary Data Partial\",
\"Binary Data Last\", \"DOMString Partial\", \"WebRTC String Empty\",
and \"WebRTC Binary Empty\". \[[RFC4960](#RFC4960){.xref}\] creates the
\"SCTP Payload Protocol Identifiers\" registry from which these
identifiers were assigned. IANA has updated the reference of these six
assignments to point to this document and changed the names of the first
four PPIDs. The corresponding dates remain
unchanged.[¶](#section-8-1){.pilcrow}

The six assignments have been updated to
read:[¶](#section-8-2){.pilcrow}

  Value                                SCTP PPID   Reference   Date
  ------------------------------------ ----------- ----------- ------------
  WebRTC String                        51          RFC 8831    2013-09-20
  WebRTC Binary Partial (deprecated)   52          RFC 8831    2013-09-20
  WebRTC Binary                        53          RFC 8831    2013-09-20
  WebRTC String Partial (deprecated)   54          RFC 8831    2013-09-20
  WebRTC String Empty                  56          RFC 8831    2014-08-22
  WebRTC Binary Empty                  57          RFC 8831    2014-08-22

  : [Table 1](#table-1){.selfRef}
:::
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC3758\]
:   [Stewart, R.]{.refAuthor}[, Ramalho, M.]{.refAuthor}[,
    Xie, Q.]{.refAuthor}[, Tuexen, M.]{.refAuthor}[, and P.
    Conrad]{.refAuthor}, [\"Stream Control Transmission Protocol (SCTP)
    Partial Reliability Extension\"]{.refTitle}, [RFC
    3758]{.seriesInfo}, [DOI 10.17487/RFC3758]{.seriesInfo}, May 2004,
    \<<https://www.rfc-editor.org/info/rfc3758>\>.
:   

\[RFC4820\]
:   [Tuexen, M.]{.refAuthor}[, Stewart, R.]{.refAuthor}[, and P.
    Lei]{.refAuthor}, [\"Padding Chunk and Parameter for the Stream
    Control Transmission Protocol (SCTP)\"]{.refTitle}, [RFC
    4820]{.seriesInfo}, [DOI 10.17487/RFC4820]{.seriesInfo}, March 2007,
    \<<https://www.rfc-editor.org/info/rfc4820>\>.
:   

\[RFC4821\]
:   [Mathis, M.]{.refAuthor}[ and J. Heffner]{.refAuthor},
    [\"Packetization Layer Path MTU Discovery\"]{.refTitle}, [RFC
    4821]{.seriesInfo}, [DOI 10.17487/RFC4821]{.seriesInfo}, March 2007,
    \<<https://www.rfc-editor.org/info/rfc4821>\>.
:   

\[RFC4960\]
:   [Stewart, R., Ed.]{.refAuthor}, [\"Stream Control Transmission
    Protocol\"]{.refTitle}, [RFC 4960]{.seriesInfo}, [DOI
    10.17487/RFC4960]{.seriesInfo}, September 2007,
    \<<https://www.rfc-editor.org/info/rfc4960>\>.
:   

\[RFC5061\]
:   [Stewart, R.]{.refAuthor}[, Xie, Q.]{.refAuthor}[,
    Tuexen, M.]{.refAuthor}[, Maruyama, S.]{.refAuthor}[, and M.
    Kozuka]{.refAuthor}, [\"Stream Control Transmission Protocol (SCTP)
    Dynamic Address Reconfiguration\"]{.refTitle}, [RFC
    5061]{.seriesInfo}, [DOI 10.17487/RFC5061]{.seriesInfo}, September
    2007, \<<https://www.rfc-editor.org/info/rfc5061>\>.
:   

\[RFC6525\]
:   [Stewart, R.]{.refAuthor}[, Tuexen, M.]{.refAuthor}[, and P.
    Lei]{.refAuthor}, [\"Stream Control Transmission Protocol (SCTP)
    Stream Reconfiguration\"]{.refTitle}, [RFC 6525]{.seriesInfo}, [DOI
    10.17487/RFC6525]{.seriesInfo}, February 2012,
    \<<https://www.rfc-editor.org/info/rfc6525>\>.
:   

\[RFC7496\]
:   [Tuexen, M.]{.refAuthor}[, Seggelmann, R.]{.refAuthor}[,
    Stewart, R.]{.refAuthor}[, and S. Loreto]{.refAuthor}, [\"Additional
    Policies for the Partially Reliable Stream Control Transmission
    Protocol Extension\"]{.refTitle}, [RFC 7496]{.seriesInfo}, [DOI
    10.17487/RFC7496]{.seriesInfo}, April 2015,
    \<<https://www.rfc-editor.org/info/rfc7496>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8260\]
:   [Stewart, R.]{.refAuthor}[, Tuexen, M.]{.refAuthor}[,
    Loreto, S.]{.refAuthor}[, and R. Seggelmann]{.refAuthor}, [\"Stream
    Schedulers and User Message Interleaving for the Stream Control
    Transmission Protocol\"]{.refTitle}, [RFC 8260]{.seriesInfo}, [DOI
    10.17487/RFC8260]{.seriesInfo}, November 2017,
    \<<https://www.rfc-editor.org/info/rfc8260>\>.
:   

\[RFC8261\]
:   [Tuexen, M.]{.refAuthor}[, Stewart, R.]{.refAuthor}[,
    Jesup, R.]{.refAuthor}[, and S. Loreto]{.refAuthor}, [\"Datagram
    Transport Layer Security (DTLS) Encapsulation of SCTP
    Packets\"]{.refTitle}, [RFC 8261]{.seriesInfo}, [DOI
    10.17487/RFC8261]{.seriesInfo}, November 2017,
    \<<https://www.rfc-editor.org/info/rfc8261>\>.
:   

\[RFC8445\]
:   [Keranen, A.]{.refAuthor}[, Holmberg, C.]{.refAuthor}[, and J.
    Rosenberg]{.refAuthor}, [\"Interactive Connectivity Establishment
    (ICE): A Protocol for Network Address Translator (NAT)
    Traversal\"]{.refTitle}, [RFC 8445]{.seriesInfo}, [DOI
    10.17487/RFC8445]{.seriesInfo}, July 2018,
    \<<https://www.rfc-editor.org/info/rfc8445>\>.
:   

\[RFC8826\]
:   [Rescorla, E.]{.refAuthor}, [\"Security Considerations for
    WebRTC\"]{.refTitle}, [RFC 8826]{.seriesInfo}, [DOI
    10.17487/RFC8826]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8826>\>.
:   

\[RFC8827\]
:   [Rescorla, E.]{.refAuthor}, [\"WebRTC Security
    Architecture\"]{.refTitle}, [RFC 8827]{.seriesInfo}, [DOI
    10.17487/RFC8827]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8827>\>.
:   

\[RFC8829\]
:   [Uberti, J.]{.refAuthor}[, Jennings, C.]{.refAuthor}[, and E.
    Rescorla, Ed.]{.refAuthor}, [\"JavaScript Session Establishment
    Protocol (JSEP)\"]{.refTitle}, [RFC 8829]{.seriesInfo}, [DOI
    10.17487/RFC8829]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8829>\>.
:   

\[RFC8832\]
:   [Jesup, R.]{.refAuthor}[, Loreto, S.]{.refAuthor}[, and M.
    Tüxen]{.refAuthor}, [\"WebRTC Data Channel Establishment
    Protocol\"]{.refTitle}, [RFC 8832]{.seriesInfo}, [DOI
    10.17487/RFC8832]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8832>\>.
:   

\[RFC8841\]
:   [Holmberg, C.]{.refAuthor}[, Shpount, R.]{.refAuthor}[,
    Loreto, S.]{.refAuthor}[, and G. Camarillo]{.refAuthor}, [\"Session
    Description Protocol (SDP) Offer/Answer Procedures for Stream
    Control Transmission Protocol (SCTP) over Datagram Transport Layer
    Security (DTLS) Transport\"]{.refTitle}, [RFC 8841]{.seriesInfo},
    [DOI 10.17487/RFC8841]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8841>\>.
:   
:::

::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[RFC1122\]
:   [Braden, R., Ed.]{.refAuthor}, [\"Requirements for Internet Hosts -
    Communication Layers\"]{.refTitle}, [STD 3]{.seriesInfo}, [RFC
    1122]{.seriesInfo}, [DOI 10.17487/RFC1122]{.seriesInfo}, October
    1989, \<<https://www.rfc-editor.org/info/rfc1122>\>.
:   

\[RFC4347\]
:   [Rescorla, E.]{.refAuthor}[ and N. Modadugu]{.refAuthor},
    [\"Datagram Transport Layer Security\"]{.refTitle}, [RFC
    4347]{.seriesInfo}, [DOI 10.17487/RFC4347]{.seriesInfo}, April 2006,
    \<<https://www.rfc-editor.org/info/rfc4347>\>.
:   

\[RFC5389\]
:   [Rosenberg, J.]{.refAuthor}[, Mahy, R.]{.refAuthor}[,
    Matthews, P.]{.refAuthor}[, and D. Wing]{.refAuthor}, [\"Session
    Traversal Utilities for NAT (STUN)\"]{.refTitle}, [RFC
    5389]{.seriesInfo}, [DOI 10.17487/RFC5389]{.seriesInfo}, October
    2008, \<<https://www.rfc-editor.org/info/rfc5389>\>.
:   

\[RFC5764\]
:   [McGrew, D.]{.refAuthor}[ and E. Rescorla]{.refAuthor}, [\"Datagram
    Transport Layer Security (DTLS) Extension to Establish Keys for the
    Secure Real-time Transport Protocol (SRTP)\"]{.refTitle}, [RFC
    5764]{.seriesInfo}, [DOI 10.17487/RFC5764]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5764>\>.
:   

\[RFC6083\]
:   [Tuexen, M.]{.refAuthor}[, Seggelmann, R.]{.refAuthor}[, and E.
    Rescorla]{.refAuthor}, [\"Datagram Transport Layer Security (DTLS)
    for Stream Control Transmission Protocol (SCTP)\"]{.refTitle}, [RFC
    6083]{.seriesInfo}, [DOI 10.17487/RFC6083]{.seriesInfo}, January
    2011, \<<https://www.rfc-editor.org/info/rfc6083>\>.
:   

\[RFC6347\]
:   [Rescorla, E.]{.refAuthor}[ and N. Modadugu]{.refAuthor},
    [\"Datagram Transport Layer Security Version 1.2\"]{.refTitle}, [RFC
    6347]{.seriesInfo}, [DOI 10.17487/RFC6347]{.seriesInfo}, January
    2012, \<<https://www.rfc-editor.org/info/rfc6347>\>.
:   

\[RFC6951\]
:   [Tuexen, M.]{.refAuthor}[ and R. Stewart]{.refAuthor}, [\"UDP
    Encapsulation of Stream Control Transmission Protocol (SCTP) Packets
    for End-Host to End-Host Communication\"]{.refTitle}, [RFC
    6951]{.seriesInfo}, [DOI 10.17487/RFC6951]{.seriesInfo}, May 2013,
    \<<https://www.rfc-editor.org/info/rfc6951>\>.
:   

\[TLS-DTLS13\]
:   [Rescorla, E.]{.refAuthor}[, Tschofenig, H.]{.refAuthor}[, and N.
    Modadugu]{.refAuthor}, [\"The Datagram Transport Layer Security
    (DTLS) Protocol Version 1.3\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-tls-dtls13-39]{.seriesInfo}, 2 November 2020,
    \<<https://tools.ietf.org/html/draft-ietf-tls-dtls13-39>\>.
:   
:::
:::

::: {#section-appendix.a .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

Many thanks for comments, ideas, and text from [Harald
Alvestrand]{.contact-name}, [Richard Barnes]{.contact-name}, [Adam
Bergkvist]{.contact-name}, [Alissa Cooper]{.contact-name}, [Benoit
Claise]{.contact-name}, [Spencer Dawkins]{.contact-name}, [Gunnar
Hellström]{.contact-name}, [Christer Holmberg]{.contact-name}, [Cullen
Jennings]{.contact-name}, [Paul Kyzivat]{.contact-name}, [Eric
Rescorla]{.contact-name}, [Adam Roach]{.contact-name}, [Irene
Rüngeler]{.contact-name}, [Randall Stewart]{.contact-name}, [Martin
Stiemerling]{.contact-name}, [Justin Uberti]{.contact-name}, and [Magnus
Westerlund]{.contact-name}.[¶](#section-appendix.a-1){.pilcrow}
:::

::: {#authors-addresses}
::: {#section-appendix.b .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Randell Jesup]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Mozilla]{.org}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <randell-ietf@jesup.org>
:::

::: {.left dir="auto"}
[Salvatore Loreto]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Ericsson]{.org}
:::

::: {.left dir="auto"}
[Hirsalantie 11]{.street-address}
:::

::: {.left dir="auto"}
FI-[02420]{.postal-code} [Jorvas]{.locality}
:::

::: {.left dir="auto"}
[Finland]{.country-name}
:::

::: email
Email: <salvatore.loreto@ericsson.com>
:::

::: {.left dir="auto"}
[Michael Tüxen]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Münster University of Applied Sciences]{.org}
:::

::: {.left dir="auto"}
[Stegerwaldstrasse 39]{.street-address}
:::

::: {.left dir="auto"}
[48565]{.postal-code} [ Steinfurt]{.locality}
:::

::: {.left dir="auto"}
[Germany]{.country-name}
:::

::: email
Email: <tuexen@fh-muenster.de>
:::
:::
:::
