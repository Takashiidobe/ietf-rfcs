  RFC 9019        IoT Firmware Update Architecture   April 2021
  --------------- ---------------------------------- ------------
  Moran, et al.   Informational                      \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9019](https://www.rfc-editor.org/rfc/rfc9019){.eref}

Category:
:   Informational

Published:
:   April 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    B. Moran
    :::

    ::: org
    Arm Limited
    :::
    :::

    ::: author
    ::: author-name
    H. Tschofenig
    :::

    ::: org
    Arm Limited
    :::
    :::

    ::: author
    ::: author-name
    D. Brown
    :::

    ::: org
    Linaro
    :::
    :::

    ::: author
    ::: author-name
    M. Meriac
    :::

    ::: org
    Consultant
    :::
    :::
:::

# RFC 9019 {#rfcnum}

# A Firmware Update Architecture for Internet of Things {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

Vulnerabilities in Internet of Things (IoT) devices have raised the need
for a reliable and secure firmware update mechanism suitable for devices
with resource constraints. Incorporating such an update mechanism is a
fundamental requirement for fixing vulnerabilities, but it also enables
other important capabilities such as updating configuration settings and
adding new functionality.[¶](#section-abstract-1){.pilcrow}

In addition to the definition of terminology and an architecture, this
document provides the motivation for the standardization of a manifest
format as a transport-agnostic means for describing and protecting
firmware updates.[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for informational
purposes.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Not all documents approved
by the IESG are candidates for any level of Internet Standard; see
Section 2 of RFC 7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9019>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Conventions and
    Terminology](#name-conventions-and-terminology){.xref}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Terms](#name-terms){.xref}
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [Stakeholders](#name-stakeholders){.xref}
        :::

    -   ::: {#section-toc.1-1.2.2.3}
        [2.3](#section-2.3){.xref}.  [Functions](#name-functions){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Architecture](#name-architecture){.xref}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Invoking the
    Firmware](#name-invoking-the-firmware){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [The
        Bootloader](#name-the-bootloader){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Types of IoT
    Devices](#name-types-of-iot-devices){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Single
        MCU](#name-single-mcu){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Single CPU with Partitioning
        between Secure Mode and Normal
        Mode](#name-single-cpu-with-partitionin){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Symmetric Multiple
        CPUs](#name-symmetric-multiple-cpus){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [Dual CPU, Shared
        Memory](#name-dual-cpu-shared-memory){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [Dual CPU, Other
        Bus](#name-dual-cpu-other-bus){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Manifests](#name-manifests){.xref}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Securing Firmware
    Updates](#name-securing-firmware-updates){.xref}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Example](#name-example){.xref}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Security
    Considerations](#name-security-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [Informative
    References](#name-informative-references){.xref}
    :::

-   ::: {#section-toc.1-1.12}
    [](#section-appendix.a){.xref}[Acknowledgements](#name-acknowledgements){.xref}
    :::

-   ::: {#section-toc.1-1.13}
    [](#section-appendix.b){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Firmware updates can help to fix security vulnerabilities, and
performing updates is an important building block in securing IoT
devices. Due to rising concerns about insecure IoT devices, the Internet
Architecture Board (IAB) organized the Internet of Things Software
Update (IoTSU) Workshop \[[RFC8240](#RFC8240){.xref}\] to take a look at
the bigger picture. The workshop revealed a number of challenges for
developers and led to the formation of the IETF Software Updates for
Internet of Things (SUIT) Working Group.[¶](#section-1-1){.pilcrow}

Developing secure IoT devices is not an easy task, and supporting a
firmware update solution requires skillful engineers. Once devices are
deployed, firmware updates play a critical part in their life-cycle
management, particularly when devices have a long lifetime or are
deployed in remote or inaccessible areas where manual intervention is
cost prohibitive or otherwise difficult. Firmware updates for IoT
devices are expected to work automatically, i.e., without user
involvement. Conversely, non-IoT devices are expected to account for
user preferences and consent when scheduling updates. Automatic updates
that do not require human intervention are key to a scalable solution
for fixing software vulnerabilities.[¶](#section-1-2){.pilcrow}

Firmware updates are done not only to fix bugs but also to add new
functionality and to reconfigure the device to work in new environments
or to behave differently in an already-deployed
context.[¶](#section-1-3){.pilcrow}

The manifest specification has to allow the
following:[¶](#section-1-4){.pilcrow}

-   [The firmware image is authenticated and integrity protected.
    Attempts to flash a maliciously modified firmware image or an image
    from an unknown, untrusted source must be prevented. This document
    uses asymmetric cryptography in examples because it is the preferred
    approach by many IoT deployments. The use of symmetric credentials
    is also supported and can be used by very constrained IoT
    devices.[¶](#section-1-5.1){.pilcrow}]{#section-1-5.1}
-   [The firmware image can be confidentiality protected so that
    attempts by an adversary to recover the plaintext binary can be
    mitigated or at least made more difficult. Obtaining the firmware is
    often one of the first steps to mounting an attack since it gives
    the adversary valuable insights into the software libraries used,
    configuration settings, and generic functionality. Even though
    reverse engineering the binary can be a tedious process, modern
    reverse engineering frameworks have made this task a lot
    easier.[¶](#section-1-5.2){.pilcrow}]{#section-1-5.2}

Authentication and integrity protection of firmware images must be used
in a deployment, but the confidential protection of firmware is
optional.[¶](#section-1-6){.pilcrow}

While the standardization work has been informed by and optimized for
firmware update use cases of Class 1 devices (according to the device
class definitions in RFC 7228 \[[RFC7228](#RFC7228){.xref}\]), there is
nothing in the architecture that restricts its use to only these
constrained IoT devices. Moreover, this architecture is not limited to
managing firmware and software updates but can also be applied to
managing the delivery of arbitrary data, such as configuration
information and keys. Unlike higher-end devices, like laptops and
desktop PCs, many IoT devices do not have user interfaces; therefore,
support for unattended updates is essential for the design of a
practical solution. Constrained IoT devices often use a software
engineering model where a developer is responsible for creating and
compiling all software running on the device into a single, monolithic
firmware image. On higher-end devices, application software is, on the
other hand, often downloaded separately and even obtained from
developers different from the developers of the lower-level software.
The details for how to obtain those application-layer software binaries
then depend heavily on the platform, the programming language used, and
the sandbox in which the software is
executed.[¶](#section-1-7){.pilcrow}

While the IETF standardization work has been focused on the manifest
format, a fully interoperable solution needs more than a standardized
manifest. For example, protocols for transferring firmware images and
manifests to the device need to be available, as well as the status
tracker functionality. Devices also require a mechanism to discover the
status tracker(s) and/or firmware servers, for example, using
preconfigured hostnames or DNS-based Service Discovery (DNS-SD)
\[[RFC6763](#RFC6763){.xref}\]. These building blocks have been
developed by various organizations under the umbrella of an IoT device
management solution. The Lightweight Machine-to-Machine (LwM2M) protocol
\[[LwM2M](#LwM2M){.xref}\] is one IoT device management
protocol.[¶](#section-1-8){.pilcrow}

However, there are several areas that (partially) fall outside the scope
of the IETF and other standards organizations but need to be considered
by firmware authors as well as device and network operators. Here are
some of them, as highlighted during the IoTSU
workshop:[¶](#section-1-9){.pilcrow}

-   [Installing firmware updates in a robust fashion so that the update
    does not break the device functionality of the environment in which
    this device operates. This requires proper testing and offering of
    recovery strategies when a firmware update is
    unsuccessful.[¶](#section-1-10.1){.pilcrow}]{#section-1-10.1}
-   [Making firmware updates available in a timely fashion considering
    the complexity of the decision-making process for updating devices,
    potential recertification requirements, the length of a supply chain
    an update needs to go through before it reaches the end customer,
    and the need for user consent to install
    updates.[¶](#section-1-10.2){.pilcrow}]{#section-1-10.2}
-   [Ensuring an energy-efficient design of a battery-powered IoT
    device; a firmware update, particularly radio communication and
    writing the firmware image to flash, is an energy-intensive task for
    a device.[¶](#section-1-10.3){.pilcrow}]{#section-1-10.3}
-   [Creating incentives for device operators to use a firmware update
    mechanism and to require its integration from IoT device
    vendors.[¶](#section-1-10.4){.pilcrow}]{#section-1-10.4}
-   [Ensuring that firmware updates addressing critical flaws can be
    obtained even after a product is discontinued or a vendor goes out
    of business.[¶](#section-1-10.5){.pilcrow}]{#section-1-10.5}

This document starts with a terminology list followed by a description
of the architecture. We then explain the bootloader and how it
integrates with the firmware update mechanism. Subsequently, we offer a
categorization of IoT devices in terms of their hardware capabilities
relevant for firmware updates. Next, we talk about the manifest
structure and how to use it to secure firmware updates. We conclude with
a more detailed example of a message flow for distributing a firmware
image to a device.[¶](#section-1-11){.pilcrow}
:::
:::

::: {#terminology}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Conventions and Terminology](#name-conventions-and-terminology){.section-name .selfRef} {#name-conventions-and-terminology}

::: {#terms}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Terms](#name-terms){.section-name .selfRef} {#name-terms}

This document uses the following terms:[¶](#section-2.1-1){.pilcrow}

[]{.break}

Firmware Image:

:   The firmware image, or simply the \"image\", is a binary that may
    contain the complete software of a device or a subset of it. The
    firmware image may consist of multiple images if the device contains
    more than one microcontroller. Often, it is also a compressed
    archive that contains code, configuration data, and even the entire
    file system. The image may consist of a differential update for
    performance reasons.[¶](#section-2.1-2.2.1){.pilcrow}

    The terms \"firmware image\", \"firmware\", and \"image\" are used
    in this document and are interchangeable. We use the term
    \"application firmware image\" to differentiate it from a firmware
    image that contains the bootloader. An application firmware image,
    as the name indicates, contains the application program often
    including all the necessary code to run it (such as protocol stacks
    and an embedded operating system
    (OS)).[¶](#section-2.1-2.2.2){.pilcrow}

:   

Manifest:
:   The manifest contains metadata about the firmware image. The
    manifest is protected against modification and provides information
    about the author.[¶](#section-2.1-2.4){.pilcrow}
:   

Microcontroller:
:   A microcontroller unit (MCU) is a compact integrated circuit
    designed for use in embedded systems. A typical microcontroller
    includes a processor, memory (RAM and flash), input/output (I/O)
    ports, and other features connected via some bus on a single chip.
    The term \"system on chip\" (SoC) is often used interchangeably with
    MCU, but MCU tends to imply more limited peripheral
    functions.[¶](#section-2.1-2.6){.pilcrow}
:   

Rich Execution Environment (REE):
:   An environment that is provided and governed by a typical OS (e.g.,
    Linux, Windows, Android, iOS), potentially in conjunction with other
    supporting operating systems and hypervisors; it is outside of the
    Trusted Execution Environment (TEE). This environment and the
    applications running on it are considered
    untrusted.[¶](#section-2.1-2.8){.pilcrow}
:   

Software:
:   Similar to firmware but typically dynamically loaded by an OS. Used
    interchangeably with firmware in this
    document.[¶](#section-2.1-2.10){.pilcrow}
:   

System on Chip (SoC):
:   An SoC is an integrated circuit that contains all components of a
    computer, such as the CPU, memory, I/O ports, secondary storage, a
    bus to connect the components, and other hardware blocks of
    logic.[¶](#section-2.1-2.12){.pilcrow}
:   

Trust Anchor:
:   A trust anchor, as defined in RFC 6024
    \[[RFC6024](#RFC6024){.xref}\], represents an authoritative entity
    via a public key and associated data. The public key is used to
    verify digital signatures, and the associated data is used to
    constrain the types of information for which the trust anchor is
    authoritative.[¶](#section-2.1-2.14){.pilcrow}
:   

Trust Anchor Store:
:   A trust anchor store, as defined in \[[RFC6024](#RFC6024){.xref}\],
    is a set of one or more trust anchors stored in a device. A device
    may have more than one trust anchor store, each of which may be used
    by one or more applications. A trust anchor store must resist
    modification against unauthorized insertion, deletion, and
    modification.[¶](#section-2.1-2.16){.pilcrow}
:   

Trusted Applications (TAs):
:   An application component that runs in a
    TEE.[¶](#section-2.1-2.18){.pilcrow}
:   

Trusted Execution Environments (TEEs):
:   An execution environment that runs alongside of, but is isolated
    from, an REE. For more information about TEEs, see
    \[[TEEP-ARCH](#I-D.ietf-teep-architecture){.xref}\].[¶](#section-2.1-2.20){.pilcrow}
:   
:::
:::

::: {#stakeholders}
::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [Stakeholders](#name-stakeholders){.section-name .selfRef} {#name-stakeholders}

The following stakeholders are used in this
document:[¶](#section-2.2-1){.pilcrow}

[]{.break}

Author:
:   The author is the entity that creates the firmware image. There may
    be multiple authors involved in producing firmware running on an IoT
    device. [Section 5](#device){.xref} talks about those IoT device
    deployment cases.[¶](#section-2.2-2.2){.pilcrow}
:   

Device Operator:
:   The device operator is responsible for the day-to-day operation of a
    fleet of IoT devices. Customers of IoT devices, as the owners of IoT
    devices (such as enterprise customers or end users), interact with
    their IoT devices indirectly through the device operator via the Web
    or smartphone apps.[¶](#section-2.2-2.4){.pilcrow}
:   

Network Operator:
:   The network operator is responsible for the operation of a network
    to which IoT devices connect.[¶](#section-2.2-2.6){.pilcrow}
:   

Trust Provisioning Authority (TPA):
:   The TPA distributes trust anchors and authorization policies to
    devices and various stakeholders. The TPA may also delegate rights
    to stakeholders. Typically, the original equipment manufacturer
    (OEM) or original design manufacturer (ODM) will act as a TPA;
    however, complex supply chains may require a different design. In
    some cases, the TPA may decide to remain in full control over the
    firmware update process of their
    products.[¶](#section-2.2-2.8){.pilcrow}
:   

User:
:   The end user of a device. The user may interact with devices via the
    Web or smartphone apps, as well as through direct user
    interfaces.[¶](#section-2.2-2.10){.pilcrow}
:   
:::
:::

::: {#functions}
::: {#section-2.3 .section}
### [2.3.](#section-2.3){.section-number .selfRef} [Functions](#name-functions){.section-name .selfRef} {#name-functions}

[]{.break}

(IoT) Device:
:   A device refers to the entire IoT product, which consists of one or
    many MCUs, sensors, and/or actuators. Many IoT devices sold today
    contain multiple MCUs; therefore, a single device may need to obtain
    more than one firmware image and manifest to successfully perform an
    update.[¶](#section-2.3-1.2){.pilcrow}
:   

Status Tracker:

:   The status tracker has a client and a server component and performs
    three tasks:[¶](#section-2.3-1.4.1){.pilcrow}

    1.  [It communicates the availability of a new firmware version.
        This information will flow from the server to the
        client.[¶](#section-2.3-1.4.2.1){.pilcrow}]{#section-2.3-1.4.2.1}
    2.  [It conveys information about the software and hardware
        characteristics of the device. The information flow is from the
        client to the
        server.[¶](#section-2.3-1.4.2.2){.pilcrow}]{#section-2.3-1.4.2.2}
    3.  [It can remotely trigger the firmware update process. The
        information flow is from the server to the
        client.[¶](#section-2.3-1.4.2.3){.pilcrow}]{#section-2.3-1.4.2.3}

    For example, a device operator may want to read the installed
    firmware version number running on the device and information about
    available flash memory. Once an update has been triggered, the
    device operator may want to obtain information about the state of
    the firmware update. If errors occurred, the device operator may
    want to troubleshoot problems by first obtaining diagnostic
    information (typically using a device management
    protocol).[¶](#section-2.3-1.4.3){.pilcrow}

    We make no assumptions about where the server-side component is
    deployed. The deployment of status trackers is flexible: they may be
    found at cloud-based servers or on-premise servers, or they may be
    embedded in edge computing devices. A status tracker server
    component may even be deployed on an IoT device. For example, if the
    IoT device contains multiple MCUs, then the main MCU may act as a
    status tracker towards the other MCUs. Such deployment is useful
    when updates have to be synchronized across
    MCUs.[¶](#section-2.3-1.4.4){.pilcrow}

    The status tracker may be operated by any suitable stakeholder,
    typically the author, device operator, or network
    operator.[¶](#section-2.3-1.4.5){.pilcrow}

:   

Firmware Consumer:
:   The firmware consumer is the recipient of the firmware image and the
    manifest. It is responsible for parsing and verifying the received
    manifest and for storing the obtained firmware image. The firmware
    consumer plays the role of the update component on the IoT device,
    typically running in the application firmware. It interacts with the
    firmware server and the status tracker client
    (locally).[¶](#section-2.3-1.6){.pilcrow}
:   

Firmware Server:
:   The firmware server stores firmware images and manifests and
    distributes them to IoT devices. Some deployments may require a
    store-and-forward concept, which requires storing the firmware
    images and/or manifests on more than one entity before they reach
    the device. There is typically some interaction between the firmware
    server and the status tracker, and these two entities are often
    physically separated on different devices for scalability
    reasons.[¶](#section-2.3-1.8){.pilcrow}
:   

Bootloader:
:   A bootloader is a piece of software that is executed once a
    microcontroller has been reset. It is responsible for deciding what
    code to execute.[¶](#section-2.3-1.10){.pilcrow}
:   
:::
:::
:::
:::

::: {#architecture}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Architecture](#name-architecture){.section-name .selfRef} {#name-architecture}

More devices than ever before are connected to the Internet, which
drives the need for firmware updates to be provided over the Internet
rather than through traditional interfaces, such as USB or RS-232.
Sending updates over the Internet requires the device to fetch the new
firmware image as well as the manifest.[¶](#section-3-1){.pilcrow}

Hence, the following components are necessary on a device for a firmware
update solution:[¶](#section-3-2){.pilcrow}

-   [The Internet protocol stack for firmware downloads. Firmware images
    are often multiple kilobytes, sometimes exceeding one hundred
    kilobytes, for low-end IoT devices and can even be several megabytes
    for IoT devices running full-fledged operating systems like Linux.
    The protocol mechanism for retrieving these images needs to offer
    features like congestion control, flow control, fragmentation and
    reassembly, and mechanisms to resume interrupted or corrupted
    transfers.[¶](#section-3-3.1){.pilcrow}]{#section-3-3.1}
-   [The capability to write the received firmware image to persistent
    storage (most likely flash
    memory).[¶](#section-3-3.2){.pilcrow}]{#section-3-3.2}
-   [A manifest parser with code to verify a digital signature or a
    message authentication code
    (MAC).[¶](#section-3-3.3){.pilcrow}]{#section-3-3.3}
-   [The ability to unpack, decompress, and/or decrypt the received
    firmware image.[¶](#section-3-3.4){.pilcrow}]{#section-3-3.4}
-   [A status tracker.[¶](#section-3-3.5){.pilcrow}]{#section-3-3.5}

The features listed above are most likely provided by code in the
application firmware image running on the device rather than by the
bootloader itself. Note that cryptographic algorithms will likely run in
a trusted execution environment on a separate MCU in a hardware security
module or in a secure element rather than in the same context as the
application code.[¶](#section-3-4){.pilcrow}

[Figure 1](#arch-figure){.xref} shows the architecture where a firmware
image is created by an author and made available to a firmware server.
For security reasons, the author will not have the permissions to upload
firmware images to the firmware server and to initiate an update
directly. Instead, authors will make firmware images available to the
device operators. Note that there may be a longer supply chain involved
to pass software updates from the author all the way to the authorizing
party, which can then finally make a decision to deploy it with IoT
devices.[¶](#section-3-5){.pilcrow}

As a first step in the firmware update process, the status tracker
server needs to inform the status tracker client that a new firmware
update is available. This can be accomplished via polling (client
initiated), push notifications (server initiated), or more complex
mechanisms (such as a hybrid approach):[¶](#section-3-6){.pilcrow}

-   [Client-initiated updates take the form of a status tracker client
    proactively checking (polling) for
    updates.[¶](#section-3-7.1){.pilcrow}]{#section-3-7.1}
-   [With server-initiated updates, the server-side component of the
    status tracker learns about a new firmware version and determines
    which devices qualify for a firmware update. Once the relevant
    devices have been selected, the status tracker informs these
    devices, and the firmware consumers obtain those images and
    manifests. Server-initiated updates are important because they allow
    a quick response time. Note that in this mode, the client-side
    status tracker needs to be reachable by the server-side component.
    This may require devices to keep reachability information on the
    server side up to date and the state at NATs and stateful packet
    filtering firewalls
    alive.[¶](#section-3-7.2){.pilcrow}]{#section-3-7.2}
-   [Using a hybrid approach, the server side of the status tracker
    pushes update availability notifications to the client side and
    requests that the firmware consumer pull the manifest and the
    firmware image from the firmware
    server.[¶](#section-3-7.3){.pilcrow}]{#section-3-7.3}

Once the device operator triggers an update via the status tracker, it
will keep track of the update process on the device. This allows the
device operator to know what devices have received an update and which
of them are still pending an update.[¶](#section-3-8){.pilcrow}

Firmware images can be conveyed to devices in a variety of ways,
including USB, Universal Asynchronous Receiver Transmitter (UART), WiFi,
Bluetooth Low Energy (BLE), low-power WAN technologies, mesh networks
and many more. At the application layer, a variety of protocols are also
available: Message Queuing Telemetry Transport (MQTT), Constrained
Application Protocol (CoAP), and HTTP are the most popular
application-layer protocols used by IoT devices. This architecture does
not make assumptions about how the firmware images are distributed to
the devices and therefore aims to support all these
technologies.[¶](#section-3-9){.pilcrow}

In some cases, it may be desirable to distribute firmware images using a
multicast or broadcast protocol. This architecture does not make
recommendations for any such protocol. However, given that broadcast may
be desirable for some networks, updates must cause the least disruption
possible both in the metadata and firmware transmission. For an update
to be broadcast friendly, it cannot rely on link-layer, network-layer,
or transport-layer security. A solution has to rely on security
protection applied to the manifest and firmware image instead. In
addition, the same manifest must be deliverable to many devices, both
those to which it applies and those to which it does not, without a
chance that the wrong device will accept the update. Considerations that
apply to network broadcasts apply equally to the use of third-party
content distribution networks for payload
distribution.[¶](#section-3-10){.pilcrow}

[]{#name-architecture-2}

::: {#arch-figure}
::: {#section-3-11.1 .artwork .art-text .alignCenter}
                                                          +----------+
                                                          |          |
                                                          |  Author  |
                                                          |          |
                                                          +----------+
                           Firmware + Manifest                 |
                  +----------------------------------+         | Firmware +
                  |                                  |         | Manifest
                  |                               ---+-------  |
                  |                           ----   |       --|-
                  |                         //+----------+     | \\
                 -+--                      // |          |     |   \
            ----/ |  ----                |/   | Firmware |<-+  |    \
          //      |      \\              |    | Server   |  |  |     \
         /        |        \             /    |          |  +  +      \
        /         |         \           /     +----------+   \ /       |
       / +--------+--------+ \         /                      |        |
      /  |        v        |  \       /                       v        |
     |   | +------------+  |   |     |          +----------------+      |
     |   | |  Firmware  |  |   |     |          |     Device     |      |
     |   | |  Consumer  |  |   |     |          |     Management |      |
    |    | +------------+  |    |    |          |                |      |
    |    | +------------+  |    |    |          |    +--------+  |      |
    |    | |  Status    |<-+--------------------+->  |        |  |      |
    |    | |  Tracker   |  |    |    |          |    | Status |  |      |
    |    | |  Client    |  |    |    |          |    | Tracker|  |     |
     |   | +------------+  |   |     |          |    | Server |  |     |
     |   |    Device       |   |      |         |    +--------+  |     |
     |   +-----------------+   |       \        |                |    /
      \                       /         \       +----------------+   /
       \       Network       /           \                          /
        \     Operator      /             \     Device Operator    /
         \\               //               \\                    //
            ----     ----                     ----           ----
                -----                             -----------
:::

[Figure 1](#figure-1){.selfRef}:
[Architecture](#name-architecture-2){.selfRef}
:::

Firmware images and manifests may be conveyed as a bundle or detached.
The manifest format must support both
approaches.[¶](#section-3-12){.pilcrow}

For distribution as a bundle, the firmware image is embedded into the
manifest. This is a useful approach for deployments where devices are
not connected to the Internet and cannot contact a dedicated firmware
server for the firmware download. It is also applicable when the
firmware update happens via USB sticks or short-range radio technologies
(such as Bluetooth Smart).[¶](#section-3-13){.pilcrow}

Alternatively, the manifest is distributed detached from the firmware
image. Using this approach, the firmware consumer is presented with the
manifest first and then needs to obtain one or more firmware images as
dictated in the manifest.[¶](#section-3-14){.pilcrow}

The pre-authorization step involves verifying whether the entity signing
the manifest is indeed authorized to perform an update. The firmware
consumer must also determine whether it should fetch and process a
firmware image, which is referenced in a
manifest.[¶](#section-3-15){.pilcrow}

A dependency resolution phase is needed when more than one component can
be updated or when a differential update is used. The necessary
dependencies must be available prior to
installation.[¶](#section-3-16){.pilcrow}

The download step is the process of acquiring a local copy of the
firmware image. When the download is client initiated, this means that
the firmware consumer chooses when a download occurs and initiates the
download process. When a download is server initiated, this means that
the status tracker tells the device when to download or that it
initiates the transfer directly to the firmware consumer. For example, a
download from an HTTP/1.1-based firmware server is client initiated.
Pushing a manifest and firmware image to the Package Resource of the
LwM2M Firmware Update Object \[[LwM2M](#LwM2M){.xref}\] is a
server-initiated update.[¶](#section-3-17){.pilcrow}

If the firmware consumer has downloaded a new firmware image and is
ready to install it, to initiate the installation, it
may[¶](#section-3-18){.pilcrow}

-   [need to wait for a trigger from the status
    tracker,[¶](#section-3-19.1){.pilcrow}]{#section-3-19.1}
-   [trigger the update automatically,
    or[¶](#section-3-19.2){.pilcrow}]{#section-3-19.2}
-   [go through a more complex decision-making process to determine the
    appropriate timing for an
    update.[¶](#section-3-19.3){.pilcrow}]{#section-3-19.3}

Sometimes the final decision may require confirmation of the user of the
device for safety reasons.[¶](#section-3-20){.pilcrow}

Installation is the act of processing the payload into a format that the
IoT device can recognize, and the bootloader is responsible for then
booting from the newly installed firmware image. This process is
different when a bootloader is not involved. For example, when an
application is updated in a full-featured OS, the updater may halt and
restart the application in isolation. Devices must not fail when a
disruption, such as a power failure or network interruption, occurs
during the update process.[¶](#section-3-21){.pilcrow}
:::
:::

::: {#invocation}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Invoking the Firmware](#name-invoking-the-firmware){.section-name .selfRef} {#name-invoking-the-firmware}

[Section 3](#architecture){.xref} describes the steps for getting the
firmware image and the manifest from the author to the firmware consumer
on the IoT device. Once the firmware consumer has retrieved and
successfully processed the manifest and the firmware image, it needs to
invoke the new firmware image. This is managed in many different ways
depending on the type of device, but it typically involves halting the
current version of the firmware, handing over control to firmware with a
higher privilege or trust level (the firmware verifier), verifying the
new firmware\'s authenticity and integrity, and then invoking
it.[¶](#section-4-1){.pilcrow}

In an execute-in-place microcontroller, this is often done by rebooting
into a bootloader (simultaneously halting the application and handing
over control to the higher privilege level) then executing a secure boot
process (verifying and invoking the new
image).[¶](#section-4-2){.pilcrow}

In a rich OS, this may be done by halting one or more processes and then
invoking new applications. In some OSes, this implicitly involves the
kernel verifying the code signatures on the new
applications.[¶](#section-4-3){.pilcrow}

The invocation process is security sensitive. An attacker will typically
try to retrieve a firmware image from the device for reverse engineering
or will try to get the firmware verifier to execute an attacker-modified
firmware image. Therefore, firmware verifier will have to perform
security checks on the firmware image before it can be invoked. These
security checks by the firmware verifier happen in addition to the
security checks that took place when the firmware image and the manifest
were downloaded by the firmware consumer.[¶](#section-4-4){.pilcrow}

The overlap between the firmware consumer and the firmware verifier
functionality comes in two forms, namely:[¶](#section-4-5){.pilcrow}

-   [A firmware verifier must verify the firmware image it boots as part
    of the secure boot process. Doing so requires metadata to be stored
    alongside the firmware image so that the firmware verifier can
    cryptographically verify the firmware image before booting it to
    ensure it has not been tampered with or replaced. This metadata used
    by the firmware verifier may well be the same manifest obtained with
    the firmware image during the update
    process.[¶](#section-4-6.1){.pilcrow}]{#section-4-6.1}
-   [An IoT device needs a recovery strategy in case the firmware
    update/invocation process fails. The recovery strategy may include
    storing two or more application firmware images on the device or
    offering the ability to invoke a recovery image to perform the
    firmware update process again using firmware updates over serial,
    USB, or even wireless connectivity like Bluetooth Smart. In the
    latter case, the firmware consumer functionality is contained in the
    recovery image and requires the necessary functionality for
    executing the firmware update process, including manifest
    parsing.[¶](#section-4-6.2){.pilcrow}]{#section-4-6.2}

While this document assumes that the firmware verifier itself is
distinct from the role of the firmware consumer and therefore does not
manage the firmware update process, this is not a requirement, and these
roles may be combined in practice.[¶](#section-4-7){.pilcrow}

Using a bootloader as the firmware verifier requires some special
considerations, particularly when the bootloader implements the
robustness requirements identified by the IoTSU workshop
\[[RFC8240](#RFC8240){.xref}\].[¶](#section-4-8){.pilcrow}

::: {#bootloader}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [The Bootloader](#name-the-bootloader){.section-name .selfRef} {#name-the-bootloader}

In most cases, the MCU must restart in order to hand over control to the
bootloader. Once the MCU has initiated a restart, the bootloader
determines whether a newly available firmware image should be executed.
If the bootloader concludes that the newly available firmware image is
invalid, a recovery strategy is necessary. There are only two approaches
for recovering from invalid firmware: either the bootloader must be able
to select different, valid firmware or it must be able to obtain new,
valid firmware. Both of these approaches have implications for the
architecture of the update system.[¶](#section-4.1-1){.pilcrow}

Assuming the first approach, there are (at least) three firmware images
available on the device:[¶](#section-4.1-2){.pilcrow}

-   [First, the bootloader is also firmware. If a bootloader is
    updatable, then its firmware image is treated like any other
    application firmware
    image.[¶](#section-4.1-3.1){.pilcrow}]{#section-4.1-3.1}
-   [Second, the firmware image that has to be replaced is still
    available on the device as a backup in case the freshly downloaded
    firmware image does not boot or operate
    correctly.[¶](#section-4.1-3.2){.pilcrow}]{#section-4.1-3.2}
-   [Third, there is the newly downloaded firmware
    image.[¶](#section-4.1-3.3){.pilcrow}]{#section-4.1-3.3}

Therefore, the firmware consumer must know where to store the new
firmware. In some cases, this may be implicit (for example, replacing
the least recently used firmware image). In other cases, the storage
location of the new firmware must be explicit, for example, when a
device has one or more application firmware images and a recovery image
with limited functionality, sufficient only to perform an
update.[¶](#section-4.1-4){.pilcrow}

Since many low-end IoT devices do not use position-independent code,
either the bootloader needs to copy the newly downloaded application
firmware image into the location of the old application firmware image
and vice versa or multiple versions of the firmware need to be prepared
for different locations.[¶](#section-4.1-5){.pilcrow}

In general, it is assumed that the bootloader itself, or a minimal part
of it, will not be updated since a failed update of the bootloader poses
a reliability risk.[¶](#section-4.1-6){.pilcrow}

For a bootloader to offer a secure boot functionality, it needs to
implement the following functionality:[¶](#section-4.1-7){.pilcrow}

-   [The bootloader needs to fetch the manifest from nonvolatile storage
    and parse its contents for subsequent cryptographic
    verification.[¶](#section-4.1-8.1){.pilcrow}]{#section-4.1-8.1}
-   [Cryptographic libraries with hash functions, digital signatures
    (for asymmetric crypto), and message authentication codes (for
    symmetric crypto) need to be
    accessible.[¶](#section-4.1-8.2){.pilcrow}]{#section-4.1-8.2}
-   [The device needs to have a trust anchor store to verify the digital
    signature. Alternatively, access to a key store for use with the
    message authentication code may be
    used.[¶](#section-4.1-8.3){.pilcrow}]{#section-4.1-8.3}
-   [There must be an ability to expose boot-process-related data to the
    application firmware (such as the status tracker). This allows
    information sharing about the current firmware version and the
    status of the firmware update process and whether errors have
    occurred.[¶](#section-4.1-8.4){.pilcrow}]{#section-4.1-8.4}
-   [Produce boot measurements as part of an attestation solution; see
    \[[RATS-ARCH](#I-D.ietf-rats-architecture){.xref}\] for more
    information
    (optional).[¶](#section-4.1-8.5){.pilcrow}]{#section-4.1-8.5}
-   [The bootloader must be able to decrypt firmware images in case
    confidentiality protection was applied. This requires a solution for
    key management
    (optional).[¶](#section-4.1-8.6){.pilcrow}]{#section-4.1-8.6}
:::
:::
:::
:::

::: {#device}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Types of IoT Devices](#name-types-of-iot-devices){.section-name .selfRef} {#name-types-of-iot-devices}

Today, there are billions of MCUs used in devices produced by a large
number of silicon manufacturers. While MCUs can vary significantly in
their characteristics, there are a number of similarities that allow us
to categorize them into groups.[¶](#section-5-1){.pilcrow}

The firmware update architecture, and the manifest format in particular,
needs to offer enough flexibility to cover these common deployment
cases.[¶](#section-5-2){.pilcrow}

::: {#single-mcu}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Single MCU](#name-single-mcu){.section-name .selfRef} {#name-single-mcu}

The simplest and currently most common architecture consists of a single
MCU along with its own peripherals. These SoCs generally contain some
amount of flash memory for code and fixed data, as well as RAM for
working storage. A notable characteristic of these SoCs is that the
primary code is generally execute in place (XIP). Due to the
non-relocatable nature of the code, the firmware image needs to be
placed in a specific location in flash memory since the code cannot be
executed from an arbitrary location therein. Hence, when the firmware
image is updated, it is necessary to swap the old and the new
image.[¶](#section-5.1-1){.pilcrow}
:::
:::

::: {#single-cpu-with-secure-normal-mode-partitioning}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Single CPU with Partitioning between Secure Mode and Normal Mode](#name-single-cpu-with-partitionin){.section-name .selfRef} {#name-single-cpu-with-partitionin}

Another configuration consists of a similar architecture to the one
previously discussed: it contains a single CPU. However, this CPU
supports a security partitioning scheme that allows memory and other
system components to be divided into secure and normal mode. There will
generally be two images: one for secure mode and one for normal mode. In
this configuration, firmware upgrades will generally be done by the CPU
in secure mode, which is able to write to both areas of the flash
device. In addition, there are requirements to be able to update either
image independently as well as to update them together atomically, as
specified in the associated manifests.[¶](#section-5.2-1){.pilcrow}
:::
:::

::: {#symmetric-multiple-cpus}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Symmetric Multiple CPUs](#name-symmetric-multiple-cpus){.section-name .selfRef} {#name-symmetric-multiple-cpus}

In more complex SoCs with symmetric multiprocessing support, advanced
operating systems, such as Linux, are often used. These SoCs frequently
use an external storage medium, such as raw NAND flash or an embedded
Multimedia Card (eMMC). Due to the higher quantity of resources, these
devices are often capable of storing multiple copies of their firmware
images and selecting the most appropriate one to boot. Many SoCs also
support bootloaders that are capable of updating the firmware image;
however, this is typically a last resort because it requires the device
to be held in the bootloader while the new firmware is downloaded and
installed, which results in downtime for the device. Firmware updates in
this class of device are typically not done in
place.[¶](#section-5.3-1){.pilcrow}
:::
:::

::: {#dual-cpu-shared-memory}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [Dual CPU, Shared Memory](#name-dual-cpu-shared-memory){.section-name .selfRef} {#name-dual-cpu-shared-memory}

This configuration has two or more heterogeneous CPUs in a single SoC
that share memory (flash and RAM). Generally, there will be a mechanism
to prevent one CPU from unintentionally accessing memory currently
allocated to the other. Upgrades in this case will typically be done by
one of the CPUs and is similar to the single CPU with secure
mode.[¶](#section-5.4-1){.pilcrow}
:::
:::

::: {#dual-cpu-other-bus}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [Dual CPU, Other Bus](#name-dual-cpu-other-bus){.section-name .selfRef} {#name-dual-cpu-other-bus}

This configuration has two or more heterogeneous CPUs, each having their
own memory. There will be a communication channel between them, but it
will be used as a peripheral, not via shared memory. In this case, each
CPU will have to be responsible for its own firmware upgrade. It is
likely that one of the CPUs will be considered the primary CPU and will
direct the other CPU to do the upgrade. This configuration is commonly
used to offload specific work to other CPUs. Firmware dependencies are
similar to the other solutions above: sometimes allowing only one image
to be upgraded, other times requiring several to be upgraded atomically.
Because the updates are happening on multiple CPUs, upgrading the two
images atomically is challenging.[¶](#section-5.5-1){.pilcrow}
:::
:::
:::
:::

::: {#manifests}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Manifests](#name-manifests){.section-name .selfRef} {#name-manifests}

In order for a firmware consumer to apply an update, it has to make
several decisions using manifest-provided information and data available
on the device itself. For more detailed information and a longer list of
information elements in the manifest, consult the information model
specification
\[[SUIT-INFO-MODEL](#I-D.ietf-suit-information-model){.xref}\], which
offers justifications for each element, and the manifest specification
\[[SUIT-MANIFEST](#I-D.ietf-suit-manifest){.xref}\] for details about
how this information is included in the
manifest.[¶](#section-6-1){.pilcrow}

[]{#name-example-firmware-update-dec}

::: {#manifest-info}
  Decision                                         Information Elements
  ------------------------------------------------ ------------------------------------------------------------------------
  Should I trust the author of the firmware?       Trust anchors and authorization policies on the device
  Has the firmware been corrupted?                 Digital signature and MAC covering the firmware image
  Does the firmware update apply to this device?   Conditions with Vendor ID, Class ID, and Device ID
  Is the update older than the active firmware?    Sequence number in the manifest (1)
  When should the device apply the update?         Wait directive
  How should the device apply the update?          Manifest commands
  What kind of firmware binary is it?              Unpack algorithms to interpret a format
  Where should the update be obtained?             Dependencies on other manifests and firmware image URI in the manifest
  Where should the firmware be stored?             Storage location and component identifier

  : [Table 1](#table-1){.selfRef}: [Example Firmware Update
  Decisions](#name-example-firmware-update-dec){.selfRef}
:::

[]{.break}

(1):
:   A device presented with an old but valid manifest and firmware must
    not be tricked into installing such firmware since a vulnerability
    in the old firmware image may allow an attacker to gain control of
    the device.[¶](#section-6-3.2){.pilcrow}
:   

Keeping the code size and complexity of a manifest parser small is
important for constrained IoT devices. Since the manifest parsing code
may also be used by the bootloader, it can be part of the trusted
computing base.[¶](#section-6-4){.pilcrow}

A manifest may be used to protect not only firmware images but also
configuration data such as network credentials or personalization data
related to the firmware or software. Personalization data demonstrates
the need for confidentiality to be maintained between two or more
stakeholders that deliver images to the same device. Personalization
data is used with TEEs, which benefit from a protocol for managing the
life cycle of TAs running inside a TEE. TEEs may obtain TAs from
different authors, and those TAs may require personalization data, such
as payment information, to be securely conveyed to the TEE. The TA\'s
author does not want to expose the TA\'s code to any other stakeholder
or third party. The user does not want to expose the payment information
to any other stakeholder or third party.[¶](#section-6-5){.pilcrow}
:::
:::

::: {#securing}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Securing Firmware Updates](#name-securing-firmware-updates){.section-name .selfRef} {#name-securing-firmware-updates}

Using firmware updates to fix vulnerabilities in devices is important,
but securing this update mechanism is equally important since security
problems are exacerbated by the update mechanism. An update is
essentially authorized remote code execution, so any security problems
in the update process expose that remote code execution system. Failure
to secure the firmware update process will help attackers take control
of devices.[¶](#section-7-1){.pilcrow}

End-to-end security mechanisms are used to protect the firmware image
and the manifest. The following assumptions are made to allow the
firmware consumer to verify the received firmware image and manifest
before updating the software:[¶](#section-7-2){.pilcrow}

-   [Authentication ensures that the device can cryptographically
    identify the author(s) creating firmware images and manifests.
    Authenticated identities may be used as input to the authorization
    process. Not all entities creating and signing manifests have the
    same permissions. A device needs to determine whether the requested
    action is indeed covered by the permission of the party that signed
    the manifest. Informing the device about the permissions of the
    different parties also happens in an out-of-band fashion and is a
    duty of the Trust Provisioning
    Authority.[¶](#section-7-3.1){.pilcrow}]{#section-7-3.1}
-   [Integrity protection ensures that no third party can modify the
    manifest or the firmware image. To accept an update, a device needs
    to verify the signature covering the manifest. There may be one or
    multiple manifests that need to be validated, potentially signed by
    different parties. The device needs to be in possession of the trust
    anchors to verify those signatures. Installing trust anchors to
    devices via the Trust Provisioning Authority happens in an
    out-of-band fashion prior to the firmware update
    process.[¶](#section-7-3.2){.pilcrow}]{#section-7-3.2}
-   [Confidentiality protection of the firmware image must be done in
    such a way that no one aside from the intended firmware consumer(s)
    and other authorized parties can decrypt it. The information that is
    encrypted individually for each device/recipient must be done in a
    way that is usable with Content Distribution Networks (CDNs), bulk
    storage, and broadcast protocols. For confidentiality protection of
    firmware images, the author needs to be in possession of the
    certificate/public key or a pre-shared key of a device. The use of
    confidentiality protection of firmware images is
    optional.[¶](#section-7-3.3){.pilcrow}]{#section-7-3.3}

A manifest specification must support different cryptographic algorithms
and algorithm extensibility. Moreover, since signature schemes based on
RSA and Elliptic Curve Cryptography (ECC) may become vulnerable to
quantum-accelerated key extraction in the future, unchangeable
bootloader code in ROM is recommended to use post-quantum secure
signature schemes such as hash-based signatures
\[[RFC8778](#RFC8778){.xref}\]. A bootloader author must carefully
consider the service lifetime of their product and the time horizon for
quantum-accelerated key extraction. At the time of writing, the
worst-case estimate for the time horizon to key extraction with quantum
acceleration is approximately 2030, based on current research
\[[quantum-factorization](#quantum-factorization){.xref}\].[¶](#section-7-4){.pilcrow}

When a device obtains a monolithic firmware image from a single author
without any additional approval steps, the authorization flow is
relatively simple. However, there are other cases where more complex
policy decisions need to be made before updating a
device.[¶](#section-7-5){.pilcrow}

In this architecture, the authorization policy is separated from the
underlying communication architecture. This is accomplished by
separating the entities from their permissions. For example, an author
may not have the authority to install a firmware image on a device in
critical infrastructure without the authorization of a device operator.
In this case, the device may be programmed to reject firmware updates
unless they are signed both by the firmware author and by the device
operator.[¶](#section-7-6){.pilcrow}

Alternatively, a device may trust precisely one entity that does all
permission management and coordination. This entity allows the device to
offload complex permissions calculations for the
device.[¶](#section-7-7){.pilcrow}
:::
:::

::: {#example}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Example](#name-example){.section-name .selfRef} {#name-example}

[Figure 2](#firmware-update){.xref} illustrates an example message flow
for distributing a firmware image to a device. The firmware and manifest
are stored on the same firmware server and distributed in a detached
manner.[¶](#section-8-1){.pilcrow}

[]{#name-first-example-flow-for-a-fi}

::: {#firmware-update}
::: {#section-8-2.1 .artwork .art-text .alignCenter}
    +--------+    +-----------------+    +-----------------------------+
    |        |    | Firmware Server |    |         IoT Device          |
    | Author |    | Status Tracker  |    | +------------+ +----------+ |
    +--------+    | Server          |    | |  Firmware  | |Bootloader| |
      |           +-----------------+    | |  Consumer  | |          | |
      |                   |              | +------------+ +----------+ |
      |                   |              |      |                |     |
      |                   |              |  +-----------------------+  |
      | Create Firmware   |              |  | Status Tracker Client |  |
      |--------------+    |              |  +-----------------------+  |
      |              |    |               `''''''''''''''''''''''''''''
      |<-------------+    |                     |        |       |
      |                   |                     |        |       |
      | Upload Firmware   |                     |        |       |
      |------------------>|                     |        |       |
      |                   |                     |        |       |
      | Create Manifest   |                     |        |       |
      |---------------+   |                     |        |       |
      |               |   |                     |        |       |
      |<--------------+   |                     |        |       |
      |                   |                     |        |       |
      | Sign Manifest     |                     |        |       |
      |-------------+     |                     |        |       |
      |             |     |                     |        |       |
      |<------------+     |                     |        |       |
      |                   |                     |        |       |
      | Upload Manifest   |                     |        |       |
      |------------------>|  Notification of    |        |       |
      |                   |  new firmware image |        |       |
      |                   |----------------------------->|       |
      |                   |                     |        |       |
      |                   |                     |Initiate|       |
      |                   |                     | Update |       |
      |                   |                     |<-------|       |
      |                   |                     |        |       |
      |                   |   Query Manifest    |        |       |
      |                   |<--------------------|        .       |
      |                   |                     |        .       |
      |                   |   Send Manifest     |        .       |
      |                   |-------------------->|        .       |
      |                   |                     | Validate       |
      |                   |                     | Manifest       |
      |                   |                     |--------+       |
      |                   |                     |        |       |
      |                   |                     |<-------+       |
      |                   |                     |        .       |
      |                   |  Request Firmware   |        .       |
      |                   |<--------------------|        .       |
      |                   |                     |        .       |
      |                   | Send Firmware       |        .       |
      |                   |-------------------->|        .       |
      |                   |                     | Verify .       |
      |                   |                     | Firmware       |
      |                   |                     |--------+       |
      |                   |                     |        |       |
      |                   |                     |<-------+       |
      |                   |                     |        .       |
      |                   |                     | Store  .       |
      |                   |                     | Firmware       |
      |                   |                     |--------+       |
      |                   |                     |        |       |
      |                   |                     |<-------+       |
      |                   |                     |        .       |
      |                   |                     |        .       |
      |                   |                     |        .       |
      |                   |                     |        |       |
      |                   |                     | Update |       |
      |                   |                     |Complete|       |
      |                   |                     |------->|       |
      |                   |                              |       |
      |                   |  Firmware Update Completed   |       |
      |                   |<-----------------------------|       |
      |                   |                              |       |
      |                   |  Reboot                      |       |
      |                   |----------------------------->|       |
      |                   |                     |        |       |
      |                   |                     |        |       |
      |                   |                     |        |Reboot |
      |                   |                     |        |------>|
      |                   |                     |        |       |
      |                   |                     |        .       |
      |                   |                 +---+----------------+--+
      |                   |                S|   |                |  |
      |                   |                E|   | Verify         |  |
      |                   |                C|   | Firmware       |  |
      |                   |                U|   | +--------------|  |
      |                   |                R|   | |              |  |
      |                   |                E|   | +------------->|  |
      |                   |                 |   |                |  |
      |                   |                B|   | Activate new   |  |
      |                   |                O|   | Firmware       |  |
      |                   |                O|   | +--------------|  |
      |                   |                T|   | |              |  |
      |                   |                 |   | +------------->|  |
      |                   |                P|   |                |  |
      |                   |                R|   | Boot new       |  |
      |                   |                O|   | Firmware       |  |
      |                   |                C|   | +--------------|  |
      |                   |                E|   | |              |  |
      |                   |                S|   | +------------->|  |
      |                   |                S|   |                |  |
      |                   |                 +---+----------------+--+
      |                   |                     |        .       |
      |                   |                     |        |       |
      |                   |                     .        |       |
      |                   |  Device running new firmware |       |
      |                   |<-----------------------------|       |
      |                   |                     .        |       |
      |                   |                              |       |
:::

[Figure 2](#figure-2){.selfRef}: [First Example Flow for a Firmware
Update](#name-first-example-flow-for-a-fi){.selfRef}
:::

[Figure 3](#firmware-update2){.xref} shows an exchange that starts with
the status tracker querying the device for its current firmware version.
Later, a new firmware version becomes available, and since this device
is running an older version, the status tracker server interacts with
the device to initiate an update.[¶](#section-8-3){.pilcrow}

The manifest and the firmware are stored on different servers in this
example. When the device processes the manifest, it learns where to
download the new firmware version. The firmware consumer downloads the
firmware image with the newer version X.Y.Z after successful validation
of the manifest. Subsequently, a reboot is initiated, and the secure
boot process starts. Finally, the device reports the successful boot of
the new firmware version.[¶](#section-8-4){.pilcrow}

[]{#name-second-example-flow-for-a-f}

::: {#firmware-update2}
::: {#section-8-5.1 .artwork .art-text .alignCenter}
     +---------+   +-----------------+    +-----------------------------+
     | Status  |   | Firmware Server |    | +------------+ +----------+ |
     | Tracker |   | Status Tracker  |    | |  Firmware  | |Bootloader| |
     | Server  |   | Server          |    | |  Consumer  | |          | |
     +---------+   +-----------------+    | |  +Status   | +----------+ |
          |                |              | |  Tracker   |        |     |
          |                |              | |  Client    |        |     |
          |                |              | +------------+        |     |
          |                |              |      |  IoT Device    |     |
          |                |               `''''''''''''''''''''''''''''
          |                |                     |                |
          |        Query Firmware Version        |                |
          |------------------------------------->|                |
          |        Firmware Version A.B.C        |                |
          |<-------------------------------------|                |
          |                |                     |                |
          |         <<some time later>>          |                |
          |                |                     |                |
        _,...._         _,...._                  |                |
      ,'       `.     ,'       `.                |                |
     |   New     |   |   New     |               |                |
     \ Manifest  /   \ Firmware  /               |                |
      `.._   _,,'     `.._   _,,'                |                |
          `''             `''                    |                |
          |            Push manifest             |                |
          |----------------+-------------------->|                |
          |                |                     |                |
          |                '                     |                '
          |                |                     | Validate       |
          |                |                     | Manifest       |
          |                |                     |---------+      |
          |                |                     |         |      |
          |                |                     |<--------+      |
          |                | Request firmware    |                |
          |                | X.Y.Z               |                |
          |                |<--------------------|                |
          |                |                     |                |
          |                | Firmware X.Y.Z      |                |
          |                |-------------------->|                |
          |                |                     |                |
          |                |                     | Verify         |
          |                |                     | Firmware       |
          |                |                     |--------------+ |
          |                |                     |              | |
          |                |                     |<-------------+ |
          |                |                     |                |
          |                |                     | Store          |
          |                |                     | Firmware       |
          |                |                     |-------------+  |
          |                |                     |             |  |
          |                |                     |<------------+  |
          |                |                     |                |
          |                |                     |                |
          |                |                     | Trigger Reboot |
          |                |                     |--------------->|
          |                |                     |                |
          |                |                     |                |
          |                |                     | __..-------..._'
          |                |                    ,-'               `-.
          |                |                   |      Secure Boot    |
          |                |                   `-.                 _/
          |                |                     |`--..._____,,.,-'
          |                |                     |                |
          | Device running firmware X.Y.Z        |                |
          |<-------------------------------------|                |
          |                |                     |                |
          |                |                     |                |
:::

[Figure 3](#figure-3){.selfRef}: [Second Example Flow for a Firmware
Update](#name-second-example-flow-for-a-f){.selfRef}
:::
:::
:::

::: {#iana-considerations}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-9-1){.pilcrow}
:::
:::

::: {#security-considerations}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

This document describes the terminology, requirements, and an
architecture for firmware updates of IoT devices. The content of the
document is thereby focused on improving the security of IoT devices via
firmware update mechanisms and informs the standardization of a manifest
format.[¶](#section-10-1){.pilcrow}

An in-depth examination of the security considerations of the
architecture is presented in
\[[SUIT-INFO-MODEL](#I-D.ietf-suit-information-model){.xref}\].[¶](#section-10-2){.pilcrow}
:::
:::

::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[LwM2M\]
:   [Open Mobile Alliance]{.refAuthor}, [\"Lightweight Machine to
    Machine Technical Specification\"]{.refTitle}, [Version
    1.0.2]{.seriesInfo}, February 2018,
    \<<http://www.openmobilealliance.org/release/LightweightM2M/V1_0_2-20180209-A/OMA-TS-LightweightM2M-V1_0_2-20180209-A.pdf>\>.
:   

\[quantum-factorization\]
:   [Jiang, S.]{.refAuthor}, [Britt, K.A.]{.refAuthor}, [McCaskey,
    A.J.]{.refAuthor}, [Humble, T.S.]{.refAuthor}, and [S.
    Kais]{.refAuthor}, [\"Quantum Annealing for Prime
    Factorization\"]{.refTitle}, [Scientific Reports 8]{.seriesInfo},
    December 2018,
    \<<https://www.nature.com/articles/s41598-018-36058-z>\>.
:   

\[RATS-ARCH\]
:   [Birkholz, H.]{.refAuthor}, [Thaler, D.]{.refAuthor},
    [Richardson, M.]{.refAuthor}, [Smith, N.]{.refAuthor}, and [W.
    Pan]{.refAuthor}, [\"Remote Attestation Procedures
    Architecture\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-rats-architecture-12]{.seriesInfo}, 23
    April 2021,
    \<<https://tools.ietf.org/html/draft-ietf-rats-architecture-12>\>.
:   

\[RFC6024\]
:   [Reddy, R.]{.refAuthor} and [C. Wallace]{.refAuthor}, [\"Trust
    Anchor Management Requirements\"]{.refTitle}, [RFC
    6024]{.seriesInfo}, [DOI 10.17487/RFC6024]{.seriesInfo}, October
    2010, \<<https://www.rfc-editor.org/info/rfc6024>\>.
:   

\[RFC6763\]
:   [Cheshire, S.]{.refAuthor} and [M. Krochmal]{.refAuthor},
    [\"DNS-Based Service Discovery\"]{.refTitle}, [RFC
    6763]{.seriesInfo}, [DOI 10.17487/RFC6763]{.seriesInfo}, February
    2013, \<<https://www.rfc-editor.org/info/rfc6763>\>.
:   

\[RFC7228\]
:   [Bormann, C.]{.refAuthor}, [Ersue, M.]{.refAuthor}, and [A.
    Keranen]{.refAuthor}, [\"Terminology for Constrained-Node
    Networks\"]{.refTitle}, [RFC 7228]{.seriesInfo}, [DOI
    10.17487/RFC7228]{.seriesInfo}, May 2014,
    \<<https://www.rfc-editor.org/info/rfc7228>\>.
:   

\[RFC8240\]
:   [Tschofenig, H.]{.refAuthor} and [S. Farrell]{.refAuthor}, [\"Report
    from the Internet of Things Software Update (IoTSU) Workshop
    2016\"]{.refTitle}, [RFC 8240]{.seriesInfo}, [DOI
    10.17487/RFC8240]{.seriesInfo}, September 2017,
    \<<https://www.rfc-editor.org/info/rfc8240>\>.
:   

\[RFC8778\]
:   [Housley, R.]{.refAuthor}, [\"Use of the HSS/LMS Hash-Based
    Signature Algorithm with CBOR Object Signing and Encryption
    (COSE)\"]{.refTitle}, [RFC 8778]{.seriesInfo}, [DOI
    10.17487/RFC8778]{.seriesInfo}, April 2020,
    \<<https://www.rfc-editor.org/info/rfc8778>\>.
:   

\[SUIT-INFO-MODEL\]
:   [Moran, B.]{.refAuthor}, [Tschofenig, H.]{.refAuthor}, and [H.
    Birkholz]{.refAuthor}, [\"A Manifest Information Model for Firmware
    Updates in IoT Devices\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-suit-information-model-11]{.seriesInfo}, 6 April 2021,
    \<<https://tools.ietf.org/html/draft-ietf-suit-information-model-11>\>.
:   

\[SUIT-MANIFEST\]
:   [Moran, B.]{.refAuthor}, [Tschofenig, H.]{.refAuthor},
    [Birkholz, H.]{.refAuthor}, and [K. Zandberg]{.refAuthor}, [\"A
    Concise Binary Object Representation (CBOR)-based Serialization
    Format for the Software Updates for Internet of Things (SUIT)
    Manifest\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-suit-manifest-12]{.seriesInfo}, 22
    February 2021,
    \<<https://tools.ietf.org/html/draft-ietf-suit-manifest-12>\>.
:   

\[TEEP-ARCH\]
:   [Pei, M.]{.refAuthor}, [Tschofenig, H.]{.refAuthor},
    [Thaler, D.]{.refAuthor}, and [D. Wheeler]{.refAuthor}, [\"Trusted
    Execution Environment Provisioning (TEEP)
    Architecture\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-teep-architecture-14]{.seriesInfo}, 22
    February 2021,
    \<<https://tools.ietf.org/html/draft-ietf-teep-architecture-14>\>.
:   
:::

::: {#acknowledgements}
::: {#section-appendix.a .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

We would like to thank the following individuals for their
feedback:[¶](#section-appendix.a-1){.pilcrow}

-   ::: {#section-appendix.a-2.1}
    [Geraint
    Luff]{.contact-name}[¶](#section-appendix.a-2.1.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.2}
    [Amyas
    Phillips]{.contact-name}[¶](#section-appendix.a-2.2.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.3}
    [Dan Ros]{.contact-name}[¶](#section-appendix.a-2.3.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.4}
    [Thomas
    Eichinger]{.contact-name}[¶](#section-appendix.a-2.4.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.5}
    [Michael
    Richardson]{.contact-name}[¶](#section-appendix.a-2.5.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.6}
    [Emmanuel
    Baccelli]{.contact-name}[¶](#section-appendix.a-2.6.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.7}
    [Ned Smith]{.contact-name}[¶](#section-appendix.a-2.7.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.8}
    [Jim Schaad]{.contact-name}[¶](#section-appendix.a-2.8.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.9}
    [Carsten
    Bormann]{.contact-name}[¶](#section-appendix.a-2.9.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.10}
    [Cullen
    Jennings]{.contact-name}[¶](#section-appendix.a-2.10.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.11}
    [Olaf
    Bergmann]{.contact-name}[¶](#section-appendix.a-2.11.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.12}
    [Suhas
    Nandakumar]{.contact-name}[¶](#section-appendix.a-2.12.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.13}
    [Phillip
    Hallam-Baker]{.contact-name}[¶](#section-appendix.a-2.13.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.14}
    [Marti
    Bolivar]{.contact-name}[¶](#section-appendix.a-2.14.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.15}
    [Andrzej
    Puzdrowski]{.contact-name}[¶](#section-appendix.a-2.15.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.16}
    [Markus
    Gueller]{.contact-name}[¶](#section-appendix.a-2.16.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.17}
    [Henk
    Birkholz]{.contact-name}[¶](#section-appendix.a-2.17.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.18}
    [Jintao Zhu]{.contact-name}[¶](#section-appendix.a-2.18.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.19}
    [Takeshi
    Takahashi]{.contact-name}[¶](#section-appendix.a-2.19.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.20}
    [Jacob
    Beningo]{.contact-name}[¶](#section-appendix.a-2.20.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.21}
    [Kathleen
    Moriarty]{.contact-name}[¶](#section-appendix.a-2.21.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.22}
    [Bob
    Briscoe]{.contact-name}[¶](#section-appendix.a-2.22.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.23}
    [Roman
    Danyliw]{.contact-name}[¶](#section-appendix.a-2.23.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.24}
    [Brian
    Carpenter]{.contact-name}[¶](#section-appendix.a-2.24.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.25}
    [Theresa
    Enghardt]{.contact-name}[¶](#section-appendix.a-2.25.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.26}
    [Rich Salz]{.contact-name}[¶](#section-appendix.a-2.26.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.27}
    [Mohit
    Sethi]{.contact-name}[¶](#section-appendix.a-2.27.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.28}
    [Éric
    Vyncke]{.contact-name}[¶](#section-appendix.a-2.28.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.29}
    [Alvaro
    Retana]{.contact-name}[¶](#section-appendix.a-2.29.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.30}
    [Barry
    Leiba]{.contact-name}[¶](#section-appendix.a-2.30.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.31}
    [Benjamin
    Kaduk]{.contact-name}[¶](#section-appendix.a-2.31.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.32}
    [Martin
    Duke]{.contact-name}[¶](#section-appendix.a-2.32.1){.pilcrow}
    :::

-   ::: {#section-appendix.a-2.33}
    [Robert
    Wilton]{.contact-name}[¶](#section-appendix.a-2.33.1){.pilcrow}
    :::

We would also like to thank the WG chairs, [Russ
Housley]{.contact-name}, [David Waltermire]{.contact-name}, and [Dave
Thaler]{.contact-name} for their support and
review.[¶](#section-appendix.a-3){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.b .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Brendan Moran]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Arm Limited]{.org}
:::

::: email
Email: <Brendan.Moran@arm.com>
:::

::: {.left dir="auto"}
[Hannes Tschofenig]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Arm Limited]{.org}
:::

::: email
Email: <hannes.tschofenig@arm.com>
:::

::: {.left dir="auto"}
[David Brown]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Linaro]{.org}
:::

::: email
Email: <david.brown@linaro.org>
:::

::: {.left dir="auto"}
[Milosch Meriac]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Consultant]{.org}
:::

::: email
Email: <milosch@meriac.com>
:::
:::
:::
