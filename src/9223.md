  RFC 9223      ROUTE           April 2022
  ------------- --------------- ------------
  Zia, et al.   Informational   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Independent Submission

RFC:
:   [9223](https://www.rfc-editor.org/rfc/rfc9223){.eref}

Category:
:   Informational

Published:
:   April 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    W. Zia
    :::

    ::: org
    Qualcomm CDMA Technologies GmbH
    :::
    :::

    ::: author
    ::: author-name
    T. Stockhammer
    :::

    ::: org
    Qualcomm CDMA Technologies GmbH
    :::
    :::

    ::: author
    ::: author-name
    L. Chaponniere
    :::

    ::: org
    Qualcomm Technologies Inc.
    :::
    :::

    ::: author
    ::: author-name
    G. Mandyam
    :::

    ::: org
    Qualcomm Technologies Inc.
    :::
    :::

    ::: author
    ::: author-name
    M. Luby
    :::

    ::: org
    BitRipple, Inc.
    :::
    :::
:::

# RFC 9223 {#rfcnum}

# Real-Time Transport Object Delivery over Unidirectional Transport (ROUTE) {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

The Real-time Transport Object delivery over Unidirectional Transport
(ROUTE) protocol is specified for robust delivery of Application
Objects, including Application Objects with real-time delivery
constraints, to receivers over a unidirectional transport. Application
Objects consist of data that has meaning to applications that use the
ROUTE protocol for delivery of data to receivers; for example, it can be
a file, a Dynamic Adaptive Streaming over HTTP (DASH) or HTTP Live
Streaming (HLS) segment, a WAV audio clip, etc. The ROUTE protocol also
supports low-latency streaming
applications.[¶](#section-abstract-1){.pilcrow}

The ROUTE protocol is suitable for unicast, broadcast, and multicast
transport. Therefore, it can be run over UDP/IP, including multicast IP.
The ROUTE protocol can leverage the features of the underlying protocol
layer, e.g., to provide security, it can leverage IP security protocols
such as IPsec.[¶](#section-abstract-2){.pilcrow}

This document specifies the ROUTE protocol such that it could be used by
a variety of services for delivery of Application Objects by specifying
their own profiles of this protocol (e.g., by adding or constraining
some features).[¶](#section-abstract-3){.pilcrow}

This is not an IETF specification and does not have IETF
consensus.[¶](#section-abstract-4){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for informational
purposes.[¶](#section-boilerplate.1-1){.pilcrow}

This is a contribution to the RFC Series, independently of any other RFC
stream. The RFC Editor has chosen to publish this document at its
discretion and makes no statement about its value for implementation or
deployment. Documents approved for publication by the RFC Editor are not
candidates for any level of Internet Standard; see Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9223>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Overview](#name-overview){.xref}
        :::

    -   ::: {#section-toc.1-1.1.2.2}
        [1.2](#section-1.2){.xref}.  [Protocol Stack for
        ROUTE](#name-protocol-stack-for-route){.xref}
        :::

    -   ::: {#section-toc.1-1.1.2.3}
        [1.3](#section-1.3){.xref}.  [Data
        Model](#name-data-model){.xref}
        :::

    -   ::: {#section-toc.1-1.1.2.4}
        [1.4](#section-1.4){.xref}.  [Architecture and Scope of
        Specification](#name-architecture-and-scope-of-s){.xref}
        :::

    -   ::: {#section-toc.1-1.1.2.5}
        [1.5](#section-1.5){.xref}.  [Conventions Used in This
        Document](#name-conventions-used-in-this-do){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [ROUTE Packet
    Format](#name-route-packet-format){.xref}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Packet Structure and Header
        Fields](#name-packet-structure-and-header){.xref}
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [LCT Header
        Extensions](#name-lct-header-extensions){.xref}
        :::

    -   ::: {#section-toc.1-1.2.2.3}
        [2.3](#section-2.3){.xref}.  [FEC Payload ID for Source
        Flows](#name-fec-payload-id-for-source-f){.xref}
        :::

    -   ::: {#section-toc.1-1.2.2.4}
        [2.4](#section-2.4){.xref}.  [FEC Payload ID for Repair
        Flows](#name-fec-payload-id-for-repair-f){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Session
    Metadata](#name-session-metadata){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Generic
        Metadata](#name-generic-metadata){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Session Metadata for Source
        Flows](#name-session-metadata-for-source){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Session Metadata for Repair
        Flows](#name-session-metadata-for-repair){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Delivery Object
    Mode](#name-delivery-object-mode){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [File Mode](#name-file-mode){.xref}

        -   ::: {#section-toc.1-1.4.2.1.2.1}
            [4.1.1](#section-4.1.1){.xref}.  [Extensions to
            FDT](#name-extensions-to-fdt){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.2}
            [4.1.2](#section-4.1.2){.xref}.  [Constraints on Extended
            FDT](#name-constraints-on-extended-fdt){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Entity
        Mode](#name-entity-mode){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Unsigned Package
        Mode](#name-unsigned-package-mode){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Signed Package
        Mode](#name-signed-package-mode){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Sender
    Operation](#name-sender-operation){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Usage of ALC and LCT for Source
        Flow](#name-usage-of-alc-and-lct-for-so){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [ROUTE Packetization for Source
        Flow](#name-route-packetization-for-sou){.xref}

        -   ::: {#section-toc.1-1.5.2.2.2.1}
            [5.2.1](#section-5.2.1){.xref}.  [Basic ROUTE
            Packetization](#name-basic-route-packetization){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.2}
            [5.2.2](#section-5.2.2){.xref}.  [ROUTE Packetization for
            CMAF Chunked
            Content](#name-route-packetization-for-cma){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Timing of Packet
        Emission](#name-timing-of-packet-emission){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [Extended FDT Encoding for File
        Mode Sending](#name-extended-fdt-encoding-for-f){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [FEC Framework
        Considerations](#name-fec-framework-consideration){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.6}
        [5.6](#section-5.6){.xref}.  [FEC Transport Object
        Construction](#name-fec-transport-object-constr){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.7}
        [5.7](#section-5.7){.xref}.  [Super-Object
        Construction](#name-super-object-construction){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.8}
        [5.8](#section-5.8){.xref}.  [Repair Packet
        Considerations](#name-repair-packet-consideration){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.9}
        [5.9](#section-5.9){.xref}.  [Summary FEC
        Information](#name-summary-fec-information){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Receiver
    Operation](#name-receiver-operation){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Basic Application Object Recovery
        for Source Flows](#name-basic-application-object-re){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Fast Stream
        Acquisition](#name-fast-stream-acquisition){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Generating Extended FDT-Instance
        for File Mode](#name-generating-extended-fdt-ins){.xref}

        -   ::: {#section-toc.1-1.6.2.3.2.1}
            [6.3.1](#section-6.3.1){.xref}.  [File Template Substitution
            for Content-Location
            Derivation](#name-file-template-substitution-){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.3.2.2}
            [6.3.2](#section-6.3.2){.xref}.  [File\@Transfer-Length
            Derivation](#name-filetransfer-length-derivat){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.3.2.3}
            [6.3.3](#section-6.3.3){.xref}.  [FDT-Instance\@Expires
            Derivation](#name-fdt-instanceexpires-derivat){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [FEC
    Application](#name-fec-application){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [General FEC Application
        Guidelines](#name-general-fec-application-gui){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [TOI
        Mapping](#name-toi-mapping){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Delivery Object Reception
        Timeout](#name-delivery-object-reception-t){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [Example FEC
        Operation](#name-example-fec-operation){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Considerations for Defining ROUTE
    Profiles](#name-considerations-for-defining){.xref}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [ROUTE
    Concepts](#name-route-concepts){.xref}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [ROUTE Modes of
        Delivery](#name-route-modes-of-delivery){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [File Mode
        Optimizations](#name-file-mode-optimizations){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.3}
        [9.3](#section-9.3){.xref}.  [In-Band Signaling of Object
        Transfer Length](#name-in-band-signaling-of-object){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.4}
        [9.4](#section-9.4){.xref}.  [Repair Protocol
        Concepts](#name-repair-protocol-concepts){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Interoperability
    Chart](#name-interoperability-chart){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [Security and Privacy
    Considerations](#name-security-and-privacy-consid){.xref}

    -   ::: {#section-toc.1-1.11.2.1}
        [11.1](#section-11.1){.xref}.  [Security
        Considerations](#name-security-considerations){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [11.2](#section-11.2){.xref}.  [Privacy
        Considerations](#name-privacy-considerations){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.13}
    [13](#section-13){.xref}. [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.13.2.1}
        [13.1](#section-13.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.13.2.2}
        [13.2](#section-13.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.14}
    [](#appendix-A){.xref}[Acknowledgments](#name-acknowledgments){.xref}
    :::

-   ::: {#section-toc.1-1.15}
    [](#appendix-B){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#sect-1}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

::: {#sect-1.1}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Overview](#name-overview){.section-name .selfRef} {#name-overview}

The Real-time Transport Object delivery over Unidirectional Transport
(ROUTE) protocol can be used for robust delivery of Application Objects,
including Application Objects with real-time delivery constraints, to
receivers over a unidirectional transport. Unidirectional transport in
this document has identical meaning to that in RFC 6726
\[[RFC6726](#RFC6726){.xref}\], i.e., transport in the direction of
receiver(s) from a sender. The robustness is enabled by a built-in
mechanism, e.g., signaling for loss detection, enabling loss recovery,
and optionally integrating application-layer Forward Error Correction
(FEC).[¶](#section-1.1-1){.pilcrow}

Application Objects consist of data that has meaning to applications
that use the ROUTE protocol for delivery of data to receivers, e.g., an
Application Object can be a file, an MPEG Dynamic Adaptive Streaming
over HTTP (DASH) \[[DASH](#DASH){.xref}\] video segment, a WAV audio
clip, an MPEG Common Media Application Format (CMAF)
\[[CMAF](#CMAF){.xref}\] addressable resource, an MPEG-4 video clip,
etc.[¶](#section-1.1-2){.pilcrow}

The ROUTE protocol is designed to enable delivery of sequences of
related Application Objects in a timely manner to receivers, e.g., a
sequence of DASH video segments associated to a Representation or a
sequence of CMAF addressable resources associated to a CMAF Track. The
applications of this protocol target services enabled on media
consumption devices such as smartphones, tablets, television sets, and
so on. Most of these applications are real-time in the sense that they
are sensitive to and rely upon such timely reception of data. The ROUTE
protocol also supports chunked delivery of real-time Application Objects
to enable low-latency streaming applications (similar in its properties
to chunked delivery using HTTP). The protocol also enables low-latency
delivery of DASH and Apple HTTP Live Streaming (HLS) content with CMAF
Chunks.[¶](#section-1.1-3){.pilcrow}

Content not intended for rendering in real time as it is received (e.g.,
a downloaded application), a file comprising continuous or discrete
media and belonging to an app-based feature, or a file containing
(opaque) data to be consumed by a Digital Rights Management (DRM) system
client can also be delivered by ROUTE.[¶](#section-1.1-4){.pilcrow}

The ROUTE protocol supports a caching model where Application Objects
are recovered into a cache at the receiver and may be made available to
applications via standard HTTP requests from the cache. Many current day
applications rely on using HTTP to access content; hence, this approach
enables such applications in broadcast/multicast
environments.[¶](#section-1.1-5){.pilcrow}

ROUTE is aligned with File Delivery over Unidirectional Transport
(FLUTE) as defined in RFC 6726 \[[RFC6726](#RFC6726){.xref}\] as well as
the extensions defined in Multimedia Broadcast/Multicast Service (MBMS)
\[[MBMS](#MBMS){.xref}\], but it also makes use of some principles of
FCAST (Object Delivery for the Asynchronous Layered Coding (ALC) and
NACK-Oriented Reliable Multicast (NORM) Protocols) as defined in RFC
6968 \[[RFC6968](#RFC6968){.xref}\]; for example, object metadata and
the object content may be sent together in a compound
object.[¶](#section-1.1-6){.pilcrow}

The alignment to FLUTE is enabled since in addition to reusing several
of the basic FLUTE protocol features, as referred to by this document,
certain optimizations and restrictions are added that enable optimized
support for real-time delivery of media data; hence, the name of the
protocol. Among others, the source ROUTE protocol enables or enhances
the following functionalities:[¶](#section-1.1-7){.pilcrow}

-   [Real-time delivery of object-based media
    data[¶](#section-1.1-8.1){.pilcrow}]{#section-1.1-8.1}
-   [Flexible packetization, including enabling media-aware
    packetization as well as transport-aware packetization of delivery
    objects[¶](#section-1.1-8.2){.pilcrow}]{#section-1.1-8.2}
-   [Independence of Application Objects and delivery objects, i.e., a
    delivery object may be a part of a file or may be a group of
    files.[¶](#section-1.1-8.3){.pilcrow}]{#section-1.1-8.3}

Advanced Television Systems Committee (ATSC) 3.0 specifies the ROUTE
protocol integrated with an ATSC 3.0 services layer. That specification
will be referred to as ATSC-ROUTE \[[ATSCA331](#ATSCA331){.xref}\] for
the remainder of this document. Digital Video Broadcasting (DVB) has
specified a profile of ATSC-ROUTE in DVB Adaptive Media Streaming over
IP Multicast (DVB-MABR) \[[DVBMABR](#DVBMABR){.xref}\]. This document
specifies the Application Object delivery aspects (delivery protocol)
for such services, as the corresponding delivery protocol could be used
as a reference by a variety of services by specifying profiles of ROUTE
in their respective fora, e.g., by adding new optional features atop or
by restricting various optional features specified in this document in a
specific service standard. Hence, in the context of this document, the
aforementioned ATSC-ROUTE and DVB-MABR are the services using ROUTE. The
definition of profiles by the services also have to give due
consideration to compatibility issues, and some related guidelines are
also provided in this document.[¶](#section-1.1-9){.pilcrow}

This document is not an IETF specification and does not have IETF
consensus. It is provided here to aid the production of interoperable
implementations.[¶](#section-1.1-10){.pilcrow}
:::
:::

::: {#sect-1.2}
::: {#section-1.2 .section}
### [1.2.](#section-1.2){.section-number .selfRef} [Protocol Stack for ROUTE](#name-protocol-stack-for-route){.section-name .selfRef} {#name-protocol-stack-for-route}

ROUTE delivers Application Objects such as MPEG DASH or HLS segments and
optionally the associated repair data, operating over UDP/IP networks,
as depicted in [Table 1](#protocol-layering){.xref}. The session
metadata signaling to realize a ROUTE session as specified in this
document [MAY]{.bcp14} be delivered out of band or in band as well.
Since ROUTE delivers objects in an application cache at the receiver
from where the application can access them using HTTP, an application
like DASH may use its standardized unicast streaming mechanisms in
conjunction with ROUTE over broadcast/multicast to augment the
services.[¶](#section-1.2-1){.pilcrow}

[]{#name-protocol-layering}

::: {#protocol-layering}
  --------------------------------------------------------
  Application (DASH and HLS segments, CMAF Chunks, etc.)
  ROUTE
  UDP
  IP
  --------------------------------------------------------

  : [Table 1](#table-1){.selfRef}: [Protocol
  Layering](#name-protocol-layering){.selfRef}
:::
:::
:::

::: {#sect-1.3}
::: {#section-1.3 .section}
### [1.3.](#section-1.3){.section-number .selfRef} [Data Model](#name-data-model){.section-name .selfRef} {#name-data-model}

The ROUTE data model is constituted by the following key
concepts.[¶](#section-1.3-1){.pilcrow}

[]{.break}

Application Object:
:   data that has meaning to the application that uses the ROUTE
    protocol for delivery of data to receivers, e.g., an Application
    Object can be a file, a DASH video segment, a WAV audio clip, an
    MPEG-4 video clip, etc.[¶](#section-1.3-2.2){.pilcrow}
:   

Delivery Object:
:   an object on course of delivery to the application from the ROUTE
    sender to ROUTE receiver.[¶](#section-1.3-2.4){.pilcrow}
:   

Transport Object:
:   an object identified by the Transport Object Identifier (TOI) in RFC
    5651 \[[RFC5651](#RFC5651){.xref}\]. It [MAY]{.bcp14} be either a
    source or a repair object, depending on if it is carried by a Source
    Flow or a Repair Flow, respectively.[¶](#section-1.3-2.6){.pilcrow}
:   

Transport Session:
:   a Layered Coding Transport (LCT) channel, as defined by RFC 5651
    \[[RFC5651](#RFC5651){.xref}\]. A Transport Session [SHALL]{.bcp14}
    be uniquely identified by a unique Transport Session Identifier
    (TSI) value in the LCT header. The TSI is scoped by the IP address
    of the sender, and the IP address of the sender together with the
    TSI uniquely identify the session. Transport Sessions are a subset
    of a ROUTE session. For media delivery, a Transport Session would
    typically carry a media component, for example, a DASH
    Representation. Within each Transport Session, one or more objects
    are carried, typically objects that are related, e.g., DASH segments
    associated to one Representation.[¶](#section-1.3-2.8){.pilcrow}
:   

ROUTE Session:
:   an ensemble or multiplex of one or more Transport Sessions. Each
    ROUTE session is associated with an IP address/port combination. A
    ROUTE session typically carries one or more media components of
    streaming media e.g., Representations associated with a DASH Media
    Presentation.[¶](#section-1.3-2.10){.pilcrow}
:   

Source Flow:
:   a Transport Session carrying source data. Source Flow is independent
    of the Repair Flow, i.e., the Source Flow [MAY]{.bcp14} be used by a
    ROUTE receiver without the ROUTE Repair
    Flows.[¶](#section-1.3-2.12){.pilcrow}
:   

Repair Flow:
:   a Transport Session carrying repair data for one or more Source
    Flows.[¶](#section-1.3-2.14){.pilcrow}
:   
:::
:::

::: {#sect-1.4}
::: {#section-1.4 .section}
### [1.4.](#section-1.4){.section-number .selfRef} [Architecture and Scope of Specification](#name-architecture-and-scope-of-s){.section-name .selfRef} {#name-architecture-and-scope-of-s}

The scope of the ROUTE protocol is to enable robust and real-time
transport of delivery objects using LCT packets. This architecture is
depicted in [Figure
1](#architecture-diagram){.xref}.[¶](#section-1.4-1){.pilcrow}

The normative aspects of the ROUTE protocol focus on the following
aspects:[¶](#section-1.4-2){.pilcrow}

-   [The format of the LCT packets that carry the transport
    objects.[¶](#section-1.4-3.1){.pilcrow}]{#section-1.4-3.1}
-   [The robust transport of the delivery object using a repair protocol
    based on Forward Error Correction
    (FEC).[¶](#section-1.4-3.2){.pilcrow}]{#section-1.4-3.2}
-   [The definition and possible carriage of object metadata along with
    the delivery objects. Metadata may be conveyed in LCT packets and/or
    separate objects.[¶](#section-1.4-3.3){.pilcrow}]{#section-1.4-3.3}
-   [The ROUTE session, LCT channel, and delivery object description
    provided as service metadata signaling to enable the reception of
    objects.[¶](#section-1.4-3.4){.pilcrow}]{#section-1.4-3.4}
-   [The normative aspects (formats, semantics) of the delivery objects
    conveyed as a content manifest to be delivered along with the
    objects to optimize the performance for specific applications e.g.,
    real-time delivery. The objects and manifest are made available to
    the application through an Application Object cache. The interface
    of this cache to the application is not specified in this document;
    however, it will typically be enabled by the application acting as
    an HTTP client and the cache as the HTTP
    server.[¶](#section-1.4-3.5){.pilcrow}]{#section-1.4-3.5}

[]{#name-architecture-functional-blo}

::: {#architecture-diagram}
::: {#section-1.4-4.1 .alignLeft .art-text .artwork}
                                                 Application Objects
    Application                                  to application
    Objects from                                          ^
    an application    +--------------------------------------------+
         +            |  ROUTE Receiver                   |        |
         |            |                            +------+------+ |
         |            |                            | Application | |
         |            |                            | Object Cache| |
         |            |                            +------+------+ |
         |    LCT over|    +---------------+              ^        |
         v    UDP/IP  |    | Source object |  +---------+ |        |
    +----+---+        | +->+ recovery      +--+  Repair +-+        |
    | ROUTE  |        | |  +---------------+  +----+----+          |
    | Sender +----------+                          ^               |
    +----+---+        | |                          |               |
         |            | |  +---------------+       |               |
         |            | |  | Repair object |       |               |
         |            | +->+ recovery      +-------+               |
         +----------->+    +---------------+                       |
           ROUTE      |                                            |
           Metadata   +--------------------------------------------+
:::

[Figure 1](#figure-1){.selfRef}: [Architecture/Functional Block
Diagram](#name-architecture-functional-blo){.selfRef}
:::
:::
:::

::: {#sect-1.6}
::: {#section-1.5 .section}
### [1.5.](#section-1.5){.section-number .selfRef} [Conventions Used in This Document](#name-conventions-used-in-this-do){.section-name .selfRef} {#name-conventions-used-in-this-do}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.5-1){.pilcrow}
:::
:::
:::
:::

::: {#sect-2}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [ROUTE Packet Format](#name-route-packet-format){.section-name .selfRef} {#name-route-packet-format}

::: {#sect-2.1}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Packet Structure and Header Fields](#name-packet-structure-and-header){.section-name .selfRef} {#name-packet-structure-and-header}

The packet format used by ROUTE Source Flows and Repair Flows follows
the ALC packet format specified in RFC 5775
\[[RFC5775](#RFC5775){.xref}\] with the UDP header followed by the
default LCT header and the source FEC Payload ID followed by the packet
payload. The overall ROUTE packet format is as depicted in [Figure
2](#route-packet-format){.xref}.[¶](#section-2.1-1){.pilcrow}

[]{#name-overall-route-packet-format}

::: {#route-packet-format}
::: {#section-2.1-2.1 .alignLeft .art-text .artwork}
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           UDP Header                          |
    |                                                               |
    +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    |                       Default LCT header                      |
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                         FEC Payload ID                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                          Payload Data                         |
    |                               ...                             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 2](#figure-2){.selfRef}: [Overall ROUTE Packet
Format](#name-overall-route-packet-format){.selfRef}
:::

The Default LCT header is as defined in the LCT building block in RFC
5651 \[[RFC5651](#RFC5651){.xref}\].[¶](#section-2.1-3){.pilcrow}

The LCT packet header fields [SHALL]{.bcp14} be used as defined by the
LCT building block in RFC 5651 \[[RFC5651](#RFC5651){.xref}\]. The
semantics and usage of the following LCT header fields [SHALL]{.bcp14}
be further constrained in ROUTE as follows:[¶](#section-2.1-4){.pilcrow}

[]{.break}

Version number (V):
:   This 4-bit field indicates the protocol version number. The version
    number [SHALL]{.bcp14} be set to \'0001\', as specified in RFC 5651
    \[[RFC5651](#RFC5651){.xref}\].[¶](#section-2.1-5.2){.pilcrow}
:   

Congestion Control flag (C) field:
:   This 2-bit field, as defined in RFC 5651
    \[[RFC5651](#RFC5651){.xref}\], [SHALL]{.bcp14} be set to
    \'00\'.[¶](#section-2.1-5.4){.pilcrow}
:   

Protocol-Specific Indication (PSI):
:   The most significant bit of this 2-bit flag is called the Source
    Packet Indicator (SPI) and indicates whether the current packet is a
    source packet or a FEC repair packet. The SPI [SHALL]{.bcp14} be set
    to \'1\' to indicate a source packet and [SHALL]{.bcp14} bet set to
    \'0\' to indicate a repair packet.[¶](#section-2.1-5.6){.pilcrow}
:   

Transport Session Identifier flag (S):
:   This 1-bit field [SHALL]{.bcp14} be set to \'1\' to indicate a
    32-bit word in the TSI field.[¶](#section-2.1-5.8){.pilcrow}
:   

Transport Object Identifier flag (O):
:   This 2-bit field [SHALL]{.bcp14} be set to \'01\' to indicate the
    number of full 32-bit words in the TOI
    field.[¶](#section-2.1-5.10){.pilcrow}
:   

Half-word flag (H):
:   This 1-bit field [SHALL]{.bcp14} be set to \'0\' to indicate that no
    half-word field sizes are used.[¶](#section-2.1-5.12){.pilcrow}
:   

Codepoint (CP):
:   This 8-bit field is used to indicate the type of the payload that is
    carried by this packet; for ROUTE, it is defined as shown below to
    indicate the type of delivery object carried in the payload of the
    associated ROUTE packet. The remaining unmapped Codepoint values can
    be used by a service using ROUTE. In this case, the Codepoint values
    [SHALL]{.bcp14} follow the semantics specified in the following
    table. \"IS\" stands for Initialization Segment of the media content
    such as the DASH Initialization Segment \[[DASH](#DASH){.xref}\].
    The various modes of operation in the table (File/Entity/Package
    Mode) are specified in [Section 4](#sect-4){.xref}. The table also
    lists a Codepoint value range that is reserved for future
    service-specific uses.[¶](#section-2.1-5.14){.pilcrow}
:   

[]{#name-codepoint-values}

::: {#codepoint-values}
  Codepoint value   Semantics
  ----------------- --------------------------------------------------------
  0                 Reserved (not used)
  1                 Non Real Time (NRT) - File Mode
  2                 NRT - Entity Mode
  3                 NRT - Unsigned Package Mode
  4                 NRT - Signed Package Mode
  5                 New IS, timeline changed
  6                 New IS, timeline continued
  7                 Redundant IS
  8                 Media Segment, File Mode
  9                 Media Segment, Entity Mode
  10                Media Segment, File Mode with CMAF Random Access chunk
  11 - 255          Reserved, service-specific

  : [Table 2](#table-2){.selfRef}: [Codepoint
  Values](#name-codepoint-values){.selfRef}
:::

[]{.break}

Congestion Control Information (CCI):
:   For packets carrying DASH segments, CCI [MAY]{.bcp14} convey the
    32-bit earliest presentation time \[[DASH](#DASH){.xref}\] of the
    DASH segment contained in the ROUTE packet. In this case, this
    information can be used by a ROUTE receiver for fast stream
    acquisition (details in [Section 6.2](#sect-6.2){.xref}). Otherwise,
    this field [SHALL]{.bcp14} be set to
    0.[¶](#section-2.1-7.2){.pilcrow}
:   

Transport Session Identifier (TSI):
:   This 32-bit field identifies the Transport Session in ROUTE. The
    context of the Transport Session is provided by signaling metadata.
    The value TSI = 0 [SHALL]{.bcp14} only be used for service-specific
    signaling.[¶](#section-2.1-7.4){.pilcrow}
:   

Transport Object Identifier (TOI):
:   This 32-bit field [SHALL]{.bcp14} identify the object within this
    session to which the payload of the current packet belongs. The
    mapping of the TOI field to the object is provided by the Extended
    File Delivery Table (FDT).[¶](#section-2.1-7.6){.pilcrow}
:   
:::
:::

::: {#sect-2.2}
::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [LCT Header Extensions](#name-lct-header-extensions){.section-name .selfRef} {#name-lct-header-extensions}

The following LCT header extensions are defined or used by
ROUTE:[¶](#section-2.2-1){.pilcrow}

[]{.break}

EXT_FTI:
:   as specified in RFC 5775.[¶](#section-2.2-2.2){.pilcrow}
:   

EXT_TOL:
:   the length in bytes of the multicast transport object shall be
    signaled using EXT_TOL as specified by ATSC-ROUTE
    \[[ATSCA331](#ATSCA331){.xref}\] with 24 bits or, if required, 48
    bits of Transfer Length. The frequency of using the EXT_TOL header
    extension is determined by channel conditions that may cause the
    loss of the packet carrying the Close Object flag (B)
    \[[RFC5651](#RFC5651){.xref}\].[¶](#section-2.2-2.4){.pilcrow}
:   

:   NOTE: The transport object length can also be determined without the
    use of EXT_TOL by examining the LCT packet with the Close Object
    flag (B). However, if this packet is lost, then the EXT_TOL
    information can be used by the receiver to determine the transport
    object length.[¶](#section-2.2-2.6){.pilcrow}
:   

EXT_TIME Header:
:   as specified in RFC 5651 \[[RFC5651](#RFC5651){.xref}\]. The Sender
    Current Time [SHALL]{.bcp14} be signaled using
    EXT_TIME.[¶](#section-2.2-2.8){.pilcrow}
:   
:::
:::

::: {#sect-2.3}
::: {#section-2.3 .section}
### [2.3.](#section-2.3){.section-number .selfRef} [FEC Payload ID for Source Flows](#name-fec-payload-id-for-source-f){.section-name .selfRef} {#name-fec-payload-id-for-source-f}

The syntax of the FEC Payload ID for the Compact No-Code FEC Scheme used
in ROUTE Source Flows is a 32-bit unsigned integer value that
[SHALL]{.bcp14} express the start_offset as an octet number
corresponding to the first octet of the fragment of the delivery object
carried in this packet. The start_offset value for the first fragment of
any delivery object [SHALL]{.bcp14} be set to 0. [Figure
3](#start_offset){.xref} shows the 32-bit start_offset
field.[¶](#section-2.3-1){.pilcrow}

[]{#name-fec-payload-id-for-source-fl}

::: {#start_offset}
::: {#section-2.3-2.1 .alignLeft .art-text .artwork}
         0                   1                   2                   3
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |                         start_offset                          |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:::

[Figure 3](#figure-3){.selfRef}: [FEC Payload ID for Source
Flows](#name-fec-payload-id-for-source-fl){.selfRef}
:::
:::
:::

::: {#sect-2.4}
::: {#section-2.4 .section}
### [2.4.](#section-2.4){.section-number .selfRef} [FEC Payload ID for Repair Flows](#name-fec-payload-id-for-repair-f){.section-name .selfRef} {#name-fec-payload-id-for-repair-f}

FEC Payload ID for Repair Flows is specified in RFC 6330
\[[RFC6330](#RFC6330){.xref}\].[¶](#section-2.4-1){.pilcrow}
:::
:::
:::
:::

::: {#sect-3}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Session Metadata](#name-session-metadata){.section-name .selfRef} {#name-session-metadata}

The required session metadata for Source and Repair Flows is specified
in the following sections. The list specified here is not exhaustive; a
service [MAY]{.bcp14} signal more metadata to meet its needs. The data
format is also not specified beyond its cardinality; the exact format of
specifying the data is left for the service, e.g., by using XML encoding
format, as has been done by \[[DVBMABR](#DVBMABR){.xref}\] and
\[[ATSCA331](#ATSCA331){.xref}\]. It is specified in the following if an
attribute is mandatory (m), conditional mandatory (cm) or optional (o)
to realize a basic ROUTE session. A mandatory field [SHALL]{.bcp14}
always be present in the session metadata, and a conditional mandatory
field [SHALL]{.bcp14} be present if the specified condition is true. The
delivery of the session metadata to the ROUTE receiver is beyond the
scope of this document.[¶](#section-3-1){.pilcrow}

::: {#sect-3.1}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Generic Metadata](#name-generic-metadata){.section-name .selfRef} {#name-generic-metadata}

Generic metadata is applicable to both Source and Repair Flows as
follows. Before a receiver can join a ROUTE session, the receiver needs
to obtain this generic metadata that contains at least the following
information:[¶](#section-3.1-1){.pilcrow}

[]{.break}

ROUTE version number (m):
:   the version number of ROUTE used in this session. The version number
    conforming to this document [SHALL]{.bcp14} be
    1.[¶](#section-3.1-2.2){.pilcrow}
:   

Connection ID (m):
:   the unique identifier of a Connection, usually consisting of the
    following 4-tuple: source IP address/source port number, destination
    IP address/destination port number. The IP addresses can be IPv4 or
    IPv6 addresses depending upon which IP version is used by the
    deployment.[¶](#section-3.1-2.4){.pilcrow}
:   
:::
:::

::: {#sect-3.2}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Session Metadata for Source Flows](#name-session-metadata-for-source){.section-name .selfRef} {#name-session-metadata-for-source}

stsi (m): The LCT TSI value corresponding to the Transport Session for
the Source Flow.[¶](#section-3.2-1){.pilcrow}

[]{.break}

rt (o):
:   A Boolean flag that [SHALL]{.bcp14} indicate whether the content
    component carried by this Source Flow corresponds to real-time
    streaming media or non-real-time content. When set to \"true\", it
    [SHALL]{.bcp14} be an indication of real-time content, and when
    absent or set to \"false\", it [SHALL]{.bcp14} be an indication of
    non-real-time (NRT) content.[¶](#section-3.2-2.2){.pilcrow}
:   

minBufferSize (o):
:   A 32-bit unsigned integer that [SHALL]{.bcp14} represent, in
    kilobytes, the minimum required storage size of the receiver
    transport buffer for the parent LCT channel of this Source Flow. The
    buffer holds the data belonging to a source object until its
    complete reception. This attribute is only applicable when rt =
    \"true\".[¶](#section-3.2-2.4){.pilcrow}
:   

:   A service that chooses not to signal this attribute relies on the
    receiver implementation, which must discard the received data beyond
    its buffering capability. Such discarding of data will impact the
    service quality.[¶](#section-3.2-2.6){.pilcrow}
:   

EFDT (cm):
:   When present, [SHALL]{.bcp14} contain a single instance of an
    FDT-Instance element per RFC 6726 FLUTE
    \[[RFC6726](#RFC6726){.xref}\], which [MAY]{.bcp14} contain the
    optional FDT extensions as defined in [Section
    4.1](#sect-4.1){.xref}. The optional EFDT element [MAY]{.bcp14} only
    be present for File Mode of delivery. In File Mode, it
    [SHALL]{.bcp14} be present if this Source Flow transports streaming
    media segments.[¶](#section-3.2-2.8){.pilcrow}
:   

contentType (o):
:   A string that [SHALL]{.bcp14} represent the media type for the media
    content. It [SHALL]{.bcp14} obey the semantics of the Content-Type
    header as specified by the HTTP/1.1 protocol in RFC 7231
    \[[RFC7231](#RFC7231){.xref}\]. This document does not define any
    new contentType strings. In its absence, the signaling of media type
    for the media content is beyond the scope of this
    document.[¶](#section-3.2-2.10){.pilcrow}
:   

applicationMapping (m):
:   A set of identifiers that provide an application-specific mapping of
    the received Application Objects to the Source Flows. For example,
    for DASH, this would provide the mapping of a Source Flow to a
    specific DASH Representation from a Media Presentation Description
    (MPD), the latter identified by its Representation and corresponding
    Adaptation Set and Period IDs.[¶](#section-3.2-2.12){.pilcrow}
:   
:::
:::

::: {#sect-3.3}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Session Metadata for Repair Flows](#name-session-metadata-for-repair){.section-name .selfRef} {#name-session-metadata-for-repair}

[]{.break}

minBuffSize (o):

:   A 32-bit unsigned integer whose value [SHALL]{.bcp14} represent a
    required size of the receiver transport buffer for AL‑FEC decoding
    processing. When present, this attribute [SHALL]{.bcp14} indicate
    the minimum buffer size that is required to handle all associated
    objects that are assigned to a super-object, i.e., a delivery object
    formed by the concatenation of multiple FEC transport objects in
    order to bundle these FEC transport objects for AL-FEC
    protection.[¶](#section-3.3-1.2.1){.pilcrow}

    A service that chooses not to signal this attribute relies on the
    receiver implementation, which must discard the received repair data
    beyond its buffering capability. Such discarding of data will impact
    the service quality.[¶](#section-3.3-1.2.2){.pilcrow}

:   

fecOTI (m):
:   A parameter consisting of the concatenation of Common and
    Scheme-Specific FEC Object Transmission Information (FEC OTI) as
    defined in Sections
    [3.3.2](https://www.rfc-editor.org/rfc/rfc6330#section-3.3.2){.relref}
    and
    [3.3.3](https://www.rfc-editor.org/rfc/rfc6330#section-3.3.3){.relref}
    of \[[RFC6330](#RFC6330){.xref}\] and that corresponds to the
    delivery objects carried in the Source Flow to which this Repair
    Flow is associated, with the following qualification: the 40-bit
    Transfer Length (F) field may either represent the actual size of
    the object, or it is encoded as all zeroes. In the latter case, the
    FEC transport object size either is unknown or cannot be represented
    by this attribute. In other words, for the all-zeroes format, the
    delivery objects in the Source Flow correspond to streaming content,
    either a live Service whereby content encoding has not yet occurred
    at the time this session data was generated or pre-recorded
    streaming content whose delivery object sizes, albeit known at the
    time of session data generation, are variable and cannot be
    represented as a single value by the fecOTI
    attribute.[¶](#section-3.3-1.4){.pilcrow}
:   

ptsi (m):
:   TSI value(s) of each Source Flow protected by this Repair
    Flow.[¶](#section-3.3-1.6){.pilcrow}
:   

mappingTOIx (o):
:   Values of the constant X for use in deriving the TOI of the delivery
    object of each protected Source Flow from the TOI of the FEC
    (super-)object. The default value is \"1\". Multiple mappingTOIx
    values [MAY]{.bcp14} be provided for each protected Source Flow
    depending upon the usage of FEC
    (super-)object.[¶](#section-3.3-1.8){.pilcrow}
:   

mappingTOIy (o):
:   The corresponding constant Y to each mappingTOIx, when present, for
    use in deriving the parent SourceTOI value from the above equation.
    The default value is \"0\".[¶](#section-3.3-1.10){.pilcrow}
:   
:::
:::
:::
:::

::: {#sect-4}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Delivery Object Mode](#name-delivery-object-mode){.section-name .selfRef} {#name-delivery-object-mode}

ROUTE provides several different delivery object modes, and one of these
modes may suit the application needs better for a given Transport
Session. A delivery object is self contained for the application,
typically associated with certain properties, metadata, and
timing-related information relevant to the application. The signaling of
the delivery object mode is done on an object basis using Codepoint as
specified in [Section 2.1](#sect-2.1){.xref}.[¶](#section-4-1){.pilcrow}

::: {#sect-4.1}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [File Mode](#name-file-mode){.section-name .selfRef} {#name-file-mode}

File Mode uses an out-of-band Extended FDT (EFDT) signaling for recovery
of delivery objects with the following extensions and
considerations.[¶](#section-4.1-1){.pilcrow}

::: {#sect-4.1.1}
::: {#section-4.1.1 .section}
#### [4.1.1.](#section-4.1.1){.section-number .selfRef} [Extensions to FDT](#name-extensions-to-fdt){.section-name .selfRef} {#name-extensions-to-fdt}

The following extensions are specified to FDT, as specified in RFC 6726
\[[RFC6726](#RFC6726){.xref}\]. An Extended FDT-Instance is an instance
of FLUTE FDT, as specified in \[[RFC6726](#RFC6726){.xref}\], plus
optionally one or more of the following
extensions:[¶](#section-4.1.1-1){.pilcrow}

[]{.break}

efdtVersion:
:   A value that [SHALL]{.bcp14} represent the version of this Extended
    FDT-Instance.[¶](#section-4.1.1-2.2){.pilcrow}
:   

maxExpiresDelta:
:   Let \"tp\" represent the wall clock time at the receiver when the
    receiver acquires the first ROUTE packet carrying data of the object
    described by this Extended FDT-Instance. maxExpiresDelta, when
    present, [SHALL]{.bcp14} represent a time interval that when added
    to \"tp\" [SHALL]{.bcp14} represent the expiration time of the
    associated Extended FDT-Instance \"te\". The time interval is
    expressed in number of seconds. When maxExpiresDelta is not present,
    the expiration time of the Extended FDT-Instance [SHALL]{.bcp14} be
    given by the sum of a) the value of the ERT field in the EXT_TIME
    LCT header extension in the first ROUTE packet carrying data of that
    file, and b) the current receiver time when parsing the packet
    header of that ROUTE packet. See Sections [5.4](#sect-5.4){.xref}
    and [6.3.3](#sect-6.3.3){.xref} on additional rules for deriving the
    Extended FDT-Instance expiration time. Hence,
    `te = tp + maxExpiresDelta`[¶](#section-4.1.1-2.4){.pilcrow}
:   

maxTransportSize:
:   An attribute that [SHALL]{.bcp14} represent the maximum transport
    size in bytes of any delivery object described by this Extended
    FDT-Instance. This attribute [SHALL]{.bcp14} be present if a) the
    fileTemplate is present in Extended FDT-Instance, or b) one or more
    File elements, if present in this Extended FDT-Instance, do not
    include the Transfer-Length attribute. When maxTransportSize is not
    present, the maximum transport size is not signaled, while other
    signaling such as the Transfer-Length attribute signal the exact
    Transfer Length of the object.[¶](#section-4.1.1-2.6){.pilcrow}
:   

fileTemplate:
:   A string value, which when present and in conjunction with parameter
    substitution, is used in deriving the Content-Location attribute for
    the delivery object described by this Extended FDT-Instance. It
    [SHALL]{.bcp14} include the \"\$TOI\$\" identifier. Each identifier
    [MAY]{.bcp14} be suffixed as needed by specific file names within
    the enclosing \'\$\' characters following this prototype:
    `%0[width]d`[¶](#section-4.1.1-2.8){.pilcrow}
:   

The width parameter is an unsigned integer that provides the minimum
number of characters to be printed. If the value to be printed is
shorter than this number, the result [SHALL]{.bcp14} be padded with
leading zeroes. The value is not truncated even if the result is larger.
When no format tag is present, a default format tag with width=1
[SHALL]{.bcp14} be used.[¶](#section-4.1.1-3){.pilcrow}

Strings other than identifiers [SHALL]{.bcp14} only contain characters
that are permitted within URIs according to RFC 3986
\[[RFC3986](#RFC3986){.xref}\].[¶](#section-4.1.1-4){.pilcrow}

`$$` is an escape sequence in fileTemplate value, i.e., \"\$\$\" is
non-recursively replaced with a single
\"\$\".[¶](#section-4.1.1-5){.pilcrow}

The usage of fileTemplate is described in Sender and Receiver operations
in Sections [5.4](#sect-5.4){.xref} and [6.3](#sect-6.3){.xref},
respectively.[¶](#section-4.1.1-6){.pilcrow}
:::
:::

::: {#sect-4.1.2}
::: {#section-4.1.2 .section}
#### [4.1.2.](#section-4.1.2){.section-number .selfRef} [Constraints on Extended FDT](#name-constraints-on-extended-fdt){.section-name .selfRef} {#name-constraints-on-extended-fdt}

The Extended FDT-Instance [SHALL]{.bcp14} conform to an FDT-Instance
according to RFC 6726 \[[RFC6726](#RFC6726){.xref}\] with the following
constraints: at least one File element and the \@Expires attribute
[SHALL]{.bcp14} be present.[¶](#section-4.1.2-1){.pilcrow}

Content encoding [MAY]{.bcp14} be used for delivery of any file
described by an FDT-Instance.File element in the Extended FDT-Instance.
The content encoding defined in the present document is gzip
\[[RFC1952](#RFC1952){.xref}\]. When content encoding is used, the
File\@Content-Encoding and File\@Content-Length attributes
[SHALL]{.bcp14} be present in the Extended
FDT-Instance.[¶](#section-4.1.2-2){.pilcrow}
:::
:::
:::
:::

::: {#sect-4.2}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Entity Mode](#name-entity-mode){.section-name .selfRef} {#name-entity-mode}

For Entity Mode, the following applies:[¶](#section-4.2-1){.pilcrow}

-   [Delivery object metadata [SHALL]{.bcp14} be expressed in the form
    of entity headers as defined in HTTP/1.1, which correspond to one or
    more of the representation header fields, payload header fields, and
    response header fields as defined in Sections
    [3.1](https://www.rfc-editor.org/rfc/rfc7231#section-3.1){.relref},
    [3.3](https://www.rfc-editor.org/rfc/rfc7231#section-3.3){.relref},
    and [7](https://www.rfc-editor.org/rfc/rfc7231#section-7){.relref},
    respectively, of
    \[[RFC7231](#RFC7231){.xref}\].[¶](#section-4.2-2.1){.pilcrow}]{#section-4.2-2.1}

-   [The entity headers sent along with the delivery object provide all
    information about that multicast transport
    object.[¶](#section-4.2-2.2){.pilcrow}]{#section-4.2-2.2}

-   ::: {#section-4.2-2.3}
    Sending a media object (if the object is chunked) in Entity Mode may
    result in one of the following
    options:[¶](#section-4.2-2.3.1){.pilcrow}

    -   ::: {#section-4.2-2.3.2.1}
        If the length of the chunked object is known at the sender, the
        ROUTE Entity Mode delivery object [MAY]{.bcp14} be sent without
        using HTTP/1.1 chunked transfer coding, i.e., the object starts
        with an HTTP header containing the Content Length field followed
        by the concatenation of CMAF
        Chunks:[¶](#section-4.2-2.3.2.1.1){.pilcrow}

        ::: {#section-4.2-2.3.2.1.2 .alignLeft .art-text .artwork}
            |HTTP Header+Length||---chunk ----||---chunk ----||---chunk --
            --||---chunk ----|

        [¶](#section-4.2-2.3.2.1.2){.pilcrow}
        :::
        :::

    -   ::: {#section-4.2-2.3.2.2}
        If the length of the chunked object is unknown at the sender
        when starting to send the object, HTTP/1.1 chunked transfer
        coding format [SHALL]{.bcp14} be
        used:[¶](#section-4.2-2.3.2.2.1){.pilcrow}

        ::: {#section-4.2-2.3.2.2.2 .alignLeft .art-text .artwork}
            |HTTP Header||Separator+Length||---chunk ----
            ||Separator+Length||---chunk ----||Separator+Length||---chunk
            ----||Separator+Length||---chunk ----||Separator+Length=0|

        [¶](#section-4.2-2.3.2.2.2){.pilcrow}
        :::

        Note, however, that it is not required to send a CMAF Chunk in
        exactly one HTTP chunk.[¶](#section-4.2-2.3.2.2.3){.pilcrow}
        :::
    :::
:::
:::

::: {#sect-4.3}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Unsigned Package Mode](#name-unsigned-package-mode){.section-name .selfRef} {#name-unsigned-package-mode}

In this delivery mode, the delivery object consists of a group of files
that are packaged for delivery only. If applied, the client is expected
to unpack the package and provide each file as an independent object to
the application. Packaging is supported by Multipart Multipurpose
Internet Mail Extensions (MIME) \[[RFC2557](#RFC2557){.xref}\], where
objects are packaged into one document for transport, with Content-Type
set to multipart/related. When binary files are included in the package,
Content-Transfer-Encoding of \"binary\" should be used for those
files.[¶](#section-4.3-1){.pilcrow}
:::
:::

::: {#sect-4.4}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Signed Package Mode](#name-signed-package-mode){.section-name .selfRef} {#name-signed-package-mode}

In Signed Package Mode delivery, the delivery object consists of a group
of files that are packaged for delivery, and the package includes one or
more signatures for validation. Signed packaging is supported by RFC
8551 Secure MIME (S/MIME) \[[RFC8551](#RFC8551){.xref}\], where objects
are packaged into one document for transport and the package includes
objects necessary for validation of the
package.[¶](#section-4.4-1){.pilcrow}
:::
:::
:::
:::

::: {#sect-5}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Sender Operation](#name-sender-operation){.section-name .selfRef} {#name-sender-operation}

::: {#sect-5.1}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Usage of ALC and LCT for Source Flow](#name-usage-of-alc-and-lct-for-so){.section-name .selfRef} {#name-usage-of-alc-and-lct-for-so}

ROUTE Source Flow carries the source data as specified in RFC 5775
\[[RFC5775](#RFC5775){.xref}\]. There are several special considerations
that ROUTE introduces to the usage of the LCT building block as outlined
in the following:[¶](#section-5.1-1){.pilcrow}

-   [ROUTE limits the usage of the LCT building block to a single
    channel per session. Congestion control is thus sender driven in
    ROUTE. It also signifies that there is no specific
    congestion-control-related signaling from the sender to the
    receiver; the CCI field is either set to 0 or used for other
    purposes as specified in [Section 2.1](#sect-2.1){.xref}. The
    functionality of receiver-driven layered multicast may still be
    offered by the application, allowing the receiver application to
    select the appropriate delivery session based on the bandwidth
    requirement of that
    session.[¶](#section-5.1-2.1){.pilcrow}]{#section-5.1-2.1}

Further, the following details apply to
LCT:[¶](#section-5.1-3){.pilcrow}

-   ::: {#section-5.1-4.1}
    The Layered Coding Transport (LCT) Building Block as defined in RFC
    5651 \[[RFC5651](#RFC5651){.xref}\] is used with the following
    constraints:[¶](#section-5.1-4.1.1){.pilcrow}

    -   [The TSI in the LCT header [SHALL]{.bcp14} be set equal to the
        value of the stsi attribute in [Section
        3.2](#sect-3.2){.xref}.[¶](#section-5.1-4.1.2.1){.pilcrow}]{#section-5.1-4.1.2.1}

    -   [The Codepoint (CP) in the LCT header [SHALL]{.bcp14} be used to
        signal the applied formatting as defined in the signaling
        metadata.[¶](#section-5.1-4.1.2.2){.pilcrow}]{#section-5.1-4.1.2.2}

    -   ::: {#section-5.1-4.1.2.3}
        In accordance with ALC, a source FEC Payload ID header is used
        to identify, for FEC purposes, the encoding symbols of the
        delivery object, or a portion thereof, carried by the associated
        ROUTE packet. This information may be sent in several
        ways:[¶](#section-5.1-4.1.2.3.1){.pilcrow}

        -   ::: {#section-5.1-4.1.2.3.2.1}
            As a simple new null FEC scheme with the following
            usage:[¶](#section-5.1-4.1.2.3.2.1.1){.pilcrow}

            -   [The value of the source FEC Payload ID header
                [SHALL]{.bcp14} be set to 0 in case the ROUTE packet
                contains the entire delivery object,
                or[¶](#section-5.1-4.1.2.3.2.1.2.1){.pilcrow}]{#section-5.1-4.1.2.3.2.1.2.1}
            -   [The value of the source FEC Payload ID header
                [SHALL]{.bcp14} be set as a direct address (start
                offset) corresponding to the starting byte position of
                the portion of the object carried in this packet using a
                32-bit
                field.[¶](#section-5.1-4.1.2.3.2.1.2.2){.pilcrow}]{#section-5.1-4.1.2.3.2.1.2.2}
            :::

        -   [In a compatible manner to RFC 6330
            \[[RFC6330](#RFC6330){.xref}\] where the SBN and ESI defines
            the start offset together with the symbol size
            T.[¶](#section-5.1-4.1.2.3.2.2){.pilcrow}]{#section-5.1-4.1.2.3.2.2}

        -   [The signaling metadata provides the appropriate parameters
            to indicate any of the above modes using the srcFecPayloadId
            attribute.[¶](#section-5.1-4.1.2.3.2.3){.pilcrow}]{#section-5.1-4.1.2.3.2.3}
        :::
    :::

-   ::: {#section-5.1-4.2}
    The LCT Header EXT_TIME extension as defined in RFC 5651
    \[[RFC5651](#RFC5651){.xref}\] [MAY]{.bcp14} be used by the sender
    in the following manner:[¶](#section-5.1-4.2.1){.pilcrow}

    -   [The Sender Current Time (SCT), depending on the application,
        [MAY]{.bcp14} be used to occasionally or frequently signal the
        sender current time possibly for reliever time
        synchronization.[¶](#section-5.1-4.2.2.1){.pilcrow}]{#section-5.1-4.2.2.1}
    -   [The Expected Residual Time (ERT) [MAY]{.bcp14} be used to
        indicate the expected remaining time for transmission of the
        current object in order to optimize detection of a lost delivery
        object.[¶](#section-5.1-4.2.2.2){.pilcrow}]{#section-5.1-4.2.2.2}
    -   [The Sender Last Changed (SLC) flag is typically not utilized
        but [MAY]{.bcp14} be used to indicate the addition/removal of
        Segments.[¶](#section-5.1-4.2.2.3){.pilcrow}]{#section-5.1-4.2.2.3}
    :::

Additional extension headers [MAY]{.bcp14} be used to support real-time
delivery. Such extension headers are defined in [Section
2.1](#sect-2.1){.xref}.[¶](#section-5.1-5){.pilcrow}
:::
:::

::: {#sect-5.2}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [ROUTE Packetization for Source Flow](#name-route-packetization-for-sou){.section-name .selfRef} {#name-route-packetization-for-sou}

The following description of the ROUTE sender operation on the mapping
of the Application Object to the ROUTE packet payloads logically
represents an extension of RFC 5445 \[[RFC5445](#RFC5445){.xref}\],
which in turn inherits the context, language, declarations, and
restrictions of the FEC building block in RFC 5052
\[[RFC5052](#RFC5052){.xref}\].[¶](#section-5.2-1){.pilcrow}

The data carried in the payload of a given ROUTE packet constitutes a
contiguous portion of the Application Object. ROUTE source delivery can
be considered as a special case of the use of the Compact No-Code Scheme
associated with FEC Encoding ID = 0 according to Sections
[3.4.1](https://www.rfc-editor.org/rfc/rfc5445#section-3.4.1){.relref}
and
[3.4.2](https://www.rfc-editor.org/rfc/rfc5445#section-3.4.2){.relref}
of \[[RFC5445](#RFC5445){.xref}\], in which the encoding symbol size is
exactly one byte. As specified in [Section 2.1](#sect-2.1){.xref}, for
ROUTE Source Flows, the FEC Payload ID [SHALL]{.bcp14} deliver the
32-bit start_offset. All receivers are expected to support, at minimum,
operation with this special case of the Compact No-Code
FEC.[¶](#section-5.2-2){.pilcrow}

Note that in the event the source object size is greater than 2^32^
bytes (approximately 4.3 GB), the applications (in the broadcaster
server and the receiver) are expected to perform segmentation/reassembly
using methods beyond the scope of this
document.[¶](#section-5.2-3){.pilcrow}

Finally, in some special cases, a ROUTE sender [MAY]{.bcp14} need to
produce ROUTE packets that do not contain any payload. This may be
required, for example, to signal the end of a session. These dataless
packets do not contain FEC Payload ID or payload data, but only the LCT
header fields. The total datagram length, conveyed by outer protocol
headers (e.g., the IP or UDP header), enables receivers to detect the
absence of the LCT header, FEC Payload ID, and payload
data.[¶](#section-5.2-4){.pilcrow}

::: {#sect-5.2.1}
::: {#section-5.2.1 .section}
#### [5.2.1.](#section-5.2.1){.section-number .selfRef} [Basic ROUTE Packetization](#name-basic-route-packetization){.section-name .selfRef} {#name-basic-route-packetization}

In the basic operation, it is assumed that the Application Object is
fully available at the ROUTE sender.[¶](#section-5.2.1-1){.pilcrow}

1.  [The amount of data to be sent in a single ROUTE packet is limited
    by the maximum transfer unit of the data packets or the size of the
    remaining data of the Application Object being sent, whichever is
    smaller. The transfer unit is determined either by knowledge of
    underlying transport block sizes or by other
    constraints.[¶](#section-5.2.1-2.1){.pilcrow}]{#section-5.2.1-2.1}
2.  [The start_offset field in the LCT header of the ROUTE packet
    indicates the byte offset of the carried data in the Application
    Object being
    sent.[¶](#section-5.2.1-2.2){.pilcrow}]{#section-5.2.1-2.2}
3.  [The Close Object flag (B) is set to 1 if this is the last ROUTE
    packet carrying the data of the Application
    Object.[¶](#section-5.2.1-2.3){.pilcrow}]{#section-5.2.1-2.3}

The order of packet delivery is arbitrary, but in the absence of other
constraints, delivery with increasing start_offset value is
recommended.[¶](#section-5.2.1-3){.pilcrow}
:::
:::

::: {#sect-5.2.2}
::: {#section-5.2.2 .section}
#### [5.2.2.](#section-5.2.2){.section-number .selfRef} [ROUTE Packetization for CMAF Chunked Content](#name-route-packetization-for-cma){.section-name .selfRef} {#name-route-packetization-for-cma}

The following additional guidelines should be followed for ROUTE
packetization of CMAF Chunked Content in addition to the guidelines of
[Section 5.2.1](#sect-5.2.1){.xref}:[¶](#section-5.2.2-1){.pilcrow}

1.  [If it is the first ROUTE packet carrying a CMAF Random Access
    chunk, except for the first CMAF Chunk in the segment, the Codepoint
    value [MAY]{.bcp14} be set to 10, as specified in the Codepoint
    value table in [Section 2.1](#sect-2.1){.xref}. The receiver
    [MAY]{.bcp14} use this information for optimization of random
    access.[¶](#section-5.2.2-2.1){.pilcrow}]{#section-5.2.2-2.1}
2.  [As soon as the total length of the media object is known,
    potentially with the packaging of the last CMAF Chunk of a segment,
    the EXT_TOL extension header [MAY]{.bcp14} be added to the LCT
    header to signal the Transfer Length, so that the receiver may know
    this information in a timely
    fashion.[¶](#section-5.2.2-2.2){.pilcrow}]{#section-5.2.2-2.2}
:::
:::
:::
:::

::: {#sect-5.3}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Timing of Packet Emission](#name-timing-of-packet-emission){.section-name .selfRef} {#name-timing-of-packet-emission}

The sender [SHALL]{.bcp14} use the timing information provided by the
application to time the emission of packets for a timely reception. This
information may be contained in the Application Objects e.g., DASH
segments and/or the presentation manifest. Hence, such packets of
streaming media with real-time constraints [SHALL]{.bcp14} be sent in
such a way as to enable their timely reception with respect to the
presentation timeline.[¶](#section-5.3-1){.pilcrow}
:::
:::

::: {#sect-5.4}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [Extended FDT Encoding for File Mode Sending](#name-extended-fdt-encoding-for-f){.section-name .selfRef} {#name-extended-fdt-encoding-for-f}

For File Mode sending:[¶](#section-5.4-1){.pilcrow}

-   [The TOI field in the ROUTE packet header [SHALL]{.bcp14} be set
    such that Content-Location can be derived at the receiver according
    to File Template substitution specified in [Section
    6.3.1](#sect-6.3.1){.xref}.[¶](#section-5.4-2.1){.pilcrow}]{#section-5.4-2.1}
-   [After sending the first packet with a given TOI value, none of the
    packets pertaining to this TOI [SHALL]{.bcp14} be sent later than
    the wall clock time as derived from maxExpiresDelta. The EXT_TIME
    header with Expected Residual Time (ERT) [MAY]{.bcp14} be used in
    order to convey more accurate expiry
    time.[¶](#section-5.4-2.2){.pilcrow}]{#section-5.4-2.2}
:::
:::

::: {#sect-5.5}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [FEC Framework Considerations](#name-fec-framework-consideration){.section-name .selfRef} {#name-fec-framework-consideration}

The FEC framework uses concepts of the FECFRAME work as defined in RFC
6363 \[[RFC6363](#RFC6363){.xref}\], as well as the FEC building block,
RFC 5052 \[[RFC5052](#RFC5052){.xref}\], which is adopted in the
existing FLUTE/ALC/LCT specifications.[¶](#section-5.5-1){.pilcrow}

The FEC design adheres to the following
principles:[¶](#section-5.5-2){.pilcrow}

-   [FEC-related information is provided only where
    needed.[¶](#section-5.5-3.1){.pilcrow}]{#section-5.5-3.1}
-   [Receivers not capable of this framework can ignore repair
    packets.[¶](#section-5.5-3.2){.pilcrow}]{#section-5.5-3.2}
-   [The FEC is symbol based with fixed symbol size per protected Source
    Flow. The ALC protocol and existing FEC schemes are
    reused.[¶](#section-5.5-3.3){.pilcrow}]{#section-5.5-3.3}
-   [A FEC Repair Flow provides protection of delivery objects from one
    or more Source
    Flows.[¶](#section-5.5-3.4){.pilcrow}]{#section-5.5-3.4}

The FEC-specific components of the FEC framework
are:[¶](#section-5.5-4){.pilcrow}

-   [FEC Repair Flow declaration including all FEC-specific
    information.[¶](#section-5.5-5.1){.pilcrow}]{#section-5.5-5.1}
-   [A FEC transport object that is the concatenation of a delivery
    object, padding octets, and size information in order to form a
    chunk of data that has a size in symbols of N, where N >=
    1.[¶](#section-5.5-5.2){.pilcrow}]{#section-5.5-5.2}
-   [A FEC super-object that is the concatenation of one or more FEC
    transport objects in order to bundle FEC transport objects for FEC
    protection.[¶](#section-5.5-5.3){.pilcrow}]{#section-5.5-5.3}
-   [A FEC protocol and packet
    structure.[¶](#section-5.5-5.4){.pilcrow}]{#section-5.5-5.4}

A receiver needs to be able to recover delivery objects from repair
packets based on available FEC information.[¶](#section-5.5-6){.pilcrow}
:::
:::

::: {#sect-5.6}
::: {#section-5.6 .section}
### [5.6.](#section-5.6){.section-number .selfRef} [FEC Transport Object Construction](#name-fec-transport-object-constr){.section-name .selfRef} {#name-fec-transport-object-constr}

In order to identify a delivery object in the context of the repair
protocol, the following information is
needed:[¶](#section-5.6-1){.pilcrow}

-   [TSI and TOI of the delivery object. In this case, the FEC object
    corresponds to the (entire) delivery
    object.[¶](#section-5.6-2.1){.pilcrow}]{#section-5.6-2.1}
-   [Octet range of the delivery object, i.e., start offset within the
    delivery object and number of subsequent and contiguous octets of
    delivery object that constitutes the FEC object (i.e., the
    FEC-protected portion of the source object). In this case, the FEC
    object corresponds to a contiguous byte range portion of the
    delivery object.[¶](#section-5.6-2.2){.pilcrow}]{#section-5.6-2.2}

Typically, for real-time object delivery with smaller delivery object
sizes, the first mapping is applied, i.e., the delivery object is a FEC
object.[¶](#section-5.6-3){.pilcrow}

Assuming that the FEC object is the delivery object, for each delivery
object, the associated FEC transport object is comprised of the
concatenation of the delivery object, padding octets (P), and the FEC
object size (F) in octets, where F is carried in a 4-octet
field.[¶](#section-5.6-4){.pilcrow}

The FEC transport object size S, in FEC encoding symbols,
[SHALL]{.bcp14} be an integer multiple of the symbol size Y. S is
determined from the session information and/or the repair packet
headers.[¶](#section-5.6-5){.pilcrow}

F is carried in the last 4 octets of the FEC transport object.
Specifically, let:[¶](#section-5.6-6){.pilcrow}

-   [F be the size of the delivery object in
    octets,[¶](#section-5.6-7.1){.pilcrow}]{#section-5.6-7.1}
-   [F\' be the F octets of data of the delivery
    object,[¶](#section-5.6-7.2){.pilcrow}]{#section-5.6-7.2}
-   [f\' denote the four octets of data carrying the value of F in
    network octet order (high-order octet
    first),[¶](#section-5.6-7.3){.pilcrow}]{#section-5.6-7.3}
-   [S be the size of the FEC transport object with S=ceil((F+4)/Y),
    where the ceil() function rounds the result upward to its nearest
    integer,[¶](#section-5.6-7.4){.pilcrow}]{#section-5.6-7.4}
-   [P\' be S\*Y-4-F octets of data, i.e., padding placed between the
    delivery object and the 4-byte field conveying the value of F and
    located at the end of the FEC transport object,
    and[¶](#section-5.6-7.5){.pilcrow}]{#section-5.6-7.5}
-   [O\' be the concatenation of F\', P\', and
    f\'.[¶](#section-5.6-7.6){.pilcrow}]{#section-5.6-7.6}

O\' then constitutes the FEC transport object of size S\*Y octets. Note
that padding octets and the object size F are not sent in source packets
of the delivery object but are only part of a FEC transport object that
FEC decoding recovers in order to extract the FEC object and thus the
delivery object or portion of the delivery object that constitutes the
FEC object. In the above context, the FEC transport object size in
symbols is S.[¶](#section-5.6-8){.pilcrow}

The general information about a FEC transport object that is conveyed to
a FEC-enabled receiver is the source TSI, source TOI, and the associated
octet range within the delivery object comprising the associated FEC
object. However, as the size in octets of the FEC object is provided in
the appended field within the FEC transport object, the remaining
information can be conveyed as:[¶](#section-5.6-9){.pilcrow}

-   [The TSI and TOI of the delivery object from which the FEC object
    associated with the FEC transport object is
    generated[¶](#section-5.6-10.1){.pilcrow}]{#section-5.6-10.1}
-   [The start octet within the delivery object for the associated FEC
    object[¶](#section-5.6-10.2){.pilcrow}]{#section-5.6-10.2}
-   [The size in symbols of the FEC transport object,
    S[¶](#section-5.6-10.3){.pilcrow}]{#section-5.6-10.3}
:::
:::

::: {#sect-5.7}
::: {#section-5.7 .section}
### [5.7.](#section-5.7){.section-number .selfRef} [Super-Object Construction](#name-super-object-construction){.section-name .selfRef} {#name-super-object-construction}

From the FEC Repair Flow declaration, the construction of a FEC
super-object as the concatenation of one or more FEC transport objects
can be determined. The FEC super-object includes the general information
about the FEC transport objects as described in the previous sections,
as well as the placement order of FEC transport objects within the FEC
super-object.[¶](#section-5.7-1){.pilcrow}

Let:[¶](#section-5.7-2){.pilcrow}

-   [N be the total number of FEC transport objects for the FEC
    super-object
    construction.[¶](#section-5.7-3.1){.pilcrow}]{#section-5.7-3.1}
-   [For i = 0, \..., N-1, let S\[i\] be the size in symbols of FEC
    transport object
    i.[¶](#section-5.7-3.2){.pilcrow}]{#section-5.7-3.2}
-   [B\' be the FEC super-object that is the concatenation of the FEC
    transport objects in numerical order, comprised of K = Sum of N
    source symbols, each symbol denoted as
    S\[i\].[¶](#section-5.7-3.3){.pilcrow}]{#section-5.7-3.3}

For each FEC super-object, the remaining general information that needs
to be conveyed to a FEC-enabled receiver, beyond what is already carried
in the FEC transport objects that constitute the FEC super-object,
comprises:[¶](#section-5.7-4){.pilcrow}

-   [The total number of FEC transport objects
    N.[¶](#section-5.7-5.1){.pilcrow}]{#section-5.7-5.1}

-   ::: {#section-5.7-5.2}
    For each FEC transport object:[¶](#section-5.7-5.2.1){.pilcrow}

    -   [The TSI and TOI of the delivery object from which the FEC
        object associated with the FEC transport object is
        generated,[¶](#section-5.7-5.2.2.1){.pilcrow}]{#section-5.7-5.2.2.1}
    -   [The start octet within the delivery object for the associated
        FEC object,
        and[¶](#section-5.7-5.2.2.2){.pilcrow}]{#section-5.7-5.2.2.2}
    -   [The size in symbols of the FEC transport
        object.[¶](#section-5.7-5.2.2.3){.pilcrow}]{#section-5.7-5.2.2.3}
    :::

The carriage of the FEC repair information is discussed
below.[¶](#section-5.7-6){.pilcrow}
:::
:::

::: {#sect-5.8}
::: {#section-5.8 .section}
### [5.8.](#section-5.8){.section-number .selfRef} [Repair Packet Considerations](#name-repair-packet-consideration){.section-name .selfRef} {#name-repair-packet-consideration}

The repair protocol is based on Asynchronous Layered Coding (ALC) as
defined in RFC 5775 \[[RFC5775](#RFC5775){.xref}\] and the Layered
Coding Transport (LCT) Building Block as defined in RFC 5651
\[[RFC5651](#RFC5651){.xref}\] with the following
details:[¶](#section-5.8-1){.pilcrow}

-   ::: {#section-5.8-2.1}
    The Layered Coding Transport (LCT) Building Block as defined in RFC
    5651 \[[RFC5651](#RFC5651){.xref}\] is used as defined in
    Asynchronous Layered Coding (ALC), [Section 2.1](#sect-2.1){.xref}.
    In addition, the following constraint
    applies:[¶](#section-5.8-2.1.1){.pilcrow}

    -   [The TSI in the LCT header [SHALL]{.bcp14} identify the Repair
        Flow to which this packet applies by the matching the value of
        the ptsi attribute in the signaling metadata among the LCT
        channels carrying Repair
        Flows.[¶](#section-5.8-2.1.2.1){.pilcrow}]{#section-5.8-2.1.2.1}
    :::

-   ::: {#section-5.8-2.2}
    The FEC building block is used according to RFC 6330
    \[[RFC6330](#RFC6330){.xref}\], but only repair packets are
    delivered.[¶](#section-5.8-2.2.1){.pilcrow}

    -   [Each repair packet within the scope of the Repair Flow (as
        indicated by the TSI field in the LCT header) [SHALL]{.bcp14}
        carry the repair symbols for a corresponding FEC transport
        object/super-object as identified by its TOI. The repair
        object/super- object TOI [SHALL]{.bcp14} be unique for each FEC
        super-object that is created within the scope of the
        TSI.[¶](#section-5.8-2.2.2.1){.pilcrow}]{#section-5.8-2.2.2.1}
    :::
:::
:::

::: {#sect-5.9}
::: {#section-5.9 .section}
### [5.9.](#section-5.9){.section-number .selfRef} [Summary FEC Information](#name-summary-fec-information){.section-name .selfRef} {#name-summary-fec-information}

For each super-object (identified by a unique TOI within a Repair Flow
that is in turn identified by the TSI in the LCT header) that is
generated, the following information needs to be communicated to the
receiver:[¶](#section-5.9-1){.pilcrow}

-   ::: {#section-5.9-2.1}
    The FEC configuration consisting
    of:[¶](#section-5.9-2.1.1){.pilcrow}

    -   [FEC Object Transmission Information (OTI) per RFC 5052
        \[[RFC5052](#RFC5052){.xref}\].[¶](#section-5.9-2.1.2.1){.pilcrow}]{#section-5.9-2.1.2.1}
    -   [Additional FEC information (see [Section
        3.3](#sect-3.3){.xref}).[¶](#section-5.9-2.1.2.2){.pilcrow}]{#section-5.9-2.1.2.2}
    -   [The total number of FEC objects included in the FEC
        super-object,
        N.[¶](#section-5.9-2.1.2.3){.pilcrow}]{#section-5.9-2.1.2.3}
    :::

-   ::: {#section-5.9-2.2}
    For each FEC transport object:[¶](#section-5.9-2.2.1){.pilcrow}

    -   [TSI and TOI of the delivery object used to generate the FEC
        object associated with the FEC transport
        object,[¶](#section-5.9-2.2.2.1){.pilcrow}]{#section-5.9-2.2.2.1}
    -   [The start octet within the delivery object of the associated
        FEC object, if applicable,
        and[¶](#section-5.9-2.2.2.2){.pilcrow}]{#section-5.9-2.2.2.2}
    -   [The size in symbols of the FEC transport object,
        S.[¶](#section-5.9-2.2.2.3){.pilcrow}]{#section-5.9-2.2.2.3}
    :::

The above information is delivered:[¶](#section-5.9-3){.pilcrow}

-   [Statically in the session metadata as defined in [Section
    3.3](#sect-3.3){.xref},
    and[¶](#section-5.9-4.1){.pilcrow}]{#section-5.9-4.1}
-   [Dynamically in an LCT extension
    header.[¶](#section-5.9-4.2){.pilcrow}]{#section-5.9-4.2}
:::
:::
:::
:::

::: {#sect-6}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Receiver Operation](#name-receiver-operation){.section-name .selfRef} {#name-receiver-operation}

The receiver receives packets and filters those packets according to the
following. From the ROUTE session and each contained LCT channel, the
receiver regenerates delivery objects from the ROUTE session and each
contained LCT channel.[¶](#section-6-1){.pilcrow}

In the event that the receiver receives data that does not conform to
the ROUTE protocol specified in this document, the receiver
[SHOULD]{.bcp14} attempt to recover gracefully by e.g., informing the
application about the issues using means beyond the scope of this
document. The ROUTE packetization specified in [Section
5.2.1](#sect-5.2.1){.xref} implies that the receiver [SHALL NOT]{.bcp14}
receive overlapping data; if such a condition is encountered at the
receiver, the packet [SHALL]{.bcp14} be assumed to be
corrupted.[¶](#section-6-2){.pilcrow}

The basic receiver operation is provided below (it assumes an error-free
scenario), while repair considerations are provided in [Section
7](#sect-7){.xref}.[¶](#section-6-3){.pilcrow}

::: {#sect-6.1}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Basic Application Object Recovery for Source Flows](#name-basic-application-object-re){.section-name .selfRef} {#name-basic-application-object-re}

Upon receipt of each ROUTE packet of a Source Flow, the receiver
proceeds with the following steps in the order
listed.[¶](#section-6.1-1){.pilcrow}

[]{.break}

1\)
:   The ROUTE receiver is expected to parse the LCT and FEC Payload ID
    to verify that it is a valid header. If it is not valid, then the
    payload is discarded without further
    processing.[¶](#section-6.1-2.1){.pilcrow}
:   

2\)
:   All ROUTE packets used to recover a specific delivery object carry
    the same TOI value in the LCT header.[¶](#section-6.1-2.2){.pilcrow}
:   

3\)
:   The ROUTE receiver is expected to assert that the TSI and the
    Codepoint represent valid operation points in the signaling
    metadata, i.e., the signaling contains a matching entry to the TSI
    value provided in the packet header, as well as for this TSI, and
    the Codepoint field in the LCT header has a valid Codepoint
    mapping.[¶](#section-6.1-2.3){.pilcrow}
:   

4\)

:   The ROUTE receiver should process the remainder of the payload,
    including the appropriate interpretation of the other payload header
    fields, using the source FEC Payload ID (to determine the
    start_offset) and the payload data to reconstruct the corresponding
    object as follows:[¶](#section-6.1-2.4.1){.pilcrow}

    a.  [For File Mode, upon receipt of the first ROUTE packet payload
        for an object, the ROUTE receiver uses the File\@Transfer-Length
        attribute of the associated Extended FDT-Instance, when present,
        to determine the length T of the object. When the
        File\@Transfer-Length attribute is not present in the Extended
        FDT-Instance, the receiver uses the maxTransportSize attribute
        of the associated Extended FDT-Instance to determine the maximum
        length T\' of the object. Alternatively, and specifically for
        delivery modes other than File Mode, the EXT_TOL header can be
        used to determine the length T of the
        object.[¶](#section-6.1-2.4.2.1){.pilcrow}]{#section-6.1-2.4.2.1}

    b.  [The ROUTE receiver allocates buffer space for the T or T\'
        bytes that the object will or may
        occupy.[¶](#section-6.1-2.4.2.2){.pilcrow}]{#section-6.1-2.4.2.2}

    c.  [The ROUTE receiver computes the length of the payload, Y, by
        subtracting the payload header length from the total length of
        the received
        payload.[¶](#section-6.1-2.4.2.3){.pilcrow}]{#section-6.1-2.4.2.3}

    d.  ::: {#section-6.1-2.4.2.4}
        The ROUTE receiver allocates a Boolean array RECEIVED\[0..T-1\]
        or RECEIVED\[0..T\'-1\], as appropriate, with all entries
        initialized to false to track received object symbols. The ROUTE
        receiver continuously acquires packet payloads for the object as
        long as all of the following conditions are
        satisfied:[¶](#section-6.1-2.4.2.4.1){.pilcrow}

        i.  [there is at least one entry in RECEIVED still set to
            false,[¶](#section-6.1-2.4.2.4.2.1){.pilcrow}]{#section-6.1-2.4.2.4.2.1}

        ii. [the object has not yet expired,
            and[¶](#section-6.1-2.4.2.4.2.2){.pilcrow}]{#section-6.1-2.4.2.4.2.2}

        iii. ::: {#section-6.1-2.4.2.4.2.3}
             the application has not given up on reception of this
             object.[¶](#section-6.1-2.4.2.4.2.3.1){.pilcrow}

             More details are provided
             below.[¶](#section-6.1-2.4.2.4.2.3.2){.pilcrow}
             :::
        :::

    e.  ::: {#section-6.1-2.4.2.5}
        For each received ROUTE packet payload for the object (including
        the first payload), the steps to be taken to help recover the
        object are as follows:[¶](#section-6.1-2.4.2.5.1){.pilcrow}

        i.  [If the packet includes an EXT_TOL or EXT_FTI header, modify
            the Boolean array RECEIVED\[0..T\'-1\] to become
            RECEIVED\[0..T-1\].[¶](#section-6.1-2.4.2.5.2.1){.pilcrow}]{#section-6.1-2.4.2.5.2.1}
        ii. [Let X be the value of the start_offset field in the ROUTE
            packet header and let Y be the length of the payload, Y,
            computed by subtracting the LCT header size and the FEC
            Payload ID size from the total length of the received
            packet.[¶](#section-6.1-2.4.2.5.2.2){.pilcrow}]{#section-6.1-2.4.2.5.2.2}
        iii. [The ROUTE receiver copies the data into the appropriate
             place within the space reserved for the object and sets
             RECEIVED\[X \... X+Y-1\] =
             true.[¶](#section-6.1-2.4.2.5.2.3){.pilcrow}]{#section-6.1-2.4.2.5.2.3}
        iv. [If all T entries of RECEIVED are true, then the receiver
            has recovered the entire
            object.[¶](#section-6.1-2.4.2.5.2.4){.pilcrow}]{#section-6.1-2.4.2.5.2.4}
        :::

:   

Upon recovery of both the complete set of packet payloads for the
delivery object associated with a given TOI value, and the metadata for
that delivery object, the reception of the delivery object, now a fully
received Application Object, is complete.[¶](#section-6.1-3){.pilcrow}

Given the timely reception of ROUTE packets belonging to an Application
Object, the receiver [SHALL]{.bcp14} make the Application Objects
available to the application in a timely fashion using the
application-provided timing data (e.g., the timing data signaled via the
presentation manifest file). For example, HTTP/1.1 chunked transfer may
need to be enabled to transfer the Application Objects if
MPD\@availabilityTimeOffset is signaled in the DASH presentation
manifest in order to allow for the timely sending of segment data to the
application.[¶](#section-6.1-4){.pilcrow}
:::
:::

::: {#sect-6.2}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Fast Stream Acquisition](#name-fast-stream-acquisition){.section-name .selfRef} {#name-fast-stream-acquisition}

When the receiver initially starts reception of ROUTE packets, it is
likely that the reception does not start from the very first packet
carrying the data of a multicast transport object; in this case, such a
partially received object is normally discarded. However, the channel
acquisition or \"tune-in\" times can be improved if the partially
received object is usable by the application. One example realization
for this is as follows:[¶](#section-6.2-1){.pilcrow}

-   [The receiver checks for the first received packet with the
    Codepoint value set to 10, indicating the start of a CMAF Random
    Access chunk.[¶](#section-6.2-2.1){.pilcrow}]{#section-6.2-2.1}
-   [The receiver [MAY]{.bcp14} make the partially received object (a
    partial DASH segment starting from the packet above) available to
    the application for fast stream
    acquisition.[¶](#section-6.2-2.2){.pilcrow}]{#section-6.2-2.2}
-   [It [MAY]{.bcp14} recover the earliest presentation time of this
    CMAF Random Access chunk from the ROUTE packet LCT Congestion
    Control Information (CCI) field as specified in [Section
    2.1](#sect-2.1){.xref} to be able to add a new Period element in the
    MPD exposed to the application containing just the partially
    received DASH segment with period continuity
    signaling.[¶](#section-6.2-2.3){.pilcrow}]{#section-6.2-2.3}
:::
:::

::: {#sect-6.3}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Generating Extended FDT-Instance for File Mode](#name-generating-extended-fdt-ins){.section-name .selfRef} {#name-generating-extended-fdt-ins}

An Extended FDT-Instance conforming to RFC 6726
\[[RFC6726](#RFC6726){.xref}\], is produced at the receiver using the
service metadata and in-band signaling in the following
steps:[¶](#section-6.3-1){.pilcrow}

::: {#sect-6.3.1}
::: {#section-6.3.1 .section}
#### [6.3.1.](#section-6.3.1){.section-number .selfRef} [File Template Substitution for Content-Location Derivation](#name-file-template-substitution-){.section-name .selfRef} {#name-file-template-substitution-}

The Content-Location element of the Extended FDT for a specific
Application Object is derived as follows:[¶](#section-6.3.1-1){.pilcrow}

\"\$TOI\$\" is substituted with the unique TOI value in the LCT header
of the ROUTE packets used to recover the given delivery object (as
specified in [Section
6.1](#sect-6.1){.xref}).[¶](#section-6.3.1-2){.pilcrow}

After the substitution, the fileTemplate [SHALL]{.bcp14} be a valid URL
corresponding to the Content-Location attribute of the associated
Application Object.[¶](#section-6.3.1-3){.pilcrow}

An example \@fileTemplate using a width of 5 is:
fileTemplate=\"myVideo\$TOI%05d\$.mps\", resulting in file names with
exactly five digits in the number portion. The Media Segment file name
for TOI=33 using this template is
myVideo00033.mps.[¶](#section-6.3.1-4){.pilcrow}
:::
:::

::: {#sect-6.3.2}
::: {#section-6.3.2 .section}
#### [6.3.2.](#section-6.3.2){.section-number .selfRef} [File\@Transfer-Length Derivation](#name-filetransfer-length-derivat){.section-name .selfRef} {#name-filetransfer-length-derivat}

Either the EXT_FTI header (per RFC 5775 \[[RFC5775](#RFC5775){.xref}\])
or the EXT_TOL header, when present, is used to derive the Transport
Object Length (TOL) of the File. If the File\@Transfer-Length parameter
in the Extended FDT-Instance is not present, then the EXT_TOL header or
the or EXT_FTI header [SHALL]{.bcp14} be present. Note that a header
containing the transport object length (EXT_TOL or EXT_FTI) need not be
present in each packet header. If the broadcaster does not know the
length of the transport object at the beginning of the transfer, an
EXT_TOL or EXT_FTI header [SHALL]{.bcp14} be included in at least the
last packet of the file and should be included in the last few packets
of the transfer.[¶](#section-6.3.2-1){.pilcrow}
:::
:::

::: {#sect-6.3.3}
::: {#section-6.3.3 .section}
#### [6.3.3.](#section-6.3.3){.section-number .selfRef} [FDT-Instance\@Expires Derivation](#name-fdt-instanceexpires-derivat){.section-name .selfRef} {#name-fdt-instanceexpires-derivat}

When present, the maxExpiresDelta attribute [SHALL]{.bcp14} be used to
generate the value of the FDT-Instance\@Expires attribute. The receiver
is expected to add this value to its wall clock time when acquiring the
first ROUTE packet carrying the data of a given delivery object to
obtain the value for \@Expires.[¶](#section-6.3.3-1){.pilcrow}

When maxExpiresDelta is not present, the EXT_TIME header with Expected
Residual Time (ERT) [SHALL]{.bcp14} be used to derive the expiry time of
the Extended FDT-Instance. When both maxExpiresDelta and the ERT of
EXT_TIME are present, the smaller of the two values should be used as
the incremental time interval to be added to the receiver\'s current
time to generate the effective value for \@Expires. When neither
maxExpiresDelta nor the ERT field of the EXT_TIME header is present,
then the expiration time of the Extended FDT-Instance is given by its
\@Expires attribute.[¶](#section-6.3.3-2){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#sect-7}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [FEC Application](#name-fec-application){.section-name .selfRef} {#name-fec-application}

::: {#sect-7.1}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [General FEC Application Guidelines](#name-general-fec-application-gui){.section-name .selfRef} {#name-general-fec-application-gui}

It is up to the receiver to decide to use zero, one, or more of the FEC
streams. Hence, the application assigns a recovery property to each
flow, which defines aspects such as the delay and the required memory if
one or the other is chosen. The receiver [MAY]{.bcp14} decide whether or
not to utilize Repair Flows based on the following
considerations:[¶](#section-7.1-1){.pilcrow}

-   [The desired start-up and end-to-end latency. If a Repair Flow
    requires a significant amount of buffering time to be effective,
    such Repair Flow might only be used in time-shift operations or in
    poor reception conditions, since use of such Repair Flow trades off
    end-to-end latency against DASH Media Presentation
    quality.[¶](#section-7.1-2.1){.pilcrow}]{#section-7.1-2.1}
-   [FEC capabilities, i.e., the receiver [MAY]{.bcp14} pick only the
    FEC algorithm that it
    supports.[¶](#section-7.1-2.2){.pilcrow}]{#section-7.1-2.2}
-   [Which Source Flows are being protected; for example, if the Repair
    Flow protects Source Flows that are not selected by the receiver,
    then the receiver may not select the Repair
    Flow.[¶](#section-7.1-2.3){.pilcrow}]{#section-7.1-2.3}
-   [Other considerations such as available buffer size, reception
    conditions, etc.[¶](#section-7.1-2.4){.pilcrow}]{#section-7.1-2.4}

If a receiver decides to acquire a certain Repair Flow, then the
receiver must receive data on all Source Flows that are protected by
that Repair Flow to collect the relevant
packets.[¶](#section-7.1-3){.pilcrow}
:::
:::

::: {#sect-7.2}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [TOI Mapping](#name-toi-mapping){.section-name .selfRef} {#name-toi-mapping}

When mappingTOIx/mappingTOIy are used to signal X and Y values, the TOI
value(s) of the one or more source objects (sourceTOI) protected by a
given FEC transport object or FEC super-object with a TOI value rTOI is
derived through an equation sourceTOI = X\*rTOI +
Y.[¶](#section-7.2-1){.pilcrow}

When neither mappingTOIx nor mappingTOIy is present, there is a 1:1
relationship between each delivery object carried in the Source Flow as
identified by ptsi to a FEC object carried in this Repair Flow. In this
case, the TOI of each of those delivery objects [SHALL]{.bcp14} be
identical to the TOI of the corresponding FEC
object.[¶](#section-7.2-2){.pilcrow}
:::
:::

::: {#sect-7.3}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Delivery Object Reception Timeout](#name-delivery-object-reception-t){.section-name .selfRef} {#name-delivery-object-reception-t}

The permitted start and end times for the receiver to perform the file
repair procedure, in case of unsuccessful broadcast file reception, and
associated rules and parameters are as
follows:[¶](#section-7.3-1){.pilcrow}

-   [The latest time that the file repair procedure may start is bound
    by the \@Expires attribute of the
    FDT-Instance.[¶](#section-7.3-2.1){.pilcrow}]{#section-7.3-2.1}

-   ::: {#section-7.3-2.2}
    The receiver may choose to start the file repair procedure earlier
    if it detects the occurrence of any of the following
    events:[¶](#section-7.3-2.2.1){.pilcrow}

    -   [Presence of the Close Object flag (B) in the LCT header
        \[[RFC5651](#RFC5651){.xref}\] for the file of
        interest;[¶](#section-7.3-2.2.2.1){.pilcrow}]{#section-7.3-2.2.2.1}
    -   [Presence of the Close Session flag (A) in the LCT header
        \[[RFC5651](#RFC5651){.xref}\] before the nominal expiration of
        the Extended FDT-Instance as defined by the \@Expires
        attribute.[¶](#section-7.3-2.2.2.2){.pilcrow}]{#section-7.3-2.2.2.2}
    :::
:::
:::

::: {#sect-7.4}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [Example FEC Operation](#name-example-fec-operation){.section-name .selfRef} {#name-example-fec-operation}

To be able to recover the delivery objects that are protected by a
Repair Flow, a receiver needs to obtain the necessary Service signaling
metadata fragments that describe the corresponding collection of
delivery objects that are covered by this Repair Flow. A Repair Flow is
characterized by the combination of an LCT channel, a unique TSI number,
as well as the corresponding protected Source
Flows.[¶](#section-7.4-1){.pilcrow}

If a receiver acquires data of a Repair Flow, the receiver is expected
to collect all packets of all protected Transport Sessions. Upon receipt
of each packet, whether it is a source or repair packet, the receiver
proceeds with the following steps in the order
listed.[¶](#section-7.4-2){.pilcrow}

1.  [The receiver is expected to parse the packet header and verify that
    it is a valid header. If it is not valid, then the packet
    [SHALL]{.bcp14} be discarded without further
    processing.[¶](#section-7.4-3.1){.pilcrow}]{#section-7.4-3.1}

2.  [The receiver is expected to parse the TSI field of the packet
    header and verify that a matching value exists in the Service
    signaling for the Repair Flow or the associated Protected Source
    Flow. If no match is found, the packet [SHALL]{.bcp14} be discarded
    without further
    processing.[¶](#section-7.4-3.2){.pilcrow}]{#section-7.4-3.2}

3.  ::: {#section-7.4-3.3}
    The receiver processes the remainder of the packet, including
    interpretation of the other header fields, and using the source FEC
    Payload ID (to determine the start_offset byte position within the
    source object), the Repair FEC Payload ID, as well as the payload
    data, reconstructs the decoding blocks corresponding to a FEC
    super-object as follows:[¶](#section-7.4-3.3.1){.pilcrow}

    a.  [For a source packet, the receiver identifies the delivery
        object to which the received packet is associated using the
        session information and the TOI carried in the payload header.
        Similarly, for a repair object, the receiver identifies the FEC
        super-object to which the received packet is associated using
        the session information and the TOI carried in the payload
        header.[¶](#section-7.4-3.3.2.1){.pilcrow}]{#section-7.4-3.3.2.1}
    b.  [For source packets, the receiver collects the data for each FEC
        super-object and recovers FEC super-objects in the same way as a
        Source Flow in [Section 6.1](#sect-6.1){.xref}. The received FEC
        super-object is then mapped to a source block and the
        corresponding encoding symbols are
        generated.[¶](#section-7.4-3.3.2.2){.pilcrow}]{#section-7.4-3.3.2.2}
    c.  [With the reception of the repair packets, the FEC super-object
        can be
        recovered.[¶](#section-7.4-3.3.2.3){.pilcrow}]{#section-7.4-3.3.2.3}
    d.  [Once the FEC super-object is recovered, the individual delivery
        objects can be
        extracted.[¶](#section-7.4-3.3.2.4){.pilcrow}]{#section-7.4-3.3.2.4}
    :::
:::
:::
:::
:::

::: {#sect-8}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Considerations for Defining ROUTE Profiles](#name-considerations-for-defining){.section-name .selfRef} {#name-considerations-for-defining}

Services (e.g., ATSC-ROUTE \[[ATSCA331](#ATSCA331){.xref}\], DVB-MABR
\[[DVBMABR](#DVBMABR){.xref}\], etc.) may define specific ROUTE
\"profiles\" based on this document in their respective standards
organizations. An example is noted in the overview section: DVB has
specified a profile of ATSC-ROUTE in DVB Adaptive Media Streaming over
IP Multicast (DVB-MABR) \[[DVBMABR](#DVBMABR){.xref}\]. The definition
has the following considerations. Services
[MAY]{.bcp14}[¶](#section-8-1){.pilcrow}

-   [Restrict the signaling of certain values signaled in the LCT header
    and/or provision unused fields in the LCT
    header.[¶](#section-8-2.1){.pilcrow}]{#section-8-2.1}
-   [Restrict using certain LCT header extensions and/or add new LCT
    header extensions.[¶](#section-8-2.2){.pilcrow}]{#section-8-2.2}
-   [Restrict or limit usage of some Codepoints and/or assign semantics
    to service-specific Codepoints marked as reserved in this
    document.[¶](#section-8-2.3){.pilcrow}]{#section-8-2.3}
-   [Restrict usage of certain Service signaling attributes and/or add
    their own service
    metadata.[¶](#section-8-2.4){.pilcrow}]{#section-8-2.4}

Services [SHALL NOT]{.bcp14} redefine the semantics of any of the ROUTE
attributes in LCT headers and extensions, as well as Service signaling
attributes already specified in this
document.[¶](#section-8-3){.pilcrow}

By following these guidelines, services can define profiles that are
interoperable.[¶](#section-8-4){.pilcrow}
:::
:::

::: {#sect-9}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [ROUTE Concepts](#name-route-concepts){.section-name .selfRef} {#name-route-concepts}

::: {#sect-9.1}
::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [ROUTE Modes of Delivery](#name-route-modes-of-delivery){.section-name .selfRef} {#name-route-modes-of-delivery}

Different ROUTE delivery modes specified in [Section 4](#sect-4){.xref}
are optimized for delivery of different types of media data. For
example, File Mode is specifically optimized for delivering DASH content
using Segment Template with number substitution. Using File Template in
EFDT avoids the need for the repeated sending of metadata as outlined in
the following section. Same optimizations, however, cannot be used for
time substitution and segment timeline where the addressing of each
segment is time dependent and in general does not follow a fixed or
repeated pattern. In this case, Entity Mode is more optimized since it
carries the file location in band. Also, Entity Mode can be used to
deliver a file or part of the file using HTTP Partial Content response
headers.[¶](#section-9.1-1){.pilcrow}
:::
:::

::: {#sect-9.2}
::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [File Mode Optimizations](#name-file-mode-optimizations){.section-name .selfRef} {#name-file-mode-optimizations}

In File Mode, the delivery object represents an Application Object. This
mode replicates FLUTE as defined in RFC 6726
\[[RFC6726](#RFC6726){.xref}\] but with the ability to send static and
pre-known file metadata out of band.[¶](#section-9.2-1){.pilcrow}

In FLUTE, FDT-Instances are delivered in band and need to be generated
and delivered in real time if objects are generated in real time at the
sender. These FDT-Instances have some differences as compared to the FDT
specified in [Section
3.4.2](https://www.rfc-editor.org/rfc/rfc6726#section-3.4.2){.relref} of
\[[RFC6726](#RFC6726){.xref}\] and Section 7.2.10 of MBMS
\[[MBMS](#MBMS){.xref}\]. The key difference is that besides separated
delivery of file metadata from the delivery object it describes, the FDT
functionality in ROUTE may be extended by additional file metadata and
rules that enable the receiver to generate the Content-Location
attribute of the File element of the FDT, on the fly. This is done by
using information in both the extensions to the FDT and the LCT header.
The combination of pre-delivery of static file metadata and receiver
self generation of dynamic file metadata avoids the necessity of
continuously sending the FDT-Instances for real-time objects. Such
modified FDT functionality in ROUTE is referred to as the Extended
FDT.[¶](#section-9.2-2){.pilcrow}
:::
:::

::: {#sect-9.3}
::: {#section-9.3 .section}
### [9.3.](#section-9.3){.section-number .selfRef} [In-Band Signaling of Object Transfer Length](#name-in-band-signaling-of-object){.section-name .selfRef} {#name-in-band-signaling-of-object}

As an extension to FLUTE, ROUTE allows for using EXT_TOL LCT header
extension with 24 bits or, if required, 48 bits to signal the Transfer
Length directly within the ROUTE packet.[¶](#section-9.3-1){.pilcrow}

The transport object length can also be determined without the use of
EXT_TOL by examining the LCT packet with the Close Object flag (B).
However, if this packet is lost, then the EXT_TOL information can be
used by the receiver to determine the transport object
length.[¶](#section-9.3-2){.pilcrow}

Applications using ROUTE for delivery of low-latency streaming content
may make use of this feature for sender-end latency optimizations: the
sender does not have to wait for the completion of the packaging of a
whole Application Object to find its Transfer Length to be included in
the FDT before the sending can start. Rather, partially encoded data can
already be started to be sent via the ROUTE sender. As the time
approaches when the encoding of the Application Object is nearing
completion, and the length of the object becomes known (e.g., the time
of writing the last CMAF Chunk of a DASH segment), only then the sender
can signal the object length using the EXT TOL LCT header. For example,
for a 2-second DASH segment with 100-millisecond chunks, it may result
in saving up to 1.9 second latency at the sending
end.[¶](#section-9.3-3){.pilcrow}
:::
:::

::: {#sect-9.4}
::: {#section-9.4 .section}
### [9.4.](#section-9.4){.section-number .selfRef} [Repair Protocol Concepts](#name-repair-protocol-concepts){.section-name .selfRef} {#name-repair-protocol-concepts}

The ROUTE repair protocol is FEC-based and is enabled as an additional
layer between the transport layer (e.g., UDP) and the object delivery
layer protocol. The FEC reuses concepts of the FEC Framework defined in
RFC 6363 \[[RFC6363](#RFC6363){.xref}\], but in contrast to the FEC
Framework in RFC 6363 \[[RFC6363](#RFC6363){.xref}\], the ROUTE repair
protocol does not protect packets but instead protects delivery objects
as delivered in the source protocol. In addition, as an extension to
FLUTE, it supports the protection of multiple objects in one source
block which is in alignment with the FEC Framework as defined in RFC
6363 \[[RFC6363](#RFC6363){.xref}\]. Each FEC source block may consist
of parts of a delivery object, as a single delivery object (similar to
FLUTE) or multiple delivery objects that are bundled prior to FEC
protection. ROUTE FEC makes use of FEC schemes in a similar way as those
defined in RFC 5052 \[[RFC5052](#RFC5052){.xref}\] and uses the
terminology of that document. The FEC scheme defines the FEC encoding
and decoding as well as the protocol fields and procedures used to
identify packet payload data in the context of the FEC
scheme.[¶](#section-9.4-1){.pilcrow}

In ROUTE, all packets are LCT packets as defined in RFC 5651
\[[RFC5651](#RFC5651){.xref}\]. Source and repair packets may be
distinguished by:[¶](#section-9.4-2){.pilcrow}

-   [Different ROUTE sessions, i.e., they are carried on different
    UDP/IP port
    combinations.[¶](#section-9.4-3.1){.pilcrow}]{#section-9.4-3.1}
-   [Different LCT channels, i.e., they use different TSI values in the
    LCT header.[¶](#section-9.4-3.2){.pilcrow}]{#section-9.4-3.2}
-   [The most significant PSI bit in the LCT, if carried in the same LCT
    channel. This mode of operation is mostly suitable for
    FLUTE-compatible
    deployments.[¶](#section-9.4-3.3){.pilcrow}]{#section-9.4-3.3}
:::
:::
:::
:::

::: {#sect-10}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Interoperability Chart](#name-interoperability-chart){.section-name .selfRef} {#name-interoperability-chart}

As noted in prevision sections, ATSC-ROUTE
\[[ATSCA331](#ATSCA331){.xref}\] and DVB-MABR
\[[DVBMABR](#DVBMABR){.xref}\] are considered services using this
document that constrain specific features as well as add new ones. In
this context, the following table is an informative comparison of the
interoperability of ROUTE as specified in this document with ATSC-ROUTE
\[[ATSCA331](#ATSCA331){.xref}\] and DVB-MABR
\[[DVBMABR](#DVBMABR){.xref}\]:[¶](#section-10-1){.pilcrow}

[]{#name-interoperability-chart-2}

::: {#interoperability}
  Element                           ATSC-ROUTE                                                                             This Document                                                                                                                                                                                          DVB-MABR
  --------------------------------- -------------------------------------------------------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ -------------------------------------------------------------------
  LCT header field                  PSI LSB set to 0 for Source Flow                                                       Not defined                                                                                                                                                                                            Set to 1 for Source Flow for CMAF Random Access chunk
                                    CCI may be set to 0                                                                    CCI may be set to EPT for Source Flow                                                                                                                                                                  
  LCT header extensions             EXT_ROUTE\_​PRESENTATION_TIME Header used for Media Delivery Event (MDE) mode          Not defined; may be added by a profile.                                                                                                                                                                Shall not be used.
                                    EXT_TIME Header linked to MDE mode in Annex A.3.7.2 \[[ATSCA331](#ATSCA331){.xref}\]   EXT_TIME Header may be used regardless (for FDT-Instance\@Expires calculation)                                                                                                                         
  Codepoints                        Full set                                                                               Does not specify range 11 - 255 (leaves to profiles)                                                                                                                                                   Restricted to 5 - 9
  Session metadata                  Full set                                                                               Only defines a small subset of data necessary for setting up Source and Repair Flows. Does not define format or encoding of data except if data is integral/alphanumerical. Leaves rest to profiles.   Reuses A/331 metadata, duplicated from its own Service signaling.
  Extended FDT                      Instance shall not be sent with Source Flow                                            Not restricted, may be restricted by a profile.                                                                                                                                                        Instance shall not be sent with Source Flow
                                    No restriction                                                                         Only allowed in File Mode                                                                                                                                                                              
  Delivery Object Mode              File, Entity, Signed/unsigned package                                                                                                                                                                                                                                                         Signed/unsigned package not allowed
  Sender operation: Packetization   Defined for DASH segment                                                               Defined for DASH segment and CMAF Chunks                                                                                                                                                               
  Receiver object recovery          Object handed to application upon complete reception                                   Object may be handed before completion if MPD\@availabilityTimeOffset signaled                                                                                                                         
                                    \-                                                                                     Fast Stream acquisition guidelines provided                                                                                                                                                            

  : [Table 3](#table-3){.selfRef}: [Interoperability
  Chart](#name-interoperability-chart-2){.selfRef}
:::
:::
:::

::: {#sect-11}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [Security and Privacy Considerations](#name-security-and-privacy-consid){.section-name .selfRef} {#name-security-and-privacy-consid}

::: {#sect-11.1}
::: {#section-11.1 .section}
### [11.1.](#section-11.1){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

As noted in [Section 9](#sect-9){.xref}, ROUTE is aligned with FLUTE as
specified in RFC 6726 \[[RFC6726](#RFC6726){.xref}\] and only diverges
in certain signaling optimizations, especially for the real-time object
delivery case. Hence, most of the security considerations documented in
RFC 6726 \[[RFC6726](#RFC6726){.xref}\] for the data flow itself, the
session metadata (session control parameters in RFC 6726
\[[RFC6726](#RFC6726){.xref}\]), and the associated building blocks
apply directly to ROUTE as elaborated in the following along with some
additional considerations.[¶](#section-11.1-1){.pilcrow}

Both encryption and integrity protection applied either on file or
packet level, as recommended in the file corruption considerations of
RFC 6726 \[[RFC6726](#RFC6726){.xref}\], [SHOULD]{.bcp14} be used for
ROUTE. Additionally, RFC 3740 \[[RFC3740](#RFC3740){.xref}\] documents
multicast security architecture in great detail with clear security
recommendations that [SHOULD]{.bcp14} be
followed.[¶](#section-11.1-2){.pilcrow}

When ROUTE is carried over UDP and a reverse channel from receiver to
sender is available, the security mechanisms provided in RFC 9147
\[[RFC9147](#RFC9147){.xref}\] [SHOULD]{.bcp14} be
applied.[¶](#section-11.1-3){.pilcrow}

In regard to considerations for attacks against session description,
this document does not specify the semantics or mechanism of delivery of
session metadata, though the same threats apply for service using ROUTE
as well. Hence, a service using ROUTE [SHOULD]{.bcp14} take these
threats into consideration and address them appropriately following the
guidelines provided by RFC 6726 \[[RFC6726](#RFC6726){.xref}\].
Additionally, to the recommendations of RFC 6726
\[[RFC6726](#RFC6726){.xref}\], for Internet connected devices, services
[SHOULD]{.bcp14} enable clients to access the session description
information using HTTPS with customary authentication/authorization,
instead of sending this data via multicast/broadcast, since considerable
security work has been done already in this unicast domain, which can
enable highly secure access of session description data. Accessing via
unicast, however, will have different privacy considerations, noted in
[Section 11.2](#sect-11.2){.xref}. Note that in general the
multicast/broadcast stream is delayed with respect to the unicast
stream. Therefore, the session description protocol [SHOULD]{.bcp14} be
time synchronized with the broadcast stream, particularly if the session
description contains security-related
information.[¶](#section-11.1-4){.pilcrow}

In regard to FDT, there is one key difference for File Mode when using
File Template in EFDT, which avoids repeated sending of FDT-Instances
and hence, the corresponding threats noted in RFC 6726
\[[RFC6726](#RFC6726){.xref}\] do not apply directly to ROUTE in this
case. The threat, however, is shifted to the ALC/LCT headers, since they
carry the additional signaling that enables determining Content-Location
and File\@Transfer-Length in this case. Hence, integrity protection
recommendations of ALC/LCT header [SHOULD]{.bcp14} be considered with
higher emphasis in this case for ROUTE.[¶](#section-11.1-5){.pilcrow}

Finally, attacks against the congestion control building block for the
case of ROUTE can impact the optional fast stream acquisition specified
in [Section 6.2](#sect-6.2){.xref}. Receivers [SHOULD]{.bcp14} have
robustness against timestamp values that are suspicious, e.g., by
comparing the signaled time in the LCT headers with the approximate time
signaled by the MPD, and [SHOULD]{.bcp14} discard outlying values.
Additionally, receivers [MUST]{.bcp14} adhere to the expiry timelines as
specified in [Section 6](#sect-6){.xref}. Integrity protection
mechanisms documented in RFC 6726 \[[RFC6726](#RFC6726){.xref}\]
[SHOULD]{.bcp14} be used to address this
threat.[¶](#section-11.1-6){.pilcrow}
:::
:::

::: {#sect-11.2}
::: {#section-11.2 .section}
### [11.2.](#section-11.2){.section-number .selfRef} [Privacy Considerations](#name-privacy-considerations){.section-name .selfRef} {#name-privacy-considerations}

Encryption mechanisms recommended for security considerations in
[Section 11.1](#sect-11.1){.xref} [SHOULD]{.bcp14} also be applied to
enable privacy and protection from snooping
attacks.[¶](#section-11.2-1){.pilcrow}

Since this protocol is primarily targeted for IP multicast/broadcast
environments where the end user is mostly listening, identity protection
and user data retention considerations are more protected than in the
unicast case. Best practices for enabling privacy on IP
multicast/broadcast [SHOULD]{.bcp14} be applied by the operators, e.g.,
\"[Recommendations for DNS Privacy Service Operators](#RFC8932){.xref}\"
in RFC 8932
\[[RFC8932](#RFC8932){.xref}\].[¶](#section-11.2-2){.pilcrow}

However, if clients access session description information via HTTPS,
the same privacy considerations and solutions [SHALL]{.bcp14} apply to
this access as for regular HTTPS communication, an area that is very
well studied and the concepts of which are being integrated directly
into newer transport protocols such as IETF QUIC
\[[RFC9000](#RFC9000){.xref}\] enabling HTTP/3
\[[HTTP3](#I-D.ietf-quic-http){.xref}\]. Hence, such newer protocols
[SHOULD]{.bcp14} be used to foster
privacy.[¶](#section-11.2-3){.pilcrow}

Note that streaming services [MAY]{.bcp14} contain content that may only
be accessed via DRM (digital rights management) systems. DRM systems can
prevent unauthorized access to content delivered via
ROUTE.[¶](#section-11.2-4){.pilcrow}
:::
:::
:::
:::

::: {#sect-12}
::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-12-1){.pilcrow}
:::
:::

::: {#section-13 .section}
## [13.](#section-13){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-13.1 .section}
### [13.1.](#section-13.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[ATSCA331\]
:   [Advanced Television Systems Committee]{.refAuthor}, [\"Signaling,
    Delivery, Synchronization, and Error Protection\"]{.refTitle}, [ATSC
    Standard A/331:2022-03]{.seriesInfo}, March 2022.
:   

\[RFC1952\]
:   [Deutsch, P.]{.refAuthor}, [\"GZIP file format specification version
    4.3\"]{.refTitle}, [RFC 1952]{.seriesInfo}, [DOI
    10.17487/RFC1952]{.seriesInfo}, May 1996,
    \<<https://www.rfc-editor.org/info/rfc1952>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC2557\]
:   [Palme, J.]{.refAuthor}, [Hopmann, A.]{.refAuthor}, and [N.
    Shelness]{.refAuthor}, [\"MIME Encapsulation of Aggregate Documents,
    such as HTML (MHTML)\"]{.refTitle}, [RFC 2557]{.seriesInfo}, [DOI
    10.17487/RFC2557]{.seriesInfo}, March 1999,
    \<<https://www.rfc-editor.org/info/rfc2557>\>.
:   

\[RFC3986\]
:   [Berners-Lee, T.]{.refAuthor}, [Fielding, R.]{.refAuthor}, and [L.
    Masinter]{.refAuthor}, [\"Uniform Resource Identifier (URI): Generic
    Syntax\"]{.refTitle}, [STD 66]{.seriesInfo}, [RFC
    3986]{.seriesInfo}, [DOI 10.17487/RFC3986]{.seriesInfo}, January
    2005, \<<https://www.rfc-editor.org/info/rfc3986>\>.
:   

\[RFC5052\]
:   [Watson, M.]{.refAuthor}, [Luby, M.]{.refAuthor}, and [L.
    Vicisano]{.refAuthor}, [\"Forward Error Correction (FEC) Building
    Block\"]{.refTitle}, [RFC 5052]{.seriesInfo}, [DOI
    10.17487/RFC5052]{.seriesInfo}, August 2007,
    \<<https://www.rfc-editor.org/info/rfc5052>\>.
:   

\[RFC5445\]
:   [Watson, M.]{.refAuthor}, [\"Basic Forward Error Correction (FEC)
    Schemes\"]{.refTitle}, [RFC 5445]{.seriesInfo}, [DOI
    10.17487/RFC5445]{.seriesInfo}, March 2009,
    \<<https://www.rfc-editor.org/info/rfc5445>\>.
:   

\[RFC5651\]
:   [Luby, M.]{.refAuthor}, [Watson, M.]{.refAuthor}, and [L.
    Vicisano]{.refAuthor}, [\"Layered Coding Transport (LCT) Building
    Block\"]{.refTitle}, [RFC 5651]{.seriesInfo}, [DOI
    10.17487/RFC5651]{.seriesInfo}, October 2009,
    \<<https://www.rfc-editor.org/info/rfc5651>\>.
:   

\[RFC5775\]
:   [Luby, M.]{.refAuthor}, [Watson, M.]{.refAuthor}, and [L.
    Vicisano]{.refAuthor}, [\"Asynchronous Layered Coding (ALC) Protocol
    Instantiation\"]{.refTitle}, [RFC 5775]{.seriesInfo}, [DOI
    10.17487/RFC5775]{.seriesInfo}, April 2010,
    \<<https://www.rfc-editor.org/info/rfc5775>\>.
:   

\[RFC6330\]
:   [Luby, M.]{.refAuthor}, [Shokrollahi, A.]{.refAuthor},
    [Watson, M.]{.refAuthor}, [Stockhammer, T.]{.refAuthor}, and [L.
    Minder]{.refAuthor}, [\"RaptorQ Forward Error Correction Scheme for
    Object Delivery\"]{.refTitle}, [RFC 6330]{.seriesInfo}, [DOI
    10.17487/RFC6330]{.seriesInfo}, August 2011,
    \<<https://www.rfc-editor.org/info/rfc6330>\>.
:   

\[RFC6363\]
:   [Watson, M.]{.refAuthor}, [Begen, A.]{.refAuthor}, and [V.
    Roca]{.refAuthor}, [\"Forward Error Correction (FEC)
    Framework\"]{.refTitle}, [RFC 6363]{.seriesInfo}, [DOI
    10.17487/RFC6363]{.seriesInfo}, October 2011,
    \<<https://www.rfc-editor.org/info/rfc6363>\>.
:   

\[RFC6726\]
:   [Paila, T.]{.refAuthor}, [Walsh, R.]{.refAuthor},
    [Luby, M.]{.refAuthor}, [Roca, V.]{.refAuthor}, and [R.
    Lehtonen]{.refAuthor}, [\"FLUTE - File Delivery over Unidirectional
    Transport\"]{.refTitle}, [RFC 6726]{.seriesInfo}, [DOI
    10.17487/RFC6726]{.seriesInfo}, November 2012,
    \<<https://www.rfc-editor.org/info/rfc6726>\>.
:   

\[RFC7231\]
:   [Fielding, R., Ed.]{.refAuthor} and [J. Reschke, Ed.]{.refAuthor},
    [\"Hypertext Transfer Protocol (HTTP/1.1): Semantics and
    Content\"]{.refTitle}, [RFC 7231]{.seriesInfo}, [DOI
    10.17487/RFC7231]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7231>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8551\]
:   [Schaad, J.]{.refAuthor}, [Ramsdell, B.]{.refAuthor}, and [S.
    Turner]{.refAuthor}, [\"Secure/Multipurpose Internet Mail Extensions
    (S/MIME) Version 4.0 Message Specification\"]{.refTitle}, [RFC
    8551]{.seriesInfo}, [DOI 10.17487/RFC8551]{.seriesInfo}, April 2019,
    \<<https://www.rfc-editor.org/info/rfc8551>\>.
:   
:::

::: {#section-13.2 .section}
### [13.2.](#section-13.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[CMAF\]
:   [International Organization for Standardization]{.refAuthor},
    [\"Information technology \-- Multimedia application format (MPEG-A)
    \-- Part 19: Common media application format (CMAF) for segmented
    media\"]{.refTitle}, [First edition]{.refContent}, [ISO/IEC FDIS
    23000-19]{.seriesInfo}, January 2018,
    \<<https://www.iso.org/standard/71975.html>\>.
:   

\[DASH\]
:   [International Organization for Standardization]{.refAuthor},
    [\"Information technology - Dynamic adaptive streaming over HTTP
    (DASH) - Part 1: Media presentation description and segment
    formats\"]{.refTitle}, [Fourth edition]{.refContent}, [ISO/IEC
    23009-1:2019]{.seriesInfo}, December 2019,
    \<<https://www.iso.org/standard/79329.html>\>.
:   

\[DVBMABR\]
:   [ETSI]{.refAuthor}, [\"Digital Video Broadcasting (DVB); Adaptive
    media streaming over IP multicast\"]{.refTitle}, [version
    1.1.1]{.refContent}, [ETSI TS 103 769]{.seriesInfo}, November 2020.
:   

\[HTTP3\]
:   [Bishop, M., Ed.]{.refAuthor}, [\"Hypertext Transfer Protocol
    Version 3 (HTTP/3)\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-quic-http-34]{.seriesInfo}, 2 February
    2021,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-quic-http-34>\>.
:   

\[MBMS\]
:   [ETSI]{.refAuthor}, [\"Universal Mobile Telecommunications Systems
    (UMTS); LTE; 5G; Multimedia Broadcast/Multicast Service (MBMS);
    Protocols and codecs\"]{.refTitle}, [version 16.9.1]{.refContent},
    [ETSI TS 126 346]{.seriesInfo}, May 2021.
:   

\[RFC3740\]
:   [Hardjono, T.]{.refAuthor} and [B. Weis]{.refAuthor}, [\"The
    Multicast Group Security Architecture\"]{.refTitle}, [RFC
    3740]{.seriesInfo}, [DOI 10.17487/RFC3740]{.seriesInfo}, March 2004,
    \<<https://www.rfc-editor.org/info/rfc3740>\>.
:   

\[RFC6968\]
:   [Roca, V.]{.refAuthor} and [B. Adamson]{.refAuthor}, [\"FCAST:
    Object Delivery for the Asynchronous Layered Coding (ALC) and
    NACK-Oriented Reliable Multicast (NORM) Protocols\"]{.refTitle},
    [RFC 6968]{.seriesInfo}, [DOI 10.17487/RFC6968]{.seriesInfo}, July
    2013, \<<https://www.rfc-editor.org/info/rfc6968>\>.
:   

\[RFC8932\]
:   [Dickinson, S.]{.refAuthor}, [Overeinder, B.]{.refAuthor}, [van
    Rijswijk-Deij, R.]{.refAuthor}, and [A. Mankin]{.refAuthor},
    [\"Recommendations for DNS Privacy Service Operators\"]{.refTitle},
    [BCP 232]{.seriesInfo}, [RFC 8932]{.seriesInfo}, [DOI
    10.17487/RFC8932]{.seriesInfo}, October 2020,
    \<<https://www.rfc-editor.org/info/rfc8932>\>.
:   

\[RFC9000\]
:   [Iyengar, J., Ed.]{.refAuthor} and [M. Thomson, Ed.]{.refAuthor},
    [\"QUIC: A UDP-Based Multiplexed and Secure Transport\"]{.refTitle},
    [RFC 9000]{.seriesInfo}, [DOI 10.17487/RFC9000]{.seriesInfo}, May
    2021, \<<https://www.rfc-editor.org/info/rfc9000>\>.
:   

\[RFC9147\]
:   [Rescorla, E.]{.refAuthor}, [Tschofenig, H.]{.refAuthor}, and [N.
    Modadugu]{.refAuthor}, [\"The Datagram Transport Layer Security
    (DTLS) Protocol Version 1.3\"]{.refTitle}, [RFC 9147]{.seriesInfo},
    [DOI 10.17487/RFC9147]{.seriesInfo}, April 2022,
    \<<https://www.rfc-editor.org/info/rfc9147>\>.
:   
:::
:::

::: {#sect-14}
::: {#appendix-A .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

As outlined in the introduction and in ROUTE concepts in [Section
9](#sect-9){.xref}, the concepts specified in this document are the
culmination of the collaborative work of several experts and
organizations over the years. The authors would especially like to
acknowledge the work and efforts of the following people and
organizations to help realize the technologies described in this
document (in no specific order): [Mike Luby]{.contact-name}, [Kent
Walker]{.contact-name}, [Charles Lo]{.contact-name}, and other
colleagues from Qualcomm Incorporated, LG Electronics, Nomor Research,
Sony, and BBC R&D.[¶](#appendix-A-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-B .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Waqar Zia]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Qualcomm CDMA Technologies GmbH]{.org}
:::

::: {.left dir="auto"}
[Anzinger Str. 13]{.street-address}
:::

::: {.left dir="auto"}
[81671]{.postal-code} [Munich]{.locality}
:::

::: {.left dir="auto"}
[Germany]{.country-name}
:::

::: email
Email: <wzia@qti.qualcomm.com>
:::

::: {.left dir="auto"}
[Thomas Stockhammer]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Qualcomm CDMA Technologies GmbH]{.org}
:::

::: {.left dir="auto"}
[Anzinger Str. 13]{.street-address}
:::

::: {.left dir="auto"}
[81671]{.postal-code} [Munich]{.locality}
:::

::: {.left dir="auto"}
[Germany]{.country-name}
:::

::: email
Email: <tsto@qti.qualcomm.com>
:::

::: {.left dir="auto"}
[Lenaig Chaponniere]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Qualcomm Technologies Inc.]{.org}
:::

::: {.left dir="auto"}
[5775 Morehouse Drive]{.street-address}
:::

::: {.left dir="auto"}
[San Diego]{.locality}, [CA]{.region} [92121]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <lguellec@qti.qualcomm.com>
:::

::: {.left dir="auto"}
[Giridhar Mandyam]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Qualcomm Technologies Inc.]{.org}
:::

::: {.left dir="auto"}
[5775 Morehouse Drive]{.street-address}
:::

::: {.left dir="auto"}
[San Diego]{.locality}, [CA]{.region} [92121]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <mandyam@qti.qualcomm.com>
:::

::: {.left dir="auto"}
[Michael Luby]{.fn .nameRole}
:::

::: {.left dir="auto"}
[BitRipple, Inc.]{.org}
:::

::: {.left dir="auto"}
[1133 Miller Ave]{.street-address}
:::

::: {.left dir="auto"}
[Berkeley]{.locality}, [CA]{.region} [94708]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <luby@bitripple.com>
:::
:::
:::
