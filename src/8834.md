  RFC 8834          RTP for WebRTC    January 2021
  ----------------- ----------------- --------------
  Perkins, et al.   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8834](https://www.rfc-editor.org/rfc/rfc8834){.eref}

Category:
:   Standards Track

Published:
:   January 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    C. Perkins
    :::

    ::: org
    University of Glasgow
    :::
    :::

    ::: author
    ::: author-name
    M. Westerlund
    :::

    ::: org
    Ericsson
    :::
    :::

    ::: author
    ::: author-name
    J. Ott
    :::

    ::: org
    Technical University Munich
    :::
    :::
:::

# RFC 8834 {#rfcnum}

# Media Transport and Use of RTP in WebRTC {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

The framework for Web Real-Time Communication (WebRTC) provides support
for direct interactive rich communication using audio, video, text,
collaboration, games, etc. between two peers\' web browsers. This memo
describes the media transport aspects of the WebRTC framework. It
specifies how the Real-time Transport Protocol (RTP) is used in the
WebRTC context and gives requirements for which RTP features, profiles,
and extensions need to be supported.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8834>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Rationale](#name-rationale){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [WebRTC Use of RTP: Core
    Protocols](#name-webrtc-use-of-rtp-core-prot){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [RTP and
        RTCP](#name-rtp-and-rtcp){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Choice of the RTP
        Profile](#name-choice-of-the-rtp-profile){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Choice of RTP Payload
        Formats](#name-choice-of-rtp-payload-forma){.xref}[¶](#section-toc.1-1.4.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Use of RTP
        Sessions](#name-use-of-rtp-sessions){.xref}[¶](#section-toc.1-1.4.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [RTP and RTCP
        Multiplexing](#name-rtp-and-rtcp-multiplexing){.xref}[¶](#section-toc.1-1.4.2.5.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.6}
        [4.6](#section-4.6){.xref}.  [Reduced Size
        RTCP](#name-reduced-size-rtcp){.xref}[¶](#section-toc.1-1.4.2.6.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.7}
        [4.7](#section-4.7){.xref}.  [Symmetric
        RTP/RTCP](#name-symmetric-rtp-rtcp){.xref}[¶](#section-toc.1-1.4.2.7.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.8}
        [4.8](#section-4.8){.xref}.  [Choice of RTP Synchronization
        Source
        (SSRC)](#name-choice-of-rtp-synchronizati){.xref}[¶](#section-toc.1-1.4.2.8.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.9}
        [4.9](#section-4.9){.xref}.  [Generation of the RTCP Canonical
        Name
        (CNAME)](#name-generation-of-the-rtcp-cano){.xref}[¶](#section-toc.1-1.4.2.9.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.10}
        [4.10](#section-4.10){.xref}. [Handling of Leap
        Seconds](#name-handling-of-leap-seconds){.xref}[¶](#section-toc.1-1.4.2.10.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [WebRTC Use of RTP:
    Extensions](#name-webrtc-use-of-rtp-extension){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Conferencing Extensions and
        Topologies](#name-conferencing-extensions-and){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.5.2.1.2.1}
            [5.1.1](#section-5.1.1){.xref}.  [Full Intra Request
            (FIR)](#name-full-intra-request-fir){.xref}[¶](#section-toc.1-1.5.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.2}
            [5.1.2](#section-5.1.2){.xref}.  [Picture Loss Indication
            (PLI)](#name-picture-loss-indication-pli){.xref}[¶](#section-toc.1-1.5.2.1.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.3}
            [5.1.3](#section-5.1.3){.xref}.  [Slice Loss Indication
            (SLI)](#name-slice-loss-indication-sli){.xref}[¶](#section-toc.1-1.5.2.1.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.4}
            [5.1.4](#section-5.1.4){.xref}.  [Reference Picture
            Selection Indication
            (RPSI)](#name-reference-picture-selection){.xref}[¶](#section-toc.1-1.5.2.1.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.5}
            [5.1.5](#section-5.1.5){.xref}.  [Temporal-Spatial Trade-Off
            Request
            (TSTR)](#name-temporal-spatial-trade-off-){.xref}[¶](#section-toc.1-1.5.2.1.2.5.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.6}
            [5.1.6](#section-5.1.6){.xref}.  [Temporary Maximum Media
            Stream Bit Rate Request
            (TMMBR)](#name-temporary-maximum-media-str){.xref}[¶](#section-toc.1-1.5.2.1.2.6.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Header
        Extensions](#name-header-extensions){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.5.2.2.2.1}
            [5.2.1](#section-5.2.1){.xref}.  [Rapid
            Synchronization](#name-rapid-synchronization){.xref}[¶](#section-toc.1-1.5.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.2}
            [5.2.2](#section-5.2.2){.xref}.  [Client-to-Mixer Audio
            Level](#name-client-to-mixer-audio-level){.xref}[¶](#section-toc.1-1.5.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.3}
            [5.2.3](#section-5.2.3){.xref}.  [Mixer-to-Client Audio
            Level](#name-mixer-to-client-audio-level){.xref}[¶](#section-toc.1-1.5.2.2.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.4}
            [5.2.4](#section-5.2.4){.xref}.  [Media Stream
            Identification](#name-media-stream-identification){.xref}[¶](#section-toc.1-1.5.2.2.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.5}
            [5.2.5](#section-5.2.5){.xref}.  [Coordination of Video
            Orientation](#name-coordination-of-video-orien){.xref}[¶](#section-toc.1-1.5.2.2.2.5.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [WebRTC Use of RTP: Improving Transport
    Robustness](#name-webrtc-use-of-rtp-improving){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Negative Acknowledgements and RTP
        Retransmission](#name-negative-acknowledgements-a){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Forward Error Correction
        (FEC)](#name-forward-error-correction-fe){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [WebRTC Use of RTP: Rate Control and Media
    Adaptation](#name-webrtc-use-of-rtp-rate-cont){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Boundary Conditions and Circuit
        Breakers](#name-boundary-conditions-and-cir){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Congestion Control
        Interoperability and Legacy
        Systems](#name-congestion-control-interope){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [WebRTC Use of RTP: Performance
    Monitoring](#name-webrtc-use-of-rtp-performan){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [WebRTC Use of RTP: Future
    Extensions](#name-webrtc-use-of-rtp-future-ex){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Signaling
    Considerations](#name-signaling-considerations){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [WebRTC API
    Considerations](#name-webrtc-api-considerations){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [RTP Implementation
    Considerations](#name-rtp-implementation-consider){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}

    -   ::: {#section-toc.1-1.12.2.1}
        [12.1](#section-12.1){.xref}.  [Configuration and Use of RTP
        Sessions](#name-configuration-and-use-of-rt){.xref}[¶](#section-toc.1-1.12.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.12.2.1.2.1}
            [12.1.1](#section-12.1.1){.xref}.  [Use of Multiple Media
            Sources within an RTP
            Session](#name-use-of-multiple-media-sourc){.xref}[¶](#section-toc.1-1.12.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.12.2.1.2.2}
            [12.1.2](#section-12.1.2){.xref}.  [Use of Multiple RTP
            Sessions](#name-use-of-multiple-rtp-session){.xref}[¶](#section-toc.1-1.12.2.1.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.12.2.1.2.3}
            [12.1.3](#section-12.1.3){.xref}.  [Differentiated Treatment
            of RTP
            Streams](#name-differentiated-treatment-of){.xref}[¶](#section-toc.1-1.12.2.1.2.3.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [12.2](#section-12.2){.xref}.  [Media Source, RTP Streams, and
        Participant
        Identification](#name-media-source-rtp-streams-an){.xref}[¶](#section-toc.1-1.12.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.12.2.2.2.1}
            [12.2.1](#section-12.2.1){.xref}.  [Media Source
            Identification](#name-media-source-identification){.xref}[¶](#section-toc.1-1.12.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.12.2.2.2.2}
            [12.2.2](#section-12.2.2){.xref}.  [SSRC Collision
            Detection](#name-ssrc-collision-detection){.xref}[¶](#section-toc.1-1.12.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.12.2.2.2.3}
            [12.2.3](#section-12.2.3){.xref}.  [Media Synchronization
            Context](#name-media-synchronization-conte){.xref}[¶](#section-toc.1-1.12.2.2.2.3.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [13](#section-13){.xref}. [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.14}
    [14](#section-14){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.15}
    [15](#section-15){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.15.1){.pilcrow}

    -   ::: {#section-toc.1-1.15.2.1}
        [15.1](#section-15.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.15.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.15.2.2}
        [15.2](#section-15.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.15.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.16}
    [](#section-appendix.a){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.16.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.17}
    [](#section-appendix.b){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.17.1){.pilcrow}
    :::
:::
:::

::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The [Real-time Transport Protocol (RTP)](#RFC3550){.xref}
\[[RFC3550](#RFC3550){.xref}\] provides a framework for delivery of
audio and video teleconferencing data and other real-time media
applications. Previous work has defined the RTP protocol, along with
numerous profiles, payload formats, and other extensions. When combined
with appropriate signaling, these form the basis for many
teleconferencing systems.[¶](#section-1-1){.pilcrow}

The Web Real-Time Communication (WebRTC) framework provides the protocol
building blocks to support direct, interactive, real-time communication
using audio, video, collaboration, games, etc. between two peers\' web
browsers. This memo describes how the RTP framework is to be used in the
WebRTC context. It proposes a baseline set of RTP features that are to
be implemented by all WebRTC endpoints, along with suggested extensions
for enhanced functionality.[¶](#section-1-2){.pilcrow}

This memo specifies a protocol intended for use within the WebRTC
framework but is not restricted to that context. An overview of the
WebRTC framework is given in
\[[RFC8825](#RFC8825){.xref}\].[¶](#section-1-3){.pilcrow}

The structure of this memo is as follows. [Section
2](#sec-rationale){.xref} outlines our rationale for preparing this memo
and choosing these RTP features. [Section 3](#sec-terminology){.xref}
defines terminology. Requirements for core RTP protocols are described
in [Section 4](#sec-rtp-core){.xref}, and suggested RTP extensions are
described in [Section 5](#sec-rtp-extn){.xref}. [Section
6](#sec-rtp-robust){.xref} outlines mechanisms that can increase
robustness to network problems, while [Section
7](#sec-rate-control){.xref} describes congestion control and rate
adaptation mechanisms. The discussion of mandated RTP mechanisms
concludes in [Section 8](#sec-perf){.xref} with a review of performance
monitoring and network management tools. [Section 9](#sec-extn){.xref}
gives some guidelines for future incorporation of other RTP and RTP
Control Protocol (RTCP) extensions into this framework. [Section
10](#sec-signalling){.xref} describes requirements placed on the
signaling channel. [Section 11](#sec-webrtc-api){.xref} discusses the
relationship between features of the RTP framework and the WebRTC
application programming interface (API), and [Section
12](#sec-rtp-func){.xref} discusses RTP implementation considerations.
The memo concludes with [security considerations](#sec-security){.xref}
([Section 13](#sec-security){.xref}) and [IANA
considerations](#sec-iana){.xref} ([Section
14](#sec-iana){.xref}).[¶](#section-1-4){.pilcrow}
:::

::: {#sec-rationale}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Rationale](#name-rationale){.section-name .selfRef} {#name-rationale}

The RTP framework comprises the RTP data transfer protocol, the RTP
control protocol, and numerous RTP payload formats, profiles, and
extensions. This range of add-ons has allowed RTP to meet various needs
that were not envisaged by the original protocol designers and support
many new media encodings, but it raises the question of what extensions
are to be supported by new implementations. The development of the
WebRTC framework provides an opportunity to review the available RTP
features and extensions and define a common baseline RTP feature set for
all WebRTC endpoints. This builds on the past 20 years of RTP
development to mandate the use of extensions that have shown widespread
utility, while still remaining compatible with the wide installed base
of RTP implementations where possible.[¶](#section-2-1){.pilcrow}

RTP and RTCP extensions that are not discussed in this document can be
implemented by WebRTC endpoints if they are beneficial for new use
cases. However, they are not necessary to address the WebRTC use cases
and requirements identified in
\[[RFC7478](#RFC7478){.xref}\].[¶](#section-2-2){.pilcrow}

While the baseline set of RTP features and extensions defined in this
memo is targeted at the requirements of the WebRTC framework, it is
expected to be broadly useful for other conferencing-related uses of
RTP. In particular, it is likely that this set of RTP features and
extensions will be appropriate for other desktop or mobile
video-conferencing systems, or for room-based high-quality telepresence
applications.[¶](#section-2-3){.pilcrow}
:::
:::

::: {#sec-terminology}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here. Lower- or mixed-case uses of these key words
are not to be interpreted as carrying special significance in this
memo.[¶](#section-3-1){.pilcrow}

We define the following additional terms:[¶](#section-3-2){.pilcrow}

[]{.break}

WebRTC MediaStream:
:   The MediaStream concept defined by the W3C in the [WebRTC
    API](#W3C.WD-mediacapture-streams){.xref}
    \[[W3C.WD-mediacapture-streams](#W3C.WD-mediacapture-streams){.xref}\].
    A MediaStream consists of zero or more
    MediaStreamTracks.[¶](#section-3-3.2){.pilcrow}
:   

MediaStreamTrack:
:   Part of the MediaStream concept defined by the W3C in the [WebRTC
    API](#W3C.WD-mediacapture-streams){.xref}
    \[[W3C.WD-mediacapture-streams](#W3C.WD-mediacapture-streams){.xref}\].
    A MediaStreamTrack is an individual stream of media from any type of
    media source such as a microphone or a camera, but conceptual
    sources such as an audio mix or a video composition are also
    possible.[¶](#section-3-3.4){.pilcrow}
:   

Transport-layer flow:
:   A unidirectional flow of transport packets that are identified by a
    particular 5-tuple of source IP address, source port, destination IP
    address, destination port, and transport
    protocol.[¶](#section-3-3.6){.pilcrow}
:   

Bidirectional transport-layer flow:
:   A bidirectional transport-layer flow is a transport-layer flow that
    is symmetric. That is, the transport-layer flow in the reverse
    direction has a 5-tuple where the source and destination address and
    ports are swapped compared to the forward path transport-layer flow,
    and the transport protocol is the same.[¶](#section-3-3.8){.pilcrow}
:   

This document uses the terminology from \[[RFC7656](#RFC7656){.xref}\]
and \[[RFC8825](#RFC8825){.xref}\]. Other terms are used according to
their definitions from the [RTP specification](#RFC3550){.xref}
\[[RFC3550](#RFC3550){.xref}\]. In particular, note the following
frequently used terms: RTP stream, RTP session, and
endpoint.[¶](#section-3-4){.pilcrow}
:::
:::

::: {#sec-rtp-core}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [WebRTC Use of RTP: Core Protocols](#name-webrtc-use-of-rtp-core-prot){.section-name .selfRef} {#name-webrtc-use-of-rtp-core-prot}

The following sections describe the core features of RTP and RTCP that
need to be implemented, along with the mandated RTP profiles. Also
described are the core extensions providing essential features that all
WebRTC endpoints need to implement to function effectively on today\'s
networks.[¶](#section-4-1){.pilcrow}

::: {#sec-rtp-rtcp}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [RTP and RTCP](#name-rtp-and-rtcp){.section-name .selfRef} {#name-rtp-and-rtcp}

The [Real-time Transport Protocol (RTP)](#RFC3550){.xref}
\[[RFC3550](#RFC3550){.xref}\] is [REQUIRED]{.bcp14} to be implemented
as the media transport protocol for WebRTC. RTP itself comprises two
parts: the RTP data transfer protocol and the RTP Control Protocol
(RTCP). RTCP is a fundamental and integral part of RTP and
[MUST]{.bcp14} be implemented and used in all WebRTC
endpoints.[¶](#section-4.1-1){.pilcrow}

The following RTP and RTCP features are sometimes omitted in
limited-functionality implementations of RTP, but they are
[REQUIRED]{.bcp14} in all WebRTC endpoints:[¶](#section-4.1-2){.pilcrow}

-   [Support for use of multiple simultaneous synchronization source
    (SSRC) values in a single RTP session, including support for RTP
    endpoints that send many SSRC values simultaneously, following
    \[[RFC3550](#RFC3550){.xref}\] and \[[RFC8108](#RFC8108){.xref}\].
    The RTCP optimizations for multi-SSRC sessions defined in
    \[[RFC8861](#RFC8861){.xref}\] [MAY]{.bcp14} be supported; if
    supported, the usage [MUST]{.bcp14} be
    signaled.[¶](#section-4.1-3.1){.pilcrow}]{#section-4.1-3.1}
-   [Random choice of SSRC on joining a session; collision detection and
    resolution for SSRC values (see also [Section
    4.8](#sec-ssrc){.xref}).[¶](#section-4.1-3.2){.pilcrow}]{#section-4.1-3.2}
-   [Support for reception of RTP data packets containing contributing
    source (CSRC) lists, as generated by RTP mixers, and RTCP packets
    relating to CSRCs.[¶](#section-4.1-3.3){.pilcrow}]{#section-4.1-3.3}
-   [Sending correct synchronization information in the RTCP Sender
    Reports, to allow receivers to implement lip synchronization; see
    [Section 5.2.1](#rapid-sync){.xref} regarding support for the rapid
    RTP synchronization
    extensions.[¶](#section-4.1-3.4){.pilcrow}]{#section-4.1-3.4}
-   [Support for multiple synchronization contexts. Participants that
    send multiple simultaneous RTP packet streams [SHOULD]{.bcp14} do so
    as part of a single synchronization context, using a single RTCP
    CNAME for all streams and allowing receivers to play the streams out
    in a synchronized manner. For compatibility with potential future
    versions of this specification, or for interoperability with
    non-WebRTC devices through a gateway, receivers [MUST]{.bcp14}
    support multiple synchronization contexts, indicated by the use of
    multiple RTCP CNAMEs in an RTP session. This specification mandates
    the usage of a single CNAME when sending RTP streams in some
    circumstances; see [Section
    4.9](#sec-cname){.xref}.[¶](#section-4.1-3.5){.pilcrow}]{#section-4.1-3.5}
-   [Support for sending and receiving RTCP Sender Report (SR), Receiver
    Report (RR), Source Description (SDES), and BYE packet types. Note
    that support for other RTCP packet types is [OPTIONAL]{.bcp14}
    unless mandated by other parts of this specification. Note that
    additional RTCP packet types are used by the [RTP/SAVPF
    profile](#sec-profile){.xref} ([Section 4.2](#sec-profile){.xref})
    and the other [RTCP extensions](#sec-rtp-extn){.xref} ([Section
    5](#sec-rtp-extn){.xref}). WebRTC endpoints that implement the
    Session Description Protocol (SDP) bundle negotiation extension will
    use the SDP Grouping Framework \"mid\" attribute to identify media
    streams. Such endpoints [MUST]{.bcp14} implement the RTCP SDES media
    identification (MID) item described in
    \[[RFC8843](#RFC8843){.xref}\].[¶](#section-4.1-3.6){.pilcrow}]{#section-4.1-3.6}
-   [Support for multiple endpoints in a single RTP session, and for
    scaling the RTCP transmission interval according to the number of
    participants in the session; support for randomized RTCP
    transmission intervals to avoid synchronization of RTCP reports;
    support for RTCP timer reconsideration ([Section
    6.3.6](https://www.rfc-editor.org/rfc/rfc3550#section-6.3.6){.relref}
    of \[[RFC3550](#RFC3550){.xref}\]) and reverse reconsideration
    ([Section
    6.3.4](https://www.rfc-editor.org/rfc/rfc3550#section-6.3.4){.relref}
    of
    \[[RFC3550](#RFC3550){.xref}\]).[¶](#section-4.1-3.7){.pilcrow}]{#section-4.1-3.7}
-   [Support for configuring the RTCP bandwidth as a fraction of the
    media bandwidth, and for configuring the fraction of the RTCP
    bandwidth allocated to senders \-- e.g., using the SDP \"b=\" line
    \[[RFC4566](#RFC4566){.xref}\]
    \[[RFC3556](#RFC3556){.xref}\].[¶](#section-4.1-3.8){.pilcrow}]{#section-4.1-3.8}
-   [Support for the reduced minimum RTCP reporting interval described
    in [Section
    6.2](https://www.rfc-editor.org/rfc/rfc3550#section-6.2){.relref} of
    \[[RFC3550](#RFC3550){.xref}\]. When using the reduced minimum RTCP
    reporting interval, the fixed (nonreduced) minimum interval
    [MUST]{.bcp14} be used when calculating the participant timeout
    interval (see Sections
    [6.2](https://www.rfc-editor.org/rfc/rfc3550#section-6.2){.relref}
    and
    [6.3.5](https://www.rfc-editor.org/rfc/rfc3550#section-6.3.5){.relref}
    of \[[RFC3550](#RFC3550){.xref}\]). The delay before sending the
    initial compound RTCP packet can be set to zero (see [Section
    6.2](https://www.rfc-editor.org/rfc/rfc3550#section-6.2){.relref} of
    \[[RFC3550](#RFC3550){.xref}\] as updated by
    \[[RFC8108](#RFC8108){.xref}\]).[¶](#section-4.1-3.9){.pilcrow}]{#section-4.1-3.9}
-   [Support for discontinuous transmission. RTP allows endpoints to
    pause and resume transmission at any time. When resuming, the RTP
    sequence number will increase by one, as usual, while the increase
    in the RTP timestamp value will depend on the duration of the pause.
    Discontinuous transmission is most commonly used with some audio
    payload formats, but it is not audio specific and can be used with
    any RTP payload
    format.[¶](#section-4.1-3.10){.pilcrow}]{#section-4.1-3.10}
-   [Ignore unknown RTCP packet types and RTP header extensions. This is
    to ensure robust handling of future extensions, middlebox behaviors,
    etc., that can result in receiving RTP header extensions or RTCP
    packet types that were not signaled. If a compound RTCP packet that
    contains a mixture of known and unknown RTCP packet types is
    received, the known packet types need to be processed as usual, with
    only the unknown packet types being
    discarded.[¶](#section-4.1-3.11){.pilcrow}]{#section-4.1-3.11}

It is known that a significant number of legacy RTP implementations,
especially those targeted at systems with only Voice over IP (VoIP), do
not support all of the above features and in some cases do not support
RTCP at all. Implementers are advised to consider the requirements for
graceful degradation when interoperating with legacy
implementations.[¶](#section-4.1-4){.pilcrow}

Other implementation considerations are discussed in [Section
12](#sec-rtp-func){.xref}.[¶](#section-4.1-5){.pilcrow}
:::
:::

::: {#sec-profile}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Choice of the RTP Profile](#name-choice-of-the-rtp-profile){.section-name .selfRef} {#name-choice-of-the-rtp-profile}

The complete specification of RTP for a particular application domain
requires the choice of an RTP profile. For WebRTC use, the [extended
secure RTP profile for RTCP-based feedback (RTP/SAVPF)](#RFC5124){.xref}
\[[RFC5124](#RFC5124){.xref}\], as extended by
\[[RFC7007](#RFC7007){.xref}\], [MUST]{.bcp14} be implemented. The
RTP/SAVPF profile is the combination of the basic [RTP/AVP
profile](#RFC3551){.xref} \[[RFC3551](#RFC3551){.xref}\], the [RTP
profile for RTCP-based feedback (RTP/AVPF)](#RFC4585){.xref}
\[[RFC4585](#RFC4585){.xref}\], and the [secure RTP profile
(RTP/SAVP)](#RFC3711){.xref}
\[[RFC3711](#RFC3711){.xref}\].[¶](#section-4.2-1){.pilcrow}

The RTCP-based feedback extensions \[[RFC4585](#RFC4585){.xref}\] are
needed for the improved RTCP timer model. This allows more flexible
transmission of RTCP packets in response to events, rather than strictly
according to bandwidth, and is vital for being able to report congestion
signals as well as media events. These extensions also allow saving RTCP
bandwidth, and an endpoint will commonly only use the full RTCP
bandwidth allocation if there are many events that require feedback. The
timer rules are also needed to make use of the RTP conferencing
extensions discussed in [Section
5.1](#conf-ext){.xref}.[¶](#section-4.2-2){.pilcrow}

Note: The enhanced RTCP timer model defined in the RTP/AVPF profile is
backwards compatible with legacy systems that implement only the RTP/AVP
or RTP/SAVP profile, given some constraints on parameter configuration
such as the RTCP bandwidth value and \"trr‑int\". The most important
factor for interworking with RTP/(S)AVP endpoints via a gateway is to
set the \"trr-int\" parameter to a value representing 4 seconds; see
[Section
7.1.3](https://www.rfc-editor.org/rfc/rfc8108#section-7.1.3){.relref} of
\[[RFC8108](#RFC8108){.xref}\].[¶](#section-4.2-3.1){.pilcrow}

The secure RTP (SRTP) profile extensions \[[RFC3711](#RFC3711){.xref}\]
are needed to provide media encryption, integrity protection, replay
protection, and a limited form of source authentication. WebRTC
endpoints [MUST NOT]{.bcp14} send packets using the basic RTP/AVP
profile or the RTP/AVPF profile; they [MUST]{.bcp14} employ the full
RTP/SAVPF profile to protect all RTP and RTCP packets that are
generated. In other words, implementations [MUST]{.bcp14} use SRTP and
Secure RTCP (SRTCP). The RTP/SAVPF profile [MUST]{.bcp14} be configured
using the cipher suites, DTLS-SRTP protection profiles, keying
mechanisms, and other parameters described in
\[[RFC8827](#RFC8827){.xref}\].[¶](#section-4.2-4){.pilcrow}
:::
:::

::: {#sec.codecs}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Choice of RTP Payload Formats](#name-choice-of-rtp-payload-forma){.section-name .selfRef} {#name-choice-of-rtp-payload-forma}

Mandatory-to-implement audio codecs and RTP payload formats for WebRTC
endpoints are defined in \[[RFC7874](#RFC7874){.xref}\].
Mandatory-to-implement video codecs and RTP payload formats for WebRTC
endpoints are defined in \[[RFC7742](#RFC7742){.xref}\]. WebRTC
endpoints [MAY]{.bcp14} additionally implement any other codec for which
an RTP payload format and associated signaling has been
defined.[¶](#section-4.3-1){.pilcrow}

WebRTC endpoints cannot assume that the other participants in an RTP
session understand any RTP payload format, no matter how common. The
mapping between RTP payload type numbers and specific configurations of
particular RTP payload formats [MUST]{.bcp14} be agreed before those
payload types/formats can be used. In an SDP context, this can be done
using the \"a=rtpmap:\" and \"a=fmtp:\" attributes associated with an
\"m=\" line, along with any other SDP attributes needed to configure the
RTP payload format.[¶](#section-4.3-2){.pilcrow}

Endpoints can signal support for multiple RTP payload formats or
multiple configurations of a single RTP payload format, as long as each
unique RTP payload format configuration uses a different RTP payload
type number. As outlined in [Section 4.8](#sec-ssrc){.xref}, the RTP
payload type number is sometimes used to associate an RTP packet stream
with a signaling context. This association is possible provided unique
RTP payload type numbers are used in each context. For example, an RTP
packet stream can be associated with an SDP \"m=\" line by comparing the
RTP payload type numbers used by the RTP packet stream with payload
types signaled in the \"a=rtpmap:\" lines in the media sections of the
SDP. This leads to the following
considerations:[¶](#section-4.3-3){.pilcrow}

-   [If RTP packet streams are being associated with signaling contexts
    based on the RTP payload type, then the assignment of RTP payload
    type numbers [MUST]{.bcp14} be unique across signaling
    contexts.[¶](#section-4.3-4.1){.pilcrow}]{#section-4.3-4.1}
-   [If the same RTP payload format configuration is used in multiple
    contexts, then a different RTP payload type number has to be
    assigned in each context to ensure
    uniqueness.[¶](#section-4.3-4.2){.pilcrow}]{#section-4.3-4.2}
-   [If the RTP payload type number is not being used to associate RTP
    packet streams with a signaling context, then the same RTP payload
    type number can be used to indicate the exact same RTP payload
    format configuration in multiple
    contexts.[¶](#section-4.3-4.3){.pilcrow}]{#section-4.3-4.3}

A single RTP payload type number [MUST NOT]{.bcp14} be assigned to
different RTP payload formats, or different configurations of the same
RTP payload format, within a single RTP session (note that the \"m=\"
lines in an [SDP BUNDLE group](#RFC8843){.xref}
\[[RFC8843](#RFC8843){.xref}\] form a single RTP
session).[¶](#section-4.3-5){.pilcrow}

An endpoint that has signaled support for multiple RTP payload formats
[MUST]{.bcp14} be able to accept data in any of those payload formats at
any time, unless it has previously signaled limitations on its decoding
capability. This requirement is constrained if several types of media
(e.g., audio and video) are sent in the same RTP session. In such a
case, a source (SSRC) is restricted to switching only between the RTP
payload formats signaled for the type of media that is being sent by
that source; see [Section 4.4](#sec.session-mux){.xref}. To support
rapid rate adaptation by changing codecs, RTP does not require advance
signaling for changes between RTP payload formats used by a single SSRC
that were signaled during session setup.[¶](#section-4.3-6){.pilcrow}

If performing changes between two RTP payload types that use different
RTP clock rates, an RTP sender [MUST]{.bcp14} follow the recommendations
in [Section
4.1](https://www.rfc-editor.org/rfc/rfc7160#section-4.1){.relref} of
\[[RFC7160](#RFC7160){.xref}\]. RTP receivers [MUST]{.bcp14} follow the
recommendations in [Section
4.3](https://www.rfc-editor.org/rfc/rfc7160#section-4.3){.relref} of
\[[RFC7160](#RFC7160){.xref}\] in order to support sources that switch
between clock rates in an RTP session. These recommendations for
receivers are backwards compatible with the case where senders use only
a single clock rate.[¶](#section-4.3-7){.pilcrow}
:::
:::

::: {#sec.session-mux}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Use of RTP Sessions](#name-use-of-rtp-sessions){.section-name .selfRef} {#name-use-of-rtp-sessions}

An association amongst a set of endpoints communicating using RTP is
known as an RTP session \[[RFC3550](#RFC3550){.xref}\]. An endpoint can
be involved in several RTP sessions at the same time. In a multimedia
session, each type of media has typically been carried in a separate RTP
session (e.g., using one RTP session for the audio and a separate RTP
session using a different transport-layer flow for the video). WebRTC
endpoints are [REQUIRED]{.bcp14} to implement support for multimedia
sessions in this way, separating each RTP session using different
transport-layer flows for compatibility with legacy systems (this is
sometimes called session multiplexing).[¶](#section-4.4-1){.pilcrow}

In modern-day networks, however, with the widespread use of network
address/port translators (NAT/NAPT) and firewalls, it is desirable to
reduce the number of transport-layer flows used by RTP applications.
This can be done by sending all the RTP packet streams in a single RTP
session, which will comprise a single transport-layer flow. This will
prevent the use of some quality-of-service mechanisms, as discussed in
[Section 12.1.3](#sec-differentiated){.xref}. Implementations are
therefore also [REQUIRED]{.bcp14} to support transport of all RTP packet
streams, independent of media type, in a single RTP session using a
single transport-layer flow, according to \[[RFC8860](#RFC8860){.xref}\]
(this is sometimes called SSRC multiplexing). If multiple types of media
are to be used in a single RTP session, all participants in that RTP
session [MUST]{.bcp14} agree to this usage. In an SDP context, the
mechanisms described in \[[RFC8843](#RFC8843){.xref}\] can be used to
signal such a bundle of RTP packet streams forming a single RTP
session.[¶](#section-4.4-2){.pilcrow}

Further discussion about the suitability of different RTP session
structures and multiplexing methods to different scenarios can be found
in \[[RFC8872](#RFC8872){.xref}\].[¶](#section-4.4-3){.pilcrow}
:::
:::

::: {#sec.rtcp-mux}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [RTP and RTCP Multiplexing](#name-rtp-and-rtcp-multiplexing){.section-name .selfRef} {#name-rtp-and-rtcp-multiplexing}

Historically, RTP and RTCP have been run on separate transport-layer
flows (e.g., two UDP ports for each RTP session, one for RTP and one for
RTCP). With the increased use of Network Address/Port Translation
(NAT/NAPT), this has become problematic, since maintaining multiple NAT
bindings can be costly. It also complicates firewall administration,
since multiple ports need to be opened to allow RTP traffic. To reduce
these costs and session setup times, implementations are
[REQUIRED]{.bcp14} to support multiplexing RTP data packets and RTCP
control packets on a single transport-layer flow
\[[RFC5761](#RFC5761){.xref}\]. Such RTP and RTCP multiplexing
[MUST]{.bcp14} be negotiated in the signaling channel before it is used.
If SDP is used for signaling, this negotiation [MUST]{.bcp14} use the
mechanism defined in \[[RFC5761](#RFC5761){.xref}\]. Implementations can
also support sending RTP and RTCP on separate transport-layer flows, but
this is [OPTIONAL]{.bcp14} to implement. If an implementation does not
support RTP and RTCP sent on separate transport-layer flows, it
[MUST]{.bcp14} indicate that using the mechanism defined in
\[[RFC8858](#RFC8858){.xref}\].[¶](#section-4.5-1){.pilcrow}

Note that the use of RTP and RTCP multiplexed onto a single
transport-layer flow ensures that there is occasional traffic sent on
that port, even if there is no active media traffic. This can be useful
to keep NAT bindings alive
\[[RFC6263](#RFC6263){.xref}\].[¶](#section-4.5-2){.pilcrow}
:::
:::

::: {#section-4.6 .section}
### [4.6.](#section-4.6){.section-number .selfRef} [Reduced Size RTCP](#name-reduced-size-rtcp){.section-name .selfRef} {#name-reduced-size-rtcp}

RTCP packets are usually sent as compound RTCP packets, and
\[[RFC3550](#RFC3550){.xref}\] requires that those compound packets
start with an SR or RR packet. When using frequent RTCP feedback
messages under the RTP/AVPF profile \[[RFC4585](#RFC4585){.xref}\],
these statistics are not needed in every packet, and they unnecessarily
increase the mean RTCP packet size. This can limit the frequency at
which RTCP packets can be sent within the RTCP bandwidth
share.[¶](#section-4.6-1){.pilcrow}

To avoid this problem, \[[RFC5506](#RFC5506){.xref}\] specifies how to
reduce the mean RTCP message size and allow for more frequent feedback.
Frequent feedback, in turn, is essential to make real-time applications
quickly aware of changing network conditions and to allow them to adapt
their transmission and encoding behavior. Implementations [MUST]{.bcp14}
support sending and receiving noncompound RTCP feedback packets
\[[RFC5506](#RFC5506){.xref}\]. Use of noncompound RTCP packets
[MUST]{.bcp14} be negotiated using the signaling channel. If SDP is used
for signaling, this negotiation [MUST]{.bcp14} use the attributes
defined in \[[RFC5506](#RFC5506){.xref}\]. For backwards compatibility,
implementations are also [REQUIRED]{.bcp14} to support the use of
compound RTCP feedback packets if the remote endpoint does not agree to
the use of noncompound RTCP in the signaling
exchange.[¶](#section-4.6-2){.pilcrow}
:::

::: {#section-4.7 .section}
### [4.7.](#section-4.7){.section-number .selfRef} [Symmetric RTP/RTCP](#name-symmetric-rtp-rtcp){.section-name .selfRef} {#name-symmetric-rtp-rtcp}

To ease traversal of NAT and firewall devices, implementations are
[REQUIRED]{.bcp14} to implement and use [symmetric RTP](#RFC4961){.xref}
\[[RFC4961](#RFC4961){.xref}\]. The reason for using symmetric RTP is
primarily to avoid issues with NATs and firewalls by ensuring that the
send and receive RTP packet streams, as well as RTCP, are actually
bidirectional transport-layer flows. This will keep alive the NAT and
firewall pinholes and help indicate consent that the receive direction
is a transport-layer flow the intended recipient actually wants. In
addition, it saves resources, specifically ports at the endpoints, but
also in the network, because the NAT mappings or firewall state is not
unnecessarily bloated. The amount of per-flow QoS state kept in the
network is also reduced.[¶](#section-4.7-1){.pilcrow}
:::

::: {#sec-ssrc}
::: {#section-4.8 .section}
### [4.8.](#section-4.8){.section-number .selfRef} [Choice of RTP Synchronization Source (SSRC)](#name-choice-of-rtp-synchronizati){.section-name .selfRef} {#name-choice-of-rtp-synchronizati}

Implementations are [REQUIRED]{.bcp14} to support signaled RTP
synchronization source (SSRC) identifiers. If SDP is used, this
[MUST]{.bcp14} be done using the \"a=ssrc:\" SDP attribute defined in
Sections
[4.1](https://www.rfc-editor.org/rfc/rfc5576#section-4.1){.relref} and
[5](https://www.rfc-editor.org/rfc/rfc5576#section-5){.relref} of
\[[RFC5576](#RFC5576){.xref}\] and the \"previous-ssrc\" source
attribute defined in [Section
6.2](https://www.rfc-editor.org/rfc/rfc5576#section-6.2){.relref} of
\[[RFC5576](#RFC5576){.xref}\]; other per-SSRC attributes defined in
\[[RFC5576](#RFC5576){.xref}\] [MAY]{.bcp14} be
supported.[¶](#section-4.8-1){.pilcrow}

While support for signaled SSRC identifiers is mandated, their use in an
RTP session is [OPTIONAL]{.bcp14}. Implementations [MUST]{.bcp14} be
prepared to accept RTP and RTCP packets using SSRCs that have not been
explicitly signaled ahead of time. Implementations [MUST]{.bcp14}
support random SSRC assignment and [MUST]{.bcp14} support SSRC collision
detection and resolution, according to \[[RFC3550](#RFC3550){.xref}\].
When using signaled SSRC values, collision detection [MUST]{.bcp14} be
performed as described in [Section
5](https://www.rfc-editor.org/rfc/rfc5576#section-5){.relref} of
\[[RFC5576](#RFC5576){.xref}\].[¶](#section-4.8-2){.pilcrow}

It is often desirable to associate an RTP packet stream with a non-RTP
context. For users of the WebRTC API, a mapping between SSRCs and
MediaStreamTracks is provided per [Section 11](#sec-webrtc-api){.xref}.
For gateways or other usages, it is possible to associate an RTP packet
stream with an \"m=\" line in a session description formatted using SDP.
If SSRCs are signaled, this is straightforward (in SDP, the \"a=ssrc:\"
line will be at the media level, allowing a direct association with an
\"m=\" line). If SSRCs are not signaled, the RTP payload type numbers
used in an RTP packet stream are often sufficient to associate that
packet stream with a signaling context. For example, if RTP payload type
numbers are assigned as described in [Section 4.3](#sec.codecs){.xref}
of this memo, the RTP payload types used by an RTP packet stream can be
compared with values in SDP \"a=rtpmap:\" lines, which are at the media
level in SDP and so map to an \"m=\" line.[¶](#section-4.8-3){.pilcrow}
:::
:::

::: {#sec-cname}
::: {#section-4.9 .section}
### [4.9.](#section-4.9){.section-number .selfRef} [Generation of the RTCP Canonical Name (CNAME)](#name-generation-of-the-rtcp-cano){.section-name .selfRef} {#name-generation-of-the-rtcp-cano}

The RTCP Canonical Name (CNAME) provides a persistent transport-level
identifier for an RTP endpoint. While the SSRC identifier for an RTP
endpoint can change if a collision is detected or when the RTP
application is restarted, its RTCP CNAME is meant to stay unchanged for
the duration of an [RTCPeerConnection](#W3C.WebRTC){.xref}
\[[W3C.WebRTC](#W3C.WebRTC){.xref}\], so that RTP endpoints can be
uniquely identified and associated with their RTP packet streams within
a set of related RTP sessions.[¶](#section-4.9-1){.pilcrow}

Each RTP endpoint [MUST]{.bcp14} have at least one RTCP CNAME, and that
RTCP CNAME [MUST]{.bcp14} be unique within the RTCPeerConnection. RTCP
CNAMEs identify a particular synchronization context \-- i.e., all SSRCs
associated with a single RTCP CNAME share a common reference clock. If
an endpoint has SSRCs that are associated with several unsynchronized
reference clocks, and hence different synchronization contexts, it will
need to use multiple RTCP CNAMEs, one for each synchronization
context.[¶](#section-4.9-2){.pilcrow}

Taking the discussion in [Section 11](#sec-webrtc-api){.xref} into
account, a WebRTC endpoint [MUST NOT]{.bcp14} use more than one RTCP
CNAME in the RTP sessions belonging to a single RTCPeerConnection (that
is, an RTCPeerConnection forms a synchronization context). RTP
middleboxes [MAY]{.bcp14} generate RTP packet streams associated with
more than one RTCP CNAME, to allow them to avoid having to resynchronize
media from multiple different endpoints that are part of a multiparty
RTP session.[¶](#section-4.9-3){.pilcrow}

The [RTP specification](#RFC3550){.xref} \[[RFC3550](#RFC3550){.xref}\]
includes guidelines for choosing a unique RTP CNAME, but these are not
sufficient in the presence of NAT devices. In addition, long-term
persistent identifiers can be problematic from a [privacy
viewpoint](#sec-security){.xref} ([Section 13](#sec-security){.xref}).
Accordingly, a WebRTC endpoint [MUST]{.bcp14} generate a new, unique,
short-term persistent RTCP CNAME for each RTCPeerConnection, following
\[[RFC7022](#RFC7022){.xref}\], with a single exception; if explicitly
requested at creation, an RTCPeerConnection [MAY]{.bcp14} use the same
CNAME as an existing RTCPeerConnection within their common same-origin
context.[¶](#section-4.9-4){.pilcrow}

A WebRTC endpoint [MUST]{.bcp14} support reception of any CNAME that
matches the syntax limitations specified by the [RTP
specification](#RFC3550){.xref} \[[RFC3550](#RFC3550){.xref}\] and
cannot assume that any CNAME will be chosen according to the form
suggested above.[¶](#section-4.9-5){.pilcrow}
:::
:::

::: {#sec-leap-sec}
::: {#section-4.10 .section}
### [4.10.](#section-4.10){.section-number .selfRef} [Handling of Leap Seconds](#name-handling-of-leap-seconds){.section-name .selfRef} {#name-handling-of-leap-seconds}

The guidelines given in \[[RFC7164](#RFC7164){.xref}\] regarding
handling of leap seconds to limit their impact on RTP media play-out and
synchronization [SHOULD]{.bcp14} be
followed.[¶](#section-4.10-1){.pilcrow}
:::
:::
:::
:::

::: {#sec-rtp-extn}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [WebRTC Use of RTP: Extensions](#name-webrtc-use-of-rtp-extension){.section-name .selfRef} {#name-webrtc-use-of-rtp-extension}

There are a number of RTP extensions that are either needed to obtain
full functionality, or extremely useful to improve on the baseline
performance, in the WebRTC context. One set of these extensions is
related to conferencing, while others are more generic in nature. The
following subsections describe the various RTP extensions mandated or
suggested for use within WebRTC.[¶](#section-5-1){.pilcrow}

::: {#conf-ext}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Conferencing Extensions and Topologies](#name-conferencing-extensions-and){.section-name .selfRef} {#name-conferencing-extensions-and}

RTP is a protocol that inherently supports group communication. Groups
can be implemented by having each endpoint send its RTP packet streams
to an RTP middlebox that redistributes the traffic, by using a mesh of
unicast RTP packet streams between endpoints, or by using an IP
multicast group to distribute the RTP packet streams. These topologies
can be implemented in a number of ways as discussed in
\[[RFC7667](#RFC7667){.xref}\].[¶](#section-5.1-1){.pilcrow}

While the use of IP multicast groups is popular in IPTV systems, the
topologies based on RTP middleboxes are dominant in interactive
video-conferencing environments. Topologies based on a mesh of unicast
transport-layer flows to create a common RTP session have not seen
widespread deployment to date. Accordingly, WebRTC endpoints are not
expected to support topologies based on IP multicast groups or
mesh-based topologies, such as a point-to-multipoint mesh configured as
a single RTP session (\"Topo-Mesh\" in the terminology of
\[[RFC7667](#RFC7667){.xref}\]). However, a point-to-multipoint mesh
constructed using several RTP sessions, implemented in WebRTC using
independent [RTCPeerConnections](#W3C.WebRTC){.xref}
\[[W3C.WebRTC](#W3C.WebRTC){.xref}\], can be expected to be used in
WebRTC and needs to be supported.[¶](#section-5.1-2){.pilcrow}

WebRTC endpoints implemented according to this memo are expected to
support all the topologies described in \[[RFC7667](#RFC7667){.xref}\]
where the RTP endpoints send and receive unicast RTP packet streams to
and from some peer device, provided that peer can participate in
performing congestion control on the RTP packet streams. The peer device
could be another RTP endpoint, or it could be an RTP middlebox that
redistributes the RTP packet streams to other RTP endpoints. This
limitation means that some of the RTP middlebox-based topologies are not
suitable for use in WebRTC. Specifically:[¶](#section-5.1-3){.pilcrow}

-   [Video-switching Multipoint Control Units (MCUs)
    (Topo-Video-switch-MCU) [SHOULD NOT]{.bcp14} be used, since they
    make the use of RTCP for congestion control and quality-of-service
    reports problematic (see [Section
    3.8](https://www.rfc-editor.org/rfc/rfc7667#section-3.8){.relref} of
    \[[RFC7667](#RFC7667){.xref}\]).[¶](#section-5.1-4.1){.pilcrow}]{#section-5.1-4.1}
-   [The Relay-Transport Translator (Topo-PtM-Trn-Translator) topology
    [SHOULD NOT]{.bcp14} be used, because its safe use requires a
    congestion control algorithm or RTP circuit breaker that handles
    point to multipoint, which has not yet been
    standardized.[¶](#section-5.1-4.2){.pilcrow}]{#section-5.1-4.2}

The following topology can be used, however it has some issues worth
noting:[¶](#section-5.1-5){.pilcrow}

-   [Content-modifying MCUs with RTCP termination
    (Topo-RTCP-terminating-MCU) [MAY]{.bcp14} be used. Note that in this
    RTP topology, RTP loop detection and identification of active
    senders is the responsibility of the WebRTC application; since the
    clients are isolated from each other at the RTP layer, RTP cannot
    assist with these functions (see [Section
    3.9](https://www.rfc-editor.org/rfc/rfc7667#section-3.9){.relref} of
    \[[RFC7667](#RFC7667){.xref}\]).[¶](#section-5.1-6.1){.pilcrow}]{#section-5.1-6.1}

The RTP extensions described in Sections [5.1.1](#sec-fir){.xref} to
[5.1.6](#sec.tmmbr){.xref} are designed to be used with centralized
conferencing, where an RTP middlebox (e.g., a conference bridge)
receives a participant\'s RTP packet streams and distributes them to the
other participants. These extensions are not necessary for
interoperability; an RTP endpoint that does not implement these
extensions will work correctly but might offer poor performance. Support
for the listed extensions will greatly improve the quality of
experience; to provide a reasonable baseline quality, some of these
extensions are mandatory to be supported by WebRTC
endpoints.[¶](#section-5.1-7){.pilcrow}

The RTCP conferencing extensions are defined in [\"Extended RTP Profile
for Real-time Transport Control Protocol (RTCP)-Based Feedback
(RTP/AVPF)\"](#RFC4585){.xref} \[[RFC4585](#RFC4585){.xref}\] and
[\"Codec Control Messages in the RTP Audio-Visual Profile with Feedback
(AVPF)\"](#RFC5104){.xref} \[[RFC5104](#RFC5104){.xref}\]; they are
fully usable by the [secure variant of this profile
(RTP/SAVPF)](#RFC5124){.xref}
\[[RFC5124](#RFC5124){.xref}\].[¶](#section-5.1-8){.pilcrow}

::: {#sec-fir}
::: {#section-5.1.1 .section}
#### [5.1.1.](#section-5.1.1){.section-number .selfRef} [Full Intra Request (FIR)](#name-full-intra-request-fir){.section-name .selfRef} {#name-full-intra-request-fir}

The Full Intra Request message is defined in Sections
[3.5.1](https://www.rfc-editor.org/rfc/rfc5104#section-3.5.1){.relref}
and
[4.3.1](https://www.rfc-editor.org/rfc/rfc5104#section-4.3.1){.relref}
of [Codec Control Messages](#RFC5104){.xref}
\[[RFC5104](#RFC5104){.xref}\]. It is used to make the mixer request a
new Intra picture from a participant in the session. This is used when
switching between sources to ensure that the receivers can decode the
video or other predictive media encoding with long prediction chains.
WebRTC endpoints that are sending media [MUST]{.bcp14} understand and
react to FIR feedback messages they receive, since this greatly improves
the user experience when using centralized mixer-based conferencing.
Support for sending FIR messages is
[OPTIONAL]{.bcp14}.[¶](#section-5.1.1-1){.pilcrow}
:::
:::

::: {#section-5.1.2 .section}
#### [5.1.2.](#section-5.1.2){.section-number .selfRef} [Picture Loss Indication (PLI)](#name-picture-loss-indication-pli){.section-name .selfRef} {#name-picture-loss-indication-pli}

The Picture Loss Indication message is defined in [Section
6.3.1](https://www.rfc-editor.org/rfc/rfc4585#section-6.3.1){.relref} of
the RTP/AVPF profile \[[RFC4585](#RFC4585){.xref}\]. It is used by a
receiver to tell the sending encoder that it lost the decoder context
and would like to have it repaired somehow. This is semantically
different from the Full Intra Request above, as there could be multiple
ways to fulfill the request. WebRTC endpoints that are sending media
[MUST]{.bcp14} understand and react to PLI feedback messages as a
loss-tolerance mechanism. Receivers [MAY]{.bcp14} send PLI
messages.[¶](#section-5.1.2-1){.pilcrow}
:::

::: {#section-5.1.3 .section}
#### [5.1.3.](#section-5.1.3){.section-number .selfRef} [Slice Loss Indication (SLI)](#name-slice-loss-indication-sli){.section-name .selfRef} {#name-slice-loss-indication-sli}

The Slice Loss Indication message is defined in [Section
6.3.2](https://www.rfc-editor.org/rfc/rfc4585#section-6.3.2){.relref} of
the RTP/AVPF profile \[[RFC4585](#RFC4585){.xref}\]. It is used by a
receiver to tell the encoder that it has detected the loss or corruption
of one or more consecutive macro blocks and would like to have these
repaired somehow. It is [RECOMMENDED]{.bcp14} that receivers generate
SLI feedback messages if slices are lost when using a codec that
supports the concept of macro blocks. A sender that receives an SLI
feedback message [SHOULD]{.bcp14} attempt to repair the lost
slice(s).[¶](#section-5.1.3-1){.pilcrow}
:::

::: {#section-5.1.4 .section}
#### [5.1.4.](#section-5.1.4){.section-number .selfRef} [Reference Picture Selection Indication (RPSI)](#name-reference-picture-selection){.section-name .selfRef} {#name-reference-picture-selection}

Reference Picture Selection Indication (RPSI) messages are defined in
[Section
6.3.3](https://www.rfc-editor.org/rfc/rfc4585#section-6.3.3){.relref} of
the RTP/AVPF profile \[[RFC4585](#RFC4585){.xref}\]. Some video-encoding
standards allow the use of older reference pictures than the most recent
one for predictive coding. If such a codec is in use, and if the encoder
has learned that encoder-decoder synchronization has been lost, then a
known-as-correct reference picture can be used as a base for future
coding. The RPSI message allows this to be signaled. Receivers that
detect that encoder-decoder synchronization has been lost
[SHOULD]{.bcp14} generate an RPSI feedback message if the codec being
used supports reference-picture selection. An RTP packet-stream sender
that receives such an RPSI message [SHOULD]{.bcp14} act on that messages
to change the reference picture, if it is possible to do so within the
available bandwidth constraints and with the codec being
used.[¶](#section-5.1.4-1){.pilcrow}
:::

::: {#section-5.1.5 .section}
#### [5.1.5.](#section-5.1.5){.section-number .selfRef} [Temporal-Spatial Trade-Off Request (TSTR)](#name-temporal-spatial-trade-off-){.section-name .selfRef} {#name-temporal-spatial-trade-off-}

The temporal-spatial trade-off request and notification are defined in
Sections
[3.5.2](https://www.rfc-editor.org/rfc/rfc5104#section-3.5.2){.relref}
and
[4.3.2](https://www.rfc-editor.org/rfc/rfc5104#section-4.3.2){.relref}
of \[[RFC5104](#RFC5104){.xref}\]. This request can be used to ask the
video encoder to change the trade-off it makes between temporal and
spatial resolution \-- for example, to prefer high spatial image quality
but low frame rate. Support for TSTR requests and notifications is
[OPTIONAL]{.bcp14}.[¶](#section-5.1.5-1){.pilcrow}
:::

::: {#sec.tmmbr}
::: {#section-5.1.6 .section}
#### [5.1.6.](#section-5.1.6){.section-number .selfRef} [Temporary Maximum Media Stream Bit Rate Request (TMMBR)](#name-temporary-maximum-media-str){.section-name .selfRef} {#name-temporary-maximum-media-str}

The Temporary Maximum Media Stream Bit Rate Request (TMMBR) feedback
message is defined in Sections
[3.5.4](https://www.rfc-editor.org/rfc/rfc5104#section-3.5.4){.relref}
and
[4.2.1](https://www.rfc-editor.org/rfc/rfc5104#section-4.2.1){.relref}
of [Codec Control Messages](#RFC5104){.xref}
\[[RFC5104](#RFC5104){.xref}\]. This request and its corresponding
Temporary Maximum Media Stream Bit Rate Notification (TMMBN) message
\[[RFC5104](#RFC5104){.xref}\] are used by a media receiver to inform
the sending party that there is a current limitation on the amount of
bandwidth available to this receiver. There can be various reasons for
this: for example, an RTP mixer can use this message to limit the media
rate of the sender being forwarded by the mixer (without doing media
transcoding) to fit the bottlenecks existing towards the other session
participants. WebRTC endpoints that are sending media are
[REQUIRED]{.bcp14} to implement support for TMMBR messages and
[MUST]{.bcp14} follow bandwidth limitations set by a TMMBR message
received for their SSRC. The sending of TMMBR messages is
[OPTIONAL]{.bcp14}.[¶](#section-5.1.6-1){.pilcrow}
:::
:::
:::
:::

::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Header Extensions](#name-header-extensions){.section-name .selfRef} {#name-header-extensions}

The [RTP specification](#RFC3550){.xref} \[[RFC3550](#RFC3550){.xref}\]
provides the capability to include RTP header extensions containing
in-band data, but the format and semantics of the extensions are poorly
specified. The use of header extensions is [OPTIONAL]{.bcp14} in WebRTC,
but if they are used, they [MUST]{.bcp14} be formatted and signaled
following the general mechanism for RTP header extensions defined in
\[[RFC8285](#RFC8285){.xref}\], since this gives well-defined semantics
to RTP header extensions.[¶](#section-5.2-1){.pilcrow}

As noted in \[[RFC8285](#RFC8285){.xref}\], the requirement from the RTP
specification that header extensions are \"designed so that the header
extension may be ignored\" \[[RFC3550](#RFC3550){.xref}\] stands. To be
specific, header extensions [MUST]{.bcp14} only be used for data that
can safely be ignored by the recipient without affecting
interoperability and [MUST NOT]{.bcp14} be used when the presence of the
extension has changed the form or nature of the rest of the packet in a
way that is not compatible with the way the stream is signaled (e.g., as
defined by the payload type). Valid examples of RTP header extensions
might include metadata that is additional to the usual RTP information
but that can safely be ignored without compromising
interoperability.[¶](#section-5.2-2){.pilcrow}

::: {#rapid-sync}
::: {#section-5.2.1 .section}
#### [5.2.1.](#section-5.2.1){.section-number .selfRef} [Rapid Synchronization](#name-rapid-synchronization){.section-name .selfRef} {#name-rapid-synchronization}

Many RTP sessions require synchronization between audio, video, and
other content. This synchronization is performed by receivers, using
information contained in RTCP SR packets, as described in the [RTP
specification](#RFC3550){.xref} \[[RFC3550](#RFC3550){.xref}\]. This
basic mechanism can be slow, however, so it is [RECOMMENDED]{.bcp14}
that the rapid RTP synchronization extensions described in
\[[RFC6051](#RFC6051){.xref}\] be implemented in addition to RTCP
SR-based synchronization.[¶](#section-5.2.1-1){.pilcrow}

This header extension uses the generic header extension framework
described in \[[RFC8285](#RFC8285){.xref}\] and so needs to be
negotiated before it can be used.[¶](#section-5.2.1-2){.pilcrow}
:::
:::

::: {#sec-client-to-mixer}
::: {#section-5.2.2 .section}
#### [5.2.2.](#section-5.2.2){.section-number .selfRef} [Client-to-Mixer Audio Level](#name-client-to-mixer-audio-level){.section-name .selfRef} {#name-client-to-mixer-audio-level}

The [client-to-mixer audio level extension](#RFC6464){.xref}
\[[RFC6464](#RFC6464){.xref}\] is an RTP header extension used by an
endpoint to inform a mixer about the level of audio activity in the
packet to which the header is attached. This enables an RTP middlebox to
make mixing or selection decisions without decoding or detailed
inspection of the payload, reducing the complexity in some types of
mixers. It can also save decoding resources in receivers, which can
choose to decode only the most relevant RTP packet streams based on
audio activity levels.[¶](#section-5.2.2-1){.pilcrow}

The [client-to-mixer audio level header extension](#RFC6464){.xref}
\[[RFC6464](#RFC6464){.xref}\] [MUST]{.bcp14} be implemented. It is
[REQUIRED]{.bcp14} that implementations be capable of encrypting the
header extension according to \[[RFC6904](#RFC6904){.xref}\], since the
information contained in these header extensions can be considered
sensitive. The use of this encryption is [RECOMMENDED]{.bcp14}; however,
usage of the encryption can be explicitly disabled through API or
signaling.[¶](#section-5.2.2-2){.pilcrow}

This header extension uses the generic header extension framework
described in \[[RFC8285](#RFC8285){.xref}\] and so needs to be
negotiated before it can be used.[¶](#section-5.2.2-3){.pilcrow}
:::
:::

::: {#sec-mixer-to-client}
::: {#section-5.2.3 .section}
#### [5.2.3.](#section-5.2.3){.section-number .selfRef} [Mixer-to-Client Audio Level](#name-mixer-to-client-audio-level){.section-name .selfRef} {#name-mixer-to-client-audio-level}

The [mixer-to-client audio level header extension](#RFC6465){.xref}
\[[RFC6465](#RFC6465){.xref}\] provides an endpoint with the audio level
of the different sources mixed into a common source stream by an RTP
mixer. This enables a user interface to indicate the relative activity
level of each session participant, rather than just being included or
not based on the CSRC field. This is a pure optimization of non-critical
functions and is hence [OPTIONAL]{.bcp14} to implement. If this header
extension is implemented, it is [REQUIRED]{.bcp14} that implementations
be capable of encrypting the header extension according to
\[[RFC6904](#RFC6904){.xref}\], since the information contained in these
header extensions can be considered sensitive. It is further
[RECOMMENDED]{.bcp14} that this encryption be used, unless the
encryption has been explicitly disabled through API or
signaling.[¶](#section-5.2.3-1){.pilcrow}

This header extension uses the generic header extension framework
described in \[[RFC8285](#RFC8285){.xref}\] and so needs to be
negotiated before it can be used.[¶](#section-5.2.3-2){.pilcrow}
:::
:::

::: {#sec-mid}
::: {#section-5.2.4 .section}
#### [5.2.4.](#section-5.2.4){.section-number .selfRef} [Media Stream Identification](#name-media-stream-identification){.section-name .selfRef} {#name-media-stream-identification}

WebRTC endpoints that implement the SDP bundle negotiation extension
will use the SDP Grouping Framework \"mid\" attribute to identify media
streams. Such endpoints [MUST]{.bcp14} implement the RTP MID header
extension described in
\[[RFC8843](#RFC8843){.xref}\].[¶](#section-5.2.4-1){.pilcrow}

This header extension uses the generic header extension framework
described in \[[RFC8285](#RFC8285){.xref}\] and so needs to be
negotiated before it can be used.[¶](#section-5.2.4-2){.pilcrow}
:::
:::

::: {#sec-cvo}
::: {#section-5.2.5 .section}
#### [5.2.5.](#section-5.2.5){.section-number .selfRef} [Coordination of Video Orientation](#name-coordination-of-video-orien){.section-name .selfRef} {#name-coordination-of-video-orien}

WebRTC endpoints that send or receive video [MUST]{.bcp14} implement the
coordination of video orientation (CVO) RTP header extension as
described in [Section
4](https://www.rfc-editor.org/rfc/rfc7742#section-4){.relref} of
\[[RFC7742](#RFC7742){.xref}\].[¶](#section-5.2.5-1){.pilcrow}

This header extension uses the generic header extension framework
described in \[[RFC8285](#RFC8285){.xref}\] and so needs to be
negotiated before it can be used.[¶](#section-5.2.5-2){.pilcrow}
:::
:::
:::
:::
:::

::: {#sec-rtp-robust}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [WebRTC Use of RTP: Improving Transport Robustness](#name-webrtc-use-of-rtp-improving){.section-name .selfRef} {#name-webrtc-use-of-rtp-improving}

There are tools that can make RTP packet streams robust against packet
loss and reduce the impact of loss on media quality. However, they
generally add some overhead compared to a non-robust stream. The
overhead needs to be considered, and the aggregate bitrate
[MUST]{.bcp14} be rate controlled to avoid causing network congestion
(see [Section 7](#sec-rate-control){.xref}). As a result, improving
robustness might require a lower base encoding quality but has the
potential to deliver that quality with fewer errors. The mechanisms
described in the following subsections can be used to improve tolerance
to packet loss.[¶](#section-6-1){.pilcrow}

::: {#sec-rtx}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Negative Acknowledgements and RTP Retransmission](#name-negative-acknowledgements-a){.section-name .selfRef} {#name-negative-acknowledgements-a}

As a consequence of supporting the RTP/SAVPF profile, implementations
can send negative acknowledgements (NACKs) for RTP data packets
\[[RFC4585](#RFC4585){.xref}\]. This feedback can be used to inform a
sender of the loss of particular RTP packets, subject to the capacity
limitations of the RTCP feedback channel. A sender can use this
information to optimize the user experience by adapting the media
encoding to compensate for known lost
packets.[¶](#section-6.1-1){.pilcrow}

RTP packet stream senders are [REQUIRED]{.bcp14} to understand the
generic NACK message defined in [Section
6.2.1](https://www.rfc-editor.org/rfc/rfc4585#section-6.2.1){.relref} of
\[[RFC4585](#RFC4585){.xref}\], but they [MAY]{.bcp14} choose to ignore
some or all of this feedback (following [Section
4.2](https://www.rfc-editor.org/rfc/rfc4585#section-4.2){.relref} of
\[[RFC4585](#RFC4585){.xref}\]). Receivers [MAY]{.bcp14} send NACKs for
missing RTP packets. Guidelines on when to send NACKs are provided in
\[[RFC4585](#RFC4585){.xref}\]. It is not expected that a receiver will
send a NACK for every lost RTP packet; rather, it needs to consider the
cost of sending NACK feedback and the importance of the lost packet to
make an informed decision on whether it is worth telling the sender
about a packet-loss event.[¶](#section-6.1-2){.pilcrow}

The [RTP retransmission payload format](#RFC4588){.xref}
\[[RFC4588](#RFC4588){.xref}\] offers the ability to retransmit lost
packets based on NACK feedback. Retransmission needs to be used with
care in interactive real-time applications to ensure that the
retransmitted packet arrives in time to be useful, but it can be
effective in environments with relatively low network RTT. (An RTP
sender can estimate the RTT to the receivers using the information in
RTCP SR and RR packets, as described at the end of [Section
6.4.1](https://www.rfc-editor.org/rfc/rfc3550#section-6.4.1){.relref} of
\[[RFC3550](#RFC3550){.xref}\]). The use of retransmissions can also
increase the forward RTP bandwidth and can potentially cause increased
packet loss if the original packet loss was caused by network
congestion. Note, however, that retransmission of an important lost
packet to repair decoder state can have lower cost than sending a full
intra frame. It is not appropriate to blindly retransmit RTP packets in
response to a NACK. The importance of lost packets and the likelihood of
them arriving in time to be useful need to be considered before RTP
retransmission is used.[¶](#section-6.1-3){.pilcrow}

Receivers are [REQUIRED]{.bcp14} to implement support for RTP
retransmission packets \[[RFC4588](#RFC4588){.xref}\] sent using SSRC
multiplexing and [MAY]{.bcp14} also support RTP retransmission packets
sent using session multiplexing. Senders [MAY]{.bcp14} send RTP
retransmission packets in response to NACKs if support for the RTP
retransmission payload format has been negotiated and the sender
believes it is useful to send a retransmission of the packet(s)
referenced in the NACK. Senders do not need to retransmit every NACKed
packet.[¶](#section-6.1-4){.pilcrow}
:::
:::

::: {#sec-FEC}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Forward Error Correction (FEC)](#name-forward-error-correction-fe){.section-name .selfRef} {#name-forward-error-correction-fe}

The use of Forward Error Correction (FEC) can provide an effective
protection against some degree of packet loss, at the cost of steady
bandwidth overhead. There are several FEC schemes that are defined for
use with RTP. Some of these schemes are specific to a particular RTP
payload format, and others operate across RTP packets and can be used
with any payload format. Note that using redundant encoding or FEC will
lead to increased play-out delay, which needs to be considered when
choosing FEC schemes and their parameters.[¶](#section-6.2-1){.pilcrow}

WebRTC endpoints [MUST]{.bcp14} follow the recommendations for FEC use
given in \[[RFC8854](#RFC8854){.xref}\]. WebRTC endpoints [MAY]{.bcp14}
support other types of FEC, but these [MUST]{.bcp14} be negotiated
before they are used.[¶](#section-6.2-2){.pilcrow}
:::
:::
:::
:::

::: {#sec-rate-control}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [WebRTC Use of RTP: Rate Control and Media Adaptation](#name-webrtc-use-of-rtp-rate-cont){.section-name .selfRef} {#name-webrtc-use-of-rtp-rate-cont}

WebRTC will be used in heterogeneous network environments using a
variety of link technologies, including both wired and wireless links,
to interconnect potentially large groups of users around the world. As a
result, the network paths between users can have widely varying one-way
delays, available bitrates, load levels, and traffic mixtures.
Individual endpoints can send one or more RTP packet streams to each
participant, and there can be several participants. Each of these RTP
packet streams can contain different types of media, and the type of
media, bitrate, and number of RTP packet streams as well as
transport-layer flows can be highly asymmetric. Non-RTP traffic can
share the network paths with RTP transport-layer flows. Since the
network environment is not predictable or stable, WebRTC endpoints
[MUST]{.bcp14} ensure that the RTP traffic they generate can adapt to
match changes in the available network
capacity.[¶](#section-7-1){.pilcrow}

The quality of experience for users of WebRTC is very dependent on
effective adaptation of the media to the limitations of the network.
Endpoints have to be designed so they do not transmit significantly more
data than the network path can support, except for very short time
periods; otherwise, high levels of network packet loss or delay spikes
will occur, causing media quality degradation. The limiting factor on
the capacity of the network path might be the link bandwidth, or it
might be competition with other traffic on the link (this can be
non-WebRTC traffic, traffic due to other WebRTC flows, or even
competition with other WebRTC flows in the same
session).[¶](#section-7-2){.pilcrow}

An effective media congestion control algorithm is therefore an
essential part of the WebRTC framework. However, at the time of this
writing, there is no standard congestion control algorithm that can be
used for interactive media applications such as WebRTC\'s flows. Some
requirements for congestion control algorithms for RTCPeerConnections
are discussed in \[[RFC8836](#RFC8836){.xref}\]. If a standardized
congestion control algorithm that satisfies these requirements is
developed in the future, this memo will need to be updated to mandate
its use.[¶](#section-7-3){.pilcrow}

::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Boundary Conditions and Circuit Breakers](#name-boundary-conditions-and-cir){.section-name .selfRef} {#name-boundary-conditions-and-cir}

WebRTC endpoints [MUST]{.bcp14} implement the RTP circuit breaker
algorithm that is described in \[[RFC8083](#RFC8083){.xref}\]. The RTP
circuit breaker is designed to enable applications to recognize and
react to situations of extreme network congestion. However, since the
RTP circuit breaker might not be triggered until congestion becomes
extreme, it cannot be considered a substitute for congestion control,
and applications [MUST]{.bcp14} also implement congestion control to
allow them to adapt to changes in network capacity. The congestion
control algorithm will have to be proprietary until a standardized
congestion control algorithm is available. Any future RTP congestion
control algorithms are expected to operate within the envelope allowed
by the circuit breaker.[¶](#section-7.1-1){.pilcrow}

The session-establishment signaling will also necessarily establish
boundaries to which the media bitrate will conform. The choice of media
codecs provides upper and lower bounds on the supported bitrates that
the application can utilize to provide useful quality, and the
packetization choices that exist. In addition, the signaling channel can
establish maximum media bitrate boundaries using, for example, the SDP
\"b=AS:\" or \"b=CT:\" lines and the RTP/AVPF TMMBR messages (see
[Section 5.1.6](#sec.tmmbr){.xref} of this memo). Signaled bandwidth
limitations, such as SDP \"b=AS:\" or \"b=CT:\" lines received from the
peer, [MUST]{.bcp14} be followed when sending RTP packet streams. A
WebRTC endpoint receiving media [SHOULD]{.bcp14} signal its bandwidth
limitations. These limitations have to be based on known bandwidth
limitations, for example the capacity of the edge
links.[¶](#section-7.1-2){.pilcrow}
:::

::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Congestion Control Interoperability and Legacy Systems](#name-congestion-control-interope){.section-name .selfRef} {#name-congestion-control-interope}

All endpoints that wish to interwork with WebRTC [MUST]{.bcp14}
implement RTCP and provide congestion feedback via the defined RTCP
reporting mechanisms.[¶](#section-7.2-1){.pilcrow}

When interworking with legacy implementations that support RTCP using
the [RTP/AVP profile](#RFC3551){.xref} \[[RFC3551](#RFC3551){.xref}\],
congestion feedback is provided in RTCP RR packets every few seconds.
Implementations that have to interwork with such endpoints
[MUST]{.bcp14} ensure that they keep within the [RTP circuit
breaker](#RFC8083){.xref} \[[RFC8083](#RFC8083){.xref}\] constraints to
limit the congestion they can cause.[¶](#section-7.2-2){.pilcrow}

If a legacy endpoint supports RTP/AVPF, this enables negotiation of
important parameters for frequent reporting, such as the \"trr-int\"
parameter, and the possibility that the endpoint supports some useful
feedback format for congestion control purposes such as
[TMMBR](#RFC5104){.xref} \[[RFC5104](#RFC5104){.xref}\]. Implementations
that have to interwork with such endpoints [MUST]{.bcp14} ensure that
they stay within the [RTP circuit breaker](#RFC8083){.xref}
\[[RFC8083](#RFC8083){.xref}\] constraints to limit the congestion they
can cause, but they might find that they can achieve better congestion
response depending on the amount of feedback that is
available.[¶](#section-7.2-3){.pilcrow}

With proprietary congestion control algorithms, issues can arise when
different algorithms and implementations interact in a communication
session. If the different implementations have made different choices in
regards to the type of adaptation, for example one sender based, and one
receiver based, then one could end up in a situation where one direction
is dual controlled when the other direction is not controlled. This memo
cannot mandate behavior for proprietary congestion control algorithms,
but implementations that use such algorithms ought to be aware of this
issue and try to ensure that effective congestion control is negotiated
for media flowing in both directions. If the IETF were to standardize
both sender- and receiver-based congestion control algorithms for WebRTC
traffic in the future, the issues of interoperability, control, and
ensuring that both directions of media flow are congestion controlled
would also need to be considered.[¶](#section-7.2-4){.pilcrow}
:::
:::
:::

::: {#sec-perf}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [WebRTC Use of RTP: Performance Monitoring](#name-webrtc-use-of-rtp-performan){.section-name .selfRef} {#name-webrtc-use-of-rtp-performan}

As described in [Section 4.1](#sec-rtp-rtcp){.xref}, implementations are
[REQUIRED]{.bcp14} to generate RTCP Sender Report (SR) and Receiver
Report (RR) packets relating to the RTP packet streams they send and
receive. These RTCP reports can be used for performance monitoring
purposes, since they include basic packet-loss and jitter
statistics.[¶](#section-8-1){.pilcrow}

A large number of additional performance metrics are supported by the
RTCP Extended Reports (XR) framework; see \[[RFC3611](#RFC3611){.xref}\]
and \[[RFC6792](#RFC6792){.xref}\]. At the time of this writing, it is
not clear what extended metrics are suitable for use in WebRTC, so there
is no requirement that implementations generate RTCP XR packets.
However, implementations that can use detailed performance monitoring
data [MAY]{.bcp14} generate RTCP XR packets as appropriate. The use of
RTCP XR packets [SHOULD]{.bcp14} be signaled; implementations
[MUST]{.bcp14} ignore RTCP XR packets that are unexpected or not
understood.[¶](#section-8-2){.pilcrow}
:::
:::

::: {#sec-extn}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [WebRTC Use of RTP: Future Extensions](#name-webrtc-use-of-rtp-future-ex){.section-name .selfRef} {#name-webrtc-use-of-rtp-future-ex}

It is possible that the core set of RTP protocols and RTP extensions
specified in this memo will prove insufficient for the future needs of
WebRTC. In this case, future updates to this memo have to be made
following [\"Guidelines for Writers of RTP Payload Format
Specifications\"](#RFC2736){.xref} \[[RFC2736](#RFC2736){.xref}\],
[\"How to Write an RTP Payload Format\"](#RFC8088){.xref}
\[[RFC8088](#RFC8088){.xref}\], and [\"Guidelines for Extending the RTP
Control Protocol (RTCP)\"](#RFC5968){.xref}
\[[RFC5968](#RFC5968){.xref}\]. They also [SHOULD]{.bcp14} take into
account any future guidelines for extending RTP and related protocols
that have been developed.[¶](#section-9-1){.pilcrow}

Authors of future extensions are urged to consider the wide range of
environments in which RTP is used when recommending extensions, since
extensions that are applicable in some scenarios can be problematic in
others. Where possible, the WebRTC framework will adopt RTP extensions
that are of general utility, to enable easy implementation of a gateway
to other applications using RTP, rather than adopt mechanisms that are
narrowly targeted at specific WebRTC use
cases.[¶](#section-9-2){.pilcrow}
:::
:::

::: {#sec-signalling}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Signaling Considerations](#name-signaling-considerations){.section-name .selfRef} {#name-signaling-considerations}

RTP is built with the assumption that an external signaling channel
exists and can be used to configure RTP sessions and their features. The
basic configuration of an RTP session consists of the following
parameters:[¶](#section-10-1){.pilcrow}

[]{.break}

RTP profile:
:   The name of the RTP profile to be used in the session. The
    [RTP/AVP](#RFC3551){.xref} \[[RFC3551](#RFC3551){.xref}\] and
    [RTP/AVPF](#RFC4585){.xref} \[[RFC4585](#RFC4585){.xref}\] profiles
    can interoperate on a basic level, as can their secure variants,
    [RTP/SAVP](#RFC3711){.xref} \[[RFC3711](#RFC3711){.xref}\] and
    [RTP/SAVPF](#RFC5124){.xref} \[[RFC5124](#RFC5124){.xref}\]. The
    secure variants of the profiles do not directly interoperate with
    the nonsecure variants, due to the presence of additional header
    fields for authentication in SRTP packets and cryptographic
    transformation of the payload. WebRTC requires the use of the
    RTP/SAVPF profile, and this [MUST]{.bcp14} be signaled. Interworking
    functions might transform this into the RTP/SAVP profile for a
    legacy use case by indicating to the WebRTC endpoint that the
    RTP/SAVPF is used and configuring a \"trr-int\" value of 4
    seconds.[¶](#section-10-2.2){.pilcrow}
:   

Transport information:
:   Source and destination IP address(es) and ports for RTP and RTCP
    [MUST]{.bcp14} be signaled for each RTP session. In WebRTC, these
    transport addresses will be provided by [Interactive Connectivity
    Establishment (ICE)](#RFC8445){.xref} \[[RFC8445](#RFC8445){.xref}\]
    that signals candidates and arrives at nominated candidate address
    pairs. If [RTP and RTCP multiplexing](#RFC5761){.xref}
    \[[RFC5761](#RFC5761){.xref}\] is to be used such that a single port
    \-- i.e., transport-layer flow \-- is used for RTP and RTCP flows,
    this [MUST]{.bcp14} be signaled (see [Section
    4.5](#sec.rtcp-mux){.xref}).[¶](#section-10-2.4){.pilcrow}
:   

RTP payload types, media formats, and format parameters:
:   The mapping between media type names (and hence the RTP payload
    formats to be used) and the RTP payload type numbers [MUST]{.bcp14}
    be signaled. Each media type [MAY]{.bcp14} also have a number of
    media type parameters that [MUST]{.bcp14} also be signaled to
    configure the codec and RTP payload format (the \"a=fmtp:\" line
    from SDP). [Section 4.3](#sec.codecs){.xref} of this memo discusses
    requirements for uniqueness of payload
    types.[¶](#section-10-2.6){.pilcrow}
:   

RTP extensions:
:   The use of any additional RTP header extensions and RTCP packet
    types, including any necessary parameters, [MUST]{.bcp14} be
    signaled. This signaling ensures that a WebRTC endpoint\'s behavior,
    especially when sending, is predictable and consistent. For
    robustness and compatibility with non-WebRTC systems that might be
    connected to a WebRTC session via a gateway, implementations are
    [REQUIRED]{.bcp14} to ignore unknown RTCP packets and RTP header
    extensions (see also [Section
    4.1](#sec-rtp-rtcp){.xref}).[¶](#section-10-2.8){.pilcrow}
:   

RTCP bandwidth:
:   Support for exchanging RTCP bandwidth values with the endpoints will
    be necessary. This [SHALL]{.bcp14} be done as described in
    [\"Session Description Protocol (SDP) Bandwidth Modifiers for RTP
    Control Protocol (RTCP) Bandwidth\"](#RFC3556){.xref}
    \[[RFC3556](#RFC3556){.xref}\] if using SDP, or something
    semantically equivalent. This also ensures that the endpoints have a
    common view of the RTCP bandwidth. A common view of the RTCP
    bandwidth among different endpoints is important to prevent
    differences in RTCP packet timing and timeout intervals causing
    interoperability problems.[¶](#section-10-2.10){.pilcrow}
:   

These parameters are often expressed in SDP messages conveyed within an
offer/answer exchange. RTP does not depend on SDP or the offer/answer
model but does require all the necessary parameters to be agreed upon
and provided to the RTP implementation. Note that in WebRTC, it will
depend on the signaling model and API how these parameters need to be
configured, but they will need to either be set in the API or explicitly
signaled between the peers.[¶](#section-10-3){.pilcrow}
:::
:::

::: {#sec-webrtc-api}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [WebRTC API Considerations](#name-webrtc-api-considerations){.section-name .selfRef} {#name-webrtc-api-considerations}

The [WebRTC API](#W3C.WebRTC){.xref}
\[[W3C.WebRTC](#W3C.WebRTC){.xref}\] and the [Media Capture and Streams
API](#W3C.WD-mediacapture-streams){.xref}
\[[W3C.WD-mediacapture-streams](#W3C.WD-mediacapture-streams){.xref}\]
define and use the concept of a MediaStream that consists of zero or
more MediaStreamTracks. A MediaStreamTrack is an individual stream of
media from any type of media source, such as a microphone or a camera,
but conceptual sources, like an audio mix or a video composition, are
also possible. The MediaStreamTracks within a MediaStream might need to
be synchronized during playback.[¶](#section-11-1){.pilcrow}

A MediaStreamTrack\'s realization in RTP, in the context of an
RTCPeerConnection, consists of a source packet stream, identified by an
SSRC, sent within an RTP session that is part of the RTCPeerConnection.
The MediaStreamTrack can also result in additional packet streams, and
thus SSRCs, in the same RTP session. These can be dependent packet
streams from scalable encoding of the source stream associated with the
MediaStreamTrack, if such a media encoder is used. They can also be
redundancy packet streams; these are created when applying [Forward
Error Correction](#sec-FEC){.xref} ([Section 6.2](#sec-FEC){.xref}) or
[RTP retransmission](#sec-rtx){.xref} ([Section 6.1](#sec-rtx){.xref})
to the source packet stream.[¶](#section-11-2){.pilcrow}

It is important to note that the same media source can be feeding
multiple MediaStreamTracks. As different sets of constraints or other
parameters can be applied to the MediaStreamTrack, each MediaStreamTrack
instance added to an RTCPeerConnection [SHALL]{.bcp14} result in an
independent source packet stream with its own set of associated packet
streams and thus different SSRC(s). It will depend on applied
constraints and parameters if the source stream and the encoding
configuration will be identical between different MediaStreamTracks
sharing the same media source. If the encoding parameters and
constraints are the same, an implementation could choose to use only one
encoded stream to create the different RTP packet streams. Note that
such optimizations would need to take into account that the constraints
for one of the MediaStreamTracks can change at any moment, meaning that
the encoding configurations might no longer be identical, and two
different encoder instances would then be
needed.[¶](#section-11-3){.pilcrow}

The same MediaStreamTrack can also be included in multiple MediaStreams;
thus, multiple sets of MediaStreams can implicitly need to use the same
synchronization base. To ensure that this works in all cases and does
not force an endpoint to disrupt the media by changing synchronization
base and CNAME during delivery of any ongoing packet streams, all
MediaStreamTracks and their associated SSRCs originating from the same
endpoint need to be sent using the same CNAME within one
RTCPeerConnection. This is motivating the use of a single CNAME in
[Section 4.9](#sec-cname){.xref}.[¶](#section-11-4){.pilcrow}

The requirement to use the same CNAME for all SSRCs that originate from
the same endpoint does not require a middlebox that forwards traffic
from multiple endpoints to only use a single
CNAME.[¶](#section-11-5.1){.pilcrow}

Different CNAMEs normally need to be used for different
RTCPeerConnection instances, as specified in [Section
4.9](#sec-cname){.xref}. Having two communication sessions with the same
CNAME could enable tracking of a user or device across different
services (see [Section
4.4.1](https://www.rfc-editor.org/rfc/rfc8826#section-4.4.1){.relref} of
\[[RFC8826](#RFC8826){.xref}\] for details). A web application can
request that the CNAMEs used in different RTCPeerConnections (within a
same-origin context) be the same; this allows for synchronization of the
endpoint\'s RTP packet streams across the different
RTCPeerConnections.[¶](#section-11-6){.pilcrow}

Note: This doesn\'t result in a tracking issue, since the creation of
matching CNAMEs depends on existing tracking within a single
origin.[¶](#section-11-7.1){.pilcrow}

The above will currently force a WebRTC endpoint that receives a
MediaStreamTrack on one RTCPeerConnection and adds it as outgoing one on
any RTCPeerConnection to perform resynchronization of the stream. Since
the sending party needs to change the CNAME to the one it uses, this
implies it has to use a local system clock as the timebase for the
synchronization. Thus, the relative relation between the timebase of the
incoming stream and the system sending out needs to be defined. This
relation also needs monitoring for clock drift and likely adjustments of
the synchronization. The sending entity is also responsible for
congestion control for its sent streams. In cases of packet loss, the
loss of incoming data also needs to be handled. This leads to the
observation that the method that is least likely to cause issues or
interruptions in the outgoing source packet stream is a model of full
decoding, including repair, followed by encoding of the media again into
the outgoing packet stream. Optimizations of this method are clearly
possible and implementation specific.[¶](#section-11-8){.pilcrow}

A WebRTC endpoint [MUST]{.bcp14} support receiving multiple
MediaStreamTracks, where each of the different MediaStreamTracks (and
its sets of associated packet streams) uses different CNAMEs. However,
MediaStreamTracks that are received with different CNAMEs have no
defined synchronization.[¶](#section-11-9){.pilcrow}

Note: The motivation for supporting reception of multiple CNAMEs is to
allow for forward compatibility with any future changes that enable more
efficient stream handling when endpoints relay/forward streams. It also
ensures that endpoints can interoperate with certain types of
multistream middleboxes or endpoints that are not
WebRTC.[¶](#section-11-10.1){.pilcrow}

[\"JavaScript Session Establishment Protocol (JSEP)\"](#RFC8829){.xref}
\[[RFC8829](#RFC8829){.xref}\] specifies that the binding between the
WebRTC MediaStreams, MediaStreamTracks, and the SSRC is done as
specified in [\"WebRTC MediaStream Identification in the Session
Description Protocol\"](#RFC8830){.xref} \[[RFC8830](#RFC8830){.xref}\].
Section 4.1 of [the MediaStream Identification (MSID)
document](#RFC8830){.xref} \[[RFC8830](#RFC8830){.xref}\] also defines
how to map source packet streams with unknown SSRCs to MediaStreamTracks
and MediaStreams. This later is relevant to handle some cases of legacy
interoperability. Commonly, the RTP payload type of any incoming packets
will reveal if the packet stream is a source stream or a redundancy or
dependent packet stream. The association to the correct source packet
stream depends on the payload format in use for the packet
stream.[¶](#section-11-11){.pilcrow}

Finally, this specification puts a requirement on the WebRTC API to
realize a method for determining the [CSRC list](#sec-rtp-rtcp){.xref}
([Section 4.1](#sec-rtp-rtcp){.xref}) as well as the [mixer-to-client
audio levels](#sec-mixer-to-client){.xref} ([Section
5.2.3](#sec-mixer-to-client){.xref}) (when supported); the basic
requirements for this is further discussed in [Section
12.2.1](#sec-media-stream-id){.xref}.[¶](#section-11-12){.pilcrow}
:::
:::

::: {#sec-rtp-func}
::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [RTP Implementation Considerations](#name-rtp-implementation-consider){.section-name .selfRef} {#name-rtp-implementation-consider}

The following discussion provides some guidance on the implementation of
the RTP features described in this memo. The focus is on a WebRTC
endpoint implementation perspective, and while some mention is made of
the behavior of middleboxes, that is not the focus of this
memo.[¶](#section-12-1){.pilcrow}

::: {#section-12.1 .section}
### [12.1.](#section-12.1){.section-number .selfRef} [Configuration and Use of RTP Sessions](#name-configuration-and-use-of-rt){.section-name .selfRef} {#name-configuration-and-use-of-rt}

A WebRTC endpoint will be a simultaneous participant in one or more RTP
sessions. Each RTP session can convey multiple media sources and include
media data from multiple endpoints. In the following, some ways in which
WebRTC endpoints can configure and use RTP sessions are
outlined.[¶](#section-12.1-1){.pilcrow}

::: {#sec.multiple-flows}
::: {#section-12.1.1 .section}
#### [12.1.1.](#section-12.1.1){.section-number .selfRef} [Use of Multiple Media Sources within an RTP Session](#name-use-of-multiple-media-sourc){.section-name .selfRef} {#name-use-of-multiple-media-sourc}

RTP is a group communication protocol, and every RTP session can
potentially contain multiple RTP packet streams. There are several
reasons why this might be desirable:[¶](#section-12.1.1-1){.pilcrow}

-   ::: {#section-12.1.1-2.1}
    Multiple media types:[¶](#section-12.1.1-2.1.1){.pilcrow}

    Outside of WebRTC, it is common to use one RTP session for each type
    of media source (e.g., one RTP session for audio sources and one for
    video sources, each sent over different transport-layer flows).
    However, to reduce the number of UDP ports used, the default in
    WebRTC is to send all types of media in a single RTP session, as
    described in [Section 4.4](#sec.session-mux){.xref}, using RTP and
    RTCP multiplexing ([Section 4.5](#sec.rtcp-mux){.xref}) to further
    reduce the number of UDP ports needed. This RTP session then uses
    only one bidirectional transport-layer flow but will contain
    multiple RTP packet streams, each containing a different type of
    media. A common example might be an endpoint with a camera and
    microphone that sends two RTP packet streams, one video and one
    audio, into a single RTP
    session.[¶](#section-12.1.1-2.1.2){.pilcrow}
    :::

-   ::: {#section-12.1.1-2.2}
    Multiple capture devices:[¶](#section-12.1.1-2.2.1){.pilcrow}

    A WebRTC endpoint might have multiple cameras, microphones, or other
    media capture devices, and so it might want to generate several RTP
    packet streams of the same media type. Alternatively, it might want
    to send media from a single capture device in several different
    formats or quality settings at once. Both can result in a single
    endpoint sending multiple RTP packet streams of the same media type
    into a single RTP session at the same
    time.[¶](#section-12.1.1-2.2.2){.pilcrow}
    :::

-   ::: {#section-12.1.1-2.3}
    Associated repair data:[¶](#section-12.1.1-2.3.1){.pilcrow}

    An endpoint might send an RTP packet stream that is somehow
    associated with another stream. For example, it might send an RTP
    packet stream that contains FEC or retransmission data relating to
    another stream. Some RTP payload formats send this sort of
    associated repair data as part of the source packet stream, while
    others send it as a separate packet
    stream.[¶](#section-12.1.1-2.3.2){.pilcrow}
    :::

-   ::: {#section-12.1.1-2.4}
    Layered or multiple-description
    coding:[¶](#section-12.1.1-2.4.1){.pilcrow}

    Within a single RTP session, an endpoint can use a layered media
    codec \-- for example, H.264 Scalable Video Coding (SVC) \-- or a
    multiple-description codec that generates multiple RTP packet
    streams, each with a distinct RTP
    SSRC.[¶](#section-12.1.1-2.4.2){.pilcrow}
    :::

-   ::: {#section-12.1.1-2.5}
    RTP mixers, translators, and other
    middleboxes:[¶](#section-12.1.1-2.5.1){.pilcrow}

    An RTP session, in the WebRTC context, is a point-to-point
    association between an endpoint and some other peer device, where
    those devices share a common SSRC space. The peer device might be
    another WebRTC endpoint, or it might be an RTP mixer, translator, or
    some other form of media-processing middlebox. In the latter cases,
    the middlebox might send mixed or relayed RTP streams from several
    participants, which the WebRTC endpoint will need to render. Thus,
    even though a WebRTC endpoint might only be a member of a single RTP
    session, the peer device might be extending that RTP session to
    incorporate other endpoints. WebRTC is a group communication
    environment, and endpoints need to be capable of receiving,
    decoding, and playing out multiple RTP packet streams at once, even
    in a single RTP session.[¶](#section-12.1.1-2.5.2){.pilcrow}
    :::
:::
:::

::: {#sec.multiple-sessions}
::: {#section-12.1.2 .section}
#### [12.1.2.](#section-12.1.2){.section-number .selfRef} [Use of Multiple RTP Sessions](#name-use-of-multiple-rtp-session){.section-name .selfRef} {#name-use-of-multiple-rtp-session}

In addition to sending and receiving multiple RTP packet streams within
a single RTP session, a WebRTC endpoint might participate in multiple
RTP sessions. There are several reasons why a WebRTC endpoint might
choose to do this:[¶](#section-12.1.2-1){.pilcrow}

-   ::: {#section-12.1.2-2.1}
    To interoperate with legacy
    devices:[¶](#section-12.1.2-2.1.1){.pilcrow}

    The common practice in the non-WebRTC world is to send different
    types of media in separate RTP sessions \-- for example, using one
    RTP session for audio and another RTP session, on a separate
    transport-layer flow, for video. All WebRTC endpoints need to
    support the option of sending different types of media on different
    RTP sessions so they can interwork with such legacy devices. This is
    discussed further in [Section
    4.4](#sec.session-mux){.xref}.[¶](#section-12.1.2-2.1.2){.pilcrow}
    :::

-   ::: {#section-12.1.2-2.2}
    To provide enhanced quality of
    service:[¶](#section-12.1.2-2.2.1){.pilcrow}

    Some network-based quality-of-service mechanisms operate on the
    granularity of transport-layer flows. If use of these mechanisms to
    provide differentiated quality of service for some RTP packet
    streams is desired, then those RTP packet streams need to be sent in
    a separate RTP session using a different transport-layer flow, and
    with appropriate quality-of-service marking. This is discussed
    further in [Section
    12.1.3](#sec-differentiated){.xref}.[¶](#section-12.1.2-2.2.2){.pilcrow}
    :::

-   ::: {#section-12.1.2-2.3}
    To separate media with different
    purposes:[¶](#section-12.1.2-2.3.1){.pilcrow}

    An endpoint might want to send RTP packet streams that have
    different purposes on different RTP sessions, to make it easy for
    the peer device to distinguish them. For example, some centralized
    multiparty conferencing systems display the active speaker in high
    resolution but show low-resolution \"thumbnails\" of other
    participants. Such systems might configure the endpoints to send
    simulcast high- and low-resolution versions of their video using
    separate RTP sessions to simplify the operation of the RTP
    middlebox. In the WebRTC context, this is currently possible by
    establishing multiple WebRTC MediaStreamTracks that have the same
    media source in one (or more) RTCPeerConnection. Each
    MediaStreamTrack is then configured to deliver a particular media
    quality and thus media bitrate, and it will produce an independently
    encoded version with the codec parameters agreed specifically in the
    context of that RTCPeerConnection. The RTP middlebox can distinguish
    packets corresponding to the low- and high-resolution streams by
    inspecting their SSRC, RTP payload type, or some other information
    contained in RTP payload, RTP header extension, or RTCP packets.
    However, it can be easier to distinguish the RTP packet streams if
    they arrive on separate RTP sessions on separate transport-layer
    flows.[¶](#section-12.1.2-2.3.2){.pilcrow}
    :::

-   ::: {#section-12.1.2-2.4}
    To directly connect with multiple
    peers:[¶](#section-12.1.2-2.4.1){.pilcrow}

    A multiparty conference does not need to use an RTP middlebox.
    Rather, a multi-unicast mesh can be created, comprising several
    distinct RTP sessions, with each participant sending RTP traffic
    over a separate RTP session (that is, using an independent
    RTCPeerConnection object) to every other participant, as shown in
    [Figure 1](#fig-mesh){.xref}. This topology has the benefit of not
    requiring an RTP middlebox node that is trusted to access and
    manipulate the media data. The downside is that it increases the
    used bandwidth at each sender by requiring one copy of the RTP
    packet streams for each participant that is part of the same session
    beyond the sender itself.[¶](#section-12.1.2-2.4.2){.pilcrow}

    []{#name-multi-unicast-using-several}
    ::: {#fig-mesh}
    ::: {#section-12.1.2-2.4.3.1 .artwork .art-text .alignLeft}

        +---+     +---+
        | A |<--->| B |
        +---+     +---+
          ^         ^
           \       /
            \     /
             v   v
             +---+
             | C |
             +---+
    :::

    [Figure 1](#figure-1){.selfRef}: [Multi-unicast Using Several RTP
    Sessions](#name-multi-unicast-using-several){.selfRef}
    :::

    The multi-unicast topology could also be implemented as a single RTP
    session, spanning multiple peer-to-peer transport-layer connections,
    or as several pairwise RTP sessions, one between each pair of peers.
    To maintain a coherent mapping of the relationship between RTP
    sessions and RTCPeerConnection objects, it is [RECOMMENDED]{.bcp14}
    that this be implemented as several individual RTP sessions. The
    only downside is that endpoint A will not learn of the quality of
    any transmission happening between B and C, since it will not see
    RTCP reports for the RTP session between B and C, whereas it would
    if all three participants were part of a single RTP session.
    Experience with the Mbone tools (experimental RTP-based multicast
    conferencing tools from the late 1990s) has shown that RTCP
    reception quality reports for third parties can be presented to
    users in a way that helps them understand asymmetric network
    problems, and the approach of using separate RTP sessions prevents
    this. However, an advantage of using separate RTP sessions is that
    it enables using different media bitrates and RTP session
    configurations between the different peers, thus not forcing B to
    endure the same quality reductions as C will if there are
    limitations in the transport from A to C. It is believed that these
    advantages outweigh the limitations in debugging
    power.[¶](#section-12.1.2-2.4.4){.pilcrow}
    :::

-   ::: {#section-12.1.2-2.5}
    To indirectly connect with multiple
    peers:[¶](#section-12.1.2-2.5.1){.pilcrow}

    A common scenario in multiparty conferencing is to create indirect
    connections to multiple peers, using an RTP mixer, translator, or
    some other type of RTP middlebox. [Figure 2](#fig-mixerFirst){.xref}
    outlines a simple topology that might be used in a four-person
    centralized conference. The middlebox acts to optimize the
    transmission of RTP packet streams from certain perspectives, either
    by only sending some of the received RTP packet stream to any given
    receiver, or by providing a combined RTP packet stream out of a set
    of contributing streams.[¶](#section-12.1.2-2.5.2){.pilcrow}

    []{#name-rtp-mixer-with-only-unicast}
    ::: {#fig-mixerFirst}
    ::: {#section-12.1.2-2.5.3.1 .artwork .art-text .alignLeft}

        +---+      +-------------+      +---+
        | A |<---->|             |<---->| B |
        +---+      | RTP mixer,  |      +---+
                   | translator, |
                   | or other    |
        +---+      | middlebox   |      +---+
        | C |<---->|             |<---->| D |
        +---+      +-------------+      +---+
    :::

    [Figure 2](#figure-2){.selfRef}: [RTP Mixer with Only Unicast
    Paths](#name-rtp-mixer-with-only-unicast){.selfRef}
    :::

    There are various methods of implementation for the middlebox. If
    implemented as a standard RTP mixer or translator, a single RTP
    session will extend across the middlebox and encompass all the
    endpoints in one multiparty session. Other types of middleboxes
    might use separate RTP sessions between each endpoint and the
    middlebox. A common aspect is that these RTP middleboxes can use a
    number of tools to control the media encoding provided by a WebRTC
    endpoint. This includes functions like requesting the breaking of
    the encoding chain and having the encoder produce a so-called Intra
    frame. Another common aspect is limiting the bitrate of a stream to
    better match the mixed output. Other aspects are controlling the
    most suitable frame rate, picture resolution, and the trade-off
    between frame rate and spatial quality. The middlebox has the
    responsibility to correctly perform congestion control, identify
    sources, and manage synchronization while providing the application
    with suitable media optimizations. The middlebox also has to be a
    trusted node when it comes to security, since it manipulates either
    the RTP header or the media itself (or both) received from one
    endpoint before sending them on towards the endpoint(s); thus they
    need to be able to decrypt and then re-encrypt the RTP packet stream
    before sending it out.[¶](#section-12.1.2-2.5.4){.pilcrow}

    Mixers are expected to not forward RTCP reports regarding RTP packet
    streams across themselves. This is due to the difference between the
    RTP packet streams provided to the different endpoints. The original
    media source lacks information about a mixer\'s manipulations prior
    to being sent to the different receivers. This scenario also results
    in an endpoint\'s feedback or requests going to the mixer. When the
    mixer can\'t act on this by itself, it is forced to go to the
    original media source to fulfill the receiver\'s request. This will
    not necessarily be explicitly visible to any RTP and RTCP traffic,
    but the interactions and the time to complete them will indicate
    such dependencies.[¶](#section-12.1.2-2.5.5){.pilcrow}

    Providing source authentication in multiparty scenarios is a
    challenge. In the mixer-based topologies, endpoints source
    authentication is based on, firstly, verifying that media comes from
    the mixer by cryptographic verification and, secondly, trust in the
    mixer to correctly identify any source towards the endpoint. In RTP
    sessions where multiple endpoints are directly visible to an
    endpoint, all endpoints will have knowledge about each others\'
    master keys and can thus inject packets claiming to come from
    another endpoint in the session. Any node performing relay can
    perform noncryptographic mitigation by preventing forwarding of
    packets that have SSRC fields that came from other endpoints before.
    For cryptographic verification of the source, SRTP would require
    additional security mechanisms \-- for example, [Timed Efficient
    Stream Loss-Tolerant Authentication (TESLA) for
    SRTP](#RFC4383){.xref} \[[RFC4383](#RFC4383){.xref}\] \-- that are
    not part of the base WebRTC
    standards.[¶](#section-12.1.2-2.5.6){.pilcrow}
    :::

-   ::: {#section-12.1.2-2.6}
    To forward media between multiple
    peers:[¶](#section-12.1.2-2.6.1){.pilcrow}

    It is sometimes desirable for an endpoint that receives an RTP
    packet stream to be able to forward that RTP packet stream to a
    third party. The are some obvious security and privacy implications
    in supporting this, but also potential uses. This is supported in
    the W3C API by taking the received and decoded media and using it as
    a media source that is re-encoded and transmitted as a new
    stream.[¶](#section-12.1.2-2.6.2){.pilcrow}

    At the RTP layer, media forwarding acts as a back-to-back RTP
    receiver and RTP sender. The receiving side terminates the RTP
    session and decodes the media, while the sender side re-encodes and
    transmits the media using an entirely separate RTP session. The
    original sender will only see a single receiver of the media, and
    will not be able to tell that forwarding is happening based on
    RTP-layer information, since the RTP session that is used to send
    the forwarded media is not connected to the RTP session on which the
    media was received by the node doing the
    forwarding.[¶](#section-12.1.2-2.6.3){.pilcrow}

    The endpoint that is performing the forwarding is responsible for
    producing an RTP packet stream suitable for onwards transmission.
    The outgoing RTP session that is used to send the forwarded media is
    entirely separate from the RTP session on which the media was
    received. This will require media transcoding for congestion control
    purposes to produce a suitable bitrate for the outgoing RTP session,
    reducing media quality and forcing the forwarding endpoint to spend
    the resource on the transcoding. The media transcoding does result
    in a separation of the two different legs, removing almost all
    dependencies, and allowing the forwarding endpoint to optimize its
    media transcoding operation. The cost is greatly increased
    computational complexity on the forwarding node. Receivers of the
    forwarded stream will see the forwarding device as the sender of the
    stream and will not be able to tell from the RTP layer that they are
    receiving a forwarded stream rather than an entirely new RTP packet
    stream generated by the forwarding
    device.[¶](#section-12.1.2-2.6.4){.pilcrow}
    :::
:::
:::

::: {#sec-differentiated}
::: {#section-12.1.3 .section}
#### [12.1.3.](#section-12.1.3){.section-number .selfRef} [Differentiated Treatment of RTP Streams](#name-differentiated-treatment-of){.section-name .selfRef} {#name-differentiated-treatment-of}

There are use cases for differentiated treatment of RTP packet streams.
Such differentiation can happen at several places in the system. First
of all is the prioritization within the endpoint sending the media,
which controls both which RTP packet streams will be sent and their
allocation of bitrate out of the current available aggregate, as
determined by the congestion control.[¶](#section-12.1.3-1){.pilcrow}

It is expected that the [WebRTC API](#W3C.WebRTC){.xref}
\[[W3C.WebRTC](#W3C.WebRTC){.xref}\] will allow the application to
indicate relative priorities for different MediaStreamTracks. These
priorities can then be used to influence the local RTP processing,
especially when it comes to determining how to divide the available
bandwidth between the RTP packet streams for the sake of congestion
control. Any changes in relative priority will also need to be
considered for RTP packet streams that are associated with the main RTP
packet streams, such as redundant streams for RTP retransmission and
FEC. The importance of such redundant RTP packet streams is dependent on
the media type and codec used, with regard to how robust that codec is
against packet loss. However, a default policy might be to use the same
priority for a redundant RTP packet stream as for the source RTP packet
stream.[¶](#section-12.1.3-2){.pilcrow}

Secondly, the network can prioritize transport-layer flows and subflows,
including RTP packet streams. Typically, differential treatment includes
two steps, the first being identifying whether an IP packet belongs to a
class that has to be treated differently, the second consisting of the
actual mechanism for prioritizing packets. Three common methods for
classifying IP packets are:[¶](#section-12.1.3-3){.pilcrow}

[]{.break}

DiffServ:
:   The endpoint marks a packet with a DiffServ code point to indicate
    to the network that the packet belongs to a particular
    class.[¶](#section-12.1.3-4.2){.pilcrow}
:   

Flow based:
:   Packets that need to be given a particular treatment are identified
    using a combination of IP and port
    address.[¶](#section-12.1.3-4.4){.pilcrow}
:   

Deep packet inspection:
:   A network classifier (DPI) inspects the packet and tries to
    determine if the packet represents a particular application and type
    that is to be prioritized.[¶](#section-12.1.3-4.6){.pilcrow}
:   

Flow-based differentiation will provide the same treatment to all
packets within a transport-layer flow, i.e., relative prioritization is
not possible. Moreover, if the resources are limited, it might not be
possible to provide differential treatment compared to best effort for
all the RTP packet streams used in a WebRTC session. The use of
flow-based differentiation needs to be coordinated between the WebRTC
system and the network(s). The WebRTC endpoint needs to know that
flow-based differentiation might be used to provide the separation of
the RTP packet streams onto different UDP flows to enable a more
granular usage of flow-based differentiation. The used flows, their
5-tuples, and prioritization will need to be communicated to the network
so that it can identify the flows correctly to enable prioritization. No
specific protocol support for this is
specified.[¶](#section-12.1.3-5){.pilcrow}

DiffServ assumes that either the endpoint or a classifier can mark the
packets with an appropriate Differentiated Services Code Point (DSCP) so
that the packets are treated according to that marking. If the endpoint
is to mark the traffic, two requirements arise in the WebRTC context: 1)
The WebRTC endpoint has to know which DSCPs to use and know that it can
use them on some set of RTP packet streams. 2) The information needs to
be propagated to the operating system when transmitting the packet.
Details of this process are outside the scope of this memo and are
further discussed in [\"Differentiated Services Code Point (DSCP) Packet
Markings for WebRTC QoS\"](#RFC8837){.xref}
\[[RFC8837](#RFC8837){.xref}\].[¶](#section-12.1.3-6){.pilcrow}

Despite the SRTP media encryption, deep packet inspectors will still be
fairly capable of classifying the RTP streams. The reason is that SRTP
leaves the first 12 bytes of the RTP header unencrypted. This enables
easy RTP stream identification using the SSRC and provides the
classifier with useful information that can be correlated to determine,
for example, the stream\'s media type. Using packet sizes, reception
times, packet inter-spacing, RTP timestamp increments, and sequence
numbers, fairly reliable classifications are
achieved.[¶](#section-12.1.3-7){.pilcrow}

For packet-based marking schemes, it might be possible to mark
individual RTP packets differently based on the relative priority of the
RTP payload. For example, video codecs that have I, P, and B pictures
could prioritize any payloads carrying only B frames less, as these are
less damaging to lose. However, depending on the QoS mechanism and what
markings are applied, this can result in not only different packet-drop
probabilities but also packet reordering; see
\[[RFC8837](#RFC8837){.xref}\] and \[[RFC7657](#RFC7657){.xref}\] for
further discussion. As a default policy, all RTP packets related to an
RTP packet stream ought to be provided with the same prioritization;
per-packet prioritization is outside the scope of this memo but might be
specified elsewhere in future.[¶](#section-12.1.3-8){.pilcrow}

It is also important to consider how RTCP packets associated with a
particular RTP packet stream need to be marked. RTCP compound packets
with Sender Reports (SRs) ought to be marked with the same priority as
the RTP packet stream itself, so the RTCP-based round-trip time (RTT)
measurements are done using the same transport-layer flow priority as
the RTP packet stream experiences. RTCP compound packets containing an
RR packet ought to be sent with the priority used by the majority of the
RTP packet streams reported on. RTCP packets containing time-critical
feedback packets can use higher priority to improve the timeliness and
likelihood of delivery of such feedback.[¶](#section-12.1.3-9){.pilcrow}
:::
:::
:::

::: {#section-12.2 .section}
### [12.2.](#section-12.2){.section-number .selfRef} [Media Source, RTP Streams, and Participant Identification](#name-media-source-rtp-streams-an){.section-name .selfRef} {#name-media-source-rtp-streams-an}

::: {#sec-media-stream-id}
::: {#section-12.2.1 .section}
#### [12.2.1.](#section-12.2.1){.section-number .selfRef} [Media Source Identification](#name-media-source-identification){.section-name .selfRef} {#name-media-source-identification}

Each RTP packet stream is identified by a unique synchronization source
(SSRC) identifier. The SSRC identifier is carried in each of the RTP
packets comprising an RTP packet stream, and is also used to identify
that stream in the corresponding RTCP reports. The SSRC is chosen as
discussed in [Section 4.8](#sec-ssrc){.xref}. The first stage in
demultiplexing RTP and RTCP packets received on a single transport-layer
flow at a WebRTC endpoint is to separate the RTP packet streams based on
their SSRC value; once that is done, additional demultiplexing steps can
determine how and where to render the
media.[¶](#section-12.2.1-1){.pilcrow}

RTP allows a mixer, or other RTP-layer middlebox, to combine encoded
streams from multiple media sources to form a new encoded stream from a
new media source (the mixer). The RTP packets in that new RTP packet
stream can include a contributing source (CSRC) list, indicating which
original SSRCs contributed to the combined source stream. As described
in [Section 4.1](#sec-rtp-rtcp){.xref}, implementations need to support
reception of RTP data packets containing a CSRC list and RTCP packets
that relate to sources present in the CSRC list. The CSRC list can
change on a packet-by-packet basis, depending on the mixing operation
being performed. Knowledge of what media sources contributed to a
particular RTP packet can be important if the user interface indicates
which participants are active in the session. Changes in the CSRC list
included in packets need to be exposed to the WebRTC application using
some API if the application is to be able to track changes in session
participation. It is desirable to map CSRC values back into WebRTC
MediaStream identities as they cross this API, to avoid exposing the
SSRC/CSRC namespace to WebRTC
applications.[¶](#section-12.2.1-2){.pilcrow}

If the mixer-to-client audio level extension
\[[RFC6465](#RFC6465){.xref}\] is being used in the session (see
[Section 5.2.3](#sec-mixer-to-client){.xref}), the information in the
CSRC list is augmented by audio-level information for each contributing
source. It is desirable to expose this information to the WebRTC
application using some API, after mapping the CSRC values to WebRTC
MediaStream identities, so it can be exposed in the user
interface.[¶](#section-12.2.1-3){.pilcrow}
:::
:::

::: {#section-12.2.2 .section}
#### [12.2.2.](#section-12.2.2){.section-number .selfRef} [SSRC Collision Detection](#name-ssrc-collision-detection){.section-name .selfRef} {#name-ssrc-collision-detection}

The RTP standard requires RTP implementations to have support for
detecting and handling SSRC collisions \-- i.e., be able to resolve the
conflict when two different endpoints use the same SSRC value (see
[Section
8.2](https://www.rfc-editor.org/rfc/rfc3550#section-8.2){.relref} of
\[[RFC3550](#RFC3550){.xref}\]). This requirement also applies to WebRTC
endpoints. There are several scenarios where SSRC collisions can
occur:[¶](#section-12.2.2-1){.pilcrow}

-   [In a point-to-point session where each SSRC is associated with
    either of the two endpoints and the main media-carrying SSRC
    identifier will be announced in the signaling channel, a collision
    is less likely to occur due to the information about used SSRCs. If
    SDP is used, this information is provided by [source-specific SDP
    attributes](#RFC5576){.xref} \[[RFC5576](#RFC5576){.xref}\]. Still,
    collisions can occur if both endpoints start using a new SSRC
    identifier prior to having signaled it to the peer and received
    acknowledgement on the signaling message. [\"Source-Specific Media
    Attributes in the Session Description Protocol
    (SDP)\"](#RFC5576){.xref} \[[RFC5576](#RFC5576){.xref}\] contains a
    mechanism to signal how the endpoint resolved the SSRC
    collision.[¶](#section-12.2.2-2.1){.pilcrow}]{#section-12.2.2-2.1}
-   [SSRC values that have not been signaled could also appear in an RTP
    session. This is more likely than it appears, since some RTP
    functions use extra SSRCs to provide their functionality. For
    example, retransmission data might be transmitted using a separate
    RTP packet stream that requires its own SSRC, separate from the SSRC
    of the source RTP packet stream \[[RFC4588](#RFC4588){.xref}\]. In
    those cases, an endpoint can create a new SSRC that strictly
    doesn\'t need to be announced over the signaling channel to function
    correctly on both RTP and RTCPeerConnection
    level.[¶](#section-12.2.2-2.2){.pilcrow}]{#section-12.2.2-2.2}
-   [Multiple endpoints in a multiparty conference can create new
    sources and signal those towards the RTP middlebox. In cases where
    the SSRC/CSRC are propagated between the different endpoints from
    the RTP middlebox, collisions can
    occur.[¶](#section-12.2.2-2.3){.pilcrow}]{#section-12.2.2-2.3}
-   [An RTP middlebox could connect an endpoint\'s RTCPeerConnection to
    another RTCPeerConnection from the same endpoint, thus forming a
    loop where the endpoint will receive its own traffic. While it is
    clearly considered a bug, it is important that the endpoint be able
    to recognize and handle the case when it occurs. This case becomes
    even more problematic when media mixers and such are involved, where
    the stream received is a different stream but still contains this
    client\'s
    input.[¶](#section-12.2.2-2.4){.pilcrow}]{#section-12.2.2-2.4}

These SSRC/CSRC collisions can only be handled on the RTP level when the
same RTP session is extended across multiple RTCPeerConnections by an
RTP middlebox. To resolve the more generic case where multiple
RTCPeerConnections are interconnected, identification of the media
source or sources that are part of a MediaStreamTrack being propagated
across multiple interconnected RTCPeerConnection needs to be preserved
across these interconnections.[¶](#section-12.2.2-3){.pilcrow}
:::

::: {#section-12.2.3 .section}
#### [12.2.3.](#section-12.2.3){.section-number .selfRef} [Media Synchronization Context](#name-media-synchronization-conte){.section-name .selfRef} {#name-media-synchronization-conte}

When an endpoint sends media from more than one media source, it needs
to consider if (and which of) these media sources are to be
synchronized. In RTP/RTCP, synchronization is provided by having a set
of RTP packet streams be indicated as coming from the same
synchronization context and logical endpoint by using the same RTCP
CNAME identifier.[¶](#section-12.2.3-1){.pilcrow}

The next provision is that the internal clocks of all media sources \--
i.e., what drives the RTP timestamp \-- can be correlated to a system
clock that is provided in RTCP Sender Reports encoded in an NTP format.
By correlating all RTP timestamps to a common system clock for all
sources, the timing relation of the different RTP packet streams, also
across multiple RTP sessions, can be derived at the receiver and, if
desired, the streams can be synchronized. The requirement is for the
media sender to provide the correlation information; whether or not the
information is used is up to the
receiver.[¶](#section-12.2.3-2){.pilcrow}
:::
:::
:::
:::

::: {#sec-security}
::: {#section-13 .section}
## [13.](#section-13){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

The overall security architecture for WebRTC is described in
\[[RFC8827](#RFC8827){.xref}\], and security considerations for the
WebRTC framework are described in \[[RFC8826](#RFC8826){.xref}\]. These
considerations also apply to this memo.[¶](#section-13-1){.pilcrow}

The security considerations of the RTP specification, the RTP/SAVPF
profile, and the various RTP/RTCP extensions and RTP payload formats
that form the complete protocol suite described in this memo apply. It
is believed that there are no new security considerations resulting from
the combination of these various protocol
extensions.[¶](#section-13-2){.pilcrow}

[\"Extended Secure RTP Profile for Real-time Transport Control Protocol
(RTCP)-Based Feedback (RTP/SAVPF)\"](#RFC5124){.xref}
\[[RFC5124](#RFC5124){.xref}\] provides handling of fundamental issues
by offering confidentiality, integrity, and partial source
authentication. A media-security solution that is mandatory to implement
and use is created by combining this secured RTP profile and [DTLS-SRTP
keying](#RFC5764){.xref} \[[RFC5764](#RFC5764){.xref}\], as defined by
[Section
5.5](https://www.rfc-editor.org/rfc/rfc8827#section-5.5){.relref} of
\[[RFC8827](#RFC8827){.xref}\].[¶](#section-13-3){.pilcrow}

RTCP packets convey a Canonical Name (CNAME) identifier that is used to
associate RTP packet streams that need to be synchronized across related
RTP sessions. Inappropriate choice of CNAME values can be a privacy
concern, since long-term persistent CNAME identifiers can be used to
track users across multiple WebRTC calls. [Section
4.9](#sec-cname){.xref} of this memo mandates generation of short-term
persistent RTCP CNAMES, as specified in RFC 7022, resulting in
untraceable CNAME values that alleviate this
risk.[¶](#section-13-4){.pilcrow}

Some potential denial-of-service attacks exist if the RTCP reporting
interval is configured to an inappropriate value. This could be done by
configuring the RTCP bandwidth fraction to an excessively large or small
value using the SDP \"b=RR:\" or \"b=RS:\" lines
\[[RFC3556](#RFC3556){.xref}\] or some similar mechanism, or by choosing
an excessively large or small value for the RTP/AVPF minimal receiver
report interval (if using SDP, this is the \"a=rtcp-fb:\... trr-int\"
parameter) \[[RFC4585](#RFC4585){.xref}\]. The risks are as
follows:[¶](#section-13-5){.pilcrow}

1.  [the RTCP bandwidth could be configured to make the regular
    reporting interval so large that effective congestion control cannot
    be maintained, potentially leading to denial of service due to
    congestion caused by the media
    traffic;[¶](#section-13-6.1){.pilcrow}]{#section-13-6.1}
2.  [the RTCP interval could be configured to a very small value,
    causing endpoints to generate high-rate RTCP traffic, potentially
    leading to denial of service due to the RTCP traffic not being
    congestion controlled;
    and[¶](#section-13-6.2){.pilcrow}]{#section-13-6.2}
3.  [RTCP parameters could be configured differently for each endpoint,
    with some of the endpoints using a large reporting interval and some
    using a smaller interval, leading to denial of service due to
    premature participant timeouts due to mismatched timeout periods
    that are based on the reporting interval. This is a particular
    concern if endpoints use a small but nonzero value for the RTP/AVPF
    minimal receiver report interval (trr-int)
    \[[RFC4585](#RFC4585){.xref}\], as discussed in [Section
    6.1](https://www.rfc-editor.org/rfc/rfc8108#section-6.1){.relref} of
    \[[RFC8108](#RFC8108){.xref}\].[¶](#section-13-6.3){.pilcrow}]{#section-13-6.3}

Premature participant timeout can be avoided by using the fixed
(nonreduced) minimum interval when calculating the participant timeout
(see [Section 4.1](#sec-rtp-rtcp){.xref} of this memo and [Section
7.1.2](https://www.rfc-editor.org/rfc/rfc8108#section-7.1.2){.relref} of
\[[RFC8108](#RFC8108){.xref}\]). To address the other concerns,
endpoints [SHOULD]{.bcp14} ignore parameters that configure the RTCP
reporting interval to be significantly longer than the default
five-second interval specified in \[[RFC3550](#RFC3550){.xref}\] (unless
the media data rate is so low that the longer reporting interval roughly
corresponds to 5% of the media data rate), or that configure the RTCP
reporting interval small enough that the RTCP bandwidth would exceed the
media bandwidth.[¶](#section-13-7){.pilcrow}

The guidelines in \[[RFC6562](#RFC6562){.xref}\] apply when using
variable bitrate (VBR) audio codecs such as Opus (see [Section
4.3](#sec.codecs){.xref} for discussion of mandated audio codecs). The
guidelines in \[[RFC6562](#RFC6562){.xref}\] also apply, but are of
lesser importance, when using the client-to-mixer audio level header
extensions ([Section 5.2.2](#sec-client-to-mixer){.xref}) or the
mixer-to-client audio level header extensions ([Section
5.2.3](#sec-mixer-to-client){.xref}). The use of the encryption of the
header extensions are [RECOMMENDED]{.bcp14}, unless there are known
reasons, like RTP middleboxes performing voice-activity-based source
selection or third-party monitoring that will greatly benefit from the
information, and this has been expressed using API or signaling. If
further evidence is produced to show that information leakage is
significant from audio-level indications, then use of encryption needs
to be mandated at that time.[¶](#section-13-8){.pilcrow}

In multiparty communication scenarios using RTP middleboxes, a lot of
trust is placed on these middleboxes to preserve the session\'s
security. The middlebox needs to maintain confidentiality and integrity
and perform source authentication. As discussed in [Section
12.1.1](#sec.multiple-flows){.xref}, the middlebox can perform checks
that prevent any endpoint participating in a conference from
impersonating another. Some additional security considerations regarding
multiparty topologies can be found in
\[[RFC7667](#RFC7667){.xref}\].[¶](#section-13-9){.pilcrow}
:::
:::

::: {#sec-iana}
::: {#section-14 .section}
## [14.](#section-14){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-14-1){.pilcrow}
:::
:::

::: {#section-15 .section}
## [15.](#section-15){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-15.1 .section}
### [15.1.](#section-15.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC2736\]
:   [Handley, M.]{.refAuthor}[ and C. Perkins]{.refAuthor},
    [\"Guidelines for Writers of RTP Payload Format
    Specifications\"]{.refTitle}, [BCP 36]{.seriesInfo}, [RFC
    2736]{.seriesInfo}, [DOI 10.17487/RFC2736]{.seriesInfo}, December
    1999, \<<https://www.rfc-editor.org/info/rfc2736>\>.
:   

\[RFC3550\]
:   [Schulzrinne, H.]{.refAuthor}[, Casner, S.]{.refAuthor}[,
    Frederick, R.]{.refAuthor}[, and V. Jacobson]{.refAuthor}, [\"RTP: A
    Transport Protocol for Real-Time Applications\"]{.refTitle}, [STD
    64]{.seriesInfo}, [RFC 3550]{.seriesInfo}, [DOI
    10.17487/RFC3550]{.seriesInfo}, July 2003,
    \<<https://www.rfc-editor.org/info/rfc3550>\>.
:   

\[RFC3551\]
:   [Schulzrinne, H.]{.refAuthor}[ and S. Casner]{.refAuthor}, [\"RTP
    Profile for Audio and Video Conferences with Minimal
    Control\"]{.refTitle}, [STD 65]{.seriesInfo}, [RFC
    3551]{.seriesInfo}, [DOI 10.17487/RFC3551]{.seriesInfo}, July 2003,
    \<<https://www.rfc-editor.org/info/rfc3551>\>.
:   

\[RFC3556\]
:   [Casner, S.]{.refAuthor}, [\"Session Description Protocol (SDP)
    Bandwidth Modifiers for RTP Control Protocol (RTCP)
    Bandwidth\"]{.refTitle}, [RFC 3556]{.seriesInfo}, [DOI
    10.17487/RFC3556]{.seriesInfo}, July 2003,
    \<<https://www.rfc-editor.org/info/rfc3556>\>.
:   

\[RFC3711\]
:   [Baugher, M.]{.refAuthor}[, McGrew, D.]{.refAuthor}[,
    Naslund, M.]{.refAuthor}[, Carrara, E.]{.refAuthor}[, and K.
    Norrman]{.refAuthor}, [\"The Secure Real-time Transport Protocol
    (SRTP)\"]{.refTitle}, [RFC 3711]{.seriesInfo}, [DOI
    10.17487/RFC3711]{.seriesInfo}, March 2004,
    \<<https://www.rfc-editor.org/info/rfc3711>\>.
:   

\[RFC4566\]
:   [Handley, M.]{.refAuthor}[, Jacobson, V.]{.refAuthor}[, and C.
    Perkins]{.refAuthor}, [\"SDP: Session Description
    Protocol\"]{.refTitle}, [RFC 4566]{.seriesInfo}, [DOI
    10.17487/RFC4566]{.seriesInfo}, July 2006,
    \<<https://www.rfc-editor.org/info/rfc4566>\>.
:   

\[RFC4585\]
:   [Ott, J.]{.refAuthor}[, Wenger, S.]{.refAuthor}[,
    Sato, N.]{.refAuthor}[, Burmeister, C.]{.refAuthor}[, and J.
    Rey]{.refAuthor}, [\"Extended RTP Profile for Real-time Transport
    Control Protocol (RTCP)-Based Feedback (RTP/AVPF)\"]{.refTitle},
    [RFC 4585]{.seriesInfo}, [DOI 10.17487/RFC4585]{.seriesInfo}, July
    2006, \<<https://www.rfc-editor.org/info/rfc4585>\>.
:   

\[RFC4588\]
:   [Rey, J.]{.refAuthor}[, Leon, D.]{.refAuthor}[,
    Miyazaki, A.]{.refAuthor}[, Varsa, V.]{.refAuthor}[, and R.
    Hakenberg]{.refAuthor}, [\"RTP Retransmission Payload
    Format\"]{.refTitle}, [RFC 4588]{.seriesInfo}, [DOI
    10.17487/RFC4588]{.seriesInfo}, July 2006,
    \<<https://www.rfc-editor.org/info/rfc4588>\>.
:   

\[RFC4961\]
:   [Wing, D.]{.refAuthor}, [\"Symmetric RTP / RTP Control Protocol
    (RTCP)\"]{.refTitle}, [BCP 131]{.seriesInfo}, [RFC
    4961]{.seriesInfo}, [DOI 10.17487/RFC4961]{.seriesInfo}, July 2007,
    \<<https://www.rfc-editor.org/info/rfc4961>\>.
:   

\[RFC5104\]
:   [Wenger, S.]{.refAuthor}[, Chandra, U.]{.refAuthor}[,
    Westerlund, M.]{.refAuthor}[, and B. Burman]{.refAuthor}, [\"Codec
    Control Messages in the RTP Audio-Visual Profile with Feedback
    (AVPF)\"]{.refTitle}, [RFC 5104]{.seriesInfo}, [DOI
    10.17487/RFC5104]{.seriesInfo}, February 2008,
    \<<https://www.rfc-editor.org/info/rfc5104>\>.
:   

\[RFC5124\]
:   [Ott, J.]{.refAuthor}[ and E. Carrara]{.refAuthor}, [\"Extended
    Secure RTP Profile for Real-time Transport Control Protocol
    (RTCP)-Based Feedback (RTP/SAVPF)\"]{.refTitle}, [RFC
    5124]{.seriesInfo}, [DOI 10.17487/RFC5124]{.seriesInfo}, February
    2008, \<<https://www.rfc-editor.org/info/rfc5124>\>.
:   

\[RFC5506\]
:   [Johansson, I.]{.refAuthor}[ and M. Westerlund]{.refAuthor},
    [\"Support for Reduced-Size Real-Time Transport Control Protocol
    (RTCP): Opportunities and Consequences\"]{.refTitle}, [RFC
    5506]{.seriesInfo}, [DOI 10.17487/RFC5506]{.seriesInfo}, April 2009,
    \<<https://www.rfc-editor.org/info/rfc5506>\>.
:   

\[RFC5761\]
:   [Perkins, C.]{.refAuthor}[ and M. Westerlund]{.refAuthor},
    [\"Multiplexing RTP Data and Control Packets on a Single
    Port\"]{.refTitle}, [RFC 5761]{.seriesInfo}, [DOI
    10.17487/RFC5761]{.seriesInfo}, April 2010,
    \<<https://www.rfc-editor.org/info/rfc5761>\>.
:   

\[RFC5764\]
:   [McGrew, D.]{.refAuthor}[ and E. Rescorla]{.refAuthor}, [\"Datagram
    Transport Layer Security (DTLS) Extension to Establish Keys for the
    Secure Real-time Transport Protocol (SRTP)\"]{.refTitle}, [RFC
    5764]{.seriesInfo}, [DOI 10.17487/RFC5764]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5764>\>.
:   

\[RFC6051\]
:   [Perkins, C.]{.refAuthor}[ and T. Schierl]{.refAuthor}, [\"Rapid
    Synchronisation of RTP Flows\"]{.refTitle}, [RFC 6051]{.seriesInfo},
    [DOI 10.17487/RFC6051]{.seriesInfo}, November 2010,
    \<<https://www.rfc-editor.org/info/rfc6051>\>.
:   

\[RFC6464\]
:   [Lennox, J., Ed.]{.refAuthor}[, Ivov, E.]{.refAuthor}[, and E.
    Marocco]{.refAuthor}, [\"A Real-time Transport Protocol (RTP) Header
    Extension for Client-to-Mixer Audio Level Indication\"]{.refTitle},
    [RFC 6464]{.seriesInfo}, [DOI 10.17487/RFC6464]{.seriesInfo},
    December 2011, \<<https://www.rfc-editor.org/info/rfc6464>\>.
:   

\[RFC6465\]
:   [Ivov, E., Ed.]{.refAuthor}[, Marocco, E., Ed.]{.refAuthor}[, and J.
    Lennox]{.refAuthor}, [\"A Real-time Transport Protocol (RTP) Header
    Extension for Mixer-to-Client Audio Level Indication\"]{.refTitle},
    [RFC 6465]{.seriesInfo}, [DOI 10.17487/RFC6465]{.seriesInfo},
    December 2011, \<<https://www.rfc-editor.org/info/rfc6465>\>.
:   

\[RFC6562\]
:   [Perkins, C.]{.refAuthor}[ and JM. Valin]{.refAuthor}, [\"Guidelines
    for the Use of Variable Bit Rate Audio with Secure
    RTP\"]{.refTitle}, [RFC 6562]{.seriesInfo}, [DOI
    10.17487/RFC6562]{.seriesInfo}, March 2012,
    \<<https://www.rfc-editor.org/info/rfc6562>\>.
:   

\[RFC6904\]
:   [Lennox, J.]{.refAuthor}, [\"Encryption of Header Extensions in the
    Secure Real-time Transport Protocol (SRTP)\"]{.refTitle}, [RFC
    6904]{.seriesInfo}, [DOI 10.17487/RFC6904]{.seriesInfo}, April 2013,
    \<<https://www.rfc-editor.org/info/rfc6904>\>.
:   

\[RFC7007\]
:   [Terriberry, T.]{.refAuthor}, [\"Update to Remove DVI4 from the
    Recommended Codecs for the RTP Profile for Audio and Video
    Conferences with Minimal Control (RTP/AVP)\"]{.refTitle}, [RFC
    7007]{.seriesInfo}, [DOI 10.17487/RFC7007]{.seriesInfo}, August
    2013, \<<https://www.rfc-editor.org/info/rfc7007>\>.
:   

\[RFC7022\]
:   [Begen, A.]{.refAuthor}[, Perkins, C.]{.refAuthor}[,
    Wing, D.]{.refAuthor}[, and E. Rescorla]{.refAuthor}, [\"Guidelines
    for Choosing RTP Control Protocol (RTCP) Canonical Names
    (CNAMEs)\"]{.refTitle}, [RFC 7022]{.seriesInfo}, [DOI
    10.17487/RFC7022]{.seriesInfo}, September 2013,
    \<<https://www.rfc-editor.org/info/rfc7022>\>.
:   

\[RFC7160\]
:   [Petit-Huguenin, M.]{.refAuthor}[ and G. Zorn, Ed.]{.refAuthor},
    [\"Support for Multiple Clock Rates in an RTP Session\"]{.refTitle},
    [RFC 7160]{.seriesInfo}, [DOI 10.17487/RFC7160]{.seriesInfo}, April
    2014, \<<https://www.rfc-editor.org/info/rfc7160>\>.
:   

\[RFC7164\]
:   [Gross, K.]{.refAuthor}[ and R. Brandenburg]{.refAuthor}, [\"RTP and
    Leap Seconds\"]{.refTitle}, [RFC 7164]{.seriesInfo}, [DOI
    10.17487/RFC7164]{.seriesInfo}, March 2014,
    \<<https://www.rfc-editor.org/info/rfc7164>\>.
:   

\[RFC7742\]
:   [Roach, A.B.]{.refAuthor}, [\"WebRTC Video Processing and Codec
    Requirements\"]{.refTitle}, [RFC 7742]{.seriesInfo}, [DOI
    10.17487/RFC7742]{.seriesInfo}, March 2016,
    \<<https://www.rfc-editor.org/info/rfc7742>\>.
:   

\[RFC7874\]
:   [Valin, JM.]{.refAuthor}[ and C. Bran]{.refAuthor}, [\"WebRTC Audio
    Codec and Processing Requirements\"]{.refTitle}, [RFC
    7874]{.seriesInfo}, [DOI 10.17487/RFC7874]{.seriesInfo}, May 2016,
    \<<https://www.rfc-editor.org/info/rfc7874>\>.
:   

\[RFC8083\]
:   [Perkins, C.]{.refAuthor}[ and V. Singh]{.refAuthor}, [\"Multimedia
    Congestion Control: Circuit Breakers for Unicast RTP
    Sessions\"]{.refTitle}, [RFC 8083]{.seriesInfo}, [DOI
    10.17487/RFC8083]{.seriesInfo}, March 2017,
    \<<https://www.rfc-editor.org/info/rfc8083>\>.
:   

\[RFC8108\]
:   [Lennox, J.]{.refAuthor}[, Westerlund, M.]{.refAuthor}[,
    Wu, Q.]{.refAuthor}[, and C. Perkins]{.refAuthor}, [\"Sending
    Multiple RTP Streams in a Single RTP Session\"]{.refTitle}, [RFC
    8108]{.seriesInfo}, [DOI 10.17487/RFC8108]{.seriesInfo}, March 2017,
    \<<https://www.rfc-editor.org/info/rfc8108>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8285\]
:   [Singer, D.]{.refAuthor}[, Desineni, H.]{.refAuthor}[, and R. Even,
    Ed.]{.refAuthor}, [\"A General Mechanism for RTP Header
    Extensions\"]{.refTitle}, [RFC 8285]{.seriesInfo}, [DOI
    10.17487/RFC8285]{.seriesInfo}, October 2017,
    \<<https://www.rfc-editor.org/info/rfc8285>\>.
:   

\[RFC8825\]
:   [Alvestrand, H.]{.refAuthor}, [\"Overview: Real-Time Protocols for
    Browser-Based Applications\"]{.refTitle}, [RFC 8825]{.seriesInfo},
    [DOI 10.17487/RFC8825]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8825>\>.
:   

\[RFC8826\]
:   [Rescorla, E.]{.refAuthor}, [\"Security Considerations for
    WebRTC\"]{.refTitle}, [RFC 8826]{.seriesInfo}, [DOI
    10.17487/RFC8826]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8826>\>.
:   

\[RFC8827\]
:   [Rescorla, E.]{.refAuthor}, [\"WebRTC Security
    Architecture\"]{.refTitle}, [RFC 8827]{.seriesInfo}, [DOI
    10.17487/RFC8827]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8827>\>.
:   

\[RFC8843\]
:   [Holmberg, C.]{.refAuthor}[, Alvestrand, H.]{.refAuthor}[, and C.
    Jennings]{.refAuthor}, [\"Negotiating Media Multiplexing Using the
    Session Description Protocol (SDP)\"]{.refTitle}, [RFC
    8843]{.seriesInfo}, [DOI 10.17487/RFC8843]{.seriesInfo}, January
    2021, \<<https://www.rfc-editor.org/info/rfc8843>\>.
:   

\[RFC8854\]
:   [Uberti, J.]{.refAuthor}, [\"WebRTC Forward Error Correction
    Requirements\"]{.refTitle}, [RFC 8854]{.seriesInfo}, [DOI
    10.17487/RFC8854]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8854>\>.
:   

\[RFC8858\]
:   [Holmberg, C.]{.refAuthor}, [\"Indicating Exclusive Support of RTP
    and RTP Control Protocol (RTCP) Multiplexing Using the Session
    Description Protocol (SDP)\"]{.refTitle}, [RFC 8858]{.seriesInfo},
    [DOI 10.17487/RFC8858]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8858>\>.
:   

\[RFC8860\]
:   [Westerlund, M.]{.refAuthor}[, Perkins, C.]{.refAuthor}[, and J.
    Lennox]{.refAuthor}, [\"Sending Multiple Types of Media in a Single
    RTP Session\"]{.refTitle}, [RFC 8860]{.seriesInfo}, [DOI
    10.17487/RFC8860]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8860>\>.
:   

\[RFC8861\]
:   [Lennox, J.]{.refAuthor}[, Westerlund, M.]{.refAuthor}[,
    Wu, Q.]{.refAuthor}[, and C. Perkins]{.refAuthor}, [\"Sending
    Multiple RTP Streams in a Single RTP Session: Grouping RTP Control
    Protocol (RTCP) Reception Statistics and Other
    Feedback\"]{.refTitle}, [RFC 8861]{.seriesInfo}, [DOI
    10.17487/RFC8861]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8861>\>.
:   

\[W3C.WD-mediacapture-streams\]
:   [Jennings, C.]{.refAuthor}[, Aboba, B.]{.refAuthor}[, Bruaroey,
    J-I.]{.refAuthor}[, and H. Boström]{.refAuthor}, [\"Media Capture
    and Streams\"]{.refTitle}, [W3C Candidate
    Recommendation]{.refContent},
    \<<https://www.w3.org/TR/mediacapture-streams/>\>.
:   

\[W3C.WebRTC\]
:   [Jennings, C.]{.refAuthor}[, Boström, H.]{.refAuthor}[, and J-I.
    Bruaroey]{.refAuthor}, [\"WebRTC 1.0: Real-time Communication
    Between Browsers\"]{.refTitle}, [W3C Proposed
    Recommendation]{.refContent}, \<<https://www.w3.org/TR/webrtc/>\>.
:   
:::

::: {#section-15.2 .section}
### [15.2.](#section-15.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[RFC3611\]
:   [Friedman, T., Ed.]{.refAuthor}[, Caceres, R., Ed.]{.refAuthor}[,
    and A. Clark, Ed.]{.refAuthor}, [\"RTP Control Protocol Extended
    Reports (RTCP XR)\"]{.refTitle}, [RFC 3611]{.seriesInfo}, [DOI
    10.17487/RFC3611]{.seriesInfo}, November 2003,
    \<<https://www.rfc-editor.org/info/rfc3611>\>.
:   

\[RFC4383\]
:   [Baugher, M.]{.refAuthor}[ and E. Carrara]{.refAuthor}, [\"The Use
    of Timed Efficient Stream Loss-Tolerant Authentication (TESLA) in
    the Secure Real-time Transport Protocol (SRTP)\"]{.refTitle}, [RFC
    4383]{.seriesInfo}, [DOI 10.17487/RFC4383]{.seriesInfo}, February
    2006, \<<https://www.rfc-editor.org/info/rfc4383>\>.
:   

\[RFC5576\]
:   [Lennox, J.]{.refAuthor}[, Ott, J.]{.refAuthor}[, and T.
    Schierl]{.refAuthor}, [\"Source-Specific Media Attributes in the
    Session Description Protocol (SDP)\"]{.refTitle}, [RFC
    5576]{.seriesInfo}, [DOI 10.17487/RFC5576]{.seriesInfo}, June 2009,
    \<<https://www.rfc-editor.org/info/rfc5576>\>.
:   

\[RFC5968\]
:   [Ott, J.]{.refAuthor}[ and C. Perkins]{.refAuthor}, [\"Guidelines
    for Extending the RTP Control Protocol (RTCP)\"]{.refTitle}, [RFC
    5968]{.seriesInfo}, [DOI 10.17487/RFC5968]{.seriesInfo}, September
    2010, \<<https://www.rfc-editor.org/info/rfc5968>\>.
:   

\[RFC6263\]
:   [Marjou, X.]{.refAuthor}[ and A. Sollaud]{.refAuthor},
    [\"Application Mechanism for Keeping Alive the NAT Mappings
    Associated with RTP / RTP Control Protocol (RTCP)
    Flows\"]{.refTitle}, [RFC 6263]{.seriesInfo}, [DOI
    10.17487/RFC6263]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6263>\>.
:   

\[RFC6792\]
:   [Wu, Q., Ed.]{.refAuthor}[, Hunt, G.]{.refAuthor}[, and P.
    Arden]{.refAuthor}, [\"Guidelines for Use of the RTP Monitoring
    Framework\"]{.refTitle}, [RFC 6792]{.seriesInfo}, [DOI
    10.17487/RFC6792]{.seriesInfo}, November 2012,
    \<<https://www.rfc-editor.org/info/rfc6792>\>.
:   

\[RFC7478\]
:   [Holmberg, C.]{.refAuthor}[, Hakansson, S.]{.refAuthor}[, and G.
    Eriksson]{.refAuthor}, [\"Web Real-Time Communication Use Cases and
    Requirements\"]{.refTitle}, [RFC 7478]{.seriesInfo}, [DOI
    10.17487/RFC7478]{.seriesInfo}, March 2015,
    \<<https://www.rfc-editor.org/info/rfc7478>\>.
:   

\[RFC7656\]
:   [Lennox, J.]{.refAuthor}[, Gross, K.]{.refAuthor}[,
    Nandakumar, S.]{.refAuthor}[, Salgueiro, G.]{.refAuthor}[, and B.
    Burman, Ed.]{.refAuthor}, [\"A Taxonomy of Semantics and Mechanisms
    for Real-Time Transport Protocol (RTP) Sources\"]{.refTitle}, [RFC
    7656]{.seriesInfo}, [DOI 10.17487/RFC7656]{.seriesInfo}, November
    2015, \<<https://www.rfc-editor.org/info/rfc7656>\>.
:   

\[RFC7657\]
:   [Black, D., Ed.]{.refAuthor}[ and P. Jones]{.refAuthor},
    [\"Differentiated Services (Diffserv) and Real-Time
    Communication\"]{.refTitle}, [RFC 7657]{.seriesInfo}, [DOI
    10.17487/RFC7657]{.seriesInfo}, November 2015,
    \<<https://www.rfc-editor.org/info/rfc7657>\>.
:   

\[RFC7667\]
:   [Westerlund, M.]{.refAuthor}[ and S. Wenger]{.refAuthor}, [\"RTP
    Topologies\"]{.refTitle}, [RFC 7667]{.seriesInfo}, [DOI
    10.17487/RFC7667]{.seriesInfo}, November 2015,
    \<<https://www.rfc-editor.org/info/rfc7667>\>.
:   

\[RFC8088\]
:   [Westerlund, M.]{.refAuthor}, [\"How to Write an RTP Payload
    Format\"]{.refTitle}, [RFC 8088]{.seriesInfo}, [DOI
    10.17487/RFC8088]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8088>\>.
:   

\[RFC8445\]
:   [Keranen, A.]{.refAuthor}[, Holmberg, C.]{.refAuthor}[, and J.
    Rosenberg]{.refAuthor}, [\"Interactive Connectivity Establishment
    (ICE): A Protocol for Network Address Translator (NAT)
    Traversal\"]{.refTitle}, [RFC 8445]{.seriesInfo}, [DOI
    10.17487/RFC8445]{.seriesInfo}, July 2018,
    \<<https://www.rfc-editor.org/info/rfc8445>\>.
:   

\[RFC8829\]
:   [Uberti, J.]{.refAuthor}[, Jennings, C.]{.refAuthor}[, and E.
    Rescorla, Ed.]{.refAuthor}, [\"JavaScript Session Establishment
    Protocol (JSEP)\"]{.refTitle}, [RFC 8829]{.seriesInfo}, [DOI
    10.17487/RFC8829]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8829>\>.
:   

\[RFC8830\]
:   [Alvestrand, H.]{.refAuthor}, [\"WebRTC MediaStream Identification
    in the Session Description Protocol\"]{.refTitle}, [RFC
    8830]{.seriesInfo}, [DOI 10.17487/RFC8830]{.seriesInfo}, January
    2021, \<<https://www.rfc-editor.org/info/rfc8830>\>.
:   

\[RFC8836\]
:   [Jesup, R.]{.refAuthor}[ and Z. Sarker, Ed.]{.refAuthor},
    [\"Congestion Control Requirements for Interactive Real-Time
    Media\"]{.refTitle}, [RFC 8836]{.seriesInfo}, [DOI
    10.17487/RFC8836]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8836>\>.
:   

\[RFC8837\]
:   [Jones, P.]{.refAuthor}[, Dhesikan, S.]{.refAuthor}[,
    Jennings, C.]{.refAuthor}[, and D. Druta]{.refAuthor},
    [\"Differentiated Services Code Point (DSCP) Packet Markings for
    WebRTC QoS\"]{.refTitle}, [RFC 8837]{.seriesInfo}, [DOI
    10.17487/RFC8837]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8837>\>.
:   

\[RFC8872\]
:   [Westerlund, M.]{.refAuthor}[, Burman, B.]{.refAuthor}[,
    Perkins, C.]{.refAuthor}[, Alvestrand, H.]{.refAuthor}[, and R.
    Even]{.refAuthor}, [\"Guidelines for Using the Multiplexing Features
    of RTP to Support Multiple Media Streams\"]{.refTitle}, [RFC
    8872]{.seriesInfo}, [DOI 10.17487/RFC8872]{.seriesInfo}, January
    2021, \<<https://www.rfc-editor.org/info/rfc8872>\>.
:   
:::
:::

::: {#Acknowledgements}
::: {#section-appendix.a .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

The authors would like to thank [Bernard Aboba]{.contact-name}, [Harald
Alvestrand]{.contact-name}, [Cary Bran]{.contact-name}, [Ben
Campbell]{.contact-name}, [Alissa Cooper]{.contact-name}, [Spencer
Dawkins]{.contact-name}, [Charles Eckel]{.contact-name}, [Alex
Eleftheriadis]{.contact-name}, [Christian Groves]{.contact-name}, [Chris
Inacio]{.contact-name}, [Cullen Jennings]{.contact-name}, [Olle
Johansson]{.contact-name}, [Suhas Nandakumar]{.contact-name}, [Dan
Romascanu]{.contact-name}, [Jim Spring]{.contact-name}, [Martin
Thomson]{.contact-name}, and the other members of the IETF RTCWEB
working group for their valuable
feedback.[¶](#section-appendix.a-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.b .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Colin Perkins]{.fn .nameRole}
:::

::: {.left dir="auto"}
[University of Glasgow]{.org}
:::

::: {.left dir="auto"}
[School of Computing Science]{.street-address}
:::

::: {.left dir="auto"}
[Glasgow]{.locality}
:::

::: {.left dir="auto"}
[G12 8QQ]{.postal-code}
:::

::: {.left dir="auto"}
[United Kingdom]{.country-name}
:::

::: email
Email: <csp@csperkins.org>
:::

::: url
URI: <https://csperkins.org/>
:::

::: {.left dir="auto"}
[Magnus Westerlund]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Ericsson]{.org}
:::

::: {.left dir="auto"}
[Torshamnsgatan 23]{.street-address}
:::

::: {.left dir="auto"}
SE-[164 80]{.postal-code} [Kista]{.locality}
:::

::: {.left dir="auto"}
[Sweden]{.country-name}
:::

::: email
Email: <magnus.westerlund@ericsson.com>
:::

::: {.left dir="auto"}
[Jörg Ott]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Technical University Munich]{.org}
:::

::: {.left dir="auto"}
[Department of Informatics\
Chair of Connected Mobility]{.extended-address}
:::

::: {.left dir="auto"}
[Boltzmannstrasse 3]{.street-address}
:::

::: {.left dir="auto"}
[85748]{.postal-code} [Garching]{.locality}
:::

::: {.left dir="auto"}
[Germany]{.country-name}
:::

::: email
Email: <ott@in.tum.de>
:::
:::
:::
