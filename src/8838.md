  RFC 8838       Trickle ICE       January 2021
  -------------- ----------------- --------------
  Ivov, et al.   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8838](https://www.rfc-editor.org/rfc/rfc8838){.eref}

Category:
:   Standards Track

Published:
:   January 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    E. Ivov
    :::

    ::: org
    8x8 / Jitsi
    :::
    :::

    ::: author
    ::: author-name
    J. Uberti
    :::

    ::: org
    Google
    :::
    :::

    ::: author
    ::: author-name
    P. Saint-Andre
    :::

    ::: org
    Mozilla
    :::
    :::
:::

# RFC 8838 {#rfcnum}

# Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes \"Trickle ICE\", an extension to the Interactive
Connectivity Establishment (ICE) protocol that enables ICE agents to
begin connectivity checks while they are still gathering candidates, by
incrementally exchanging candidates over time instead of all at once.
This method can considerably accelerate the process of establishing a
communication session.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8838>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Determining Support for Trickle
    ICE](#name-determining-support-for-tri){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Generating the Initial ICE
    Description](#name-generating-the-initial-ice-){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Handling the Initial ICE Description and
    Generating the Initial ICE
    Response](#name-handling-the-initial-ice-de){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Handling the Initial ICE
    Response](#name-handling-the-initial-ice-re){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Forming
    Checklists](#name-forming-checklists){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Performing Connectivity
    Checks](#name-performing-connectivity-che){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Gathering and Conveying Newly Gathered
    Local
    Candidates](#name-gathering-and-conveying-new){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Pairing Newly Gathered Local
    Candidates](#name-pairing-newly-gathered-loca){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [Receiving Trickled
    Candidates](#name-receiving-trickled-candidat){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [Inserting Trickled Candidate Pairs into a
    Checklist](#name-inserting-trickled-candidat){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.13}
    [13](#section-13){.xref}. [Generating an End-of-Candidates
    Indication](#name-generating-an-end-of-candid){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.14}
    [14](#section-14){.xref}. [Receiving an End-of-Candidates
    Indication](#name-receiving-an-end-of-candida){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.15}
    [15](#section-15){.xref}. [Subsequent Exchanges and ICE
    Restarts](#name-subsequent-exchanges-and-ic){.xref}[¶](#section-toc.1-1.15.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.16}
    [16](#section-16){.xref}. [Half
    Trickle](#name-half-trickle){.xref}[¶](#section-toc.1-1.16.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.17}
    [17](#section-17){.xref}. [Preserving Candidate Order While
    Trickling](#name-preserving-candidate-order-){.xref}[¶](#section-toc.1-1.17.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.18}
    [18](#section-18){.xref}. [Requirements for Using
    Protocols](#name-requirements-for-using-prot){.xref}[¶](#section-toc.1-1.18.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.19}
    [19](#section-19){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.19.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.20}
    [20](#section-20){.xref}. [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.20.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.21}
    [21](#section-21){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.21.1){.pilcrow}

    -   ::: {#section-toc.1-1.21.2.1}
        [21.1](#section-21.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.21.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.21.2.2}
        [21.2](#section-21.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.21.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.22}
    [Appendix A](#section-appendix.a){.xref}.  [Interaction with Regular
    ICE](#name-interaction-with-regular-ic){.xref}[¶](#section-toc.1-1.22.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.23}
    [Appendix B](#section-appendix.b){.xref}.  [Interaction with
    ICE-Lite](#name-interaction-with-ice-lite){.xref}[¶](#section-toc.1-1.23.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.24}
    [](#section-appendix.c){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.24.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.25}
    [](#section-appendix.d){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.25.1){.pilcrow}
    :::
:::
:::

::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The Interactive Connectivity Establishment (ICE) protocol
\[[RFC8445](#RFC8445){.xref}\] describes how an ICE agent gathers
candidates, exchanges candidates with a peer ICE agent, and creates
candidate pairs. Once the pairs have been gathered, the ICE agent will
perform connectivity checks and eventually nominate and select pairs
that will be used for sending and receiving data within a communication
session.[¶](#section-1-1){.pilcrow}

Following the procedures in \[[RFC8445](#RFC8445){.xref}\] can lead to
somewhat lengthy establishment times for communication sessions, because
candidate gathering often involves querying Session Traversal Utilities
for NAT (STUN) servers \[[RFC5389](#RFC5389){.xref}\] and allocating
relayed candidates on Traversal Using Relay NAT (TURN) servers
\[[RFC5766](#RFC5766){.xref}\]. Although many ICE procedures can be
completed in parallel, the pacing requirements from
\[[RFC8445](#RFC8445){.xref}\] still need to be
followed.[¶](#section-1-2){.pilcrow}

This document defines \"Trickle ICE\", a supplementary mode of ICE
operation in which candidates can be exchanged incrementally as soon as
they become available (and simultaneously with the gathering of other
candidates). Connectivity checks can also start as soon as candidate
pairs have been created. Because Trickle ICE enables candidate gathering
and connectivity checks to be done in parallel, the method can
considerably accelerate the process of establishing a communication
session.[¶](#section-1-3){.pilcrow}

This document also defines how to discover support for Trickle ICE, how
the procedures in \[[RFC8445](#RFC8445){.xref}\] are modified or
supplemented when using Trickle ICE, and how a Trickle ICE agent can
interoperate with an ICE agent compliant to
\[[RFC8445](#RFC8445){.xref}\].[¶](#section-1-4){.pilcrow}

This document does not define any protocol-specific usage of Trickle
ICE. Instead, protocol-specific details for Trickle ICE are defined in
separate usage documents. Examples of such documents are
\[[RFC8840](#RFC8840){.xref}\] (which defines usage with the Session
Initiation Protocol (SIP) \[[RFC3261](#RFC3261){.xref}\] and the Session
Description Protocol (SDP) \[[RFC4566](#RFC4566){.xref}\]) and
\[[XEP-0176](#XEP-0176){.xref}\] (which defines usage with the
Extensible Messaging and Presence Protocol (XMPP)
\[[RFC6120](#RFC6120){.xref}\]). However, some of the examples in the
document use SDP and the Offer/Answer model
\[[RFC3264](#RFC3264){.xref}\] to explain the underlying
concepts.[¶](#section-1-5){.pilcrow}

The following diagram illustrates a successful Trickle ICE exchange with
a using protocol that follows the Offer/Answer
model:[¶](#section-1-6){.pilcrow}

[]{#name-flow}

::: {#fig-flow}
::: {#section-1-7.1 .artwork .art-text .alignLeft}
            Alice                                            Bob
              |                     Offer                     |
              |---------------------------------------------->|
              |            Additional Candidates              |
              |---------------------------------------------->|
              |                     Answer                    |
              |<----------------------------------------------|
              |            Additional Candidates              |
              |<----------------------------------------------|
              | Additional Candidates and Connectivity Checks |
              |<--------------------------------------------->|
              |<========== CONNECTION ESTABLISHED ===========>|
:::

[Figure 1](#figure-1){.selfRef}: [Flow](#name-flow){.selfRef}
:::

The main body of this document is structured to describe the behavior of
Trickle ICE agents in roughly the order of operations and interactions
during an ICE session:[¶](#section-1-8){.pilcrow}

1.  [Determining support for Trickle
    ICE[¶](#section-1-9.1){.pilcrow}]{#section-1-9.1}
2.  [Generating the initial ICE
    description[¶](#section-1-9.2){.pilcrow}]{#section-1-9.2}
3.  [Handling the initial ICE description and generating the initial ICE
    response[¶](#section-1-9.3){.pilcrow}]{#section-1-9.3}
4.  [Handling the initial ICE
    response[¶](#section-1-9.4){.pilcrow}]{#section-1-9.4}
5.  [Forming checklists, pruning candidates, performing connectivity
    checks, etc.[¶](#section-1-9.5){.pilcrow}]{#section-1-9.5}
6.  [Gathering and conveying candidates after the initial ICE
    description and
    response[¶](#section-1-9.6){.pilcrow}]{#section-1-9.6}
7.  [Handling inbound trickled
    candidates[¶](#section-1-9.7){.pilcrow}]{#section-1-9.7}
8.  [Generating and handling the end-of-candidates
    indication[¶](#section-1-9.8){.pilcrow}]{#section-1-9.8}
9.  [Handling ICE restarts[¶](#section-1-9.9){.pilcrow}]{#section-1-9.9}

There is quite a bit of operational experience with the technique behind
Trickle ICE, going back as far as 2005 (when the XMPP Jingle extension
defined a \"dribble mode\" as specified in
\[[XEP-0176](#XEP-0176){.xref}\]); this document incorporates feedback
from those who have implemented and deployed the technique over the
years.[¶](#section-1-10){.pilcrow}
:::

::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}

This specification makes use of all terminology defined for Interactive
Connectivity Establishment in \[[RFC8445](#RFC8445){.xref}\]. In
addition, it defines the following terms:[¶](#section-2-2){.pilcrow}

[]{.break}

Empty Checklist:
:   A checklist that initially does not contain any candidate pairs
    because they will be incrementally added as they are trickled. (This
    scenario does not arise with a regular ICE agent, because all
    candidate pairs are known when the agent creates the checklist
    set.)[¶](#section-2-3.2){.pilcrow}
:   

Full Trickle:
:   The typical mode of operation for Trickle ICE agents, in which the
    initial ICE description can include any number of candidates (even
    zero candidates) and does not need to include a full generation of
    candidates as in half trickle.[¶](#section-2-3.4){.pilcrow}
:   

Generation:
:   All of the candidates conveyed within an ICE session (correlated
    with a particular Username Fragment and Password
    combination).[¶](#section-2-3.6){.pilcrow}
:   

Half Trickle:
:   A Trickle ICE mode of operation in which the initiator gathers a
    full generation of candidates strictly before creating and conveying
    the initial ICE description. Once conveyed, this candidate
    information can be processed by regular ICE agents, which do not
    require support for Trickle ICE. It also allows Trickle-ICE-capable
    responders to still gather candidates and perform connectivity
    checks in a non-blocking way, thus providing roughly \"half\" the
    advantages of Trickle ICE. The half-trickle mechanism is mostly
    meant for use when the responder\'s support for Trickle ICE cannot
    be confirmed prior to conveying the initial ICE
    description.[¶](#section-2-3.8){.pilcrow}
:   

ICE Description:
:   Any attributes related to the ICE session (other than candidates)
    required to configure an ICE agent. These include but are not
    limited to the Username Fragment, the Password, and other
    attributes.[¶](#section-2-3.10){.pilcrow}
:   

Trickled Candidates:
:   Candidates that a Trickle ICE agent conveys after conveying or
    responding to the initial ICE description, but within the same ICE
    session. Trickled candidates can be conveyed in parallel with
    candidate gathering and connectivity
    checks.[¶](#section-2-3.12){.pilcrow}
:   

Trickling:
:   The act of incrementally conveying trickled
    candidates.[¶](#section-2-3.14){.pilcrow}
:   
:::

::: {#support}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Determining Support for Trickle ICE](#name-determining-support-for-tri){.section-name .selfRef} {#name-determining-support-for-tri}

To fully support Trickle ICE, using protocols [SHOULD]{.bcp14}
incorporate one of the following mechanisms so that implementations can
determine whether Trickle ICE is supported:[¶](#section-3-1){.pilcrow}

1.  [Provide a capabilities discovery method so that agents can verify
    support of Trickle ICE prior to initiating a session (XMPP\'s
    [Service Discovery](#XEP-0030){.xref}
    \[[XEP-0030](#XEP-0030){.xref}\] is one such
    mechanism).[¶](#section-3-2.1){.pilcrow}]{#section-3-2.1}
2.  [Make support for Trickle ICE mandatory so that user agents can
    assume support.[¶](#section-3-2.2){.pilcrow}]{#section-3-2.2}

If a using protocol does not provide a method of determining ahead of
time whether Trickle ICE is supported, agents can make use of the
half-trickle procedure described in [Section
16](#half-trickle){.xref}.[¶](#section-3-3){.pilcrow}

Prior to conveying the initial ICE description, agents that implement
using protocols that support capabilities discovery can attempt to
verify whether or not the remote party supports Trickle ICE. If an agent
determines that the remote party does not support Trickle ICE, it
[MUST]{.bcp14} fall back to using regular ICE or abandon the entire
session.[¶](#section-3-4){.pilcrow}

Even if a using protocol does not include a capabilities discovery
method, a user agent can provide an indication within the ICE
description that it supports Trickle ICE by communicating an ICE option
of \'trickle\'. This token [MUST]{.bcp14} be provided either at the
session level or, if at the data stream level, for every data stream (an
agent [MUST NOT]{.bcp14} specify Trickle ICE support for some data
streams but not others). Note: The encoding of the \'trickle\' ICE
option, and the message(s) used to carry it to the peer, are protocol
specific; for instance, the encoding for SDP
\[[RFC4566](#RFC4566){.xref}\] is defined in
\[[RFC8840](#RFC8840){.xref}\].[¶](#section-3-5){.pilcrow}

Dedicated discovery semantics and half trickle are needed only prior to
initiation of an ICE session. After an ICE session is established and
Trickle ICE support is confirmed for both parties, either agent can use
full trickle for subsequent exchanges (see also [Section
15](#subsequent){.xref}).[¶](#section-3-6){.pilcrow}
:::
:::

::: {#initial}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Generating the Initial ICE Description](#name-generating-the-initial-ice-){.section-name .selfRef} {#name-generating-the-initial-ice-}

An ICE agent can start gathering candidates as soon as it has an
indication that communication is imminent (e.g., a user-interface cue or
an explicit request to initiate a communication session). Unlike in
regular ICE, in Trickle ICE implementations do not need to gather
candidates in a blocking manner. Therefore, unless half trickle is being
used, the user experience is improved if the initiating agent generates
and transmits its initial ICE description as early as possible (thus
enabling the remote party to start gathering and trickling
candidates).[¶](#section-4-1){.pilcrow}

An initiator [MAY]{.bcp14} include any mix of candidates when conveying
the initial ICE description. This includes the possibility of conveying
all the candidates the initiator plans to use (as in half trickle),
conveying only a publicly reachable IP address (e.g., a candidate at a
data relay that is known to not be behind a firewall), or conveying no
candidates at all (in which case the initiator can obtain the
responder\'s initial candidate list sooner, and the responder can begin
candidate gathering more quickly).[¶](#section-4-2){.pilcrow}

For candidates included in the initial ICE description, the methods for
calculating priorities and foundations, determining redundancy of
candidates, and the like work just as in regular ICE
\[[RFC8445](#RFC8445){.xref}\].[¶](#section-4-3){.pilcrow}
:::
:::

::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Handling the Initial ICE Description and Generating the Initial ICE Response](#name-handling-the-initial-ice-de){.section-name .selfRef} {#name-handling-the-initial-ice-de}

When a responder receives the initial ICE description, it will first
check if the ICE description or initiator indicates support for Trickle
ICE as explained in [Section 3](#support){.xref}. If not, the responder
[MUST]{.bcp14} process the initial ICE description according to regular
ICE procedures \[[RFC8445](#RFC8445){.xref}\] (or, if no ICE support is
detected at all, according to relevant processing rules for the using
protocol, such as Offer/Answer processing rules
\[[RFC3264](#RFC3264){.xref}\]). However, if support for Trickle ICE is
confirmed, a responder will automatically assume support for regular ICE
as well.[¶](#section-5-1){.pilcrow}

If the initial ICE description indicates support for Trickle ICE, the
responder will determine its role and start gathering and prioritizing
candidates; while doing so, it will also respond by conveying an initial
ICE response, so that both the initiator and the responder can form
checklists and begin connectivity checks.[¶](#section-5-2){.pilcrow}

A responder can respond to the initial ICE description at any point
while gathering candidates. The initial ICE response [MAY]{.bcp14}
contain any set of candidates, including all candidates or no
candidates. (The benefit of including no candidates is to convey the
initial ICE response as quickly as possible, so that both parties can
consider the ICE session to be under active negotiation as soon as
possible.)[¶](#section-5-3){.pilcrow}

As noted in [Section 3](#support){.xref}, in using protocols that use
SDP, the initial ICE response can indicate support for Trickle ICE by
including a token of \'trickle\' in the ice-options
attribute.[¶](#section-5-4){.pilcrow}
:::

::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Handling the Initial ICE Response](#name-handling-the-initial-ice-re){.section-name .selfRef} {#name-handling-the-initial-ice-re}

When processing the initial ICE response, the initiator follows regular
ICE procedures to determine its role, after which it forms checklists
([Section 7](#checklists){.xref}) and performs connectivity checks
([Section 8](#checks){.xref}).[¶](#section-6-1){.pilcrow}
:::

::: {#checklists}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Forming Checklists](#name-forming-checklists){.section-name .selfRef} {#name-forming-checklists}

According to regular ICE procedures \[[RFC8445](#RFC8445){.xref}\], in
order for candidate pairing to be possible and for redundant candidates
to be pruned, the candidates would need to be provided in the initial
ICE description and initial ICE response. By contrast, under Trickle
ICE, checklists can be empty until candidates are conveyed or received.
Therefore, a Trickle ICE agent handles checklist formation and candidate
pairing in a slightly different way than a regular ICE agent: the agent
still forms the checklists, but it populates a given checklist only
after it actually has candidate pairs for that checklist. Every
checklist is initially placed in the Running state, even if the
checklist is empty (this is consistent with [Section
6.1.2.1](https://www.rfc-editor.org/rfc/rfc8445#section-6.1.2.1){.relref}
of \[[RFC8445](#RFC8445){.xref}\]).[¶](#section-7-1){.pilcrow}
:::
:::

::: {#checks}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Performing Connectivity Checks](#name-performing-connectivity-che){.section-name .selfRef} {#name-performing-connectivity-che}

As specified in \[[RFC8445](#RFC8445){.xref}\], whenever timer Ta fires,
only checklists in the Running state will be picked when scheduling
connectivity checks for candidate pairs. Therefore, a Trickle ICE agent
[MUST]{.bcp14} keep each checklist in the Running state as long as it
expects candidate pairs to be incrementally added to the checklist.
After that, the checklist state is set according to the procedures in
\[[RFC8445](#RFC8445){.xref}\].[¶](#section-8-1){.pilcrow}

Whenever timer Ta fires and an empty checklist is picked, no action is
performed for the list. Without waiting for timer Ta to expire again,
the agent selects the next checklist in the Running state, in accordance
with [Section
6.1.4.2](https://www.rfc-editor.org/rfc/rfc8445#section-6.1.4.2){.relref}
of \[[RFC8445](#RFC8445){.xref}\].[¶](#section-8-2){.pilcrow}

[Section
7.2.5.4](https://www.rfc-editor.org/rfc/rfc8445#section-7.2.5.4){.relref}
of \[[RFC8445](#RFC8445){.xref}\] requires that agents update checklists
and timer states upon completing a connectivity check transaction.
During such an update, regular ICE agents would set the state of a
checklist to Failed if both of the following two conditions are
satisfied:[¶](#section-8-3){.pilcrow}

-   [all of the pairs in the checklist are in either the Failed state or
    the Succeeded state;
    and[¶](#section-8-4.1){.pilcrow}]{#section-8-4.1}
-   [there is not a pair in the valid list for each component of the
    data stream.[¶](#section-8-4.2){.pilcrow}]{#section-8-4.2}

With Trickle ICE, the above situation would often occur when candidate
gathering and trickling are still in progress, even though it is quite
possible that future checks will succeed. For this reason, Trickle ICE
agents add the following conditions to the above
list:[¶](#section-8-5){.pilcrow}

-   [all candidate gathering has completed, and the agent is not
    expecting to discover any new local candidates;
    and[¶](#section-8-6.1){.pilcrow}]{#section-8-6.1}
-   [the remote agent has conveyed an end-of-candidates indication for
    that checklist as described in [Section
    13](#end-of-candidates.send){.xref}.[¶](#section-8-6.2){.pilcrow}]{#section-8-6.2}
:::
:::

::: {#trickle-send}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Gathering and Conveying Newly Gathered Local Candidates](#name-gathering-and-conveying-new){.section-name .selfRef} {#name-gathering-and-conveying-new}

After Trickle ICE agents have conveyed initial ICE descriptions and
initial ICE responses, they will most likely continue gathering new
local candidates as STUN, TURN, and other non-host candidate gathering
mechanisms begin to yield results. Whenever an agent discovers such a
new candidate, it will compute its priority, type, foundation, and
component ID according to regular ICE
procedures.[¶](#section-9-1){.pilcrow}

The new candidate is then checked for redundancy against the existing
list of local candidates. If its transport address and base match those
of an existing candidate, it will be considered redundant and will be
ignored. This would often happen for server-reflexive candidates that
match the host addresses they were obtained from (e.g., when the latter
are public IPv4 addresses). Contrary to regular ICE, Trickle ICE agents
will consider the new candidate redundant regardless of its
priority.[¶](#section-9-2){.pilcrow}

Next, the agent \"trickles\" the newly discovered candidate(s) to the
remote agent. The actual delivery of the new candidates is handled by a
using protocol such as SIP or XMPP. Trickle ICE imposes no restrictions
on the way this is done (e.g., some using protocols might choose not to
trickle updates for server-reflexive candidates and instead rely on the
discovery of peer-reflexive ones).[¶](#section-9-3){.pilcrow}

When candidates are trickled, the using protocol [MUST]{.bcp14} deliver
each candidate (and any end-of-candidates indication as described in
[Section 13](#end-of-candidates.send){.xref}) to the receiving Trickle
ICE implementation exactly once and in the same order it was conveyed.
If the using protocol provides any candidate retransmissions, they need
to be hidden from the ICE implementation.[¶](#section-9-4){.pilcrow}

Also, candidate trickling needs to be correlated to a specific ICE
session, so that if there is an ICE restart, any delayed updates for a
previous session can be recognized as such and ignored by the receiving
party. For example, using protocols that signal candidates via SDP might
include a Username Fragment value in the corresponding a=candidate line,
such as:[¶](#section-9-5){.pilcrow}

::: {#section-9-6}
``` {.sourcecode .lang-sdp}
  a=candidate:1 1 UDP 2130706431 2001:db8::1 5000 typ host ufrag 8hhY
```

[¶](#section-9-6){.pilcrow}
:::

Or, as another example, WebRTC implementations might include a Username
Fragment in the JavaScript objects that represent
candidates.[¶](#section-9-7){.pilcrow}

Note: The using protocol needs to provide a mechanism for both parties
to indicate and agree on the ICE session in force (as identified by the
Username Fragment and Password combination), so that they have a
consistent view of which candidates are to be paired. This is especially
important in the case of ICE restarts (see [Section
15](#subsequent){.xref}).[¶](#section-9-8){.pilcrow}

Note: A using protocol might prefer not to trickle server-reflexive
candidates to entities that are known to be publicly accessible and
where sending a direct STUN binding request is likely to reach the
destination faster than the trickle update that travels through the
signaling path.[¶](#section-9-9){.pilcrow}
:::
:::

::: {#local-pairing}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Pairing Newly Gathered Local Candidates](#name-pairing-newly-gathered-loca){.section-name .selfRef} {#name-pairing-newly-gathered-loca}

As a Trickle ICE agent gathers local candidates, it needs to form
candidate pairs; this works as described in the ICE specification
\[[RFC8445](#RFC8445){.xref}\], with the following
provisos:[¶](#section-10-1){.pilcrow}

1.  [A Trickle ICE agent [MUST NOT]{.bcp14} pair a local candidate until
    it has been trickled to the remote
    party.[¶](#section-10-2.1){.pilcrow}]{#section-10-2.1}
2.  [Once the agent has conveyed the local candidate to the remote
    party, the agent checks if any remote candidates are currently known
    for this same stream and component. If not, the agent merely adds
    the new candidate to the list of local candidates (without pairing
    it).[¶](#section-10-2.2){.pilcrow}]{#section-10-2.2}
3.  [Otherwise, if the agent has already learned of one or more remote
    candidates for this stream and component, it attempts to pair the
    new local candidate as described in the ICE specification
    \[[RFC8445](#RFC8445){.xref}\].[¶](#section-10-2.3){.pilcrow}]{#section-10-2.3}
4.  [If a newly formed pair has a local candidate whose type is
    server-reflexive, the agent [MUST]{.bcp14} replace the local
    candidate with its base before completing the relevant redundancy
    tests.[¶](#section-10-2.4){.pilcrow}]{#section-10-2.4}
5.  [The agent prunes redundant pairs by following the rules in [Section
    6.1.2.4](https://www.rfc-editor.org/rfc/rfc8445#section-6.1.2.4){.relref}
    of \[[RFC8445](#RFC8445){.xref}\] but checks existing pairs only if
    they have a state of Waiting or Frozen; this avoids removal of pairs
    for which connectivity checks are in flight (a state of In‑Progress)
    or for which connectivity checks have already yielded a definitive
    result (a state of Succeeded or
    Failed).[¶](#section-10-2.5){.pilcrow}]{#section-10-2.5}
6.  [If, after completing the relevant redundancy tests, the checklist
    where the pair is to be added already contains the maximum number of
    candidate pairs (100 by default as per
    \[[RFC8445](#RFC8445){.xref}\]), the agent [SHOULD]{.bcp14} discard
    any pairs in the Failed state to make room for the new pair. If
    there are no such pairs, the agent [SHOULD]{.bcp14} discard a pair
    with a lower priority than the new pair in order to make room for
    the new pair, until the number of pairs is equal to the maximum
    number of pairs. This processing is consistent with [Section
    6.1.2.5](https://www.rfc-editor.org/rfc/rfc8445#section-6.1.2.5){.relref}
    of
    \[[RFC8445](#RFC8445){.xref}\].[¶](#section-10-2.6){.pilcrow}]{#section-10-2.6}
:::
:::

::: {#trickle-recv}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [Receiving Trickled Candidates](#name-receiving-trickled-candidat){.section-name .selfRef} {#name-receiving-trickled-candidat}

At any time during an ICE session, a Trickle ICE agent might receive new
candidates from the remote agent, from which it will attempt to form a
candidate pair; this works as described in the ICE specification
\[[RFC8445](#RFC8445){.xref}\], with the following
provisos:[¶](#section-11-1){.pilcrow}

1.  [The agent checks if any local candidates are currently known for
    this same stream and component. If not, the agent merely adds the
    new candidate to the list of remote candidates (without pairing
    it).[¶](#section-11-2.1){.pilcrow}]{#section-11-2.1}

2.  [Otherwise, if the agent has already gathered one or more local
    candidates for this stream and component, it attempts to pair the
    new remote candidate as described in the ICE specification
    \[[RFC8445](#RFC8445){.xref}\].[¶](#section-11-2.2){.pilcrow}]{#section-11-2.2}

3.  [If a newly formed pair has a local candidate whose type is
    server-reflexive, the agent [MUST]{.bcp14} replace the local
    candidate with its base before completing the redundancy check in
    the next step.[¶](#section-11-2.3){.pilcrow}]{#section-11-2.3}

4.  ::: {#section-11-2.4}
    The agent prunes redundant pairs as described below but checks
    existing pairs only if they have a state of Waiting or Frozen; this
    avoids removal of pairs for which connectivity checks are in flight
    (a state of In-Progress) or for which connectivity checks have
    already yielded a definitive result (a state of Succeeded or
    Failed).[¶](#section-11-2.4.1){.pilcrow}

    A.  [If the agent finds a redundancy between two pairs and one of
        those pairs contains a newly received remote candidate whose
        type is peer-reflexive, the agent [SHOULD]{.bcp14} discard the
        pair containing that candidate, set the priority of the existing
        pair to the priority of the discarded pair, and re-sort the
        checklist. (This policy helps to eliminate problems with remote
        peer-reflexive candidates for which a STUN Binding request is
        received before signaling of the candidate is trickled to the
        receiving agent, such as a different view of pair priorities
        between the local agent and the remote agent, because the same
        candidate could be perceived as peer-reflexive by one agent and
        as server-reflexive by the other
        agent.)[¶](#section-11-2.4.2.1){.pilcrow}]{#section-11-2.4.2.1}
    B.  [The agent then applies the rules defined in [Section
        6.1.2.4](https://www.rfc-editor.org/rfc/rfc8445#section-6.1.2.4){.relref}
        of
        \[[RFC8445](#RFC8445){.xref}\].[¶](#section-11-2.4.2.2){.pilcrow}]{#section-11-2.4.2.2}
    :::

5.  [If, after completing the relevant redundancy tests, the checklist
    where the pair is to be added already contains the maximum number of
    candidate pairs (100 by default as per
    \[[RFC8445](#RFC8445){.xref}\]), the agent [SHOULD]{.bcp14} discard
    any pairs in the Failed state to make room for the new pair. If
    there are no such pairs, the agent [SHOULD]{.bcp14} discard a pair
    with a lower priority than the new pair in order to make room for
    the new pair, until the number of pairs is equal to the maximum
    number of pairs. This processing is consistent with [Section
    6.1.2.5](https://www.rfc-editor.org/rfc/rfc8445#section-6.1.2.5){.relref}
    of
    \[[RFC8445](#RFC8445){.xref}\].[¶](#section-11-2.5){.pilcrow}]{#section-11-2.5}
:::
:::

::: {#trickle-insert}
::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [Inserting Trickled Candidate Pairs into a Checklist](#name-inserting-trickled-candidat){.section-name .selfRef} {#name-inserting-trickled-candidat}

After a local agent has trickled a candidate and formed a candidate pair
from that local candidate ([Section 9](#trickle-send){.xref}), or after
a remote agent has received a trickled candidate and formed a candidate
pair from that remote candidate ([Section 11](#trickle-recv){.xref}), a
Trickle ICE agent adds the new candidate pair to a checklist as defined
in this section.[¶](#section-12-1){.pilcrow}

As an aid to understanding the procedures defined in this section,
consider the following tabular representation of all checklists in an
agent (note that initially for one of the foundations, i.e., f5, there
are no candidate pairs):[¶](#section-12-2){.pilcrow}

[]{#name-example-of-checklist-state}

::: {#checklist_table}
                    f1   f2   f3   f4   f5
  ----------------- ---- ---- ---- ---- ----
  s1 (Audio.RTP)    F    F    F         
  s2 (Audio.RTCP)   F    F    F    F    
  s3 (Video.RTP)    F                   
  s4 (Video.RTCP)   F                   

  : [Table 1](#table-1){.selfRef}: [Example of Checklist
  State](#name-example-of-checklist-state){.selfRef}
:::

Each row in the table represents a component for a given data stream
(e.g., s1 and s2 might be the RTP and RTP Control Protocol (RTCP)
components for audio) and thus a single checklist in the checklist set.
Each column represents one foundation. Each cell represents one
candidate pair. In the tables shown in this section, \"F\" stands for
\"frozen\", \"W\" stands for \"waiting\", and \"S\" stands for
\"succeeded\"; in addition, \"\^\^\" is used to notate newly added
candidate pairs.[¶](#section-12-4){.pilcrow}

When an agent commences ICE processing, in accordance with [Section
6.1.2.6](https://www.rfc-editor.org/rfc/rfc8445#section-6.1.2.6){.relref}
of \[[RFC8445](#RFC8445){.xref}\], for each foundation it will unfreeze
the pair with the lowest component ID and, if the component IDs are
equal, with the highest priority (this is the topmost candidate pair in
every column). This initial state is shown in the following
table.[¶](#section-12-5){.pilcrow}

[]{#name-initial-checklist-state}

::: {#fig-checklist-initial}
                    f1   f2   f3   f4   f5
  ----------------- ---- ---- ---- ---- ----
  s1 (Audio.RTP)    W    W    W         
  s2 (Audio.RTCP)   F    F    F    W    
  s3 (Video.RTP)    F                   
  s4 (Video.RTCP)   F                   

  : [Table 2](#table-2){.selfRef}: [Initial Checklist
  State](#name-initial-checklist-state){.selfRef}
:::

Then, as the checks proceed (see [Section
7.2.5.4](https://www.rfc-editor.org/rfc/rfc8445#section-7.2.5.4){.relref}
of \[[RFC8445](#RFC8445){.xref}\]), for each pair that enters the
Succeeded state (denoted here by \"S\"), the agent will unfreeze all
pairs for all data streams with the same foundation (e.g., if the pair
in column 1, row 1 succeeds then the agent will unfreeze the pairs in
column 1, rows 2, 3, and 4).[¶](#section-12-7){.pilcrow}

[]{#name-checklist-state-with-succee}

::: {#fig-checklist-succeeded}
                    f1   f2   f3   f4   f5
  ----------------- ---- ---- ---- ---- ----
  s1 (Audio.RTP)    S    W    W         
  s2 (Audio.RTCP)   W    F    F    W    
  s3 (Video.RTP)    W                   
  s4 (Video.RTCP)   W                   

  : [Table 3](#table-3){.selfRef}: [Checklist State with Succeeded
  Candidate Pair](#name-checklist-state-with-succee){.selfRef}
:::

Trickle ICE preserves all of these rules as they apply to \"static\"
checklist sets. This implies that if a Trickle ICE agent were to begin
connectivity checks with all of its pairs already present, the way that
pair states change is indistinguishable from that of a regular ICE
agent.[¶](#section-12-9){.pilcrow}

Of course, the major difference with Trickle ICE is that checklist sets
can be dynamically updated because candidates can arrive after
connectivity checks have started. When this happens, an agent sets the
state of the newly formed pair as described
below.[¶](#section-12-10){.pilcrow}

Rule 1: If the newly formed pair has the lowest component ID and, if the
component IDs are equal, the highest priority of any candidate pair for
this foundation (i.e., if it is the topmost pair in the column), set the
state to Waiting. For example, this would be the case if the newly
formed pair were placed in column 5, row 1. This rule is consistent with
[Section
6.1.2.6](https://www.rfc-editor.org/rfc/rfc8445#section-6.1.2.6){.relref}
of \[[RFC8445](#RFC8445){.xref}\].[¶](#section-12-11){.pilcrow}

[]{#name-checklist-state-with-newly-}

::: {#fig-checklist-rule1}
                    f1   f2   f3   f4   f5
  ----------------- ---- ---- ---- ---- -------
  s1 (Audio.RTP)    S    W    W         \^W\^
  s2 (Audio.RTCP)   W    F    F    W    
  s3 (Video.RTP)    W                   
  s4 (Video.RTCP)   W                   

  : [Table 4](#table-4){.selfRef}: [Checklist State with Newly Formed
  Pair, Rule 1](#name-checklist-state-with-newly-){.selfRef}
:::

Rule 2: If there is at least one pair in the Succeeded state for this
foundation, set the state to Waiting. For example, this would be the
case if the pair in column 5, row 1 succeeded and the newly formed pair
were placed in column 5, row 2. This rule is consistent with [Section
7.2.5.3.3](https://www.rfc-editor.org/rfc/rfc8445#section-7.2.5.3.3){.relref}
of \[[RFC8445](#RFC8445){.xref}\].[¶](#section-12-13){.pilcrow}

[]{#name-checklist-state-with-newly-f}

::: {#fig-checklist-rule2}
                    f1   f2   f3   f4   f5
  ----------------- ---- ---- ---- ---- -------
  s1 (Audio.RTP)    S    W    W         S
  s2 (Audio.RTCP)   W    F    F    W    \^W\^
  s3 (Video.RTP)    W                   
  s4 (Video.RTCP)   W                   

  : [Table 5](#table-5){.selfRef}: [Checklist State with Newly Formed
  Pair, Rule 2](#name-checklist-state-with-newly-f){.selfRef}
:::

Rule 3: In all other cases, set the state to Frozen. For example, this
would be the case if the newly formed pair were placed in column 3, row
3.[¶](#section-12-15){.pilcrow}

[]{#name-checklist-state-with-newly-fo}

::: {#fig-checklist-rule3}
                    f1   f2   f3      f4   f5
  ----------------- ---- ---- ------- ---- ----
  s1 (Audio.RTP)    S    W    W            S
  s2 (Audio.RTCP)   W    F    F       W    W
  s3 (Video.RTP)    W         \^F\^        
  s4 (Video.RTCP)   W                      

  : [Table 6](#table-6){.selfRef}: [Checklist State with Newly Formed
  Pair, Rule 3](#name-checklist-state-with-newly-fo){.selfRef}
:::
:::
:::

::: {#end-of-candidates.send}
::: {#section-13 .section}
## [13.](#section-13){.section-number .selfRef} [Generating an End-of-Candidates Indication](#name-generating-an-end-of-candid){.section-name .selfRef} {#name-generating-an-end-of-candid}

Once all candidate gathering is completed or expires for an ICE session
associated with a specific data stream, the agent will generate an
\"end-of-candidates\" indication for that session and convey it to the
remote agent via the signaling channel. Although the exact form of the
indication depends on the using protocol, the indication [MUST]{.bcp14}
specify the generation (Username Fragment and Password combination), so
that an agent can correlate the end-of-candidates indication with a
particular ICE session. The indication can be conveyed in the following
ways:[¶](#section-13-1){.pilcrow}

-   [As part of an initiation request (which would typically be the case
    with the initial ICE description for half
    trickle)[¶](#section-13-2.1){.pilcrow}]{#section-13-2.1}
-   [Along with the last candidate an agent can send for a
    stream[¶](#section-13-2.2){.pilcrow}]{#section-13-2.2}
-   [As a standalone notification (e.g., after STUN Binding requests or
    TURN Allocate requests to a server time out and the agent is no
    longer actively gathering
    candidates)[¶](#section-13-2.3){.pilcrow}]{#section-13-2.3}

Conveying an end-of-candidates indication in a timely manner is
important in order to avoid ambiguities and speed up the conclusion of
ICE processing. In particular:[¶](#section-13-3){.pilcrow}

-   [A controlled Trickle ICE agent [SHOULD]{.bcp14} convey an
    end-of-candidates indication after it has completed gathering for a
    data stream, unless ICE processing terminates before the agent has
    had a chance to complete
    gathering.[¶](#section-13-4.1){.pilcrow}]{#section-13-4.1}
-   [A controlling agent [MAY]{.bcp14} conclude ICE processing prior to
    conveying end-of-candidates indications for all streams. However, it
    is [RECOMMENDED]{.bcp14} for a controlling agent to convey
    end-of-candidates indications whenever possible for the sake of
    consistency and to keep middleboxes and controlled agents up-to-date
    on the state of ICE
    processing.[¶](#section-13-4.2){.pilcrow}]{#section-13-4.2}

When conveying an end-of-candidates indication during trickling (rather
than as a part of the initial ICE description or a response thereto), it
is the responsibility of the using protocol to define methods for
associating the indication with one or more specific data
streams.[¶](#section-13-5){.pilcrow}

An agent [MAY]{.bcp14} also choose to generate an end-of-candidates
indication before candidate gathering has actually completed, if the
agent determines that gathering has continued for more than an
acceptable period of time. However, an agent [MUST NOT]{.bcp14} convey
any more candidates after it has conveyed an end-of-candidates
indication.[¶](#section-13-6){.pilcrow}

When performing half trickle, an agent [SHOULD]{.bcp14} convey an
end-of-candidates indication together with its initial ICE description
unless it is planning to potentially trickle additional candidates
(e.g., in case the remote party turns out to support Trickle
ICE).[¶](#section-13-7){.pilcrow}

After an agent conveys the end-of-candidates indication, it will update
the state of the corresponding checklist as explained in [Section
8](#checks){.xref}. Past that point, an agent [MUST NOT]{.bcp14} trickle
any new candidates within this ICE session. Therefore, adding new
candidates to the negotiation is possible only through an ICE restart
(see [Section 15](#subsequent){.xref}).[¶](#section-13-8){.pilcrow}

This specification does not override regular ICE semantics for
concluding ICE processing. Therefore, even if end-of-candidates
indications are conveyed, an agent will still need to go through pair
nomination. Also, if pairs have been nominated for components and data
streams, ICE processing [MAY]{.bcp14} still conclude even if
end-of-candidates indications have not been received for all streams. In
all cases, an agent [MUST NOT]{.bcp14} trickle any new candidates within
an ICE session after nomination of a candidate pair as described in
[Section
8.1.1](https://www.rfc-editor.org/rfc/rfc8445#section-8.1.1){.relref} of
\[[RFC8445](#RFC8445){.xref}\].[¶](#section-13-9){.pilcrow}
:::
:::

::: {#end-of-candidates.recv}
::: {#section-14 .section}
## [14.](#section-14){.section-number .selfRef} [Receiving an End-of-Candidates Indication](#name-receiving-an-end-of-candida){.section-name .selfRef} {#name-receiving-an-end-of-candida}

Receiving an end-of-candidates indication enables an agent to update
checklist states and, in case valid pairs do not exist for every
component in every data stream, determine that ICE processing has
failed. It also enables an agent to speed up the conclusion of ICE
processing when a candidate pair has been validated but uses a
lower-preference transport such as TURN. In such situations, an
implementation [MAY]{.bcp14} choose to wait and see if higher-priority
candidates are received; in this case, the end-of-candidates indication
provides a notification that such candidates are not
forthcoming.[¶](#section-14-1){.pilcrow}

When an agent receives an end-of-candidates indication for a specific
data stream, it will update the state of the relevant checklist as per
[Section 8](#checks){.xref} (which might lead to some checklists being
marked as Failed). If the checklist is still in the Running state after
the update, the agent will note that an end-of-candidates indication has
been received and take it into account in future updates to the
checklist.[¶](#section-14-2){.pilcrow}

After an agent has received an end-of-candidates indication, it
[MUST]{.bcp14} ignore any newly received candidates for that data stream
or data session.[¶](#section-14-3){.pilcrow}
:::
:::

::: {#subsequent}
::: {#section-15 .section}
## [15.](#section-15){.section-number .selfRef} [Subsequent Exchanges and ICE Restarts](#name-subsequent-exchanges-and-ic){.section-name .selfRef} {#name-subsequent-exchanges-and-ic}

Before conveying an end-of-candidates indication, either agent
[MAY]{.bcp14} convey subsequent candidate information at any time
allowed by the using protocol. When this happens, agents will use
semantics from \[[RFC8445](#RFC8445){.xref}\] (e.g., checking of the
Username Fragment and Password combination) to determine whether or not
the new candidate information requires an ICE
restart.[¶](#section-15-1){.pilcrow}

If an ICE restart occurs, the agents can assume that Trickle ICE is
still supported if support was determined previously; thus, they can
engage in Trickle ICE behavior as they would in an initial exchange of
ICE descriptions where support was determined through a capabilities
discovery method.[¶](#section-15-2){.pilcrow}
:::
:::

::: {#half-trickle}
::: {#section-16 .section}
## [16.](#section-16){.section-number .selfRef} [Half Trickle](#name-half-trickle){.section-name .selfRef} {#name-half-trickle}

In half trickle, the initiator conveys the initial ICE description with
a usable but not necessarily full generation of candidates. This ensures
that the ICE description can be processed by a regular ICE responder and
is mostly meant for use in cases where support for Trickle ICE cannot be
confirmed prior to conveying the initial ICE description. The initial
ICE description indicates support for Trickle ICE, so that the responder
can respond with something less than a full generation of candidates and
then trickle the rest. The initial ICE description for half trickle can
contain an end-of-candidates indication, although this is not mandatory
because if trickle support is confirmed, then the initiator can choose
to trickle additional candidates before it conveys an end-of-candidates
indication.[¶](#section-16-1){.pilcrow}

The half-trickle mechanism can be used in cases where there is no way
for an agent to verify in advance whether a remote party supports
Trickle ICE. Because the initial ICE description contains a full
generation of candidates, it can thus be handled by a regular ICE agent,
while still allowing a Trickle ICE agent to use the optimization defined
in this specification. This prevents negotiation from failing in the
former case while still giving roughly half the Trickle ICE benefits in
the latter.[¶](#section-16-2){.pilcrow}

Use of half trickle is only necessary during an initial exchange of ICE
descriptions. After both parties have received an ICE description from
their peer, they can each reliably determine Trickle ICE support and use
it for all subsequent exchanges (see [Section
15](#subsequent){.xref}).[¶](#section-16-3){.pilcrow}

In some instances, using half trickle might bring more than just half
the improvement in terms of user experience. This can happen when an
agent starts gathering candidates upon user-interface cues that the user
will soon be initiating an interaction, such as activity on a keypad or
the phone going off hook. This would mean that some or all of the
candidate gathering could be completed before the agent actually needs
to convey the candidate information. Because the responder will be able
to trickle candidates, both agents will be able to start connectivity
checks and complete ICE processing earlier than with regular ICE and
potentially even as early as with full
trickle.[¶](#section-16-4){.pilcrow}

However, such anticipation is not always possible. For example, a
multipurpose user agent or a WebRTC web page where communication is a
non-central feature (e.g., calling a support line in case of a problem
with the main features) would not necessarily have a way of
distinguishing between call intentions and other user activity. In such
cases, using full trickle is most likely to result in an ideal user
experience. Even so, using half trickle would be an improvement over
regular ICE because it would result in a better experience for
responders.[¶](#section-16-5){.pilcrow}
:::
:::

::: {#section-17 .section}
## [17.](#section-17){.section-number .selfRef} [Preserving Candidate Order While Trickling](#name-preserving-candidate-order-){.section-name .selfRef} {#name-preserving-candidate-order-}

One important aspect of regular ICE is that connectivity checks for a
specific foundation and component are attempted simultaneously by both
agents, so that any firewalls or NATs fronting the agents would
whitelist both endpoints and allow all except for the first
(\"suicide\") packets to go through. This is also important to
unfreezing candidates at the right time. While not crucial, preserving
this behavior in Trickle ICE is likely to improve ICE
performance.[¶](#section-17-1){.pilcrow}

To achieve this, when trickling candidates, agents [SHOULD]{.bcp14}
respect the order of components as reflected by their component IDs;
that is, candidates for a given component [SHOULD NOT]{.bcp14} be
conveyed prior to candidates for a component with a lower ID number
within the same foundation. In addition, candidates [SHOULD]{.bcp14} be
paired, following the procedures in [Section
12](#trickle-insert){.xref}, in the same order they are
conveyed.[¶](#section-17-2){.pilcrow}

For example, the following SDP description contains two components (RTP
and RTCP) and two foundations (host and
server-reflexive):[¶](#section-17-3){.pilcrow}

::: {#section-17-4}
``` {.sourcecode .lang-sdp}
  v=0
  o=jdoe 2890844526 2890842807 IN IP4 10.0.1.1
  s=
  c=IN IP4 10.0.1.1
  t=0 0
  a=ice-pwd:asd88fgpdd777uzjYhagZg
  a=ice-ufrag:8hhY
  m=audio 5000 RTP/AVP 0
  a=rtpmap:0 PCMU/8000
  a=candidate:1 1 UDP 2130706431 10.0.1.1 5000 typ host
  a=candidate:1 2 UDP 2130706431 10.0.1.1 5001 typ host
  a=candidate:2 1 UDP 1694498815 192.0.2.3 5000 typ srflx
      raddr 10.0.1.1 rport 8998
  a=candidate:2 2 UDP 1694498815 192.0.2.3 5001 typ srflx
      raddr 10.0.1.1 rport 8998
```

[¶](#section-17-4){.pilcrow}
:::

For this candidate information, the RTCP host candidate would not be
conveyed prior to the RTP host candidate. Similarly, the RTP
server-reflexive candidate would be conveyed together with or prior to
the RTCP server-reflexive candidate.[¶](#section-17-5){.pilcrow}
:::

::: {#reqs}
::: {#section-18 .section}
## [18.](#section-18){.section-number .selfRef} [Requirements for Using Protocols](#name-requirements-for-using-prot){.section-name .selfRef} {#name-requirements-for-using-prot}

In order to fully enable the use of Trickle ICE, this specification
defines the following requirements for using
protocols.[¶](#section-18-1){.pilcrow}

-   [A using protocol [SHOULD]{.bcp14} provide a way for parties to
    advertise and discover support for Trickle ICE before an ICE session
    begins (see [Section
    3](#support){.xref}).[¶](#section-18-2.1){.pilcrow}]{#section-18-2.1}
-   [A using protocol [MUST]{.bcp14} provide methods for incrementally
    conveying (i.e., \"trickling\") additional candidates after
    conveying the initial ICE description (see [Section
    9](#trickle-send){.xref}).[¶](#section-18-2.2){.pilcrow}]{#section-18-2.2}
-   [A using protocol [MUST]{.bcp14} deliver each trickled candidate or
    end-of-candidates indication exactly once and in the same order it
    was conveyed (see [Section
    9](#trickle-send){.xref}).[¶](#section-18-2.3){.pilcrow}]{#section-18-2.3}
-   [A using protocol [MUST]{.bcp14} provide a mechanism for both
    parties to indicate and agree on the ICE session in force (see
    [Section
    9](#trickle-send){.xref}).[¶](#section-18-2.4){.pilcrow}]{#section-18-2.4}
-   [A using protocol [MUST]{.bcp14} provide a way for parties to
    communicate the end-of-candidates indication, which [MUST]{.bcp14}
    specify the particular ICE session to which the indication applies
    (see [Section
    13](#end-of-candidates.send){.xref}).[¶](#section-18-2.5){.pilcrow}]{#section-18-2.5}
:::
:::

::: {#section-19 .section}
## [19.](#section-19){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

IANA has registered the following ICE option in the \"ICE Options\"
subregistry of the \"Interactive Connectivity Establishment (ICE)
registry\", following the procedures defined in
\[[RFC6336](#RFC6336){.xref}\].[¶](#section-19-1){.pilcrow}

[]{.break}

ICE Option:
:   trickle[¶](#section-19-2.2){.pilcrow}
:   

Contact:
:   IESG \<iesg\@ietf.org>[¶](#section-19-2.4){.pilcrow}
:   

Change controller:
:   IESG[¶](#section-19-2.6){.pilcrow}
:   

Description:
:   An ICE option of \'trickle\' indicates support for incremental
    communication of ICE candidates.[¶](#section-19-2.8){.pilcrow}
:   

Reference:
:   RFC 8838[¶](#section-19-2.10){.pilcrow}
:   
:::

::: {#section-20 .section}
## [20.](#section-20){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

This specification inherits most of its semantics from
\[[RFC8445](#RFC8445){.xref}\], and as a result, all security
considerations described there apply to Trickle
ICE.[¶](#section-20-1){.pilcrow}

If the privacy implications of revealing host addresses on an endpoint
device are a concern (see, for example, the discussion in
\[[RFC8828](#RFC8828){.xref}\] and in [Section
19](https://www.rfc-editor.org/rfc/rfc8445#section-19){.relref} of
\[[RFC8445](#RFC8445){.xref}\]), agents can generate ICE descriptions
that contain no candidates and then only trickle candidates that do not
reveal host addresses (e.g., relayed
candidates).[¶](#section-20-2){.pilcrow}
:::

::: {#section-21 .section}
## [21.](#section-21){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-21.1 .section}
### [21.1.](#section-21.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8445\]
:   [Keranen, A.]{.refAuthor}[, Holmberg, C.]{.refAuthor}[, and J.
    Rosenberg]{.refAuthor}, [\"Interactive Connectivity Establishment
    (ICE): A Protocol for Network Address Translator (NAT)
    Traversal\"]{.refTitle}, [RFC 8445]{.seriesInfo}, [DOI
    10.17487/RFC8445]{.seriesInfo}, July 2018,
    \<<https://www.rfc-editor.org/info/rfc8445>\>.
:   
:::

::: {#section-21.2 .section}
### [21.2.](#section-21.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[RFC1918\]
:   [Rekhter, Y.]{.refAuthor}[, Moskowitz, B.]{.refAuthor}[,
    Karrenberg, D.]{.refAuthor}[, de Groot, G. J.]{.refAuthor}[, and E.
    Lear]{.refAuthor}, [\"Address Allocation for Private
    Internets\"]{.refTitle}, [BCP 5]{.seriesInfo}, [RFC
    1918]{.seriesInfo}, [DOI 10.17487/RFC1918]{.seriesInfo}, February
    1996, \<<https://www.rfc-editor.org/info/rfc1918>\>.
:   

\[RFC3261\]
:   [Rosenberg, J.]{.refAuthor}[, Schulzrinne, H.]{.refAuthor}[,
    Camarillo, G.]{.refAuthor}[, Johnston, A.]{.refAuthor}[,
    Peterson, J.]{.refAuthor}[, Sparks, R.]{.refAuthor}[,
    Handley, M.]{.refAuthor}[, and E. Schooler]{.refAuthor}, [\"SIP:
    Session Initiation Protocol\"]{.refTitle}, [RFC 3261]{.seriesInfo},
    [DOI 10.17487/RFC3261]{.seriesInfo}, June 2002,
    \<<https://www.rfc-editor.org/info/rfc3261>\>.
:   

\[RFC3264\]
:   [Rosenberg, J.]{.refAuthor}[ and H. Schulzrinne]{.refAuthor}, [\"An
    Offer/Answer Model with Session Description Protocol
    (SDP)\"]{.refTitle}, [RFC 3264]{.seriesInfo}, [DOI
    10.17487/RFC3264]{.seriesInfo}, June 2002,
    \<<https://www.rfc-editor.org/info/rfc3264>\>.
:   

\[RFC4566\]
:   [Handley, M.]{.refAuthor}[, Jacobson, V.]{.refAuthor}[, and C.
    Perkins]{.refAuthor}, [\"SDP: Session Description
    Protocol\"]{.refTitle}, [RFC 4566]{.seriesInfo}, [DOI
    10.17487/RFC4566]{.seriesInfo}, July 2006,
    \<<https://www.rfc-editor.org/info/rfc4566>\>.
:   

\[RFC4787\]
:   [Audet, F., Ed.]{.refAuthor}[ and C. Jennings]{.refAuthor},
    [\"Network Address Translation (NAT) Behavioral Requirements for
    Unicast UDP\"]{.refTitle}, [BCP 127]{.seriesInfo}, [RFC
    4787]{.seriesInfo}, [DOI 10.17487/RFC4787]{.seriesInfo}, January
    2007, \<<https://www.rfc-editor.org/info/rfc4787>\>.
:   

\[RFC5389\]
:   [Rosenberg, J.]{.refAuthor}[, Mahy, R.]{.refAuthor}[,
    Matthews, P.]{.refAuthor}[, and D. Wing]{.refAuthor}, [\"Session
    Traversal Utilities for NAT (STUN)\"]{.refTitle}, [RFC
    5389]{.seriesInfo}, [DOI 10.17487/RFC5389]{.seriesInfo}, October
    2008, \<<https://www.rfc-editor.org/info/rfc5389>\>.
:   

\[RFC5766\]
:   [Mahy, R.]{.refAuthor}[, Matthews, P.]{.refAuthor}[, and J.
    Rosenberg]{.refAuthor}, [\"Traversal Using Relays around NAT (TURN):
    Relay Extensions to Session Traversal Utilities for NAT
    (STUN)\"]{.refTitle}, [RFC 5766]{.seriesInfo}, [DOI
    10.17487/RFC5766]{.seriesInfo}, April 2010,
    \<<https://www.rfc-editor.org/info/rfc5766>\>.
:   

\[RFC6120\]
:   [Saint-Andre, P.]{.refAuthor}, [\"Extensible Messaging and Presence
    Protocol (XMPP): Core\"]{.refTitle}, [RFC 6120]{.seriesInfo}, [DOI
    10.17487/RFC6120]{.seriesInfo}, March 2011,
    \<<https://www.rfc-editor.org/info/rfc6120>\>.
:   

\[RFC6336\]
:   [Westerlund, M.]{.refAuthor}[ and C. Perkins]{.refAuthor}, [\"IANA
    Registry for Interactive Connectivity Establishment (ICE)
    Options\"]{.refTitle}, [RFC 6336]{.seriesInfo}, [DOI
    10.17487/RFC6336]{.seriesInfo}, July 2011,
    \<<https://www.rfc-editor.org/info/rfc6336>\>.
:   

\[RFC8828\]
:   [Uberti, J.]{.refAuthor}[ and G. Shieh]{.refAuthor}, [\"WebRTC IP
    Address Handling Requirements\"]{.refTitle}, [RFC
    8828]{.seriesInfo}, [DOI 10.17487/RFC8828]{.seriesInfo}, January
    2021, \<<https://www.rfc-editor.org/info/rfc8828>\>.
:   

\[RFC8840\]
:   [Ivov, E.]{.refAuthor}[, Stach, T.]{.refAuthor}[,
    Marocco, E.]{.refAuthor}[, and C. Holmberg]{.refAuthor}, [\"A
    Session Initiation Protocol (SIP) Usage for Incremental Provisioning
    of Candidates for the Interactive Connectivity Establishment
    (Trickle ICE)\"]{.refTitle}, [RFC 8840]{.seriesInfo}, [DOI
    10.17487/RFC8840]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8840>\>.
:   

\[XEP-0030\]
:   [Hildebrand, J.]{.refAuthor}[, Millard, P.]{.refAuthor}[,
    Eatmon, R.]{.refAuthor}[, and P. Saint-Andre]{.refAuthor},
    [\"XEP-0030: Service Discovery\"]{.refTitle}, [XMPP Standards
    Foundation, XEP-0030]{.seriesInfo}, June 2008.
:   

\[XEP-0176\]
:   [Beda, J.]{.refAuthor}[, Ludwig, S.]{.refAuthor}[,
    Saint-Andre, P.]{.refAuthor}[, Hildebrand, J.]{.refAuthor}[,
    Egan, S.]{.refAuthor}[, and R. McQueen]{.refAuthor}, [\"XEP-0176:
    Jingle ICE-UDP Transport Method\"]{.refTitle}, [XMPP Standards
    Foundation, XEP-0176]{.seriesInfo}, June 2009.
:   
:::
:::

::: {#interaction}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Interaction with Regular ICE](#name-interaction-with-regular-ic){.section-name .selfRef} {#name-interaction-with-regular-ic}

The ICE protocol was designed to be flexible enough to work in and adapt
to as many network environments as possible. Despite that flexibility,
ICE as specified in \[[RFC8445](#RFC8445){.xref}\] does not by itself
support Trickle ICE. This section describes how trickling of candidates
interacts with ICE.[¶](#section-appendix.a-1){.pilcrow}

\[[RFC8445](#RFC8445){.xref}\] describes the conditions required to
update checklists and timer states while an ICE agent is in the Running
state. These conditions are verified upon transaction completion, and
one of them stipulates that:[¶](#section-appendix.a-2){.pilcrow}

> if there is not a valid pair in the valid list for each component of
> the data stream associated with the checklist, the state of the
> checklist is set to Failed.[¶](#section-appendix.a-3.1){.pilcrow}

This could be a problem and cause ICE processing to fail prematurely in
a number of scenarios. Consider the following
case:[¶](#section-appendix.a-4){.pilcrow}

1.  [Alice and Bob are both located in different networks with Network
    Address Translation (NAT). Alice and Bob themselves have different
    addresses, but both networks use the same private internet block
    (e.g., the \"20-bit block\" 172.16/12 specified in
    \[[RFC1918](#RFC1918){.xref}\]).[¶](#section-appendix.a-5.1){.pilcrow}]{#section-appendix.a-5.1}
2.  [Alice conveys to Bob the candidate 172.16.0.1, which also happens
    to correspond to an existing host on Bob\'s
    network.[¶](#section-appendix.a-5.2){.pilcrow}]{#section-appendix.a-5.2}
3.  [Bob creates a candidate pair from his host candidate and
    172.16.0.1, puts this one pair into a checklist, and starts
    checks.[¶](#section-appendix.a-5.3){.pilcrow}]{#section-appendix.a-5.3}
4.  [These checks reach the host at 172.16.0.1 in Bob\'s network, which
    responds with an ICMP \"port unreachable\" error; per
    \[[RFC8445](#RFC8445){.xref}\], Bob marks the transaction as
    Failed.[¶](#section-appendix.a-5.4){.pilcrow}]{#section-appendix.a-5.4}

At this point, the checklist only contains a Failed pair, and the valid
list is empty. This causes the data stream and potentially all ICE
processing to fail, even though Trickle ICE agents can subsequently
convey candidates that could
succeed.[¶](#section-appendix.a-6){.pilcrow}

A similar race condition would occur if the initial ICE description from
Alice contains only candidates that can be determined as unreachable
from any of the candidates that Bob has gathered (e.g., this would be
the case if Bob\'s candidates only contain IPv4 addresses and the first
candidate that he receives from Alice is an IPv6
one).[¶](#section-appendix.a-7){.pilcrow}

Another potential problem could arise when a non-Trickle ICE
implementation initiates an interaction with a Trickle ICE
implementation. Consider the following
case:[¶](#section-appendix.a-8){.pilcrow}

1.  [Alice\'s client has a non-Trickle ICE
    implementation.[¶](#section-appendix.a-9.1){.pilcrow}]{#section-appendix.a-9.1}
2.  [Bob\'s client has support for Trickle
    ICE.[¶](#section-appendix.a-9.2){.pilcrow}]{#section-appendix.a-9.2}
3.  [Alice and Bob are behind NATs with address-dependent filtering
    \[[RFC4787](#RFC4787){.xref}\].[¶](#section-appendix.a-9.3){.pilcrow}]{#section-appendix.a-9.3}
4.  [Bob has two STUN servers, but one of them is currently
    unreachable.[¶](#section-appendix.a-9.4){.pilcrow}]{#section-appendix.a-9.4}

After Bob\'s agent receives Alice\'s initial ICE description, it would
immediately start connectivity checks. It would also start gathering
candidates, which would take a long time because of the unreachable STUN
server. By the time Bob\'s answer is ready and conveyed to Alice, Bob\'s
connectivity checks might have failed: until Alice gets Bob\'s answer,
she won\'t be able to start connectivity checks and punch holes in her
NAT. The NAT would hence be filtering Bob\'s checks as originating from
an unknown endpoint.[¶](#section-appendix.a-10){.pilcrow}
:::
:::

::: {#section-appendix.b .section}
## [Appendix B.](#section-appendix.b){.section-number .selfRef} [Interaction with ICE-Lite](#name-interaction-with-ice-lite){.section-name .selfRef} {#name-interaction-with-ice-lite}

The behavior of ICE-lite agents that are capable of Trickle ICE does not
require any particular rules other than those already defined in this
specification and \[[RFC8445](#RFC8445){.xref}\]. This section is hence
provided only for informational
purposes.[¶](#section-appendix.b-1){.pilcrow}

An ICE-lite agent would generate candidate information as per
\[[RFC8445](#RFC8445){.xref}\] and would indicate support for Trickle
ICE. Given that the candidate information will contain a full generation
of candidates, it would also be accompanied by an end-of-candidates
indication.[¶](#section-appendix.b-2){.pilcrow}

When performing full trickle, a full ICE implementation could convey the
initial ICE description or response thereto with no candidates. After
receiving a response that identifies the remote agent as an ICE-lite
implementation, the initiator can choose to not trickle any additional
candidates. The same is also true in the case when the ICE-lite agent
initiates the interaction and the full ICE agent is the responder. In
these cases, the connectivity checks would be enough for the ICE-lite
implementation to discover all potentially useful candidates as
peer-reflexive. The following example illustrates one such ICE session
using SDP syntax:[¶](#section-appendix.b-3){.pilcrow}

[]{#name-example}

::: {#fig-ice-lite}
::: {#section-appendix.b-4.1 .artwork .art-text .alignLeft}
            ICE-Lite                                          Bob
             Agent
               |   Offer (a=ice-lite a=ice-options:trickle)    |
               |---------------------------------------------->|
               |                                               |no cand
               |         Answer (a=ice-options:trickle)        |trickling
               |<----------------------------------------------|
               |              Connectivity Checks              |
               |<--------------------------------------------->|
      peer rflx|                                               |
     cand disco|                                               |
               |<========== CONNECTION ESTABLISHED ===========>|
:::

[Figure 2](#figure-2){.selfRef}: [Example](#name-example){.selfRef}
:::

In addition to reducing signaling traffic, this approach also removes
the need to discover STUN Bindings or make TURN allocations, which can
considerably lighten ICE processing.[¶](#section-appendix.b-5){.pilcrow}
:::

::: {#section-appendix.c .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

The authors would like to thank [Bernard Aboba]{.contact-name},
[Flemming Andreasen]{.contact-name}, [Rajmohan Banavi]{.contact-name},
[Taylor Brandstetter]{.contact-name}, [Philipp Hancke]{.contact-name},
[Christer Holmberg]{.contact-name}, [Ari Keränen]{.contact-name}, [Paul
Kyzivat]{.contact-name}, [Jonathan Lennox]{.contact-name}, [Enrico
Marocco]{.contact-name}, [Pal Martinsen]{.contact-name}, [Nils
Ohlmeier]{.contact-name}, [Thomas Stach]{.contact-name}, [Peter
Thatcher]{.contact-name}, [Martin Thomson]{.contact-name}, [Brandon
Williams]{.contact-name}, and [Dale Worley]{.contact-name} for their
reviews and suggestions on improving this document. [Sarah
Banks]{.contact-name}, [Roni Even]{.contact-name}, and [David
Mandelberg]{.contact-name} completed OPSDIR, GenART, and security
reviews, respectively. Thanks also to [Ari Keränen]{.contact-name} and
[Peter Thatcher]{.contact-name} in their role as chairs and [Ben
Campbell]{.contact-name} in his role as responsible Area
Director.[¶](#section-appendix.c-1){.pilcrow}
:::

::: {#authors-addresses}
::: {#section-appendix.d .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Emil Ivov]{.fn .nameRole}
:::

::: {.left dir="auto"}
[8x8, Inc. / Jitsi]{.org}
:::

::: {.left dir="auto"}
[675 Creekside Way]{.street-address}
:::

::: {.left dir="auto"}
[Campbell]{.locality}, [CA]{.region} [95008]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: tel
Phone: [+1 512 420 6968](tel:+1%20512%20420%206968){.tel}
:::

::: email
Email: <emcho@jitsi.org>
:::

::: {.left dir="auto"}
[Justin Uberti]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Google]{.org}
:::

::: {.left dir="auto"}
[747 6th Street S]{.street-address}
:::

::: {.left dir="auto"}
[Kirkland]{.locality}, [WA]{.region} [98033]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: tel
Phone: [+1 857 288 8888](tel:+1%20857%20288%208888){.tel}
:::

::: email
Email: <justin@uberti.name>
:::

::: {.left dir="auto"}
[Peter Saint-Andre]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Mozilla]{.org}
:::

::: {.left dir="auto"}
[P.O. Box 787]{.street-address}
:::

::: {.left dir="auto"}
[Parker]{.locality}, [CO]{.region} [80134]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: tel
Phone: [+1 720 256 6756](tel:+1%20720%20256%206756){.tel}
:::

::: email
Email: <stpeter@mozilla.com>
:::

::: url
URI: <https://www.mozilla.com/>
:::
:::
:::
