  RFC 8672            Pinning with Tickets   October 2019
  ------------------- ---------------------- --------------
  Sheffer & Migault   Experimental           \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Independent Submission

RFC:
:   [8672](https://www.rfc-editor.org/rfc/rfc8672){.eref}

Category:
:   Experimental

Published:
:   October 2019

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    Y. Sheffer
    :::

    ::: org
    Intuit
    :::
    :::

    ::: author
    ::: author-name
    D. Migault
    :::

    ::: org
    Ericsson
    :::
    :::
:::

# RFC 8672 {#rfcnum}

# TLS Server Identity Pinning with Tickets {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

Misissued public-key certificates can prevent TLS clients from
appropriately authenticating the TLS server. Several alternatives have
been proposed to detect this situation and prevent a client from
establishing a TLS session with a TLS end point authenticated with an
illegitimate public-key certificate. These mechanisms are either not
widely deployed or limited to public web
browsing.[¶](#section-abstract-1){.pilcrow}

This document proposes experimental extensions to TLS with opaque
pinning tickets as a way to pin the server\'s identity. During an
initial TLS session, the server provides an original encrypted pinning
ticket. In subsequent TLS session establishment, upon receipt of the
pinning ticket, the server proves its ability to decrypt the pinning
ticket and thus the ownership of the pinning protection key. The client
can now safely conclude that the TLS session is established with the
same TLS server as the original TLS session. One of the important
properties of this proposal is that no manual management actions are
required.[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for examination, experimental implementation, and
evaluation.[¶](#section-boilerplate.1-1){.pilcrow}

This document defines an Experimental Protocol for the Internet
community. This is a contribution to the RFC Series, independently of
any other RFC stream. The RFC Editor has chosen to publish this document
at its discretion and makes no statement about its value for
implementation or deployment. Documents approved for publication by the
RFC Editor are not candidates for any level of Internet Standard; see
Section 2 of RFC 7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8672>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2019 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(https://trustee.ietf.org/license-info) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-boilerplate.3 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-boilerplate.3-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-boilerplate.3-1.1.1){.pilcrow}

    -   ::: {#section-boilerplate.3-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Conventions Used in This
        Document](#name-conventions-used-in-this-do){.xref}[¶](#section-boilerplate.3-1.1.2.1.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.1.2.2}
        [1.2](#section-1.2){.xref}.  [Scope of
        Experimentation](#name-scope-of-experimentation){.xref}[¶](#section-boilerplate.3-1.1.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-boilerplate.3-1.2}
    [2](#section-2){.xref}.  [Protocol
    Overview](#name-protocol-overview){.xref}[¶](#section-boilerplate.3-1.2.1){.pilcrow}

    -   ::: {#section-boilerplate.3-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Initial
        Connection](#name-initial-connection){.xref}[¶](#section-boilerplate.3-1.2.2.1.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [Subsequent
        Connections](#name-subsequent-connections){.xref}[¶](#section-boilerplate.3-1.2.2.2.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.2.2.3}
        [2.3](#section-2.3){.xref}.  [Indexing the
        Pins](#name-indexing-the-pins){.xref}[¶](#section-boilerplate.3-1.2.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-boilerplate.3-1.3}
    [3](#section-3){.xref}.  [Message
    Definitions](#name-message-definitions){.xref}[¶](#section-boilerplate.3-1.3.1){.pilcrow}
    :::

-   ::: {#section-boilerplate.3-1.4}
    [4](#section-4){.xref}.  [Cryptographic
    Operations](#name-cryptographic-operations){.xref}[¶](#section-boilerplate.3-1.4.1){.pilcrow}

    -   ::: {#section-boilerplate.3-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Pinning
        Secret](#name-pinning-secret){.xref}[¶](#section-boilerplate.3-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Pinning
        Ticket](#name-pinning-ticket){.xref}[¶](#section-boilerplate.3-1.4.2.2.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Pinning Protection
        Key](#name-pinning-protection-key){.xref}[¶](#section-boilerplate.3-1.4.2.3.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Pinning
        Proof](#name-pinning-proof){.xref}[¶](#section-boilerplate.3-1.4.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-boilerplate.3-1.5}
    [5](#section-5){.xref}.  [Operational
    Considerations](#name-operational-considerations){.xref}[¶](#section-boilerplate.3-1.5.1){.pilcrow}

    -   ::: {#section-boilerplate.3-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Protection Key
        Synchronization](#name-protection-key-synchronizat){.xref}[¶](#section-boilerplate.3-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Ticket
        Lifetime](#name-ticket-lifetime){.xref}[¶](#section-boilerplate.3-1.5.2.2.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Certificate
        Renewal](#name-certificate-renewal){.xref}[¶](#section-boilerplate.3-1.5.2.3.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [Certificate
        Revocation](#name-certificate-revocation){.xref}[¶](#section-boilerplate.3-1.5.2.4.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [Disabling
        Pinning](#name-disabling-pinning){.xref}[¶](#section-boilerplate.3-1.5.2.5.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.5.2.6}
        [5.6](#section-5.6){.xref}.  [Server
        Compromise](#name-server-compromise){.xref}[¶](#section-boilerplate.3-1.5.2.6.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.5.2.7}
        [5.7](#section-5.7){.xref}.  [Disaster
        Recovery](#name-disaster-recovery){.xref}[¶](#section-boilerplate.3-1.5.2.7.1){.pilcrow}
        :::
    :::

-   ::: {#section-boilerplate.3-1.6}
    [6](#section-6){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-boilerplate.3-1.6.1){.pilcrow}

    -   ::: {#section-boilerplate.3-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Trust-on-First-Use (TOFU) and MITM
        Attacks](#name-trust-on-first-use-tofu-and){.xref}[¶](#section-boilerplate.3-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Pervasive
        Monitoring](#name-pervasive-monitoring){.xref}[¶](#section-boilerplate.3-1.6.2.2.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Server-Side Error
        Detection](#name-server-side-error-detection){.xref}[¶](#section-boilerplate.3-1.6.2.3.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [Client Policy and SSL
        Proxies](#name-client-policy-and-ssl-proxi){.xref}[¶](#section-boilerplate.3-1.6.2.4.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.6.2.5}
        [6.5](#section-6.5){.xref}.  [Client-Side Error
        Behavior](#name-client-side-error-behavior){.xref}[¶](#section-boilerplate.3-1.6.2.5.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.6.2.6}
        [6.6](#section-6.6){.xref}.  [Stolen and Forged
        Tickets](#name-stolen-and-forged-tickets){.xref}[¶](#section-boilerplate.3-1.6.2.6.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.6.2.7}
        [6.7](#section-6.7){.xref}.  [Client
        Privacy](#name-client-privacy){.xref}[¶](#section-boilerplate.3-1.6.2.7.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.6.2.8}
        [6.8](#section-6.8){.xref}.  [Ticket Protection Key
        Management](#name-ticket-protection-key-manag){.xref}[¶](#section-boilerplate.3-1.6.2.8.1){.pilcrow}
        :::
    :::

-   ::: {#section-boilerplate.3-1.7}
    [7](#section-7){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-boilerplate.3-1.7.1){.pilcrow}
    :::

-   ::: {#section-boilerplate.3-1.8}
    [8](#section-8){.xref}.  [References](#name-references){.xref}[¶](#section-boilerplate.3-1.8.1){.pilcrow}

    -   ::: {#section-boilerplate.3-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-boilerplate.3-1.8.2.1.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-boilerplate.3-1.8.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-boilerplate.3-1.9}
    [Appendix A](#section-appendix.a){.xref}.  [Previous
    Work](#name-previous-work){.xref}[¶](#section-boilerplate.3-1.9.1){.pilcrow}

    -   ::: {#section-boilerplate.3-1.9.2.1}
        [A.1](#section-a.1){.xref}.  [Comparison:
        HPKP](#name-comparison-hpkp){.xref}[¶](#section-boilerplate.3-1.9.2.1.1){.pilcrow}
        :::

    -   ::: {#section-boilerplate.3-1.9.2.2}
        [A.2](#section-a.2){.xref}.  [Comparison:
        TACK](#name-comparison-tack){.xref}[¶](#section-boilerplate.3-1.9.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-boilerplate.3-1.10}
    [](#section-appendix.b){.xref}[Acknowledgments](#name-acknowledgments){.xref}[¶](#section-boilerplate.3-1.10.1){.pilcrow}
    :::

-   ::: {#section-boilerplate.3-1.11}
    [](#section-appendix.c){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-boilerplate.3-1.11.1){.pilcrow}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Misissued public-key certificates can prevent TLS
\[[RFC8446](#RFC8446){.xref}\] clients from appropriately authenticating
the TLS server. This is a significant risk in the context of the global
public key infrastructure (PKI), and similarly for large-scale
deployments of certificates within
enterprises.[¶](#section-1-1){.pilcrow}

This document proposes experimental extensions to TLS with opaque
pinning tickets as a way to pin the server\'s identity. The approach is
intended to be easy to implement and deploy, and reuses some of the
ideas behind TLS session resumption
\[[RFC5077](#RFC5077){.xref}\].[¶](#section-1-2){.pilcrow}

Ticket pinning is a second-factor server authentication method and is
not proposed as a substitute for the authentication method provided in
the TLS key exchange. More specifically, the client only uses the
pinning identity method after the TLS key exchange is successfully
completed. In other words, the pinning identity method is only performed
over an authenticated TLS session. Note that ticket pinning does not pin
certificate information and therefore is truly an independent
second-factor authentication.[¶](#section-1-3){.pilcrow}

Ticket pinning is a trust-on-first-use (TOFU) mechanism, in that the
first server authentication is only based on PKI certificate validation,
but for any follow-on sessions, the client is further ensuring the
server\'s identity based on the server\'s ability to decrypt the ticket,
in addition to normal PKI certificate
authentication.[¶](#section-1-4){.pilcrow}

During initial TLS session establishment, the client requests a pinning
ticket from the server. Upon receiving the request the server generates
a pinning secret that is expected to be unpredictable for peers other
than the client or the server. In our case, the pinning secret is
generated from parameters exchanged during the TLS key exchange, so
client and server can generate it locally and independently. The server
constructs the pinning ticket with the necessary information to retrieve
the pinning secret. The server then encrypts the ticket and returns the
pinning ticket to the client with an associated pinning
lifetime.[¶](#section-1-5){.pilcrow}

The pinning lifetime value indicates for how long the server promises to
retain the server-side ticket-encryption key, which allows it to
complete the protocol exchange correctly and prove its identity. The
server commitment (and ticket lifetime) is typically on the order of
weeks.[¶](#section-1-6){.pilcrow}

Once the key exchange is completed, and the server is deemed
authenticated, the client generates locally the pinning secret and
caches the server\'s identifiers to index the pinning secret as well as
the pinning ticket and its associated
lifetime.[¶](#section-1-7){.pilcrow}

When the client reestablishes a new TLS session with the server, it
sends the pinning ticket to the server. Upon receiving it, the server
returns a proof of knowledge of the pinning secret. Once the key
exchange is completed, and the server has been authenticated, the client
checks the pinning proof returned by the server using the client\'s
stored pinning secret. If the proof matches, the client can conclude
that the server to which it is currently connecting is, in fact, the
correct server.[¶](#section-1-8){.pilcrow}

This document only applies to TLS 1.3. We believe that the idea can also
be retrofitted into earlier versions of the protocol, but this would
require significant changes. One example is that TLS 1.2
\[[RFC5246](#RFC5246){.xref}\] and earlier versions do not provide a
generic facility of encrypted handshake extensions, such as is used here
to transport the ticket.[¶](#section-1-9){.pilcrow}

The main advantages of this protocol over earlier pinning solutions are
the following:[¶](#section-1-10){.pilcrow}

-   [The protocol is at the TLS level, and as a result is not restricted
    to HTTP at the application
    level.[¶](#section-1-11.1){.pilcrow}]{#section-1-11.1}
-   [The protocol is robust to changes in server IP address,
    certification authority (CA), and public key. The server is
    characterized by the ownership of the pinning protection key, which
    is never provided to the client. Server configuration parameters
    such as the CA and the public key may change without affecting the
    pinning ticket
    protocol.[¶](#section-1-11.2){.pilcrow}]{#section-1-11.2}
-   [Once a single parameter is configured (the ticket\'s lifetime),
    operation is fully automated. The server administrator need not
    bother with the management of backup certificates or explicit
    pins.[¶](#section-1-11.3){.pilcrow}]{#section-1-11.3}
-   [For server clusters, we reuse the existing infrastructure
    \[[RFC5077](#RFC5077){.xref}\] where it
    exists.[¶](#section-1-11.4){.pilcrow}]{#section-1-11.4}
-   [Pinning errors, presumably resulting from man-in-the-middle (MITM)
    attacks, can be detected both by the client and the server. This
    allows for server-side detection of MITM attacks using large-scale
    analytics, and with no need to rely on clients to explicitly report
    the error.[¶](#section-1-11.5){.pilcrow}]{#section-1-11.5}

A note on terminology: unlike other solutions in this space, we do not
do \"certificate pinning\" (or \"public key pinning\"), since the
protocol is oblivious to the server\'s certificate. We prefer the term
\"server identity pinning\" for this new solution. In our solution, the
server proves its identity by generating a proof that it can read and
decrypt an encrypted ticket. As a result, the identity proof relies on
proof of ownership of the pinning protection key. However, this key is
never exchanged with the client or known by it, and so cannot itself be
pinned.[¶](#section-1-12){.pilcrow}

::: {#conventions-used-in-this-document}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Conventions Used in This Document](#name-conventions-used-in-this-do){.section-name .selfRef} {#name-conventions-used-in-this-do}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-1){.pilcrow}
:::
:::

::: {#scope-of-experimentation}
::: {#section-1.2 .section}
### [1.2.](#section-1.2){.section-number .selfRef} [Scope of Experimentation](#name-scope-of-experimentation){.section-name .selfRef} {#name-scope-of-experimentation}

This document describes an experimental extension to the TLS protocol.
This section defines constraints on this experiment and how it can yield
useful information, potentially resulting in a
standard.[¶](#section-1.2-1){.pilcrow}

The protocol is designed so that if the server does not support it, the
client and server fall back to a normal TLS exchange, with the exception
of a single PinningTicket extension being initially sent by the client.
In addition, the protocol is designed only to strengthen the validation
of the server\'s identity (\"second factor\"). As a result,
implementation or even protocol errors should not result in weakened
security compared to the normal TLS exchange. Given these two points,
experimentation can be run on the open Internet between consenting
client and server implementations.[¶](#section-1.2-2){.pilcrow}

The goal of the experiment is to prove
that:[¶](#section-1.2-3){.pilcrow}

-   [Non-supporting clients and servers are
    unaffected.[¶](#section-1.2-4.1){.pilcrow}]{#section-1.2-4.1}
-   [Connectivity between supporting clients and servers is retained
    under normal circumstances, whether the client connects to the
    server frequently (relative to the ticket\'s lifetime) or very
    rarely.[¶](#section-1.2-4.2){.pilcrow}]{#section-1.2-4.2}
-   [Enterprise middleboxes do not interrupt such
    connectivity.[¶](#section-1.2-4.3){.pilcrow}]{#section-1.2-4.3}
-   [Misissued certificates and rogue TLS-aware middleboxes do result in
    broken connectivity, and these cases are detected on the client
    and/or server side. Clients and servers can be recovered even after
    such events and the normal connectivity
    restored.[¶](#section-1.2-4.4){.pilcrow}]{#section-1.2-4.4}

Following two years of successful deployment, the authors will publish a
document that summarizes the experiment\'s findings and will resubmit
the protocol for consideration as a Proposed
Standard.[¶](#section-1.2-5){.pilcrow}
:::
:::
:::
:::

::: {#protocol-overview}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Protocol Overview](#name-protocol-overview){.section-name .selfRef} {#name-protocol-overview}

The protocol consists of two phases: the first time a particular client
connects to a server, and subsequent
connections.[¶](#section-2-1){.pilcrow}

This protocol supports full TLS handshakes, as well as 0-RTT handshakes.
Below we present it in the context of a full handshake, but behavior in
0-RTT handshakes should be identical.[¶](#section-2-2){.pilcrow}

The document presents some similarities with the ticket resumption
mechanism described in \[[RFC5077](#RFC5077){.xref}\]. However the scope
of this document differs from session resumption mechanisms implemented
with \[[RFC5077](#RFC5077){.xref}\] or with other mechanisms.
Specifically, the pinning ticket does not carry any state associated
with a TLS session and thus cannot be used for session resumption or
client authentication. Instead, the pinning ticket only contains the
encrypted pinning secret. The pinning ticket is used by the server to
prove its ability to decrypt it, which implies ownership of the pinning
protection key.[¶](#section-2-3){.pilcrow}

\[[RFC5077](#RFC5077){.xref}\] has been obsoleted by
\[[RFC8446](#RFC8446){.xref}\], and ticket resumption is now defined by
[Section
2.2](https://www.rfc-editor.org/rfc/rfc8446#section-2.2){.relref} of
\[[RFC8446](#RFC8446){.xref}\]. This document references
\[[RFC5077](#RFC5077){.xref}\] as an informational document since it
contains a more thorough discussion of stateless ticket resumption, and
because ticket resumption benefits from significant operational
experience with TLS 1.2 that is still widely deployed at the time of
writing. This experience, as well as deployment experience, can easily
be re-used for identity pinning.[¶](#section-2-4){.pilcrow}

With TLS 1.3, session resumption is based on a Pre-Shared Key (PSK).
This is orthogonal to this protocol. With TLS 1.3, a TLS session can be
established using PKI and a pinning ticket, and later resumed with
PSK.[¶](#section-2-5){.pilcrow}

However, the protocol described in this document addresses the problem
of misissued certificates. Thus, it is not expected to be used outside a
certificate-based TLS key exchange, such as in PSK. As a result, PSK
handshakes [MUST NOT]{.bcp14} include the extension defined
here.[¶](#section-2-6){.pilcrow}

::: {#initial-connection}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Initial Connection](#name-initial-connection){.section-name .selfRef} {#name-initial-connection}

When a client first connects to a server, it requests a pinning ticket
by sending an empty PinningTicket extension, and receives it as part of
the server\'s first response, in the returned PinningTicket
extension.[¶](#section-2.1-1){.pilcrow}

::: {#section-2.1-2 .artwork .art-text .alignLeft .art-ascii-art}
     Client                                               Server

     ClientHello
       + key_share
       + signature_algorithms
       + PinningTicket         -------->
                                                     ServerHello
                                                     + key_share
                                           {EncryptedExtensions
                                                + PinningTicket}
                                           {CertificateRequest*}
                                                  {Certificate*}
                                            {CertificateVerify*}
                               <--------              {Finished}
     {Certificate*}
     {CertificateVerify*}
     {Finished}                -------->
     [Application Data]        <------->      [Application Data]

            *  Indicates optional or situation-dependent
               messages that are not always sent.

            {} Indicates messages protected using keys
               derived from the ephemeral secret.

            [] Indicates messages protected using keys
               derived from the master secret.

[¶](#section-2.1-2){.pilcrow}
:::

If a client supports the PinningTicket extension and does not have any
pinning ticket associated with the server, the exchange is considered as
an initial connection. Other reasons the client may not have a pinning
ticket include the client having flushed its pinning ticket store, or
the committed lifetime of the pinning ticket having
expired.[¶](#section-2.1-3){.pilcrow}

Upon receipt of the PinningTicket extension, the server computes a
pinning secret ([Section 4.1](#pinning-secret){.xref}) and sends the
pinning ticket ([Section 4.2](#pinning-ticket){.xref}) encrypted with
the pinning protection key ([Section 4.3](#pinning-ticket-key){.xref}).
The pinning ticket is associated with a lifetime value by which the
server assumes the responsibility of retaining the pinning protection
key and being able to decrypt incoming pinning tickets during the period
indicated by the committed lifetime.[¶](#section-2.1-4){.pilcrow}

Once the pinning ticket has been generated, the server returns the
pinning ticket and the committed lifetime in a PinningTicket extension
embedded in the EncryptedExtensions message. We note that a
PinningTicket extension [MUST NOT]{.bcp14} be sent as part of a
HelloRetryRequest.[¶](#section-2.1-5){.pilcrow}

Upon receiving the pinning ticket, the client [MUST NOT]{.bcp14} accept
it until the key exchange is completed and the server authenticated. If
the key exchange is not completed successfully, the client
[MUST]{.bcp14} ignore the received pinning ticket. Otherwise, the client
computes the pinning secret and [SHOULD]{.bcp14} cache the pinning
secret and the pinning ticket for the duration indicated by the pinning
ticket lifetime. The client [SHOULD]{.bcp14} clean up the cached values
at the end of the indicated lifetime.[¶](#section-2.1-6){.pilcrow}
:::
:::

::: {#subsequent-connections}
::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [Subsequent Connections](#name-subsequent-connections){.section-name .selfRef} {#name-subsequent-connections}

When the client initiates a connection to a server it has previously
seen (see [Section 2.3](#indexing){.xref} on identifying servers), it
[SHOULD]{.bcp14} send the pinning ticket for that server. The pinning
ticket, pinning secret, and pinning ticket lifetime computed during the
establishment of the previous TLS session are designated in this
document as the \"original\" ones, to distinguish them from a new ticket
that may be generated during the current
session.[¶](#section-2.2-1){.pilcrow}

The server [MUST]{.bcp14} extract the original pinning_secret value from
the ticket and [MUST]{.bcp14} respond with a PinningTicket extension,
which includes:[¶](#section-2.2-2){.pilcrow}

-   [A proof that the server can understand the ticket that was sent by
    the client; this proof also binds the pinning ticket to the
    server\'s (current) public key, as well as the ongoing TLS session.
    The proof is mandatory and [MUST]{.bcp14} be included if a pinning
    ticket was sent by the
    client.[¶](#section-2.2-3.1){.pilcrow}]{#section-2.2-3.1}
-   [A fresh pinning ticket. The main reason for refreshing the ticket
    on each connection is privacy: to avoid the ticket serving as a
    fixed client identifier. While a fresh pinning ticket might be of
    zero length, it is [RECOMMENDED]{.bcp14} to include a fresh ticket
    with a nonzero length with each
    response.[¶](#section-2.2-3.2){.pilcrow}]{#section-2.2-3.2}

If the server cannot validate the received ticket, that might indicate
an earlier MITM attack on this client. The server [MUST]{.bcp14} then
abort the connection with a handshake_failure alert and [SHOULD]{.bcp14}
log this failure.[¶](#section-2.2-4){.pilcrow}

The client [MUST]{.bcp14} verify the proof, and if it fails to do so,
the client [MUST]{.bcp14} issue a handshake_failure alert and abort the
connection (see also [Section 6.5](#client_error){.xref}). It is
important that the client does not attempt to \"fall back\" by omitting
the PinningTicket extension.[¶](#section-2.2-5){.pilcrow}

When the connection is successfully set up, i.e., after the Finished
message is verified, the client [SHOULD]{.bcp14} store the new ticket
along with the corresponding pinning_secret, replacing the original
ticket.[¶](#section-2.2-6){.pilcrow}

Although this is an extension, if the client already has a ticket for a
server, the client [MUST]{.bcp14} interpret a missing PinningTicket
extension in the server\'s response as an attack, because of the
server\'s prior commitment to respect the ticket. The client
[MUST]{.bcp14} abort the connection in this case. See also [Section
5.5](#ramp_down){.xref} on ramping down support for this
extension.[¶](#section-2.2-7){.pilcrow}
:::
:::

::: {#indexing}
::: {#section-2.3 .section}
### [2.3.](#section-2.3){.section-number .selfRef} [Indexing the Pins](#name-indexing-the-pins){.section-name .selfRef} {#name-indexing-the-pins}

Each pin is associated with a set of identifiers that include, among
others, hostname, protocol (TLS or DTLS), and port number. In other
words, the pin for port TCP/443 may be different from that for DTLS, or
from the pin for port TCP/8443. These identifiers are expected to be
relevant to characterize the identity of the server as well as the
establishing TLS session. When a hostname is used, it [MUST]{.bcp14} be
the value sent inside the Server Name Indication (SNI) extension. This
definition is similar to the concept of a Web Origin
\[[RFC6454](#RFC6454){.xref}\], but does not assume the existence of a
URL.[¶](#section-2.3-1){.pilcrow}

The purpose of ticket pinning is to pin the server identity. As a
result, any information orthogonal to the server\'s identity [MUST
NOT]{.bcp14} be considered in indexing. More particularly, IP addresses
are ephemeral and forbidden in SNI, and therefore pins [MUST
NOT]{.bcp14} be associated with IP addresses. Similarly, CA names or
public keys associated with server [MUST NOT]{.bcp14} be used for
indexing as they may change over time.[¶](#section-2.3-2){.pilcrow}
:::
:::
:::
:::

::: {#message-definitions}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Message Definitions](#name-message-definitions){.section-name .selfRef} {#name-message-definitions}

This section defines the format of the PinningTicket extension. We
follow the message notation of
\[[RFC8446](#RFC8446){.xref}\].[¶](#section-3-1){.pilcrow}

::: {#section-3-2}
``` {.sourcecode .lang-c}
 opaque pinning_ticket<0..2^16-1>;

 opaque pinning_proof<0..2^8-1>;

 struct {
   select (Role) {
     case client:
       pinning_ticket ticket<0..2^16-1>; //omitted on 1st connection

     case server:
       pinning_proof proof<0..2^8-1>; //no proof on 1st connection
       pinning_ticket ticket<0..2^16-1>; //omitted on ramp down
       uint32 lifetime;
   }
} PinningTicketExtension;
```

[¶](#section-3-2){.pilcrow}
:::

ticket
:   a pinning ticket sent by the client or returned by the server. The
    ticket is opaque to the client. The extension [MUST]{.bcp14} contain
    exactly 0 or 1 tickets.[¶](#section-3-3.2){.pilcrow}

proof
:   a demonstration by the server that it understands the received
    ticket and therefore that it is in possession of the secret that was
    used to generate it originally. The extension [MUST]{.bcp14} contain
    exactly 0 or 1 proofs.[¶](#section-3-3.4){.pilcrow}

lifetime
:   the duration (in seconds) that the server commits to accept offered
    tickets in the future.[¶](#section-3-3.6){.pilcrow}
:::
:::

::: {#crypto}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Cryptographic Operations](#name-cryptographic-operations){.section-name .selfRef} {#name-cryptographic-operations}

This section provides details on the cryptographic operations performed
by the protocol peers.[¶](#section-4-1){.pilcrow}

::: {#pinning-secret}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Pinning Secret](#name-pinning-secret){.section-name .selfRef} {#name-pinning-secret}

The pinning secret is generated locally by the client and the server,
which means they must use the same inputs to generate it. This value
must be generated before the ServerHello message is sent, as the server
includes the corresponding pinning ticket in the same flight as the
ServerHello message. In addition, the pinning secret must be
unpredictable to any party other than the client and the
server.[¶](#section-4.1-1){.pilcrow}

The pinning secret is derived using the Derive-Secret function provided
by TLS 1.3, described in [Section
7.1](https://www.rfc-editor.org/rfc/rfc8446#section-7.1){.relref} of
\[[RFC8446](#RFC8446){.xref}\].[¶](#section-4.1-2){.pilcrow}

::: {#section-4.1-3}
``` {.sourcecode .lang-c}
pinning secret = Derive-Secret(Handshake Secret, "pinning secret",
         ClientHello...ServerHello)
```

[¶](#section-4.1-3){.pilcrow}
:::
:::
:::

::: {#pinning-ticket}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Pinning Ticket](#name-pinning-ticket){.section-name .selfRef} {#name-pinning-ticket}

The pinning ticket contains the pinning secret. The pinning ticket is
provided by the client to the server, which decrypts it in order to
extract the pinning secret and responds with a pinning proof. As a
result, the characteristics of the pinning ticket
are:[¶](#section-4.2-1){.pilcrow}

-   [Pinning tickets [MUST]{.bcp14} be encrypted and integrity-protected
    using strong cryptographic
    algorithms.[¶](#section-4.2-2.1){.pilcrow}]{#section-4.2-2.1}
-   [Pinning tickets [MUST]{.bcp14} be protected with a long-term
    pinning protection
    key.[¶](#section-4.2-2.2){.pilcrow}]{#section-4.2-2.2}
-   [Pinning tickets [MUST]{.bcp14} include a pinning protection key ID
    or serial number as to enable the pinning protection key to be
    refreshed.[¶](#section-4.2-2.3){.pilcrow}]{#section-4.2-2.3}
-   [The pinning ticket [MAY]{.bcp14} include other information, in
    addition to the pinning secret. When additional information is
    included, a careful review needs to be performed to evaluate its
    impact on privacy.[¶](#section-4.2-2.4){.pilcrow}]{#section-4.2-2.4}

The pinning ticket\'s format is not specified by this document, but a
format similar to the one proposed by \[[RFC5077](#RFC5077){.xref}\] is
[RECOMMENDED]{.bcp14}.[¶](#section-4.2-3){.pilcrow}
:::
:::

::: {#pinning-ticket-key}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Pinning Protection Key](#name-pinning-protection-key){.section-name .selfRef} {#name-pinning-protection-key}

The pinning protection key is used only by the server and so remains
server implementation specific. \[[RFC5077](#RFC5077){.xref}\]
recommends the use of two keys, but when using Authenticated Encryption
with Associated Data (AEAD) algorithms, only a single key is
required.[¶](#section-4.3-1){.pilcrow}

When a single server terminates TLS for multiple virtual servers using
the SNI mechanism, it is strongly [RECOMMENDED]{.bcp14} that the server
use a separate protection key for each one of them, in order to allow
migrating virtual servers between different servers while keeping
pinning active.[¶](#section-4.3-2){.pilcrow}

As noted in [Section 5.1](#cluster){.xref}, if the server is actually a
cluster of machines, the protection key [MUST]{.bcp14} be synchronized
between all the nodes that accept TLS connections to the same server
name. When \[[RFC5077](#RFC5077){.xref}\] is deployed, an easy way to do
it is to derive the protection key from the session-ticket protection
key, which is already synchronized. For
example:[¶](#section-4.3-3){.pilcrow}

::: {#section-4.3-4}
``` {.sourcecode .lang-c}
pinning_protection_key = HKDF-Expand(resumption_protection_key,
                              "pinning protection", L)
```

[¶](#section-4.3-4){.pilcrow}
:::

Where resumption_protection_key is the ticket protection key defined in
\[[RFC5077](#RFC5077){.xref}\]. Both resumption_protection_key and
pinning_protection_key are only used by the
server.[¶](#section-4.3-5){.pilcrow}

The above solution attempts to minimize code changes related to
management of the resumption_protection_key. The drawback is that this
key would be used both to directly encrypt session tickets and to derive
the pinning_protection_key, and such mixed usage of a single key is not
in line with cryptographic best practices. Where possible, it is
[RECOMMENDED]{.bcp14} that the resumption_protection_key be unrelated to
the pinning_protection_key and that they are separately shared among the
relevant servers.[¶](#section-4.3-6){.pilcrow}
:::
:::

::: {#pinning-proof}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Pinning Proof](#name-pinning-proof){.section-name .selfRef} {#name-pinning-proof}

The pinning proof is sent by the server to demonstrate that it has been
able to decrypt the pinning ticket and to retrieve the pinning secret.
The proof must be unpredictable and must not be replayed. Similarly to
the pinning ticket, the pinning proof is sent by the server in the
ServerHello message. In addition, it must not be possible for a MITM
server with a fake certificate to obtain a pinning proof from the
original server.[¶](#section-4.4-1){.pilcrow}

In order to address these requirements, the pinning proof is bound to
the TLS session as well as the public key of the
server:[¶](#section-4.4-2){.pilcrow}

::: {#section-4.4-3}
``` {.sourcecode .lang-c}
pinning_proof_secret=Derive-Secret(Handshake Secret, 
             "pinning proof 1", ClientHello...ServerHello)

proof = HMAC(original_pinning_secret, "pinning proof 2" +
             pinning_proof_secret + Hash(server_public_key))
```

[¶](#section-4.4-3){.pilcrow}
:::

where HMAC \[[RFC2104](#RFC2104){.xref}\] uses the Hash algorithm that
was negotiated in the handshake, and the same hash is also used over the
server\'s public key. The original_pinning_secret value refers to the
secret value extracted from the ticket sent by the client, to
distinguish it from a new pinning secret value that is possibly computed
in the current exchange. The server_public_key value is the DER
representation of the public key, specifically the SubjectPublicKeyInfo
structure as-is.[¶](#section-4.4-4){.pilcrow}
:::
:::
:::
:::

::: {#operational-considerations}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Operational Considerations](#name-operational-considerations){.section-name .selfRef} {#name-operational-considerations}

The main motivation behind the current protocol is to enable identity
pinning without the need for manual operations. Manual operations are
susceptible to human error, and in the case of public key pinning, can
easily result in \"server bricking\": the server becoming inaccessible
to some or all of its users. To achieve this goal, operations described
in identity pinning are only performed within the current TLS session,
and there is no dependence on any TLS configuration parameters such as
CA identity or public keys. As a result, configuration changes are
unlikely to lead to desynchronized state between the client and the
server.[¶](#section-5-1){.pilcrow}

::: {#cluster}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Protection Key Synchronization](#name-protection-key-synchronizat){.section-name .selfRef} {#name-protection-key-synchronizat}

The only operational requirement when deploying this protocol is that,
if the server is part of a cluster, protection keys (the keys used to
encrypt tickets) [MUST]{.bcp14} be synchronized between all cluster
members. The protocol is designed so that if resumption ticket
protection keys \[[RFC5077](#RFC5077){.xref}\] are already synchronized
between cluster members, nothing more needs to be
done.[¶](#section-5.1-1){.pilcrow}

Moreover, synchronization does not need to be instantaneous, e.g.,
protection keys can be distributed a few minutes or hours in advance of
their rollover. In such scenarios, each cluster member [MUST]{.bcp14} be
able to accept tickets protected with a new version of the protection
key, even while it is still using an old version to generate keys. This
ensures that, when a client receives a \"new\" ticket, it does not next
hit a cluster member that still rejects this
ticket.[¶](#section-5.1-2){.pilcrow}

Misconfiguration can lead to the server\'s clock being off by a large
amount of time. Consider a case where a server\'s clock is
misconfigured, for example, to be 1 year in the future, and the system
is allowed to delete expired keys automatically. The server will then
delete many outstanding keys because they are now long expired and will
end up rejecting valid tickets that are stored by clients. Such a
scenario could make the server inaccessible to a large number of
clients.[¶](#section-5.1-3){.pilcrow}

The decision to delete a key should at least consider the largest value
of the ticket lifetime as well as the expected time desynchronization
between the servers of the cluster and the time difference for
distributing the new key among the different servers in the
cluster.[¶](#section-5.1-4){.pilcrow}
:::
:::

::: {#ticket-lifetime}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Ticket Lifetime](#name-ticket-lifetime){.section-name .selfRef} {#name-ticket-lifetime}

The lifetime of the ticket is a commitment by the server to retain the
ticket\'s corresponding protection key for this duration, so that the
server can prove to the client that it knows the secret embedded in the
ticket. For production systems, the lifetime [SHOULD]{.bcp14} be between
7 and 31 days.[¶](#section-5.2-1){.pilcrow}
:::
:::

::: {#certificate-renewal}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Certificate Renewal](#name-certificate-renewal){.section-name .selfRef} {#name-certificate-renewal}

The protocol ensures that the client will continue speaking to the
correct server even when the server\'s certificate is renewed. In this
sense, pinning is not associated with certificates, which is the reason
we designate the protocol described in this document as \"server
identity pinning\".[¶](#section-5.3-1){.pilcrow}

Note that this property is not impacted by the use of the server\'s
public key in the pinning proof because the scope of the public key used
is only the current TLS session.[¶](#section-5.3-2){.pilcrow}
:::
:::

::: {#certificate-revocation}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [Certificate Revocation](#name-certificate-revocation){.section-name .selfRef} {#name-certificate-revocation}

The protocol is orthogonal to certificate validation in the sense that,
if the server\'s certificate has been revoked or is invalid for some
other reason, the client [MUST]{.bcp14} refuse to connect to it
regardless of any ticket-related behavior.[¶](#section-5.4-1){.pilcrow}
:::
:::

::: {#ramp_down}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [Disabling Pinning](#name-disabling-pinning){.section-name .selfRef} {#name-disabling-pinning}

A server implementing this protocol [MUST]{.bcp14} have a \"ramp down\"
mode of operation where:[¶](#section-5.5-1){.pilcrow}

-   [The server continues to accept valid pinning tickets and responds
    correctly with a
    proof.[¶](#section-5.5-2.1){.pilcrow}]{#section-5.5-2.1}
-   [The server does not send back a new pinning
    ticket.[¶](#section-5.5-2.2){.pilcrow}]{#section-5.5-2.2}

After a while, no clients will hold valid tickets, and the feature may
be disabled. Note that clients that do not receive a new pinning ticket
do not necessarily need to remove the original ticket. Instead, the
client may keep using the ticket until its lifetime expires. However, as
detailed in [Section 6.7](#privacy){.xref}, re-use of a ticket by the
client may result in privacy concerns as the ticket value may be used to
correlate TLS sessions.[¶](#section-5.5-3){.pilcrow}

Issuing a new pinning ticket with a shorter lifetime would only delay
the ramp down process, as the shorter lifetime can only affect clients
that actually initiated a new connection. Other clients would still see
the original lifetime for their pinning
tickets.[¶](#section-5.5-4){.pilcrow}
:::
:::

::: {#server-compromise}
::: {#section-5.6 .section}
### [5.6.](#section-5.6){.section-number .selfRef} [Server Compromise](#name-server-compromise){.section-name .selfRef} {#name-server-compromise}

If a server compromise is detected, the pinning protection key
[MUST]{.bcp14} be rotated immediately, but the server [MUST]{.bcp14}
still accept valid tickets that use the old, compromised key. Clients
that still hold old pinning tickets will remain vulnerable to MITM
attacks, but those that connect to the correct server will immediately
receive new tickets protected with the newly generated pinning
protection key.[¶](#section-5.6-1){.pilcrow}

The same procedure applies if the pinning protection key is compromised
directly, e.g., if a backup copy is inadvertently made
public.[¶](#section-5.6-2){.pilcrow}
:::
:::

::: {#disaster-recovery}
::: {#section-5.7 .section}
### [5.7.](#section-5.7){.section-number .selfRef} [Disaster Recovery](#name-disaster-recovery){.section-name .selfRef} {#name-disaster-recovery}

All web servers in production need to be backed up, so that they can be
recovered if a disaster (including a malicious activity) ever wipes them
out. Backup often includes the certificate and its private key, which
must be backed up securely. The pinning secret, including earlier
versions that are still being accepted, must be backed up regularly.
However since it is only used as an authentication second factor, it
does not require the same level of confidentiality as the server\'s
private key.[¶](#section-5.7-1){.pilcrow}

Readers should note that \[[RFC5077](#RFC5077){.xref}\] session
resumption keys are more security sensitive and should normally not be
backed up, but rather treated as ephemeral keys. Even when servers
derive pinning secrets from resumption keys ([Section
4.1](#pinning-secret){.xref}), they [MUST NOT]{.bcp14} back up
resumption keys.[¶](#section-5.7-2){.pilcrow}
:::
:::
:::
:::

::: {#security-considerations}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

This section reviews several security aspects related to the proposed
extension.[¶](#section-6-1){.pilcrow}

::: {#trust-on-first-use-tofu-and-mitm-attacks}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Trust-on-First-Use (TOFU) and MITM Attacks](#name-trust-on-first-use-tofu-and){.section-name .selfRef} {#name-trust-on-first-use-tofu-and}

This protocol is a trust-on-first-use protocol. If a client initially
connects to the \"right\" server, it will be protected against MITM
attackers for the lifetime of each received ticket. If it connects
regularly (depending, of course, on the server-selected lifetime), it
will stay constantly protected against fake
certificates.[¶](#section-6.1-1){.pilcrow}

However if it initially connects to an attacker, subsequent connections
to the \"right\" server will fail. Server operators might want to advise
clients on how to remove corrupted pins, once such large-scale attacks
are detected and remediated.[¶](#section-6.1-2){.pilcrow}

The protocol is designed so that it is not vulnerable to an active MITM
attacker who has real-time access to the original server. The pinning
proof includes a hash of the server\'s public key to ensure the client
that the proof was in fact generated by the server with which it is
initiating the connection.[¶](#section-6.1-3){.pilcrow}
:::
:::

::: {#pervasive-monitoring}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Pervasive Monitoring](#name-pervasive-monitoring){.section-name .selfRef} {#name-pervasive-monitoring}

Some organizations, and even some countries, perform pervasive
monitoring on their constituents \[[RFC7258](#RFC7258){.xref}\]. This
often takes the form of always-active SSL proxies. Because of the TOFU
property, this protocol does not provide any security in such
cases.[¶](#section-6.2-1){.pilcrow}

Pervasive monitoring may also result in privacy concerns detailed in
[Section 6.7](#privacy){.xref}.[¶](#section-6.2-2){.pilcrow}
:::
:::

::: {#server_error}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Server-Side Error Detection](#name-server-side-error-detection){.section-name .selfRef} {#name-server-side-error-detection}

Uniquely, this protocol allows the server to detect clients that present
incorrect tickets and therefore can be assumed to be victims of a MITM
attack. Server operators can use such cases as indications of ongoing
attacks, similarly to fake certificate attacks that took place in a few
countries in the past.[¶](#section-6.3-1){.pilcrow}
:::
:::

::: {#client_policy}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [Client Policy and SSL Proxies](#name-client-policy-and-ssl-proxi){.section-name .selfRef} {#name-client-policy-and-ssl-proxi}

Like it or not, some clients are normally deployed behind an SSL proxy.
Similar to \[[RFC7469](#RFC7469){.xref}\], it is acceptable to allow
pinning to be disabled for some hosts according to local policy. For
example, a User Agent (UA) [MAY]{.bcp14} disable pinning for hosts whose
validated certificate chain terminates at a user-defined trust anchor,
rather than a trust anchor built into the UA (or underlying platform).
Moreover, a client [MAY]{.bcp14} accept an empty PinningTicket extension
from such hosts as a valid response.[¶](#section-6.4-1){.pilcrow}
:::
:::

::: {#client_error}
::: {#section-6.5 .section}
### [6.5.](#section-6.5){.section-number .selfRef} [Client-Side Error Behavior](#name-client-side-error-behavior){.section-name .selfRef} {#name-client-side-error-behavior}

When a client receives a malformed or empty PinningTicket extension from
a pinned server, it [MUST]{.bcp14} abort the handshake. If the client
retries the request, it [MUST NOT]{.bcp14} omit the PinningTicket in the
retry message. Doing otherwise would expose the client to trivial
fallback attacks, similar to those described in
\[[RFC7507](#RFC7507){.xref}\].[¶](#section-6.5-1){.pilcrow}

However, this rule can negatively impact clients that move from behind
SSL proxies into the open Internet, and vice versa, if the advice in
[Section 6.4](#client_policy){.xref} is not followed. Therefore, it is
[RECOMMENDED]{.bcp14} that browser and library vendors provide a
documented way to remove stored pins.[¶](#section-6.5-2){.pilcrow}
:::
:::

::: {#stolen-and-forged-tickets}
::: {#section-6.6 .section}
### [6.6.](#section-6.6){.section-number .selfRef} [Stolen and Forged Tickets](#name-stolen-and-forged-tickets){.section-name .selfRef} {#name-stolen-and-forged-tickets}

An attacker gains no benefit from stealing pinning tickets, even in
conjunction with other pinning parameters such as the associated pinning
secret, since pinning tickets are used to secure the client rather than
the server. Similarly, it is useless to forge a ticket for a particular
server.[¶](#section-6.6-1){.pilcrow}
:::
:::

::: {#privacy}
::: {#section-6.7 .section}
### [6.7.](#section-6.7){.section-number .selfRef} [Client Privacy](#name-client-privacy){.section-name .selfRef} {#name-client-privacy}

This protocol is designed so that an external attacker cannot link
different requests to a single client, provided the client requests and
receives a fresh ticket upon each connection. This may be of concern
particularly during ramp down, if the server does not provide a new
ticket, and the client reuses the same ticket. To reduce or avoid such
privacy concerns, it is [RECOMMENDED]{.bcp14} for the server to issue a
fresh ticket with a reduced lifetime. This would at least reduce the
time period in which the TLS sessions of the client can be linked. The
server [MAY]{.bcp14} also issue tickets with a zero-second lifetime
until it is confident all tickets are
expired.[¶](#section-6.7-1){.pilcrow}

On the other hand, the server to which the client is connecting can
easily track the client. This may be an issue when the client expects to
connect to the server (e.g., a mail server) with multiple identities.
Implementations [SHOULD]{.bcp14} allow the user to opt out of pinning,
either in general or for particular
servers.[¶](#section-6.7-2){.pilcrow}

This document does not define the exact content of tickets. Including
client-specific information in tickets would raise privacy concerns and
is [NOT RECOMMENDED]{.bcp14}.[¶](#section-6.7-3){.pilcrow}
:::
:::

::: {#ticket-protection-key-management}
::: {#section-6.8 .section}
### [6.8.](#section-6.8){.section-number .selfRef} [Ticket Protection Key Management](#name-ticket-protection-key-manag){.section-name .selfRef} {#name-ticket-protection-key-manag}

While the ticket format is not mandated by this document, protecting the
ticket using authenticated encryption is [RECOMMENDED]{.bcp14}. Some of
the algorithms commonly used for authenticated encryption, e.g.,
Galois/Counter Mode (GCM), are highly vulnerable to nonce reuse, and
this problem is magnified in a cluster setting. Therefore,
implementations that choose AES-GCM or any AEAD equivalent
[MUST]{.bcp14} adopt one of these three
alternatives:[¶](#section-6.8-1){.pilcrow}

-   [Partition the nonce namespace between cluster members and use
    monotonic counters on each member, e.g., by setting the nonce to the
    concatenation of the cluster member ID and an incremental
    counter.[¶](#section-6.8-2.1){.pilcrow}]{#section-6.8-2.1}
-   [Generate random nonces but avoid the so-called birthday bound,
    i.e., never generate more than the maximum allowed number of
    encrypted tickets (2\*\*64 for AES-128-GCM) for the same ticket
    pinning protection
    key.[¶](#section-6.8-2.2){.pilcrow}]{#section-6.8-2.2}
-   [An alternative design that has been attributed to Karthik Bhargavan
    is as follows. Start with a 128-bit master key K_master and then for
    each encryption, generate a 256-bit random nonce and compute: K =
    HKDF(K_master, Nonce \|\| \"key\"), then N = HKDF(K_master, Nonce
    \|\| \"nonce\"). Use these values to encrypt the ticket, AES-GCM(K,
    N, data). This nonce should then be stored and transmitted with the
    ticket.[¶](#section-6.8-2.3){.pilcrow}]{#section-6.8-2.3}
:::
:::
:::
:::

::: {#iana-considerations}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

The IANA has allocated a TicketPinning extension value in the \"TLS
ExtensionType Values\" registry.[¶](#section-7-1){.pilcrow}

\[[RFC8447](#RFC8447){.xref}\] defines the procedure, requirements, and
the necessary information for the IANA to update the \"TLS ExtensionType
Values\" registry \[[TLS-EXT](#TLS-EXT){.xref}\]. The registration
procedure is \"Specification Required\"
\[[RFC8126](#RFC8126){.xref}\].[¶](#section-7-2){.pilcrow}

The TicketPinning extension is registered as follows. (The extension is
not limited to Private Use, and as such has its first byte in the range
0-254.)[¶](#section-7-3){.pilcrow}

Value:
:   32[¶](#section-7-4.2){.pilcrow}

Name:
:   ticket_pinning[¶](#section-7-4.4){.pilcrow}

Recommended:
:   No[¶](#section-7-4.6){.pilcrow}

TLS 1.3:
:   CH, EE (to indicate that the extension is present in ClientHello and
    EncryptedExtensions messages)[¶](#section-7-4.8){.pilcrow}
:::
:::

::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.

\[RFC8126\]
:   [Cotton, M.]{.refAuthor}[, Leiba, B.]{.refAuthor}[, and T.
    Narten]{.refAuthor}, [\"Guidelines for Writing an IANA
    Considerations Section in RFCs\"]{.refTitle}, [BCP 26]{.seriesInfo},
    [RFC 8126]{.seriesInfo}, [DOI 10.17487/RFC8126]{.seriesInfo}, June
    2017, \<<https://www.rfc-editor.org/info/rfc8126>\>.

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.

\[RFC8446\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.

\[RFC8447\]
:   [Salowey, J.]{.refAuthor}[ and S. Turner]{.refAuthor}, [\"IANA
    Registry Updates for TLS and DTLS\"]{.refTitle}, [RFC
    8447]{.seriesInfo}, [DOI 10.17487/RFC8447]{.seriesInfo}, August
    2018, \<<https://www.rfc-editor.org/info/rfc8447>\>.
:::

::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[Netcraft\]
:   [Mutton, P.]{.refAuthor}, [\"HTTP Public Key Pinning: You\'re doing
    it wrong!\"]{.refTitle}, March 2016,
    \<<https://news.netcraft.com/archives/2016/03/30/http-public-key-pinning-youre-doing-it-wrong.html>\>.

\[Oreo\]
:   [Berkman, O.]{.refAuthor}[, Pinkas, B.]{.refAuthor}[, and M.
    Yung]{.refAuthor}, [\"Firm Grip Handshakes: A Tool for Bidirectional
    Vouching\"]{.refTitle}, [Cryptology and Network Security pp.
    142-157]{.seriesInfo}, 2012.

\[RFC2104\]
:   [Krawczyk, H.]{.refAuthor}[, Bellare, M.]{.refAuthor}[, and R.
    Canetti]{.refAuthor}, [\"HMAC: Keyed-Hashing for Message
    Authentication\"]{.refTitle}, [RFC 2104]{.seriesInfo}, [DOI
    10.17487/RFC2104]{.seriesInfo}, February 1997,
    \<<https://www.rfc-editor.org/info/rfc2104>\>.

\[RFC5077\]
:   [Salowey, J.]{.refAuthor}[, Zhou, H.]{.refAuthor}[,
    Eronen, P.]{.refAuthor}[, and H. Tschofenig]{.refAuthor},
    [\"Transport Layer Security (TLS) Session Resumption without
    Server-Side State\"]{.refTitle}, [RFC 5077]{.seriesInfo}, [DOI
    10.17487/RFC5077]{.seriesInfo}, January 2008,
    \<<https://www.rfc-editor.org/info/rfc5077>\>.

\[RFC5246\]
:   [Dierks, T.]{.refAuthor}[ and E. Rescorla]{.refAuthor}, [\"The
    Transport Layer Security (TLS) Protocol Version 1.2\"]{.refTitle},
    [RFC 5246]{.seriesInfo}, [DOI 10.17487/RFC5246]{.seriesInfo}, August
    2008, \<<https://www.rfc-editor.org/info/rfc5246>\>.

\[RFC6454\]
:   [Barth, A.]{.refAuthor}, [\"The Web Origin Concept\"]{.refTitle},
    [RFC 6454]{.seriesInfo}, [DOI 10.17487/RFC6454]{.seriesInfo},
    December 2011, \<<https://www.rfc-editor.org/info/rfc6454>\>.

\[RFC6962\]
:   [Laurie, B.]{.refAuthor}[, Langley, A.]{.refAuthor}[, and E.
    Kasper]{.refAuthor}, [\"Certificate Transparency\"]{.refTitle}, [RFC
    6962]{.seriesInfo}, [DOI 10.17487/RFC6962]{.seriesInfo}, June 2013,
    \<<https://www.rfc-editor.org/info/rfc6962>\>.

\[RFC7258\]
:   [Farrell, S.]{.refAuthor}[ and H. Tschofenig]{.refAuthor},
    [\"Pervasive Monitoring Is an Attack\"]{.refTitle}, [BCP
    188]{.seriesInfo}, [RFC 7258]{.seriesInfo}, [DOI
    10.17487/RFC7258]{.seriesInfo}, May 2014,
    \<<https://www.rfc-editor.org/info/rfc7258>\>.

\[RFC7469\]
:   [Evans, C.]{.refAuthor}[, Palmer, C.]{.refAuthor}[, and R.
    Sleevi]{.refAuthor}, [\"Public Key Pinning Extension for
    HTTP\"]{.refTitle}, [RFC 7469]{.seriesInfo}, [DOI
    10.17487/RFC7469]{.seriesInfo}, April 2015,
    \<<https://www.rfc-editor.org/info/rfc7469>\>.

\[RFC7507\]
:   [Moeller, B.]{.refAuthor}[ and A. Langley]{.refAuthor}, [\"TLS
    Fallback Signaling Cipher Suite Value (SCSV) for Preventing Protocol
    Downgrade Attacks\"]{.refTitle}, [RFC 7507]{.seriesInfo}, [DOI
    10.17487/RFC7507]{.seriesInfo}, April 2015,
    \<<https://www.rfc-editor.org/info/rfc7507>\>.

\[RFC8555\]
:   [Barnes, R.]{.refAuthor}[, Hoffman-Andrews, J.]{.refAuthor}[,
    McCarney, D.]{.refAuthor}[, and J. Kasten]{.refAuthor}, [\"Automatic
    Certificate Management Environment (ACME)\"]{.refTitle}, [RFC
    8555]{.seriesInfo}, [DOI 10.17487/RFC8555]{.seriesInfo}, March 2019,
    \<<https://www.rfc-editor.org/info/rfc8555>\>.

\[TLS-EXT\]
:   [IANA]{.refAuthor}, [\"TLS Extension Type Value\"]{.refTitle},
    \<<https://www.iana.org/assignments/tls-extensiontype-values/>\>.

\[TLS-TACK\]
:   [Marlinspike, M.]{.refAuthor}, [\"Trust Assertions for Certificate
    Keys\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-perrin-tls-tack-02]{.seriesInfo}, 7 January
    2013, \<<https://tools.ietf.org/html/draft-perrin-tls-tack-02>\>.
:::
:::

::: {#previous-work}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Previous Work](#name-previous-work){.section-name .selfRef} {#name-previous-work}

The global PKI system relies on the trust of a CA issuing certificates.
As a result, a corrupted trusted CA may issue a certificate for any
organization without the organization\'s approval (a misissued or
\"fake\" certificate), and use the certificate to impersonate the
organization. There are many attempts to resolve these weaknesses,
including the Certificate Transparency (CT) protocol
\[[RFC6962](#RFC6962){.xref}\], HTTP Public Key Pinning (HPKP)
\[[RFC7469](#RFC7469){.xref}\], and Trust Assertions for Certificate
Keys (TACK)
\[[TLS-TACK](#I-D.perrin-tls-tack){.xref}\].[¶](#section-appendix.a-1){.pilcrow}

CT requires cooperation of a large portion of the hundreds of extant
certificate authorities (CAs) before it can be used \"for real\", in
enforcing mode. It is noted that the relevant industry forum (CA/Browser
Forum) is indeed pushing for such extensive adoption. However the public
nature of CT often makes it inappropriate for enterprise use because
many organizations are not willing to expose their internal
infrastructure publicly.[¶](#section-appendix.a-2){.pilcrow}

TACK has some similarities to the current proposal, but work on it seems
to have stalled. [Appendix A.2](#tack){.xref} compares our proposal to
TACK.[¶](#section-appendix.a-3){.pilcrow}

HPKP is an IETF standard, but so far has proven hard to deploy. HPKP
pins (fixes) a public key, one of the public keys listed in the
certificate chain. As a result, HPKP needs to be coordinated with the
certificate management process. Certificate management impacts HPKP and
thus increases the probability of HPKP failures. This risk is made even
higher given the fact that, even though work has been done in the
Automated Certificate Management Environment (ACME) working group to
automate certificate management, in many or even most cases,
certificates are still managed manually. As a result, HPKP cannot be
completely automated, resulting in error-prone manual configuration.
Such errors could prevent the web server from being accessed by some
clients. In addition, HPKP uses an HTTP header, which makes this
solution HTTPS specific and not generic to TLS. On the other hand, the
current document provides a solution that is independent of the
server\'s certificate management, and that can be entirely and easily
automated. [Appendix A.1](#hpkp){.xref} compares HPKP to the current
document in more detail.[¶](#section-appendix.a-4){.pilcrow}

The ticket pinning proposal augments these mechanisms with a much easier
to implement and deploy solution for server identity pinning, by reusing
some of the ideas behind TLS session
resumption.[¶](#section-appendix.a-5){.pilcrow}

This section compares ticket pinning to two earlier proposals, HPKP and
TACK.[¶](#section-appendix.a-6){.pilcrow}

::: {#hpkp}
::: {#section-a.1 .section}
## [A.1.](#section-a.1){.section-number .selfRef} [Comparison: HPKP](#name-comparison-hpkp){.section-name .selfRef} {#name-comparison-hpkp}

The current IETF standard for pinning the identity of web servers is
HPKP \[[RFC7469](#RFC7469){.xref}\].[¶](#section-a.1-1){.pilcrow}

The main differences between HPKP and the current document are the
following:[¶](#section-a.1-2){.pilcrow}

-   [HPKP limits its scope to HTTPS, while the current document
    considers all application above
    TLS.[¶](#section-a.1-3.1){.pilcrow}]{#section-a.1-3.1}
-   [HPKP pins the public key of the server (or another public key along
    the certificate chain), and as such, is highly dependent on the
    management of certificates. Such dependency increases the potential
    error surface, especially as certificate management is not yet
    largely automated. The current proposal, on the other hand, is
    independent of certificate
    management.[¶](#section-a.1-3.2){.pilcrow}]{#section-a.1-3.2}
-   [HPKP pins public keys that are public and used for the standard TLS
    authentication. Identity pinning relies on the ownership of the
    pinning key, which is not disclosed to the public and not involved
    in the standard TLS authentication. As a result, identity pinning is
    a completely independent, second-factor authentication
    mechanism.[¶](#section-a.1-3.3){.pilcrow}]{#section-a.1-3.3}
-   [HPKP relies on a backup key to recover the misissuance of a key. We
    believe such backup mechanisms add excessive complexity and cost.
    Reliability of the current mechanism is primarily based on its being
    highly automated.[¶](#section-a.1-3.4){.pilcrow}]{#section-a.1-3.4}
-   [HPKP relies on the client to report errors to the report-uri. The
    current document does not need any out-of-band mechanism, and the
    server is informed automatically. This provides an easier and more
    reliable health
    monitoring.[¶](#section-a.1-3.5){.pilcrow}]{#section-a.1-3.5}

On the other hand, HPKP shares the following aspects with identity
pinning:[¶](#section-a.1-4){.pilcrow}

-   [Both mechanisms provide hard failure. With HPKP, only the client is
    aware of the failure, while with the current proposal both client
    and server are informed of the failure. This provides room for
    further mechanisms to automatically recover from such
    failures.[¶](#section-a.1-5.1){.pilcrow}]{#section-a.1-5.1}
-   [Both mechanisms are subject to a server compromise in which users
    are provided with an invalid ticket (e.g., a random one) or HTTP
    header with a very long lifetime. For identity pinning, this
    lifetime [SHOULD NOT]{.bcp14} be longer than 31 days. In both cases,
    clients will not be able to reconnect the server during this
    lifetime. With the current proposal, an attacker needs to compromise
    the TLS layer, while with HPKP, the attacker needs to compromise the
    HTTP server. Arguably, the TLS-level compromise is typically more
    difficult for the
    attacker.[¶](#section-a.1-5.2){.pilcrow}]{#section-a.1-5.2}

Unfortunately HPKP has not seen wide deployment yet. As of March 2016,
the number of servers using HPKP was less than 3000
\[[Netcraft](#Netcraft){.xref}\]. This may simply be due to inertia, but
we believe the main reason is the interactions between HPKP and manual
certificate management that is needed to implement HPKP for enterprise
servers. The penalty for making mistakes (e.g., being too early or too
late to deploy new pins) is that the server becomes unusable for some of
the clients.[¶](#section-a.1-6){.pilcrow}

To demonstrate this point, we present a list of the steps involved in
deploying HPKP on a security-sensitive web
server.[¶](#section-a.1-7){.pilcrow}

1.  ::: {#section-a.1-8.1}
    Generate two public/private key pairs on a computer that is not the
    live server. The second one is the \"backup1\" key
    pair.[¶](#section-a.1-8.1.1){.pilcrow}

    ::: {#section-a.1-8.1.2}
    ``` {.sourcecode .lang-bash}
    openssl genrsa -out "example.com.key" 2048;

    openssl genrsa -out "example.com.backup1.key" 2048;
    ```

    [¶](#section-a.1-8.1.2){.pilcrow}
    :::
    :::

2.  ::: {#section-a.1-8.2}
    Generate hashes for both of the public keys. These will be used in
    the HPKP header:[¶](#section-a.1-8.2.1){.pilcrow}

    ::: {#section-a.1-8.2.2}
    ``` {.sourcecode .lang-bash}
    openssl rsa -in "example.com.key" -outform der -pubout | \
    openssl dgst -sha256 -binary | openssl enc -base64  

    openssl rsa -in "example.com.backup1.key" -outform der \
    -pubout | openssl dgst -sha256 -binary | openssl enc -base64
    ```

    [¶](#section-a.1-8.2.2){.pilcrow}
    :::
    :::

3.  ::: {#section-a.1-8.3}
    Generate a single CSR (Certificate Signing Request) for the first
    key pair, where you include the domain name in the CN (Common Name)
    field:[¶](#section-a.1-8.3.1){.pilcrow}

    ::: {#section-a.1-8.3.2}
    ``` {.sourcecode .lang-bash}
    openssl req -new -subj "/C=GB/ST=Area/L=Town/O=Org/ \
    CN=example.com" -key "example.com.key" -out "example.com.csr"; 
    ```

    [¶](#section-a.1-8.3.2){.pilcrow}
    :::
    :::

4.  [Send this CSR to the CA and go though the dance to prove you own
    the domain. The CA will give you a single certificate that will
    typically expire within a year or
    two.[¶](#section-a.1-8.4){.pilcrow}]{#section-a.1-8.4}

5.  ::: {#section-a.1-8.5}
    On the live server, upload and set up the first key pair and its
    certificate. At this point, you can add the \"Public-Key-Pins\"
    header, using the two hashes you created in step
    2.[¶](#section-a.1-8.5.1){.pilcrow}

    Note that only the first key pair has been uploaded to the server so
    far.[¶](#section-a.1-8.5.2){.pilcrow}
    :::

6.  [Store the second (backup1) key pair somewhere safe, probably
    somewhere encrypted like a password manager. It won\'t expire, as
    it\'s just a key pair; it just needs to be ready for when you need
    to get your next
    certificate.[¶](#section-a.1-8.6){.pilcrow}]{#section-a.1-8.6}

7.  [Time passes \-- probably just under a year (if waiting for a
    certificate to expire), or maybe sooner if you find that your server
    has been compromised, and you need to replace the key pair and
    certificate.[¶](#section-a.1-8.7){.pilcrow}]{#section-a.1-8.7}

8.  [Create a new CSR using the \"backup1\" key pair, and get a new
    certificate from your
    CA.[¶](#section-a.1-8.8){.pilcrow}]{#section-a.1-8.8}

9.  [Generate a new backup key pair (backup2), get its hash, and store
    it in a safe place (again, not on the live
    server).[¶](#section-a.1-8.9){.pilcrow}]{#section-a.1-8.9}

10. [Replace your old certificate and old key pair, update the
    \"Public-Key-Pins\" header to remove the old hash, and add the new
    \"backup2\" key
    pair.[¶](#section-a.1-8.10){.pilcrow}]{#section-a.1-8.10}

Note that in the above steps, both the certificate issuance as well as
the storage of the backup key pair involve manual steps. Even with an
automated CA that runs the ACME protocol \[[RFC8555](#RFC8555){.xref}\],
key backup would be a challenge to
automate.[¶](#section-a.1-9){.pilcrow}
:::
:::

::: {#tack}
::: {#section-a.2 .section}
## [A.2.](#section-a.2){.section-number .selfRef} [Comparison: TACK](#name-comparison-tack){.section-name .selfRef} {#name-comparison-tack}

Compared with HPKP, TACK \[[TLS-TACK](#I-D.perrin-tls-tack){.xref}\] is
more similar to the current document. It can even be argued that this
document is a symmetric-cryptography variant of TACK. That said, there
are still a few significant differences:[¶](#section-a.2-1){.pilcrow}

-   [Probably the most important difference is that with TACK,
    validation of the server certificate is no longer required, and in
    fact TACK specifies it as a \"[MAY]{.bcp14}\" requirement
    (\[[TLS-TACK](#I-D.perrin-tls-tack){.xref}\], [Section
    5.3](https://tools.ietf.org/html/draft-perrin-tls-tack-02#section-5.3){.relref}).
    With ticket pinning, certificate validation by the client remains a
    [MUST]{.bcp14} requirement, and the ticket acts only as a second
    factor. If the pinning secret is compromised, the server\'s security
    is not immediately at
    risk.[¶](#section-a.2-2.1){.pilcrow}]{#section-a.2-2.1}
-   [Both TACK and the current document are mostly orthogonal to the
    server certificate as far as their life cycle, and so both can be
    deployed with no manual
    steps.[¶](#section-a.2-2.2){.pilcrow}]{#section-a.2-2.2}
-   [TACK uses Elliptic Curve Digital Signature Algorithm (ECDSA) to
    sign the server\'s public key. This allows cooperating clients to
    share server assertions between themselves. This is an optional TACK
    feature, and one that cannot be done with pinning
    tickets.[¶](#section-a.2-2.3){.pilcrow}]{#section-a.2-2.3}
-   [TACK allows multiple servers to share its public keys. Such sharing
    is disallowed by the current
    document.[¶](#section-a.2-2.4){.pilcrow}]{#section-a.2-2.4}
-   [TACK does not allow the server to track a particular client, and so
    has better privacy properties than the current
    document.[¶](#section-a.2-2.5){.pilcrow}]{#section-a.2-2.5}
-   [TACK has an interesting way to determine the pin\'s lifetime,
    setting it to the time period since the pin was first observed, with
    a hard upper bound of 30 days. The current document makes the
    lifetime explicit, which may be more flexible to deploy. For
    example, web sites that are only visited rarely by users may opt for
    a longer period than other sites that expect users to visit on a
    daily basis.[¶](#section-a.2-2.6){.pilcrow}]{#section-a.2-2.6}
:::
:::
:::
:::

::: {#acknowledgments}
::: {#section-appendix.b .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

The original idea behind this proposal was published in
\[[Oreo](#Oreo){.xref}\] by Moti Yung, Benny Pinkas, and Omer Berkman.
The current protocol is but a distant relative of the original Oreo
protocol, and any errors are the responsibility of the authors of this
document alone.[¶](#section-appendix.b-1){.pilcrow}

We would like to thank Adrian Farrel, Dave Garrett, Daniel Kahn Gillmor,
Alexey Melnikov, Yoav Nir, Eric Rescorla, Benjamin Kaduk, and Rich Salz
for their comments on this document. Special thanks to Craig Francis for
contributing the HPKP deployment script, and to Ralph Holz for several
fruitful discussions.[¶](#section-appendix.b-2){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.c .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Yaron Sheffer]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Intuit]{.org}
:::

::: email
Email: <yaronf.ietf@gmail.com>
:::

::: {.left dir="auto"}
[Daniel Migault]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Ericsson]{.org}
:::

::: email
Email: <daniel.migault@ericsson.com>
:::
:::
:::
