  RFC 8699        Coupled Congestion Control for RTP Media   January 2020
  --------------- ------------------------------------------ --------------
  Islam, et al.   Experimental                               \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8699](https://www.rfc-editor.org/rfc/rfc8699){.eref}

Category:
:   Experimental

Published:
:   January 2020

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    S. Islam
    :::

    ::: org
    University of Oslo
    :::
    :::

    ::: author
    ::: author-name
    M. Welzl
    :::

    ::: org
    University of Oslo
    :::
    :::

    ::: author
    ::: author-name
    S. Gjessing
    :::

    ::: org
    University of Oslo
    :::
    :::
:::

# RFC 8699 {#rfcnum}

# Coupled Congestion Control for RTP Media {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

When multiple congestion-controlled Real-time Transport Protocol (RTP)
sessions traverse the same network bottleneck, combining their controls
can improve the total on-the-wire behavior in terms of delay, loss, and
fairness. This document describes such a method for flows that have the
same sender, in a way that is as flexible and simple as possible while
minimizing the number of changes needed to existing RTP applications.
This document also specifies how to apply the method for the
Network-Assisted Dynamic Adaptation (NADA) congestion control algorithm
and provides suggestions on how to apply it to other congestion control
algorithms.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for examination, experimental implementation, and
evaluation.[¶](#section-boilerplate.1-1){.pilcrow}

This document defines an Experimental Protocol for the Internet
community. This document is a product of the Internet Engineering Task
Force (IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Not all documents approved
by the IESG are candidates for any level of Internet Standard; see
Section 2 of RFC 7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8699>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Definitions](#name-definitions){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Limitations](#name-limitations){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Architectural
    Overview](#name-architectural-overview){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Roles](#name-roles){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [SBD](#name-sbd){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [FSE](#name-fse){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Flows](#name-flows){.xref}[¶](#section-toc.1-1.5.2.3.1){.pilcrow}

        -   ::: {#section-toc.1-1.5.2.3.2.1}
            [5.3.1](#section-5.3.1){.xref}.  [Example Algorithm 1 -
            Active
            FSE](#name-example-algorithm-1-active-){.xref}[¶](#section-toc.1-1.5.2.3.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.2}
            [5.3.2](#section-5.3.2){.xref}.  [Example Algorithm 2 -
            Conservative Active
            FSE](#name-example-algorithm-2-conserv){.xref}[¶](#section-toc.1-1.5.2.3.2.2.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Application](#name-application){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [NADA](#name-nada){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [General
        Recommendations](#name-general-recommendations){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Expected Feedback from
    Experiments](#name-expected-feedback-from-expe){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}

    -   ::: {#section-toc.1-1.10.2.1}
        [10.1](#section-10.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.10.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [10.2](#section-10.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.10.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [Appendix A](#section-appendix.a){.xref}.  [Application to
    GCC](#name-application-to-gcc){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.12}
    [Appendix
    B](#section-appendix.b){.xref}.  [Scheduling](#name-scheduling){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.13}
    [Appendix C](#section-appendix.c){.xref}.  [Example Algorithm -
    Passive
    FSE](#name-example-algorithm-passive-f){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}

    -   ::: {#section-toc.1-1.13.2.1}
        [C.1](#section-c.1){.xref}.  [Example Operation
        (Passive)](#name-example-operation-passive){.xref}[¶](#section-toc.1-1.13.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.14}
    [](#section-appendix.d){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.15}
    [](#section-appendix.e){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.15.1){.pilcrow}
    :::
:::
:::

::: {#sec-intro}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

When there is enough data to send, a congestion controller attempts to
increase its sending rate until the path\'s capacity has been reached.
Some controllers detect path capacity by increasing the sending rate
further, until packets are ECN-marked \[[RFC8087](#RFC8087){.xref}\] or
dropped, and then decreasing the sending rate until that stops
happening. This process inevitably creates undesirable queuing delay
when multiple congestion-controlled connections traverse the same
network bottleneck, and each connection overshoots the path capacity as
it determines its sending rate.[¶](#section-1-1){.pilcrow}

The Congestion Manager (CM) \[[RFC3124](#RFC3124){.xref}\] couples flows
by providing a single congestion controller. It is hard to implement
because it requires an additional congestion controller and removes all
per-connection congestion control functionality, which is quite a
significant change to existing RTP-based applications. This document
presents a method to combine the behavior of congestion control
mechanisms that is easier to implement than the Congestion Manager
\[[RFC3124](#RFC3124){.xref}\] and also requires fewer significant
changes to existing RTP-based applications. It attempts to roughly
approximate the CM behavior by sharing information between existing
congestion controllers. It is able to honor user-specified priorities,
which is required by WebRTC
\[[RTCWEB-OVERVIEW](#I-D.ietf-rtcweb-overview){.xref}\]
\[[RFC7478](#RFC7478){.xref}\].[¶](#section-1-2){.pilcrow}

The described mechanisms are believed safe to use, but they are
experimental and are presented for wider review and operational
evaluation.[¶](#section-1-3){.pilcrow}
:::
:::

::: {#sec-def}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Definitions](#name-definitions){.section-name .selfRef} {#name-definitions}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}

Available Bandwidth:
:   The available bandwidth is the nominal link capacity minus the
    amount of traffic that traversed the link during a certain time
    interval, divided by that time
    interval.[¶](#section-2-2.2){.pilcrow}

Bottleneck:
:   The first link with the smallest available bandwidth along the path
    between a sender and receiver.[¶](#section-2-2.4){.pilcrow}

Flow:
:   A flow is the entity that congestion control is operating on. It
    could, for example, be a transport-layer connection or an RTP stream
    \[[RFC7656](#RFC7656){.xref}\], regardless of whether or not this
    RTP stream is multiplexed onto an RTP session with other RTP
    streams.[¶](#section-2-2.6){.pilcrow}

Flow Group Identifier (FGI):
:   A unique identifier for each subset of flows that is limited by a
    common bottleneck.[¶](#section-2-2.8){.pilcrow}

Flow State Exchange (FSE):
:   The entity that maintains information that is exchanged between
    flows.[¶](#section-2-2.10){.pilcrow}

Flow Group (FG):
:   A group of flows having the same FGI.[¶](#section-2-2.12){.pilcrow}

Shared Bottleneck Detection (SBD):
:   The entity that determines which flows traverse the same bottleneck
    in the network or the process of doing
    so.[¶](#section-2-2.14){.pilcrow}
:::
:::

::: {#sec-limits}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Limitations](#name-limitations){.section-name .selfRef} {#name-limitations}

Sender-side only:
:   Shared bottlenecks can exist when multiple flows originate from the
    same sender or when flows from different senders reach the same
    receiver (see [Section
    3](https://www.rfc-editor.org/rfc/rfc8382#section-3){.relref} of
    \[[RFC8382](#RFC8382){.xref}\]). Coupled congestion control, as
    described here, only supports the former case, not the latter, as it
    operates inside a single host on the sender
    side.[¶](#section-3-1.2){.pilcrow}

Shared bottlenecks do not change quickly:
:   As per the definition above, a bottleneck depends on cross traffic,
    and since such traffic can heavily fluctuate, bottlenecks can change
    at a high frequency (e.g., there can be oscillation between two or
    more links). This means that, when flows are partially routed along
    different paths, they may quickly change between sharing and not
    sharing a bottleneck. For simplicity, here it is assumed that a
    shared bottleneck is valid for a time interval that is significantly
    longer than the interval at which congestion controllers operate.
    Note that, for the only SBD mechanism defined in this document
    (multiplexing on the same five-tuple), the notion of a shared
    bottleneck stays correct even in the presence of fast traffic
    fluctuations; since all flows that are assumed to share a bottleneck
    are routed in the same way, if the bottleneck changes, it will still
    be shared.[¶](#section-3-1.4){.pilcrow}
:::
:::

::: {#sec-arch}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Architectural Overview](#name-architectural-overview){.section-name .selfRef} {#name-architectural-overview}

[Figure 1](#fig_1){.xref} shows the elements of the architecture for
coupled congestion control: the Flow State Exchange (FSE), Shared
Bottleneck Detection (SBD), and Flows. The FSE is a storage element that
can be implemented in two ways: active and passive. In the active
version, it initiates communication with flows and SBD. However, in the
passive version, it does not actively initiate communication with flows
and SBD; its only active role is internal state maintenance (e.g., an
implementation could use soft state to remove a flow\'s data after long
periods of inactivity). Every time a flow\'s congestion control
mechanism would normally update its sending rate, the flow instead
updates information in the FSE and performs a query on the FSE, leading
to a sending rate that can be different from what the congestion
controller originally determined. Using information about/from the
currently active flows, SBD updates the FSE with the correct Flow Group
Identifiers (FGIs).[¶](#section-4-1){.pilcrow}

This document describes both active and passive versions. While the
passive algorithm works better for congestion controls with
RTT-independent convergence, it can still produce oscillations on short
time scales. The passive algorithm, described in [Appendix
C](#example-alg-pas){.xref}, is therefore considered highly experimental
and not safe to deploy outside of testbed environments. [Figure
2](#fig_2){.xref} shows the interaction between flows and the FSE using
the variable names defined in [Section
5.2](#fse-variables){.xref}.[¶](#section-4-2){.pilcrow}

[]{#name-coupled-congestion-control-}

::: {#fig_1}
::: {#section-4-3.1 .artwork .art-text .alignCenter}
    -------  <---  Flow 1
    | FSE |  <---  Flow 2 ..
    -------  <---  .. Flow N
       ^
       |             |
    -------          |
    | SBD |  <-------|
    -------         
:::

[Figure 1](#figure-1){.selfRef}: [Coupled congestion control
architecture](#name-coupled-congestion-control-){.selfRef}
:::

[]{#name-flow-fse-interactions}

::: {#fig_2}
::: {#section-4-4.1 .artwork .art-text .alignCenter}
    Flow#1(cc)                     FSE                    Flow#2(cc)
    ----------                     ---                    ----------
    #1 JOIN     ----register--> REGISTER

                                REGISTER    <--register-- JOIN #1

    #2 CC_R(1)  ----UPDATE----> UPDATE (in)

    #3 NEW RATE <---FSE_R(1)-- UPDATE (out) --FSE_R(2)-> #3 NEW RATE
              
:::

[Figure 2](#figure-2){.selfRef}: [Flow-FSE
interactions](#name-flow-fse-interactions){.selfRef}
:::

Since everything shown in [Figure 1](#fig_1){.xref} is assumed to
operate on a single host (the sender) only, this document only describes
aspects that have an influence on the resulting on-the-wire behavior. It
does not, for instance, define how many bits must be used to represent
FGIs or in which way the entities
communicate.[¶](#section-4-5){.pilcrow}

Implementations can take various forms; for instance, all the elements
in the figure could be implemented within a single application, thereby
operating on flows generated by that application only. Another
alternative could be to implement both the FSE and SBD together in a
separate process that different applications communicate with via some
form of Inter-Process Communication (IPC). Such an implementation would
extend the scope to flows generated by multiple applications. The FSE
and SBD could also be included in the Operating System kernel. However,
only one type of coupling algorithm should be used for all flows.
Combinations of multiple algorithms at different aggregation levels
(e.g., the Operating System coupling application aggregates with one
algorithm, and applications coupling their flows with another) have not
been tested and are therefore not
recommended.[¶](#section-4-6){.pilcrow}
:::
:::

::: {#roles}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Roles](#name-roles){.section-name .selfRef} {#name-roles}

This section gives an overview of the roles of the elements of coupled
congestion control and provides an example of how coupled congestion
control can operate.[¶](#section-5-1){.pilcrow}

::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [SBD](#name-sbd){.section-name .selfRef} {#name-sbd}

SBD uses knowledge about the flows to determine which flows belong in
the same Flow Group (FG) and assigns FGIs accordingly. This knowledge
can be derived in three basic ways:[¶](#section-5.1-1){.pilcrow}

1.  [From multiplexing: It can be based on the simple assumption that
    packets sharing the same five-tuple (IP source and destination
    address, protocol, and transport-layer port number pair) and having
    the same values for the Differentiated Services Code Point (DSCP)
    and the ECN field in the IP header are typically treated in the same
    way along the path. This method is the only one specified in this
    document; SBD [MAY]{.bcp14} consider all flows that use the same
    five-tuple, DSCP, and ECN field value to belong to the same FG. This
    classification applies to certain tunnels or RTP flows that are
    multiplexed over one transport (cf.
    \[[TRANSPORT-MULTIPLEX](#TRANSPORT-MULTIPLEX){.xref}\]). Such
    multiplexing is also a recommended usage of RTP in WebRTC
    \[[RTCWEB-RTP-USAGE](#I-D.ietf-rtcweb-rtp-usage){.xref}\].[¶](#section-5.1-2.1){.pilcrow}]{#section-5.1-2.1}
2.  [Via configuration: e.g., by assuming that a common wireless uplink
    is also a shared
    bottleneck.[¶](#section-5.1-2.2){.pilcrow}]{#section-5.1-2.2}
3.  [From measurements: e.g., by considering correlations among measured
    delay and loss as an indication of a shared
    bottleneck.[¶](#section-5.1-2.3){.pilcrow}]{#section-5.1-2.3}

The methods above have some essential trade-offs. For example,
multiplexing is a completely reliable measure, but it is limited in
scope to two endpoints (i.e., it cannot be applied to couple congestion
controllers of one sender talking to multiple receivers). A
measurement-based SBD mechanism is described in
\[[RFC8382](#RFC8382){.xref}\]. Measurements can never be 100% reliable,
in particular because they are based on the past, but applying coupled
congestion control involves making an assumption about the future; it is
therefore recommended to implement cautionary measures, e.g., by
disabling coupled congestion control if enabling it causes a significant
increase in delay and/or packet loss. Measurements also take time, which
entails a certain delay for turning on coupling (refer to
\[[RFC8382](#RFC8382){.xref}\] for details). When this is possible, it
can be more efficient to statically configure shared bottlenecks (e.g.,
via a system configuration or user input) based on assumptions about the
network environment.[¶](#section-5.1-3){.pilcrow}
:::

::: {#fse-variables}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [FSE](#name-fse){.section-name .selfRef} {#name-fse}

The FSE contains a list of all flows that have registered with it. For
each flow, the FSE stores the following:[¶](#section-5.2-1){.pilcrow}

-   [a unique flow number f to identify the
    flow.[¶](#section-5.2-2.1){.pilcrow}]{#section-5.2-2.1}
-   [the FGI of the FG that it belongs to (based on the definitions in
    this document, a flow has only one bottleneck and can therefore be
    in only one FG).[¶](#section-5.2-2.2){.pilcrow}]{#section-5.2-2.2}
-   [a priority P(f), which is a number greater than
    zero.[¶](#section-5.2-2.3){.pilcrow}]{#section-5.2-2.3}
-   [The rate used by the flow in bits per second,
    FSE_R(f).[¶](#section-5.2-2.4){.pilcrow}]{#section-5.2-2.4}
-   [The desired rate DR(f) of flow f. This can be smaller than FSE_R(f)
    if the application feeding into the flow has less data to send than
    FSE_R(f) would allow or if a maximum value is imposed on the rate.
    In the absence of such limits, DR(f) must be set to the sending rate
    provided by the congestion control module of flow
    f.[¶](#section-5.2-2.5){.pilcrow}]{#section-5.2-2.5}

Note that the absolute range of priorities does not matter; the
algorithm works with a flow\'s priority portion of the sum of all
priority values. For example, if there are two flows, flow 1 with
priority 1 and flow 2 with priority 2, the sum of the priorities is 3.
Then, flow 1 will be assigned 1/3 of the aggregate sending rate, and
flow 2 will be assigned 2/3 of the aggregate sending rate. Priorities
can be mapped to the \"very-low\", \"low\", \"medium\", or \"high\"
priority levels described in
\[[WEBRTC-TRANS](#I-D.ietf-rtcweb-transports){.xref}\] by simply using
the values 1, 2, 4, and 8, respectively.[¶](#section-5.2-3){.pilcrow}

In the FSE, each FG contains one static variable, S_CR, which is the sum
of the calculated rates of all flows in the same FG. This value is used
to calculate the sending rate.[¶](#section-5.2-4){.pilcrow}

The information listed here is enough to implement the sample flow
algorithm given below. FSE implementations could easily be extended to
store, e.g., a flow\'s current sending rate for statistics gathering or
future potential optimizations.[¶](#section-5.2-5){.pilcrow}
:::
:::

::: {#flows}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Flows](#name-flows){.section-name .selfRef} {#name-flows}

Flows register themselves with SBD and FSE when they start, deregister
from the FSE when they stop, and carry out an UPDATE function call every
time their congestion controller calculates a new sending rate. Via
UPDATE, they provide the newly calculated rate and, optionally (if the
algorithm supports it), the desired rate. The desired rate is less than
the calculated rate in case of application-limited flows; otherwise, it
is the same as the calculated rate.[¶](#section-5.3-1){.pilcrow}

Below, two example algorithms are described. While other algorithms
could be used instead, the same algorithm must be applied to all flows.
Names of variables used in the algorithms are explained
below.[¶](#section-5.3-2){.pilcrow}

CC_R(f)
:   The rate received from the congestion controller of flow f when it
    calls UPDATE.[¶](#section-5.3-3.2){.pilcrow}

FSE_R(f)
:   The rate calculated by the FSE for flow
    f.[¶](#section-5.3-3.4){.pilcrow}

DR(f)
:   The desired rate of flow f.[¶](#section-5.3-3.6){.pilcrow}

S_CR
:   The sum of the calculated rates of all flows in the same FG; this
    value is used to calculate the sending
    rate.[¶](#section-5.3-3.8){.pilcrow}

FG
:   A group of flows having the same FGI and hence, sharing the same
    bottleneck.[¶](#section-5.3-3.10){.pilcrow}

P(f)
:   The priority of flow f, which is received from the flow\'s
    congestion controller; the FSE uses this variable for calculating
    FSE_R(f).[¶](#section-5.3-3.12){.pilcrow}

S_P
:   The sum of all the priorities.[¶](#section-5.3-3.14){.pilcrow}

TLO
:   The total leftover rate; the sum of rates that could not be assigned
    to flows that were limited by their desired
    rate.[¶](#section-5.3-3.16){.pilcrow}

AR
:   The aggregate rate that is assigned to flows that are not limited by
    their desired rate.[¶](#section-5.3-3.18){.pilcrow}

::: {#example-alg-act}
::: {#section-5.3.1 .section}
#### [5.3.1.](#section-5.3.1){.section-number .selfRef} [Example Algorithm 1 - Active FSE](#name-example-algorithm-1-active-){.section-name .selfRef} {#name-example-algorithm-1-active-}

This algorithm was designed to be the simplest possible method to assign
rates according to the priorities of flows. Simulation results in
\[[FSE](#FSE){.xref}\] indicate that it does not, however, significantly
reduce queuing delay and packet loss.[¶](#section-5.3.1-1){.pilcrow}

\(1\)
:   When a flow f starts, it registers itself with SBD and the FSE.
    FSE_R(f) is initialized with the congestion controller\'s initial
    rate. SBD will assign the correct FGI. When a flow is assigned an
    FGI, it adds its FSE_R(f) to S_CR.[¶](#section-5.3.1-2.1){.pilcrow}

\(2\)
:   When a flow f stops or pauses, its entry is removed from the
    list.[¶](#section-5.3.1-2.2){.pilcrow}

\(3\)

:   Every time the congestion controller of the flow f determines a new
    sending rate CC_R(f), the flow calls UPDATE, which carries out the
    tasks listed below to derive the new sending rates for all the flows
    in the FG. A flow\'s UPDATE function uses three local (i.e.,
    per-flow) temporary variables: S_P, TLO, and
    AR.[¶](#section-5.3.1-2.3.1){.pilcrow}

    \(a\)

    :   It updates S_CR.[¶](#section-5.3.1-2.3.2.1.1){.pilcrow}

        ::: {#section-5.3.1-2.3.2.1.2}
        ``` {.sourcecode .lang-pseudocode}
                    S_CR = S_CR + CC_R(f) - FSE_R(f)            
        ```

        [¶](#section-5.3.1-2.3.2.1.2){.pilcrow}
        :::

    \(b\)

    :   It calculates the sum of all the priorities, S_P, and
        initializes FSE_R.[¶](#section-5.3.1-2.3.2.2.1){.pilcrow}

        ::: {#section-5.3.1-2.3.2.2.2}
        ``` {.sourcecode .lang-pseudocode}
                    S_P = 0
                    for all flows i in FG do
                        S_P = S_P + P(i)
                        FSE_R(i) = 0
                    end for            
        ```

        [¶](#section-5.3.1-2.3.2.2.2){.pilcrow}
        :::

    \(c\)

    :   It distributes S_CR among all flows, ensuring that each flow\'s
        desired rate is not
        exceeded.[¶](#section-5.3.1-2.3.2.3.1){.pilcrow}

        ::: {#section-5.3.1-2.3.2.3.2}
        ``` {.sourcecode .lang-pseudocode}
                    TLO = S_CR
                    while(TLO-AR>0 and S_P>0)
                        AR = 0
                        for all flows i in FG do
                            if FSE_R[i] < DR[i] then
                                if TLO * P[i] / S_P >= DR[i] then
                                    TLO = TLO - DR[i]
                                    FSE_R[i] = DR[i]
                                    S_P = S_P - P[i]
                                else
                                    FSE_R[i] = TLO * P[i] / S_P
                                    AR = AR + TLO * P[i] / S_P
                                end if
                            end if
                        end for
                    end while            
        ```

        [¶](#section-5.3.1-2.3.2.3.2){.pilcrow}
        :::

    \(d\)

    :   It distributes FSE_R to all the
        flows.[¶](#section-5.3.1-2.3.2.4.1){.pilcrow}

        ::: {#section-5.3.1-2.3.2.4.2}
        ``` {.sourcecode .lang-pseudocode}
                    for all flows i in FG do
                        send FSE_R(i) to the flow i
                    end for            
        ```

        [¶](#section-5.3.1-2.3.2.4.2){.pilcrow}
        :::
:::
:::

::: {#example-alg-act-cons}
::: {#section-5.3.2 .section}
#### [5.3.2.](#section-5.3.2){.section-number .selfRef} [Example Algorithm 2 - Conservative Active FSE](#name-example-algorithm-2-conserv){.section-name .selfRef} {#name-example-algorithm-2-conserv}

This algorithm changes algorithm 1 to conservatively emulate the
behavior of a single flow by proportionally reducing the aggregate rate
on congestion. Simulation results in \[[FSE](#FSE){.xref}\] indicate
that it can significantly reduce queuing delay and packet
loss.[¶](#section-5.3.2-1){.pilcrow}

Step (a) of the UPDATE function is changed as described below. This also
introduces a local variable DELTA, which is used to calculate the
difference between CC_R(f) and the previously stored FSE_R(f). To
prevent flows from either ignoring congestion or overreacting, a timer
keeps them from changing their rates immediately after the common rate
reduction that follows a congestion event. This timer is set to two RTTs
of the flow that experienced congestion because it is assumed that a
congestion event can persist for up to one RTT of that flow, with
another RTT added to compensate for fluctuations in the measured RTT
value.[¶](#section-5.3.2-2){.pilcrow}

\(a\)

:   It updates S_CR based on DELTA.[¶](#section-5.3.2-3.1.1){.pilcrow}

    ::: {#section-5.3.2-3.1.2}
    ``` {.sourcecode .lang-pseudocode}
                if Timer has expired or was not set then
                  DELTA = CC_R(f) - FSE_R(f)
                  if DELTA < 0 then  // Reduce S_CR proportionally 
                    S_CR = S_CR * CC_R(f) / FSE_R(f)
                    Set Timer for 2 RTTs
                  else    
                    S_CR = S_CR + DELTA
                  end if
                 end if             
    ```

    [¶](#section-5.3.2-3.1.2){.pilcrow}
    :::
:::
:::
:::
:::
:::
:::

::: {#Application}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Application](#name-application){.section-name .selfRef} {#name-application}

This section specifies how the FSE can be applied to specific congestion
control mechanisms and makes general recommendations that facilitate
applying the FSE to future congestion
controls.[¶](#section-6-1){.pilcrow}

::: {#app-NADA}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [NADA](#name-nada){.section-name .selfRef} {#name-nada}

Network-Assisted Dynamic Adaptation (NADA)
\[[RFC8698](#RFC8698){.xref}\] is a congestion control scheme for
WebRTC. It calculates a reference rate r_ref upon receiving an
acknowledgment and then, based on the reference rate, calculates a video
target rate r_vin and a sending rate for the flows,
r_send.[¶](#section-6.1-1){.pilcrow}

When applying the FSE to NADA, the UPDATE function call described in
[Section 5.3](#flows){.xref} gives the FSE NADA\'s reference rate r_ref.
The recommended algorithm for NADA is the Active FSE in [Section
5.3.1](#example-alg-act){.xref}. In step 3 (d), when the FSE_R(i) is
\"sent\" to the flow i, r_ref (r_vin and r_send) of flow i is updated
with the value of FSE_R(i).[¶](#section-6.1-2){.pilcrow}
:::
:::

::: {#app-general}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [General Recommendations](#name-general-recommendations){.section-name .selfRef} {#name-general-recommendations}

This section provides general advice for applying the FSE to congestion
control mechanisms.[¶](#section-6.2-1){.pilcrow}

Receiver-side calculations:
:   When receiver-side calculations make assumptions about the rate of
    the sender, the calculations need to be synchronized, or the
    receiver needs to be updated accordingly. This applies to TCP
    Friendly Rate Control (TFRC) \[[RFC5348](#RFC5348){.xref}\], for
    example, where simulations showed somewhat less favorable results
    when using the FSE without a receiver-side change
    \[[FSE](#FSE){.xref}\].[¶](#section-6.2-2.2){.pilcrow}

Stateful algorithms:
:   When a congestion control algorithm is stateful (e.g., during the
    TCP slow start, congestion avoidance, or fast recovery phase), these
    states should be carefully considered such that the overall state of
    the aggregate flow is correct. This may require sharing more
    information in the UPDATE call.[¶](#section-6.2-2.4){.pilcrow}

Rate jumps:
:   The FSE-based coupling algorithms can let a flow quickly increase
    its rate to its fair share, e.g., when a new flow joins or after a
    quiescent period. In case of window-based congestion controls, this
    may produce a burst that should be mitigated in some way. An example
    of how this could be done without using a timer is presented in
    \[[ANRW2016](#ANRW2016){.xref}\], using TCP as an
    example.[¶](#section-6.2-2.6){.pilcrow}
:::
:::
:::
:::

::: {#expected-feedback}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Expected Feedback from Experiments](#name-expected-feedback-from-expe){.section-name .selfRef} {#name-expected-feedback-from-expe}

The algorithm described in this memo has so far been evaluated using
simulations covering all the tests for more than one flow from
\[[RMCAT-PROPOSALS](#I-D.ietf-rmcat-eval-test){.xref}\] (see
\[[IETF-93](#IETF-93){.xref}\] and \[[IETF-94](#IETF-94){.xref}\]).
Experiments should confirm these results using at least the NADA
congestion control algorithm with real-life code (e.g., browsers
communicating over an emulated network covering the conditions in
\[[RMCAT-PROPOSALS](#I-D.ietf-rmcat-eval-test){.xref}\]). The tests with
real-life code should be repeated afterwards in real network
environments and monitored. Experiments should investigate cases where
the media coder\'s output rate is below the rate that is calculated by
the coupling algorithm (FSE_R(i) in algorithms 1 ([Section
5.3.1](#example-alg-act){.xref}) and 2 ([Section
5.3.2](#example-alg-act-cons){.xref})). Implementers and testers are
invited to document their findings in an
Internet-Draft.[¶](#section-7-1){.pilcrow}
:::
:::

::: {#IANA}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-8-1){.pilcrow}
:::
:::

::: {#Security}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

In scenarios where the architecture described in this document is
applied across applications, various cheating possibilities arise, e.g.,
supporting wrong values for the calculated rate, desired rate, or
priority of a flow. In the worst case, such cheating could either
prevent other flows from sending or make them send at a rate that is
unreasonably large. The end result would be unfair behavior at the
network bottleneck, akin to what could be achieved with any UDP-based
application. Hence, since this is no worse than UDP in general, there
seems to be no significant harm in using this in the absence of UDP rate
limiters.[¶](#section-9-1){.pilcrow}

In the case of a single-user system, it should also be in the interest
of any application programmer to give the user the best possible
experience by using reasonable flow priorities or even letting the user
choose them. In a multi-user system, this interest may not be given, and
one could imagine the worst case of an \"arms race\" situation where
applications end up setting their priorities to the maximum value. If
all applications do this, the end result is a fair allocation in which
the priority mechanism is implicitly eliminated and no major harm is
done.[¶](#section-9-2){.pilcrow}

Implementers should also be aware of the Security Considerations
sections of \[[RFC3124](#RFC3124){.xref}\],
\[[RFC5348](#RFC5348){.xref}\], and
\[[RFC7478](#RFC7478){.xref}\].[¶](#section-9-3){.pilcrow}
:::
:::

::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-10.1 .section}
### [10.1.](#section-10.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.

\[RFC3124\]
:   [Balakrishnan, H.]{.refAuthor}[ and S. Seshan]{.refAuthor}, [\"The
    Congestion Manager\"]{.refTitle}, [RFC 3124]{.seriesInfo}, [DOI
    10.17487/RFC3124]{.seriesInfo}, June 2001,
    \<<https://www.rfc-editor.org/info/rfc3124>\>.

\[RFC5348\]
:   [Floyd, S.]{.refAuthor}[, Handley, M.]{.refAuthor}[,
    Padhye, J.]{.refAuthor}[, and J. Widmer]{.refAuthor}, [\"TCP
    Friendly Rate Control (TFRC): Protocol Specification\"]{.refTitle},
    [RFC 5348]{.seriesInfo}, [DOI 10.17487/RFC5348]{.seriesInfo},
    September 2008, \<<https://www.rfc-editor.org/info/rfc5348>\>.

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.

\[RFC8698\]
:   [Zhu, X.]{.refAuthor}[, Pan, R.]{.refAuthor}[,
    Ramalho, M.]{.refAuthor}[, and S. Mena]{.refAuthor},
    [\"Network-Assisted Dynamic Adaptation (NADA): A Unified Congestion
    Control Scheme for Real-Time Media\"]{.refTitle}, [RFC
    8698]{.seriesInfo}, [DOI 10.17487/RFC8698]{.seriesInfo}, January
    2020, \<<https://www.rfc-editor.org/info/rfc8698>\>.
:::

::: {#section-10.2 .section}
### [10.2.](#section-10.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[ANRW2016\]
:   [Islam, S.]{.refAuthor}[ and M. Welzl]{.refAuthor}, [\"Start Me Up:
    Determining and Sharing TCP\'s Initial Congestion
    Window\"]{.refTitle}, [ACM, IRTF, ISOC Applied Networking Research
    Workshop 2016 (ANRW 2016) ]{.refContent}, [DOI
    10.1145/2959424.2959440]{.seriesInfo}, [Proceedings of the 2016
    Applied Networking Research Workshop Pages 52-54]{.seriesInfo}, July
    2016, \<<https://doi.org/10.1145/2959424.2959440>\>.

\[FSE\]
:   [Islam, S.]{.refAuthor}[, Welzl, M.]{.refAuthor}[,
    Gjessing, S.]{.refAuthor}[, and N. Khademi]{.refAuthor}, [\"Coupled
    Congestion Control for RTP Media\"]{.refTitle}, [ACM SIGCOMM
    Capacity Sharing Workshop (CSWS 2014) and ACM SIGCOMM CCR 44(4) 2014
    ]{.refContent}, March 2014,
    \<<http://safiquli.at.ifi.uio.no/paper/fse-tech-report.pdf>\>.

\[FSE-NOMS\]
:   [Islam, S.]{.refAuthor}[, Welzl, M.]{.refAuthor}[,
    Hayes, D.]{.refAuthor}[, and S. Gjessing]{.refAuthor}, [\"Managing
    real-time media flows through a flow state exchange\"]{.refTitle},
    [IEEE NOMS 2016 ]{.refContent}, [DOI
    10.1109/NOMS.2016.7502803]{.seriesInfo},
    \<<https://doi.org/10.1109/NOMS.2016.7502803>\>.

\[GCC-RTCWEB\]
:   [Holmer, S.]{.refAuthor}[, Lundin, H.]{.refAuthor}[,
    Carlucci, G.]{.refAuthor}[, Cicco, L.]{.refAuthor}[, and S.
    Mascolo]{.refAuthor}, [\"A Google Congestion Control Algorithm for
    Real-Time Communication\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-rmcat-gcc-02]{.seriesInfo}, 8 July 2016,
    \<<https://tools.ietf.org/html/draft-ietf-rmcat-gcc-02>\>.

\[IETF-93\]
:   [Islam, S.]{.refAuthor}[, Welzl, M.]{.refAuthor}[, and S.
    Gjessing]{.refAuthor}, [\"Updates on \'Coupled Congestion Control
    for RTP Media\'\"]{.refTitle}, [RTP Media Congestion Avoidance
    Techniques (rmcat) Working Group]{.refContent}, [IETF
    93]{.seriesInfo}, July 2015,
    \<<https://www.ietf.org/proceedings/93/rmcat.html>\>.

\[IETF-94\]
:   [Islam, S.]{.refAuthor}[, Welzl, M.]{.refAuthor}[, and S.
    Gjessing]{.refAuthor}, [\"Updates on \'Coupled Congestion Control
    for RTP Media\'\"]{.refTitle}, [RTP Media Congestion Avoidance
    Techniques (rmcat) Working Group]{.refContent}, [IETF
    94]{.seriesInfo}, November 2015,
    \<<https://www.ietf.org/proceedings/94/rmcat.html>\>.

\[RFC7478\]
:   [Holmberg, C.]{.refAuthor}[, Hakansson, S.]{.refAuthor}[, and G.
    Eriksson]{.refAuthor}, [\"Web Real-Time Communication Use Cases and
    Requirements\"]{.refTitle}, [RFC 7478]{.seriesInfo}, [DOI
    10.17487/RFC7478]{.seriesInfo}, March 2015,
    \<<https://www.rfc-editor.org/info/rfc7478>\>.

\[RFC7656\]
:   [Lennox, J.]{.refAuthor}[, Gross, K.]{.refAuthor}[,
    Nandakumar, S.]{.refAuthor}[, Salgueiro, G.]{.refAuthor}[, and B.
    Burman, Ed.]{.refAuthor}, [\"A Taxonomy of Semantics and Mechanisms
    for Real-Time Transport Protocol (RTP) Sources\"]{.refTitle}, [RFC
    7656]{.seriesInfo}, [DOI 10.17487/RFC7656]{.seriesInfo}, November
    2015, \<<https://www.rfc-editor.org/info/rfc7656>\>.

\[RFC8087\]
:   [Fairhurst, G.]{.refAuthor}[ and M. Welzl]{.refAuthor}, [\"The
    Benefits of Using Explicit Congestion Notification
    (ECN)\"]{.refTitle}, [RFC 8087]{.seriesInfo}, [DOI
    10.17487/RFC8087]{.seriesInfo}, March 2017,
    \<<https://www.rfc-editor.org/info/rfc8087>\>.

\[RFC8382\]
:   [Hayes, D., Ed.]{.refAuthor}[, Ferlin, S.]{.refAuthor}[,
    Welzl, M.]{.refAuthor}[, and K. Hiorth]{.refAuthor}, [\"Shared
    Bottleneck Detection for Coupled Congestion Control for RTP
    Media\"]{.refTitle}, [RFC 8382]{.seriesInfo}, [DOI
    10.17487/RFC8382]{.seriesInfo}, June 2018,
    \<<https://www.rfc-editor.org/info/rfc8382>\>.

\[RMCAT-PROPOSALS\]
:   [Sarker, Z.]{.refAuthor}[, Singh, V.]{.refAuthor}[,
    Zhu, X.]{.refAuthor}[, and M. Ramalho]{.refAuthor}, [\"Test Cases
    for Evaluating RMCAT Proposals\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-rmcat-eval-test-10]{.seriesInfo}, 23 May 2019,
    \<<https://tools.ietf.org/html/draft-ietf-rmcat-eval-test-10>\>.

\[RTCWEB-OVERVIEW\]
:   [Alvestrand, H.]{.refAuthor}, [\"Overview: Real Time Protocols for
    Browser-based Applications\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-rtcweb-overview-19]{.seriesInfo}, 11 November 2017,
    \<<https://tools.ietf.org/html/draft-ietf-rtcweb-overview-19>\>.

\[RTCWEB-RTP-USAGE\]
:   [Perkins, C.]{.refAuthor}[, Westerlund, M.]{.refAuthor}[, and J.
    Ott]{.refAuthor}, [\"Web Real-Time Communication (WebRTC): Media
    Transport and Use of RTP\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-rtcweb-rtp-usage-26]{.seriesInfo}, 17 March 2016,
    \<<https://tools.ietf.org/html/draft-ietf-rtcweb-rtp-usage-26>\>.

\[TRANSPORT-MULTIPLEX\]
:   [Westerlund, M.]{.refAuthor}[ and C. Perkins]{.refAuthor},
    [\"Multiple RTP Sessions on a Single Lower-Layer
    Transport\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft,
    draft-westerlund-avtcore-transport-multiplexing-07]{.seriesInfo},
    October 2013,
    \<<https://tools.ietf.org/html/draft-westerlund-avtcore-transport-multiplexing-07>\>.

\[WEBRTC-TRANS\]
:   [Alvestrand, H.]{.refAuthor}, [\"Transports for
    WebRTC\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-rtcweb-transports-17]{.seriesInfo}, 26
    October 2016,
    \<<https://tools.ietf.org/html/draft-ietf-rtcweb-transports-17>\>.
:::
:::

::: {#app-GCC}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Application to GCC](#name-application-to-gcc){.section-name .selfRef} {#name-application-to-gcc}

Google Congestion Control (GCC)
\[[GCC-RTCWEB](#I-D.ietf-rmcat-gcc){.xref}\] is another congestion
control scheme for RTP flows that is under development. GCC is not yet
finalized, but at the time of this writing, the rate control of GCC
employs two parts: controlling the bandwidth estimate based on delay and
controlling the bandwidth estimate based on loss. Both are designed to
estimate the available bandwidth,
A_hat.[¶](#section-appendix.a-1){.pilcrow}

When applying the FSE to GCC, the UPDATE function call described in
[Section 5.3](#flows){.xref} gives the FSE GCC\'s estimate of available
bandwidth A_hat. The recommended algorithm for GCC is the Active FSE in
[Section 5.3.1](#example-alg-act){.xref}. In step 3 (d) of this
algorithm, when the FSE_R(i) is \"sent\" to the flow i, A_hat of flow i
is updated with the value of
FSE_R(i).[¶](#section-appendix.a-2){.pilcrow}
:::
:::

::: {#scheduling}
::: {#section-appendix.b .section}
## [Appendix B.](#section-appendix.b){.section-number .selfRef} [Scheduling](#name-scheduling){.section-name .selfRef} {#name-scheduling}

When flows originate from the same host, it would be possible to use
only one sender-side congestion controller that determines the overall
allowed sending rate and then use a local scheduler to assign a
proportion of this rate to each RTP session. This way, priorities could
also be implemented as a function of the scheduler. The Congestion
Manager (CM) \[[RFC3124](#RFC3124){.xref}\] also uses such a scheduling
function.[¶](#section-appendix.b-1){.pilcrow}
:::
:::

::: {#example-alg-pas}
::: {#section-appendix.c .section}
## [Appendix C.](#section-appendix.c){.section-number .selfRef} [Example Algorithm - Passive FSE](#name-example-algorithm-passive-f){.section-name .selfRef} {#name-example-algorithm-passive-f}

Active algorithms calculate the rates for all the flows in the FG and
actively distribute them. In a passive algorithm, UPDATE returns a rate
that should be used instead of the rate that the congestion controller
has determined. This can make a passive algorithm easier to implement;
however, when round-trip times of flows are unequal, flows with shorter
RTTs may (depending on the congestion control algorithm) update and
react to the overall FSE state more often than flows with longer RTTs,
which can produce unwanted side effects. This problem is more
significant when the congestion control convergence depends on the RTT.
While the passive algorithm works better for congestion controls with
RTT-independent convergence, it can still produce oscillations on short
time scales. The algorithm described below is therefore considered
highly experimental and not safe to deploy outside of testbed
environments. Results of a simplified passive FSE algorithm with both
NADA and GCC can be found in
\[[FSE-NOMS](#FSE-NOMS){.xref}\].[¶](#section-appendix.c-1){.pilcrow}

In the passive version of the FSE, TLO (Total Leftover Rate) is a static
variable per FG that is initialized to 0. Additionally, S_CR is limited
to increase or decrease as conservatively as a flow\'s congestion
controller decides in order to prohibit sudden rate
jumps.[¶](#section-appendix.c-2){.pilcrow}

\(1\)
:   When a flow f starts, it registers itself with SBD and the FSE.
    FSE_R(f) and DR(f) are initialized with the congestion controller\'s
    initial rate. SBD will assign the correct FGI. When a flow is
    assigned an FGI, it adds its FSE_R(f) to
    S_CR.[¶](#section-appendix.c-3.1){.pilcrow}

\(2\)
:   When a flow f stops or pauses, it sets its DR(f) to 0 and sets P(f)
    to -1.[¶](#section-appendix.c-3.2){.pilcrow}

\(3\)

:   Every time the congestion controller of the flow f determines a new
    sending rate CC_R(f), assuming the flow\'s new desired rate
    new_DR(f) to be \"infinity\" in case of a bulk data transfer with an
    unknown maximum rate, the flow calls UPDATE, which carries out the
    tasks listed below to derive the flow\'s new sending rate, Rate(f).
    A flow\'s UPDATE function uses a few local (i.e., per-flow)
    temporary variables, which are all initialized to 0: DELTA,
    new_S\_CR, and S_P.[¶](#section-appendix.c-3.3.1){.pilcrow}

    \(a\)

    :   For all the flows in its FG (including itself), it calculates
        the sum of all the calculated rates, new_S\_CR. Then, it
        calculates DELTA: the difference between FSE_R(f) and
        CC_R(f).[¶](#section-appendix.c-3.3.2.1.1){.pilcrow}

        ::: {#section-appendix.c-3.3.2.1.2}
        ``` {.sourcecode .lang-pseudocode}
                  for all flows i in FG do
                      new_S_CR = new_S_CR + FSE_R(i)
                  end for
                  DELTA =  CC_R(f) - FSE_R(f)                  
        ```

        [¶](#section-appendix.c-3.3.2.1.2){.pilcrow}
        :::

    \(b\)

    :   It updates S_CR, FSE_R(f), and
        DR(f).[¶](#section-appendix.c-3.3.2.2.1){.pilcrow}

        ::: {#section-appendix.c-3.3.2.2.2}
        ``` {.sourcecode .lang-pseudocode}
                  FSE_R(f) = CC_R(f)
                  if DELTA > 0 then  // the flow's rate has increased
                      S_CR = S_CR + DELTA
                  else if DELTA < 0 then
                      S_CR = new_S_CR + DELTA
                  end if 
                  DR(f) = min(new_DR(f),FSE_R(f))                  
        ```

        [¶](#section-appendix.c-3.3.2.2.2){.pilcrow}
        :::

    \(c\)

    :   It calculates the leftover rate TLO, removes the terminated
        flows from the FSE, and calculates the sum of all the
        priorities, S_P.[¶](#section-appendix.c-3.3.2.3.1){.pilcrow}

        ::: {#section-appendix.c-3.3.2.3.2}
        ``` {.sourcecode .lang-pseudocode}
                    for all flows i in FG do
                       if P(i)<0 then
                          delete flow
                       else
                          S_P = S_P + P(i)
                       end if
                    end for
                    if DR(f) < FSE_R(f) then
                       TLO = TLO + (P(f)/S_P) * S_CR - DR(f))
                    end if                  
        ```

        [¶](#section-appendix.c-3.3.2.3.2){.pilcrow}
        :::

    \(d\)

    :   It calculates the sending rate,
        Rate(f).[¶](#section-appendix.c-3.3.2.4.1){.pilcrow}

        ::: {#section-appendix.c-3.3.2.4.2}
        ``` {.sourcecode .lang-pseudocode}
                    Rate(f) = min(new_DR(f), (P(f)*S_CR)/S_P + TLO)
                                  
                    if Rate(f) != new_DR(f) and TLO > 0 then
                        TLO = 0  // f has 'taken' TLO
                    end if                  
        ```

        [¶](#section-appendix.c-3.3.2.4.2){.pilcrow}
        :::

    \(e\)

    :   It updates DR(f) and FSE_R(f) with
        Rate(f).[¶](#section-appendix.c-3.3.2.5.1){.pilcrow}

        ::: {#section-appendix.c-3.3.2.5.2}
        ``` {.sourcecode .lang-pseudocode}
                    if Rate(f) > DR(f) then
                        DR(f) = Rate(f)
                    end if
                    FSE_R(f)  = Rate(f)                
        ```

        [¶](#section-appendix.c-3.3.2.5.2){.pilcrow}
        :::

The goals of the flow algorithm are to achieve prioritization, improve
network utilization in the face of application-limited flows, and impose
limits on the increase behavior such that the negative impact of
multiple flows trying to increase their rate together is minimized. It
does that by assigning a flow a sending rate that may not be what the
flow\'s congestion controller expected. It therefore builds on the
assumption that no significant inefficiencies arise from temporary
application-limited behavior or from quickly jumping to a rate that is
higher than the congestion controller intended. How problematic these
issues really are depends on the controllers in use and requires careful
per-controller experimentation. The coupled congestion control mechanism
described here also does not require all controllers to be equal;
effects of heterogeneous controllers, or homogeneous controllers being
in different states, are also subject to
experimentation.[¶](#section-appendix.c-4){.pilcrow}

This algorithm gives the leftover rate of application-limited flows to
the first flow that updates its sending rate, provided that this flow
needs it all (otherwise, its own leftover rate can be taken by the next
flow that updates its rate). Other policies could be applied, e.g., to
divide the leftover rate of a flow equally among all other flows in the
FGI.[¶](#section-appendix.c-5){.pilcrow}

::: {#example-op}
::: {#section-c.1 .section}
## [C.1.](#section-c.1){.section-number .selfRef} [Example Operation (Passive)](#name-example-operation-passive){.section-name .selfRef} {#name-example-operation-passive}

In order to illustrate the operation of the passive coupled congestion
control algorithm, this section presents a toy example of two flows that
use it. Let us assume that both flows traverse a common 10 Mbit/s
bottleneck and use a simplistic congestion controller that starts out
with 1 Mbit/s, increases its rate by 1 Mbit/s in the absence of
congestion, and decreases it by 2 Mbit/s in the presence of congestion.
For simplicity, flows are assumed to always operate in a round-robin
fashion. Rate numbers below without units are assumed to be in Mbit/s.
For illustration purposes, the actual sending rate is also shown for
every flow in FSE diagrams even though it is not really stored in the
FSE.[¶](#section-c.1-1){.pilcrow}

Flow #1 begins. It is a bulk data transfer and considers itself to have
top priority. This is the FSE after the flow algorithm\'s step
1:[¶](#section-c.1-2){.pilcrow}

::: {#section-c.1-3 .artwork .art-text .alignLeft}
    ----------------------------------------
    | # | FGI |  P  | FSE_R  |  DR  | Rate |
    |   |     |     |        |      |      |
    | 1 |  1  |  1  |   1    |   1  |   1  |
    ----------------------------------------
    S_CR = 1, TLO = 0                  

[¶](#section-c.1-3){.pilcrow}
:::

Its congestion controller gradually increases its rate. Eventually, at
some point, the FSE should look like this:[¶](#section-c.1-4){.pilcrow}

::: {#section-c.1-5 .artwork .art-text .alignLeft}
    -----------------------------------------
    | # | FGI |  P  |  FSE_R  |  DR  | Rate |
    |   |     |     |         |      |      |
    | 1 |  1  |  1  |   10    |  10  |  10  |
    -----------------------------------------
    S_CR = 10, TLO = 0    

[¶](#section-c.1-5){.pilcrow}
:::

Now, another flow joins. It is also a bulk data transfer and has a lower
priority (0.5):[¶](#section-c.1-6){.pilcrow}

::: {#section-c.1-7 .artwork .art-text .alignLeft}
    ------------------------------------------
    | # | FGI |   P   | FSE_R  |  DR  | Rate |
    |   |     |       |        |      |      |
    | 1 |  1  |   1   |   10   |  10  |  10  |
    | 2 |  1  |  0.5  |    1   |   1  |   1  |
    ------------------------------------------
    S_CR = 11, TLO = 0    

[¶](#section-c.1-7){.pilcrow}
:::

Now, assume that the first flow updates its rate to 8, because the total
sending rate of 11 exceeds the total capacity. Let us take a closer look
at what happens in step 3 of the flow
algorithm.[¶](#section-c.1-8){.pilcrow}

CC_R(1) = 8. new_DR(1) = infinity.[¶](#section-c.1-9){.pilcrow}

(3a)
:   new_S\_CR = 11; DELTA = 8 - 10 = -2.[¶](#section-c.1-10.1){.pilcrow}

(3b)
:   FSE_R(1) = 8. DELTA is negative, hence S_CR = 9; DR(1) =
    8[¶](#section-c.1-10.2){.pilcrow}

(3c)
:   S_P = 1.5.[¶](#section-c.1-10.3){.pilcrow}

(3d)
:   new sending rate Rate(1) = min(infinity, 1/1.5 \* 9 + 0) =
    6.[¶](#section-c.1-10.4){.pilcrow}

(3e)
:   FSE_R(1) = 6.[¶](#section-c.1-10.5){.pilcrow}

The resulting FSE looks as follows:[¶](#section-c.1-11){.pilcrow}

::: {#section-c.1-12 .artwork .art-text .alignLeft}
    -------------------------------------------
    | # | FGI |   P   |  FSE_R  |  DR  | Rate |
    |   |     |       |         |      |      |
    | 1 |  1  |   1   |    6    |   8  |   6  |
    | 2 |  1  |  0.5  |    1    |   1  |   1  |
    -------------------------------------------
    S_CR = 9, TLO = 0    

[¶](#section-c.1-12){.pilcrow}
:::

The effect is that flow #1 is sending with 6 Mbit/s instead of the 8
Mbit/s that the congestion controller derived. Let us now assume that
flow #2 updates its rate. Its congestion controller detects that the
network is not fully saturated (the actual total sending rate is 6+1=7)
and increases its rate.[¶](#section-c.1-13){.pilcrow}

CC_R(2) = 2. new_DR(2) = infinity.[¶](#section-c.1-14){.pilcrow}

(3a)
:   new_S\_CR = 7; DELTA = 2 - 1 = 1.[¶](#section-c.1-15.1){.pilcrow}

(3b)
:   FSE_R(2) = 2. DELTA is positive, hence S_CR = 9 + 1 = 10; DR(2) =
    2.[¶](#section-c.1-15.2){.pilcrow}

(3c)
:   S_P = 1.5.[¶](#section-c.1-15.3){.pilcrow}

(3d)
:   Rate(2) = min(infinity, 0.5/1.5 \* 10 + 0) =
    3.33.[¶](#section-c.1-15.4){.pilcrow}

(3e)
:   DR(2) = FSE_R(2) = 3.33.[¶](#section-c.1-15.5){.pilcrow}

The resulting FSE looks as follows:[¶](#section-c.1-16){.pilcrow}

::: {#section-c.1-17 .artwork .art-text .alignLeft}
    -------------------------------------------
    | # | FGI |   P   |  FSE_R  |  DR  | Rate |
    |   |     |       |         |      |      |
    | 1 |  1  |   1   |    6    |   8  |   6  |
    | 2 |  1  |  0.5  |   3.33  | 3.33 | 3.33 |
    -------------------------------------------
    S_CR = 10, TLO = 0    

[¶](#section-c.1-17){.pilcrow}
:::

The effect is that flow #2 is now sending with 3.33 Mbit/s, which is
close to half of the rate of flow #1 and leads to a total utilization of
6(#1) + 3.33(#2) = 9.33 Mbit/s. Flow #2\'s congestion controller has
increased its rate faster than the controller actually expected. Now,
flow #1 updates its rate. Its congestion controller detects that the
network is not fully saturated and increases its rate. Additionally, the
application feeding into flow #1 limits the flow\'s sending rate to at
most 2 Mbit/s.[¶](#section-c.1-18){.pilcrow}

CC_R(1) = 7. new_DR(1) = 2.[¶](#section-c.1-19){.pilcrow}

(3a)
:   new_S\_CR = 9.33; DELTA = 1.[¶](#section-c.1-20.1){.pilcrow}

(3b)
:   FSE_R(1) = 7, DELTA is positive, hence S_CR = 10 + 1 = 11; DR(1) =
    min(2, 7) = 2.[¶](#section-c.1-20.2){.pilcrow}

(3c)
:   S_P = 1.5; DR(1) \< FSE_R(1), hence TLO = 1/1.5 \* 11 - 2 =
    5.33.[¶](#section-c.1-20.3){.pilcrow}

(3d)
:   Rate(1) = min(2, 1/1.5 \* 11 + 5.33) =
    2.[¶](#section-c.1-20.4){.pilcrow}

(3e)
:   FSE_R(1) = 2.[¶](#section-c.1-20.5){.pilcrow}

The resulting FSE looks as follows:[¶](#section-c.1-21){.pilcrow}

::: {#section-c.1-22 .artwork .art-text .alignLeft}
    -------------------------------------------
    | # | FGI |   P   |  FSE_R  |  DR  | Rate |
    |   |     |       |         |      |      |
    | 1 |  1  |   1   |    2    |   2  |   2  |
    | 2 |  1  |  0.5  |   3.33  | 3.33 | 3.33 |
    -------------------------------------------
    S_CR = 11, TLO = 5.33                  

[¶](#section-c.1-22){.pilcrow}
:::

Now, the total rate of the two flows is 2 + 3.33 = 5.33 Mbit/s, i.e.,
the network is significantly underutilized due to the limitation of flow
#1. Flow #2 updates its rate. Its congestion controller detects that the
network is not fully saturated and increases its
rate.[¶](#section-c.1-23){.pilcrow}

CC_R(2) = 4.33. new_DR(2) = infinity.[¶](#section-c.1-24){.pilcrow}

(3a)
:   new_S\_CR = 5.33; DELTA = 1.[¶](#section-c.1-25.1){.pilcrow}

(3b)
:   FSE_R(2) = 4.33. DELTA is positive, hence S_CR = 12; DR(2) =
    4.33.[¶](#section-c.1-25.2){.pilcrow}

(3c)
:   S_P = 1.5.[¶](#section-c.1-25.3){.pilcrow}

(3d)
:   Rate(2) = min(infinity, 0.5/1.5 \* 12 + 5.33 ) =
    9.33.[¶](#section-c.1-25.4){.pilcrow}

(3e)
:   FSE_R(2) = 9.33, DR(2) = 9.33.[¶](#section-c.1-25.5){.pilcrow}

The resulting FSE looks as follows:[¶](#section-c.1-26){.pilcrow}

::: {#section-c.1-27 .artwork .art-text .alignLeft}
    -------------------------------------------
    | # | FGI |   P   |  FSE_R  |  DR  | Rate |
    |   |     |       |         |      |      |
    | 1 |  1  |   1   |    2    |   2  |   2  |
    | 2 |  1  |  0.5  |   9.33  | 9.33 | 9.33 |
    -------------------------------------------
    S_CR = 12, TLO = 0    

[¶](#section-c.1-27){.pilcrow}
:::

Now, the total rate of the two flows is 2 + 9.33 = 11.33 Mbit/s.
Finally, flow #1 terminates. It sets P(1) to -1 and DR(1) to 0. Let us
assume that it terminated late enough for flow #2 to still experience
the network in a congested state, i.e., flow #2 decreases its rate in
the next iteration.[¶](#section-c.1-28){.pilcrow}

CC_R(2) = 7.33. new_DR(2) = infinity.[¶](#section-c.1-29){.pilcrow}

(3a)
:   new_S\_CR = 11.33; DELTA = -2.[¶](#section-c.1-30.1){.pilcrow}

(3b)
:   FSE_R(2) = 7.33. DELTA is negative, hence S_CR = 9.33; DR(2) =
    7.33.[¶](#section-c.1-30.2){.pilcrow}

(3c)
:   Flow 1 has P(1) = -1, hence it is deleted from the FSE. S_P =
    0.5.[¶](#section-c.1-30.3){.pilcrow}

(3d)
:   Rate(2) = min(infinity, 0.5/0.5\*9.33 + 0) =
    9.33.[¶](#section-c.1-30.4){.pilcrow}

(3e)
:   FSE_R(2) = DR(2) = 9.33.[¶](#section-c.1-30.5){.pilcrow}

The resulting FSE looks as follows:[¶](#section-c.1-31){.pilcrow}

::: {#section-c.1-32 .artwork .art-text .alignLeft}
    -------------------------------------------
    | # | FGI |   P   |  FSE_R  |  DR  | Rate |
    |   |     |       |         |      |      |
    | 2 |  1  |  0.5  |   9.33  | 9.33 | 9.33 |
    -------------------------------------------
    S_CR = 9.33, TLO = 0        

[¶](#section-c.1-32){.pilcrow}
:::
:::
:::
:::
:::

::: {#Acknowledgements}
::: {#section-appendix.d .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

This document benefited from discussions with and feedback from [Andreas
Petlund]{.contact-name}, [Anna Brunstrom]{.contact-name}, [Colin
Perkins]{.contact-name}, [David Hayes]{.contact-name}, [David
Ros]{.contact-name} (who also gave the FSE its name), [Ingemar
Johansson]{.contact-name}, [Karen Nielsen]{.contact-name}, [Kristian
Hiorth]{.contact-name}, [Martin Stiemerling]{.contact-name}, [Mirja
Kühlewind]{.contact-name}, [Spencer Dawkins]{.contact-name}, [Varun
Singh]{.contact-name}, [Xiaoqing Zhu]{.contact-name}, and [Zaheduzzaman
Sarker]{.contact-name}. The authors would like to especially thank
[Xiaoqing Zhu]{.contact-name} and [Stefan Holmer]{.contact-name} for
helping with NADA and GCC, and [Anna Brunstrom]{.contact-name} as well
as [Julius Flohr]{.contact-name} for helping us correct the active
algorithm for the case of application-limited
flows.[¶](#section-appendix.d-1){.pilcrow}

This work was partially funded by the European Community under its
Seventh Framework Program through the Reducing Internet Transport
Latency (RITE) project (ICT-317700).[¶](#section-appendix.d-2){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.e .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Safiqul Islam]{.fn .nameRole}
:::

::: {.left dir="auto"}
[University of Oslo]{.org}
:::

::: {.left dir="auto"}
[PO Box 1080 Blindern]{.street-address}
:::

::: {.left dir="auto"}
[N-0316]{.postal-code} [Oslo]{.locality}
:::

::: {.left dir="auto"}
[Norway]{.country-name}
:::

::: tel
Phone: [+47 22 84 08 37](tel:+47%2022%2084%2008%2037){.tel}
:::

::: email
Email: <safiquli@ifi.uio.no>
:::

::: {.left dir="auto"}
[Michael Welzl]{.fn .nameRole}
:::

::: {.left dir="auto"}
[University of Oslo]{.org}
:::

::: {.left dir="auto"}
[PO Box 1080 Blindern]{.street-address}
:::

::: {.left dir="auto"}
[N-0316]{.postal-code} [Oslo]{.locality}
:::

::: {.left dir="auto"}
[Norway]{.country-name}
:::

::: tel
Phone: [+47 22 85 24 20](tel:+47%2022%2085%2024%2020){.tel}
:::

::: email
Email: <michawe@ifi.uio.no>
:::

::: {.left dir="auto"}
[Stein Gjessing]{.fn .nameRole}
:::

::: {.left dir="auto"}
[University of Oslo]{.org}
:::

::: {.left dir="auto"}
[PO Box 1080 Blindern]{.street-address}
:::

::: {.left dir="auto"}
[N-0316]{.postal-code} [Oslo]{.locality}
:::

::: {.left dir="auto"}
[Norway]{.country-name}
:::

::: tel
Phone: [+47 22 85 24 44](tel:+47%2022%2085%2024%2044){.tel}
:::

::: email
Email: <steing@ifi.uio.no>
:::
:::
:::
