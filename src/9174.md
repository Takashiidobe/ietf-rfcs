  RFC 9174        DTN TCPCLv4       January 2022
  --------------- ----------------- --------------
  Sipos, et al.   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9174](https://www.rfc-editor.org/rfc/rfc9174){.eref}

Category:
:   Standards Track

Published:
:   January 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    B. Sipos
    :::

    ::: org
    RKF Engineering
    :::
    :::

    ::: author
    ::: author-name
    M. Demmer
    :::
    :::

    ::: author
    ::: author-name
    J. Ott
    :::

    ::: org
    Technical University of Munich
    :::
    :::

    ::: author
    ::: author-name
    S. Perreault
    :::

    ::: org
    LogMeIn
    :::
    :::
:::

# RFC 9174 {#rfcnum}

# Delay-Tolerant Networking TCP Convergence-Layer Protocol Version 4 {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes a TCP convergence layer (TCPCL) for
Delay-Tolerant Networking (DTN). This version of the TCPCL protocol
resolves implementation issues in the earlier TCPCL version 3 as defined
in RFC 7242 and provides updates to the Bundle Protocol (BP) contents,
encodings, and convergence-layer requirements in BP version 7 (BPv7).
Specifically, TCPCLv4 uses BPv7 bundles encoded by the Concise Binary
Object Representation (CBOR) as its service data unit being transported
and provides a reliable transport of such bundles. This TCPCL version
also includes security and extensibility
mechanisms.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9174>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Scope](#name-scope){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Requirements
    Language](#name-requirements-language){.xref}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Definitions Specific to the TCPCL
        Protocol](#name-definitions-specific-to-the){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [General Protocol
    Description](#name-general-protocol-descriptio){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Convergence-Layer
        Services](#name-convergence-layer-services){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [TCPCL Session
        Overview](#name-tcpcl-session-overview){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [TCPCL States and
        Transitions](#name-tcpcl-states-and-transition){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [PKIX Environments and CA
        Policy](#name-pkix-environments-and-ca-po){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.5}
        [3.5](#section-3.5){.xref}.  [Session-Keeping
        Policies](#name-session-keeping-policies){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.6}
        [3.6](#section-3.6){.xref}.  [Transfer Segmentation
        Policies](#name-transfer-segmentation-polic){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.7}
        [3.7](#section-3.7){.xref}.  [Example Message
        Exchange](#name-example-message-exchange){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Session
    Establishment](#name-session-establishment){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [TCP
        Connection](#name-tcp-connection){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Contact
        Header](#name-contact-header){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Contact Validation and
        Negotiation](#name-contact-validation-and-nego){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Session
        Security](#name-session-security){.xref}

        -   ::: {#section-toc.1-1.4.2.4.2.1}
            [4.4.1](#section-4.4.1){.xref}.  [Entity
            Identification](#name-entity-identification){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.2}
            [4.4.2](#section-4.4.2){.xref}.  [Certificate Profile for
            the TCPCL](#name-certificate-profile-for-the){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.3}
            [4.4.3](#section-4.4.3){.xref}.  [TLS
            Handshake](#name-tls-handshake){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.4}
            [4.4.4](#section-4.4.4){.xref}.  [TLS
            Authentication](#name-tls-authentication){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.5}
            [4.4.5](#section-4.4.5){.xref}.  [Policy
            Recommendations](#name-policy-recommendations){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.4.2.6}
            [4.4.6](#section-4.4.6){.xref}.  [Example TLS
            Initiation](#name-example-tls-initiation){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [Message
        Header](#name-message-header){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.6}
        [4.6](#section-4.6){.xref}.  [Session Initialization Message
        (SESS_INIT)](#name-session-initialization-mess){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.7}
        [4.7](#section-4.7){.xref}.  [Session Parameter
        Negotiation](#name-session-parameter-negotiati){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.8}
        [4.8](#section-4.8){.xref}.  [Session Extension
        Items](#name-session-extension-items){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Established Session
    Operation](#name-established-session-operati){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Upkeep and Status
        Messages](#name-upkeep-and-status-messages){.xref}

        -   ::: {#section-toc.1-1.5.2.1.2.1}
            [5.1.1](#section-5.1.1){.xref}.  [Session Upkeep
            (KEEPALIVE)](#name-session-upkeep-keepalive){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.2}
            [5.1.2](#section-5.1.2){.xref}.  [Message Rejection
            (MSG_REJECT)](#name-message-rejection-msg_rejec){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Bundle
        Transfer](#name-bundle-transfer){.xref}

        -   ::: {#section-toc.1-1.5.2.2.2.1}
            [5.2.1](#section-5.2.1){.xref}.  [Bundle Transfer
            ID](#name-bundle-transfer-id){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.2}
            [5.2.2](#section-5.2.2){.xref}.  [Data Transmission
            (XFER_SEGMENT)](#name-data-transmission-xfer_segm){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.3}
            [5.2.3](#section-5.2.3){.xref}.  [Data Acknowledgments
            (XFER_ACK)](#name-data-acknowledgments-xfer_a){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.4}
            [5.2.4](#section-5.2.4){.xref}.  [Transfer Refusal
            (XFER_REFUSE)](#name-transfer-refusal-xfer_refus){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.5}
            [5.2.5](#section-5.2.5){.xref}.  [Transfer Extension
            Items](#name-transfer-extension-items){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Session
    Termination](#name-session-termination){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Session Termination Message
        (SESS_TERM)](#name-session-termination-message){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Idle Session
        Termination](#name-idle-session-termination){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Threat: Passive Leak of Node
        Data](#name-threat-passive-leak-of-node){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Threat: Passive Leak of Bundle
        Data](#name-threat-passive-leak-of-bund){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Threat: TCPCL Version
        Downgrade](#name-threat-tcpcl-version-downgr){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [Threat: Transport Security
        Stripping](#name-threat-transport-security-s){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.5}
        [7.5](#section-7.5){.xref}.  [Threat: Weak TLS
        Configurations](#name-threat-weak-tls-configurati){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.6}
        [7.6](#section-7.6){.xref}.  [Threat: Untrusted End-Entity
        Certificate](#name-threat-untrusted-end-entity){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.7}
        [7.7](#section-7.7){.xref}.  [Threat: Certificate Validation
        Vulnerabilities](#name-threat-certificate-validati){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.8}
        [7.8](#section-7.8){.xref}.  [Threat: Symmetric Key
        Limits](#name-threat-symmetric-key-limits){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.9}
        [7.9](#section-7.9){.xref}.  [Threat: BP Node
        Impersonation](#name-threat-bp-node-impersonatio){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.10}
        [7.10](#section-7.10){.xref}. [Threat: Denial of
        Service](#name-threat-denial-of-service){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.11}
        [7.11](#section-7.11){.xref}. [Mandatory-to-Implement
        TLS](#name-mandatory-to-implement-tls){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.12}
        [7.12](#section-7.12){.xref}. [Alternate Uses of
        TLS](#name-alternate-uses-of-tls){.xref}

        -   ::: {#section-toc.1-1.7.2.12.2.1}
            [7.12.1](#section-7.12.1){.xref}.  [TLS without
            Authentication](#name-tls-without-authentication){.xref}
            :::

        -   ::: {#section-toc.1-1.7.2.12.2.2}
            [7.12.2](#section-7.12.2){.xref}.  [Non-certificate TLS
            Use](#name-non-certificate-tls-use){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.7.2.13}
        [7.13](#section-7.13){.xref}. [Predictability of Transfer
        IDs](#name-predictability-of-transfer-){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Port
        Number](#name-port-number){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Protocol
        Versions](#name-protocol-versions){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [8.3](#section-8.3){.xref}.  [Session Extension
        Types](#name-session-extension-types){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.4}
        [8.4](#section-8.4){.xref}.  [Transfer Extension
        Types](#name-transfer-extension-types){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.5}
        [8.5](#section-8.5){.xref}.  [Message
        Types](#name-message-types){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.6}
        [8.6](#section-8.6){.xref}.  [XFER_REFUSE Reason
        Codes](#name-xfer_refuse-reason-codes-2){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.7}
        [8.7](#section-8.7){.xref}.  [SESS_TERM Reason
        Codes](#name-sess_term-reason-codes-2){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.8}
        [8.8](#section-8.8){.xref}.  [MSG_REJECT Reason
        Codes](#name-msg_reject-reason-codes-2){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.9}
        [8.9](#section-8.9){.xref}.  [Object Identifier for PKIX Module
        Identifier](#name-object-identifier-for-pkix-){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.10}
        [8.10](#section-8.10){.xref}. [Object Identifier for PKIX Other
        Name Forms](#name-object-identifier-for-pkix-o){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.11}
        [8.11](#section-8.11){.xref}. [Object Identifier for PKIX
        Extended Key Usage](#name-object-identifier-for-pkix-e){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [Appendix A](#appendix-A){.xref}.  [Significant Changes from RFC
    7242](#name-significant-changes-from-rf){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [Appendix B](#appendix-B){.xref}.  [ASN.1
    Module](#name-asn1-module){.xref}
    :::

-   ::: {#section-toc.1-1.12}
    [Appendix C](#appendix-C){.xref}.  [Example of the BundleEID Other
    Name Form](#name-example-of-the-bundleeid-ot){.xref}
    :::

-   ::: {#section-toc.1-1.13}
    [](#appendix-D){.xref}[Acknowledgments](#name-acknowledgments){.xref}
    :::

-   ::: {#section-toc.1-1.14}
    [](#appendix-E){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#sec-intro}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

This document describes the TCP convergence-layer protocol for
Delay-Tolerant Networking (DTN). DTN is an end-to-end architecture
providing communications in and/or through highly stressed environments,
including those with intermittent connectivity, long and/or variable
delays, and high bit error rates. More detailed descriptions of the
rationale and capabilities of these networks can be found in
\"[Delay-Tolerant Networking Architecture](#RFC4838){.xref}\"
\[[RFC4838](#RFC4838){.xref}\].[¶](#section-1-1){.pilcrow}

An important goal of the DTN architecture is to accommodate a wide range
of networking technologies and environments. The protocol used for DTN
communications is the Bundle Protocol version 7 (BPv7)
\[[RFC9171](#RFC9171){.xref}\], an application-layer protocol that is
used to construct a store-and-forward overlay network. BPv7 requires the
services of a \"convergence-layer adapter\" (CLA) to send and receive
bundles using the service of some \"native\" link, network, or Internet
protocol. This document describes one such convergence-layer adapter
that uses the well-known Transmission Control Protocol (TCP). This
convergence layer is referred to as TCP Convergence Layer version 4
(TCPCLv4). For the remainder of this
document,[¶](#section-1-2){.pilcrow}

-   [the abbreviation \"BP\" without the version suffix refers to
    BPv7.[¶](#section-1-3.1){.pilcrow}]{#section-1-3.1}
-   [the abbreviation \"TCPCL\" without the version suffix refers to
    TCPCLv4.[¶](#section-1-3.2){.pilcrow}]{#section-1-3.2}

The locations of the TCPCL and the Bundle Protocol in the Internet model
protocol stack (described in \[[RFC1122](#RFC1122){.xref}\]) are shown
in [Figure 1](#fig-tcpcl-ip-stack){.xref}. In particular, when BP is
using TCP as its bearer with the TCPCL as its convergence layer, both BP
and the TCPCL reside at the application layer of the Internet
model.[¶](#section-1-4){.pilcrow}

[]{#name-the-locations-of-the-bundle}

::: {#fig-tcpcl-ip-stack}
::: {#section-1-5.1 .alignCenter .art-ascii-art .art-text .artwork}
    +-------------------------+
    |     DTN Application     | -\
    +-------------------------|   |
    |  Bundle Protocol (BP)   |   -> Application Layer
    +-------------------------+   |
    | TCP Conv. Layer (TCPCL) |   |
    +-------------------------+   |
    |     TLS (optional)      | -/
    +-------------------------+
    |          TCP            | ---> Transport Layer
    +-------------------------+
    |       IPv4/IPv6         | ---> Network Layer
    +-------------------------+
    |   Link-Layer Protocol   | ---> Link Layer
    +-------------------------+
:::

[Figure 1](#figure-1){.selfRef}: [The Locations of the Bundle Protocol
and the TCP Convergence-Layer Protocol above the Internet Protocol
Stack](#name-the-locations-of-the-bundle){.selfRef}
:::

::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Scope](#name-scope){.section-name .selfRef} {#name-scope}

This document describes the format of the protocol data units passed
between entities participating in TCPCL communications. This document
does not address:[¶](#section-1.1-1){.pilcrow}

-   [The format of protocol data units of the Bundle Protocol, as those
    are defined elsewhere in \[[RFC9171](#RFC9171){.xref}\]. This
    includes the concept of bundle fragmentation or bundle
    encapsulation. The TCPCL transfers bundles as opaque data
    blocks.[¶](#section-1.1-2.1){.pilcrow}]{#section-1.1-2.1}
-   [Mechanisms for locating or identifying other bundle entities
    (peers) within a network or across an internet. The mapping of a
    node ID to a potential convergence layer (CL) protocol and network
    address is left to implementation and configuration of the BP Agent
    (BPA) and its various potential routing strategies, as is the
    mapping of a DNS name and/or address to a choice of an end-entity
    certificate to authenticate a node to its
    peers.[¶](#section-1.1-2.2){.pilcrow}]{#section-1.1-2.2}
-   [Logic for routing bundles along a path toward a bundle\'s endpoint.
    This CL protocol is involved only in transporting bundles between
    adjacent entities in a routing
    sequence.[¶](#section-1.1-2.3){.pilcrow}]{#section-1.1-2.3}
-   [Policies or mechanisms for issuing Public Key Infrastructure Using
    X.509 (PKIX) certificates; provisioning, deploying, or accessing
    certificates and private keys; deploying or accessing certificate
    revocation lists (CRLs); or configuring security parameters on an
    individual entity or across a
    network.[¶](#section-1.1-2.4){.pilcrow}]{#section-1.1-2.4}
-   [Uses of TLS that are not based on PKIX certificate authentication
    (see [Section 7.12.2](#sec-security-tlsnopki){.xref}) or in which
    authentication of both entities is not possible (see [Section
    7.12.1](#sec-security-tlsnoauth){.xref}).[¶](#section-1.1-2.5){.pilcrow}]{#section-1.1-2.5}

Any TCPCL implementation requires a BPA to perform those above-listed
functions in order to perform end-to-end bundle
delivery.[¶](#section-1.1-3){.pilcrow}
:::
:::
:::

::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Requirements Language](#name-requirements-language){.section-name .selfRef} {#name-requirements-language}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}

::: {#sec-term-defs}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Definitions Specific to the TCPCL Protocol](#name-definitions-specific-to-the){.section-name .selfRef} {#name-definitions-specific-to-the}

This section contains definitions specific to the TCPCL
protocol.[¶](#section-2.1-1){.pilcrow}

[]{.break}

Network Byte Order:
:   Here, \"network byte order\" means most significant byte first,
    a.k.a. big endian. All of the integer encodings in this protocol
    [SHALL]{.bcp14} be transmitted in network byte
    order.[¶](#section-2.1-2.2){.pilcrow}
:   

TCPCL Entity:

:   This is the notional TCPCL application that initiates TCPCL
    sessions. This design, implementation, configuration, and specific
    behavior of such an entity is outside of the scope of this document.
    However, the concept of an entity has utility within the scope of
    this document as the container and initiator of TCPCL sessions. The
    relationship between a TCPCL entity and TCPCL sessions is defined as
    follows:[¶](#section-2.1-2.4.1){.pilcrow}

    -   [A TCPCL entity [MAY]{.bcp14} actively initiate any number of
        TCPCL sessions and should do so whenever the entity is the
        initial transmitter of information to another entity in the
        network.[¶](#section-2.1-2.4.2.1){.pilcrow}]{#section-2.1-2.4.2.1}
    -   [A TCPCL entity [MAY]{.bcp14} support zero or more passive
        listening elements that listen for connection requests from
        other TCPCL entities operating on other entities in the
        network.[¶](#section-2.1-2.4.2.2){.pilcrow}]{#section-2.1-2.4.2.2}
    -   [A TCPCL entity [MAY]{.bcp14} passively initiate any number of
        TCPCL sessions from requests received by its passive listening
        element(s) if the entity uses such
        elements.[¶](#section-2.1-2.4.2.3){.pilcrow}]{#section-2.1-2.4.2.3}

    These relationships are illustrated in [Figure
    2](#fig-entity-session-relations){.xref}. For most TCPCL behavior
    within a session, the two entities are symmetric and there is no
    protocol distinction between them. Some specific behavior,
    particularly during session establishment, distinguishes between the
    active entity and the passive entity. For the remainder of this
    document, the term \"entity\" without the prefix \"TCPCL\" refers to
    a TCPCL entity.[¶](#section-2.1-2.4.3){.pilcrow}

:   

TCP Connection:
:   The term \"connection\" in this specification exclusively refers to
    a TCP connection and any and all behaviors, sessions, and other
    states associated with that TCP
    connection.[¶](#section-2.1-2.6){.pilcrow}
:   

TCPCL Session:
:   A TCPCL session (as opposed to a TCP connection) is a TCPCL
    communication relationship between two TCPCL entities. A TCPCL
    session operates within a single underlying TCP connection, and the
    lifetime of a TCPCL session is bound to the lifetime of that TCP
    connection. A TCPCL session is terminated when the TCP connection
    ends, due to either (1) one or both entities actively closing the
    TCP connection or (2) network errors causing a failure of the TCP
    connection. Within a single TCPCL session, there are two possible
    transfer streams: one in each direction, with one stream from each
    entity being the outbound stream and the other being the inbound
    stream (see [Figure 3](#fig-session-stream){.xref}). From the
    perspective of a TCPCL session, the two transfer streams do not
    logically interact with each other. The streams do operate over the
    same TCP connection and between the same BPAs, so there are logical
    relationships at those layers (message and bundle interleaving,
    respectively). For the remainder of this document, the term
    \"session\" without the prefix \"TCPCL\" refers to a TCPCL
    session.[¶](#section-2.1-2.8){.pilcrow}
:   

Session Parameters:
:   These are a set of values used to affect the operation of the TCPCL
    for a given session. The manner in which these parameters are
    conveyed to the bundle entity and thereby to the TCPCL is
    implementation dependent. However, the mechanism by which two
    entities exchange and negotiate the values to be used for a given
    session is described in [Section
    4.3](#sec-contact-negotiate){.xref}.[¶](#section-2.1-2.10){.pilcrow}
:   

Transfer Stream:
:   A transfer stream is a unidirectional user-data path within a TCPCL
    session. Transfers sent over a transfer stream are serialized,
    meaning that one transfer must complete its transmission prior to
    another transfer being started over the same transfer stream. At the
    stream layer, there is no logical relationship between transfers in
    that stream; it\'s only within the BPA that transfers are fully
    decoded as bundles. Each unidirectional stream has a single sender
    entity and a single receiver entity.[¶](#section-2.1-2.12){.pilcrow}
:   

Transfer:
:   This refers to the procedures and mechanisms for conveyance of an
    individual bundle from one node to another. Each transfer within the
    TCPCL is identified by a Transfer ID number, which is guaranteed to
    be unique only to a single direction within a single
    session.[¶](#section-2.1-2.14){.pilcrow}
:   

Transfer Segment:
:   A transfer segment is a subset of a transfer of user data being
    communicated over a transfer stream.[¶](#section-2.1-2.16){.pilcrow}
:   

Idle Session:
:   A TCPCL session is idle while there is no transmission in progress
    in either direction. While idle, the only messages being transmitted
    or received are KEEPALIVE messages.[¶](#section-2.1-2.18){.pilcrow}
:   

Live Session:
:   A TCPCL session is live while there is a transmission in progress in
    either direction.[¶](#section-2.1-2.20){.pilcrow}
:   

Reason Codes:
:   The TCPCL uses numeric codes to encode specific reasons for
    individual failure/error message
    types.[¶](#section-2.1-2.22){.pilcrow}
:   

The relationship between connections, sessions, and streams is shown in
[Figure 3](#fig-session-stream){.xref}.[¶](#section-2.1-3){.pilcrow}

[]{#name-the-relationships-between-t}

::: {#fig-entity-session-relations}
::: {#section-2.1-4.1 .alignCenter .art-ascii-art .art-text .artwork}
    +--------------------------------------------+
    |                 TCPCL Entity               |
    |                                            |      +----------------+
    |   +--------------------------------+       |      |                |-+
    |   | Actively Initiated Session #1  +------------->| Other          | |
    |   +--------------------------------+       |      | TCPCL Entity's | |
    |                  ...                       |      | Passive        | |
    |   +--------------------------------+       |      | Listener       | |
    |   | Actively Initiated Session #n  +------------->|                | |
    |   +--------------------------------+       |      +----------------+ |
    |                                            |       +-----------------+
    |      +---------------------------+         |
    |  +---| +---------------------------+       |      +----------------+
    |  |   | | Optional Passive          |       |      |                |-+
    |  |   +-| Listener(s)               +<-------------+                | |
    |  |     +---------------------------+       |      |                | |
    |  |                                         |      | Other          | |
    |  |    +---------------------------------+  |      | TCPCL Entity's | |
    |  +--->| Passively Initiated Session #1  +-------->| Active         | |
    |  |    +---------------------------------+  |      | Initiator(s)   | |
    |  |                                         |      |                | |
    |  |    +---------------------------------+  |      |                | |
    |  +--->| Passively Initiated Session #n  +-------->|                | |
    |       +---------------------------------+  |      +----------------+ |
    |                                            |       +-----------------+
    +--------------------------------------------+
:::

[Figure 2](#figure-2){.selfRef}: [The Relationships between TCPCL
Entities](#name-the-relationships-between-t){.selfRef}
:::

[]{#name-the-relationship-within-a-t}

::: {#fig-session-stream}
::: {#section-2.1-5.1 .alignCenter .art-ascii-art .art-text .artwork}
    +---------------------------+              +---------------------------+
    |    "Own" TCPCL Session    |              |   "Other" TCPCL Session   |
    |                           |              |                           |
    | +----------------------+  |              |  +----------------------+ |
    | |   TCP Connection     |  |              |  |    TCP Connection    | |
    | |                      |  |              |  |                      | |
    | | +-----------------+  |  |   Messages   |  |  +-----------------+ | |
    | | |   Own Inbound   |  +--------------------+  |  Peer Outbound  | | |
    | | | Transfer Stream |                          | Transfer Stream | | |
    | | |       -----     |<---[Seg]--[Seg]--[Seg]---|       -----     | | |
    | | |     RECEIVER    |---[Ack]----[Ack]-------->|      SENDER     | | |
    | | +-----------------+                          +-----------------+ | |
    | |                                                                  | |
    | | +-----------------+                          +-----------------+ | |
    | | | Own Outbound    |-------[Seg]---[Seg]----->|  Peer Inbound   | | |
    | | | Transfer Stream |<---[Ack]----[Ack]-[Ack]--| Transfer Stream | | |
    | | |       -----     |                          |       -----     | | |
    | | |      SENDER     |   +--------------------+ |     RECEIVER    | | |
    | | +-----------------+   |  |              |  | +-----------------+ | |
    | +-----------------------+  |              |  +---------------------+ |
    +----------------------------+              +--------------------------+
:::

[Figure 3](#figure-3){.selfRef}: [The Relationship within a TCPCL
Session of its Two Streams](#name-the-relationship-within-a-t){.selfRef}
:::
:::
:::
:::

::: {#sec-prococol}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [General Protocol Description](#name-general-protocol-descriptio){.section-name .selfRef} {#name-general-protocol-descriptio}

The service of this protocol is the transmission of DTN bundles via TCP.
This document specifies the encapsulation of bundles, procedures for TCP
setup and teardown, and a set of messages and entity requirements. The
general operation of the protocol is as
follows.[¶](#section-3-1){.pilcrow}

::: {#sec-cl-services}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Convergence-Layer Services](#name-convergence-layer-services){.section-name .selfRef} {#name-convergence-layer-services}

This version of the TCPCL protocol provides the following services to
support the overlaying BPA. In all cases, this is not an API definition
but a logical description of how the CL can interact with the BPA. Each
of these interactions can be associated with any number of additional
metadata items as necessary to support the operation of the CL or
BPA.[¶](#section-3.1-1){.pilcrow}

[]{.break}

Attempt Session:
:   The TCPCL allows a BPA to preemptively attempt to establish a TCPCL
    session with a peer entity. Each session attempt can send a
    different set of session negotiation parameters as directed by the
    BPA.[¶](#section-3.1-2.2){.pilcrow}
:   

Terminate Session:
:   The TCPCL allows a BPA to preemptively terminate an established
    TCPCL session with a peer entity. The terminate request is done on a
    per-session basis.[¶](#section-3.1-2.4){.pilcrow}
:   

Session State Changed:

:   The TCPCL entity indicates to the BPA when the session state
    changes. The top-level session states indicated are as
    follows:[¶](#section-3.1-2.6.1){.pilcrow}

    []{.break}

    Connecting:
    :   A TCP connection is being established. This state only applies
        to the active entity.[¶](#section-3.1-2.6.2.2){.pilcrow}
    :   

    Contact Negotiating:
    :   A TCP connection has been made (as either the active or passive
        entity), and contact negotiation has
        begun.[¶](#section-3.1-2.6.2.4){.pilcrow}
    :   

    Session Negotiating:
    :   Contact negotiation has been completed (including possible TLS
        use), and session negotiation has
        begun.[¶](#section-3.1-2.6.2.6){.pilcrow}
    :   

    Established:
    :   The session has been fully established and is ready for its
        first transfer. When the session is established, the peer node
        ID (along with an indication of whether or not it was
        authenticated) and the negotiated session parameters (see
        [Section 4.7](#sec-session-negotiate){.xref}) are also
        communicated to the BPA.[¶](#section-3.1-2.6.2.8){.pilcrow}
    :   

    Ending:
    :   The entity sent a SESS_TERM message and is in the Ending
        state.[¶](#section-3.1-2.6.2.10){.pilcrow}
    :   

    Terminated:
    :   The session has finished normal termination
        sequencing.[¶](#section-3.1-2.6.2.12){.pilcrow}
    :   

    Failed:
    :   The session ended without normal termination
        sequencing.[¶](#section-3.1-2.6.2.14){.pilcrow}
    :   

:   

Session Idle Changed:
:   The TCPCL entity indicates to the BPA when the Live/Idle substate of
    the session changes. This occurs only when the top-level session
    state is \"Established\". The session transitions from Idle to Live
    at the start of a transfer in either transfer stream; the session
    transitions from Live to Idle at the end of a transfer when the
    other transfer stream does not have an ongoing transfer. Because the
    TCPCL transmits serially over a TCP connection, it suffers from
    \"head-of-queue blocking\", so a transfer in either direction can
    block an immediate start of a new transfer in the
    session.[¶](#section-3.1-2.8){.pilcrow}
:   

Begin Transmission:
:   The principal purpose of the TCPCL is to allow a BPA to transmit
    bundle data over an established TCPCL session. Transmission requests
    are done on a per-session basis, and the CL does not necessarily
    perform any per-session or inter-session queueing. Any queueing of
    transmissions is the obligation of the
    BPA.[¶](#section-3.1-2.10){.pilcrow}
:   

Transmission Success:
:   The TCPCL entity indicates to the BPA when a bundle has been fully
    transferred to a peer entity.[¶](#section-3.1-2.12){.pilcrow}
:   

Transmission Intermediate Progress:
:   The TCPCL entity indicates to the BPA the intermediate progress of a
    transfer to a peer entity. This intermediate progress is at the
    granularity of each transferred
    segment.[¶](#section-3.1-2.14){.pilcrow}
:   

Transmission Failure:
:   The TCPCL entity indicates to the BPA certain reasons for bundle
    transmission failure, notably when the peer entity rejects the
    bundle or when a TCPCL session ends before transfer success. The
    TCPCL itself does not have a notion of transfer
    timeout.[¶](#section-3.1-2.16){.pilcrow}
:   

Reception Initialized:
:   The TCPCL entity indicates this status to the receiving BPA just
    before any transmission data is sent. This corresponds to reception
    of the XFER_SEGMENT message with the `START` flag set to
    1.[¶](#section-3.1-2.18){.pilcrow}
:   

Interrupt Reception:
:   The TCPCL entity allows a BPA to interrupt an individual transfer
    before it has fully completed (successfully or not). Interruption
    can occur any time after the reception is
    initialized.[¶](#section-3.1-2.20){.pilcrow}
:   

Reception Success:
:   The TCPCL entity indicates to the BPA when a bundle has been fully
    transferred from a peer entity.[¶](#section-3.1-2.22){.pilcrow}
:   

Reception Intermediate Progress:
:   The TCPCL entity indicates to the BPA the intermediate progress of a
    transfer from the peer entity. This intermediate progress is at the
    granularity of each transferred segment. An indication of
    intermediate reception gives a BPA the chance to inspect bundle
    header contents before the entire bundle is available and thus
    supports the \"Interrupt Reception\"
    capability.[¶](#section-3.1-2.24){.pilcrow}
:   

Reception Failure:
:   The TCPCL entity indicates to the BPA certain reasons for reception
    failure, notably when the local entity rejects an attempted transfer
    for some local policy reason or when a TCPCL session ends before
    transfer success. The TCPCL itself does not have a notion of
    transfer timeout.[¶](#section-3.1-2.26){.pilcrow}
:   
:::
:::

::: {#sec-protocol-session}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [TCPCL Session Overview](#name-tcpcl-session-overview){.section-name .selfRef} {#name-tcpcl-session-overview}

First, one entity establishes a TCPCL session to the other by initiating
a TCP connection in accordance with \[[RFC0793](#RFC0793){.xref}\].
After setup of the TCP connection is complete, an initial Contact Header
is exchanged in both directions to establish a shared TCPCL version and
negotiate the use of TLS security (as described in [Section
4](#sec-session-establishment){.xref}). Once contact negotiation is
complete, TCPCL messaging is available and the session negotiation is
used to set parameters of the TCPCL session. One of these parameters is
a node ID; each TCPCL entity is acting on behalf of a BPA having a node
ID. This is used to assist in routing and forwarding messages by the BPA
and is part of the authentication capability provided by
TLS.[¶](#section-3.2-1){.pilcrow}

Once negotiated, the parameters of a TCPCL session cannot change; if
there is a desire by either peer to transfer data under different
parameters, then a new session must be established. This makes CL logic
simpler but relies on the assumption that establishing a TCP connection
is lightweight enough that TCP connection overhead is negligible
compared to TCPCL data sizes.[¶](#section-3.2-2){.pilcrow}

Once the TCPCL session is established and configured in this way,
bundles can be transferred in either direction. Each transfer is
performed by segmenting the transfer data into one or more XFER_SEGMENT
messages. Multiple bundles can be transmitted consecutively in a single
direction on a single TCPCL connection. Segments from different bundles
are never interleaved. Bundle interleaving can be accomplished by
fragmentation at the BP layer or by establishing multiple TCPCL sessions
between the same peers. There is no fundamental limit on the number of
TCPCL sessions that a single entity can establish, beyond the limit
imposed by the number of available (ephemeral) TCP ports of the active
entity.[¶](#section-3.2-3){.pilcrow}

One feature of this protocol is that the receiving entity can send
acknowledgment (XFER_ACK) messages as bundle data segments arrive. The
rationale behind these acknowledgments is to enable the transmitting
entity to determine how much of the bundle has been received, so that if
the session is interrupted, it can perform reactive fragmentation to
avoid resending the already-transmitted part of the bundle. In addition,
there is no explicit flow control on the
TCPCL.[¶](#section-3.2-4){.pilcrow}

A TCPCL receiver can interrupt the transmission of a bundle at any point
in time by replying with a XFER_REFUSE message, which causes the sender
to stop transmission of the associated bundle (if it hasn\'t already
finished transmission).[¶](#section-3.2-5){.pilcrow}

Note: This enables a cross-layer optimization in that it allows a
receiver that detects that it has already received a certain bundle to
interrupt transmission as early as possible and thus save transmission
capacity for other bundles.[¶](#section-3.2-6.1){.pilcrow}

For sessions that are idle, a KEEPALIVE message is sent at a negotiated
interval. This is used to convey entity liveness information during
otherwise messageless time intervals.[¶](#section-3.2-7){.pilcrow}

A SESS_TERM message is used to initiate the ending of a TCPCL session
(see [Section 6.1](#sec-SESS_TERM){.xref}). During termination
sequencing, in-progress transfers can be completed but no new transfers
can be initiated. A SESS_TERM message can also be used to refuse a
session setup by a peer (see [Section
4.3](#sec-contact-negotiate){.xref}). Regardless of the reason, session
termination is initiated by one of the entities and the other entity
responds to it, as illustrated by
Figures [13](#fig-sessterm-init){.xref} and
[14](#fig-sessterm-respond){.xref} in the next subsection. Even when
there are no transfers queued or in progress, the session termination
procedure allows each entity to distinguish between a clean end to a
session and the TCP connection being closed because of some underlying
network issue.[¶](#section-3.2-8){.pilcrow}

Once a session is established, the TCPCL is a symmetric protocol between
the peers. Both sides can start sending data segments in a session, and
one side\'s bundle transfer does not have to complete before the other
side can start sending data segments on its own. Hence, the protocol
allows for a bidirectional mode of communication. Note that in the case
of concurrent bidirectional transmission, acknowledgment segments
[MAY]{.bcp14} be interleaved with data
segments.[¶](#section-3.2-9){.pilcrow}
:::
:::

::: {#sec-protocol-states}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [TCPCL States and Transitions](#name-tcpcl-states-and-transition){.section-name .selfRef} {#name-tcpcl-states-and-transition}

The states of a normal TCPCL session (i.e., without session failures)
are indicated in [Figure
4](#fig-session-states){.xref}.[¶](#section-3.3-1){.pilcrow}

[]{#name-top-level-states-of-a-tcpcl}

::: {#fig-session-states}
::: {#section-3.3-2.1 .alignCenter .art-ascii-art .art-text .artwork}
      +-------+
      | START |
      +-------+
          |
      TCP Establishment
          |
          V
    +-----------+            +---------------------+
    |    TCP    |----------->|  Contact / Session  |
    | Connected |            |     Negotiation     |
    +-----------+            +---------------------+
                                        |
           +-----Session Parameters-----+
           |         Negotiated
           V
    +-------------+                     +-------------+
    | Established |----New Transfer---->| Established |
    |   Session   |                     |   Session   |
    |    Idle     |<---Transfers Done---|     Live    |
    +-------------+                     +-------------+
          |                                    |
          +------------------------------------+
          |
          V
    +-------------+
    | Established |                    +-------------+
    |   Session   |----Transfers------>|     TCP     |
    |   Ending    |      Done          | Terminating |
    +-------------+                    +-------------+
                                               |
         +----------TCP Close Message----------+
         |
         V
     +-------+
     |  END  |
     +-------+
:::

[Figure 4](#figure-4){.selfRef}: [Top-Level States of a TCPCL
Session](#name-top-level-states-of-a-tcpcl){.selfRef}
:::

Notes on established session states:[¶](#section-3.3-3){.pilcrow}

-   [Session \"Live\" means transmitting or receiving over a transfer
    stream.[¶](#section-3.3-4.1){.pilcrow}]{#section-3.3-4.1}
-   [Session \"Idle\" means no transmission/reception over a transfer
    stream.[¶](#section-3.3-4.2){.pilcrow}]{#section-3.3-4.2}
-   [Session \"Ending\" means no new transfers will be
    allowed.[¶](#section-3.3-4.3){.pilcrow}]{#section-3.3-4.3}

Contact negotiation involves exchanging a Contact Header (\"CH\" in
Figures [5](#fig-contact-init-active){.xref},
[6](#fig-contact-init-passive){.xref}, and
[7](#fig-contact-init-process){.xref}) in both directions and deriving a
negotiated state from the two headers. The contact negotiation
sequencing is performed as either the active or passive entity and is
illustrated in Figures [5](#fig-contact-init-active){.xref} and
[6](#fig-contact-init-passive){.xref}, respectively, which both share
the data validation and negotiation of the Processing of Contact Header
(\"\[PCH\]\") activity ([Figure 7](#fig-contact-init-process){.xref})
and the \"\[TCPCLOSE\]\" activity, which indicates TCP connection close.
Successful negotiation results in one of the Session Initiation
(\"\[SI\]\") activities being performed, as shown further below. To
avoid data loss, a Session Termination (\"\[ST\]\") exchange allows
cleanly finishing transfers before a session is
ended.[¶](#section-3.3-5){.pilcrow}

[]{#name-contact-initiation-as-activ}

::: {#fig-contact-init-active}
::: {#section-3.3-6.1 .alignCenter .art-ascii-art .art-text .artwork}
    +-------+
    | START |
    +-------+
        |
    TCP Connecting
        V
    +-----------+
    |    TCP    |            +---------+
    | Connected |--Send CH-->| Waiting |--Timeout-->[TCPCLOSE]
    +-----------+            +---------+
                                  |
                              Received CH
                                  V
                                [PCH]
:::

[Figure 5](#figure-5){.selfRef}: [Contact Initiation as Active
Entity](#name-contact-initiation-as-activ){.selfRef}
:::

[]{#name-contact-initiation-as-passi}

::: {#fig-contact-init-passive}
::: {#section-3.3-7.1 .alignCenter .art-ascii-art .art-text .artwork}
    +-----------+             +---------+
    |   TCP     |--Wait for-->| Waiting |--Timeout-->[TCPCLOSE]
    | Connected |     CH      +---------+
    +-----------+                  |
                              Received CH
                                   V
                           +-----------------+
                           | Preparing reply |--Send CH-->[PCH]
                           +-----------------+
:::

[Figure 6](#figure-6){.selfRef}: [Contact Initiation as Passive
Entity](#name-contact-initiation-as-passi){.selfRef}
:::

[]{#name-processing-of-contact-heade}

::: {#fig-contact-init-process}
::: {#section-3.3-8.1 .alignCenter .art-ascii-art .art-text .artwork}
    +-----------+
    |  Peer CH  |
    | available |
    +-----------+
          |
     Validate and
      Negotiate
          V
     +------------+
     | Negotiated |--Failure-->[TCPCLOSE]
     +------------+
        |       |
      No TLS    +----Negotiate---+      [ST]
        |               TLS      |       ^
        V                        |    Failure
      +-----------+              V       |
      |   TCPCL   |            +---------------+
      | Messaging |<--Success--| TLS Handshake |
      | Available |            +---------------+
      +-----------+
:::

[Figure 7](#figure-7){.selfRef}: [Processing of Contact Header
\[PCH\]](#name-processing-of-contact-heade){.selfRef}
:::

Session negotiation involves exchanging a session initialization
(SESS_INIT) message in both directions and deriving a negotiated state
from the two messages. The session negotiation sequencing is performed
as either the active or passive entity and is illustrated in
Figures [8](#fig-sess-init-active){.xref} and
[9](#fig-sess-init-passive){.xref}, respectively (where \"\[PSI\]\"
means \"Processing of Session Initiation\"), which both share the data
validation and negotiation shown in [Figure
10](#fig-sess-init-process){.xref}. The validation here includes
certificate validation and authentication when TLS is used for the
session.[¶](#section-3.3-9){.pilcrow}

[]{#name-session-initiation-si-as-ac}

::: {#fig-sess-init-active}
::: {#section-3.3-10.1 .alignCenter .art-ascii-art .art-text .artwork}
    +-----------+
    |   TCPCL   |                   +---------+
    | Messaging |--Send SESS_INIT-->| Waiting |--Timeout-->[ST]
    | Available |                   +---------+
    +-----------+                       |
                                Received SESS_INIT
                                        |
                                        V
                                      [PSI]
:::

[Figure 8](#figure-8){.selfRef}: [Session Initiation \[SI\] as Active
Entity](#name-session-initiation-si-as-ac){.selfRef}
:::

[]{#name-session-initiation-si-as-pa}

::: {#fig-sess-init-passive}
::: {#section-3.3-11.1 .alignCenter .art-ascii-art .art-text .artwork}
    +-----------+
    |   TCPCL   |                  +---------+
    | Messaging |----Wait for ---->| Waiting |--Timeout-->[ST]
    | Available |    SESS_INIT     +---------+
    +-----------+                       |
                                Received SESS_INIT
                                        |
                                +-----------------+
                                | Preparing reply |--Send SESS_INIT-->[PSI]
                                +-----------------+
:::

[Figure 9](#figure-9){.selfRef}: [Session Initiation \[SI\] as Passive
Entity](#name-session-initiation-si-as-pa){.selfRef}
:::

[]{#name-processing-of-session-initi}

::: {#fig-sess-init-process}
::: {#section-3.3-12.1 .alignCenter .art-ascii-art .art-text .artwork}
    +----------------+
    | Peer SESS_INIT |
    |   available    |
    +----------------+
            |
       Validate and
        Negotiate
            V
       +------------+
       | Negotiated |---Failure--->[ST]
       +------------+
            |
         Success
            V
      +--------------+
      | Established  |
      | Session Idle |
      +--------------+
:::

[Figure 10](#figure-10){.selfRef}: [Processing of Session Initiation
\[PSI\]](#name-processing-of-session-initi){.selfRef}
:::

Transfers can occur after a session is established and it\'s not in the
Ending state. Each transfer occurs within a single logical transfer
stream between a sender and a receiver, as illustrated in
Figures [11](#fig-transfer-tx-states){.xref} and
[12](#fig-transfer-rx-states){.xref},
respectively.[¶](#section-3.3-13){.pilcrow}

[]{#name-transfer-sender-states}

::: {#fig-transfer-tx-states}
::: {#section-3.3-14.1 .alignCenter .art-ascii-art .art-text .artwork}
                                           +--Send XFER_SEGMENT--+
    +--------+                             |                     |
    | Stream |                       +-------------+             |
    |  Idle  |---Send XFER_SEGMENT-->| In Progress |<------------+
    +--------+                       +-------------+
                                           |
         +---------All segments sent-------+
         |
         V
    +---------+                       +--------+
    | Waiting |---- Receive Final---->| Stream |
    | for Ack |       XFER_ACK        |  Idle  |
    +---------+                       +--------+
:::

[Figure 11](#figure-11){.selfRef}: [Transfer Sender
States](#name-transfer-sender-states){.selfRef}
:::

Note on transfer sending: Pipelining of transfers can occur when the
sending entity begins a new transfer while in the \"Waiting for Ack\"
state.[¶](#section-3.3-15.1){.pilcrow}

[]{#name-transfer-receiver-states}

::: {#fig-transfer-rx-states}
::: {#section-3.3-16.1 .alignCenter .art-ascii-art .art-text .artwork}
                                             +-Receive XFER_SEGMENT-+
    +--------+                               |    Send XFER_ACK     |
    | Stream |                         +-------------+              |
    |  Idle  |--Receive XFER_SEGMENT-->| In Progress |<-------------+
    +--------+                         +-------------+
                                             |
         +--------Sent Final XFER_ACK--------+
         |
         V
    +--------+
    | Stream |
    |  Idle  |
    +--------+
:::

[Figure 12](#figure-12){.selfRef}: [Transfer Receiver
States](#name-transfer-receiver-states){.selfRef}
:::

Session termination involves one entity initiating the termination of
the session and the other entity acknowledging the termination. For
either entity, it is the sending of the SESS_TERM message, which
transitions the session to the Ending substate. While a session is in
the Ending state, only in-progress transfers can be completed and no new
transfers can be started.[¶](#section-3.3-17){.pilcrow}

[]{#name-session-termination-st-from}

::: {#fig-sessterm-init}
::: {#section-3.3-18.1 .alignCenter .art-ascii-art .art-text .artwork}
    +-----------+                   +---------+
    |  Session  |--Send SESS_TERM-->| Session |
    | Live/Idle |                   | Ending  |
    +-----------+                   +---------+
:::

[Figure 13](#figure-13){.selfRef}: [Session Termination \[ST\] from the
Initiator](#name-session-termination-st-from){.selfRef}
:::

[]{#name-session-termination-st-from-}

::: {#fig-sessterm-respond}
::: {#section-3.3-19.1 .alignCenter .art-ascii-art .art-text .artwork}
    +-----------+                   +---------+
    |  Session  |--Send SESS_TERM-->| Session |
    | Live/Idle |                   | Ending  |
    +-----------+<------+           +---------+
          |             |
     Receive SESS_TERM  |
          |             |
          +-------------+
:::

[Figure 14](#figure-14){.selfRef}: [Session Termination \[ST\] from the
Responder](#name-session-termination-st-from-){.selfRef}
:::
:::
:::

::: {#sec-pkix-env}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [PKIX Environments and CA Policy](#name-pkix-environments-and-ca-po){.section-name .selfRef} {#name-pkix-environments-and-ca-po}

This specification defines requirements regarding how to use PKIX
certificates issued by a Certificate Authority (CA) but does not define
any mechanisms for how those certificates come to be. The requirements
regarding TCPCL certificate use are broad, to support two quite
different PKIX environments:[¶](#section-3.4-1){.pilcrow}

[]{.break}

DTN-Aware CAs:
:   In the ideal case, the CA or CAs issuing certificates for TCPCL
    entities are aware of the end use of the certificate, have a
    mechanism for verifying ownership of a node ID, and are issuing
    certificates directly for that node ID. In this environment, the
    ability to authenticate a peer entity node ID directly avoids the
    need to authenticate a network name or address and then implicitly
    trust the node ID of the peer. The TCPCL authenticates the node ID
    whenever possible; this is preferred over lower-level PKIX
    identities.[¶](#section-3.4-2.2){.pilcrow}
:   

DTN-Ignorant CAs:
:   It is expected that Internet-scale \"public\" CAs will continue to
    focus on DNS names as the preferred PKIX identifier. There are large
    infrastructures already in place for managing network-level
    authentication and protocols to manage identity verification in
    those environments \[[RFC8555](#RFC8555){.xref}\]. The TCPCL allows
    for this type of environment by authenticating a lower-level
    identifier for a peer and requiring the entity to trust that the
    node ID given by the peer (during session initialization) is valid.
    This situation is not ideal, as it allows the vulnerabilities
    described in [Section 7.9](#sec-threat-node-impersonation){.xref},
    but it still provides some amount of mutual authentication to take
    place for a TCPCL session.[¶](#section-3.4-2.4){.pilcrow}
:   

Even within a single TCPCL session, each entity may operate within
different PKI environments and with different identifier limitations.
The requirements related to identifiers in a PKIX certificate are
provided in [Section
4.4.1](#sec-tls-identification){.xref}.[¶](#section-3.4-3){.pilcrow}

It is important for interoperability that a TCPCL entity have its own
security policy tailored to accommodate the peers with which it is
expected to operate. Some security policy recommendations are given in
[Section 4.4.5](#sec-tls-auth-policy-rec){.xref}, but these are meant as
a starting point for tailoring. A strict TLS security policy is
appropriate for a private network with a single shared CA. Operation on
the Internet (such as inter-site BP gateways) could trade more lax TCPCL
security with the use of encrypted bundle encapsulation
\[[DTN-BIBECT](#I-D.ietf-dtn-bibect){.xref}\] to ensure strong bundle
security.[¶](#section-3.4-4){.pilcrow}

By using the Server Name Indication (SNI) DNS name (see [Section
4.4.3](#sec-tls-handshake){.xref}), a single passive entity can act as a
convergence layer for multiple BPAs with distinct node IDs. When this
\"virtual host\" behavior is used, the DNS name is used as the
indication of which BP node the active entity is attempting to
communicate with. A virtual host CL entity can be authenticated by a
certificate containing all of the DNS names and/or node IDs being hosted
or by several certificates each authenticating a single DNS name and/or
node ID, using the SNI value from the peer to select which certificate
to use. The logic for mapping an SNI DNS name to an end-entity
certificate is an implementation matter and can involve correlating a
DNS name with a node ID or other certificate
attributes.[¶](#section-3.4-5){.pilcrow}
:::
:::

::: {#sec-session-keeping}
::: {#section-3.5 .section}
### [3.5.](#section-3.5){.section-number .selfRef} [Session-Keeping Policies](#name-session-keeping-policies){.section-name .selfRef} {#name-session-keeping-policies}

This specification defines requirements regarding how to initiate,
sustain, and terminate a TCPCL session but does not impose any
requirements on how sessions need to be managed by a BPA. It is a
network administration matter to determine an appropriate
session-keeping policy, but guidance given here can be used to steer
policy toward performance goals.[¶](#section-3.5-1){.pilcrow}

[]{.break}

Persistent Session:
:   This policy preemptively establishes a single session to known
    entities in the network and keeps the session active using
    KEEPALIVEs. Benefits of this policy include reducing the total
    amount of TCP data that needs to be exchanged for a set of transfers
    (assuming that the KEEPALIVE size is significantly smaller than the
    transfer size) and allowing the session state to indicate peer
    connectivity. Drawbacks include wasted network resources when a
    session is mostly idle or when network connectivity is inconsistent
    (which requires that failed sessions be reestablished), and
    potential queueing issues when multiple transfers are requested
    simultaneously. This policy assumes that there is agreement between
    pairs of entities as to which of the peers will initiate sessions;
    if there is no such agreement, there is potential for duplicate
    sessions to be established between
    peers.[¶](#section-3.5-2.2){.pilcrow}
:   

Ephemeral Sessions:
:   This policy only establishes a session when an outgoing transfer
    needs to be sent. Benefits of this policy include not wasting
    network resources on sessions that are idle for long periods of time
    and avoiding potential queueing issues as can be seen when using a
    single persistent session. Drawbacks include the TCP and TLS
    overhead of establishing a new session for each transfer. This
    policy assumes that each entity can function in a passive role to
    listen for session requests from any peer that needs to send a
    transfer; when that is not the case, the polling behavior discussed
    below needs to happen. This policy can be augmented to keep the
    session established as long as any transfers are
    queued.[¶](#section-3.5-2.4){.pilcrow}
:   

Active-Only Polling Sessions:
:   When naming and/or addressing of one entity is variable (i.e., a
    dynamically assigned IP address or domain name) or when firewall or
    routing rules prevent incoming TCP connections, that entity can only
    function in the active role. In these cases, sessions also need to
    be established when an incoming transfer is expected from a peer or
    based on a periodic schedule. This polling behavior causes
    inefficiencies compared to as-needed ephemeral
    sessions.[¶](#section-3.5-2.6){.pilcrow}
:   

Many other policies can be established in a TCPCL network between the
two extremes of single persistent sessions and only ephemeral sessions.
Different policies can be applied to each peer entity and to each bundle
as it needs to be transferred (e.g., for quality of service).
Additionally, future session extension types can apply further nuance to
session policies and policy negotiation.[¶](#section-3.5-3){.pilcrow}
:::
:::

::: {#sec-transfer-segmentation}
::: {#section-3.6 .section}
### [3.6.](#section-3.6){.section-number .selfRef} [Transfer Segmentation Policies](#name-transfer-segmentation-polic){.section-name .selfRef} {#name-transfer-segmentation-polic}

Each TCPCL session allows a negotiated transfer segmentation policy to
be applied in each transfer direction. A receiving entity can set the
Segment Maximum Receive Unit (MRU) in its SESS_INIT message to determine
the largest acceptable segment size, and a transmitting entity can
segment a transfer into any sizes smaller than the receiver\'s Segment
MRU. It is a network administration matter to determine an appropriate
segmentation policy for entities using the TCPCL protocol, but guidance
given here can be used to steer policy toward performance goals.
Administrators are also advised to consider the Segment MRU in relation
to chunking/packetization performed by TLS, TCP, and any intermediate
network-layer nodes.[¶](#section-3.6-1){.pilcrow}

[]{.break}

Minimum Overhead:
:   For a simple network expected to exchange relatively small bundles,
    the Segment MRU can be set to be identical to the Transfer MRU,
    which indicates that all transfers can be sent with a single data
    segment (i.e., no actual segmentation). If the network is closed and
    all transmitters are known to follow a single-segment transfer
    policy, then receivers can avoid the necessity of segment
    reassembly. Because this CL operates over a TCP stream, which
    suffers from a form of head-of-queue blocking between messages,
    while one entity is transmitting a single XFER_SEGMENT message it is
    not able to transmit any XFER_ACK or XFER_REFUSE messages for any
    associated received transfers.[¶](#section-3.6-2.2){.pilcrow}
:   

Predictable Message Sizing:
:   In situations where the maximum message size is desired to be well
    controlled, the Segment MRU can be set to the largest acceptable
    size (the message size less the XFER_SEGMENT header size) and
    transmitters can always segment a transfer into maximum-size chunks
    no larger than the Segment MRU. This guarantees that any single
    XFER_SEGMENT will not monopolize the TCP stream for too long, which
    would prevent outgoing XFER_ACK and XFER_REFUSE messages associated
    with received transfers.[¶](#section-3.6-2.4){.pilcrow}
:   

Dynamic Segmentation:
:   Even after negotiation of a Segment MRU for each receiving entity,
    the actual transfer segmentation only needs to guarantee that any
    individual segment is no larger than that MRU. In a situation where
    TCP throughput is dynamic, the transfer segmentation size can also
    be dynamic in order to control message transmission
    duration.[¶](#section-3.6-2.6){.pilcrow}
:   

Many other policies can be established in a TCPCL network between the
two extremes of minimum overhead (large MRU, single segment) and
predictable message sizing (small MRU, highly segmented). Different
policies can be applied to each transfer stream to and from any
particular entity. Additionally, future session extension and transfer
extension types can apply further nuance to transfer policies and policy
negotiation.[¶](#section-3.6-3){.pilcrow}
:::
:::

::: {#sec-protocol-example}
::: {#section-3.7 .section}
### [3.7.](#section-3.7){.section-number .selfRef} [Example Message Exchange](#name-example-message-exchange){.section-name .selfRef} {#name-example-message-exchange}

[Figure 15](#fig-contact-example){.xref} depicts the protocol exchange
for a simple session, showing the session establishment and the
transmission of a single bundle split into three data segments (of
lengths \"L1\", \"L2\", and \"L3\") from Entity A to Entity
B.[¶](#section-3.7-1){.pilcrow}

Note that the sending entity can transmit multiple XFER_SEGMENT messages
without waiting for the corresponding XFER_ACK responses. This enables
pipelining of messages on a transfer stream. Although this example only
demonstrates a single bundle transmission, it is also possible to
pipeline multiple XFER_SEGMENT messages for different bundles without
necessarily waiting for XFER_ACK messages to be returned for each one.
However, interleaving data segments from different bundles is not
allowed.[¶](#section-3.7-2){.pilcrow}

No errors or rejections are shown in this
example.[¶](#section-3.7-3){.pilcrow}

[]{#name-an-example-of-the-flow-of-p}

::: {#fig-contact-example}
::: {#section-3.7-4.1 .alignCenter .art-ascii-art .art-text .artwork}
                 Entity A                             Entity B
                 ========                             ========
        +-------------------------+
        |  Open TCP Connection    | ->      +-------------------------+
        +-------------------------+      <- |    Accept Connection    |
                                            +-------------------------+
        +-------------------------+
        |     Contact Header      | ->      +-------------------------+
        +-------------------------+      <- |     Contact Header      |
                                            +-------------------------+
        +-------------------------+
        |        SESS_INIT        | ->      +-------------------------+
        +-------------------------+      <- |        SESS_INIT        |
                                            +-------------------------+

        +-------------------------+
        |   XFER_SEGMENT (start)  | ->
        |     Transfer ID [I1]    |
        |       Length [L1]       |
        |  Bundle Data 0..(L1-1)  |
        +-------------------------+
        +-------------------------+         +-------------------------+
        |     XFER_SEGMENT        | ->   <- |     XFER_ACK (start)    |
        |     Transfer ID [I1]    |         |     Transfer ID [I1]    |
        |       Length   [L2]     |         |        Length   [L1]    |
        |Bundle Data L1..(L1+L2-1)|         +-------------------------+
        +-------------------------+
        +-------------------------+         +-------------------------+
        |    XFER_SEGMENT (end)   | ->   <- |         XFER_ACK        |
        |     Transfer ID [I1]    |         |     Transfer ID [I1]    |
        |        Length   [L3]    |         |      Length   [L1+L2]   |
        |Bundle Data              |         +-------------------------+
        |    (L1+L2)..(L1+L2+L3-1)|
        +-------------------------+
                                            +-------------------------+
                                         <- |      XFER_ACK (end)     |
                                            |     Transfer ID [I1]    |
                                            |     Length   [L1+L2+L3] |
                                            +-------------------------+

        +-------------------------+
        |       SESS_TERM         | ->      +-------------------------+
        +-------------------------+      <- |        SESS_TERM        |
                                            +-------------------------+
        +-------------------------+         +-------------------------+
        |        TCP Close        | ->   <- |        TCP Close        |
        +-------------------------+         +-------------------------+
:::

[Figure 15](#figure-15){.selfRef}: [An Example of the Flow of Protocol
Messages on a Single TCP Session between Two
Entities](#name-an-example-of-the-flow-of-p){.selfRef}
:::
:::
:::
:::
:::

::: {#sec-session-establishment}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Session Establishment](#name-session-establishment){.section-name .selfRef} {#name-session-establishment}

For bundle transmissions to occur using the TCPCL, a TCPCL session
[MUST]{.bcp14} first be established between communicating entities. It
is up to the implementation to decide how and when session setup is
triggered. For example, some sessions can be opened proactively and
maintained for as long as is possible given the network conditions,
while other sessions will be opened only when there is a bundle that is
queued for transmission and the routing algorithm selects a certain
next-hop node.[¶](#section-4-1){.pilcrow}

::: {#sec-tcp-connection}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [TCP Connection](#name-tcp-connection){.section-name .selfRef} {#name-tcp-connection}

To establish a TCPCL session, an entity [MUST]{.bcp14} first establish a
TCP connection with the intended peer entity, typically by using the
services provided by the operating system. Destination port number 4556
has been assigned by IANA as the registered port number for the TCPCL;
see [Section 8.1](#sec-iana-port){.xref}. Other destination port numbers
[MAY]{.bcp14} be used per local configuration. Determining a peer\'s
destination port number (if different from the registered TCPCL port
number) is left up to the implementation. Any source port number
[MAY]{.bcp14} be used for TCPCL sessions. Typically, an operating system
assigned number in the TCP Ephemeral range (49152-65535) is
used.[¶](#section-4.1-1){.pilcrow}

If the entity is unable to establish a TCP connection for any reason,
then it is an implementation matter to determine how to handle the
connection failure. An entity [MAY]{.bcp14} decide to reattempt to
establish the connection. If it does so, it [MUST NOT]{.bcp14} overwhelm
its target with repeated connection attempts. Therefore, the entity
[MUST NOT]{.bcp14} retry the connection setup earlier than some delay
time from the last attempt, and it [SHOULD]{.bcp14} use a (binary)
exponential backoff mechanism to increase this delay in the case of
repeated failures. The upper limit on a reattempt backoff is
implementation defined but [SHOULD]{.bcp14} be no longer than one minute
(60 seconds) before signaling to the BPA that a connection cannot be
made.[¶](#section-4.1-2){.pilcrow}

Once a TCP connection is established, the active entity [SHALL]{.bcp14}
immediately transmit its Contact Header. The passive entity
[SHALL]{.bcp14} wait for the active entity\'s Contact Header. Upon
reception of a Contact Header, the passive entity [SHALL]{.bcp14}
transmit its Contact Header. If either entity does not receive a Contact
Header after some implementation-defined time duration after the TCP
connection is established, the waiting entity [SHALL]{.bcp14} close the
TCP connection. Entities [SHOULD]{.bcp14} choose a Contact Header
reception timeout interval no longer than one minute (60 seconds). The
ordering of the Contact Header exchange allows the passive entity to
avoid allocating resources to a potential TCPCL session until after a
valid Contact Header has been received from the active entity. This
ordering also allows the passive peer to adapt to alternate TCPCL
protocol versions.[¶](#section-4.1-3){.pilcrow}

The format of the Contact Header is described in [Section
4.2](#sec-contact-header){.xref}. Because the TCPCL protocol version in
use is part of the initial Contact Header, entities using TCPCL version
4 can coexist on a network with entities using earlier TCPCL versions
(with some negotiation needed for interoperation, as described in
[Section
4.3](#sec-contact-negotiate){.xref}).[¶](#section-4.1-4){.pilcrow}

Within this specification, when an entity is said to \"close\" a TCP
connection the entity [SHALL]{.bcp14} use the TCP FIN mechanism and not
the RST mechanism. However, either mechanism, when received, will cause
a TCP connection to become closed.[¶](#section-4.1-5){.pilcrow}
:::
:::

::: {#sec-contact-header}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Contact Header](#name-contact-header){.section-name .selfRef} {#name-contact-header}

This section describes the format of the Contact Header and the meaning
of its fields.[¶](#section-4.2-1){.pilcrow}

If the entity is configured to enable the exchange of messages according
to TLS 1.3 \[[RFC8446](#RFC8446){.xref}\] or any successors that are
compatible with that TLS ClientHello, the `CAN_TLS` flag within its
Contact Header [SHALL]{.bcp14} be set to 1. The [RECOMMENDED]{.bcp14}
policy is to enable TLS for all sessions, even if security policy does
not allow or require authentication. This follows the \"opportunistic
security\" model specified in \[[RFC7435](#RFC7435){.xref}\], though an
active attacker could interfere with the exchange in such cases (see
[Section
7.4](#sec-threat-tls-strip){.xref}).[¶](#section-4.2-2){.pilcrow}

Upon receipt of the Contact Header, both entities perform the validation
and negotiation procedures defined in [Section
4.3](#sec-contact-negotiate){.xref}. After receiving the Contact Header
from the other entity, either entity [MAY]{.bcp14} refuse the session by
sending a SESS_TERM message with an appropriate reason
code.[¶](#section-4.2-3){.pilcrow}

The format for the Contact Header is as
follows:[¶](#section-4.2-4){.pilcrow}

[]{#name-contact-header-format}

::: {#fig-contact-header}
::: {#section-4.2-5.1 .alignCenter .art-ascii-art .art-text .artwork}
                         1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +---------------+---------------+---------------+---------------+
    |                          magic='dtn!'                         |
    +---------------+---------------+---------------+---------------+
    |     Version   |   Flags       |
    +---------------+---------------+
:::

[Figure 16](#figure-16){.selfRef}: [Contact Header
Format](#name-contact-header-format){.selfRef}
:::

See [Section 4.3](#sec-contact-negotiate){.xref} for details on the use
of each of these Contact Header fields.[¶](#section-4.2-6){.pilcrow}

The fields of the Contact Header are as
follows:[¶](#section-4.2-7){.pilcrow}

[]{.break}

magic:
:   A four-octet field that always contains the octet sequence 0x64 0x74
    0x6E 0x21, i.e., the text string \"dtn!\" in US-ASCII (and
    UTF-8).[¶](#section-4.2-8.2){.pilcrow}
:   

Version:
:   A one-octet field value containing the value 4 (current version of
    the TCPCL protocol).[¶](#section-4.2-8.4){.pilcrow}
:   

Flags:
:   A one-octet field of single-bit flags, interpreted according to the
    descriptions in [Table 1](#tab-contact-header-flags){.xref}. All
    reserved header flag bits [SHALL]{.bcp14} be set to 0 by the sender.
    All reserved header flag bits [SHALL]{.bcp14} be ignored by the
    receiver.[¶](#section-4.2-8.6){.pilcrow}
:   

[]{#name-contact-header-flags}

::: {#tab-contact-header-flags}
  Name        Code     Description
  ----------- -------- ----------------------------------------------------------------------------------
  `CAN_TLS`   0x01     If this bit is set, it indicates that the sending peer has enabled TLS security.
  Reserved    others   

  : [Table 1](#table-1){.selfRef}: [Contact Header
  Flags](#name-contact-header-flags){.selfRef}
:::
:::
:::

::: {#sec-contact-negotiate}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Contact Validation and Negotiation](#name-contact-validation-and-nego){.section-name .selfRef} {#name-contact-validation-and-nego}

Upon reception of the Contact Header, each entity follows the following
procedures to ensure the validity of the TCPCL session and to negotiate
values for the session parameters.[¶](#section-4.3-1){.pilcrow}

If the \"magic string\" is not present or is not valid, the connection
[MUST]{.bcp14} be terminated. The intent of the magic string is to
provide some protection against an inadvertent TCP connection by a
different protocol than the one described in this document. To prevent a
flood of repeated connections from a misconfigured application, a
passive entity [MAY]{.bcp14} deny new TCP connections from a specific
peer address for a period of time after one or more connections fail to
provide a decodable Contact Header.[¶](#section-4.3-2){.pilcrow}

The first negotiation attempts to determine which TCPCL protocol version
to use. The active entity always sends its Contact Header first and
waits for a response from the passive entity. During contact initiation,
the active TCPCL entity [SHALL]{.bcp14} send the highest TCPCL protocol
version on a first session attempt for a TCPCL peer. If the active
entity receives a Contact Header with a lower protocol version than the
one sent earlier on the TCP connection, the TCP connection
[SHALL]{.bcp14} be closed. If the active entity receives a SESS_TERM
message with a reason code of \"Version mismatch\", that entity
[MAY]{.bcp14} attempt further TCPCL sessions with the peer using earlier
protocol version numbers in decreasing order. Managing
multi-TCPCL-session state such as this is an implementation
matter.[¶](#section-4.3-3){.pilcrow}

If the passive entity receives a Contact Header containing a version
that is not a version of the TCPCL protocol that the entity implements,
then the entity [SHALL]{.bcp14} send its Contact Header and immediately
terminate the session with a reason code of \"Version mismatch\". If the
passive entity receives a Contact Header with a version that is lower
than the latest version of the protocol that the entity implements, the
entity [MAY]{.bcp14} either terminate the session (with a reason code of
\"Version mismatch\") or adapt its operation to conform to the older
version of the protocol. The decision of version fallback is an
implementation matter.[¶](#section-4.3-4){.pilcrow}

The negotiated contact parameters defined by this specification are
described in the following paragraphs.[¶](#section-4.3-5){.pilcrow}

[]{.break}

TCPCL Version:
:   Both Contact Headers of a successful contact negotiation have
    identical TCPCL version numbers as described above. Only upon
    response of a Contact Header from the passive entity is the TCPCL
    protocol version established and session negotiation
    begun.[¶](#section-4.3-6.2){.pilcrow}
:   

Enable TLS:

:   Negotiation of the Enable TLS parameter is performed by taking the
    logical AND of the two Contact Headers\' `CAN_TLS` flags. A local
    security policy is then applied to determine whether the negotiated
    value of Enable TLS is acceptable. A reasonable security policy
    would require or disallow the use of TLS, depending upon the desired
    network flows. The [RECOMMENDED]{.bcp14} policy is to require TLS
    for all sessions, even if security policy does not allow or require
    authentication. Because this state is negotiated over an unsecured
    medium, there is a risk of TLS Stripping as described in [Section
    7.4](#sec-threat-tls-strip){.xref}.[¶](#section-4.3-6.4.1){.pilcrow}

    If the Enable TLS state is unacceptable, the entity [SHALL]{.bcp14}
    terminate the session with a reason code of \"Contact Failure\".
    Note that this \"Contact Failure\" reason is different than a
    failure of a TLS handshake or TLS authentication after an
    agreed-upon and acceptable Enable TLS state. If the negotiated
    Enable TLS value is \"true\" and acceptable, then the TLS
    negotiation feature described in [Section
    4.4](#sec-session-security){.xref} begins immediately following the
    Contact Header exchange.[¶](#section-4.3-6.4.2){.pilcrow}

:   
:::
:::

::: {#sec-session-security}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Session Security](#name-session-security){.section-name .selfRef} {#name-session-security}

This version of the TCPCL protocol supports establishing a TLS session
within an existing TCP connection. When TLS is used within the TCPCL, it
affects the entire session. Once TLS is established, there is no
mechanism available to downgrade the TCPCL session to non-TLS
operation.[¶](#section-4.4-1){.pilcrow}

Once established, the lifetime of a TLS connection [SHALL]{.bcp14} be
bound to the lifetime of the underlying TCP connection. Immediately
prior to actively ending a TLS connection after TCPCL session
termination, the peer that sent the original (non-reply) SESS_TERM
message [SHOULD]{.bcp14} follow the closure alert procedure provided in
\[[RFC8446](#RFC8446){.xref}\] to cleanly terminate the TLS connection.
Because each TCPCL message is either fixed length or self-indicates its
length, the lack of a TLS closure alert will not cause data truncation
or corruption.[¶](#section-4.4-2){.pilcrow}

Subsequent TCPCL session attempts to the same passive entity
[MAY]{.bcp14} attempt to use the TLS session resumption feature. There
is no guarantee that the passive entity will accept the request to
resume a TLS session, and the active entity cannot assume any resumption
outcome.[¶](#section-4.4-3){.pilcrow}

::: {#sec-tls-identification}
::: {#section-4.4.1 .section}
#### [4.4.1.](#section-4.4.1){.section-number .selfRef} [Entity Identification](#name-entity-identification){.section-name .selfRef} {#name-entity-identification}

The TCPCL uses TLS for certificate exchange in both directions to
identify each entity and to allow each entity to authenticate its peer.
Each certificate can potentially identify multiple entities, and there
is no problem using such a certificate as long as the identifiers are
sufficient to meet authentication policy (as described in later
sections) for the entity that presents
it.[¶](#section-4.4.1-1){.pilcrow}

Because the PKIX environment of each TCPCL entity is likely not
controlled by the certificate end users (see [Section
3.4](#sec-pkix-env){.xref}), the TCPCL defines a prioritized list of
what a certificate can identify regarding a TCPCL
entity:[¶](#section-4.4.1-2){.pilcrow}

[]{.break}

Node ID:
:   The ideal certificate identity is the node ID of the entity using
    the NODE-ID, as defined below. When the node ID is identified, there
    is no need for any lower-level identification to be present (though
    it can still be present, and if so it is also
    validated).[¶](#section-4.4.1-3.2){.pilcrow}
:   

DNS Name:
:   If CA policy forbids a certificate to contain an arbitrary NODE-ID
    but allows a DNS-ID to be identified, then one or more stable DNS
    names can be identified in the certificate. The use of wildcard
    DNS-IDs is discouraged due to the complex rules for matching and
    dependence on implementation support for wildcard matching (see
    [Section
    6.4.3](https://www.rfc-editor.org/rfc/rfc6125#section-6.4.3){.relref}
    of \[[RFC6125](#RFC6125){.xref}\]).[¶](#section-4.4.1-3.4){.pilcrow}
:   

Network Address:
:   If no stable DNS name is available but a stable network address is
    available and CA policy allows a certificate to contain an IPADDR-ID
    (as defined below), then one or more network addresses can be
    identified in the certificate.[¶](#section-4.4.1-3.6){.pilcrow}
:   

This specification defines a NODE-ID of a certificate as being the
subjectAltName entry of type otherName with a name form of `BundleEID`
(see [Section 4.4.2.1](#sec-pkix-oids){.xref}) and a value limited to a
node ID. An entity [SHALL]{.bcp14} ignore any entry of type otherName
with a name form of `BundleEID` and a value that is some URI other than
a node ID. The NODE-ID is similar to the URI-ID as defined in
\[[RFC6125](#RFC6125){.xref}\] but is restricted to a node ID rather
than a URI with a qualified-name authority part. Unless specified
otherwise by the definition of the URI scheme being authenticated, URI
matching of a NODE-ID [SHALL]{.bcp14} use the URI comparison logic
provided in \[[RFC3986](#RFC3986){.xref}\] and scheme-based
normalization of those schemes specified in
\[[RFC9171](#RFC9171){.xref}\]. A URI scheme can refine this \"exact
match\" logic with rules regarding how node IDs within that scheme are
to be compared with the certificate-authenticated
NODE-ID.[¶](#section-4.4.1-4){.pilcrow}

This specification reuses the DNS-ID definition in [Section
1.8](https://www.rfc-editor.org/rfc/rfc6125#section-1.8){.relref} of
\[[RFC6125](#RFC6125){.xref}\], which is the subjectAltName entry of
type dNSName whose value is encoded according to
\[[RFC5280](#RFC5280){.xref}\].[¶](#section-4.4.1-5){.pilcrow}

This specification defines an IPADDR-ID of a certificate as being the
subjectAltName entry of type iPAddress whose value is encoded according
to \[[RFC5280](#RFC5280){.xref}\].[¶](#section-4.4.1-6){.pilcrow}
:::
:::

::: {#sec-tcpcl-cert-profile}
::: {#section-4.4.2 .section}
#### [4.4.2.](#section-4.4.2){.section-number .selfRef} [Certificate Profile for the TCPCL](#name-certificate-profile-for-the){.section-name .selfRef} {#name-certificate-profile-for-the}

All end-entity certificates used by a TCPCL entity [SHALL]{.bcp14}
conform to \[[RFC5280](#RFC5280){.xref}\], or any updates or successors
to that profile. When an end-entity certificate is supplied, the full
certification chain [SHOULD]{.bcp14} be included unless security policy
indicates that is unnecessary. An entity [SHOULD]{.bcp14} omit the root
CA certificate (the last item of the chain) when sending a certification
chain, as the recipient already has the root CA to anchor its
validation.[¶](#section-4.4.2-1){.pilcrow}

The TCPCL requires version 3 certificates due to the extensions used by
this profile. TCPCL entities [SHALL]{.bcp14} reject as invalid version 1
and version 2 end-entity certificates.[¶](#section-4.4.2-2){.pilcrow}

TCPCL entities [SHALL]{.bcp14} accept certificates that contain an empty
Subject field or contain a Subject without a Common Name. Identity
information in end-entity certificates is contained entirely in the
subjectAltName extension as defined in [Section
4.4.1](#sec-tls-identification){.xref} and discussed in the paragraphs
below.[¶](#section-4.4.2-3){.pilcrow}

All end-entity and CA certificates used for the TCPCL [SHOULD]{.bcp14}
contain both a subject key identifier and an authority key identifier
extension in accordance with \[[RFC5280](#RFC5280){.xref}\]. TCPCL
entities [SHOULD NOT]{.bcp14} rely on either a subject key identifier or
an authority key identifier being present in any received certificate.
Including key identifiers simplifies the work of an entity that needs to
assemble a certification chain.[¶](#section-4.4.2-4){.pilcrow}

Unless prohibited by CA policy, a TCPCL end-entity certificate
[SHALL]{.bcp14} contain a NODE-ID that authenticates the node ID of the
peer. When assigned one or more stable DNS names, a TCPCL end-entity
certificate [SHOULD]{.bcp14} contain a DNS-ID that authenticates those
(fully qualified) names. When assigned one or more stable network
addresses, a TCPCL end-entity certificate [MAY]{.bcp14} contain an
IPADDR-ID that authenticates those
addresses.[¶](#section-4.4.2-5){.pilcrow}

When allowed by CA policy, a Bundle Protocol Security (BPSec; see
\[[RFC9172](#RFC9172){.xref}\]) end-entity certificate [SHOULD]{.bcp14}
contain a PKIX Extended Key Usage (EKU) extension in accordance with
[Section
4.2.1.12](https://www.rfc-editor.org/rfc/rfc5280#section-4.2.1.12){.relref}
of \[[RFC5280](#RFC5280){.xref}\]. When the PKIX EKU extension is
present, it [SHOULD]{.bcp14} contain the key purpose
`id-kp-bundleSecurity` (see [Section 4.4.2.1](#sec-pkix-oids){.xref}).
Although not specifically required by the TCPCL, some networks or TLS
implementations assume that `id-kp-clientAuth` and `id-kp-serverAuth`
need to be used for the client side and the server side of TLS
authentication, respectively. For interoperability, a TCPCL end-entity
certificate [MAY]{.bcp14} contain an EKU with both `id-kp-clientAuth`
and `id-kp-serverAuth` values.[¶](#section-4.4.2-6){.pilcrow}

When allowed by CA policy, a TCPCL end-entity certificate
[SHOULD]{.bcp14} contain a PKIX key usage extension in accordance with
[Section
4.2.1.3](https://www.rfc-editor.org/rfc/rfc5280#section-4.2.1.3){.relref}
of \[[RFC5280](#RFC5280){.xref}\]. The PKIX key usage bit that is
consistent with TCPCL security using TLS 1.3 is digitalSignature. The
specific algorithms used during the TLS handshake will determine which
of those key uses are exercised. Earlier versions of TLS can mandate the
use of the keyEncipherment bit or the keyAgreement
bit.[¶](#section-4.4.2-7){.pilcrow}

When allowed by CA policy, a TCPCL end-entity certificate
[SHOULD]{.bcp14} contain an Online Certificate Status Protocol (OCSP)
URI within an authority information access extension in accordance with
[Section
4.2.2.1](https://www.rfc-editor.org/rfc/rfc5280#section-4.2.2.1){.relref}
of \[[RFC5280](#RFC5280){.xref}\].[¶](#section-4.4.2-8){.pilcrow}

::: {#sec-pkix-oids}
::: {#section-4.4.2.1 .section}
##### [4.4.2.1.](#section-4.4.2.1){.section-number .selfRef} [PKIX OID Allocations](#name-pkix-oid-allocations){.section-name .selfRef} {#name-pkix-oid-allocations}

This document defines a PKIX Other Name Form identifier,
`id-on-bundleEID`, in [Appendix B](#sec-asn1-mod){.xref}; this
identifier can be used as the `type-id` in a subjectAltName entry of
type otherName. The `BundleEID` value associated with the otherName
type-id `id-on-bundleEID` [SHALL]{.bcp14} be a URI, encoded as an
IA5String, with a scheme that is present in the IANA \"Bundle Protocol
URI Scheme Types\" registry \[[IANA-BUNDLE](#IANA-BUNDLE){.xref}\].
Although this Other Name Form allows any endpoint ID to be present, the
NODE-ID defined in [Section 4.4.1](#sec-tls-identification){.xref}
limits its use to contain only a node
ID.[¶](#section-4.4.2.1-1){.pilcrow}

This document defines a PKIX EKU key purpose, `id-kp-bundleSecurity`, in
[Appendix B](#sec-asn1-mod){.xref}; this purpose can be used to restrict
a certificate\'s use. The `id-kp-bundleSecurity` purpose can be combined
with other purposes in the same
certificate.[¶](#section-4.4.2.1-2){.pilcrow}
:::
:::
:::
:::

::: {#sec-tls-handshake}
::: {#section-4.4.3 .section}
#### [4.4.3.](#section-4.4.3){.section-number .selfRef} [TLS Handshake](#name-tls-handshake){.section-name .selfRef} {#name-tls-handshake}

The use of TLS is negotiated via the Contact Header, as described in
[Section 4.3](#sec-contact-negotiate){.xref}. After negotiating an
Enable TLS parameter of \"true\", and before any other TCPCL messages
are sent within the session, the session entities [SHALL]{.bcp14} begin
a TLS handshake in accordance with \[[RFC8446](#RFC8446){.xref}\]. By
convention, this protocol uses the entity that initiated the underlying
TCP connection (the active peer) as the \"client\" role of the TLS
handshake request.[¶](#section-4.4.3-1){.pilcrow}

The TLS handshake, if it occurs, is considered to be part of the contact
negotiation before the TCPCL session itself is established. Specifics
regarding exposure of sensitive data are discussed in [Section
7](#sec-security){.xref}.[¶](#section-4.4.3-2){.pilcrow}

The parameters within each TLS negotiation are implementation dependent
but any TCPCL entity [SHALL]{.bcp14} follow all recommended practices
specified in [BCP 195](#RFC7525){.xref} \[[RFC7525](#RFC7525){.xref}\],
or any updates or successors that become part of BCP 195. Within each
TLS handshake, the following requirements apply (using the rough order
in which they occur):[¶](#section-4.4.3-3){.pilcrow}

[]{.break}

ClientHello:

:   When a resolved DNS name was used to establish the TCP connection,
    the TLS ClientHello [SHOULD]{.bcp14} include a \"server_name\"
    extension in accordance with \[[RFC6066](#RFC6066){.xref}\]. When
    present, the server_name extension [SHALL]{.bcp14} contain a
    \"HostName\" value taken from the DNS name (of the passive entity)
    that was resolved.[¶](#section-4.4.3-4.2.1){.pilcrow}

    Note: The \"HostName\" in the server_name extension is the network
    name for the passive entity, not the node ID of that
    entity.[¶](#section-4.4.3-4.2.2.1){.pilcrow}

:   

Server Certificate:
:   The passive entity [SHALL]{.bcp14} supply a certificate within the
    TLS handshake to allow authentication of its side of the session.
    The supplied end-entity certificate [SHALL]{.bcp14} conform to the
    profile described in [Section
    4.4.2](#sec-tcpcl-cert-profile){.xref}. The passive entity
    [MAY]{.bcp14} use the SNI DNS name to choose an appropriate
    server-side certificate that authenticates that DNS
    name.[¶](#section-4.4.3-4.4){.pilcrow}
:   

Certificate Request:
:   During the TLS handshake, the passive entity [SHALL]{.bcp14} request
    a client-side certificate.[¶](#section-4.4.3-4.6){.pilcrow}
:   

Client Certificate:
:   The active entity [SHALL]{.bcp14} supply a certificate chain within
    the TLS handshake to allow authentication of its side of the
    session. The supplied end-entity certificate [SHALL]{.bcp14} conform
    to the profile described in [Section
    4.4.2](#sec-tcpcl-cert-profile){.xref}.[¶](#section-4.4.3-4.8){.pilcrow}
:   

If a TLS handshake cannot negotiate a TLS connection, both entities of
the TCPCL session [SHALL]{.bcp14} close the TCP connection. At this
point, the TCPCL session has not yet been established, so there is no
TCPCL session to terminate.[¶](#section-4.4.3-5){.pilcrow}

After a TLS connection is successfully established, the active entity
[SHALL]{.bcp14} send a SESS_INIT message to begin session negotiation.
This session negotiation and all subsequent messaging are
secured.[¶](#section-4.4.3-6){.pilcrow}
:::
:::

::: {#sec-tls-authentication}
::: {#section-4.4.4 .section}
#### [4.4.4.](#section-4.4.4){.section-number .selfRef} [TLS Authentication](#name-tls-authentication){.section-name .selfRef} {#name-tls-authentication}

Using PKIX certificates exchanged during the TLS handshake, each of the
entities can authenticate a peer node ID directly or authenticate the
peer DNS name or network address. The logic for handling certificates
and certificate data is separated into the following
phases:[¶](#section-4.4.4-1){.pilcrow}

1.  [Validating the certification path from the end-entity certificate
    up to a trusted root
    CA.[¶](#section-4.4.4-2.1){.pilcrow}]{#section-4.4.4-2.1}
2.  [Validating the EKU and other properties of the end-entity
    certificate.[¶](#section-4.4.4-2.2){.pilcrow}]{#section-4.4.4-2.2}
3.  [Authenticating identities from a valid end-entity
    certificate.[¶](#section-4.4.4-2.3){.pilcrow}]{#section-4.4.4-2.3}
4.  [Applying security policy to the result of each identity type
    authentication.[¶](#section-4.4.4-2.4){.pilcrow}]{#section-4.4.4-2.4}

The result of validating a peer identity (see [Section
4.4.1](#sec-tls-identification){.xref}) against one or more types of
certificate claims is one of the
following:[¶](#section-4.4.4-3){.pilcrow}

[]{.break}

Absent:
:   Indicating that no such claims are present in the certificate and
    the identity cannot be
    authenticated.[¶](#section-4.4.4-4.2){.pilcrow}
:   

Success:
:   Indicating that one or more such claims are present and at least one
    matches the peer identity value.[¶](#section-4.4.4-4.4){.pilcrow}
:   

Failure:
:   Indicating that one or more such claims are present and none match
    the peer identity.[¶](#section-4.4.4-4.6){.pilcrow}
:   

::: {#sec-tls-auth-valid-cert}
::: {#section-4.4.4.1 .section}
##### [4.4.4.1.](#section-4.4.4.1){.section-number .selfRef} [Certificate Path and Purpose Validation](#name-certificate-path-and-purpos){.section-name .selfRef} {#name-certificate-path-and-purpos}

For any peer end-entity certificate received during the TLS handshake,
the entity [SHALL]{.bcp14} perform the certification path validation
described in \[[RFC5280](#RFC5280){.xref}\] up to one of the entity\'s
trusted CA certificates. If enabled by local policy, the entity
[SHALL]{.bcp14} perform an OCSP check of each certificate providing OCSP
authority information in accordance with \[[RFC6960](#RFC6960){.xref}\].
If certificate validation fails or if security policy disallows a
certificate for any reason, the entity [SHALL]{.bcp14} fail the TLS
handshake with a \"bad_certificate\" alert. Leaving out part of the
certification chain can cause the entity to fail to validate a
certificate if the certificates that were left out are unknown to the
entity (see [Section
7.6](#sec-threat-untrust-cert){.xref}).[¶](#section-4.4.4.1-1){.pilcrow}

For the end-entity peer certificate received during the TLS handshake,
the entity [SHALL]{.bcp14} apply security policy to the key usage
extension (if present) and EKU extension (if present) in accordance with
Sections [4.2.1.12](https://www.rfc-editor.org/rfc/rfc5280#section-4.2.1.12){.relref}
and
[4.2.1.3](https://www.rfc-editor.org/rfc/rfc5280#section-4.2.1.3){.relref}
of \[[RFC5280](#RFC5280){.xref}\], respectively, and with the profile
discussed in [Section 4.4.2](#sec-tcpcl-cert-profile){.xref} of this
document.[¶](#section-4.4.4.1-2){.pilcrow}
:::
:::

::: {#sec-tls-auth-valid-netid}
::: {#section-4.4.4.2 .section}
##### [4.4.4.2.](#section-4.4.4.2){.section-number .selfRef} [Network-Level Authentication](#name-network-level-authenticatio){.section-name .selfRef} {#name-network-level-authenticatio}

Either during or immediately after the TLS handshake, each entity, if
required by security policy, [SHALL]{.bcp14} validate the following
certificate identifiers together in accordance with [Section
6](https://www.rfc-editor.org/rfc/rfc6125#section-6){.relref} of
\[[RFC6125](#RFC6125){.xref}\]:[¶](#section-4.4.4.2-1){.pilcrow}

-   [If the active entity resolved a DNS name (of the passive entity) in
    order to initiate the TCP connection, that DNS name [SHALL]{.bcp14}
    be used as a DNS-ID reference
    identifier.[¶](#section-4.4.4.2-2.1){.pilcrow}]{#section-4.4.4.2-2.1}
-   [The IP address of the other side of the TCP connection
    [SHALL]{.bcp14} be used as an IPADDR-ID reference
    identifier.[¶](#section-4.4.4.2-2.2){.pilcrow}]{#section-4.4.4.2-2.2}

If the network-level identifier\'s authentication result is Failure or
if the result is Absent and security policy requires an authenticated
network-level identifier, the entity [SHALL]{.bcp14} terminate the
session (with a reason code of \"Contact
Failure\").[¶](#section-4.4.4.2-3){.pilcrow}
:::
:::

::: {#sec-tls-auth-valid-nodeid}
::: {#section-4.4.4.3 .section}
##### [4.4.4.3.](#section-4.4.4.3){.section-number .selfRef} [Node ID Authentication](#name-node-id-authentication){.section-name .selfRef} {#name-node-id-authentication}

Immediately before session parameter negotiation, each entity, if
required by security policy, [SHALL]{.bcp14} validate the certificate
NODE-ID in accordance with [Section
6](https://www.rfc-editor.org/rfc/rfc6125#section-6){.relref} of
\[[RFC6125](#RFC6125){.xref}\] using the node ID of the peer\'s
SESS_INIT message as the NODE-ID reference identifier. If the NODE-ID
validation result is Failure or if the result is Absent and security
policy requires an authenticated node ID, the entity [SHALL]{.bcp14}
terminate the session (with a reason code of \"Contact
Failure\").[¶](#section-4.4.4.3-1){.pilcrow}
:::
:::
:::
:::

::: {#sec-tls-auth-policy-rec}
::: {#section-4.4.5 .section}
#### [4.4.5.](#section-4.4.5){.section-number .selfRef} [Policy Recommendations](#name-policy-recommendations){.section-name .selfRef} {#name-policy-recommendations}

A [RECOMMENDED]{.bcp14} security policy encompasses the
following:[¶](#section-4.4.5-1){.pilcrow}

-   [enabling the use of OCSP checking during the TLS
    handshake.[¶](#section-4.4.5-2.1){.pilcrow}]{#section-4.4.5-2.1}
-   [instructing that, if an EKU extension is present, the extension
    needs to contain `id-kp-bundleSecurity` ([Section
    4.4.2.1](#sec-pkix-oids){.xref}) to be usable with TCPCL
    security.[¶](#section-4.4.5-2.2){.pilcrow}]{#section-4.4.5-2.2}
-   [requiring a validated node ID ([Section
    4.4.4.3](#sec-tls-auth-valid-nodeid){.xref}) and ignoring any
    network-level identifier ([Section
    4.4.4.2](#sec-tls-auth-valid-netid){.xref}).[¶](#section-4.4.5-2.3){.pilcrow}]{#section-4.4.5-2.3}

This policy relies on and informs the certificate requirements provided
in [Section 4.4.3](#sec-tls-handshake){.xref}. This policy assumes that
a DTN-aware CA (see [Section 3.4](#sec-pkix-env){.xref}) will only issue
a certificate for a node ID when it has verified that the private key
holder actually controls the bundle node; this is needed to avoid the
threat identified in [Section
7.9](#sec-threat-node-impersonation){.xref}. This policy requires that a
certificate contain a NODE-ID and allows the certificate to also contain
network-level identifiers. A tailored policy on a more controlled
network could relax the requirement on node ID validation and allow just
network-level identifiers to authenticate a
peer.[¶](#section-4.4.5-3){.pilcrow}
:::
:::

::: {#section-4.4.6 .section}
#### [4.4.6.](#section-4.4.6){.section-number .selfRef} [Example TLS Initiation](#name-example-tls-initiation){.section-name .selfRef} {#name-example-tls-initiation}

A summary of a typical TLS initiation is shown in the sequence in
[Figure 17](#fig-tls-example){.xref} below. In this example, the active
peer terminates the session, but termination can be initiated from
either peer.[¶](#section-4.4.6-1){.pilcrow}

[]{#name-a-simple-visual-example-of-}

::: {#fig-tls-example}
::: {#section-4.4.6-2.1 .alignCenter .art-ascii-art .art-text .artwork}
             Entity A                             Entity B
            active peer                         passive peer

    +-------------------------+
    |  Open TCP Connection    | ->      +-------------------------+
    +-------------------------+      <- |    Accept Connection    |
                                        +-------------------------+
    +-------------------------+
    |     Contact Header      | ->      +-------------------------+
    +-------------------------+      <- |     Contact Header      |
                                        +-------------------------+

    +-------------------------+         +-------------------------+
    |     TLS Negotiation     | ->   <- |     TLS Negotiation     |
    |       (as client)       |         |       (as server)       |
    +-------------------------+         +-------------------------+

               DNS-ID and IPADDR-ID authentication occurs.
                   Secured TCPCL messaging can begin.

    +-------------------------+
    |        SESS_INIT        | ->      +-------------------------+
    +-------------------------+      <- |        SESS_INIT        |
                                        +-------------------------+

                      NODE-ID authentication occurs.
               Session is established, transfers can begin.

    +-------------------------+
    |       SESS_TERM         | ->      +-------------------------+
    +-------------------------+      <- |        SESS_TERM        |
                                        +-------------------------+
    +-------------------------+
    |    TLS Closure Alert    | ->      +-------------------------+
    +-------------------------+      <- |    TLS Closure Alert    |
                                        +-------------------------+
    +-------------------------+         +-------------------------+
    |        TCP Close        | ->   <- |        TCP Close        |
    +-------------------------+         +-------------------------+
:::

[Figure 17](#figure-17){.selfRef}: [A Simple Visual Example of TCPCL TLS
Establishment between Two
Entities](#name-a-simple-visual-example-of-){.selfRef}
:::
:::
:::
:::

::: {#sec-msg-header}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [Message Header](#name-message-header){.section-name .selfRef} {#name-message-header}

After the initial exchange of a Contact Header and (if TLS is negotiated
to be used) the TLS handshake, all messages transmitted over the session
are identified by a one-octet header with the following
structure:[¶](#section-4.5-1){.pilcrow}

[]{#name-format-of-the-message-heade}

::: {#fig-msg-header}
::: {#section-4.5-2.1 .alignCenter .art-ascii-art .art-text .artwork}
     0 1 2 3 4 5 6 7
    +---------------+
    | Message Type  |
    +---------------+
:::

[Figure 18](#figure-18){.selfRef}: [Format of the Message
Header](#name-format-of-the-message-heade){.selfRef}
:::

The Message Header contains the following
field:[¶](#section-4.5-3){.pilcrow}

[]{.break}

Message Type:
:   Indicates the type of the message as per [Table
    2](#tab-msg-types){.xref} below. Encoded values are listed in
    [Section
    8.5](#sec-iana-message-types){.xref}.[¶](#section-4.5-4.2){.pilcrow}
:   

[]{#name-tcpcl-message-types}

::: {#tab-msg-types}
  Name           Code   Description
  -------------- ------ ----------------------------------------------------------------------------------------------------------------------------------------------------------------
  SESS_INIT      0x07   Contains the session parameter inputs from one of the entities, as described in [Section 4.6](#sec-SESS_INIT){.xref}.
  SESS_TERM      0x05   Indicates that one of the entities participating in the session wishes to cleanly terminate the session, as described in [Section 6.1](#sec-SESS_TERM){.xref}.
  XFER_SEGMENT   0x01   Indicates the transmission of a segment of bundle data, as described in [Section 5.2.2](#sec-XFER_SEGMENT){.xref}.
  XFER_ACK       0x02   Acknowledges reception of a data segment, as described in [Section 5.2.3](#sec-XFER_ACK){.xref}.
  XFER_REFUSE    0x03   Indicates that the transmission of the current bundle [SHALL]{.bcp14} be stopped, as described in [Section 5.2.4](#sec-XFER_REFUSE){.xref}.
  KEEPALIVE      0x04   Used to keep the TCPCL session active, as described in [Section 5.1.1](#sec-KEEPALIVE){.xref}.
  MSG_REJECT     0x06   Contains a TCPCL message rejection, as described in [Section 5.1.2](#sec-MSG_REJECT){.xref}.

  : [Table 2](#table-2){.selfRef}: [TCPCL Message
  Types](#name-tcpcl-message-types){.selfRef}
:::
:::
:::

::: {#sec-SESS_INIT}
::: {#section-4.6 .section}
### [4.6.](#section-4.6){.section-number .selfRef} [Session Initialization Message (SESS_INIT)](#name-session-initialization-mess){.section-name .selfRef} {#name-session-initialization-mess}

Before a session is established and ready to transfer bundles, the
session parameters are negotiated between the connected entities. The
SESS_INIT message is used to convey the per-entity parameters, which are
used together to negotiate the per-session parameters as described in
[Section
4.7](#sec-session-negotiate){.xref}.[¶](#section-4.6-1){.pilcrow}

The format of a SESS_INIT message is shown in [Figure
19](#fig-msg-SESS_INIT-fields){.xref}.[¶](#section-4.6-2){.pilcrow}

[]{#name-sess_init-format}

::: {#fig-msg-SESS_INIT-fields}
::: {#section-4.6-3.1 .alignCenter .art-ascii-art .art-text .artwork}
    +-----------------------------+
    |       Message Header        |
    +-----------------------------+
    |   Keepalive Interval (U16)  |
    +-----------------------------+
    |       Segment MRU (U64)     |
    +-----------------------------+
    |      Transfer MRU (U64)     |
    +-----------------------------+
    |     Node ID Length (U16)    |
    +-----------------------------+
    |    Node ID Data (variable)  |
    +-----------------------------+
    |      Session Extension      |
    |      Items Length (U32)     |
    +-----------------------------+
    |      Session Extension      |
    |         Items (var.)        |
    +-----------------------------+
:::

[Figure 19](#figure-19){.selfRef}: [SESS_INIT
Format](#name-sess_init-format){.selfRef}
:::

The fields of the SESS_INIT message are as
follows:[¶](#section-4.6-4){.pilcrow}

[]{.break}

Keepalive Interval:
:   A 16-bit unsigned integer indicating the minimum interval, in
    seconds, to negotiate as the Session Keepalive using the method
    described in [Section
    4.7](#sec-session-negotiate){.xref}.[¶](#section-4.6-5.2){.pilcrow}
:   

Segment MRU:
:   A 64-bit unsigned integer indicating the largest allowable
    single-segment data payload size to be received in this session. Any
    XFER_SEGMENT sent to this peer [SHALL]{.bcp14} have a data payload
    no longer than the peer\'s Segment MRU. The two entities of a single
    session [MAY]{.bcp14} have different Segment MRUs, and no
    relationship between the two is
    required.[¶](#section-4.6-5.4){.pilcrow}
:   

Transfer MRU:
:   A 64-bit unsigned integer indicating the largest allowable
    total-bundle data size to be received in this session. Any bundle
    transfer sent to this peer [SHALL]{.bcp14} have a Total Bundle
    Length payload no longer than the peer\'s Transfer MRU. This value
    can be used to perform proactive bundle fragmentation. The two
    entities of a single session [MAY]{.bcp14} have different Transfer
    MRUs, and no relationship between the two is
    required.[¶](#section-4.6-5.6){.pilcrow}
:   

Node ID Length and Node ID Data:
:   Together, these fields represent a variable-length text string. The
    Node ID Length is a 16-bit unsigned integer indicating the number of
    octets of Node ID Data to follow. A zero-length node ID
    [SHALL]{.bcp14} be used to indicate the lack of a node ID rather
    than a truly empty node ID. This case allows an entity to avoid
    exposing node ID information on an untrusted network. A
    non-zero-length Node ID Data [SHALL]{.bcp14} contain the UTF-8
    encoded node ID of the entity that sent the SESS_INIT message. Every
    node ID [SHALL]{.bcp14} be a URI consistent with the requirements in
    \[[RFC3986](#RFC3986){.xref}\] and the URI schemes of the IANA
    \"Bundle Protocol URI Scheme Types\" registry
    \[[IANA-BUNDLE](#IANA-BUNDLE){.xref}\]. The node ID itself can be
    authenticated as described in [Section
    4.4.4](#sec-tls-authentication){.xref}.[¶](#section-4.6-5.8){.pilcrow}
:   

Session Extension Items Length and Session Extension Items list:  
:   ​ Together, these fields represent protocol extension data not
    defined by this specification. The Session Extension Items Length is
    the total number of octets to follow that are used to encode the
    Session Extension Items list. The encoding of each Session Extension
    Item is within a consistent data container as described in [Section
    4.8](#sec-session-extension){.xref}. The full set of Session
    Extension Items apply for the duration of the TCPCL session to
    follow. The order and multiplicity of these Session Extension Items
    are significant, as defined in the associated type specification(s).
    If the content of the Session Extension Items list disagrees with
    the Session Extension Items Length (e.g., the last item claims to
    use more or fewer octets than are indicated in the Session Extension
    Items Length), the reception of the SESS_INIT is considered to have
    failed.[¶](#section-4.6-5.10){.pilcrow}
:   

If an entity receives a peer node ID that is not authenticated (by the
procedure described in [Section
4.4.4.3](#sec-tls-auth-valid-nodeid){.xref}), that node ID [SHOULD
NOT]{.bcp14} be used by a BPA for any discovery or routing functions.
Trusting an unauthenticated node ID can lead to the threat described in
[Section
7.9](#sec-threat-node-impersonation){.xref}.[¶](#section-4.6-6){.pilcrow}

When the active entity initiates a TCPCL session, it is likely based on
routing information that binds a node ID to CL parameters used to
initiate the session. If the active entity receives a SESS_INIT with a
different node ID than was intended for the TCPCL session, the session
[MAY]{.bcp14} be allowed to be established. If allowed, such a session
[SHALL]{.bcp14} be associated with the node ID provided in the SESS_INIT
message rather than any intended value.[¶](#section-4.6-7){.pilcrow}
:::
:::

::: {#sec-session-negotiate}
::: {#section-4.7 .section}
### [4.7.](#section-4.7){.section-number .selfRef} [Session Parameter Negotiation](#name-session-parameter-negotiati){.section-name .selfRef} {#name-session-parameter-negotiati}

An entity calculates the parameters for a TCPCL session by negotiating
the values from its own preferences (conveyed by the SESS_INIT it sent
to the peer) with the preferences of the peer entity (expressed in the
SESS_INIT that it received from the peer). The negotiated parameters
defined by this specification are described in the following
paragraphs.[¶](#section-4.7-1){.pilcrow}

[]{.break}

Transfer MTU and Segment MTU:
:   The Maximum Transmission Unit (MTU) for whole transfers and
    individual segments is identical to the Transfer MRU and Segment
    MRU, respectively, of the received SESS_INIT message. A transmitting
    peer can send individual segments with any size smaller than the
    Segment MTU, depending on local policy, dynamic network conditions,
    etc. Determining the size of each transmitted segment is an
    implementation matter. If either the Transfer MRU or Segment MRU is
    unacceptable, the entity [SHALL]{.bcp14} terminate the session with
    a reason code of \"Contact Failure\".[¶](#section-4.7-2.2){.pilcrow}
:   

Session Keepalive:

:   Negotiation of the Session Keepalive parameter is performed by
    taking the minimum of the two Keepalive Interval values from the two
    SESS_INIT messages. The Session Keepalive Interval is a parameter
    for the behavior described in [Section
    5.1.1](#sec-KEEPALIVE){.xref}. If the Session Keepalive Interval is
    unacceptable, the entity [SHALL]{.bcp14} terminate the session with
    a reason code of \"Contact
    Failure\".[¶](#section-4.7-2.4.1){.pilcrow}

    Note: A negotiated Session Keepalive of zero indicates that
    KEEPALIVEs are disabled.[¶](#section-4.7-2.4.2.1){.pilcrow}

:   

Once this process of parameter negotiation is completed, this protocol
defines no additional mechanism to change the parameters of an
established session; to effect such a change, the TCPCL session
[MUST]{.bcp14} be terminated and a new session
established.[¶](#section-4.7-3){.pilcrow}
:::
:::

::: {#sec-session-extension}
::: {#section-4.8 .section}
### [4.8.](#section-4.8){.section-number .selfRef} [Session Extension Items](#name-session-extension-items){.section-name .selfRef} {#name-session-extension-items}

Each of the Session Extension Items [SHALL]{.bcp14} be encoded in an
identical Type-Length-Value (TLV) container form as indicated in [Figure
20](#fig-session-extension){.xref}.[¶](#section-4.8-1){.pilcrow}

The fields of the Session Extension Item are as
follows:[¶](#section-4.8-2){.pilcrow}

[]{.break}

Item Flags:
:   A one-octet field containing generic bit flags related to the Item,
    which are listed in [Table 3](#tab-session-extension-flags){.xref}.
    All reserved header flag bits [SHALL]{.bcp14} be set to 0 by the
    sender. All reserved header flag bits [SHALL]{.bcp14} be ignored by
    the receiver. If a TCPCL entity receives a Session Extension Item
    with an unknown Item Type and the `CRITICAL` flag set to 1, the
    entity [SHALL]{.bcp14} terminate the TCPCL session with a SESS_TERM
    reason code of \"Contact Failure\". If the `CRITICAL` flag is 0, an
    entity [SHALL]{.bcp14} skip over and ignore any item with an unknown
    Item Type.[¶](#section-4.8-3.2){.pilcrow}
:   

Item Type:
:   A 16-bit unsigned integer field containing the type of the extension
    item. This specification does not define any extension types
    directly but does create an IANA registry for such codes (see
    [Section
    8.3](#sec-iana-session-extension-type){.xref}).[¶](#section-4.8-3.4){.pilcrow}
:   

Item Length:
:   A 16-bit unsigned integer field containing the number of Item Value
    octets to follow.[¶](#section-4.8-3.6){.pilcrow}
:   

Item Value:
:   A variable-length data field that is interpreted according to the
    associated Item Type. This specification places no restrictions on
    an extension\'s use of available Item Value data. Extension
    specifications [SHOULD]{.bcp14} avoid the use of large data lengths,
    as no bundle transfers can begin until the full extension data is
    sent.[¶](#section-4.8-3.8){.pilcrow}
:   

[]{#name-session-extension-item-form}

::: {#fig-session-extension}
::: {#section-4.8-4.1 .alignCenter .art-ascii-art .art-text .artwork}
                         1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +---------------+---------------+---------------+---------------+
    |  Item Flags   |           Item Type           | Item Length...|
    +---------------+---------------+---------------+---------------+
    | length contd. | Item Value...                                 |
    +---------------+---------------+---------------+---------------+
:::

[Figure 20](#figure-20){.selfRef}: [Session Extension Item
Format](#name-session-extension-item-form){.selfRef}
:::

[]{#name-session-extension-item-flag}

::: {#tab-session-extension-flags}
  Name         Code     Description
  ------------ -------- ------------------------------------------------------------------------------------------
  `CRITICAL`   0x01     If this bit is set, it indicates that the receiving peer must handle the extension item.
  Reserved     others   

  : [Table 3](#table-3){.selfRef}: [Session Extension Item
  Flags](#name-session-extension-item-flag){.selfRef}
:::
:::
:::
:::
:::

::: {#sec-session}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Established Session Operation](#name-established-session-operati){.section-name .selfRef} {#name-established-session-operati}

This section describes the protocol operation for the duration of an
established session, including the mechanism for transmitting bundles
over the session.[¶](#section-5-1){.pilcrow}

::: {#sec-conn-upkeep}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Upkeep and Status Messages](#name-upkeep-and-status-messages){.section-name .selfRef} {#name-upkeep-and-status-messages}

::: {#sec-KEEPALIVE}
::: {#section-5.1.1 .section}
#### [5.1.1.](#section-5.1.1){.section-number .selfRef} [Session Upkeep (KEEPALIVE)](#name-session-upkeep-keepalive){.section-name .selfRef} {#name-session-upkeep-keepalive}

The protocol includes a provision for transmission of KEEPALIVE messages
over the TCPCL session to help determine if the underlying TCP
connection has been disrupted.[¶](#section-5.1.1-1){.pilcrow}

As described in [Section 4.7](#sec-session-negotiate){.xref}, a
negotiated parameter of each session is the Session Keepalive Interval.
If the negotiated Session Keepalive is zero (i.e., one or both SESS_INIT
messages contain a zero Keepalive Interval), then the keepalive feature
is disabled. There is no logical minimum value for the Keepalive
Interval (within the minimum imposed by the positive-value encoding),
but when used for many sessions on an open, shared network, a short
interval could lead to excessive traffic. For shared network use,
entities [SHOULD]{.bcp14} choose a Keepalive Interval no shorter than 30
seconds. There is no logical maximum value for the Keepalive Interval
(within the maximum imposed by the fixed-size encoding), but an idle TCP
connection is liable for closure by the host operating system if the
keepalive time is longer than tens of minutes. Entities [SHOULD]{.bcp14}
choose a Keepalive Interval no longer than 10 minutes (600
seconds).[¶](#section-5.1.1-2){.pilcrow}

The chosen Keepalive Interval [SHOULD NOT]{.bcp14} be too short, as TCP
retransmissions may occur in the case of packet loss. Those will have to
be triggered by a timeout (TCP retransmission timeout (RTO)), which is
dependent on the measured RTT for the TCP connection so that KEEPALIVE
messages can experience noticeable
latency.[¶](#section-5.1.1-3){.pilcrow}

The format of a KEEPALIVE message is a one-octet Message Type code of
KEEPALIVE (as described in [Table 2](#tab-msg-types){.xref}) with no
additional data. Both sides [SHALL]{.bcp14} send a KEEPALIVE message
whenever the negotiated interval has elapsed with no transmission of any
message (KEEPALIVE or other).[¶](#section-5.1.1-4){.pilcrow}

If no message (KEEPALIVE or other) has been received in a session after
some implementation-defined time duration, then the entity
[SHALL]{.bcp14} terminate the session by transmitting a SESS_TERM
message (as described in [Section 6.1](#sec-SESS_TERM){.xref}) with a
reason code of \"Idle timeout\". If configurable, the idle timeout
duration [SHOULD]{.bcp14} be no shorter than twice the Keepalive
Interval. If not configurable, the idle timeout duration
[SHOULD]{.bcp14} be exactly twice the Keepalive
Interval.[¶](#section-5.1.1-5){.pilcrow}
:::
:::

::: {#sec-MSG_REJECT}
::: {#section-5.1.2 .section}
#### [5.1.2.](#section-5.1.2){.section-number .selfRef} [Message Rejection (MSG_REJECT)](#name-message-rejection-msg_rejec){.section-name .selfRef} {#name-message-rejection-msg_rejec}

This message type is not expected to be seen in a well-functioning
session. Its purpose is to aid in troubleshooting bad entity behavior by
allowing the peer to observe why an entity is not responding as expected
to its messages.[¶](#section-5.1.2-1){.pilcrow}

If a TCPCL entity receives a message type that is unknown to it
(possibly due to an unhandled protocol version mismatch or an
incorrectly negotiated session extension that defines a new message
type), the entity [SHALL]{.bcp14} send a MSG_REJECT message with a
reason code of \"Message Type Unknown\" and close the TCP connection. If
a TCPCL entity receives a message type that is known but is
inappropriate for the negotiated session parameters (possibly due to an
incorrectly negotiated session extension), the entity [SHALL]{.bcp14}
send a MSG_REJECT message with a reason code of \"Message Unsupported\".
If a TCPCL entity receives a message that is inappropriate for the
current session state (e.g., a SESS_INIT after the session has already
been established or a XFER_ACK message with an unknown Transfer ID), the
entity [SHALL]{.bcp14} send a MSG_REJECT message with a reason code of
\"Message Unexpected\".[¶](#section-5.1.2-2){.pilcrow}

The format of a MSG_REJECT message is shown in [Figure
21](#fig-MSG_REJECT-fields){.xref}.[¶](#section-5.1.2-3){.pilcrow}

[]{#name-format-of-msg_reject-messag}

::: {#fig-MSG_REJECT-fields}
::: {#section-5.1.2-4.1 .alignCenter .art-ascii-art .art-text .artwork}
    +-----------------------------+
    |       Message Header        |
    +-----------------------------+
    |      Reason Code (U8)       |
    +-----------------------------+
    |   Rejected Message Header   |
    +-----------------------------+
:::

[Figure 21](#figure-21){.selfRef}: [Format of MSG_REJECT
Messages](#name-format-of-msg_reject-messag){.selfRef}
:::

The fields of the MSG_REJECT message are as
follows:[¶](#section-5.1.2-5){.pilcrow}

[]{.break}

Reason Code:
:   A one-octet refusal reason code interpreted according to the
    descriptions in [Table
    4](#tab-MSG_REJECT-reasons){.xref}.[¶](#section-5.1.2-6.2){.pilcrow}
:   

Rejected Message Header:
:   The Rejected Message Header is a copy of the Message Header to which
    the MSG_REJECT message is sent as a
    response.[¶](#section-5.1.2-6.4){.pilcrow}
:   

[]{#name-msg_reject-reason-codes}

::: {#tab-MSG_REJECT-reasons}
  Name                   Code   Description
  ---------------------- ------ ----------------------------------------------------------------------------------------------
  Message Type Unknown   0x01   A message was received with a Message Type code unknown to the TCPCL entity.
  Message Unsupported    0x02   A message was received, but the TCPCL entity cannot comply with the message contents.
  Message Unexpected     0x03   A message was received while the session is in a state in which the message is not expected.

  : [Table 4](#table-4){.selfRef}: [MSG_REJECT Reason
  Codes](#name-msg_reject-reason-codes){.selfRef}
:::
:::
:::
:::
:::

::: {#sec-transfer}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Bundle Transfer](#name-bundle-transfer){.section-name .selfRef} {#name-bundle-transfer}

All of the messages discussed in this section are directly associated
with transferring a bundle between TCPCL
entities.[¶](#section-5.2-1){.pilcrow}

A single TCPCL transfer results in the exchange of a bundle (handled by
the convergence layer as opaque data) between two entities. In the
TCPCL, a transfer is accomplished by dividing a single bundle up into
\"segments\" based on the receiving-side Segment MRU, which is defined
in [Section 4.6](#sec-SESS_INIT){.xref}. The choice of the length to use
for segments is an implementation matter, but each segment [MUST
NOT]{.bcp14} be larger than the receiving entity\'s Segment MRU. The
first segment for a bundle is indicated by the `START` flag, and the
last segment is indicated by the `END`
flag.[¶](#section-5.2-2){.pilcrow}

A single transfer (and, by extension, a single segment) [SHALL
NOT]{.bcp14} contain data of more than a single bundle. This requirement
is imposed on the agent using the TCPCL, rather than on the TCPCL
itself.[¶](#section-5.2-3){.pilcrow}

If multiple bundles are transmitted on a single TCPCL connection, they
[MUST]{.bcp14} be transmitted consecutively, without the interleaving of
segments from multiple bundles.[¶](#section-5.2-4){.pilcrow}

::: {#sec-transfer-id}
::: {#section-5.2.1 .section}
#### [5.2.1.](#section-5.2.1){.section-number .selfRef} [Bundle Transfer ID](#name-bundle-transfer-id){.section-name .selfRef} {#name-bundle-transfer-id}

Each of the bundle transfer messages contains a Transfer ID, which is
used to correlate messages (from both sides of a transfer) for each
bundle. A Transfer ID does not attempt to address uniqueness of the
bundle data itself and is not related to such concepts as bundle
fragmentation. Each invocation of the TCPCL by the BPA, requesting
transmission of a bundle (fragmentary or otherwise), results in the
initiation of a single TCPCL transfer. Each transfer entails the sending
of a sequence of some number of XFER_SEGMENT and XFER_ACK messages; all
are correlated by the same Transfer ID. The sending entity originates a
Transfer ID, and the receiving entity uses that same Transfer ID in
acknowledgments.[¶](#section-5.2.1-1){.pilcrow}

Transfer IDs from each entity [SHALL]{.bcp14} be unique within a single
TCPCL session. Upon exhaustion of the entire 64-bit Transfer ID space,
the sending entity [SHALL]{.bcp14} terminate the session with a
SESS_TERM reason code of \"Resource Exhaustion\". For bidirectional
bundle transfers, a TCPCL entity [SHOULD NOT]{.bcp14} rely on any
relationship between Transfer IDs originating from each side of the
TCPCL session.[¶](#section-5.2.1-2){.pilcrow}

Although there is not a strict requirement for initial Transfer ID
values or the ordering of Transfer IDs (see [Section
7.13](#sec-security-xferid){.xref}), in the absence of any other
mechanism for generating Transfer IDs, an entity [SHALL]{.bcp14} use the
following algorithm: the initial Transfer ID from each entity is zero,
and subsequent Transfer ID values are incremented from the prior
Transfer ID value by one.[¶](#section-5.2.1-3){.pilcrow}
:::
:::

::: {#sec-XFER_SEGMENT}
::: {#section-5.2.2 .section}
#### [5.2.2.](#section-5.2.2){.section-number .selfRef} [Data Transmission (XFER_SEGMENT)](#name-data-transmission-xfer_segm){.section-name .selfRef} {#name-data-transmission-xfer_segm}

Each bundle is transmitted in one or more data segments. The format of a
XFER_SEGMENT message is shown in [Figure
22](#fig-XFER_SEGMENT-fields){.xref}.[¶](#section-5.2.2-1){.pilcrow}

[]{#name-format-of-xfer_segment-mess}

::: {#fig-XFER_SEGMENT-fields}
::: {#section-5.2.2-2.1 .alignCenter .art-ascii-art .art-text .artwork}
    +------------------------------+
    |       Message Header         |
    +------------------------------+
    |     Message Flags (U8)       |
    +------------------------------+
    |      Transfer ID (U64)       |
    +------------------------------+
    |     Transfer Extension       |
    |      Items Length (U32)      |
    |   (only for START segment)   |
    +------------------------------+
    |     Transfer Extension       |
    |         Items (var.)         |
    |   (only for START segment)   |
    +------------------------------+
    |      Data length (U64)       |
    +------------------------------+
    | Data contents (octet string) |
    +------------------------------+
:::

[Figure 22](#figure-22){.selfRef}: [Format of XFER_SEGMENT
Messages](#name-format-of-xfer_segment-mess){.selfRef}
:::

The fields of the XFER_SEGMENT message are as
follows:[¶](#section-5.2.2-3){.pilcrow}

[]{.break}

Message Flags:
:   A one-octet field of single-bit flags, interpreted according to the
    descriptions in [Table 5](#tab-XFER_SEGMENT-flags){.xref}. All
    reserved header flag bits [SHALL]{.bcp14} be set to 0 by the sender.
    All reserved header flag bits [SHALL]{.bcp14} be ignored by the
    receiver.[¶](#section-5.2.2-4.2){.pilcrow}
:   

Transfer ID:
:   A 64-bit unsigned integer identifying the transfer being
    made.[¶](#section-5.2.2-4.4){.pilcrow}
:   

Transfer Extension Items Length and Transfer Extension Items list:
:   ​ Together, these fields represent protocol extension data for this
    specification. The Transfer Extension Items Length and Transfer
    Extension Items list [SHALL]{.bcp14} only be present when the
    `START` flag is set to 1 on the message. The Transfer Extension
    Items Length is the total number of octets to follow that are used
    to encode the Transfer Extension Items list. The encoding of each
    Transfer Extension Item is within a consistent data container, as
    described in [Section 5.2.5](#sec-transfer-extension){.xref}. The
    full set of Transfer Extension Items apply only to the associated
    single transfer. The order and multiplicity of these Transfer
    Extension Items are significant, as defined in the associated type
    specification(s). If the content of the Transfer Extension Items
    list disagrees with the Transfer Extension Items Length (e.g., the
    last item claims to use more or fewer octets than are indicated in
    the Transfer Extension Items Length), the reception of the
    XFER_SEGMENT is considered to have
    failed.[¶](#section-5.2.2-4.6){.pilcrow}
:   

Data length:
:   A 64-bit unsigned integer indicating the number of octets in Data
    contents to follow.[¶](#section-5.2.2-4.8){.pilcrow}
:   

Data contents:
:   The variable-length data payload of the
    message.[¶](#section-5.2.2-4.10){.pilcrow}
:   

[]{#name-xfer_segment-flags}

::: {#tab-XFER_SEGMENT-flags}
  Name       Code     Description
  ---------- -------- ----------------------------------------------------------------------------------
  `END`      0x01     If this bit is set, it indicates that this is the last segment of the transfer.
  `START`    0x02     If this bit is set, it indicates that this is the first segment of the transfer.
  Reserved   others   

  : [Table 5](#table-5){.selfRef}: [XFER_SEGMENT
  Flags](#name-xfer_segment-flags){.selfRef}
:::

The flags portion of the message contains two flag values in the two
low-order bits, denoted `START` and `END` in [Table
5](#tab-XFER_SEGMENT-flags){.xref}. The `START` flag [SHALL]{.bcp14} be
set to 1 when transmitting the first segment of a transfer. The `END`
flag [SHALL]{.bcp14} be set to 1 when transmitting the last segment of a
transfer. In the case where an entire transfer is accomplished in a
single segment, both the `START` flag and the `END` flag [SHALL]{.bcp14}
be set to 1.[¶](#section-5.2.2-6){.pilcrow}

Once a transfer of a bundle has commenced, the entity [MUST]{.bcp14}
only send segments containing sequential portions of that bundle until
it sends a segment with the `END` flag set to 1. No interleaving of
multiple transfers from the same entity is possible within a single
TCPCL session. Simultaneous transfers between two entities [MAY]{.bcp14}
be achieved using multiple TCPCL
sessions.[¶](#section-5.2.2-7){.pilcrow}
:::
:::

::: {#sec-XFER_ACK}
::: {#section-5.2.3 .section}
#### [5.2.3.](#section-5.2.3){.section-number .selfRef} [Data Acknowledgments (XFER_ACK)](#name-data-acknowledgments-xfer_a){.section-name .selfRef} {#name-data-acknowledgments-xfer_a}

Although the TCP transport provides reliable transfer of data between
transport peers, the typical BSD sockets interface provides no means to
inform a sending application of when the receiving application has
processed some amount of transmitted data. Thus, after transmitting some
data, the TCPCL needs an additional mechanism to determine whether the
receiving agent has successfully received and fully processed the
segment. To this end, the TCPCL protocol provides feedback messaging
whereby a receiving entity transmits acknowledgments of reception of
data segments.[¶](#section-5.2.3-1){.pilcrow}

The format of a XFER_ACK message is shown in [Figure
23](#fig-XFER_ACK-fields){.xref}.[¶](#section-5.2.3-2){.pilcrow}

[]{#name-format-of-xfer_ack-messages}

::: {#fig-XFER_ACK-fields}
::: {#section-5.2.3-3.1 .alignCenter .art-ascii-art .art-text .artwork}
    +-----------------------------+
    |       Message Header        |
    +-----------------------------+
    |     Message Flags (U8)      |
    +-----------------------------+
    |      Transfer ID (U64)      |
    +-----------------------------+
    | Acknowledged length (U64)   |
    +-----------------------------+
:::

[Figure 23](#figure-23){.selfRef}: [Format of XFER_ACK
Messages](#name-format-of-xfer_ack-messages){.selfRef}
:::

The fields of the XFER_ACK message are as
follows:[¶](#section-5.2.3-4){.pilcrow}

[]{.break}

Message Flags:
:   A one-octet field of single-bit flags, interpreted according to the
    descriptions in [Table 5](#tab-XFER_SEGMENT-flags){.xref}. All
    reserved header flag bits [SHALL]{.bcp14} be set to 0 by the sender.
    All reserved header flag bits [SHALL]{.bcp14} be ignored by the
    receiver.[¶](#section-5.2.3-5.2){.pilcrow}
:   

Transfer ID:
:   A 64-bit unsigned integer identifying the transfer being
    acknowledged.[¶](#section-5.2.3-5.4){.pilcrow}
:   

Acknowledged length:
:   A 64-bit unsigned integer indicating the total number of octets in
    the transfer that are being
    acknowledged.[¶](#section-5.2.3-5.6){.pilcrow}
:   

A receiving TCPCL entity [SHALL]{.bcp14} send a XFER_ACK message in
response to each received XFER_SEGMENT message after the segment has
been fully processed. The flags portion of the XFER_ACK header
[SHALL]{.bcp14} be set to match the corresponding XFER_SEGMENT message
being acknowledged (including flags not decodable to the entity). The
acknowledged length of each XFER_ACK contains the sum of the Data length
fields of all XFER_SEGMENT messages received so far in the course of the
indicated transfer. The sending entity [SHOULD]{.bcp14} transmit
multiple XFER_SEGMENT messages without waiting for the corresponding
XFER_ACK responses. This enables pipelining of messages on a transfer
stream.[¶](#section-5.2.3-6){.pilcrow}

For example, suppose the sending entity transmits four segments of
bundle data with lengths 100, 200, 500, and 1000, respectively. After
receiving the first segment, the entity sends an acknowledgment of
length 100. After the second segment is received, the entity sends an
acknowledgment of length 300. The third and fourth acknowledgments are
of lengths 800 and 1800, respectively.[¶](#section-5.2.3-7){.pilcrow}
:::
:::

::: {#sec-XFER_REFUSE}
::: {#section-5.2.4 .section}
#### [5.2.4.](#section-5.2.4){.section-number .selfRef} [Transfer Refusal (XFER_REFUSE)](#name-transfer-refusal-xfer_refus){.section-name .selfRef} {#name-transfer-refusal-xfer_refus}

The TCPCL supports a mechanism by which a receiving entity can indicate
to the sender that it does not want to receive the corresponding bundle.
To do so, upon receiving a XFER_SEGMENT message, the entity
[MAY]{.bcp14} transmit a XFER_REFUSE message. As data segments and
acknowledgments can cross on the wire, the bundle that is being refused
[SHALL]{.bcp14} be identified by the Transfer ID of the
refusal.[¶](#section-5.2.4-1){.pilcrow}

There is no required relationship between the Transfer MRU of a TCPCL
entity (which is supposed to represent a firm limitation of what the
entity will accept) and the sending of a XFER_REFUSE message. A
XFER_REFUSE can be used in cases where the agent\'s bundle storage is
temporarily depleted or somehow constrained. A XFER_REFUSE can also be
used after the bundle header or any bundle data is inspected by an agent
and determined to be unacceptable.[¶](#section-5.2.4-2){.pilcrow}

A transfer receiver [MAY]{.bcp14} send a XFER_REFUSE message as soon as
it receives any XFER_SEGMENT message. The transfer sender [MUST]{.bcp14}
be prepared for this and [MUST]{.bcp14} associate the refusal with the
correct bundle via the Transfer ID
fields.[¶](#section-5.2.4-3){.pilcrow}

The TCPCL itself does not have any required behavior related to
responding to a XFER_REFUSE based on its reason code; the refusal is
passed up as an indication to the BPA that the transfer has been
refused. If a transfer refusal has a reason code that is not decodable
to the BPA, the agent [SHOULD]{.bcp14} treat the refusal as having a
reason code of \"Unknown\".[¶](#section-5.2.4-4){.pilcrow}

The format of the XFER_REFUSE message is shown in [Figure
24](#fig-msg-XFER_REFUSE){.xref}.[¶](#section-5.2.4-5){.pilcrow}

[]{#name-format-of-xfer_refuse-messa}

::: {#fig-msg-XFER_REFUSE}
::: {#section-5.2.4-6.1 .alignCenter .art-ascii-art .art-text .artwork}
    +-----------------------------+
    |       Message Header        |
    +-----------------------------+
    |      Reason Code (U8)       |
    +-----------------------------+
    |      Transfer ID (U64)      |
    +-----------------------------+
:::

[Figure 24](#figure-24){.selfRef}: [Format of XFER_REFUSE
Messages](#name-format-of-xfer_refuse-messa){.selfRef}
:::

The fields of the XFER_REFUSE message are as
follows:[¶](#section-5.2.4-7){.pilcrow}

[]{.break}

Reason Code:
:   A one-octet refusal reason code interpreted according to the
    descriptions in [Table
    6](#tab-XFER_REFUSE-reasons){.xref}.[¶](#section-5.2.4-8.2){.pilcrow}
:   

Transfer ID:
:   A 64-bit unsigned integer identifying the transfer being
    refused.[¶](#section-5.2.4-8.4){.pilcrow}
:   

[]{#name-xfer_refuse-reason-codes}

::: {#tab-XFER_REFUSE-reasons}
  Name                  Code   Description
  --------------------- ------ -----------------------------------------------------------------------------------------------------------------------------------------------------------------
  Unknown               0x00   The reason for refusal is unknown or is not specified.
  Completed             0x01   The receiver already has the complete bundle. The sender [MAY]{.bcp14} consider the bundle as completely received.
  No Resources          0x02   The receiver\'s resources are exhausted. The sender [SHOULD]{.bcp14} apply reactive bundle fragmentation before retrying.
  Retransmit            0x03   The receiver has encountered a problem that requires the bundle to be retransmitted in its entirety.
  Not Acceptable        0x04   Some issue with the bundle data or the transfer extension data was encountered. The sender [SHOULD NOT]{.bcp14} retry the same bundle with the same extensions.
  Extension Failure     0x05   A failure processing the Transfer Extension Items has occurred.
  Session Terminating   0x06   The receiving entity is in the process of terminating the session. The sender [MAY]{.bcp14} retry the same bundle at a later time in a different session.

  : [Table 6](#table-6){.selfRef}: [XFER_REFUSE Reason
  Codes](#name-xfer_refuse-reason-codes){.selfRef}
:::

The receiver [MUST]{.bcp14}, for each transfer preceding the one to be
refused, have either acknowledged all XFER_SEGMENT messages or refused
the bundle transfer.[¶](#section-5.2.4-10){.pilcrow}

The bundle transfer refusal [MAY]{.bcp14} be sent before an entire data
segment is received. If a sender receives a XFER_REFUSE message, the
sender [MUST]{.bcp14} complete the transmission of any partially sent
XFER_SEGMENT message. There is no way to interrupt an individual TCPCL
message partway through sending it. The sender [MUST NOT]{.bcp14}
subsequently commence transmission of any further segments of the
refused bundle. Note, however, that this requirement does not ensure
that an entity will not receive another XFER_SEGMENT for the same bundle
after transmitting a XFER_REFUSE message, since messages can cross on
the wire; if this happens, subsequent segments of the bundle
[SHALL]{.bcp14} also be refused with a XFER_REFUSE
message.[¶](#section-5.2.4-11){.pilcrow}

Note: If a bundle transmission is aborted in this way, the receiver does
not receive a segment with the `END` flag set to 1 for the aborted
bundle. The beginning of the next bundle is identified by the `START`
flag set to 1, indicating the start of a new transfer, and with a
distinct Transfer ID value.[¶](#section-5.2.4-12.1){.pilcrow}
:::
:::

::: {#sec-transfer-extension}
::: {#section-5.2.5 .section}
#### [5.2.5.](#section-5.2.5){.section-number .selfRef} [Transfer Extension Items](#name-transfer-extension-items){.section-name .selfRef} {#name-transfer-extension-items}

Each of the Transfer Extension Items [SHALL]{.bcp14} be encoded in an
identical Type-Length-Value (TLV) container form as indicated in [Figure
25](#fig-transfer-extension){.xref}.[¶](#section-5.2.5-1){.pilcrow}

The fields of the Transfer Extension Item are as
follows:[¶](#section-5.2.5-2){.pilcrow}

[]{.break}

Item Flags:
:   A one-octet field containing generic bit flags related to the Item,
    which are listed in [Table 7](#tab-transfer-extension-flags){.xref}.
    All reserved header flag bits [SHALL]{.bcp14} be set to 0 by the
    sender. All reserved header flag bits [SHALL]{.bcp14} be ignored by
    the receiver. If a TCPCL entity receives a Transfer Extension Item
    with an unknown Item Type and the `CRITICAL` flag is 1, the entity
    [SHALL]{.bcp14} refuse the transfer with a XFER_REFUSE reason code
    of \"Extension Failure\". If the `CRITICAL` flag is 0, an entity
    [SHALL]{.bcp14} skip over and ignore any item with an unknown Item
    Type.[¶](#section-5.2.5-3.2){.pilcrow}
:   

Item Type:
:   A 16-bit unsigned integer field containing the type of the extension
    item. This specification creates an IANA registry for such codes
    (see [Section
    8.4](#sec-iana-transfer-extension-type){.xref}).[¶](#section-5.2.5-3.4){.pilcrow}
:   

Item Length:
:   A 16-bit unsigned integer field containing the number of Item Value
    octets to follow.[¶](#section-5.2.5-3.6){.pilcrow}
:   

Item Value:
:   A variable-length data field that is interpreted according to the
    associated Item Type. This specification places no restrictions on
    an extension\'s use of available Item Value data. Extension
    specifications [SHOULD]{.bcp14} avoid the use of large data lengths,
    as the associated transfer cannot begin until the full extension
    data is sent.[¶](#section-5.2.5-3.8){.pilcrow}
:   

[]{#name-transfer-extension-item-for}

::: {#fig-transfer-extension}
::: {#section-5.2.5-4.1 .alignCenter .art-ascii-art .art-text .artwork}
                         1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +---------------+---------------+---------------+---------------+
    |  Item Flags   |           Item Type           | Item Length...|
    +---------------+---------------+---------------+---------------+
    | length contd. | Item Value...                                 |
    +---------------+---------------+---------------+---------------+
:::

[Figure 25](#figure-25){.selfRef}: [Transfer Extension Item
Format](#name-transfer-extension-item-for){.selfRef}
:::

[]{#name-transfer-extension-item-fla}

::: {#tab-transfer-extension-flags}
  Name         Code     Description
  ------------ -------- ------------------------------------------------------------------------------------------
  `CRITICAL`   0x01     If this bit is set, it indicates that the receiving peer must handle the extension item.
  Reserved     others   

  : [Table 7](#table-7){.selfRef}: [Transfer Extension Item
  Flags](#name-transfer-extension-item-fla){.selfRef}
:::

::: {#sec-transfer-extension-transfer-length}
::: {#section-5.2.5.1 .section}
##### [5.2.5.1.](#section-5.2.5.1){.section-number .selfRef} [Transfer Length Extension](#name-transfer-length-extension){.section-name .selfRef} {#name-transfer-length-extension}

The purpose of the Transfer Length Extension is to allow entities to
preemptively refuse bundles that would exceed their resources or to
prepare storage on the receiving entity for the upcoming bundle
data.[¶](#section-5.2.5.1-1){.pilcrow}

Multiple Transfer Length Extension Items [SHALL NOT]{.bcp14} occur
within the same transfer. The lack of a Transfer Length Extension Item
in any transfer [SHALL NOT]{.bcp14} imply anything regarding the
potential length of the transfer. The Transfer Length Extension
[SHALL]{.bcp14} use the IANA-assigned code point from [Section
8.4](#sec-iana-transfer-extension-type){.xref}.[¶](#section-5.2.5.1-2){.pilcrow}

If a transfer occupies exactly one segment (i.e., both the `START` flag
and the `END` flag are 1), the Transfer Length Extension [SHOULD
NOT]{.bcp14} be present. The extension does not provide any additional
information for single-segment
transfers.[¶](#section-5.2.5.1-3){.pilcrow}

The format of the Transfer Length Extension data is shown in [Figure
26](#fig-Transfer-Length-fields){.xref}.[¶](#section-5.2.5.1-4){.pilcrow}

[]{#name-format-of-transfer-length-e}

::: {#fig-Transfer-Length-fields}
::: {#section-5.2.5.1-5.1 .alignCenter .art-ascii-art .art-text .artwork}
    +----------------------+
    |  Total Length (U64)  |
    +----------------------+
:::

[Figure 26](#figure-26){.selfRef}: [Format of Transfer Length Extension
Data](#name-format-of-transfer-length-e){.selfRef}
:::

The Transfer Length Extension data contains the following
field:[¶](#section-5.2.5.1-6){.pilcrow}

[]{.break}

Total Length:
:   A 64-bit unsigned integer indicating the size of the data to be
    transferred. The Total Length field [SHALL]{.bcp14} be treated as
    authoritative by the receiver. If, for whatever reason, the actual
    total length of bundle data received differs from the value
    indicated by the Total Length value, the receiver [SHALL]{.bcp14}
    treat the transmitted data as invalid and send a XFER_REFUSE with a
    reason code of \"Not
    Acceptable\".[¶](#section-5.2.5.1-7.2){.pilcrow}
:   
:::
:::
:::
:::
:::
:::
:::
:::

::: {#sec-termination}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Session Termination](#name-session-termination){.section-name .selfRef} {#name-session-termination}

This section describes the procedures for terminating a TCPCL session.
The purpose of terminating a session is to allow transfers to complete
before the TCP connection is closed but not allow any new transfers to
start. A session state change is necessary for this to happen, because
transfers can be in progress in either direction (transfer stream)
within a session. Waiting for a transfer to complete in one direction
does not control or influence the possibility of a transfer in the other
direction. Either peer of a session can terminate an established session
at any time.[¶](#section-6-1){.pilcrow}

::: {#sec-SESS_TERM}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Session Termination Message (SESS_TERM)](#name-session-termination-message){.section-name .selfRef} {#name-session-termination-message}

To cleanly terminate a session, a SESS_TERM message [SHALL]{.bcp14} be
transmitted by either entity at any point following complete
transmission of any other message. When sent to initiate a termination,
the `REPLY` flag of a SESS_TERM message [SHALL]{.bcp14} be 0. Upon
receiving a SESS_TERM message after not sending a SESS_TERM message in
the same session, an entity [SHALL]{.bcp14} send an acknowledging
SESS_TERM message. When sent to acknowledge a termination, a SESS_TERM
message [SHALL]{.bcp14} have identical data content from the message
being acknowledged except for the `REPLY` flag, which is set to 1 to
indicate acknowledgment.[¶](#section-6.1-1){.pilcrow}

Once a SESS_TERM message is sent, the state of that TCPCL session
changes to Ending. While the session is in the Ending
state,[¶](#section-6.1-2){.pilcrow}

-   [an entity [MAY]{.bcp14} finish an in-progress transfer in either
    direction.[¶](#section-6.1-3.1){.pilcrow}]{#section-6.1-3.1}
-   [an entity [SHALL NOT]{.bcp14} begin any new outgoing transfer for
    the remainder of the
    session.[¶](#section-6.1-3.2){.pilcrow}]{#section-6.1-3.2}
-   [an entity [SHALL NOT]{.bcp14} accept any new incoming transfer for
    the remainder of the
    session.[¶](#section-6.1-3.3){.pilcrow}]{#section-6.1-3.3}

If a new incoming transfer is attempted while in the Ending state, the
receiving entity [SHALL]{.bcp14} send a XFER_REFUSE with a reason code
of \"Session Terminating\".[¶](#section-6.1-4){.pilcrow}

There are circumstances where an entity has an urgent need to close a
TCP connection associated with a TCPCL session, without waiting for
transfers to complete but also in a way that doesn\'t force timeouts to
occur \-- for example, due to impending shutdown of the underlying
data-link layer. Instead of following a clean termination sequence,
after transmitting a SESS_TERM message, an entity [MAY]{.bcp14} perform
an unclean termination by immediately closing the associated TCP
connection. When performing an unclean termination, an entity
[SHOULD]{.bcp14} acknowledge all received XFER_SEGMENTs with a XFER_ACK
before closing the TCP connection. Not acknowledging received segments
can result in unnecessary bundle or bundle fragment retransmissions. Any
delay between a request to close the TCP connection and the actual
closing of the connection (a \"half-closed\" state) [MAY]{.bcp14} be
ignored by the TCPCL entity. If the underlying TCP connection is closed
during a transmission (in either transfer stream), the transfer
[SHALL]{.bcp14} be indicated to the BPA as failed (see the transmission
failure and reception failure indications defined in [Section
3.1](#sec-cl-services){.xref}).[¶](#section-6.1-5){.pilcrow}

The TCPCL itself does not have any required behavior related to
responding to a SESS_TERM based on its reason code; the termination is
passed up as an indication to the BPA that the session state has
changed. If a termination has a reason code that is not decodable to the
BPA, the agent [SHOULD]{.bcp14} treat the termination as having a reason
code of \"Unknown\".[¶](#section-6.1-6){.pilcrow}

The format of the SESS_TERM message is shown in [Figure
27](#fig-msg-SESS_TERM-fields){.xref}.[¶](#section-6.1-7){.pilcrow}

[]{#name-format-of-sess_term-message}

::: {#fig-msg-SESS_TERM-fields}
::: {#section-6.1-8.1 .alignCenter .art-ascii-art .art-text .artwork}
    +-----------------------------+
    |       Message Header        |
    +-----------------------------+
    |     Message Flags (U8)      |
    +-----------------------------+
    |      Reason Code (U8)       |
    +-----------------------------+
:::

[Figure 27](#figure-27){.selfRef}: [Format of SESS_TERM
Messages](#name-format-of-sess_term-message){.selfRef}
:::

The fields of the SESS_TERM message are as
follows:[¶](#section-6.1-9){.pilcrow}

[]{.break}

Message Flags:
:   A one-octet field of single-bit flags, interpreted according to the
    descriptions in [Table 8](#tab-SESS_TERM-flags){.xref}. All reserved
    header flag bits [SHALL]{.bcp14} be set to 0 by the sender. All
    reserved header flag bits [SHALL]{.bcp14} be ignored by the
    receiver.[¶](#section-6.1-10.2){.pilcrow}
:   

Reason Code:
:   A one-octet refusal reason code interpreted according to the
    descriptions in [Table
    9](#tab-SESS_TERM-reasons){.xref}.[¶](#section-6.1-10.4){.pilcrow}
:   

[]{#name-sess_term-flags}

::: {#tab-SESS_TERM-flags}
  Name       Code     Description
  ---------- -------- ----------------------------------------------------------------------------------------------------------
  `REPLY`    0x01     If this bit is set, it indicates that this message is an acknowledgment of an earlier SESS_TERM message.
  Reserved   others   

  : [Table 8](#table-8){.selfRef}: [SESS_TERM
  Flags](#name-sess_term-flags){.selfRef}
:::

[]{#name-sess_term-reason-codes}

::: {#tab-SESS_TERM-reasons}
  Name                  Code   Description
  --------------------- ------ --------------------------------------------------------------------------------
  Unknown               0x00   A termination reason is not available.
  Idle timeout          0x01   The session is being terminated due to idleness.
  Version mismatch      0x02   The entity cannot conform to the specified TCPCL protocol version.
  Busy                  0x03   The entity is too busy to handle the current session.
  Contact Failure       0x04   The entity cannot interpret or negotiate a Contact Header or SESS_INIT option.
  Resource Exhaustion   0x05   The entity has run into some resource limit and cannot continue the session.

  : [Table 9](#table-9){.selfRef}: [SESS_TERM Reason
  Codes](#name-sess_term-reason-codes){.selfRef}
:::

The earliest a TCPCL session termination [MAY]{.bcp14} occur is
immediately after transmission of a Contact Header (and prior to any
further message transmissions). This can, for example, be used as a
notification that the entity is currently not able or willing to
communicate. However, an entity [MUST]{.bcp14} always send the Contact
Header to its peer before sending a SESS_TERM
message.[¶](#section-6.1-13){.pilcrow}

Termination of the TCP connection [MAY]{.bcp14} occur prior to receiving
the Contact Header as discussed in [Section
4.1](#sec-tcp-connection){.xref}. If reception of the Contact Header
itself somehow fails (e.g., an invalid magic string is received), an
entity [SHALL]{.bcp14} close the TCP connection without sending a
SESS_TERM message.[¶](#section-6.1-14){.pilcrow}

If a session is to be terminated before the sending of a protocol
message has completed, then the entity [MUST NOT]{.bcp14} transmit the
SESS_TERM message but still [SHALL]{.bcp14} close the TCP connection.
Each TCPCL message is contiguous in the octet stream and has no ability
to be cut short and/or preempted by another message. This is
particularly important when large segment sizes are being transmitted;
either the entire XFER_SEGMENT is sent before a SESS_TERM message or the
connection is simply terminated
mid-XFER_SEGMENT.[¶](#section-6.1-15){.pilcrow}
:::
:::

::: {#sec-idle-terminate}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Idle Session Termination](#name-idle-session-termination){.section-name .selfRef} {#name-idle-session-termination}

The protocol includes a provision for clean termination of idle
sessions. Determining the length of time to wait before terminating idle
sessions, if they are to be terminated at all, is an implementation and
configuration matter.[¶](#section-6.2-1){.pilcrow}

If there is a configured time to terminate idle sessions and if no TCPCL
messages (other than KEEPALIVE messages) have been received for at least
that amount of time, then either entity [MAY]{.bcp14} terminate the
session by transmitting a SESS_TERM message with a reason code of \"Idle
timeout\" (as described in [Table
9](#tab-SESS_TERM-reasons){.xref}).[¶](#section-6.2-2){.pilcrow}
:::
:::
:::
:::

::: {#sec-security}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

This section separates security considerations into threat categories
based on guidance provided in [BCP 72](#RFC3552){.xref}
\[[RFC3552](#RFC3552){.xref}\].[¶](#section-7-1){.pilcrow}

::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Threat: Passive Leak of Node Data](#name-threat-passive-leak-of-node){.section-name .selfRef} {#name-threat-passive-leak-of-node}

When used without TLS security, the TCPCL exposes the node ID and other
configuration data to passive eavesdroppers. This occurs even when no
transfers occur within a TCPCL session. This can be avoided by always
using TLS, even if authentication is not available (see [Section
7.12](#sec-security-tlsalt){.xref}).[¶](#section-7.1-1){.pilcrow}
:::

::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Threat: Passive Leak of Bundle Data](#name-threat-passive-leak-of-bund){.section-name .selfRef} {#name-threat-passive-leak-of-bund}

The TCPCL can be used to provide point-to-point transport security, but
it does not provide security of data at rest and does not guarantee
end-to-end bundle security. The bundle security mechanisms defined in
\[[RFC9172](#RFC9172){.xref}\] are to be used
instead.[¶](#section-7.2-1){.pilcrow}

When used without TLS security, the TCPCL exposes all bundle data to
passive eavesdroppers. This can be avoided by always using TLS, even if
authentication is not available (see [Section
7.12](#sec-security-tlsalt){.xref}).[¶](#section-7.2-2){.pilcrow}
:::

::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Threat: TCPCL Version Downgrade](#name-threat-tcpcl-version-downgr){.section-name .selfRef} {#name-threat-tcpcl-version-downgr}

When a TCPCL entity supports multiple versions of the protocol, it is
possible for a malicious or misconfigured peer to use an older version
of the TCPCL protocol that does not support transport security. An
on-path attacker can also manipulate a Contact Header to present a lower
protocol version than desired.[¶](#section-7.3-1){.pilcrow}

It is up to security policies within each TCPCL entity to ensure that
the negotiated TCPCL version meets transport security
requirements.[¶](#section-7.3-2){.pilcrow}
:::

::: {#sec-threat-tls-strip}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [Threat: Transport Security Stripping](#name-threat-transport-security-s){.section-name .selfRef} {#name-threat-transport-security-s}

When security policy allows non-TLS sessions, the TCPCL does not protect
against active network attackers. It is possible for an on-path attacker
to set the `CAN_TLS` flag to 0 on either side of the Contact Header
exchange, which will cause the negotiation discussed in [Section
4.3](#sec-contact-negotiate){.xref} to disable TLS. This leads to the
\"SSL Stripping\" attack described in
\[[RFC7457](#RFC7457){.xref}\].[¶](#section-7.4-1){.pilcrow}

The purpose of the `CAN_TLS` flag is to allow the use of the TCPCL on
entities that simply do not have a TLS implementation available. When
TLS is available on an entity, it is strongly encouraged that the
security policy disallow non-TLS sessions. This requires that the TLS
handshake occur, regardless of the policy-driven parameters of the
handshake and policy-driven handling of the handshake
outcome.[¶](#section-7.4-2){.pilcrow}

One mechanism to mitigate the possibility of TLS Stripping is the use of
DNS-based Authentication of Named Entities (DANE)
\[[RFC6698](#RFC6698){.xref}\] toward the passive peer. This mechanism
relies on DNS and is unidirectional, so it doesn\'t help with applying
policy toward the active peer, but it can be useful in an environment
using opportunistic security. The configuration and use of DANE are
outside of the scope of this document.[¶](#section-7.4-3){.pilcrow}

The negotiated use of TLS is identical in behavior to the use of
STARTTLS as described in \[[RFC2595](#RFC2595){.xref}\],
\[[RFC4511](#RFC4511){.xref}\], and others.[¶](#section-7.4-4){.pilcrow}
:::
:::

::: {#section-7.5 .section}
### [7.5.](#section-7.5){.section-number .selfRef} [Threat: Weak TLS Configurations](#name-threat-weak-tls-configurati){.section-name .selfRef} {#name-threat-weak-tls-configurati}

Even when using TLS to secure the TCPCL session, the actual cipher suite
negotiated between the TLS peers can be insecure. Recommendations for
using cipher suites are included in [BCP 195](#RFC7525){.xref}
\[[RFC7525](#RFC7525){.xref}\]. It is up to security policies within
each TCPCL entity to ensure that the negotiated TLS cipher suite meets
transport security requirements.[¶](#section-7.5-1){.pilcrow}
:::

::: {#sec-threat-untrust-cert}
::: {#section-7.6 .section}
### [7.6.](#section-7.6){.section-number .selfRef} [Threat: Untrusted End-Entity Certificate](#name-threat-untrusted-end-entity){.section-name .selfRef} {#name-threat-untrusted-end-entity}

The authentication method discussed in [Section
4.4.4](#sec-tls-authentication){.xref} uses end-entity certificates
chained to a trusted root CA. During a TLS handshake, either entity can
send a certificate set that does not contain the full chain, possibly
excluding intermediate or root CAs. In an environment where peers are
known to already contain needed root and intermediate CAs, there is no
need to include those CAs, but this carries the risk of an entity not
actually having one of the needed CAs.[¶](#section-7.6-1){.pilcrow}
:::
:::

::: {#section-7.7 .section}
### [7.7.](#section-7.7){.section-number .selfRef} [Threat: Certificate Validation Vulnerabilities](#name-threat-certificate-validati){.section-name .selfRef} {#name-threat-certificate-validati}

Even when TLS itself is operating properly, an attacker can attempt to
exploit vulnerabilities within certificate check algorithms or
configuration to establish a secure TCPCL session using an invalid
certificate. A BPA treats the peer node ID within a TCPCL session as
authoritative, and exploitation via an invalid certificate could lead to
bundle data leaking and/or denial of service to the node ID being
impersonated.[¶](#section-7.7-1){.pilcrow}

There are many reasons, as described in \[[RFC5280](#RFC5280){.xref}\]
and \[[RFC6125](#RFC6125){.xref}\], why a certificate can fail to
validate, including using the certificate outside of its valid time
interval, using purposes for which it was not authorized, or using it
after it has been revoked by its CA. Validating a certificate is a
complex task and can require network connectivity outside of the primary
TCPCL network path(s) if a mechanism such as OCSP
\[[RFC6960](#RFC6960){.xref}\] is used by the CA. The configuration and
use of particular certificate validation methods are outside of the
scope of this document.[¶](#section-7.7-2){.pilcrow}
:::

::: {#section-7.8 .section}
### [7.8.](#section-7.8){.section-number .selfRef} [Threat: Symmetric Key Limits](#name-threat-symmetric-key-limits){.section-name .selfRef} {#name-threat-symmetric-key-limits}

Even with a secure block cipher and securely established session keys,
there are limits to the amount of plaintext that can be safely encrypted
with a given set of keys, as described in
\[[AEAD-LIMITS](#AEAD-LIMITS){.xref}\]. When permitted by the negotiated
TLS version (see \[[RFC8446](#RFC8446){.xref}\]), it is advisable to
take advantage of session key updates to avoid those
limits.[¶](#section-7.8-1){.pilcrow}
:::

::: {#sec-threat-node-impersonation}
::: {#section-7.9 .section}
### [7.9.](#section-7.9){.section-number .selfRef} [Threat: BP Node Impersonation](#name-threat-bp-node-impersonatio){.section-name .selfRef} {#name-threat-bp-node-impersonatio}

The certificates exchanged by TLS enable authentication of the peer DNS
name and node ID, but it is possible that either a peer does not provide
a valid certificate or the certificate does not validate either the
DNS-ID/IPADDR-ID or NODE-ID of the peer (see [Section
3.4](#sec-pkix-env){.xref}). Having a CA-validated certificate does not
alone guarantee the identity of the network host or BP node from which
the certificate is provided; additional validation procedures as
provided in [Section 4.4.4](#sec-tls-authentication){.xref} bind the
DNS-ID/IPADDR-ID or NODE-ID based on the contents of the
certificate.[¶](#section-7.9-1){.pilcrow}

The DNS-ID/IPADDR-ID validation is a weaker form of authentication,
because even if a peer is operating on an authenticated network DNS name
or IP address it can provide an invalid node ID and cause bundles to be
\"leaked\" to an invalid node. Especially in DTN environments, network
names and addresses of nodes can be time-variable, so binding a
certificate to a node ID results in a more stable
identity.[¶](#section-7.9-2){.pilcrow}

NODE-ID validation ensures that the peer to which a bundle is
transferred is in fact the node that the BPA expects it to be. In
circumstances where certificates can only be issued to DNS names, node
ID validation is not possible, but it could be reasonable to assume that
a trusted host is not going to present an invalid node ID. Determining
when a DNS-ID/IPADDR-ID authentication can be trusted to validate a node
ID is also a policy matter outside of the scope of this
document.[¶](#section-7.9-3){.pilcrow}

One mitigation regarding arbitrary entities with valid PKIX certificates
impersonating arbitrary node IDs is the use of the PKIX EKU key purpose
`id-kp-bundleSecurity` ([Section 4.4.2.1](#sec-pkix-oids){.xref}). When
this EKU is present in the certificate, it represents a stronger
assertion that the private key holder should in fact be trusted to
operate as a bundle node.[¶](#section-7.9-4){.pilcrow}
:::
:::

::: {#section-7.10 .section}
### [7.10.](#section-7.10){.section-number .selfRef} [Threat: Denial of Service](#name-threat-denial-of-service){.section-name .selfRef} {#name-threat-denial-of-service}

The behaviors described in this section all amount to a potential denial
of service to a TCPCL entity. The denial of service could be limited to
an individual TCPCL session, could affect other well-behaved sessions on
an entity, or could affect all sessions on a
host.[¶](#section-7.10-1){.pilcrow}

A malicious entity can trigger timeouts by continually establishing
TCPCL sessions and delaying the sending of protocol-required data. The
victim entity can block TCP connections from network peers that are
thought to behave incorrectly within the
TCPCL.[¶](#section-7.10-2){.pilcrow}

An entity can send a large amount of data over a TCPCL session,
requiring the receiving entity to handle the data. The victim entity can
attempt to stop the flood of data by sending a XFER_REFUSE message or
can forcibly terminate the session.[¶](#section-7.10-3){.pilcrow}

A \"data dribble\" attack is also possible, in which an entity presents
a very small Segment MRU that causes transfers to be split among a large
number of very small segments and causes the resultant segmentation
overhead to overwhelm the actual bundle data segments. Similarly, an
entity can present a very small Transfer MRU that will cause resources
to be wasted on establishment and upkeep of a TCPCL session over which a
bundle could never be transferred. The victim entity can terminate the
session during parameter negotiation ([Section
4.7](#sec-session-negotiate){.xref}) if the MRUs are
unacceptable.[¶](#section-7.10-4){.pilcrow}

An abusive entity could cause the keepalive mechanism to waste
throughput within a network link that would otherwise be usable for
bundle transmissions. Due to the quantization of the Keepalive Interval
parameter, the smallest Session Keepalive is one second, which should be
long enough to not flood the link. The victim entity can terminate the
session during parameter negotiation ([Section
4.7](#sec-session-negotiate){.xref}) if the Keepalive Interval is
unacceptable.[¶](#section-7.10-5){.pilcrow}

Finally, an attacker or a misconfigured entity can cause issues at the
TCP connection that will cause unnecessary TCP retransmissions or
connection resets, effectively denying the use of the overlying TCPCL
session.[¶](#section-7.10-6){.pilcrow}
:::

::: {#sec-security-tls-mandate}
::: {#section-7.11 .section}
### [7.11.](#section-7.11){.section-number .selfRef} [Mandatory-to-Implement TLS](#name-mandatory-to-implement-tls){.section-name .selfRef} {#name-mandatory-to-implement-tls}

Following IETF best current practice, TLS is mandatory to implement for
all TCPCL implementations but TLS is optional to use for a given TCPCL
session. The policy recommendations in
Sections [4.2](#sec-contact-header){.xref} and
[4.3](#sec-contact-negotiate){.xref} both enable TLS and require TLS,
but entities are permitted to disable and not require TLS based on local
configuration. The configuration to enable or require TLS for an entity
or a session is outside of the scope of this document. The configuration
to disable TLS is different from the threat of TLS Stripping as
described in [Section
7.4](#sec-threat-tls-strip){.xref}.[¶](#section-7.11-1){.pilcrow}
:::
:::

::: {#sec-security-tlsalt}
::: {#section-7.12 .section}
### [7.12.](#section-7.12){.section-number .selfRef} [Alternate Uses of TLS](#name-alternate-uses-of-tls){.section-name .selfRef} {#name-alternate-uses-of-tls}

This specification makes use of PKIX certificate validation and
authentication within TLS. There are alternate uses of TLS that are not
necessarily incompatible with the security goals of this specification
but that are outside of the scope of this document. The following
subsections give examples of alternate TLS
uses.[¶](#section-7.12-1){.pilcrow}

::: {#sec-security-tlsnoauth}
::: {#section-7.12.1 .section}
#### [7.12.1.](#section-7.12.1){.section-number .selfRef} [TLS without Authentication](#name-tls-without-authentication){.section-name .selfRef} {#name-tls-without-authentication}

In environments where PKI is available but there are restrictions on the
issuance of certificates (including the contents of certificates), it
may be possible to make use of TLS in a way that authenticates only the
passive entity of a TCPCL session or that does not authenticate either
entity. Using TLS in a way that does not successfully authenticate some
claim of both peer entities of a TCPCL session is outside of the scope
of this document but does have properties similar to the opportunistic
security model
\[[RFC7435](#RFC7435){.xref}\].[¶](#section-7.12.1-1){.pilcrow}
:::
:::

::: {#sec-security-tlsnopki}
::: {#section-7.12.2 .section}
#### [7.12.2.](#section-7.12.2){.section-number .selfRef} [Non-certificate TLS Use](#name-non-certificate-tls-use){.section-name .selfRef} {#name-non-certificate-tls-use}

In environments where PKI is unavailable, alternate uses of TLS that do
not require certificates such as pre-shared key (PSK) authentication
\[[RFC5489](#RFC5489){.xref}\] and the use of raw public keys
\[[RFC7250](#RFC7250){.xref}\] are available and can be used to ensure
confidentiality within the TCPCL. Using non-PKI node authentication
methods is outside of the scope of this
document.[¶](#section-7.12.2-1){.pilcrow}
:::
:::
:::
:::

::: {#sec-security-xferid}
::: {#section-7.13 .section}
### [7.13.](#section-7.13){.section-number .selfRef} [Predictability of Transfer IDs](#name-predictability-of-transfer-){.section-name .selfRef} {#name-predictability-of-transfer-}

The only requirement on Transfer IDs is that they be unique within each
session from the sending peer only. The trivial algorithm of the first
transfer starting at zero and later transfers incrementing by one causes
absolutely predictable Transfer IDs. Even when a TCPCL session is not
TLS secured and there is an on-path attacker causing denial of service
with XFER_REFUSE messages, it is not possible to preemptively refuse a
transfer, so there is no benefit in having unpredictable Transfer IDs
within a session.[¶](#section-7.13-1){.pilcrow}
:::
:::
:::
:::

::: {#sec-iana}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

Registration procedures referred to in this section (e.g., the RFC
Required policy) are defined in
\[[RFC8126](#RFC8126){.xref}\].[¶](#section-8-1){.pilcrow}

Some of the registries have been defined as version specific for
TCPCLv4, and these registries reuse some or all codepoints from TCPCLv3.
This was done to disambiguate the use of these codepoints between
TCPCLv3 and TCPCLv4 while preserving the semantics of some of the
codepoints.[¶](#section-8-2){.pilcrow}

::: {#sec-iana-port}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Port Number](#name-port-number){.section-name .selfRef} {#name-port-number}

Within the \"Service Name and Transport Protocol Port Number Registry\"
\[[IANA-PORTS](#IANA-PORTS){.xref}\], TCP port number 4556 had
previously been assigned as the default port for the TCPCL; see
\[[RFC7242](#RFC7242){.xref}\]. This assignment is unchanged by TCPCL
version 4, but the assignment reference has been updated to point to
this specification. Each TCPCL entity identifies its TCPCL protocol
version in its initial contact (see
Sections [3.2](#sec-protocol-session){.xref} and
[8.2](#sec-iana-protonum){.xref}), so there is no ambiguity regarding
what protocol is being used. The related assignments for UDP and DCCP
port 4556 (both registered by \[[RFC7122](#RFC7122){.xref}\]) are
unchanged.[¶](#section-8.1-1){.pilcrow}

[]{#name-tcp-port-number-for-the-tcp}

  Parameter                Value
  ------------------------ ----------------------------
  Service Name:            dtn-bundle
  Transport Protocol(s):   TCP
  Assignee:                IESG (iesg\@ietf.org)
  Contact:                 IESG (iesg\@ietf.org)
  Description:             DTN Bundle TCP CL Protocol
  Reference:               This specification
  Port Number:             4556

  : [Table 10](#table-10){.selfRef}: [TCP Port Number for the
  TCPCL](#name-tcp-port-number-for-the-tcp){.selfRef}
:::
:::

::: {#sec-iana-protonum}
::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Protocol Versions](#name-protocol-versions){.section-name .selfRef} {#name-protocol-versions}

IANA has registered the following value in the \"Bundle Protocol TCP
Convergence-Layer Version Numbers\" registry
\[[RFC7242](#RFC7242){.xref}\].[¶](#section-8.2-1){.pilcrow}

[]{#name-new-tcpcl-version-number}

  Value   Description   Reference
  ------- ------------- --------------------
  4       TCPCLv4       This specification

  : [Table 11](#table-11){.selfRef}: [New TCPCL Version
  Number](#name-new-tcpcl-version-number){.selfRef}
:::
:::

::: {#sec-iana-session-extension-type}
::: {#section-8.3 .section}
### [8.3.](#section-8.3){.section-number .selfRef} [Session Extension Types](#name-session-extension-types){.section-name .selfRef} {#name-session-extension-types}

Under the \"Bundle Protocol\" registry
\[[IANA-BUNDLE](#IANA-BUNDLE){.xref}\], IANA has created the \"Bundle
Protocol TCP Convergence-Layer Version 4 Session Extension Types\"
registry and populated it with the contents of [Table
12](#tab-iana-session-extension-type){.xref}. The registration procedure
is Expert Review within the lower range 0x0001-0x7FFF. Values in the
range 0x8000-0xFFFF are reserved for Private or Experimental Use, which
are not recorded by IANA.[¶](#section-8.3-1){.pilcrow}

Specifications of new session extension types need to define the
encoding of the Item Value data as well as any meaning or restriction on
the number of or order of instances of the type within an extension item
list. Specifications need to define how the extension functions when no
instance of the new extension type is received during session
negotiation.[¶](#section-8.3-2){.pilcrow}

Experts are encouraged to be biased towards approving registrations
unless they are abusive, frivolous, or actively harmful (not merely
esthetically displeasing or architecturally
dubious).[¶](#section-8.3-3){.pilcrow}

[]{#name-session-extension-type-code}

::: {#tab-iana-session-extension-type}
  Code            Session Extension Type
  --------------- ------------------------------------------
  0x0000          Reserved
  0x0001-0x7FFF   Unassigned
  0x8000-0xFFFF   Reserved for Private or Experimental Use

  : [Table 12](#table-12){.selfRef}: [Session Extension Type
  Codes](#name-session-extension-type-code){.selfRef}
:::
:::
:::

::: {#sec-iana-transfer-extension-type}
::: {#section-8.4 .section}
### [8.4.](#section-8.4){.section-number .selfRef} [Transfer Extension Types](#name-transfer-extension-types){.section-name .selfRef} {#name-transfer-extension-types}

Under the \"Bundle Protocol\" registry
\[[IANA-BUNDLE](#IANA-BUNDLE){.xref}\], IANA has created the \"Bundle
Protocol TCP Convergence-Layer Version 4 Transfer Extension Types\"
registry and populated it with the contents of [Table
13](#tab-iana-transfer-extension-type){.xref}. The registration
procedure is Expert Review within the lower range 0x0001-0x7FFF. Values
in the range 0x8000-0xFFFF are reserved for Private or Experimental Use,
which are not recorded by IANA.[¶](#section-8.4-1){.pilcrow}

Specifications of new transfer extension types need to define the
encoding of the Item Value data as well as any meaning or restriction on
the number of or order of instances of the type within an extension item
list. Specifications need to define how the extension functions when no
instance of the new extension type is received in a
transfer.[¶](#section-8.4-2){.pilcrow}

Experts are encouraged to be biased towards approving registrations
unless they are abusive, frivolous, or actively harmful (not merely
esthetically displeasing or architecturally
dubious).[¶](#section-8.4-3){.pilcrow}

[]{#name-transfer-extension-type-cod}

::: {#tab-iana-transfer-extension-type}
  Code            Transfer Extension Type
  --------------- ------------------------------------------
  0x0000          Reserved
  0x0001          Transfer Length Extension
  0x0002-0x7FFF   Unassigned
  0x8000-0xFFFF   Reserved for Private or Experimental Use

  : [Table 13](#table-13){.selfRef}: [Transfer Extension Type
  Codes](#name-transfer-extension-type-cod){.selfRef}
:::
:::
:::

::: {#sec-iana-message-types}
::: {#section-8.5 .section}
### [8.5.](#section-8.5){.section-number .selfRef} [Message Types](#name-message-types){.section-name .selfRef} {#name-message-types}

Under the \"Bundle Protocol\" registry
\[[IANA-BUNDLE](#IANA-BUNDLE){.xref}\], IANA has created the \"Bundle
Protocol TCP Convergence-Layer Version 4 Message Types\" registry and
populated it with the contents of [Table
14](#tab-iana-message-types){.xref}. The registration procedure is RFC
Required within the lower range 0x01-0xEF. Values in the range 0xF0-0xFF
are reserved for Private or Experimental Use, which are not recorded by
IANA.[¶](#section-8.5-1){.pilcrow}

Specifications of new message types need to define the encoding of the
message data as well as the purpose and relationship of the new message
to existing session/transfer state within the baseline message
sequencing. The use of new message types needs to be negotiated between
TCPCL entities within a session (using the session extension mechanism)
so that the receiving entity can properly decode all message types used
in the session.[¶](#section-8.5-2){.pilcrow}

Experts are encouraged to favor new session/transfer extension types
over new message types. TCPCL messages are not self-delimiting, so care
must be taken in introducing new message types. If an entity receives an
unknown message type, the only thing that can be done is to send a
MSG_REJECT and close the TCP connection; not even a clean termination
can be done at that point.[¶](#section-8.5-3){.pilcrow}

[]{#name-message-type-codes}

::: {#tab-iana-message-types}
  Code        Message Type
  ----------- ------------------------------------------
  0x00        Reserved
  0x01        XFER_SEGMENT
  0x02        XFER_ACK
  0x03        XFER_REFUSE
  0x04        KEEPALIVE
  0x05        SESS_TERM
  0x06        MSG_REJECT
  0x07        SESS_INIT
  0x08-0xEF   Unassigned
  0xF0-0xFF   Reserved for Private or Experimental Use

  : [Table 14](#table-14){.selfRef}: [Message Type
  Codes](#name-message-type-codes){.selfRef}
:::
:::
:::

::: {#sec-iana-XFER_REFUSE-codes}
::: {#section-8.6 .section}
### [8.6.](#section-8.6){.section-number .selfRef} [XFER_REFUSE Reason Codes](#name-xfer_refuse-reason-codes-2){.section-name .selfRef} {#name-xfer_refuse-reason-codes-2}

Under the \"Bundle Protocol\" registry
\[[IANA-BUNDLE](#IANA-BUNDLE){.xref}\], IANA has created the \"Bundle
Protocol TCP Convergence-Layer Version 4 XFER_REFUSE Reason Codes\"
registry and populated it with the contents of [Table
15](#tab-iana-XFER_REFUSE-codes){.xref}. The registration procedure is
Specification Required within the lower range 0x00-0xEF. Values in the
range 0xF0-0xFF are reserved for Private or Experimental Use, which are
not recorded by IANA.[¶](#section-8.6-1){.pilcrow}

Specifications of new XFER_REFUSE reason codes need to define the
meaning of the reason and disambiguate it from preexisting reasons. Each
refusal reason needs to be usable by the receiving BPA to make
retransmission or rerouting decisions.[¶](#section-8.6-2){.pilcrow}

Experts are encouraged to be biased towards approving registrations
unless they are abusive, frivolous, or actively harmful (not merely
esthetically displeasing or architecturally
dubious).[¶](#section-8.6-3){.pilcrow}

[]{#name-xfer_refuse-reason-codes-3}

::: {#tab-iana-XFER_REFUSE-codes}
  Code        Refusal Reason
  ----------- ------------------------------------------
  0x00        Unknown
  0x01        Completed
  0x02        No Resources
  0x03        Retransmit
  0x04        Not Acceptable
  0x05        Extension Failure
  0x06        Session Terminating
  0x07-0xEF   Unassigned
  0xF0-0xFF   Reserved for Private or Experimental Use

  : [Table 15](#table-15){.selfRef}: [XFER_REFUSE Reason
  Codes](#name-xfer_refuse-reason-codes-3){.selfRef}
:::
:::
:::

::: {#sec-iana-SESS_TERM-codes}
::: {#section-8.7 .section}
### [8.7.](#section-8.7){.section-number .selfRef} [SESS_TERM Reason Codes](#name-sess_term-reason-codes-2){.section-name .selfRef} {#name-sess_term-reason-codes-2}

Under the \"Bundle Protocol\" registry
\[[IANA-BUNDLE](#IANA-BUNDLE){.xref}\], IANA has created the \"Bundle
Protocol TCP Convergence-Layer Version 4 SESS_TERM Reason Codes\"
registry and populated it with the contents of [Table
16](#tab-iana-SESS_TERM-codes){.xref}. The registration procedure is
Specification Required within the lower range 0x00-0xEF. Values in the
range 0xF0-0xFF are reserved for Private or Experimental Use, which are
not recorded by IANA.[¶](#section-8.7-1){.pilcrow}

Specifications of new SESS_TERM reason codes need to define the meaning
of the reason and disambiguate it from preexisting reasons. Each
termination reason needs to be usable by the receiving BPA to make
reconnection decisions.[¶](#section-8.7-2){.pilcrow}

Experts are encouraged to be biased towards approving registrations
unless they are abusive, frivolous, or actively harmful (not merely
esthetically displeasing or architecturally
dubious).[¶](#section-8.7-3){.pilcrow}

[]{#name-sess_term-reason-codes-3}

::: {#tab-iana-SESS_TERM-codes}
  Code        Termination Reason
  ----------- ------------------------------------------
  0x00        Unknown
  0x01        Idle timeout
  0x02        Version mismatch
  0x03        Busy
  0x04        Contact Failure
  0x05        Resource Exhaustion
  0x06-0xEF   Unassigned
  0xF0-0xFF   Reserved for Private or Experimental Use

  : [Table 16](#table-16){.selfRef}: [SESS_TERM Reason
  Codes](#name-sess_term-reason-codes-3){.selfRef}
:::
:::
:::

::: {#sec-iana-MSG_REJECT-codes}
::: {#section-8.8 .section}
### [8.8.](#section-8.8){.section-number .selfRef} [MSG_REJECT Reason Codes](#name-msg_reject-reason-codes-2){.section-name .selfRef} {#name-msg_reject-reason-codes-2}

Under the \"Bundle Protocol\" registry
\[[IANA-BUNDLE](#IANA-BUNDLE){.xref}\], IANA has created the \"Bundle
Protocol TCP Convergence-Layer Version 4 MSG_REJECT Reason Codes\"
registry and populated it with the contents of [Table
17](#tab-iana-MSG_REJECT-codes){.xref}. The registration procedure is
Specification Required within the lower range 0x01-0xEF. Values in the
range 0xF0-0xFF are reserved for Private or Experimental Use, which are
not recorded by IANA.[¶](#section-8.8-1){.pilcrow}

Specifications of new MSG_REJECT reason codes need to define the meaning
of the reason and disambiguate it from preexisting reasons. Each
rejection reason needs to be usable by the receiving TCPCL entity to
make message sequencing and/or session termination
decisions.[¶](#section-8.8-2){.pilcrow}

Experts are encouraged to be biased towards approving registrations
unless they are abusive, frivolous, or actively harmful (not merely
esthetically displeasing or architecturally
dubious).[¶](#section-8.8-3){.pilcrow}

[]{#name-msg_reject-reason-codes-3}

::: {#tab-iana-MSG_REJECT-codes}
  Code        Rejection Reason
  ----------- ------------------------------------------
  0x00        Reserved
  0x01        Message Type Unknown
  0x02        Message Unsupported
  0x03        Message Unexpected
  0x04-0xEF   Unassigned
  0xF0-0xFF   Reserved for Private or Experimental Use

  : [Table 17](#table-17){.selfRef}: [MSG_REJECT Reason
  Codes](#name-msg_reject-reason-codes-3){.selfRef}
:::
:::
:::

::: {#sec-iana-smi-mod}
::: {#section-8.9 .section}
### [8.9.](#section-8.9){.section-number .selfRef} [Object Identifier for PKIX Module Identifier](#name-object-identifier-for-pkix-){.section-name .selfRef} {#name-object-identifier-for-pkix-}

IANA has registered the following in the \"SMI Security for PKIX Module
Identifier\" registry \[[IANA-SMI](#IANA-SMI){.xref}\] for identifying
the module described in [Appendix
B](#sec-asn1-mod){.xref}.[¶](#section-8.9-1){.pilcrow}

[]{#name-new-smi-security-module}

::: {#id-mod-dtn-tcpclv4-2021}
  Decimal   Description               References
  --------- ------------------------- --------------------
  103       id-mod-dtn-tcpclv4-2021   This specification

  : [Table 18](#table-18){.selfRef}: [New SMI Security
  Module](#name-new-smi-security-module){.selfRef}
:::
:::
:::

::: {#sec-iana-pkix-on-oid}
::: {#section-8.10 .section}
### [8.10.](#section-8.10){.section-number .selfRef} [Object Identifier for PKIX Other Name Forms](#name-object-identifier-for-pkix-o){.section-name .selfRef} {#name-object-identifier-for-pkix-o}

IANA has registered the following in the \"SMI Security for PKIX Other
Name Forms\" registry \[[IANA-SMI](#IANA-SMI){.xref}\] for identifying
bundle endpoint IDs:[¶](#section-8.10-1){.pilcrow}

[]{#name-new-pkix-other-name-form}

::: {#id-on-bundleEID}
  Decimal   Description       References
  --------- ----------------- --------------------
  11        id-on-bundleEID   This specification

  : [Table 19](#table-19){.selfRef}: [New PKIX Other Name
  Form](#name-new-pkix-other-name-form){.selfRef}
:::

The formal structure of the associated Other Name Form is provided in
[Appendix B](#sec-asn1-mod){.xref}. The use of this OID is defined in
Sections [4.4.1](#sec-tls-identification){.xref} and
[4.4.2](#sec-tcpcl-cert-profile){.xref}.[¶](#section-8.10-3){.pilcrow}
:::
:::

::: {#sec-iana-pkix-kp-oid}
::: {#section-8.11 .section}
### [8.11.](#section-8.11){.section-number .selfRef} [Object Identifier for PKIX Extended Key Usage](#name-object-identifier-for-pkix-e){.section-name .selfRef} {#name-object-identifier-for-pkix-e}

IANA has registered the following in the \"SMI Security for PKIX
Extended Key Purpose\" registry \[[IANA-SMI](#IANA-SMI){.xref}\] for
securing BP bundles.[¶](#section-8.11-1){.pilcrow}

[]{#name-new-pkix-extended-key-purpo}

::: {#tbl-id-kp-bundleSecurity}
  Decimal   Description            References
  --------- ---------------------- --------------------
  35        id-kp-bundleSecurity   This specification

  : [Table 20](#table-20){.selfRef}: [New PKIX Extended Key
  Purpose](#name-new-pkix-extended-key-purpo){.selfRef}
:::

The formal definition of this EKU is provided in [Appendix
B](#sec-asn1-mod){.xref}. The use of this OID is defined in [Section
4.4.2](#sec-tcpcl-cert-profile){.xref}.[¶](#section-8.11-3){.pilcrow}
:::
:::
:::
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[IANA-BUNDLE\]
:   [IANA]{.refAuthor}, [\"Bundle Protocol\"]{.refTitle},
    \<<https://www.iana.org/assignments/bundle/>\>.
:   

\[IANA-PORTS\]
:   [IANA]{.refAuthor}, [\"Service Name and Transport Protocol Port
    Number Registry\"]{.refTitle},
    \<<https://www.iana.org/assignments/service-names-port-numbers/>\>.
:   

\[IANA-SMI\]
:   [IANA]{.refAuthor}, [\"Structure of Management Information (SMI)
    Numbers (MIB Module Registrations)\"]{.refTitle},
    \<<https://www.iana.org/assignments/smi-numbers/>\>.
:   

\[RFC0793\]
:   [Postel, J.]{.refAuthor}, [\"Transmission Control
    Protocol\"]{.refTitle}, [STD 7]{.seriesInfo}, [RFC
    793]{.seriesInfo}, [DOI 10.17487/RFC0793]{.seriesInfo}, September
    1981, \<<https://www.rfc-editor.org/info/rfc793>\>.
:   

\[RFC1122\]
:   [Braden, R., Ed.]{.refAuthor}, [\"Requirements for Internet Hosts -
    Communication Layers\"]{.refTitle}, [STD 3]{.seriesInfo}, [RFC
    1122]{.seriesInfo}, [DOI 10.17487/RFC1122]{.seriesInfo}, October
    1989, \<<https://www.rfc-editor.org/info/rfc1122>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC3986\]
:   [Berners-Lee, T.]{.refAuthor}, [Fielding, R.]{.refAuthor}, and [L.
    Masinter]{.refAuthor}, [\"Uniform Resource Identifier (URI): Generic
    Syntax\"]{.refTitle}, [STD 66]{.seriesInfo}, [RFC
    3986]{.seriesInfo}, [DOI 10.17487/RFC3986]{.seriesInfo}, January
    2005, \<<https://www.rfc-editor.org/info/rfc3986>\>.
:   

\[RFC5280\]
:   [Cooper, D.]{.refAuthor}, [Santesson, S.]{.refAuthor},
    [Farrell, S.]{.refAuthor}, [Boeyen, S.]{.refAuthor},
    [Housley, R.]{.refAuthor}, and [W. Polk]{.refAuthor}, [\"Internet
    X.509 Public Key Infrastructure Certificate and Certificate
    Revocation List (CRL) Profile\"]{.refTitle}, [RFC
    5280]{.seriesInfo}, [DOI 10.17487/RFC5280]{.seriesInfo}, May 2008,
    \<<https://www.rfc-editor.org/info/rfc5280>\>.
:   

\[RFC6066\]
:   [Eastlake 3rd, D.]{.refAuthor}, [\"Transport Layer Security (TLS)
    Extensions: Extension Definitions\"]{.refTitle}, [RFC
    6066]{.seriesInfo}, [DOI 10.17487/RFC6066]{.seriesInfo}, January
    2011, \<<https://www.rfc-editor.org/info/rfc6066>\>.
:   

\[RFC6125\]
:   [Saint-Andre, P.]{.refAuthor} and [J. Hodges]{.refAuthor},
    [\"Representation and Verification of Domain-Based Application
    Service Identity within Internet Public Key Infrastructure Using
    X.509 (PKIX) Certificates in the Context of Transport Layer Security
    (TLS)\"]{.refTitle}, [RFC 6125]{.seriesInfo}, [DOI
    10.17487/RFC6125]{.seriesInfo}, March 2011,
    \<<https://www.rfc-editor.org/info/rfc6125>\>.
:   

\[RFC6960\]
:   [Santesson, S.]{.refAuthor}, [Myers, M.]{.refAuthor},
    [Ankney, R.]{.refAuthor}, [Malpani, A.]{.refAuthor},
    [Galperin, S.]{.refAuthor}, and [C. Adams]{.refAuthor}, [\"X.509
    Internet Public Key Infrastructure Online Certificate Status
    Protocol - OCSP\"]{.refTitle}, [RFC 6960]{.seriesInfo}, [DOI
    10.17487/RFC6960]{.seriesInfo}, June 2013,
    \<<https://www.rfc-editor.org/info/rfc6960>\>.
:   

\[RFC7525\]
:   [Sheffer, Y.]{.refAuthor}, [Holz, R.]{.refAuthor}, and [P.
    Saint-Andre]{.refAuthor}, [\"Recommendations for Secure Use of
    Transport Layer Security (TLS) and Datagram Transport Layer Security
    (DTLS)\"]{.refTitle}, [BCP 195]{.seriesInfo}, [RFC
    7525]{.seriesInfo}, [DOI 10.17487/RFC7525]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7525>\>.
:   

\[RFC8126\]
:   [Cotton, M.]{.refAuthor}, [Leiba, B.]{.refAuthor}, and [T.
    Narten]{.refAuthor}, [\"Guidelines for Writing an IANA
    Considerations Section in RFCs\"]{.refTitle}, [BCP 26]{.seriesInfo},
    [RFC 8126]{.seriesInfo}, [DOI 10.17487/RFC8126]{.seriesInfo}, June
    2017, \<<https://www.rfc-editor.org/info/rfc8126>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8446\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   

\[RFC9171\]
:   [Burleigh, S.]{.refAuthor}, [Fall, K.]{.refAuthor}, and [E. Birrane,
    III]{.refAuthor}, [\"Bundle Protocol Version 7\"]{.refTitle}, [RFC
    9171]{.seriesInfo}, [DOI 10.17487/RFC9171]{.seriesInfo}, January
    2022, \<<https://www.rfc-editor.org/info/rfc9171>\>.
:   

\[X.680\]
:   [ITU-T]{.refAuthor}, [\"Information technology - Abstract Syntax
    Notation One (ASN.1): Specification of basic notation\"]{.refTitle},
    [ITU-T Recommendation X.680, ISO/IEC 8824-1:2021]{.refContent},
    February 2021,
    \<<https://www.itu.int/rec/T-REC-X.680-202102-I/en>\>.
:   
:::

::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[AEAD-LIMITS\]
:   [Luykx, A.]{.refAuthor} and [K. Paterson]{.refAuthor}, [\"Limits on
    Authenticated Encryption Use in TLS\"]{.refTitle}, August 2017,
    \<<https://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>\>.
:   

\[RFC2595\]
:   [Newman, C.]{.refAuthor}, [\"Using TLS with IMAP, POP3 and
    ACAP\"]{.refTitle}, [RFC 2595]{.seriesInfo}, [DOI
    10.17487/RFC2595]{.seriesInfo}, June 1999,
    \<<https://www.rfc-editor.org/info/rfc2595>\>.
:   

\[RFC3552\]
:   [Rescorla, E.]{.refAuthor} and [B. Korver]{.refAuthor},
    [\"Guidelines for Writing RFC Text on Security
    Considerations\"]{.refTitle}, [BCP 72]{.seriesInfo}, [RFC
    3552]{.seriesInfo}, [DOI 10.17487/RFC3552]{.seriesInfo}, July 2003,
    \<<https://www.rfc-editor.org/info/rfc3552>\>.
:   

\[RFC4511\]
:   [Sermersheim, J., Ed.]{.refAuthor}, [\"Lightweight Directory Access
    Protocol (LDAP): The Protocol\"]{.refTitle}, [RFC
    4511]{.seriesInfo}, [DOI 10.17487/RFC4511]{.seriesInfo}, June 2006,
    \<<https://www.rfc-editor.org/info/rfc4511>\>.
:   

\[RFC4838\]
:   [Cerf, V.]{.refAuthor}, [Burleigh, S.]{.refAuthor},
    [Hooke, A.]{.refAuthor}, [Torgerson, L.]{.refAuthor},
    [Durst, R.]{.refAuthor}, [Scott, K.]{.refAuthor},
    [Fall, K.]{.refAuthor}, and [H. Weiss]{.refAuthor},
    [\"Delay-Tolerant Networking Architecture\"]{.refTitle}, [RFC
    4838]{.seriesInfo}, [DOI 10.17487/RFC4838]{.seriesInfo}, April 2007,
    \<<https://www.rfc-editor.org/info/rfc4838>\>.
:   

\[RFC5489\]
:   [Badra, M.]{.refAuthor} and [I. Hajjeh]{.refAuthor}, [\"ECDHE_PSK
    Cipher Suites for Transport Layer Security (TLS)\"]{.refTitle}, [RFC
    5489]{.seriesInfo}, [DOI 10.17487/RFC5489]{.seriesInfo}, March 2009,
    \<<https://www.rfc-editor.org/info/rfc5489>\>.
:   

\[RFC5912\]
:   [Hoffman, P.]{.refAuthor} and [J. Schaad]{.refAuthor}, [\"New ASN.1
    Modules for the Public Key Infrastructure Using X.509
    (PKIX)\"]{.refTitle}, [RFC 5912]{.seriesInfo}, [DOI
    10.17487/RFC5912]{.seriesInfo}, June 2010,
    \<<https://www.rfc-editor.org/info/rfc5912>\>.
:   

\[RFC6698\]
:   [Hoffman, P.]{.refAuthor} and [J. Schlyter]{.refAuthor}, [\"The
    DNS-Based Authentication of Named Entities (DANE) Transport Layer
    Security (TLS) Protocol: TLSA\"]{.refTitle}, [RFC
    6698]{.seriesInfo}, [DOI 10.17487/RFC6698]{.seriesInfo}, August
    2012, \<<https://www.rfc-editor.org/info/rfc6698>\>.
:   

\[RFC7122\]
:   [Kruse, H.]{.refAuthor}, [Jero, S.]{.refAuthor}, and [S.
    Ostermann]{.refAuthor}, [\"Datagram Convergence Layers for the
    Delay- and Disruption-Tolerant Networking (DTN) Bundle Protocol and
    Licklider Transmission Protocol (LTP)\"]{.refTitle}, [RFC
    7122]{.seriesInfo}, [DOI 10.17487/RFC7122]{.seriesInfo}, March 2014,
    \<<https://www.rfc-editor.org/info/rfc7122>\>.
:   

\[RFC7242\]
:   [Demmer, M.]{.refAuthor}, [Ott, J.]{.refAuthor}, and [S.
    Perreault]{.refAuthor}, [\"Delay-Tolerant Networking TCP
    Convergence-Layer Protocol\"]{.refTitle}, [RFC 7242]{.seriesInfo},
    [DOI 10.17487/RFC7242]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7242>\>.
:   

\[RFC7250\]
:   [Wouters, P., Ed.]{.refAuthor}, [Tschofenig, H., Ed.]{.refAuthor},
    [Gilmore, J.]{.refAuthor}, [Weiler, S.]{.refAuthor}, and [T.
    Kivinen]{.refAuthor}, [\"Using Raw Public Keys in Transport Layer
    Security (TLS) and Datagram Transport Layer Security
    (DTLS)\"]{.refTitle}, [RFC 7250]{.seriesInfo}, [DOI
    10.17487/RFC7250]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7250>\>.
:   

\[RFC7435\]
:   [Dukhovni, V.]{.refAuthor}, [\"Opportunistic Security: Some
    Protection Most of the Time\"]{.refTitle}, [RFC 7435]{.seriesInfo},
    [DOI 10.17487/RFC7435]{.seriesInfo}, December 2014,
    \<<https://www.rfc-editor.org/info/rfc7435>\>.
:   

\[RFC7457\]
:   [Sheffer, Y.]{.refAuthor}, [Holz, R.]{.refAuthor}, and [P.
    Saint-Andre]{.refAuthor}, [\"Summarizing Known Attacks on Transport
    Layer Security (TLS) and Datagram TLS (DTLS)\"]{.refTitle}, [RFC
    7457]{.seriesInfo}, [DOI 10.17487/RFC7457]{.seriesInfo}, February
    2015, \<<https://www.rfc-editor.org/info/rfc7457>\>.
:   

\[RFC8555\]
:   [Barnes, R.]{.refAuthor}, [Hoffman-Andrews, J.]{.refAuthor},
    [McCarney, D.]{.refAuthor}, and [J. Kasten]{.refAuthor},
    [\"Automatic Certificate Management Environment
    (ACME)\"]{.refTitle}, [RFC 8555]{.seriesInfo}, [DOI
    10.17487/RFC8555]{.seriesInfo}, March 2019,
    \<<https://www.rfc-editor.org/info/rfc8555>\>.
:   

\[RFC9172\]
:   [Birrane, III, E.]{.refAuthor} and [K. McKeever]{.refAuthor},
    [\"Bundle Protocol Security (BPSec)\"]{.refTitle}, [RFC
    9172]{.seriesInfo}, [DOI 10.17487/RFC9172]{.seriesInfo}, January
    2022, \<<https://www.rfc-editor.org/info/rfc9172>\>.
:   

\[DTN-BIBECT\]
:   [Burleigh, S.]{.refAuthor}, [\"Bundle-in-Bundle
    Encapsulation\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-dtn-bibect-03]{.seriesInfo}, 18 February
    2020,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-dtn-bibect-03>\>.
:   
:::
:::

::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [Significant Changes from RFC 7242](#name-significant-changes-from-rf){.section-name .selfRef} {#name-significant-changes-from-rf}

The areas in which changes from \[[RFC7242](#RFC7242){.xref}\] have been
made to existing headers and messages are as
follows:[¶](#appendix-A-1){.pilcrow}

-   [Split Contact Header into pre-TLS protocol negotiation and
    SESS_INIT parameter negotiation. The Contact Header is now fixed
    length.[¶](#appendix-A-2.1){.pilcrow}]{#appendix-A-2.1}
-   [Changed Contact Header content to limit number of negotiated
    options.[¶](#appendix-A-2.2){.pilcrow}]{#appendix-A-2.2}
-   [Added session option to negotiate maximum segment size (per each
    direction).[¶](#appendix-A-2.3){.pilcrow}]{#appendix-A-2.3}
-   [Renamed \"endpoint ID\" to \"node ID\" to conform with BPv7
    terminology.[¶](#appendix-A-2.4){.pilcrow}]{#appendix-A-2.4}
-   [Added session extension
    capability.[¶](#appendix-A-2.5){.pilcrow}]{#appendix-A-2.5}
-   [Added transfer extension capability. Moved transfer total length
    into an extension
    item.[¶](#appendix-A-2.6){.pilcrow}]{#appendix-A-2.6}
-   [Defined new IANA registries for message / type / reason codes to
    allow renaming some codes for
    clarity.[¶](#appendix-A-2.7){.pilcrow}]{#appendix-A-2.7}
-   [Pointed out that segments of all new IANA registries are reserved
    for private/experimental
    use.[¶](#appendix-A-2.8){.pilcrow}]{#appendix-A-2.8}
-   [Expanded Message Header to octet-aligned fields instead of
    bit-packing.[¶](#appendix-A-2.9){.pilcrow}]{#appendix-A-2.9}
-   [Added a bundle transfer identification number to all bundle-related
    messages (XFER_SEGMENT, XFER_ACK,
    XFER_REFUSE).[¶](#appendix-A-2.10){.pilcrow}]{#appendix-A-2.10}
-   [Added flags in XFER_ACK to mirror flags from
    XFER_SEGMENT.[¶](#appendix-A-2.11){.pilcrow}]{#appendix-A-2.11}
-   [Removed all uses of Self-Delimiting Numeric Value (SDNV) fields and
    replaced with fixed-bit-length (network byte order)
    fields.[¶](#appendix-A-2.12){.pilcrow}]{#appendix-A-2.12}
-   [Renamed SHUTDOWN to SESS_TERM to deconflict term \"shutdown\"
    related to TCP
    connections.[¶](#appendix-A-2.13){.pilcrow}]{#appendix-A-2.13}
-   [Removed the notion of a reconnection delay
    parameter.[¶](#appendix-A-2.14){.pilcrow}]{#appendix-A-2.14}

The areas in which extensions from \[[RFC7242](#RFC7242){.xref}\] have
been made as new messages and codes are as
follows:[¶](#appendix-A-3){.pilcrow}

-   [Added MSG_REJECT message to indicate that an unknown or unhandled
    message was
    received.[¶](#appendix-A-4.1){.pilcrow}]{#appendix-A-4.1}
-   [Added TLS connection security
    mechanism.[¶](#appendix-A-4.2){.pilcrow}]{#appendix-A-4.2}
-   [Added \"Not Acceptable\", \"Extension Failure\", and \"Session
    Terminating\" XFER_REFUSE reason
    codes.[¶](#appendix-A-4.3){.pilcrow}]{#appendix-A-4.3}
-   [Added \"Contact Failure\" (contact negotiation failure) and
    \"Resource Exhaustion\" SESS_TERM reason
    codes.[¶](#appendix-A-4.4){.pilcrow}]{#appendix-A-4.4}
:::

::: {#sec-asn1-mod}
::: {#appendix-B .section}
## [Appendix B.](#appendix-B){.section-number .selfRef} [ASN.1 Module](#name-asn1-module){.section-name .selfRef} {#name-asn1-module}

The following ASN.1 module formally specifies the `BundleEID` structure,
its Other Name Form, and the `bundleSecurity` EKU, using ASN.1 syntax
per \[[X.680](#X.680){.xref}\]. This specification uses the ASN.1
definitions from \[[RFC5912](#RFC5912){.xref}\] with the 2002 ASN.1
notation used in that document.[¶](#appendix-B-1){.pilcrow}

::: {#appendix-B-2}
``` {.lang-asn.1 .sourcecode}
<CODE BEGINS>
DTN-TCPCLv4-2021
  { iso(1) identified-organization(3) dod(6)
    internet(1) security(5) mechanisms(5) pkix(7) id-mod(0)
    id-mod-dtn-tcpclv4-2021(103) }

DEFINITIONS IMPLICIT TAGS ::=
BEGIN

IMPORTS
  OTHER-NAME
  FROM PKIX1Implicit-2009 -- [RFC5912]
    { iso(1) identified-organization(3) dod(6) internet(1)
      security(5) mechanisms(5) pkix(7) id-mod(0)
      id-mod-pkix1-implicit-02(59) }

  id-pkix
  FROM PKIX1Explicit-2009 -- [RFC5912]
    { iso(1) identified-organization(3) dod(6) internet(1)
      security(5) mechanisms(5) pkix(7) id-mod(0)
      id-mod-pkix1-explicit-02(51) } ;

id-kp OBJECT IDENTIFIER ::= { id-pkix 3 }

id-on OBJECT IDENTIFIER ::= { id-pkix 8 }

DTNOtherNames OTHER-NAME ::= { on-bundleEID, ... }

-- The otherName definition for BundleEID
on-bundleEID OTHER-NAME ::= {
    BundleEID IDENTIFIED BY { id-on-bundleEID }
}

id-on-bundleEID OBJECT IDENTIFIER ::= { id-on 11 }

-- Same encoding as GeneralName of uniformResourceIdentifier
BundleEID ::= IA5String

-- The Extended Key Usage key for bundle security
id-kp-bundleSecurity OBJECT IDENTIFIER ::= { id-kp 35 }

END

<CODE ENDS>
```

[¶](#appendix-B-2){.pilcrow}
:::
:::
:::

::: {#appendix-C .section}
## [Appendix C.](#appendix-C){.section-number .selfRef} [Example of the BundleEID Other Name Form](#name-example-of-the-bundleeid-ot){.section-name .selfRef} {#name-example-of-the-bundleeid-ot}

This non-normative example demonstrates an otherName with a name form of
`BundleEID` to encode the node ID
\"dtn://example/\".[¶](#appendix-C-1){.pilcrow}

The hexadecimal form of the DER encoding of the otherName is as
follows:[¶](#appendix-C-2){.pilcrow}

::: {#appendix-C-3}
``` {.lang-hex .sourcecode}
a01c06082b0601050507080ba010160e64746e3a2f2f6578616d706c652f
```

[¶](#appendix-C-3){.pilcrow}
:::

And the text decoding in [Figure 28](#fig-example-dtneid){.xref} is an
output of Peter Gutmann\'s \"dumpasn1\"
program.[¶](#appendix-C-4){.pilcrow}

[]{#name-visualized-decoding-of-the-}

::: {#fig-example-dtneid}
::: {#appendix-C-5.1 .alignLeft .art-ascii-art .art-text .artwork}
      0  28: [0] {
      2   8:   OBJECT IDENTIFIER '1 3 6 1 5 5 7 8 11'
     12  16:   [0] {
     14  14:     IA5String 'dtn://example/'
           :     }
           :   }
:::

[Figure 28](#figure-28){.selfRef}: [Visualized Decoding of the
on-bundleEID](#name-visualized-decoding-of-the-){.selfRef}
:::
:::

::: {#sec-doc-ack}
::: {#appendix-D .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

This specification is based on comments regarding the implementation of
\[[RFC7242](#RFC7242){.xref}\] as provided by [Scott
Burleigh]{.contact-name}.[¶](#appendix-D-1){.pilcrow}

The ASN.1 module and its Other Name Form are based on a recommendation
provided by [Russ Housley]{.contact-name}.[¶](#appendix-D-2){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-E .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Brian Sipos]{.fn .nameRole}
:::

::: {.left dir="auto"}
[RKF Engineering Solutions, LLC]{.org}
:::

::: {.left dir="auto"}
[7500 Old Georgetown Road\
Suite 1275]{.street-address}
:::

::: {.left dir="auto"}
[Bethesda]{.locality}, [MD]{.region} [20814-6198]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <brian.sipos+ietf@gmail.com>
:::

::: {.left dir="auto"}
[Michael Demmer]{.fn .nameRole}
:::

::: email
Email: <demmer@gmail.com>
:::

::: {.left dir="auto"}
[Jörg Ott]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Technical University of Munich]{.org}
:::

::: {.left dir="auto"}
[Department of Informatics\
Chair of Connected Mobility]{.extended-address}
:::

::: {.left dir="auto"}
[Boltzmannstrasse 3]{.street-address}
:::

::: {.left dir="auto"}
[DE-85748]{.postal-code} [Garching]{.locality}
:::

::: {.left dir="auto"}
[Germany]{.country-name}
:::

::: email
Email: <ott@in.tum.de>
:::

::: {.left dir="auto"}
[Simon Perreault]{.fn .nameRole}
:::

::: {.left dir="auto"}
[LogMeIn]{.org}
:::

::: {.left dir="auto"}
[410 boulevard Charest Est\
Suite 250]{.street-address}
:::

::: {.left dir="auto"}
[Quebec]{.locality} [QC]{.region} [G1K 8G3]{.postal-code}
:::

::: {.left dir="auto"}
[Canada]{.country-name}
:::

::: email
Email: <simon.perreault@logmein.com>
:::
:::
:::
