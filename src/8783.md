  RFC 8783              DOTS Data Channel Protocol   May 2020
  --------------------- ---------------------------- ----------
  Boucadair & Reddy.K   Standards Track              \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8783](https://www.rfc-editor.org/rfc/rfc8783){.eref}

Category:
:   Standards Track

Published:
:   May 2020

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    M. Boucadair, [Ed.]{.editor}
    :::

    ::: org
    Orange
    :::
    :::

    ::: author
    ::: author-name
    T. Reddy.K, [Ed.]{.editor}
    :::

    ::: org
    McAfee
    :::
    :::
:::

# RFC 8783 {#rfcnum}

# Distributed Denial-of-Service Open Threat Signaling (DOTS) Data Channel Specification {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

The document specifies a Distributed Denial-of-Service Open Threat
Signaling (DOTS) data channel used for bulk exchange of data that cannot
easily or appropriately communicated through the DOTS signal channel
under attack conditions.[¶](#section-abstract-1){.pilcrow}

This is a companion document to \"Distributed Denial-of-Service Open
Threat Signaling (DOTS) Signal Channel Specification\" (RFC
8782).[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8783>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [DOTS Data
    Channel](#name-dots-data-channel){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Design
        Overview](#name-design-overview){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [DOTS Server(s)
        Discovery](#name-dots-servers-discovery){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [DOTS
        Gateways](#name-dots-gateways){.xref}[¶](#section-toc.1-1.3.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [Detecting and Preventing Infinite
        Loops](#name-detecting-and-preventing-in){.xref}[¶](#section-toc.1-1.3.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.5}
        [3.5](#section-3.5){.xref}.  [Preventing Stale
        Entries](#name-preventing-stale-entries){.xref}[¶](#section-toc.1-1.3.2.5.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [DOTS Data Channel YANG
    Module](#name-dots-data-channel-yang-modu){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Generic Tree
        Structure](#name-generic-tree-structure){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Filtering
        Fields](#name-filtering-fields){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [YANG
        Module](#name-yang-module){.xref}[¶](#section-toc.1-1.4.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Managing DOTS
    Clients](#name-managing-dots-clients){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Registering DOTS
        Clients](#name-registering-dots-clients){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [De-registering DOTS
        Clients](#name-de-registering-dots-clients){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Managing DOTS
    Aliases](#name-managing-dots-aliases){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Creating
        Aliases](#name-creating-aliases){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Retrieving Installed
        Aliases](#name-retrieving-installed-aliase){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Deleting
        Aliases](#name-deleting-aliases){.xref}[¶](#section-toc.1-1.6.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Managing DOTS Filtering
    Rules](#name-managing-dots-filtering-rul){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Retrieving DOTS Filtering
        Capabilities](#name-retrieving-dots-filtering-c){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Installing Filtering
        Rules](#name-installing-filtering-rules){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Retrieving Installed Filtering
        Rules](#name-retrieving-installed-filter){.xref}[¶](#section-toc.1-1.7.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [Removing Filtering
        Rules](#name-removing-filtering-rules){.xref}[¶](#section-toc.1-1.7.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Operational
    Considerations](#name-operational-considerations){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}

    -   ::: {#section-toc.1-1.11.2.1}
        [11.1](#section-11.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.11.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [11.2](#section-11.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.11.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [Appendix A](#section-appendix.a){.xref}.  [Examples: Filtering
    Fragments](#name-examples-filtering-fragment){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.13}
    [Appendix B](#section-appendix.b){.xref}.  [Examples: Filtering TCP
    Messages](#name-examples-filtering-tcp-mess){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}

    -   ::: {#section-toc.1-1.13.2.1}
        [B.1](#section-b.1){.xref}.  [Discard TCP Null
        Attack](#name-discard-tcp-null-attack){.xref}[¶](#section-toc.1-1.13.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.13.2.2}
        [B.2](#section-b.2){.xref}.  [Rate-Limit SYN
        Flooding](#name-rate-limit-syn-flooding){.xref}[¶](#section-toc.1-1.13.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.13.2.3}
        [B.3](#section-b.3){.xref}.  [Rate-Limit ACK
        Flooding](#name-rate-limit-ack-flooding){.xref}[¶](#section-toc.1-1.13.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.14}
    [](#section-appendix.c){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.15}
    [](#section-appendix.d){.xref}[Contributors](#name-contributors){.xref}[¶](#section-toc.1-1.15.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.16}
    [](#section-appendix.e){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.16.1){.pilcrow}
    :::
:::
:::

::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

A distributed denial-of-service (DDoS) attack is an attempt to make
machines or network resources unavailable to their intended users. In
most cases, sufficient scale can be achieved by compromising enough end
hosts and using those infected hosts to perpetrate and amplify the
attack. The victim of such an attack can be an application server, a
router, a firewall, an entire network, etc.[¶](#section-1-1){.pilcrow}

As discussed in \[[RFC8612](#RFC8612){.xref}\], the lack of a common
method to coordinate a real-time response among involved actors and
network domains inhibits the speed and effectiveness of DDoS attack
mitigation. From that standpoint, DDoS Open Threat Signaling (DOTS)
defines an architecture that allows a DOTS client to send requests to a
DOTS server for DDoS attack mitigation
\[[DOTS-ARCH](#I-D.ietf-dots-architecture){.xref}\]. The DOTS approach
is thus meant to minimize the impact of DDoS attacks, thereby
contributing to the enforcement of more efficient defensive if not
proactive security strategies. To that aim, DOTS defines two channels:
the signal channel and the data channel ([Figure
1](#channels){.xref}).[¶](#section-1-2){.pilcrow}

[]{#name-dots-channels}

::: {#channels}
::: {#section-1-3.1 .artwork .art-text .alignLeft}
    +---------------+                                 +---------------+
    |               | <------- Signal Channel ------> |               |
    |  DOTS Client  |                                 |  DOTS Server  |
    |               | <=======  Data Channel  ======> |               |
    +---------------+                                 +---------------+
:::

[Figure 1](#figure-1){.selfRef}: [DOTS
Channels](#name-dots-channels){.selfRef}
:::

The DOTS signal channel is used to carry information about a device or a
network (or a part thereof) that is under a DDoS attack. Such
information is sent by a DOTS client to an upstream DOTS server so that
appropriate mitigation actions are undertaken on traffic deemed
suspicious. The DOTS signal channel is further elaborated in
\[[RFC8782](#RFC8782){.xref}\].[¶](#section-1-4){.pilcrow}

The DOTS data channel is used for infrequent bulk data exchange between
DOTS agents to significantly improve the coordination of all the parties
involved in the response to the attack. [Section
2](https://tools.ietf.org/html/draft-ietf-dots-architecture-18#section-2){.relref}
of \[[DOTS-ARCH](#I-D.ietf-dots-architecture){.xref}\] mentions that the
DOTS data channel is used to perform the following
tasks:[¶](#section-1-5){.pilcrow}

-   ::: {#section-1-6.1}
    Creation of aliases for resources for which mitigation may be
    requested.[¶](#section-1-6.1.1){.pilcrow}

    A DOTS client may submit to its DOTS server a collection of prefixes
    to which it would like to refer by an alias when requesting
    mitigation. The DOTS server can respond to this request with either
    a success or failure response (see [Section
    2](https://tools.ietf.org/html/draft-ietf-dots-architecture-18#section-2){.relref}
    of
    \[[DOTS-ARCH](#I-D.ietf-dots-architecture){.xref}\]).[¶](#section-1-6.1.2){.pilcrow}

    Refer to [Section 6](#identifier){.xref} for more
    details.[¶](#section-1-6.1.3){.pilcrow}
    :::

-   ::: {#section-1-6.2}
    Policy management, which enables a DOTS client to request the
    installation or withdrawal of traffic filters, the dropping or
    rate-limiting of unwanted traffic, and the permitting of
    accept-listed traffic. A DOTS client is entitled to instruct
    filtering rules only on IP resources that belong to its
    domain.[¶](#section-1-6.2.1){.pilcrow}

    Sample use cases for populating drop- or accept-list filtering rules
    are detailed hereafter:[¶](#section-1-6.2.2){.pilcrow}

    -   ::: {#section-1-6.2.3.1}
        If a network resource (DOTS client) is informed about a
        potential DDoS attack from a set of IP addresses, the DOTS
        client informs its servicing DOTS gateway of all suspect IP
        addresses that need to be drop-listed for further investigation.
        The DOTS client could also specify a list of protocols and port
        numbers in the drop-list
        rule.[¶](#section-1-6.2.3.1.1){.pilcrow}

        The DOTS gateway then propagates the drop-listed IP addresses to
        a DOTS server, which will undertake appropriate actions so that
        traffic originated by these IP addresses to the target network
        (specified by the DOTS client) is
        blocked.[¶](#section-1-6.2.3.1.2){.pilcrow}
        :::

    -   ::: {#section-1-6.2.3.2}
        A network that has partner sites from which only legitimate
        traffic arrives may want to ensure that the traffic from these
        sites is not subjected to DDoS attack mitigation. The DOTS
        client uses the DOTS data channel to convey the accept-listed IP
        prefixes of the partner sites to its DOTS
        server.[¶](#section-1-6.2.3.2.1){.pilcrow}

        The DOTS server uses this information to accept-list flows
        originated by such IP prefixes and which reach the
        network.[¶](#section-1-6.2.3.2.2){.pilcrow}
        :::

    Refer to [Section 7](#filter){.xref} for more
    details.[¶](#section-1-6.2.4){.pilcrow}
    :::
:::

::: {#notation}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}

The reader should be familiar with the terms defined in
\[[RFC8612](#RFC8612){.xref}\].[¶](#section-2-2){.pilcrow}

The terminology for describing YANG modules is defined in
\[[RFC7950](#RFC7950){.xref}\]. The meaning of the symbols in the tree
diagrams is defined in
\[[RFC8340](#RFC8340){.xref}\].[¶](#section-2-3){.pilcrow}

This document generalizes the notion of Access Control List (ACL) so
that it is not device specific \[[RFC8519](#RFC8519){.xref}\]. As such,
this document defines an ACL as an ordered set of rules that is used to
filter traffic. Each rule is represented by an Access Control Entry
(ACE). ACLs communicated via the DOTS data channel are not bound to a
device interface.[¶](#section-2-4){.pilcrow}

For the sake of simplicity, the examples in this document use
\"/restconf\" as the discovered RESTCONF API root path. Within the
examples, many protocol header lines and message-body text are split
into multiple lines for display purposes only. When a line ends with
backslash (\'\\\') as the last character, the line is wrapped for
display purposes. It is to be considered to be joined to the next line
by deleting the backslash, the following line break, and the leading
whitespace of the next line.[¶](#section-2-5){.pilcrow}
:::
:::

::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [DOTS Data Channel](#name-dots-data-channel){.section-name .selfRef} {#name-dots-data-channel}

::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Design Overview](#name-design-overview){.section-name .selfRef} {#name-design-overview}

Unlike the DOTS signal channel, which must remain operational even when
confronted with signal degradation due to packet loss, the DOTS data
channel is not expected to be fully operational at all times, especially
when a DDoS attack is underway. The requirements for a DOTS data channel
protocol are documented in
\[[RFC8612](#RFC8612){.xref}\].[¶](#section-3.1-1){.pilcrow}

This specification does not require an order of DOTS signal and data
channel creation nor does it mandate a time interval between them. These
considerations are implementation and deployment
specific.[¶](#section-3.1-2){.pilcrow}

As the primary function of the data channel is data exchange, a reliable
transport mode is required in order for DOTS agents to detect data
delivery success or failure. This document uses RESTCONF
\[[RFC8040](#RFC8040){.xref}\] over TLS over TCP as the DOTS data
channel protocol. The abstract layering of the DOTS data channel is
shown in [Figure 2](#fig_dots2){.xref}.[¶](#section-3.1-3){.pilcrow}

[]{#name-abstract-layering-of-dots-d}

::: {#fig_dots2}
::: {#section-3.1-4.1 .artwork .art-text .alignCenter}
    +-------------------+
    | DOTS Data Channel |
    +-------------------+
    |      RESTCONF     |
    +-------------------+
    |        TLS        |
    +-------------------+
    |        TCP        |
    +-------------------+
    |        IP         |
    +-------------------+
:::

[Figure 2](#figure-2){.selfRef}: [Abstract Layering of DOTS Data
Channel](#name-abstract-layering-of-dots-d){.selfRef}
:::

The HTTP POST, PUT, PATCH, and DELETE methods are used to edit data
resources represented by DOTS data channel YANG modules. These basic
edit operations allow a DOTS client to alter the running configuration
of the DOTS data channel. Rules for generating and processing RESTCONF
methods are defined in [Section
4](https://www.rfc-editor.org/rfc/rfc8040#section-4){.relref} of
\[[RFC8040](#RFC8040){.xref}\].[¶](#section-3.1-5){.pilcrow}

DOTS data channel configuration information as well as state information
can be retrieved with the GET method. An HTTP status-line is returned
for each request to report success or failure for RESTCONF operations
([Section
5.4](https://www.rfc-editor.org/rfc/rfc8040#section-5.4){.relref} of
\[[RFC8040](#RFC8040){.xref}\]). The error-tag provides more information
about encountered errors ([Section
7](https://www.rfc-editor.org/rfc/rfc8040#section-7){.relref} of
\[[RFC8040](#RFC8040){.xref}\]).[¶](#section-3.1-6){.pilcrow}

DOTS clients perform the root resource discovery procedure discussed in
[Section
3.1](https://www.rfc-editor.org/rfc/rfc8040#section-3.1){.relref} of
\[[RFC8040](#RFC8040){.xref}\] to determine the root of the RESTCONF
API. After discovering the RESTCONF API root, a DOTS client uses this
value as the initial part of the path in the request URI in any
subsequent request to the DOTS server. The DOTS server may support the
retrieval of the YANG modules it supports ([Section
3.7](https://www.rfc-editor.org/rfc/rfc8040#section-3.7){.relref} of
\[[RFC8040](#RFC8040){.xref}\]). For example, a DOTS client may use
RESTCONF to retrieve the vendor-specific YANG modules supported by its
DOTS server.[¶](#section-3.1-7){.pilcrow}

JavaScript Object Notation (JSON) \[[RFC8259](#RFC8259){.xref}\]
payloads are used to propagate the DOTS data-channel-specific payload
messages that carry request parameters and response information, such as
errors. This specification uses the encoding rules defined in
\[[RFC7951](#RFC7951){.xref}\] for representing DOTS data channel
configuration data using YANG ([Section 4](#YANG){.xref}) as JSON
text.[¶](#section-3.1-8){.pilcrow}

A DOTS client registers itself with its DOTS server(s) in order to set
up DOTS data channel-related configuration data and to receive state
data (i.e., non-configuration data) from the DOTS server(s) ([Section
5](#registering){.xref}). Mutual authentication considerations are
specified in [Section
8](https://www.rfc-editor.org/rfc/rfc8782#section-8){.relref} of
\[[RFC8782](#RFC8782){.xref}\]. The coupling of signal and data channels
is discussed in [Section
4.4.1](https://www.rfc-editor.org/rfc/rfc8782#section-4.4.1){.relref} of
\[[RFC8782](#RFC8782){.xref}\].[¶](#section-3.1-9){.pilcrow}

A DOTS client can either maintain a persistent connection or initiate
periodic connections with its DOTS server(s). If the DOTS client needs
to frequently update the drop-list or accept-list filtering rules or
aliases, it maintains a persistent connection with the DOTS server. For
example, CAPTCHA and cryptographic puzzles can be used by the mitigation
service in the DOTS client domain to determine whether or not the IP
address is used for legitimate purpose, and the DOTS client can
frequently update the drop-list filtering rules. A persistent connection
is also useful if the DOTS client subscribes to event notifications
([Section
6.3](https://www.rfc-editor.org/rfc/rfc8040#section-6.3){.relref} of
\[[RFC8040](#RFC8040){.xref}\]). Additional considerations related to
RESTCONF connection management (including, configuring the connection
type or the reconnect strategy) can be found in
\[[RESTCONF-MODELS](#I-D.ietf-netconf-restconf-client-server){.xref}\].[¶](#section-3.1-10){.pilcrow}

A single DOTS data channel between DOTS agents can be used to exchange
multiple requests and multiple responses. To reduce DOTS client and DOTS
server workload, DOTS clients [SHOULD]{.bcp14} reuse the same TLS
session. While the communication to the DOTS server is quiescent, the
DOTS client [MAY]{.bcp14} probe the server to ensure it has maintained
cryptographic state. Such probes can also keep alive firewall and/or NAT
bindings. A TLS heartbeat \[[RFC6520](#RFC6520){.xref}\] verifies that
the DOTS server still has TLS state by returning a TLS
message.[¶](#section-3.1-11){.pilcrow}

A DOTS server may detect conflicting filtering requests from distinct
DOTS clients that belong to the same domain. For example, a DOTS client
could request to drop-list a prefix by specifying the source prefix,
while another DOTS client could request to accept-list that same source
prefix, but both having the same destination prefix. DOTS servers
[SHOULD]{.bcp14} support a configuration parameter to indicate the
behavior to follow when a conflict is detected (e.g., reject all, reject
the new request, notify an administrator for validation). [Section
7.2](#install){.xref} specifies a default behavior when no instruction
is supplied to a DOTS server.[¶](#section-3.1-12){.pilcrow}

How a DOTS client synchronizes its configuration with the one maintained
by its DOTS server(s) is implementation specific. For
example:[¶](#section-3.1-13){.pilcrow}

-   [A DOTS client can systematically send a GET message before and/or
    after a configuration change
    request.[¶](#section-3.1-14.1){.pilcrow}]{#section-3.1-14.1}
-   [A DOTS client can reestablish the disconnected DOTS session after
    an attack is mitigated. Then, it sends a GET message before a
    configuration change
    request.[¶](#section-3.1-14.2){.pilcrow}]{#section-3.1-14.2}

NAT considerations for the DOTS data channel are similar to those
discussed in [Section
3](https://www.rfc-editor.org/rfc/rfc8782#section-3){.relref} of
\[[RFC8782](#RFC8782){.xref}\].[¶](#section-3.1-15){.pilcrow}

The translation of filtering rules instantiated on a DOTS server into
network configuration actions is out of scope of this
specification.[¶](#section-3.1-16){.pilcrow}

Some of the fields introduced in [Section 4](#YANG){.xref} are also
discussed in Sections [5](#registering){.xref}, [6](#identifier){.xref},
and [7](#filter){.xref}. These sections are authoritative for these
fields.[¶](#section-3.1-17){.pilcrow}
:::

::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [DOTS Server(s) Discovery](#name-dots-servers-discovery){.section-name .selfRef} {#name-dots-servers-discovery}

This document assumes that DOTS clients are provisioned with the
knowledge of how to reach their DOTS server(s), which could occur by a
variety of means (e.g., local configuration or dynamic means such as
DHCP \[[DOTS-SERVER-DISC](#I-D.ietf-dots-server-discovery){.xref}\]).
The specification of such means are out of scope of this
document.[¶](#section-3.2-1){.pilcrow}

Likewise, it is out of scope of this document to specify the behavior to
be followed by a DOTS client to send DOTS requests when multiple DOTS
servers are provisioned (e.g., contact all DOTS servers, select one DOTS
server among the list).[¶](#section-3.2-2){.pilcrow}
:::

::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [DOTS Gateways](#name-dots-gateways){.section-name .selfRef} {#name-dots-gateways}

When a server-domain DOTS gateway is involved in DOTS data channel
exchanges, the same considerations for manipulating the \'cdid\' (client
domain identifier) parameter specified in \[[RFC8782](#RFC8782){.xref}\]
[MUST]{.bcp14} be followed by DOTS agents. As a reminder, \'cdid\' is
meant to assist the DOTS server in enforcing some policies (e.g., limit
the number of filtering rules per DOTS client or per DOTS client
domain). A loop detection mechanism for DOTS gateways is specified in
[Section 3.4](#loops){.xref}.[¶](#section-3.3-1){.pilcrow}

If a DOTS gateway is involved, the DOTS gateway verifies that the DOTS
client is authorized to undertake a data channel action (e.g.,
instantiate filtering rules). If the DOTS client is authorized, it
propagates the rules to the upstream DOTS server. Likewise, the DOTS
server verifies that the DOTS gateway is authorized to relay data
channel actions. For example, to create or purge filters, a DOTS client
sends its request to its DOTS gateway. The DOTS gateway validates the
rules in the request and proxies the requests containing the filtering
rules to its DOTS server. When the DOTS gateway receives the associated
response from the DOTS server, it propagates the response back to the
DOTS client.[¶](#section-3.3-2){.pilcrow}
:::

::: {#loops}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [Detecting and Preventing Infinite Loops](#name-detecting-and-preventing-in){.section-name .selfRef} {#name-detecting-and-preventing-in}

In order to detect and prevent infinite loops, DOTS gateways
[MUST]{.bcp14} support the procedure defined in [Section
5.7.1](https://www.rfc-editor.org/rfc/rfc7230#section-5.7.1){.relref} of
\[[RFC7230](#RFC7230){.xref}\]. In particular, each intermediate DOTS
gateway [MUST]{.bcp14} check that none of its own information (e.g.,
server names, literal IP addresses) is present in the Via header field
of a DOTS message it receives:[¶](#section-3.4-1){.pilcrow}

-   ::: {#section-3.4-2.1}
    If it detects that its own information is present in the Via header
    field, the DOTS gateway [MUST NOT]{.bcp14} forward the DOTS message.
    Messages that cannot be forwarded because of a loop [SHOULD]{.bcp14}
    be logged with a \"508 Loop Detected\" status-line returned to the
    DOTS peer. The structure of the reported error is depicted in
    [Figure 3](#looperr){.xref}.[¶](#section-3.4-2.1.1){.pilcrow}

    []{#name-loop-detected-error}
    ::: {#looperr}
    ::: {#section-3.4-2.1.2.1}
    ``` sourcecode
    error-app-tag:  loop-detected
    error-tag:      operation-failed
    error-type:     transport, application
    error-info:     <via-header> : A copy of the Via header field when
                    the loop was detected.
    Description:    An infinite loop has been detected when forwarding
                    a requests via a proxy.
    ```
    :::

    [Figure 3](#figure-3){.selfRef}: [Loop Detected
    Error](#name-loop-detected-error){.selfRef}
    :::

    It is [RECOMMENDED]{.bcp14} that DOTS clients and gateways support
    methods to alert administrators about loop errors so that
    appropriate actions are undertaken.[¶](#section-3.4-2.1.3){.pilcrow}
    :::

-   [Otherwise, the DOTS agent [MUST]{.bcp14} update or insert the Via
    header field by appending its own
    information.[¶](#section-3.4-2.2){.pilcrow}]{#section-3.4-2.2}

Unless configured otherwise, DOTS gateways at the boundaries of a DOTS
client domain [SHOULD]{.bcp14} remove the previous Via header field
information after checking for a loop before forwarding. This behavior
is required for topology hiding purposes but can also serve to minimize
potential conflicts that may arise if overlapping information is used in
distinct DOTS domains (e.g., private IPv4 addresses, aliases that are
not globally unique).[¶](#section-3.4-3){.pilcrow}
:::
:::

::: {#section-3.5 .section}
### [3.5.](#section-3.5){.section-number .selfRef} [Preventing Stale Entries](#name-preventing-stale-entries){.section-name .selfRef} {#name-preventing-stale-entries}

In order to avoid stale entries, a lifetime is associated with alias and
filtering entries created by DOTS clients. Also, DOTS servers may track
the inactivity timeout of DOTS clients to detect stale
entries.[¶](#section-3.5-1){.pilcrow}
:::
:::

::: {#YANG}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [DOTS Data Channel YANG Module](#name-dots-data-channel-yang-modu){.section-name .selfRef} {#name-dots-data-channel-yang-modu}

::: {#tree}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Generic Tree Structure](#name-generic-tree-structure){.section-name .selfRef} {#name-generic-tree-structure}

The DOTS data channel YANG module \'ietf-dots-data-channel\' provides a
method for DOTS clients to manage aliases for resources for which
mitigation may be requested. Such aliases may be used in subsequent DOTS
signal channel exchanges to refer more efficiently to the resources
under attack.[¶](#section-4.1-1){.pilcrow}

Note that the full module\'s tree has been split across several figures
to aid the exposition of the various
subtrees.[¶](#section-4.1-2){.pilcrow}

The tree structure for the DOTS alias is depicted in [Figure
4](#talias){.xref}.[¶](#section-4.1-3){.pilcrow}

[]{#name-dots-alias-subtree}

::: {#talias}
::: {#section-4.1-4.1}
``` {.sourcecode .lang-yangtree}
module: ietf-dots-data-channel
  +--rw dots-data
     +--rw dots-client* [cuid]
     |  +--rw cuid            string
     |  +--rw cdid?           string
     |  +--rw aliases
     |  |  +--rw alias* [name]
     |  |     +--rw name                 string
     |  |     +--rw target-prefix*       inet:ip-prefix
     |  |     +--rw target-port-range* [lower-port]
     |  |     |  +--rw lower-port    inet:port-number
     |  |     |  +--rw upper-port?   inet:port-number
     |  |     +--rw target-protocol*     uint8
     |  |     +--rw target-fqdn*         inet:domain-name
     |  |     +--rw target-uri*          inet:uri
     |  |     +--ro pending-lifetime?    int32
     |  +--rw acls
     |     ...
     +--ro capabilities
        ...
```
:::

[Figure 4](#figure-4){.selfRef}: [DOTS Alias
Subtree](#name-dots-alias-subtree){.selfRef}
:::

Also, the \'ietf-dots-data-channel\' YANG module provides a method for
DOTS clients to manage filtering rules. Examples of filtering management
in a DOTS context include, but are not limited
to:[¶](#section-4.1-5){.pilcrow}

-   [Drop-list management, which enables a DOTS client to inform a DOTS
    server about sources from which traffic should be
    discarded.[¶](#section-4.1-6.1){.pilcrow}]{#section-4.1-6.1}
-   [Accept-list management, which enables a DOTS client to inform a
    DOTS server about sources from which traffic should always be
    accepted.[¶](#section-4.1-6.2){.pilcrow}]{#section-4.1-6.2}
-   [Policy management, which enables a DOTS client to request the
    installation or withdrawal of traffic filters, the dropping or
    rate-limiting of unwanted traffic, and the allowance of
    accept-listed
    traffic.[¶](#section-4.1-6.3){.pilcrow}]{#section-4.1-6.3}

The tree structure for the DOTS filtering entries is depicted in [Figure
5](#tacl){.xref}.[¶](#section-4.1-7){.pilcrow}

Investigations into the prospect of augmenting
\'ietf-access-control-list\' to meet DOTS requirements concluded that
such a design approach did not support many of the DOTS requirements,
for example:[¶](#section-4.1-8){.pilcrow}

-   [Retrieve a filtering entry (or all entries) created by a DOTS
    client.[¶](#section-4.1-9.1){.pilcrow}]{#section-4.1-9.1}
-   [Delete a filtering entry that was instantiated by a DOTS
    client.[¶](#section-4.1-9.2){.pilcrow}]{#section-4.1-9.2}

Accordingly, new DOTS filtering entries (i.e., ACL) are defined that
mimic the structure specified in \[[RFC8519](#RFC8519){.xref}\].
Concretely, DOTS agents are assumed to manipulate an ordered list of
ACLs; each ACL contains a separately ordered list of ACEs. Each ACE has
a group of match and a group of action
criteria.[¶](#section-4.1-10){.pilcrow}

Once all of the ACE entries have been iterated though with no match,
then all of the following ACL\'s ACE entries are iterated through until
the first match, at which point the specified action is applied. If
there is no match during \'idle\' time (i.e., no mitigation is active),
then there is no further action to be taken against the packet. If there
is no match during active mitigation, then the packet will still be
scrubbed by the DDoS mitigator.[¶](#section-4.1-11){.pilcrow}

[]{#name-dots-acls-subtree}

::: {#tacl}
::: {#section-4.1-12.1}
``` {.sourcecode .lang-yangtree}
module: ietf-dots-data-channel
  +--rw dots-data
     +--rw dots-client* [cuid]
     |  +--rw cuid            string
     |  +--rw cdid?           string
     |  +--rw aliases
     |  |  ...
     |  +--rw acls
     |     +--rw acl* [name]
     |        +--rw name                string
     |        +--rw type?               ietf-acl:acl-type
     |        +--rw activation-type?    activation-type
     |        +--ro pending-lifetime?   int32
     |        +--rw aces
     |           +--rw ace* [name]
     |              +--rw name          string
     |              +--rw matches
     |              |  +--rw (l3)?
     |              |  |  +--:(ipv4)
     |              |  |  |  ...
     |              |  |  +--:(ipv6)
     |              |  |     ...
     |              |  +--rw (l4)?
     |              |     +--:(tcp)
     |              |     |  ...
     |              |     +--:(udp)
     |              |     |  ...
     |              |     +--:(icmp)
     |              |        ...
     |              +--rw actions
     |              |  +--rw forwarding    identityref
     |              |  +--rw rate-limit?   decimal64
     |              +--ro statistics
     |                 +--ro matched-packets?   yang:counter64
     |                 +--ro matched-octets?    yang:counter64
     +--ro capabilities
        ...
```
:::

[Figure 5](#figure-5){.selfRef}: [DOTS ACLs
Subtree](#name-dots-acls-subtree){.selfRef}
:::

Filtering rules instructed by a DOTS client assume a default direction:
the destination is the DOTS client domain.[¶](#section-4.1-13){.pilcrow}

DOTS forwarding actions can be \'accept\' (i.e., accept matching
traffic) or \'drop\' (i.e., drop matching traffic without sending any
ICMP error message). Accepted traffic can be subject to rate-limiting
\'rate-limit\'. Note that \'reject\' action (i.e., drop matching traffic
and send an ICMP error message to the source) is not supported in
\'ietf-dots-data-channel\' because it is not appropriate in the context
of DDoS mitigation. Generating ICMP messages to notify of drops when
mitigating a DDoS attack will exacerbate the DDoS attack. Furthermore,
these ICMP messages will be used by an attacker as an explicit signal
that the traffic is being blocked.[¶](#section-4.1-14){.pilcrow}
:::
:::

::: {#filf}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Filtering Fields](#name-filtering-fields){.section-name .selfRef} {#name-filtering-fields}

The \'ietf-dots-data-channel\' module reuses the packet fields module
\'ietf-packet-fields\' \[[RFC8519](#RFC8519){.xref}\], which defines
matching on fields in the packet including IPv4, IPv6, and transport
layer fields. The \'ietf-dots-data-channel\' module can be augmented,
for example, to support additional protocol-specific matching
fields.[¶](#section-4.2-1){.pilcrow}

This specification defines a new IPv4/IPv6 matching field called
\'fragment\' to efficiently handle fragment-related filtering rules.
Indeed, \[[RFC8519](#RFC8519){.xref}\] does not support such capability
for IPv6 but offers a partial support for IPv4 by means of \'flags\'.
Nevertheless, the use of \'flags\' is problematic since it does not
allow a bitmask to be defined. For example, setting other bits not
covered by the \'flags\' filtering clause in a packet will allow that
packet to get through (because it won\'t match the ACE). Examples to
illustrate how \'fragment\' can be used are provided in [Appendix
A](#frag){.xref}.[¶](#section-4.2-2){.pilcrow}

[Figure 6](#tipv4){.xref} shows the IPv4 match
subtree.[¶](#section-4.2-3){.pilcrow}

[]{#name-dots-acls-subtree-ipv4-matc}

::: {#tipv4}
::: {#section-4.2-4.1}
``` {.sourcecode .lang-yangtree}
module: ietf-dots-data-channel
  +--rw dots-data
     +--rw dots-client* [cuid]
     |  ...
     |  +--rw acls
     |     +--rw acl* [name]
     |        ...
     |        +--rw aces
     |           +--rw ace* [name]
     |              +--rw name          string
     |              +--rw matches
     |              |  +--rw (l3)?
     |              |  |  +--:(ipv4)
     |              |  |  |  +--rw ipv4
     |              |  |  |     +--rw dscp?                 inet:dscp
     |              |  |  |     +--rw ecn?                  uint8
     |              |  |  |     +--rw length?               uint16
     |              |  |  |     +--rw ttl?                  uint8
     |              |  |  |     +--rw protocol?             uint8
     |              |  |  |     +--rw ihl?                  uint8
     |              |  |  |     +--rw flags?                bits
     |              |  |  |     +--rw offset?               uint16
     |              |  |  |     +--rw identification?       uint16
     |              |  |  |     +--rw (destination-network)?
     |              |  |  |     |  +--:(destination-ipv4-network)
     |              |  |  |     |     +--rw destination-ipv4-network?
     |              |  |  |     |             inet:ipv4-prefix
     |              |  |  |     +--rw (source-network)?
     |              |  |  |     |  +--:(source-ipv4-network)
     |              |  |  |     |     +--rw source-ipv4-network?
     |              |  |  |     |             inet:ipv4-prefix
     |              |  |  |     +--rw fragment
     |              |  |  |        +--rw operator?        operator
     |              |  |  |        +--rw type        fragment-type
     |              |  |  +--:(ipv6)
     |              |  |     ...
     |              |  +--rw (l4)?
     |              |     ...
     |              +--rw actions
     |              |  ...
     |              +--ro statistics
     |                 ...
     +--ro capabilities
        ...
```
:::

[Figure 6](#figure-6){.selfRef}: [DOTS ACLs Subtree (IPv4
Match)](#name-dots-acls-subtree-ipv4-matc){.selfRef}
:::

[Figure 7](#tipv6){.xref} shows the IPv6 match
subtree.[¶](#section-4.2-5){.pilcrow}

[]{#name-dots-acls-subtree-ipv6-matc}

::: {#tipv6}
::: {#section-4.2-6.1}
``` {.sourcecode .lang-yangtree}
module: ietf-dots-data-channel
  +--rw dots-data
     +--rw dots-client* [cuid]
     |  ...
     |  +--rw acls
     |     +--rw acl* [name]
     |        ...
     |        +--rw aces
     |           +--rw ace* [name]
     |              +--rw name          string
     |              +--rw matches
     |              |  +--rw (l3)?
     |              |  |  +--:(ipv4)
     |              |  |  |  ...
     |              |  |  +--:(ipv6)
     |              |  |     +--rw ipv6
     |              |  |        +--rw dscp?                 inet:dscp
     |              |  |        +--rw ecn?                  uint8
     |              |  |        +--rw length?               uint16
     |              |  |        +--rw ttl?                  uint8
     |              |  |        +--rw protocol?             uint8
     |              |  |        +--rw (destination-network)?
     |              |  |        |  +--:(destination-ipv6-network)
     |              |  |        |     +--rw destination-ipv6-network?
     |              |  |        |             inet:ipv6-prefix
     |              |  |        +--rw (source-network)?
     |              |  |        |  +--:(source-ipv6-network)
     |              |  |        |     +--rw source-ipv6-network?
     |              |  |        |             inet:ipv6-prefix
     |              |  |        +--rw flow-label?
     |              |  |        |       inet:ipv6-flow-label
     |              |  |        +--rw fragment
     |              |  |           +--rw operator?       operator
     |              |  |           +--rw type       fragment-type
     |              |  +--rw (l4)?
     |              |     ...
     |              +--rw actions
     |              |  ...
     |              +--ro statistics
     |                 ...
     +--ro capabilities
        ...
```
:::

[Figure 7](#figure-7){.selfRef}: [DOTS ACLs Subtree (IPv6
Match)](#name-dots-acls-subtree-ipv6-matc){.selfRef}
:::

[Figure 8](#ttcp){.xref} shows the TCP match subtree. In addition to the
fields defined in \[[RFC8519](#RFC8519){.xref}\], this specification
defines a new TCP matching field, called \'flags-bitmask\', to
efficiently handle TCP flags filtering rules. Some examples are provided
in [Appendix B](#flags){.xref}.[¶](#section-4.2-7){.pilcrow}

[]{#name-dots-acls-subtree-tcp-match}

::: {#ttcp}
::: {#section-4.2-8.1}
``` {.sourcecode .lang-yangtree}
   +--rw matches
   |  +--rw (l3)?
   |  |  ...
   |  +--rw (l4)?
   |     +--:(tcp)
   |     |  +--rw tcp
   |     |     +--rw sequence-number?          uint32
   |     |     +--rw acknowledgement-number?   uint32
   |     |     +--rw data-offset?              uint8
   |     |     +--rw reserved?                 uint8
   |     |     +--rw flags?                    bits
   |     |     +--rw window-size?              uint16
   |     |     +--rw urgent-pointer?           uint16
   |     |     +--rw options?                  binary
   |     |     +--rw flags-bitmask
   |     |     |  +--rw operator?            operator
   |     |     |  +--rw bitmask                uint16
   |     |     +--rw (source-port)?
   |     |     |  +--:(source-port-range-or-operator)
   |     |     |     +--rw source-port-range-or-operator
   |     |     |        +--rw (port-range-or-operator)?
   |     |     |           +--:(range)
   |     |     |           |  +--rw lower-port
   |     |     |           |  |       inet:port-number
   |     |     |           |  +--rw upper-port
   |     |     |           |          inet:port-number
   |     |     |           +--:(operator)
   |     |     |              +--rw operator?
   |     |     |              |       operator
   |     |     |              +--rw port
   |     |     |                      inet:port-number
   |     |     +--rw (destination-port)?
   |     |        +--:(destination-port-range-or-operator)
   |     |           +--rw destination-port-range-or-operator
   |     |              +--rw (port-range-or-operator)?
   |     |                 +--:(range)
   |     |                 |  +--rw lower-port
   |     |                 |  |       inet:port-number
   |     |                 |  +--rw upper-port
   |     |                 |          inet:port-number
   |     |                 +--:(operator)
   |     |                    +--rw operator?
   |     |                    |       operator
   |     |                    +--rw port
   |     |                            inet:port-number
   |     +--:(udp)
   |     |  ...
   |     +--:(icmp)
   |        ...
   +--rw actions
   |  ...
```
:::

[Figure 8](#figure-8){.selfRef}: [DOTS ACLs Subtree (TCP
Match)](#name-dots-acls-subtree-tcp-match){.selfRef}
:::

[Figure 9](#ttransport){.xref} shows the UDP and ICMP match subtrees.
The same structure is used for both ICMP and ICMPv6. The indication
whether an ACL is about ICMP or ICMPv6 is governed by the \'l3\' match
or the ACL type.[¶](#section-4.2-9){.pilcrow}

[]{#name-dots-acls-subtree-udp-and-i}

::: {#ttransport}
::: {#section-4.2-10.1}
``` {.sourcecode .lang-yangtree}
   +--rw matches
   |  +--rw (l3)?
   |  |  ...
   |  +--rw (l4)?
   |     +--:(tcp)
   |     |  ...
   |     +--:(udp)
   |     |  +--rw udp
   |     |     +--rw length?          uint16
   |     |     +--rw (source-port)?
   |     |     |  +--:(source-port-range-or-operator)
   |     |     |     +--rw source-port-range-or-operator
   |     |     |        +--rw (port-range-or-operator)?
   |     |     |           +--:(range)
   |     |     |           |  +--rw lower-port
   |     |     |           |  |       inet:port-number
   |     |     |           |  +--rw upper-port
   |     |     |           |          inet:port-number
   |     |     |           +--:(operator)
   |     |     |              +--rw operator?
   |     |     |              |       operator
   |     |     |              +--rw port
   |     |     |                      inet:port-number
   |     |     +--rw (destination-port)?
   |     |        +--:(destination-port-range-or-operator)
   |     |           +--rw destination-port-range-or-operator
   |     |              +--rw (port-range-or-operator)?
   |     |                 +--:(range)
   |     |                 |  +--rw lower-port
   |     |                 |  |       inet:port-number
   |     |                 |  +--rw upper-port
   |     |                 |          inet:port-number
   |     |                 +--:(operator)
   |     |                    +--rw operator?
   |     |                    |       operator
   |     |                    +--rw port
   |     |                            inet:port-number
   |     +--:(icmp)
   |        +--rw icmp
   |           +--rw type?             uint8
   |           +--rw code?             uint8
   |           +--rw rest-of-header?   binary
   +--rw actions
   |  ...
```
:::

[Figure 9](#figure-9){.selfRef}: [DOTS ACLs Subtree (UDP and ICMP
Match)](#name-dots-acls-subtree-udp-and-i){.selfRef}
:::

DOTS implementations [MUST]{.bcp14} support the following matching
criteria:[¶](#section-4.2-11){.pilcrow}

-   [Match based on the IP header (IPv4 and IPv6), match based on the
    transport header (TCP, UDP, and ICMP), and match based on any
    combination thereof. The same matching fields are used for both ICMP
    and ICMPv6.[¶](#section-4.2-12.1){.pilcrow}]{#section-4.2-12.1}

The following match fields [MUST]{.bcp14} be supported by DOTS
implementations ([Table 1](#mf){.xref}):[¶](#section-4.2-13){.pilcrow}

[]{#name-mandatory-dots-channel-matc}

::: {#mf}
  ACL Match   Mandatory Fields
  ----------- --------------------------------------------------------------------------------------
  ipv4        length, protocol, destination-ipv4-network, source-ipv4-network, and fragment
  ipv6        length, protocol, destination-ipv6-network, source-ipv6-network, and fragment
  tcp         flags-bitmask, source-port-range-or-operator, and destination-port-range-or-operator
  udp         length, source-port-range-or-operator, and destination-port-range-or-operator
  icmp        type and code

  : [Table 1](#table-1){.selfRef}: [Mandatory DOTS Channel Match
  Fields](#name-mandatory-dots-channel-matc){.selfRef}
:::

Implementations [MAY]{.bcp14} support other filtering match fields and
actions. The \'ietf-dots-data-channel\' YANG module provides a method
for an implementation to expose its filtering capabilities. The tree
structure of the \'capabilities\' is shown in [Figure 10](#tcap){.xref}.
DOTS clients that support both \'fragment\' and \'flags\' (or
\'flags-bitmask\' and \'flags\') matching fields [MUST NOT]{.bcp14} set
these fields in the same request.[¶](#section-4.2-15){.pilcrow}

[]{#name-filtering-capabilities-subt}

::: {#tcap}
::: {#section-4.2-16.1}
``` {.sourcecode .lang-yangtree}
module: ietf-dots-data-channel
  +--rw dots-data
     ...
     +--ro capabilities
        +--ro address-family*        enumeration
        +--ro forwarding-actions*    identityref
        +--ro rate-limit?            boolean
        +--ro transport-protocols*   uint8
        +--ro ipv4
        |  +--ro dscp?                 boolean
        |  +--ro ecn?                  boolean
        |  +--ro length?               boolean
        |  +--ro ttl?                  boolean
        |  +--ro protocol?             boolean
        |  +--ro ihl?                  boolean
        |  +--ro flags?                boolean
        |  +--ro offset?               boolean
        |  +--ro identification?       boolean
        |  +--ro source-prefix?        boolean
        |  +--ro destination-prefix?   boolean
        |  +--ro fragment?             boolean
        +--ro ipv6
        |  +--ro dscp?                 boolean
        |  +--ro ecn?                  boolean
        |  +--ro length?               boolean
        |  +--ro hoplimit?             boolean
        |  +--ro protocol?             boolean
        |  +--ro destination-prefix?   boolean
        |  +--ro source-prefix?        boolean
        |  +--ro flow-label?           boolean
        |  +--ro fragment?             boolean
        +--ro tcp
        |  +--ro sequence-number?          boolean
        |  +--ro acknowledgement-number?   boolean
        |  +--ro data-offset?              boolean
        |  +--ro reserved?                 boolean
        |  +--ro flags?                    boolean
        |  +--ro window-size?              boolean
        |  +--ro urgent-pointer?           boolean
        |  +--ro options?                  boolean
        |  +--ro flags-bitmask?            boolean
        |  +--ro source-port?              boolean
        |  +--ro destination-port?         boolean
        |  +--ro port-range?               boolean
        +--ro udp
        |  +--ro length?             boolean
        |  +--ro source-port?        boolean
        |  +--ro destination-port?   boolean
        |  +--ro port-range?         boolean
        +--ro icmp
           +--ro type?             boolean
           +--ro code?             boolean
           +--ro rest-of-header?   boolean
```
:::

[Figure 10](#figure-10){.selfRef}: [Filtering Capabilities
Subtree](#name-filtering-capabilities-subt){.selfRef}
:::
:::
:::

::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [YANG Module](#name-yang-module){.section-name .selfRef} {#name-yang-module}

This module uses the common YANG types defined in
\[[RFC6991](#RFC6991){.xref}\] and types defined in
\[[RFC8519](#RFC8519){.xref}\].[¶](#section-4.3-1){.pilcrow}

::: {#section-4.3-2}
``` {.sourcecode .lang-yang}
<CODE BEGINS> file "ietf-dots-data-channel@2020-05-28.yang"

module ietf-dots-data-channel {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-dots-data-channel";
  prefix data-channel;

  import ietf-inet-types {
    prefix inet;
    reference
      "Section 4 of RFC 6991";
  }
  import ietf-access-control-list {
    prefix ietf-acl;
    reference
      "RFC 8519: YANG Data Model for Network Access
                 Control Lists (ACLs)";
  }
  import ietf-packet-fields {
    prefix packet-fields;
    reference
      "RFC 8519: YANG Data Model for Network Access
                 Control Lists (ACLs)";
  }

  organization
    "IETF DDoS Open Threat Signaling (DOTS) Working Group";
  contact
    "WG Web:   <https://datatracker.ietf.org/wg/dots/>
     WG List:  <mailto:dots@ietf.org>

     Editor:  Mohamed Boucadair
              <mailto:mohamed.boucadair@orange.com>

     Editor:  Konda, Tirumaleswar Reddy.K
              <mailto:TirumaleswarReddy_Konda@McAfee.com>

     Author:  Jon Shallow
              <mailto:jon.shallow@nccgroup.com>

     Author:  Kaname Nishizuka
              <mailto:kaname@nttv6.jp>

     Author:  Liang Xia
              <mailto:frank.xialiang@huawei.com>

     Author:  Prashanth Patil
              <mailto:praspati@cisco.com>

     Author:  Andrew Mortensen
              <mailto:amortensen@arbor.net>

     Author:  Nik Teague
              <mailto:nteague@ironmountain.co.uk>";
  description
    "This module contains YANG definition for configuring
     aliases for resources and filtering rules using DOTS
     data channel.

     Copyright (c) 2020 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 8783; see
     the RFC itself for full legal notices.";

  revision 2020-05-28 {
    description
      "Initial revision.";
    reference
      "RFC 8783: Distributed Denial-of-Service Open Threat
                 Signaling (DOTS) Data Channel Specification";
  }

  typedef activation-type {
    type enumeration {
      enum activate-when-mitigating {
        value 1;
        description
          "The Access Control List (ACL) is installed only when
           a mitigation is active for the DOTS client.";
      }
      enum immediate {
        value 2;
        description
          "The ACL is immediately activated.";
      }
      enum deactivate {
        value 3;
        description
          "The ACL is maintained by the DOTS server, but it is
           deactivated.";
      }
    }
    description
      "Indicates the activation type of an ACL.";
  }

  typedef operator {
    type bits {
      bit not {
        position 0;
        description
          "If set, logical negation of operation.";
      }
      bit match {
        position 1;
        description
          "Match bit.  This is a bitwise match operation
           defined as '(data & value) == value'.";
      }
      bit any {
        position 3;
        description
          "Any bit.  This is a match on any of the bits in
           bitmask.  It evaluates to 'true' if any of the bits
           in the value mask are set in the data,
           i.e., '(data & value) != 0'.";
      }
    }
    description
      "Specifies how to apply the defined bitmask.
       'any' and 'match' bits must not be set simultaneously.";
  }

  grouping tcp-flags {
    leaf operator {
      type operator;
      default "match";
      description
        "Specifies how to interpret the TCP flags.";
    }
    leaf bitmask {
      type uint16;
      mandatory true;
      description
        "The bitmask matches the last 4 bits of byte 12
         and byte 13 of the TCP header.  For clarity, the 4 bits
         of byte 12 corresponding to the TCP data offset field
         are not included in any matching.";
    }
    description
      "Operations on TCP flags.";
  }

  typedef fragment-type {
    type bits {
      bit df {
        position 0;
        description
          "Don't fragment bit for IPv4.
           Must be set to 0 when it appears in an IPv6 filter.";
      }
      bit isf {
        position 1;
        description
          "Is a fragment.";
      }
      bit ff {
        position 2;
        description
          "First fragment.";
      }
      bit lf {
        position 3;
        description
          "Last fragment.";
      }
    }
    description
      "Different fragment types to match against.";
  }

  grouping target {
    description
      "Specifies the targets of the mitigation request.";
    leaf-list target-prefix {
      type inet:ip-prefix;
      description
        "IPv4 or IPv6 prefix identifying the target.";
    }
    list target-port-range {
      key "lower-port";
      description
        "Port range.  When only lower-port is
         present, it represents a single port number.";
      leaf lower-port {
        type inet:port-number;
        mandatory true;
        description
          "Lower port number of the port range.";
      }
      leaf upper-port {
        type inet:port-number;
        must '. >= ../lower-port' {
          error-message
            "The upper-port number must be greater than
             or equal to the lower-port number.";
        }
        description
          "Upper port number of the port range.";
      }
    }
    leaf-list target-protocol {
      type uint8;
      description
        "Identifies the target protocol number.

         Values are taken from the IANA protocol registry:
         https://www.iana.org/assignments/protocol-numbers/

         For example, 6 for TCP or 17 for UDP.";
    }
    leaf-list target-fqdn {
      type inet:domain-name;
      description
        "FQDN identifying the target.";
    }
    leaf-list target-uri {
      type inet:uri;
      description
        "URI identifying the target.";
    }
  }

  grouping fragment-fields {
    leaf operator {
      type operator;
      default "match";
      description
        "Specifies how to interpret the fragment type.";
    }
    leaf type {
      type fragment-type;
      mandatory true;
      description
        "Indicates what fragment type to look for.";
    }
    description
      "Operations on fragment types.";
  }

  grouping aliases {
    description
      "Top-level container for aliases.";
    list alias {
      key "name";
      description
        "List of aliases.";
      leaf name {
        type string;
        description
          "The name of the alias.";
      }
      uses target;
      leaf pending-lifetime {
        type int32;
        units "minutes";
        config false;
        description
          "Indicates the pending validity lifetime of the alias
           entry.";
      }
    }
  }

  grouping ports {
    choice source-port {
      container source-port-range-or-operator {
        uses packet-fields:port-range-or-operator;
        description
          "Source port definition.";
      }
      description
        "Choice of specifying the source port or referring to
         a group of source port numbers.";
    }
    choice destination-port {
      container destination-port-range-or-operator {
        uses packet-fields:port-range-or-operator;
        description
          "Destination port definition.";
      }
      description
        "Choice of specifying a destination port or referring
         to a group of destination port numbers.";
    }
    description
      "Choice of specifying a source or destination port numbers.";
  }

  grouping access-lists {
    description
      "Specifies the ordered set of Access Control Lists.";
    list acl {
      key "name";
      ordered-by user;
      description
        "An ACL is an ordered list of Access Control Entries (ACE).
         Each ACE has a list of match criteria and a list of
         actions.";
      leaf name {
        type string {
          length "1..64";
        }
        description
          "The name of the access list.";
        reference
          "RFC 8519: YANG Data Model for Network Access
                     Control Lists (ACLs)";
      }
      leaf type {
        type ietf-acl:acl-type;
        description
          "Type of access control list.  Indicates the primary
           intended type of match criteria (e.g., IPv4, IPv6)
           used in the list instance.";
        reference
          "RFC 8519: YANG Data Model for Network Access
                     Control Lists (ACLs)";
      }
      leaf activation-type {
        type activation-type;
        default "activate-when-mitigating";
        description
          "Indicates the activation type of an ACL.  An ACL can be
           deactivated, installed immediately, or installed when
           a mitigation is active.";
      }
      leaf pending-lifetime {
        type int32;
        units "minutes";
        config false;
        description
          "Indicates the pending validity lifetime of the ACL
           entry.";
      }
      container aces {
        description
          "The Access Control Entries container contains
           a list of ACEs.";
        list ace {
          key "name";
          ordered-by user;
          description
            "List of access list entries.";
          leaf name {
            type string {
              length "1..64";
            }
            description
              "A unique name identifying this ACE.";
            reference
              "RFC 8519: YANG Data Model for Network Access
                         Control Lists (ACLs)";
          }
          container matches {
            description
              "The rules in this set determine what fields will be
               matched upon before any action is taken on them.

               If no matches are defined in a particular container,
               then any packet will match that container.

               If no matches are specified at all in an ACE, then any
               packet will match the ACE.";
            reference
              "RFC 8519: YANG Data Model for Network Access
                         Control Lists (ACLs)";
            choice l3 {
              container ipv4 {
                when "derived-from(../../../../type, "
                   + "'ietf-acl:ipv4-acl-type')";
                uses packet-fields:acl-ip-header-fields;
                uses packet-fields:acl-ipv4-header-fields;
                container fragment {
                  description
                    "Indicates how to handle IPv4 fragments.";
                  uses fragment-fields;
                }
                description
                  "Rule set that matches IPv4 header.";
              }
              container ipv6 {
                when "derived-from(../../../../type, "
                   + "'ietf-acl:ipv6-acl-type')";
                uses packet-fields:acl-ip-header-fields;
                uses packet-fields:acl-ipv6-header-fields;
                container fragment {
                  description
                    "Indicates how to handle IPv6 fragments.";
                  uses fragment-fields;
                }
                description
                  "Rule set that matches IPv6 header.";
              }
              description
                "Either IPv4 or IPv6.";
            }
            choice l4 {
              container tcp {
                uses packet-fields:acl-tcp-header-fields;
                container flags-bitmask {
                  description
                    "Indicates how to handle TCP flags.";
                  uses tcp-flags;
                }
                uses ports;
                description
                  "Rule set that matches TCP header.";
              }
              container udp {
                uses packet-fields:acl-udp-header-fields;
                uses ports;
                description
                  "Rule set that matches UDP header.";
              }
              container icmp {
                uses packet-fields:acl-icmp-header-fields;
                description
                  "Rule set that matches ICMP/ICMPv6 header.";
              }
              description
                "Can be TCP, UDP, or ICMP/ICMPv6";
            }
          }
          container actions {
            description
              "Definitions of action for this ACE.";
            leaf forwarding {
              type identityref {
                base ietf-acl:forwarding-action;
              }
              mandatory true;
              description
                "Specifies the forwarding action per ACE.";
              reference
                "RFC 8519: YANG Data Model for Network Access
                           Control Lists (ACLs)";
            }
            leaf rate-limit {
              when "../forwarding = 'ietf-acl:accept'" {
                description
                  "Rate-limit is valid only when accept action is
                   used.";
              }
              type decimal64 {
                fraction-digits 2;
              }
              units "bytes per second";
              description
                "Specifies how to rate-limit the traffic.";
            }
          }
          container statistics {
            config false;
            description
              "Aggregate statistics.";
            uses ietf-acl:acl-counters;
          }
        }
      }
    }
  }

  container dots-data {
    description
      "Main container for DOTS data channel.";
    list dots-client {
      key "cuid";
      description
        "List of DOTS clients.";
      leaf cuid {
        type string;
        description
          "A unique identifier that is generated by a DOTS client
           to prevent request collisions.";
        reference
          "RFC 8782: Distributed Denial-of-Service Open Threat
                  Signaling (DOTS) Signal Channel Specification";
      }
      leaf cdid {
        type string;
        description
          "A client domain identifier conveyed by a
           server-domain DOTS gateway to a remote DOTS server.";
        reference
          "RFC 8782: Distributed Denial-of-Service Open Threat
                  Signaling (DOTS) Signal Channel Specification";
      }
      container aliases {
        description
          "Set of aliases that are bound to a DOTS client.";
        uses aliases;
      }
      container acls {
        description
          "Access lists that are bound to a DOTS client.";
        uses access-lists;
      }
    }
    container capabilities {
      config false;
      description
        "Match capabilities";
      leaf-list address-family {
        type enumeration {
          enum ipv4 {
            description
              "IPv4 is supported.";
          }
          enum ipv6 {
            description
              "IPv6 is supported.";
          }
        }
        description
          "Indicates the IP address families supported by
           the DOTS server.";
      }
      leaf-list forwarding-actions {
        type identityref {
          base ietf-acl:forwarding-action;
        }
        description
          "Supported forwarding action(s).";
      }
      leaf rate-limit {
        type boolean;
        description
          "Support of rate-limit action.";
      }
      leaf-list transport-protocols {
        type uint8;
        description
          "Upper-layer protocol associated with a filtering rule.

           Values are taken from the IANA protocol registry:
           https://www.iana.org/assignments/protocol-numbers/

           For example, this field contains 1 for ICMP, 6 for TCP
           17 for UDP, or 58 for ICMPv6.";
      }
      container ipv4 {
        description
          "Indicates IPv4 header fields that are supported to enforce
           ACLs.";
        leaf dscp {
          type boolean;
          description
            "Support of filtering based on Differentiated Services
             Code Point (DSCP).";
        }
        leaf ecn {
          type boolean;
          description
            "Support of filtering based on Explicit Congestion
             Notification (ECN).";
        }
        leaf length {
          type boolean;
          description
            "Support of filtering based on the Total Length.";
        }
        leaf ttl {
          type boolean;
          description
            "Support of filtering based on the Time to Live (TTL).";
        }
        leaf protocol {
          type boolean;
          description
            "Support of filtering based on protocol field.";
        }
        leaf ihl {
          type boolean;
          description
            "Support of filtering based on the Internet Header
             Length (IHL).";
        }
        leaf flags {
          type boolean;
          description
            "Support of filtering based on the 'flags'.";
        }
        leaf offset {
          type boolean;
          description
            "Support of filtering based on the 'offset'.";
        }
        leaf identification {
          type boolean;
          description
            "Support of filtering based on the 'identification'.";
        }
        leaf source-prefix {
          type boolean;
          description
            "Support of filtering based on the source prefix.";
        }
        leaf destination-prefix {
          type boolean;
          description
            "Support of filtering based on the destination prefix.";
        }
        leaf fragment {
          type boolean;
          description
            "Indicates the capability of a DOTS server to
             enforce filters on IPv4 fragments.  That is, the match
             functionality based on the Layer 3 'fragment' clause
             is supported.";
        }
      }
      container ipv6 {
        description
          "Indicates IPv6 header fields that are supported to enforce
           ACLs.";
        leaf dscp {
          type boolean;
          description
            "Support of filtering based on DSCP.";
        }
        leaf ecn {
          type boolean;
          description
            "Support of filtering based on ECN.";
        }
        leaf length {
          type boolean;
          description
            "Support of filtering based on the Payload Length.";
        }
        leaf hoplimit {
          type boolean;
          description
            "Support of filtering based on the Hop Limit.";
        }
        leaf protocol {
          type boolean;
          description
            "Support of filtering based on the Next Header field.";
        }
        leaf destination-prefix {
          type boolean;
          description
            "Support of filtering based on the destination prefix.";
        }
        leaf source-prefix {
          type boolean;
          description
            "Support of filtering based on the source prefix.";
        }
        leaf flow-label {
          type boolean;
          description
            "Support of filtering based on the Flow Label.";
        }
        leaf fragment {
          type boolean;
          description
            "Indicates the capability of a DOTS server to
             enforce filters on IPv6 fragments.";
        }
      }
      container tcp {
        description
          "Set of TCP fields that are supported by the DOTS server
           to enforce filters.";
        leaf sequence-number {
          type boolean;
          description
            "Support of filtering based on the TCP sequence number.";
        }
        leaf acknowledgement-number {
          type boolean;
          description
            "Support of filtering based on the TCP acknowledgement
             number.";
        }
        leaf data-offset {
          type boolean;
          description
            "Support of filtering based on the TCP data-offset.";
        }
        leaf reserved {
          type boolean;
          description
            "Support of filtering based on the TCP reserved field.";
        }
        leaf flags {
          type boolean;
          description
            "Support of filtering, as defined in RFC 8519, based
             on the TCP flags.";
        }
        leaf window-size {
          type boolean;
          description
            "Support of filtering based on the TCP window size.";
        }
        leaf urgent-pointer {
          type boolean;
          description
            "Support of filtering based on the TCP urgent pointer.";
        }
        leaf options {
          type boolean;
          description
            "Support of filtering based on the TCP options.";
        }
        leaf flags-bitmask {
          type boolean;
          description
            "Support of filtering based on the TCP flags bitmask.";
        }
        leaf source-port {
          type boolean;
          description
            "Support of filtering based on the source port number.";
        }
        leaf destination-port {
          type boolean;
          description
            "Support of filtering based on the destination port
             number.";
        }
        leaf port-range {
          type boolean;
          description
            "Support of filtering based on a port range.

             This includes filtering based on a source port range,
             destination port range, or both.  All operators
             (i.e, less than or equal to, greater than or equal to,
             equal to, and not equal to) are supported.

             In particular, this means that the implementation
             supports filtering based on
             source-port-range-or-operator and
             destination-port-range-or-operator.";
        }
      }
      container udp {
        description
          "Set of UDP fields that are supported by the DOTS server
           to enforce filters.";
        leaf length {
          type boolean;
          description
            "Support of filtering based on the UDP length.";
        }
        leaf source-port {
          type boolean;
          description
            "Support of filtering based on the source port number.";
        }
        leaf destination-port {
          type boolean;
          description
            "Support of filtering based on the destination port
             number.";
        }
        leaf port-range {
          type boolean;
          description
            "Support of filtering based on a port range.

             This includes filtering based on a source port range,
             destination port range, or both.  All operators
             (i.e, less than or equal, greater than or equal,
             equal to, and not equal to) are supported.

             In particular, this means that the implementation
             supports filtering based on
             source-port-range-or-operator and
             destination-port-range-or-operator.";
        }
      }
      container icmp {
        description
          "Set of ICMP/ICMPv6 fields that are supported by the DOTS
           server to enforce filters.";
        leaf type {
          type boolean;
          description
            "Support of filtering based on the ICMP/ICMPv6 type.";
        }
        leaf code {
          type boolean;
          description
            "Support of filtering based on the ICMP/ICMPv6 code.";
        }
        leaf rest-of-header {
          type boolean;
          description
            "Support of filtering based on the ICMP four-byte
             field / the ICMPv6 message body.";
        }
      }
    }
  }
}

<CODE ENDS>
```

[¶](#section-4.3-2){.pilcrow}
:::
:::
:::
:::

::: {#registering}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Managing DOTS Clients](#name-managing-dots-clients){.section-name .selfRef} {#name-managing-dots-clients}

::: {#registe}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Registering DOTS Clients](#name-registering-dots-clients){.section-name .selfRef} {#name-registering-dots-clients}

In order to make use of the DOTS data channel, a DOTS client
[MUST]{.bcp14} register with its DOTS server(s) by creating a DOTS
client (\'dots-client\') resource. To that aim, DOTS clients
[SHOULD]{.bcp14} send a POST request (shown in [Figure
11](#register){.xref}).[¶](#section-5.1-1){.pilcrow}

[]{#name-post-to-register-schema}

::: {#register}
::: {#section-5.1-2.1}
``` sourcecode
 POST /restconf/data/ietf-dots-data-channel:dots-data HTTP/1.1
 Host: {host}:{port}
 Content-Type: application/yang-data+json

 {
   "ietf-dots-data-channel:dots-client": [
     {
       "cuid": "string"
     }
   ]
 }
```
:::

[Figure 11](#figure-11){.selfRef}: [POST to Register
Schema](#name-post-to-register-schema){.selfRef}
:::

The \'cuid\' (client unique identifier) parameter is described
below:[¶](#section-5.1-3){.pilcrow}

cuid:

:   A globally unique identifier that is meant to prevent collisions
    among DOTS clients. This attribute has the same meaning, syntax, and
    processing rules as the \'cuid\' attribute defined in
    \[[RFC8782](#RFC8782){.xref}\].[¶](#section-5.1-4.2.1){.pilcrow}

    DOTS clients [MUST]{.bcp14} use the same \'cuid\' for both signal
    and data channels.[¶](#section-5.1-4.2.2){.pilcrow}

    This is a mandatory attribute.[¶](#section-5.1-4.2.3){.pilcrow}

:   

In deployments where server-domain DOTS gateways are enabled, identity
information about the origin source client domain [SHOULD]{.bcp14} be
supplied to the DOTS server. That information is meant to assist the
DOTS server to enforce some policies. These policies can be enforced per
client, per client domain, or both. [Figure
12](#register-relayed){.xref} shows a schema of a register request
relayed by a server-domain DOTS gateway.[¶](#section-5.1-5){.pilcrow}

[]{#name-post-to-register-schema-via}

::: {#register-relayed}
::: {#section-5.1-6.1}
``` sourcecode
 POST /restconf/data/ietf-dots-data-channel:dots-data HTTP/1.1
 Host: {host}:{port}
 Content-Type: application/yang-data+json

 {
   "ietf-dots-data-channel:dots-client": [
     {
       "cuid": "string",
       "cdid": "string"
     }
   ]
 }
```
:::

[Figure 12](#figure-12){.selfRef}: [POST to Register Schema (via a
Server-Domain DOTS
Gateway)](#name-post-to-register-schema-via){.selfRef}
:::

A server-domain DOTS gateway [SHOULD]{.bcp14} add the following
attribute:[¶](#section-5.1-7){.pilcrow}

cdid:

:   This attribute has the same meaning, syntax, and processing rules as
    the \'cdid\' attribute defined in
    \[[RFC8782](#RFC8782){.xref}\].[¶](#section-5.1-8.2.1){.pilcrow}

    In deployments where server-domain DOTS gateways are enabled,
    \'cdid\' does not need to be inserted when relaying DOTS methods to
    manage aliases ([Section 6](#identifier){.xref}) or filtering rules
    ([Section 7](#filter){.xref}). DOTS servers are responsible for
    maintaining the association between \'cdid\' and \'cuid\' for policy
    enforcement purposes.[¶](#section-5.1-8.2.2){.pilcrow}

    This is an optional attribute.[¶](#section-5.1-8.2.3){.pilcrow}

:   

An example request to create a \'dots-client\' resource is depicted in
[Figure 13](#register-example){.xref}. This request is relayed by a
server-domain DOTS gateway as hinted by the presence of the \'cdid\'
attribute.[¶](#section-5.1-9){.pilcrow}

[]{#name-post-to-register-dots-gatew}

::: {#register-example}
::: {#section-5.1-10.1}
``` sourcecode
 POST /restconf/data/ietf-dots-data-channel:dots-data HTTP/1.1
 Host: example.com
 Content-Type: application/yang-data+json

 {
   "ietf-dots-data-channel:dots-client": [
     {
       "cuid": "dz6pHjaADkaFTbjr0JGBpw",
       "cdid": "7eeaf349529eb55ed50113"
     }
   ]
 }
```
:::

[Figure 13](#figure-13){.selfRef}: [POST to Register (DOTS
gateway)](#name-post-to-register-dots-gatew){.selfRef}
:::

As a reminder, DOTS gateways may rewrite the \'cuid\' used by peer DOTS
clients ([Section
4.4.1](https://www.rfc-editor.org/rfc/rfc8782#section-4.4.1){.relref} of
\[[RFC8782](#RFC8782){.xref}\]).[¶](#section-5.1-11){.pilcrow}

DOTS servers can identify the DOTS client domain using the \'cdid\'
parameter or using the client\'s DNS name specified in the Subject
Alternative Name extension\'s dNSName type in the client certificate
\[[RFC6125](#RFC6125){.xref}\].[¶](#section-5.1-12){.pilcrow}

DOTS servers [MUST]{.bcp14} limit the number of \'dots-client\'
resources to be created by the same DOTS client to 1 per request.
Requests with multiple \'dots-client\' resources [MUST]{.bcp14} be
rejected by DOTS servers. To that aim, the DOTS server [MUST]{.bcp14}
rely on the same procedure to unambiguously identify a DOTS client as
discussed in [Section
4.4.1](https://www.rfc-editor.org/rfc/rfc8782#section-4.4.1){.relref} of
\[[RFC8782](#RFC8782){.xref}\].[¶](#section-5.1-13){.pilcrow}

The DOTS server indicates the result of processing the POST request
using status-line codes. Status codes in the \"2xx\" range are success,
\"4xx\" codes are some sort of invalid requests and \"5xx\" codes are
returned if the DOTS server has erred or is incapable of accepting the
creation of the \'dots-client\' resource. In
particular,[¶](#section-5.1-14){.pilcrow}

-   [\"201 Created\" status-line is returned in the response if the DOTS
    server has accepted the
    request.[¶](#section-5.1-15.1){.pilcrow}]{#section-5.1-15.1}
-   [\"400 Bad Request\" status-line is returned by the DOTS server if
    the request does not include a \'cuid\' parameter. The error-tag
    \"missing-attribute\" is used in this
    case.[¶](#section-5.1-15.2){.pilcrow}]{#section-5.1-15.2}
-   [\"409 Conflict\" status-line is returned to the requesting DOTS
    client if the data resource already exists. The error-tag
    \"resource-denied\" is used in this
    case.[¶](#section-5.1-15.3){.pilcrow}]{#section-5.1-15.3}

Once a DOTS client registers itself with a DOTS server, it can
create/delete/retrieve aliases ([Section 6](#identifier){.xref}) and
filtering rules ([Section
7](#filter){.xref}).[¶](#section-5.1-16){.pilcrow}

A DOTS client [MAY]{.bcp14} use the PUT request ([Section
4.5](https://www.rfc-editor.org/rfc/rfc8040#section-4.5){.relref} of
\[[RFC8040](#RFC8040){.xref}\]) to register a DOTS client within the
DOTS server. An example is shown in [Figure
14](#putregister){.xref}.[¶](#section-5.1-17){.pilcrow}

[]{#name-put-to-register}

::: {#putregister}
::: {#section-5.1-18.1}
``` sourcecode
 PUT /restconf/data/ietf-dots-data-channel:dots-data\
     /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1
 Host: example.com
 Content-Type: application/yang-data+json

 {
   "ietf-dots-data-channel:dots-client": [
     {
       "cuid": "dz6pHjaADkaFTbjr0JGBpw"
     }
   ]
 }
```
:::

[Figure 14](#figure-14){.selfRef}: [PUT to
Register](#name-put-to-register){.selfRef}
:::

The DOTS gateway that inserted a \'cdid\' in a PUT request
[MUST]{.bcp14} strip the \'cdid\' parameter in the corresponding
response before forwarding the response to the DOTS
client.[¶](#section-5.1-19){.pilcrow}
:::
:::

::: {#unregistering}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [De-registering DOTS Clients](#name-de-registering-dots-clients){.section-name .selfRef} {#name-de-registering-dots-clients}

A DOTS client de-registers from its DOTS server(s) by deleting the
\'cuid\' resource(s). Resources bound to this DOTS client will be
deleted by the DOTS server. An example of a de-register request is shown
in [Figure 15](#derigister){.xref}.[¶](#section-5.2-1){.pilcrow}

[]{#name-de-register-a-dots-client}

::: {#derigister}
::: {#section-5.2-2.1}
``` sourcecode
 DELETE /restconf/data/ietf-dots-data-channel:dots-data\
        /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1
 Host: example.com
```
:::

[Figure 15](#figure-15){.selfRef}: [De-register a DOTS
Client](#name-de-register-a-dots-client){.selfRef}
:::
:::
:::
:::
:::

::: {#identifier}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Managing DOTS Aliases](#name-managing-dots-aliases){.section-name .selfRef} {#name-managing-dots-aliases}

The following subsections define the means for a DOTS client to create
aliases ([Section 6.1](#calias){.xref}), to retrieve one or a list of
aliases ([Section 6.2](#ralias){.xref}), and to delete an alias
([Section 6.3](#dalias){.xref}).[¶](#section-6-1){.pilcrow}

::: {#calias}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Creating Aliases](#name-creating-aliases){.section-name .selfRef} {#name-creating-aliases}

A POST or PUT request is used by a DOTS client to create aliases for
resources for which a mitigation may be requested. Such aliases may be
used in subsequent DOTS signal channel exchanges to refer more
efficiently to the resources under attack.[¶](#section-6.1-1){.pilcrow}

DOTS clients within the same domain can create different aliases for the
same resource.[¶](#section-6.1-2){.pilcrow}

The structure of POST requests used to create aliases is shown in
[Figure 16](#createalias){.xref}.[¶](#section-6.1-3){.pilcrow}

[]{#name-post-to-create-aliases-requ}

::: {#createalias}
::: {#section-6.1-4.1}
``` sourcecode
 POST /restconf/data/ietf-dots-data-channel:dots-data\
      /dots-client=cuid HTTP/1.1
 Host: {host}:{port}
 Content-Type: application/yang-data+json

 {
  "ietf-dots-data-channel:aliases": {
    "alias": [
      {
        "name": "string",
        "target-prefix": [
          "string"
        ],
        "target-port-range": [
          {
            "lower-port": integer,
            "upper-port": integer
          }
        ],
        "target-protocol": [
          integer
        ],
        "target-fqdn": [
          "string"
        ],
        "target-uri": [
          "string"
        ]
      }
    ]
  }
}
```
:::

[Figure 16](#figure-16){.selfRef}: [POST to Create Aliases (Request
Schema)](#name-post-to-create-aliases-requ){.selfRef}
:::

The parameters are described below:[¶](#section-6.1-5){.pilcrow}

name:

:   Name of the alias.[¶](#section-6.1-6.2.1){.pilcrow}

    This is a mandatory attribute.[¶](#section-6.1-6.2.2){.pilcrow}

:   

target-prefix:

:   Prefixes are separated by commas. Prefixes are represented using
    Classless Inter-domain Routing (CIDR) notation
    \[[RFC4632](#RFC4632){.xref}\]. As a reminder, the prefix length
    must be less than or equal to 32 for IPv4 or 128 for
    IPv6.[¶](#section-6.1-6.4.1){.pilcrow}

    The prefix list [MUST NOT]{.bcp14} include broadcast, loopback, or
    multicast addresses. These addresses are considered as invalid
    values. In addition, the DOTS server [MUST]{.bcp14} validate that
    these prefixes are within the scope of the DOTS client domain. Other
    validation checks may be supported by DOTS
    servers.[¶](#section-6.1-6.4.2){.pilcrow}

    This is an optional attribute.[¶](#section-6.1-6.4.3){.pilcrow}

:   

target-port-range:

:   A range of port numbers.[¶](#section-6.1-6.6.1){.pilcrow}

    The port range is defined by two bounds, a lower port number
    (\'lower-port\') and an upper port number (\'upper-port\'). The
    range is considered to include both the lower and upper
    bounds.[¶](#section-6.1-6.6.2){.pilcrow}

    When only \'lower-port\' is present, it represents a single port
    number.[¶](#section-6.1-6.6.3){.pilcrow}

    For TCP, UDP, Stream Control Transmission Protocol (SCTP)
    \[[RFC4960](#RFC4960){.xref}\], or Datagram Congestion Control
    Protocol (DCCP) \[[RFC4340](#RFC4340){.xref}\], the range of port
    numbers can be, for example,
    1024-65535.[¶](#section-6.1-6.6.4){.pilcrow}

    This is an optional attribute.[¶](#section-6.1-6.6.5){.pilcrow}

:   

target-protocol:

:   A list of protocols. Values are taken from the IANA protocol
    registry
    \[[IANA-PROTO](#IANA-PROTO){.xref}\].[¶](#section-6.1-6.8.1){.pilcrow}

    If \'target-protocol\' is not specified, then the request applies to
    any protocol.[¶](#section-6.1-6.8.2){.pilcrow}

    This is an optional attribute.[¶](#section-6.1-6.8.3){.pilcrow}

:   

target-fqdn:

:   A list of Fully Qualified Domain Names (FQDNs) identifying resources
    under attack
    \[[RFC8499](#RFC8499){.xref}\].[¶](#section-6.1-6.10.1){.pilcrow}

    How a name is passed to an underlying name resolution library is
    implementation and deployment specific. Nevertheless, once the name
    is resolved into one or multiple IP addresses, DOTS servers
    [MUST]{.bcp14} apply the same validation checks as those for
    \'target-prefix\'.[¶](#section-6.1-6.10.2){.pilcrow}

    The use of FQDNs may be suboptimal because it does not guarantee
    that the DOTS server will resolve a name to the same IP addresses
    that the DOTS client does.[¶](#section-6.1-6.10.3){.pilcrow}

    This is an optional attribute.[¶](#section-6.1-6.10.4){.pilcrow}

:   

target-uri:

:   A list of Uniform Resource Identifiers (URIs)
    \[[RFC3986](#RFC3986){.xref}\].[¶](#section-6.1-6.12.1){.pilcrow}

    The same validation checks used for \'target-fqdn\' [MUST]{.bcp14}
    be followed by DOTS servers to validate a target
    URI.[¶](#section-6.1-6.12.2){.pilcrow}

    This is an optional attribute.[¶](#section-6.1-6.12.3){.pilcrow}

:   

In POST or PUT requests, at least one of the \'target-prefix\',
\'target-fqdn\', or \'target-uri\' attributes [MUST]{.bcp14} be present.
DOTS agents can safely ignore vendor-specific parameters they don\'t
understand.[¶](#section-6.1-7){.pilcrow}

If more than one \'target-\*\' scope types (e.g., \'target-prefix\' and
\'target-fqdn\' or \'target-fqdn\' and \'target-uri\') are included in a
POST or PUT request, the DOTS server binds all resulting IP
addresses/prefixes to the same resource.[¶](#section-6.1-8){.pilcrow}

[Figure 17](#Figure2){.xref} shows a POST request to create an alias
called \"https1\" for HTTPS servers with IP addresses 2001:db8:6401::1
and 2001:db8:6401::2 listening on TCP port number
443.[¶](#section-6.1-9){.pilcrow}

[]{#name-example-of-a-post-to-create}

::: {#Figure2}
::: {#section-6.1-10.1}
``` sourcecode
POST /restconf/data/ietf-dots-data-channel:dots-data\
     /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-dots-data-channel:aliases": {
    "alias": [
      {
        "name": "https1",
        "target-protocol": [
          6
        ],
        "target-prefix": [
          "2001:db8:6401::1/128",
          "2001:db8:6401::2/128"
        ],
        "target-port-range": [
          {
            "lower-port": 443
          }
        ]
      }
    ]
  }
}
```
:::

[Figure 17](#figure-17){.selfRef}: [Example of a POST to Create an
Alias](#name-example-of-a-post-to-create){.selfRef}
:::

A \"201 Created\" status-line [MUST]{.bcp14} be returned in the response
if the DOTS server has accepted the alias.[¶](#section-6.1-11){.pilcrow}

A \"409 Conflict\" status-line [MUST]{.bcp14} be returned to the
requesting DOTS client, if the request is conflicting with an existing
alias name. The error-tag \"resource-denied\" is used in this
case.[¶](#section-6.1-12){.pilcrow}

If the request is missing a mandatory attribute or it contains an
invalid or unknown parameter, a \"400 Bad Request\" status-line
[MUST]{.bcp14} be returned by the DOTS server. The error-tag is set to
\"missing-attribute\", \"invalid-value\", or \"unknown-element\" as a
function of the encountered error.[¶](#section-6.1-13){.pilcrow}

If the request is received via a server-domain DOTS gateway, but the
DOTS server does not maintain a \'cdid\' for this \'cuid\' while a
\'cdid\' is expected to be supplied, the DOTS server [MUST]{.bcp14}
reply with a \"403 Forbidden\" status-line and the error-tag
\"access-denied\". Upon receipt of this message, the DOTS client
[MUST]{.bcp14} register ([Section
5](#registering){.xref}).[¶](#section-6.1-14){.pilcrow}

A DOTS client uses the PUT request to modify the aliases in the DOTS
server. In particular, a DOTS client [MUST]{.bcp14} update its alias
entries upon change of the prefix indicated in the
\'target-prefix\'.[¶](#section-6.1-15){.pilcrow}

A DOTS server [MUST]{.bcp14} maintain an alias for at least 10080
minutes (1 week). If no refresh request is seen from the DOTS client,
the DOTS server removes expired entries.[¶](#section-6.1-16){.pilcrow}
:::
:::

::: {#ralias}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Retrieving Installed Aliases](#name-retrieving-installed-aliase){.section-name .selfRef} {#name-retrieving-installed-aliase}

A GET request is used to retrieve one or all installed aliases by a DOTS
client from a DOTS server ([Section
3.3.1](https://www.rfc-editor.org/rfc/rfc8040#section-3.3.1){.relref} of
\[[RFC8040](#RFC8040){.xref}\]). If no \'name\' is included in the
request, this indicates that the request is about retrieving all aliases
instantiated by the DOTS client.[¶](#section-6.2-1){.pilcrow}

[Figure 18](#Figure4){.xref} shows an example to retrieve all the
aliases that were instantiated by the requesting DOTS client. The
\"content\" query parameter and its permitted values are defined in
[Section
4.8.1](https://www.rfc-editor.org/rfc/rfc8040#section-4.8.1){.relref} of
\[[RFC8040](#RFC8040){.xref}\].[¶](#section-6.2-2){.pilcrow}

[]{#name-get-to-retrieve-all-install}

::: {#Figure4}
::: {#section-6.2-3.1}
``` sourcecode
  GET /restconf/data/ietf-dots-data-channel:dots-data\
      /dots-client=dz6pHjaADkaFTbjr0JGBpw\
      /aliases?content=all HTTP/1.1
  Host: example.com
  Accept: application/yang-data+json
```
:::

[Figure 18](#figure-18){.selfRef}: [GET to Retrieve All Installed
Aliases](#name-get-to-retrieve-all-install){.selfRef}
:::

[Figure 19](#Figure6){.xref} shows an example of the response message
body that includes all the aliases that are maintained by the DOTS
server for the DOTS client identified by the \'cuid\'
parameter.[¶](#section-6.2-4){.pilcrow}

[]{#name-an-example-of-a-response-bo}

::: {#Figure6}
::: {#section-6.2-5.1}
``` sourcecode
{
  "ietf-dots-data-channel:aliases": {
    "alias": [
      {
        "name": "Server1",
        "target-protocol": [
          6
        ],
        "target-prefix": [
          "2001:db8:6401::1/128",
          "2001:db8:6401::2/128"
        ],
        "target-port-range": [
          {
            "lower-port": 443
          }
        ],
        "pending-lifetime": 3596
      },
      {
        "name": "Server2",
        "target-protocol": [
          6
        ],
        "target-prefix": [
          "2001:db8:6401::10/128",
          "2001:db8:6401::20/128"
        ],
        "target-port-range": [
          {
            "lower-port": 80
          }
        ],
        "pending-lifetime": 9869
      }
    ]
  }
}
```
:::

[Figure 19](#figure-19){.selfRef}: [An Example of a Response Body
Listing All Installed
Aliases](#name-an-example-of-a-response-bo){.selfRef}
:::

[Figure 20](#analias){.xref} shows an example of a GET request to
retrieve the alias \"Server2\" that was instantiated by the DOTS
client.[¶](#section-6.2-6){.pilcrow}

[]{#name-get-to-retrieve-an-alias}

::: {#analias}
::: {#section-6.2-7.1}
``` sourcecode
  GET /restconf/data/ietf-dots-data-channel:dots-data\
      /dots-client=dz6pHjaADkaFTbjr0JGBpw\
      /aliases/alias=Server2?content=all HTTP/1.1
  Host: example.com
  Accept: application/yang-data+json
```
:::

[Figure 20](#figure-20){.selfRef}: [GET to Retrieve an
Alias](#name-get-to-retrieve-an-alias){.selfRef}
:::

If an alias name (\'name\') is included in the request, but the DOTS
server does not find that alias name for this DOTS client in its
configuration data, it [MUST]{.bcp14} respond with a \"404 Not Found\"
status-line.[¶](#section-6.2-8){.pilcrow}
:::
:::

::: {#dalias}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Deleting Aliases](#name-deleting-aliases){.section-name .selfRef} {#name-deleting-aliases}

A DELETE request is used to delete an alias maintained by a DOTS
server.[¶](#section-6.3-1){.pilcrow}

If the DOTS server does not find the alias name that was conveyed in the
DELETE request in its configuration data for this DOTS client, it
[MUST]{.bcp14} respond with a \"404 Not Found\"
status-line.[¶](#section-6.3-2){.pilcrow}

The DOTS server successfully acknowledges a DOTS client\'s request to
remove the alias using \"204 No Content\" status-line in the
response.[¶](#section-6.3-3){.pilcrow}

[Figure 21](#Figure3){.xref} shows an example of a request to delete an
alias.[¶](#section-6.3-4){.pilcrow}

[]{#name-delete-an-alias}

::: {#Figure3}
::: {#section-6.3-5.1}
``` sourcecode
  DELETE /restconf/data/ietf-dots-data-channel:dots-data\
         /dots-client=dz6pHjaADkaFTbjr0JGBpw\
         /aliases/alias=Server1 HTTP/1.1
  Host: example.com
```
:::

[Figure 21](#figure-21){.selfRef}: [Delete an
Alias](#name-delete-an-alias){.selfRef}
:::
:::
:::
:::
:::

::: {#filter}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Managing DOTS Filtering Rules](#name-managing-dots-filtering-rul){.section-name .selfRef} {#name-managing-dots-filtering-rul}

The following subsections define the means for a DOTS client to retrieve
DOTS filtering capabilities ([Section 7.1](#rcap){.xref}), to create
filtering rules ([Section 7.2](#install){.xref}), to retrieve active
filtering rules ([Section 7.3](#rfilter){.xref}), and to delete a
filtering rule ([Section
7.4](#dfilter){.xref}).[¶](#section-7-1){.pilcrow}

::: {#rcap}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Retrieving DOTS Filtering Capabilities](#name-retrieving-dots-filtering-c){.section-name .selfRef} {#name-retrieving-dots-filtering-c}

A DOTS client [MAY]{.bcp14} send a GET request to retrieve the filtering
capabilities supported by a DOTS server. [Figure 22](#cap){.xref} shows
an example of such request.[¶](#section-7.1-1){.pilcrow}

[]{#name-get-to-retrieve-the-capabil}

::: {#cap}
::: {#section-7.1-2.1}
``` sourcecode
  GET /restconf/data/ietf-dots-data-channel:dots-data\
      /capabilities HTTP/1.1
  Host: example.com
  Accept: application/yang-data+json
```
:::

[Figure 22](#figure-22){.selfRef}: [GET to Retrieve the Capabilities of
a DOTS Server](#name-get-to-retrieve-the-capabil){.selfRef}
:::

A DOTS client, which issued a GET request to retrieve the filtering
capabilities supported by its DOTS server, [SHOULD NOT]{.bcp14} request
filtering actions that are not supported by that DOTS
server.[¶](#section-7.1-3){.pilcrow}

[Figure 23](#capex){.xref} shows an example of a response body received
from a DOTS server which supports:[¶](#section-7.1-4){.pilcrow}

-   [IPv4, IPv6, TCP, UDP, ICMP, and ICMPv6 mandatory match criteria
    listed in [Section
    4.2](#filf){.xref}.[¶](#section-7.1-5.1){.pilcrow}]{#section-7.1-5.1}
-   [\'accept\', \'drop\', and \'rate-limit\'
    actions.[¶](#section-7.1-5.2){.pilcrow}]{#section-7.1-5.2}

[]{#name-reply-to-a-get-request-with}

::: {#capex}
::: {#section-7.1-6.1}
``` sourcecode
 {
  "ietf-dots-data-channel:capabilities": {
    "address-family": ["ipv4", "ipv6"],
    "forwarding-actions": ["drop", "accept"],
    "rate-limit": true,
    "transport-protocols": [1, 6, 17, 58],
    "ipv4": {
      "length": true,
      "protocol": true,
      "destination-prefix": true,
      "source-prefix": true,
      "fragment": true
    },
    "ipv6": {
      "length": true,
      "protocol": true,
      "destination-prefix": true,
      "source-prefix": true,
      "fragment": true
    },
    "tcp": {
      "flags-bitmask": true,
      "source-port": true,
      "destination-port": true,
      "port-range": true
    },
    "udp": {
      "length": true,
      "source-port": true,
      "destination-port": true,
      "port-range": true
    },
    "icmp": {
      "type": true,
      "code": true
    }
  }
}
```
:::

[Figure 23](#figure-23){.selfRef}: [Reply to a GET Request with
Filtering Capabilities (Message
Body)](#name-reply-to-a-get-request-with){.selfRef}
:::
:::
:::

::: {#install}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Installing Filtering Rules](#name-installing-filtering-rules){.section-name .selfRef} {#name-installing-filtering-rules}

A POST or PUT request is used by a DOTS client to communicate filtering
rules to a DOTS server.[¶](#section-7.2-1){.pilcrow}

[Figure 24](#Figure7){.xref} shows an example of a POST request to block
traffic from 192.0.2.0/24 and destined to 198.51.100.0/24. Other
examples are discussed in [Appendix
A](#frag){.xref}.[¶](#section-7.2-2){.pilcrow}

[]{#name-post-to-install-filtering-r}

::: {#Figure7}
::: {#section-7.2-3.1}
``` sourcecode
 POST /restconf/data/ietf-dots-data-channel:dots-data\
      /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1
 Host: example.com
 Content-Type: application/yang-data+json

 {
  "ietf-dots-data-channel:acls": {
    "acl": [
      {
        "name": "sample-ipv4-acl",
        "type": "ipv4-acl-type",
        "activation-type": "activate-when-mitigating",
        "aces": {
          "ace": [
            {
              "name": "rule1",
              "matches": {
                "ipv4": {
                  "destination-ipv4-network": "198.51.100.0/24",
                  "source-ipv4-network": "192.0.2.0/24"
                }
              },
              "actions": {
                "forwarding": "drop"
              }
            }
          ]
        }
      }
    ]
  }
 }
```
:::

[Figure 24](#figure-24){.selfRef}: [POST to Install Filtering
Rules](#name-post-to-install-filtering-r){.selfRef}
:::

The meaning of these parameters is as
follows:[¶](#section-7.2-4){.pilcrow}

name:

:   The name of the access list.[¶](#section-7.2-5.2.1){.pilcrow}

    This is a mandatory attribute.[¶](#section-7.2-5.2.2){.pilcrow}

:   

type:

:   Indicates the primary intended type of match criteria (e.g., IPv4,
    IPv6). It is set to \'ipv4-acl-type\' in the example of [Figure
    24](#Figure7){.xref}.[¶](#section-7.2-5.4.1){.pilcrow}

    This is an optional attribute.[¶](#section-7.2-5.4.2){.pilcrow}

:   

activation-type:

:   Indicates whether an ACL has to be activated (immediately or during
    mitigation time) or instantiated without being activated
    (deactivated). Deactivated ACLs can be activated using a variety of
    means, such as manual configuration on a DOTS server or by using the
    DOTS data channel.[¶](#section-7.2-5.6.1){.pilcrow}

    If this attribute is not provided, the DOTS server [MUST]{.bcp14}
    use \'activate-when-mitigating\' as the default
    value.[¶](#section-7.2-5.6.2){.pilcrow}

    When a mitigation is in progress, the DOTS server [MUST]{.bcp14}
    only activate \'activate-when-mitigating\' filters that are bound to
    the DOTS client that triggered the
    mitigation.[¶](#section-7.2-5.6.3){.pilcrow}

    This is an optional attribute.[¶](#section-7.2-5.6.4){.pilcrow}

:   

matches:

:   Defines criteria used to identify a flow on which to apply the rule.
    It can be \"l3\" (IPv4, IPv6) or \"l4\" (TCP, UDP, ICMP). The
    detailed match parameters are specified in [Section
    4](#YANG){.xref}.[¶](#section-7.2-5.8.1){.pilcrow}

    In the example depicted in [Figure 24](#Figure7){.xref}, an IPv4
    matching criteria is used.[¶](#section-7.2-5.8.2){.pilcrow}

    This is an optional attribute.[¶](#section-7.2-5.8.3){.pilcrow}

:   

destination-ipv4-network:

:   The destination IPv4 prefix. DOTS servers [MUST]{.bcp14} validate
    that these prefixes are within the scope of the DOTS client domain.
    Other validation checks may be supported by DOTS servers. If this
    attribute is not provided, the DOTS server enforces the ACL on any
    destination IP address that belongs to the DOTS client
    domain.[¶](#section-7.2-5.10.1){.pilcrow}

    This is a mandatory attribute in requests with an
    \'activation-type\' set to
    \'immediate\'.[¶](#section-7.2-5.10.2){.pilcrow}

:   

source-ipv4-network:

:   The source IPv4 prefix.[¶](#section-7.2-5.12.1){.pilcrow}

    This is an optional attribute.[¶](#section-7.2-5.12.2){.pilcrow}

:   

actions:

:   Actions in the forwarding ACL category can be \'drop\' or
    \'accept\'. The \'accept\' action is used to accept-list traffic.
    The \"drop\" action is used to drop-list
    traffic.[¶](#section-7.2-5.14.1){.pilcrow}

    Accepted traffic may be subject to \'rate-limit\'; the allowed
    traffic rate is represented in bytes per second. This unit is the
    same as the one used for \"traffic-rate\" in
    \[[RFC5575](#RFC5575){.xref}\].[¶](#section-7.2-5.14.2){.pilcrow}

    This is a mandatory attribute.[¶](#section-7.2-5.14.3){.pilcrow}

:   

The DOTS server indicates the result of processing the POST request
using the status-line. Concretely, a \"201 Created\" status-line
[MUST]{.bcp14} be returned in the response if the DOTS server has
accepted the filtering rules. If the request is missing a mandatory
attribute or contains an invalid or unknown parameter (e.g., a match
field not supported by the DOTS server), a \"400 Bad Request\"
status-line [MUST]{.bcp14} be returned by the DOTS server in the
response. The error-tag is set to \"missing-attribute\",
\"invalid-value\", or \"unknown-element\" as a function of the
encountered error.[¶](#section-7.2-6){.pilcrow}

If the request is received via a server-domain DOTS gateway, but the
DOTS server does not maintain a \'cdid\' for this \'cuid\' while a
\'cdid\' is expected to be supplied, the DOTS server [MUST]{.bcp14}
reply with a \"403 Forbidden\" status-line and the error-tag
\"access-denied\". Upon receipt of this message, the DOTS client
[MUST]{.bcp14} register ([Figure
11](#register){.xref}).[¶](#section-7.2-7){.pilcrow}

If the request is conflicting with an existing filtering installed by
another DOTS client of the domain, absent any local policy, the DOTS
server returns a \"409 Conflict\" status-line to the requesting DOTS
client. The error-tag \"resource-denied\" is used in this
case.[¶](#section-7.2-8){.pilcrow}

The \"insert\" query parameter ([Section
4.8.5](https://www.rfc-editor.org/rfc/rfc8040#section-4.8.5){.relref} of
\[[RFC8040](#RFC8040){.xref}\]) [MAY]{.bcp14} be used to specify how an
access control entry is inserted within an ACL and how an ACL is
inserted within an ACL set.[¶](#section-7.2-9){.pilcrow}

The DOTS client uses the PUT request to modify its filtering rules
maintained by the DOTS server. In particular, a DOTS client
[MUST]{.bcp14} update its filtering entries upon change of the
destination prefix. How such change is detected is out of
scope.[¶](#section-7.2-10){.pilcrow}

A DOTS server [MUST]{.bcp14} maintain a filtering rule for at least
10080 minutes (1 week). If no refresh request is seen from the DOTS
client, the DOTS server removes expired entries. Typically, a refresh
request is a PUT request that echoes the content of a response to a GET
request with all of the read-only parameters stripped out (e.g.,
\'pending-lifetime\').[¶](#section-7.2-11){.pilcrow}
:::
:::

::: {#rfilter}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Retrieving Installed Filtering Rules](#name-retrieving-installed-filter){.section-name .selfRef} {#name-retrieving-installed-filter}

A DOTS client periodically queries its DOTS server to check the counters
for installed filtering rules. A GET request is used to retrieve
filtering rules from a DOTS server. In order to indicate which type of
data is requested in a GET request, the DOTS client sets adequately the
\"content\" query parameter.[¶](#section-7.3-1){.pilcrow}

If the DOTS server does not find the access list name conveyed in the
GET request in its configuration data for this DOTS client, it responds
with a \"404 Not Found\" status-line.[¶](#section-7.3-2){.pilcrow}

In order to illustrate the intended behavior, consider the example
depicted in [Figure 25](#PUTv6){.xref}. In reference to this example,
the DOTS client requests the creation of an immediate ACL called
\"test-acl-ipv6-udp\".[¶](#section-7.3-3){.pilcrow}

[]{#name-example-of-a-put-request-to}

::: {#PUTv6}
::: {#section-7.3-4.1}
``` sourcecode
PUT /restconf/data/ietf-dots-data-channel:dots-data\
    /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\
    /acl=test-acl-ipv6-udp HTTP/1.1
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-dots-data-channel:acls": {
    "acl": [
      {
        "name": "test-acl-ipv6-udp",
        "type": "ipv6-acl-type",
        "activation-type": "immediate",
        "aces": {
          "ace": [
            {
              "name": "my-test-ace",
              "matches": {
                "ipv6": {
                  "destination-ipv6-network": "2001:db8:6401::2/127",
                  "source-ipv6-network": "2001:db8:1234::/96",
                  "protocol": 17,
                  "flow-label": 10000
                },
                "udp": {
                  "source-port-range-or-operator": {
                    "operator": "lte",
                    "port": 80
                  },
                  "destination-port-range-or-operator": {
                    "operator": "neq",
                    "port": 1010
                  }
                }
              },
              "actions": {
                "forwarding": "accept"
              }
            }
          ]
        }
      }
    ]
  }
}
```
:::

[Figure 25](#figure-25){.selfRef}: [Example of a PUT Request to Create a
Filtering](#name-example-of-a-put-request-to){.selfRef}
:::

The peer DOTS server follows the procedure specified in [Section
7.2](#install){.xref} to process the request. We consider in the
following that a positive response is sent back to the requesting DOTS
client to confirm that the \"test-acl-ipv6-udp\" ACL is successfully
installed by the DOTS server.[¶](#section-7.3-5){.pilcrow}

The DOTS client can issue a GET request to retrieve all its filtering
rules and the number of matches for the installed filtering rules as
illustrated in [Figure 26](#Get){.xref}. The \"content\" query parameter
is set to \'all\'. The message body of the response to this GET request
is shown in [Figure 27](#Getr){.xref}.[¶](#section-7.3-6){.pilcrow}

[]{#name-retrieve-the-configuration-}

::: {#Get}
::: {#section-7.3-7.1}
``` sourcecode
  GET /restconf/data/ietf-dots-data-channel:dots-data\
      /dots-client=dz6pHjaADkaFTbjr0JGBpw\
      /acls?content=all HTTP/1.1
  Host: example.com
  Accept: application/yang-data+json
```
:::

[Figure 26](#figure-26){.selfRef}: [Retrieve the Configuration Data and
State Data for the Filtering Rules (GET
Request)](#name-retrieve-the-configuration-){.selfRef}
:::

[]{#name-retrieve-the-configuration-d}

::: {#Getr}
::: {#section-7.3-8.1}
``` sourcecode
{
  "ietf-dots-data-channel:acls": {
    "acl": [
      {
        "name": "test-acl-ipv6-udp",
        "type": "ipv6-acl-type",
        "activation-type": "immediate",
        "pending-lifetime":9080,
        "aces": {
          "ace": [
            {
              "name": "my-test-ace",
              "matches": {
                "ipv6": {
                  "destination-ipv6-network": "2001:db8:6401::2/127",
                  "source-ipv6-network": "2001:db8:1234::/96",
                  "protocol": 17,
                  "flow-label": 10000
                },
                "udp": {
                  "source-port-range-or-operator": {
                    "operator": "lte",
                    "port": 80
                  },
                  "destination-port-range-or-operator": {
                    "operator": "neq",
                    "port": 1010
                  }
                }
              },
              "actions": {
                "forwarding": "accept"
              }
            }
          ]
        }
      }
    ]
  }
}
```
:::

[Figure 27](#figure-27){.selfRef}: [Retrieve the Configuration Data and
State Data for the Filtering Rules (Response Message
Body)](#name-retrieve-the-configuration-d){.selfRef}
:::

Also, a DOTS client can issue a GET request to retrieve only
configuration data related to an ACL as shown in [Figure
28](#GEtc){.xref}. It does so by setting the \"content\" query parameter
to \'config\'.[¶](#section-7.3-9){.pilcrow}

[]{#name-retrieve-the-configuration-da}

::: {#GEtc}
::: {#section-7.3-10.1}
``` sourcecode
  GET /restconf/data/ietf-dots-data-channel:dots-data\
      /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\
      /acl=test-acl-ipv6-udp?content=config HTTP/1.1
  Host: example.com
  Accept: application/yang-data+json
```
:::

[Figure 28](#figure-28){.selfRef}: [Retrieve the Configuration Data for
a Filtering Rule (GET
Request)](#name-retrieve-the-configuration-da){.selfRef}
:::

A response to this GET request is shown in [Figure
29](#GEtcr){.xref}.[¶](#section-7.3-11){.pilcrow}

[]{#name-retrieve-the-configuration-dat}

::: {#GEtcr}
::: {#section-7.3-12.1}
``` sourcecode
{
  "ietf-dots-data-channel:acls": {
    "acl": [
      {
        "name": "test-acl-ipv6-udp",
        "type": "ipv6-acl-type",
        "activation-type": "immediate",
        "aces": {
          "ace": [
            {
              "name": "my-test-ace",
              "matches": {
                "ipv6": {
                  "destination-ipv6-network": "2001:db8:6401::2/127",
                  "source-ipv6-network": "2001:db8:1234::/96",
                  "protocol": 17,
                  "flow-label": 10000
                },
                "udp": {
                  "source-port-range-or-operator": {
                    "operator": "lte",
                    "port": 80
                  },
                  "destination-port-range-or-operator": {
                    "operator": "neq",
                    "port": 1010
                  }
                }
              },
              "actions": {
                "forwarding": "accept"
              }
            }
          ]
        }
      }
    ]
  }
}
```
:::

[Figure 29](#figure-29){.selfRef}: [Retrieve the Configuration Data for
a Filtering Rule (Response Message
Body)](#name-retrieve-the-configuration-dat){.selfRef}
:::

A DOTS client can also issue a GET request with a \"content\" query
parameter set to \'non-config\' to exclusively retrieve
non-configuration data bound to a given ACL as shown in [Figure
30](#GEtnc){.xref}. A response to this GET request is shown in [Figure
31](#GEtncr){.xref}.[¶](#section-7.3-13){.pilcrow}

[]{#name-retrieve-the-non-configurat}

::: {#GEtnc}
::: {#section-7.3-14.1}
``` sourcecode
  GET /restconf/data/ietf-dots-data-channel:dots-data\
      /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\
      /acl=test-acl-ipv6-udp?content=non-config HTTP/1.1
  Host: example.com
  Accept: application/yang-data+json
```
:::

[Figure 30](#figure-30){.selfRef}: [Retrieve the Non-Configuration Data
for a Filtering Rule (GET
Request)](#name-retrieve-the-non-configurat){.selfRef}
:::

[]{#name-retrieve-the-non-configurati}

::: {#GEtncr}
::: {#section-7.3-15.1}
``` sourcecode
{
  "ietf-dots-data-channel:acls":  {
    "acl": [
      {
        "name": "test-acl-ipv6-udp",
        "pending-lifetime": 8000,
        "aces": {
          "ace": [
            {
              "name": "my-test-ace"
            }
          ]
        }
      }
    ]
  }
}
```
:::

[Figure 31](#figure-31){.selfRef}: [Retrieve the Non-Configuration Data
for a Filtering Rule (Response Message
Body)](#name-retrieve-the-non-configurati){.selfRef}
:::
:::
:::

::: {#dfilter}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [Removing Filtering Rules](#name-removing-filtering-rules){.section-name .selfRef} {#name-removing-filtering-rules}

A DELETE request is used by a DOTS client to delete filtering rules from
a DOTS server.[¶](#section-7.4-1){.pilcrow}

If the DOTS server does not find the access list name carried in the
DELETE request in its configuration data for this DOTS client, it
[MUST]{.bcp14} respond with a \"404 Not Found\" status-line. The DOTS
server successfully acknowledges a DOTS client\'s request to withdraw
the filtering rules using a \"204 No Content\" status-line, and removes
the filtering rules accordingly.[¶](#section-7.4-2){.pilcrow}

[Figure 32](#Figure9){.xref} shows an example of a request to remove the
IPv4 ACL \"sample-ipv4-acl\" created in [Section
7.2](#install){.xref}.[¶](#section-7.4-3){.pilcrow}

[]{#name-remove-a-filtering-rule-del}

::: {#Figure9}
::: {#section-7.4-4.1}
``` sourcecode
  DELETE  /restconf/data/ietf-dots-data-channel:dots-data\
          /dots-client=dz6pHjaADkaFTbjr0JGBpw/acls\
          /acl=sample-ipv4-acl HTTP/1.1
  Host: example.com
```
:::

[Figure 32](#figure-32){.selfRef}: [Remove a Filtering Rule (DELETE
Request)](#name-remove-a-filtering-rule-del){.selfRef}
:::

[Figure 33](#Figure9a){.xref} shows an example of a response received
from the DOTS server to confirm the deletion of
\"sample-ipv4-acl\".[¶](#section-7.4-6){.pilcrow}

[]{#name-remove-a-filtering-rule-res}

::: {#Figure9a}
::: {#section-7.4-7.1}
``` sourcecode
 HTTP/1.1 204 No Content
 Server: Apache
 Date: Fri, 27 Jul 2018 10:05:15 GMT
 Cache-Control: no-cache
 Content-Type: application/yang-data+json
 Content-Length: 0
 Connection: Keep-Alive
```
:::

[Figure 33](#figure-33){.selfRef}: [Remove a Filtering Rule
(Response)](#name-remove-a-filtering-rule-res){.selfRef}
:::
:::
:::
:::
:::

::: {#operational}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Operational Considerations](#name-operational-considerations){.section-name .selfRef} {#name-operational-considerations}

The following operational considerations should be taken into
account:[¶](#section-8-1){.pilcrow}

-   [DOTS servers [MUST NOT]{.bcp14} enable both DOTS data channel and
    direct configuration, to avoid race conditions and inconsistent
    configurations arising from simultaneous updates from multiple
    sources.[¶](#section-8-2.1){.pilcrow}]{#section-8-2.1}
-   [DOTS agents [SHOULD]{.bcp14} enable the DOTS data channel to
    configure aliases and ACLs, and only use direct configuration as a
    stop-gap mechanism to test DOTS signal channel with aliases and
    ACLs. Further, direct configuration [SHOULD]{.bcp14} only be used
    when the on-path DOTS agents are within the same
    domain.[¶](#section-8-2.2){.pilcrow}]{#section-8-2.2}
-   [If a DOTS server has enabled direct configuration, it can reject
    the DOTS data channel connection using hard ICMP error
    \[[RFC1122](#RFC1122){.xref}\] or RST (Reset) bit in the TCP header
    or reject the RESTCONF request using an error response containing a
    \"503 Service Unavailable\"
    status-line.[¶](#section-8-2.3){.pilcrow}]{#section-8-2.3}
:::
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

IANA has registered the following URI in the \"ns\" subregistry within
the \"IETF XML Registry\"
\[[RFC3688](#RFC3688){.xref}\]:[¶](#section-9-1){.pilcrow}

ID:
:   yang:ietf-dots-data-channel[¶](#section-9-2.2){.pilcrow}
:   

URI:
:   urn:ietf:params:xml:ns:yang:ietf-dots-data-channel[¶](#section-9-2.4){.pilcrow}
:   

Registrant Contact:
:   The IESG.[¶](#section-9-2.6){.pilcrow}
:   

XML:
:   N/A; the requested URI is an XML
    namespace.[¶](#section-9-2.8){.pilcrow}
:   

Reference:
:   RFC 8783[¶](#section-9-2.10){.pilcrow}
:   

IANA has registered the following YANG module in the \"YANG Module
Names\" subregistry \[[RFC7950](#RFC7950){.xref}\] within the \"YANG
Parameters\" registry.[¶](#section-9-3){.pilcrow}

Name:
:   ietf-dots-data-channel[¶](#section-9-4.2){.pilcrow}
:   

Namespace:
:   urn:ietf:params:xml:ns:yang:ietf-dots-data-channel[¶](#section-9-4.4){.pilcrow}
:   

Prefix:
:   data-channel[¶](#section-9-4.6){.pilcrow}
:   

Reference:
:   RFC 8783[¶](#section-9-4.8){.pilcrow}
:   

This module is not maintained by IANA.[¶](#section-9-5){.pilcrow}
:::

::: {#security}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

RESTCONF security considerations are discussed in
\[[RFC8040](#RFC8040){.xref}\]. In particular, DOTS agents
[MUST]{.bcp14} follow the security recommendations in Sections
[2](https://www.rfc-editor.org/rfc/rfc8040#section-2){.relref} and
[12](https://www.rfc-editor.org/rfc/rfc8040#section-12){.relref} of
\[[RFC8040](#RFC8040){.xref}\]. Also, DOTS agents [MUST]{.bcp14} support
the mutual authentication TLS profile discussed in Sections
[7.1](https://www.rfc-editor.org/rfc/rfc8782#section-7.1){.relref} and
[8](https://www.rfc-editor.org/rfc/rfc8782#section-8){.relref} of
\[[RFC8782](#RFC8782){.xref}\].[¶](#section-10-1){.pilcrow}

Authenticated encryption [MUST]{.bcp14} be used for data confidentiality
and message integrity. The interaction between the DOTS agents requires
Transport Layer Security (TLS) with a cipher suite offering
confidentiality protection, and the guidance given in
\[[RFC7525](#RFC7525){.xref}\] [MUST]{.bcp14} be followed to avoid
attacks on TLS.[¶](#section-10-2){.pilcrow}

The installation of drop-list or accept-list rules using RESTCONF over
TLS reveals the attacker IP addresses and legitimate IP addresses only
to the DOTS server trusted by the DOTS client. The secure communication
channel between DOTS agents provides privacy and prevents a network
eavesdropper from directly gaining access to the drop-listed and
accept-listed IP addresses.[¶](#section-10-3){.pilcrow}

An attacker may be able to inject RST packets, bogus application
segments, etc., regardless of whether TLS authentication is used.
Because the application data is TLS protected, this will not result in
the application receiving bogus data, but it will constitute a DoS on
the connection. This attack can be countered by using TCP Authentication
Option (TCP-AO) \[[RFC5925](#RFC5925){.xref}\]. If TCP-AO is used, then
any bogus packets injected by an attacker will be rejected by the TCP-AO
integrity check and therefore will never reach the TLS
layer.[¶](#section-10-4){.pilcrow}

In order to prevent leaking internal information outside a client
domain, client-side DOTS gateways [SHOULD NOT]{.bcp14} reveal the
identity of internal DOTS clients (e.g., source IP address, client\'s
hostname) unless explicitly configured to do
so.[¶](#section-10-5){.pilcrow}

DOTS servers [MUST]{.bcp14} verify that requesting DOTS clients are
entitled to enforce filtering rules on a given IP prefix. That is, only
filtering rules on IP resources that belong to the DOTS client domain
can be authorized by a DOTS server. The exact mechanism for the DOTS
servers to validate that the target prefixes are within the scope of the
DOTS client domain is deployment specific.[¶](#section-10-6){.pilcrow}

Rate-limiting DOTS requests, including those with new \'cuid\' values,
from the same DOTS client defends against DoS attacks that would result
from varying the \'cuid\' to exhaust DOTS server resources. Rate-limit
policies [SHOULD]{.bcp14} be enforced on DOTS gateways (if deployed) and
DOTS servers.[¶](#section-10-7){.pilcrow}

Applying resources quota per DOTS client and/or per DOTS client domain
(e.g., limiting the number of aliases and filters to be installed by
DOTS clients) prevents DOTS server resources from being aggressively
used by some DOTS clients and therefore ensures DDoS mitigation usage
fairness. Additionally, DOTS servers may limit the number of DOTS
clients that can be enabled per domain.[¶](#section-10-8){.pilcrow}

When FQDNs are used as targets, the DOTS server [MUST]{.bcp14} rely upon
DNS privacy enabling protocols (e.g., DNS over TLS
\[[RFC7858](#RFC7858){.xref}\] or DNS over HTTPS (DoH)
\[[RFC8484](#RFC8484){.xref}\]) to prevent eavesdroppers from possibly
identifying the target resources protected by the DDoS mitigation
service, and means to ensure the target FQDN resolution is authentic
(e.g., DNSSEC
\[[RFC4034](#RFC4034){.xref}\]).[¶](#section-10-9){.pilcrow}

The presence of DOTS gateways may lead to infinite forwarding loops,
which is undesirable. To prevent and detect such loops, a mechanism is
defined in [Section 3.4](#loops){.xref}.[¶](#section-10-10){.pilcrow}

The YANG module specified in this document defines a schema for data
that is designed to be accessed via network management protocols such as
NETCONF \[[RFC6241](#RFC6241){.xref}\] or RESTCONF
\[[RFC8040](#RFC8040){.xref}\]. The lowest NETCONF layer is the secure
transport layer, and the mandatory-to-implement secure transport is
Secure Shell (SSH) \[[RFC6242](#RFC6242){.xref}\]. The lowest RESTCONF
layer is HTTPS, and the mandatory-to-implement secure transport is TLS
\[[RFC8446](#RFC8446){.xref}\].[¶](#section-10-11){.pilcrow}

The Network Configuration Access Control Model (NACM)
\[[RFC8341](#RFC8341){.xref}\] provides the means to restrict access for
particular NETCONF or RESTCONF users to a preconfigured subset of all
available NETCONF or RESTCONF protocol operations and
content.[¶](#section-10-12){.pilcrow}

There are a number of data nodes defined in this YANG module that are
writable/creatable/deletable (i.e., config true, which is the default).
These data nodes may be considered sensitive or vulnerable in some
network environments. Write operations (e.g., edit-config) to these data
nodes without proper protection can have a negative effect on network
operations. The DOTS data channel is responsible for exchanging
configuration data that affect traffic filtering during DDoS attack
mitigation, in particular. Appropriate security measures are recommended
to prevent illegitimate users from invoking DOTS data channel primitives
on writable data nodes. Nevertheless, an attacker who can access a DOTS
client is technically capable of launching various attacks, such
as:[¶](#section-10-13){.pilcrow}

-   [Setting an arbitrarily low rate-limit, which may prevent legitimate
    traffic from being forwarded
    (rate-limit).[¶](#section-10-14.1){.pilcrow}]{#section-10-14.1}
-   [Setting an arbitrarily high rate-limit, which may lead to the
    forwarding of illegitimate DDoS traffic
    (rate-limit).[¶](#section-10-14.2){.pilcrow}]{#section-10-14.2}
-   [Communicating invalid aliases to the server (alias), which will
    cause the failure of associating both data and signal
    channels.[¶](#section-10-14.3){.pilcrow}]{#section-10-14.3}
-   [Setting invalid ACL entries, which may prevent legitimate traffic
    from being forwarded. Likewise, invalid ACL entries may lead to
    forward DDoS
    traffic.[¶](#section-10-14.4){.pilcrow}]{#section-10-14.4}

This module reuses YANG structures from \[[RFC8519](#RFC8519){.xref}\],
and the security considerations for those nodes continue to apply for
this usage.[¶](#section-10-15){.pilcrow}
:::
:::

::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-11.1 .section}
### [11.1.](#section-11.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC3688\]
:   [Mealling, M.]{.refAuthor}, [\"The IETF XML Registry\"]{.refTitle},
    [BCP 81]{.seriesInfo}, [RFC 3688]{.seriesInfo}, [DOI
    10.17487/RFC3688]{.seriesInfo}, January 2004,
    \<<https://www.rfc-editor.org/info/rfc3688>\>.
:   

\[RFC4632\]
:   [Fuller, V.]{.refAuthor}[ and T. Li]{.refAuthor}, [\"Classless
    Inter-domain Routing (CIDR): The Internet Address Assignment and
    Aggregation Plan\"]{.refTitle}, [BCP 122]{.seriesInfo}, [RFC
    4632]{.seriesInfo}, [DOI 10.17487/RFC4632]{.seriesInfo}, August
    2006, \<<https://www.rfc-editor.org/info/rfc4632>\>.
:   

\[RFC6125\]
:   [Saint-Andre, P.]{.refAuthor}[ and J. Hodges]{.refAuthor},
    [\"Representation and Verification of Domain-Based Application
    Service Identity within Internet Public Key Infrastructure Using
    X.509 (PKIX) Certificates in the Context of Transport Layer Security
    (TLS)\"]{.refTitle}, [RFC 6125]{.seriesInfo}, [DOI
    10.17487/RFC6125]{.seriesInfo}, March 2011,
    \<<https://www.rfc-editor.org/info/rfc6125>\>.
:   

\[RFC6241\]
:   [Enns, R., Ed.]{.refAuthor}[, Bjorklund, M., Ed.]{.refAuthor}[,
    Schoenwaelder, J., Ed.]{.refAuthor}[, and A. Bierman,
    Ed.]{.refAuthor}, [\"Network Configuration Protocol
    (NETCONF)\"]{.refTitle}, [RFC 6241]{.seriesInfo}, [DOI
    10.17487/RFC6241]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6241>\>.
:   

\[RFC6242\]
:   [Wasserman, M.]{.refAuthor}, [\"Using the NETCONF Protocol over
    Secure Shell (SSH)\"]{.refTitle}, [RFC 6242]{.seriesInfo}, [DOI
    10.17487/RFC6242]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6242>\>.
:   

\[RFC6991\]
:   [Schoenwaelder, J., Ed.]{.refAuthor}, [\"Common YANG Data
    Types\"]{.refTitle}, [RFC 6991]{.seriesInfo}, [DOI
    10.17487/RFC6991]{.seriesInfo}, July 2013,
    \<<https://www.rfc-editor.org/info/rfc6991>\>.
:   

\[RFC7230\]
:   [Fielding, R., Ed.]{.refAuthor}[ and J. Reschke, Ed.]{.refAuthor},
    [\"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and
    Routing\"]{.refTitle}, [RFC 7230]{.seriesInfo}, [DOI
    10.17487/RFC7230]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7230>\>.
:   

\[RFC7525\]
:   [Sheffer, Y.]{.refAuthor}[, Holz, R.]{.refAuthor}[, and P.
    Saint-Andre]{.refAuthor}, [\"Recommendations for Secure Use of
    Transport Layer Security (TLS) and Datagram Transport Layer Security
    (DTLS)\"]{.refTitle}, [BCP 195]{.seriesInfo}, [RFC
    7525]{.seriesInfo}, [DOI 10.17487/RFC7525]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7525>\>.
:   

\[RFC7950\]
:   [Bjorklund, M., Ed.]{.refAuthor}, [\"The YANG 1.1 Data Modeling
    Language\"]{.refTitle}, [RFC 7950]{.seriesInfo}, [DOI
    10.17487/RFC7950]{.seriesInfo}, August 2016,
    \<<https://www.rfc-editor.org/info/rfc7950>\>.
:   

\[RFC7951\]
:   [Lhotka, L.]{.refAuthor}, [\"JSON Encoding of Data Modeled with
    YANG\"]{.refTitle}, [RFC 7951]{.seriesInfo}, [DOI
    10.17487/RFC7951]{.seriesInfo}, August 2016,
    \<<https://www.rfc-editor.org/info/rfc7951>\>.
:   

\[RFC8040\]
:   [Bierman, A.]{.refAuthor}[, Bjorklund, M.]{.refAuthor}[, and K.
    Watsen]{.refAuthor}, [\"RESTCONF Protocol\"]{.refTitle}, [RFC
    8040]{.seriesInfo}, [DOI 10.17487/RFC8040]{.seriesInfo}, January
    2017, \<<https://www.rfc-editor.org/info/rfc8040>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8259\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The JavaScript Object Notation
    (JSON) Data Interchange Format\"]{.refTitle}, [STD 90]{.seriesInfo},
    [RFC 8259]{.seriesInfo}, [DOI 10.17487/RFC8259]{.seriesInfo},
    December 2017, \<<https://www.rfc-editor.org/info/rfc8259>\>.
:   

\[RFC8341\]
:   [Bierman, A.]{.refAuthor}[ and M. Bjorklund]{.refAuthor}, [\"Network
    Configuration Access Control Model\"]{.refTitle}, [STD
    91]{.seriesInfo}, [RFC 8341]{.seriesInfo}, [DOI
    10.17487/RFC8341]{.seriesInfo}, March 2018,
    \<<https://www.rfc-editor.org/info/rfc8341>\>.
:   

\[RFC8446\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   

\[RFC8519\]
:   [Jethanandani, M.]{.refAuthor}[, Agarwal, S.]{.refAuthor}[,
    Huang, L.]{.refAuthor}[, and D. Blair]{.refAuthor}, [\"YANG Data
    Model for Network Access Control Lists (ACLs)\"]{.refTitle}, [RFC
    8519]{.seriesInfo}, [DOI 10.17487/RFC8519]{.seriesInfo}, March 2019,
    \<<https://www.rfc-editor.org/info/rfc8519>\>.
:   

\[RFC8782\]
:   [Reddy.K, T., Ed.]{.refAuthor}[, Boucadair, M., Ed.]{.refAuthor}[,
    Patil, P.]{.refAuthor}[, Mortensen, A.]{.refAuthor}[, and N.
    Teague]{.refAuthor}, [\"Distributed Denial-of-Service Open Threat
    Signaling (DOTS) Signal Channel Specification\"]{.refTitle}, [RFC
    8782]{.seriesInfo}, [DOI 10.17487/RFC8782]{.seriesInfo}, May 2020,
    \<<https://www.rfc-editor.org/info/rfc8782>\>.
:   
:::

::: {#section-11.2 .section}
### [11.2.](#section-11.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[DOTS-ARCH\]
:   [Mortensen, A.]{.refAuthor}[, Reddy.K, T.]{.refAuthor}[,
    Andreasen, F.]{.refAuthor}[, Teague, N.]{.refAuthor}[, and R.
    Compton]{.refAuthor}, [\"Distributed-Denial-of-Service Open Threat
    Signaling (DOTS) Architecture\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-dots-architecture-18]{.seriesInfo}, 6 March 2020,
    \<<https://tools.ietf.org/html/draft-ietf-dots-architecture-18>\>.
:   

\[DOTS-SERVER-DISC\]
:   [Boucadair, M.]{.refAuthor}[ and T. Reddy.K]{.refAuthor},
    [\"Distributed-Denial-of-Service Open Threat Signaling (DOTS) Agent
    Discovery\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-dots-server-discovery-10]{.seriesInfo},
    7 February 2020,
    \<<https://tools.ietf.org/html/draft-ietf-dots-server-discovery-10>\>.
:   

\[IANA-PROTO\]
:   [IANA]{.refAuthor}, [\"Protocol Numbers\"]{.refTitle}, ,
    \<[http://www.iana.org/assignments/protocol-numbers](https://www.iana.org/assignments/protocol-numbers)\>.
:   

\[RESTCONF-MODELS\]
:   [Watsen, K.]{.refAuthor}, [\"RESTCONF Client and Server
    Models\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft,
    draft-ietf-netconf-restconf-client-server-19]{.seriesInfo}, 20 May
    2020,
    \<<https://tools.ietf.org/html/draft-ietf-netconf-restconf-client-server-19>\>.
:   

\[RFC1122\]
:   [Braden, R., Ed.]{.refAuthor}, [\"Requirements for Internet Hosts -
    Communication Layers\"]{.refTitle}, [STD 3]{.seriesInfo}, [RFC
    1122]{.seriesInfo}, [DOI 10.17487/RFC1122]{.seriesInfo}, October
    1989, \<<https://www.rfc-editor.org/info/rfc1122>\>.
:   

\[RFC3986\]
:   [Berners-Lee, T.]{.refAuthor}[, Fielding, R.]{.refAuthor}[, and L.
    Masinter]{.refAuthor}, [\"Uniform Resource Identifier (URI): Generic
    Syntax\"]{.refTitle}, [STD 66]{.seriesInfo}, [RFC
    3986]{.seriesInfo}, [DOI 10.17487/RFC3986]{.seriesInfo}, January
    2005, \<<https://www.rfc-editor.org/info/rfc3986>\>.
:   

\[RFC4034\]
:   [Arends, R.]{.refAuthor}[, Austein, R.]{.refAuthor}[,
    Larson, M.]{.refAuthor}[, Massey, D.]{.refAuthor}[, and S.
    Rose]{.refAuthor}, [\"Resource Records for the DNS Security
    Extensions\"]{.refTitle}, [RFC 4034]{.seriesInfo}, [DOI
    10.17487/RFC4034]{.seriesInfo}, March 2005,
    \<<https://www.rfc-editor.org/info/rfc4034>\>.
:   

\[RFC4340\]
:   [Kohler, E.]{.refAuthor}[, Handley, M.]{.refAuthor}[, and S.
    Floyd]{.refAuthor}, [\"Datagram Congestion Control Protocol
    (DCCP)\"]{.refTitle}, [RFC 4340]{.seriesInfo}, [DOI
    10.17487/RFC4340]{.seriesInfo}, March 2006,
    \<<https://www.rfc-editor.org/info/rfc4340>\>.
:   

\[RFC4960\]
:   [Stewart, R., Ed.]{.refAuthor}, [\"Stream Control Transmission
    Protocol\"]{.refTitle}, [RFC 4960]{.seriesInfo}, [DOI
    10.17487/RFC4960]{.seriesInfo}, September 2007,
    \<<https://www.rfc-editor.org/info/rfc4960>\>.
:   

\[RFC5575\]
:   [Marques, P.]{.refAuthor}[, Sheth, N.]{.refAuthor}[,
    Raszuk, R.]{.refAuthor}[, Greene, B.]{.refAuthor}[,
    Mauch, J.]{.refAuthor}[, and D. McPherson]{.refAuthor},
    [\"Dissemination of Flow Specification Rules\"]{.refTitle}, [RFC
    5575]{.seriesInfo}, [DOI 10.17487/RFC5575]{.seriesInfo}, August
    2009, \<<https://www.rfc-editor.org/info/rfc5575>\>.
:   

\[RFC5925\]
:   [Touch, J.]{.refAuthor}[, Mankin, A.]{.refAuthor}[, and R.
    Bonica]{.refAuthor}, [\"The TCP Authentication Option\"]{.refTitle},
    [RFC 5925]{.seriesInfo}, [DOI 10.17487/RFC5925]{.seriesInfo}, June
    2010, \<<https://www.rfc-editor.org/info/rfc5925>\>.
:   

\[RFC6520\]
:   [Seggelmann, R.]{.refAuthor}[, Tuexen, M.]{.refAuthor}[, and M.
    Williams]{.refAuthor}, [\"Transport Layer Security (TLS) and
    Datagram Transport Layer Security (DTLS) Heartbeat
    Extension\"]{.refTitle}, [RFC 6520]{.seriesInfo}, [DOI
    10.17487/RFC6520]{.seriesInfo}, February 2012,
    \<<https://www.rfc-editor.org/info/rfc6520>\>.
:   

\[RFC7858\]
:   [Hu, Z.]{.refAuthor}[, Zhu, L.]{.refAuthor}[,
    Heidemann, J.]{.refAuthor}[, Mankin, A.]{.refAuthor}[,
    Wessels, D.]{.refAuthor}[, and P. Hoffman]{.refAuthor},
    [\"Specification for DNS over Transport Layer Security
    (TLS)\"]{.refTitle}, [RFC 7858]{.seriesInfo}, [DOI
    10.17487/RFC7858]{.seriesInfo}, May 2016,
    \<<https://www.rfc-editor.org/info/rfc7858>\>.
:   

\[RFC8340\]
:   [Bjorklund, M.]{.refAuthor}[ and L. Berger, Ed.]{.refAuthor},
    [\"YANG Tree Diagrams\"]{.refTitle}, [BCP 215]{.seriesInfo}, [RFC
    8340]{.seriesInfo}, [DOI 10.17487/RFC8340]{.seriesInfo}, March 2018,
    \<<https://www.rfc-editor.org/info/rfc8340>\>.
:   

\[RFC8484\]
:   [Hoffman, P.]{.refAuthor}[ and P. McManus]{.refAuthor}, [\"DNS
    Queries over HTTPS (DoH)\"]{.refTitle}, [RFC 8484]{.seriesInfo},
    [DOI 10.17487/RFC8484]{.seriesInfo}, October 2018,
    \<<https://www.rfc-editor.org/info/rfc8484>\>.
:   

\[RFC8499\]
:   [Hoffman, P.]{.refAuthor}[, Sullivan, A.]{.refAuthor}[, and K.
    Fujiwara]{.refAuthor}, [\"DNS Terminology\"]{.refTitle}, [BCP
    219]{.seriesInfo}, [RFC 8499]{.seriesInfo}, [DOI
    10.17487/RFC8499]{.seriesInfo}, January 2019,
    \<<https://www.rfc-editor.org/info/rfc8499>\>.
:   

\[RFC8612\]
:   [Mortensen, A.]{.refAuthor}[, Reddy, T.]{.refAuthor}[, and R.
    Moskowitz]{.refAuthor}, [\"DDoS Open Threat Signaling (DOTS)
    Requirements\"]{.refTitle}, [RFC 8612]{.seriesInfo}, [DOI
    10.17487/RFC8612]{.seriesInfo}, May 2019,
    \<<https://www.rfc-editor.org/info/rfc8612>\>.
:   
:::
:::

::: {#frag}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Examples: Filtering Fragments](#name-examples-filtering-fragment){.section-name .selfRef} {#name-examples-filtering-fragment}

This specification strongly recommends the use of \'fragment\' for
handling fragments.[¶](#section-appendix.a-1){.pilcrow}

[Figure 34](#fragdnsv4){.xref} shows the content of the POST request to
be issued by a DOTS client to its DOTS server to allow the traffic
destined to 198.51.100.0/24 and UDP port number 53, but to drop all
fragmented packets. The following ACEs are defined (in this
order):[¶](#section-appendix.a-2){.pilcrow}

-   [\"drop-all-fragments\" ACE: discards all
    fragments.[¶](#section-appendix.a-3.1){.pilcrow}]{#section-appendix.a-3.1}
-   [\"allow-dns-packets\" ACE: accepts DNS packets destined to
    198.51.100.0/24.[¶](#section-appendix.a-3.2){.pilcrow}]{#section-appendix.a-3.2}

[]{#name-filtering-ipv4-fragmented-p}

::: {#fragdnsv4}
::: {#section-appendix.a-4.1}
``` sourcecode
POST /restconf/data/ietf-dots-data-channel:dots-data\
     /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-dots-data-channel:acls": {
    "acl": [
      {
        "name": "dns-fragments",
        "type": "ipv4-acl-type",
        "aces": {
          "ace": [
            {
              "name": "drop-all-fragments",
              "matches": {
                "ipv4": {
                  "fragment": {
                    "operator": "match",
                    "type": "isf"
                  }
                }
              },
              "actions": {
                "forwarding": "drop"
              }
            },
            {
              "name": "allow-dns-packets",
              "matches": {
                "ipv4": {
                  "destination-ipv4-network": "198.51.100.0/24"
                },
                "udp": {
                  "destination-port-range-or-operator": {
                    "operator": "eq",
                    "port": 53
                  }
                },
                "actions": {
                  "forwarding": "accept"
                }
              }
            }
          ]
        }
      }
    ]
  }
}
```
:::

[Figure 34](#figure-34){.selfRef}: [Filtering IPv4 Fragmented
Packets](#name-filtering-ipv4-fragmented-p){.selfRef}
:::

[Figure 35](#fragdnsv6){.xref} shows an example of a POST request issued
by a DOTS client to its DOTS server to allow the traffic destined to
2001:db8::/32 and UDP port number 53, but to drop all fragmented
packets. The following ACEs are defined (in this
order):[¶](#section-appendix.a-5){.pilcrow}

-   [\"drop-all-fragments\" ACE: discards all fragments (including
    atomic fragments). That is, IPv6 packets that include a Fragment
    header (44) are
    dropped.[¶](#section-appendix.a-6.1){.pilcrow}]{#section-appendix.a-6.1}
-   [\"allow-dns-packets\" ACE: accepts DNS packets destined to
    2001:db8::/32.[¶](#section-appendix.a-6.2){.pilcrow}]{#section-appendix.a-6.2}

[]{#name-filtering-ipv6-fragmented-p}

::: {#fragdnsv6}
::: {#section-appendix.a-7.1}
``` sourcecode
POST /restconf/data/ietf-dots-data-channel:dots-data\
     /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-dots-data-channel:acls": {
    "acl": [
      {
        "name": "dns-fragments",
        "type": "ipv6-acl-type",
        "aces": {
          "ace": [
            {
              "name": "drop-all-fragments",
              "matches": {
                "ipv6": {
                  "fragment": {
                    "operator": "match",
                    "type": "isf"
                  }
                }
              },
              "actions": {
                "forwarding": "drop"
              }
            },
            {
              "name": "allow-dns-packets",
              "matches": {
                "ipv6": {
                  "destination-ipv6-network": "2001:db8::/32"
                },
                "udp": {
                  "destination-port-range-or-operator": {
                    "operator": "eq",
                    "port": 53
                  }
                }
              },
              "actions": {
                "forwarding": "accept"
              }
            }
          ]
        }
      }
    ]
  }
}
```
:::

[Figure 35](#figure-35){.selfRef}: [Filtering IPv6 Fragmented
Packets](#name-filtering-ipv6-fragmented-p){.selfRef}
:::
:::
:::

::: {#flags}
::: {#section-appendix.b .section}
## [Appendix B.](#section-appendix.b){.section-number .selfRef} [Examples: Filtering TCP Messages](#name-examples-filtering-tcp-mess){.section-name .selfRef} {#name-examples-filtering-tcp-mess}

This section provides examples to illustrate TCP-specific filtering
based on the flag bits. These examples should not be interpreted as
recommended filtering behaviors under specific DDoS
attacks.[¶](#section-appendix.b-1){.pilcrow}

::: {#section-b.1 .section}
## [B.1.](#section-b.1){.section-number .selfRef} [Discard TCP Null Attack](#name-discard-tcp-null-attack){.section-name .selfRef} {#name-discard-tcp-null-attack}

[Figure 36](#ex3){.xref} shows an example of a DOTS request sent by a
DOTS client to install immediately a filter to discard incoming TCP
messages having all flags unset. The bitmask can be set to 255 to check
against the (CWR, ECE, URG, ACK, PSH, RST, SYN, FIN)
flags.[¶](#section-b.1-1){.pilcrow}

[]{#name-example-of-a-dots-request-t}

::: {#ex3}
::: {#section-b.1-2.1}
``` sourcecode
PUT /restconf/data/ietf-dots-data-channel:dots-data\
    /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\
    /acl=tcp-flags-example HTTP/1.1
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-dots-data-channel:acls": {
    "acl": [{
      "name": "tcp-flags-example",
      "activation-type": "immediate",
      "aces": {
        "ace": [{
          "name": "null-attack",
          "matches": {
            "tcp": {
              "flags-bitmask": {
                "operator": "not any",
                "bitmask": 4095
              }
            }
          },
          "actions": {
            "forwarding": "drop"
          }
        }]
      }
    }]
  }
}
```
:::

[Figure 36](#figure-36){.selfRef}: [Example of a DOTS Request to Deny
TCP Null Attack Messages](#name-example-of-a-dots-request-t){.selfRef}
:::
:::

::: {#section-b.2 .section}
## [B.2.](#section-b.2){.section-number .selfRef} [Rate-Limit SYN Flooding](#name-rate-limit-syn-flooding){.section-name .selfRef} {#name-rate-limit-syn-flooding}

[Figure 37](#syn-rate){.xref} shows an ACL example to rate-limit
incoming SYNs during a SYN flood attack.[¶](#section-b.2-1){.pilcrow}

[]{#name-example-of-dots-request-to-}

::: {#syn-rate}
::: {#section-b.2-2.1}
``` sourcecode
PUT /restconf/data/ietf-dots-data-channel:dots-data\
    /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\
    /acl=tcp-flags-example HTTP/1.1
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-dots-data-channel:acls": {
    "acl": [{
      "name": "tcp-flags-example",
      "activation-type": "activate-when-mitigating",
      "aces": {
        "ace": [{
          "name": "rate-limit-syn",
          "matches": {
            "tcp": {
              "flags-bitmask": {
                "operator": "match",
                "bitmask": 2
              }
            }
          },
          "actions": {
            "forwarding": "accept",
            "rate-limit": "20.00"
          }
        }]
      }
    }]
  }
}
```
:::

[Figure 37](#figure-37){.selfRef}: [Example of DOTS Request to
Rate-Limit Incoming TCP
SYNs](#name-example-of-dots-request-to-){.selfRef}
:::
:::

::: {#section-b.3 .section}
## [B.3.](#section-b.3){.section-number .selfRef} [Rate-Limit ACK Flooding](#name-rate-limit-ack-flooding){.section-name .selfRef} {#name-rate-limit-ack-flooding}

[Figure 38](#ex1){.xref} shows an ACL example to rate-limit incoming
ACKs during an ACK flood attack.[¶](#section-b.3-1){.pilcrow}

[]{#name-example-of-dots-request-to-r}

::: {#ex1}
::: {#section-b.3-2.1}
``` sourcecode
PUT /restconf/data/ietf-dots-data-channel:dots-data\
    /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\
    /acl=tcp-flags-example HTTP/1.1
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-dots-data-channel:acls": {
    "acl": [{
      "name": "tcp-flags-example",
      "type": "ipv4-acl-type",
      "activation-type": "activate-when-mitigating",
      "aces": {
        "ace": [{
          "name": "rate-limit-ack",
          "matches": {
            "tcp": {
              "flags-bitmask": {
                "operator": "match",
                "bitmask": 16
              }
            }
          },
          "actions": {
            "forwarding": "accept",
            "rate-limit": "20.00"
          }
        }]
      }
    }]
  }
}
```
:::

[Figure 38](#figure-38){.selfRef}: [Example of DOTS Request to
Rate-Limit Incoming TCP
ACKs](#name-example-of-dots-request-to-r){.selfRef}
:::
:::
:::
:::

::: {#ack}
::: {#section-appendix.c .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

Thanks to [Christian Jacquenet]{.contact-name}, [Roland
Dobbins]{.contact-name}, [Roman Danyliw]{.contact-name}, [Ehud
Doron]{.contact-name}, [Russ White]{.contact-name}, [Gilbert
Clark]{.contact-name}, [Kathleen Moriarty]{.contact-name}, [Nesredien
Suleiman]{.contact-name}, [Roni Even]{.contact-name}, and [Brian
Trammel]{.contact-name} for the discussion and
comments.[¶](#section-appendix.c-1){.pilcrow}

The authors would like to give special thanks to [Kaname
Nishizuka]{.contact-name} and [Jon Shallow]{.contact-name} for their
efforts in implementing the protocol and performing interop testing at
IETF Hackathons.[¶](#section-appendix.c-2){.pilcrow}

Many thanks to [Benjamin Kaduk]{.contact-name} for the detailed AD
review.[¶](#section-appendix.c-3){.pilcrow}

Thanks to [Martin Björklund]{.contact-name} for the guidance on
RESTCONF.[¶](#section-appendix.c-4){.pilcrow}

Thanks to [Alexey Melnikov]{.contact-name}, [Adam Roach]{.contact-name},
[Suresh Krishnan]{.contact-name}, [Mirja Kühlewind]{.contact-name}, and
[Warren Kumari]{.contact-name} for the
review.[¶](#section-appendix.c-5){.pilcrow}
:::
:::

::: {#section-appendix.d .section}
## [Contributors](#name-contributors){.section-name .selfRef} {#name-contributors}

The following people contributed substantially to the content of this
document and should be considered
coauthors:[¶](#section-appendix.d-1){.pilcrow}

::: {.left dir="auto"}
[Kaname Nishizuka]{.fn .nameRole}
:::

::: {.left dir="auto"}
[NTT Communications]{.org}
:::

::: {.left dir="auto"}
[GranPark 16F 3-4-1 Shibaura, Minato-ku]{.street-address},
[Tokyo]{.region}
:::

::: {.left dir="auto"}
[108-8118]{.postal-code}
:::

::: {.left dir="auto"}
[Japan]{.country-name}
:::

::: email
Email: <kaname@nttv6.jp>
:::

::: {.left dir="auto"}
[Liang Xia]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Huawei]{.org}
:::

::: {.left dir="auto"}
[101 Software Avenue, Yuhuatai District]{.street-address}
:::

::: {.left dir="auto"}
[Nanjing]{.locality}
:::

::: {.left dir="auto"}
[Jiangsu]{.region}, [210012]{.postal-code}
:::

::: {.left dir="auto"}
[China]{.country-name}
:::

::: email
Email: <frank.xialiang@huawei.com>
:::

::: {.left dir="auto"}
[Prashanth Patil]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Cisco Systems, Inc.]{.org}
:::

::: email
Email: <praspati@cisco.com>
:::

::: {.left dir="auto"}
[Andrew Mortensen]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Arbor Networks, Inc.]{.org}
:::

::: {.left dir="auto"}
[2727 S. State Street]{.street-address}
:::

::: {.left dir="auto"}
[Ann Arbor]{.locality}, [Michigan]{.region} [48104]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <andrew@moretension.com>
:::

::: {.left dir="auto"}
[Nik Teague]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Iron Mountain Data Centers]{.org}
:::

::: {.left dir="auto"}
[United Kingdom]{.country-name}
:::

::: email
Email: <nteague@ironmountain.co.uk>
:::

The following individuals have contributed to this
document:[¶](#section-appendix.d-2){.pilcrow}

::: {.left dir="auto"}
[Dan Wing]{.fn .nameRole}
:::

::: email
Email: <dwing-ietf@fuggles.com>
:::

::: {.left dir="auto"}
[Jon Shallow]{.fn .nameRole}
:::

::: {.left dir="auto"}
[NCC Group]{.org}
:::

::: email
Email: <jon.shallow@nccgroup.com>
:::
:::

::: {#authors-addresses}
::: {#section-appendix.e .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Mohamed Boucadair ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Orange]{.org}
:::

::: {.left dir="auto"}
[35000]{.postal-code} [Rennes]{.locality}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <mohamed.boucadair@orange.com>
:::

::: {.left dir="auto"}
[Tirumaleswar Reddy.K ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[McAfee, Inc.]{.org}
:::

::: {.left dir="auto"}
[Embassy Golf Link Business Park]{.street-address}
:::

::: {.left dir="auto"}
[Bangalore]{.locality} [560071]{.postal-code}
:::

::: {.left dir="auto"}
[Karnataka]{.region}
:::

::: {.left dir="auto"}
[India]{.country-name}
:::

::: email
Email: <kondtir@gmail.com>
:::
:::
:::
