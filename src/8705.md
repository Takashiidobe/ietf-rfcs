  RFC 8705           OAuth Mutual TLS   February 2020
  ------------------ ------------------ ---------------
  Campbell, et al.   Standards Track    \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8705](https://www.rfc-editor.org/rfc/rfc8705){.eref}

Category:
:   Standards Track

Published:
:   February 2020

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    B. Campbell
    :::

    ::: org
    Ping Identity
    :::
    :::

    ::: author
    ::: author-name
    J. Bradley
    :::

    ::: org
    Yubico
    :::
    :::

    ::: author
    ::: author-name
    N. Sakimura
    :::

    ::: org
    Nomura Research Institute
    :::
    :::

    ::: author
    ::: author-name
    T. Lodderstedt
    :::

    ::: org
    YES.com AG
    :::
    :::
:::

# RFC 8705 {#rfcnum}

# OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes OAuth client authentication and
certificate-bound access and refresh tokens using mutual Transport Layer
Security (TLS) authentication with X.509 certificates. OAuth clients are
provided a mechanism for authentication to the authorization server
using mutual TLS, based on either self-signed certificates or public key
infrastructure (PKI). OAuth authorization servers are provided a
mechanism for binding access tokens to a client\'s mutual-TLS
certificate, and OAuth protected resources are provided a method for
ensuring that such an access token presented to it was issued to the
client presenting the token.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8705>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Requirements Notation and
        Conventions](#name-requirements-notation-and-c){.xref}[¶](#section-toc.1-1.1.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.1.2.2}
        [1.2](#section-1.2){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.1.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Mutual TLS for OAuth Client
    Authentication](#name-mutual-tls-for-oauth-client){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [PKI Mutual-TLS
        Method](#name-pki-mutual-tls-method){.xref}[¶](#section-toc.1-1.2.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.2.2.1.2.1}
            [2.1.1](#section-2.1.1){.xref}.  [PKI Method Metadata
            Value](#name-pki-method-metadata-value){.xref}[¶](#section-toc.1-1.2.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.2.2.1.2.2}
            [2.1.2](#section-2.1.2){.xref}.  [Client Registration
            Metadata](#name-client-registration-metadat){.xref}[¶](#section-toc.1-1.2.2.1.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [Self-Signed Certificate Mutual-TLS
        Method](#name-self-signed-certificate-mut){.xref}[¶](#section-toc.1-1.2.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.2.2.2.2.1}
            [2.2.1](#section-2.2.1){.xref}.  [Self-Signed Method
            Metadata
            Value](#name-self-signed-method-metadata){.xref}[¶](#section-toc.1-1.2.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.2.2.2.2.2}
            [2.2.2](#section-2.2.2){.xref}.  [Client Registration
            Metadata](#name-client-registration-metadata){.xref}[¶](#section-toc.1-1.2.2.2.2.2.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Mutual-TLS Client Certificate-Bound Access
    Tokens](#name-mutual-tls-client-certifica){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [JWT Certificate Thumbprint
        Confirmation
        Method](#name-jwt-certificate-thumbprint-){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Confirmation Method for Token
        Introspection](#name-confirmation-method-for-tok){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Authorization Server
        Metadata](#name-authorization-server-metada){.xref}[¶](#section-toc.1-1.3.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [Client Registration
        Metadata](#name-client-registration-metadata-2){.xref}[¶](#section-toc.1-1.3.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Public Clients and Certificate-Bound
    Tokens](#name-public-clients-and-certific){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Metadata for Mutual-TLS Endpoint
    Aliases](#name-metadata-for-mutual-tls-end){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Implementation
    Considerations](#name-implementation-consideratio){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Authorization
        Server](#name-authorization-server){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Resource
        Server](#name-resource-server){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Certificate Expiration and Bound
        Access
        Tokens](#name-certificate-expiration-and-){.xref}[¶](#section-toc.1-1.6.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [Implicit Grant
        Unsupported](#name-implicit-grant-unsupported){.xref}[¶](#section-toc.1-1.6.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.5}
        [6.5](#section-6.5){.xref}.  [TLS
        Termination](#name-tls-termination){.xref}[¶](#section-toc.1-1.6.2.5.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Certificate-Bound Refresh
        Tokens](#name-certificate-bound-refresh-t){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Certificate Thumbprint
        Binding](#name-certificate-thumbprint-bind){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [TLS Versions and Best
        Practices](#name-tls-versions-and-best-pract){.xref}[¶](#section-toc.1-1.7.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [X.509 Certificate
        Spoofing](#name-x509-certificate-spoofing){.xref}[¶](#section-toc.1-1.7.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.5}
        [7.5](#section-7.5){.xref}.  [X.509 Certificate Parsing and
        Validation
        Complexity](#name-x509-certificate-parsing-an){.xref}[¶](#section-toc.1-1.7.2.5.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Privacy
    Considerations](#name-privacy-considerations){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [JWT Confirmation Methods
        Registration](#name-jwt-confirmation-methods-re){.xref}[¶](#section-toc.1-1.9.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Authorization Server Metadata
        Registration](#name-authorization-server-metadat){.xref}[¶](#section-toc.1-1.9.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.3}
        [9.3](#section-9.3){.xref}.  [Token Endpoint Authentication
        Method
        Registration](#name-token-endpoint-authenticati){.xref}[¶](#section-toc.1-1.9.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.4}
        [9.4](#section-9.4){.xref}.  [Token Introspection Response
        Registration](#name-token-introspection-respons){.xref}[¶](#section-toc.1-1.9.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.5}
        [9.5](#section-9.5){.xref}.  [Dynamic Client Registration
        Metadata
        Registration](#name-dynamic-client-registration){.xref}[¶](#section-toc.1-1.9.2.5.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}

    -   ::: {#section-toc.1-1.10.2.1}
        [10.1](#section-10.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.10.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [10.2](#section-10.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.10.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [Appendix A](#section-appendix.a){.xref}.  [Example \"cnf\" Claim,
    Certificate, and
    JWK](#name-example-cnf-claim-certifica){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.12}
    [Appendix B](#section-appendix.b){.xref}.  [Relationship to Token
    Binding](#name-relationship-to-token-bindi){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.13}
    [](#section-appendix.c){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.14}
    [](#section-appendix.d){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::
:::
:::

::: {#Introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The OAuth 2.0 Authorization Framework \[[RFC6749](#RFC6749){.xref}\]
enables third-party client applications to obtain delegated access to
protected resources. In the prototypical abstract OAuth flow,
illustrated in [Figure 1](#protocol-flow-figure){.xref}, the client
obtains an access token from an entity known as an authorization server
and then uses that token when accessing protected resources, such as
HTTPS APIs.[¶](#section-1-1){.pilcrow}

[]{#name-abstract-oauth-20-protocol-}

::: {#protocol-flow-figure}
::: {#section-1-2.1 .artwork .art-text .alignLeft}
      +--------+                                 +---------------+
      |        |                                 |               |
      |        |<--(A)-- Get an access token --->| Authorization |
      |        |                                 |     Server    |
      |        |                                 |               |
      |        |                                 +---------------+
      |        |                                         ^
      |        |                                         |
      |        |
      |        |                               (C)       |
      | Client |                           Validate the
      |        |                           access token  |
      |        |
      |        |                                         |
      |        |                                         v
      |        |                                 +---------------+
      |        |                                 |      (C)      |
      |        |                                 |               |
      |        |<--(B)-- Use the access token -->|   Protected   |
      |        |                                 |    Resource   |
      |        |                                 |               |
      +--------+                                 +---------------+
:::

[Figure 1](#figure-1){.selfRef}: [Abstract OAuth 2.0 Protocol
Flow](#name-abstract-oauth-20-protocol-){.selfRef}
:::

The flow illustrated in [Figure 1](#protocol-flow-figure){.xref}
includes the following steps:[¶](#section-1-3){.pilcrow}

\(A\)
:   The client makes an HTTPS `POST` request to the authorization server
    and presents a credential representing the authorization grant. For
    certain types of clients (those that have been issued or otherwise
    established a set of client credentials) the request must be
    authenticated. In the response, the authorization server issues an
    access token to the client.[¶](#section-1-4.1){.pilcrow}

\(B\)
:   The client includes the access token when making a request to access
    a protected resource.[¶](#section-1-4.2){.pilcrow}

\(C\)
:   The protected resource validates the access token in order to
    authorize the request. In some cases, such as when the token is
    self-contained and cryptographically secured, the validation can be
    done locally by the protected resource. Other cases require that the
    protected resource call out to the authorization server to determine
    the state of the token and obtain metainformation about
    it.[¶](#section-1-4.3){.pilcrow}

Layering on the abstract flow above, this document standardizes enhanced
security options for OAuth 2.0 utilizing client-certificate-based mutual
TLS. [Section 2](#mtlsca){.xref} provides options for authenticating the
request in Step (A). Step (C) is supported with semantics to express the
binding of the token to the client certificate for both local and remote
processing in Sections [3.1](#x5t){.xref} and [3.2](#introspect){.xref},
respectively. This ensures that, as described in [Section
3](#CertificateBoundAccessTokens){.xref}, protected resource access in
Step (B) is only possible by the legitimate client using a
certificate-bound token and holding the private key corresponding to the
certificate.[¶](#section-1-5){.pilcrow}

OAuth 2.0 defines a shared-secret method of client authentication but
also allows for defining and using additional client authentication
mechanisms when interacting directly with the authorization server. This
document describes an additional mechanism of client authentication
utilizing mutual-TLS certificate-based authentication that provides
better security characteristics than shared secrets. While
\[[RFC6749](#RFC6749){.xref}\] documents client authentication for
requests to the token endpoint, extensions to OAuth 2.0 (such as
Introspection \[[RFC7662](#RFC7662){.xref}\], Revocation
\[[RFC7009](#RFC7009){.xref}\], and the Backchannel Authentication
Endpoint in \[[OpenID.CIBA](#OpenID.CIBA){.xref}\]) define endpoints
that also utilize client authentication, and the mutual-TLS methods
defined herein are applicable to those endpoints as
well.[¶](#section-1-6){.pilcrow}

Mutual-TLS certificate-bound access tokens ensure that only the party in
possession of the private key corresponding to the certificate can
utilize the token to access the associated resources. Such a constraint
is sometimes referred to as key confirmation, proof-of-possession, or
holder-of-key and is unlike the case of the bearer token described in
\[[RFC6750](#RFC6750){.xref}\], where any party in possession of the
access token can use it to access the associated resources. Binding an
access token to the client\'s certificate prevents the use of stolen
access tokens or replay of access tokens by unauthorized
parties.[¶](#section-1-7){.pilcrow}

Mutual-TLS certificate-bound access tokens and mutual-TLS client
authentication are distinct mechanisms that are complementary but don\'t
necessarily need to be deployed or used
together.[¶](#section-1-8){.pilcrow}

Additional client metadata parameters are introduced by this document in
support of certificate-bound access tokens and mutual-TLS client
authentication. The authorization server can obtain client metadata via
the Dynamic Client Registration Protocol \[[RFC7591](#RFC7591){.xref}\],
which defines mechanisms for dynamically registering OAuth 2.0 client
metadata with authorization servers. Also the metadata defined by
\[[RFC7591](#RFC7591){.xref}\], and registered extensions to it, imply a
general data model for clients that is useful for authorization server
implementations, even when the Dynamic Client Registration Protocol
isn\'t in play. Such implementations will typically have some sort of
user interface available for managing client
configuration.[¶](#section-1-9){.pilcrow}

::: {#RNC}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Requirements Notation and Conventions](#name-requirements-notation-and-c){.section-name .selfRef} {#name-requirements-notation-and-c}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-1){.pilcrow}
:::
:::

::: {#Terminology}
::: {#section-1.2 .section}
### [1.2.](#section-1.2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

Throughout this document the term \"mutual TLS\" refers to the process
whereby, in addition to the normal TLS server authentication with a
certificate, a client presents its X.509 certificate and proves
possession of the corresponding private key to a server when negotiating
a TLS session. In contemporary versions of TLS
\[[RFC5246](#RFC5246){.xref}\] \[[RFC8446](#RFC8446){.xref}\], this
requires that the client send the Certificate and CertificateVerify
messages during the handshake and for the server to verify the
CertificateVerify and Finished messages.[¶](#section-1.2-1){.pilcrow}
:::
:::
:::
:::

::: {#mtlsca}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Mutual TLS for OAuth Client Authentication](#name-mutual-tls-for-oauth-client){.section-name .selfRef} {#name-mutual-tls-for-oauth-client}

This section defines, as an extension of [Section
2.3](https://www.rfc-editor.org/rfc/rfc6749#section-2.3){.relref} of
OAuth 2.0 \[[RFC6749](#RFC6749){.xref}\], two distinct methods of using
mutual-TLS X.509 client certificates as client credentials. The
requirement of mutual TLS for client authentication is determined by the
authorization server, based on policy or configuration for the given
client (regardless of whether the client was dynamically registered,
statically configured, or otherwise
established).[¶](#section-2-1){.pilcrow}

In order to utilize TLS for OAuth client authentication, the TLS
connection between the client and the authorization server
[MUST]{.bcp14} have been established or re-established with mutual-TLS
X.509 certificate authentication (i.e., the client Certificate and
CertificateVerify messages are sent during the TLS
handshake).[¶](#section-2-2){.pilcrow}

For all requests to the authorization server utilizing mutual-TLS client
authentication, the client [MUST]{.bcp14} include the `client_id`
parameter described in [Section
2.2](https://www.rfc-editor.org/rfc/rfc6749#section-2.2){.relref} of
OAuth 2.0 \[[RFC6749](#RFC6749){.xref}\]. The presence of the
`client_id` parameter enables the authorization server to easily
identify the client independently from the content of the certificate.
The authorization server can locate the client configuration using the
client identifier and check the certificate presented in the TLS
handshake against the expected credentials for that client. The
authorization server [MUST]{.bcp14} enforce the binding between client
and certificate, as described in either Section
[2.1](#pki_method){.xref} or [2.2](#self_signed_method){.xref} below. If
no certificate is presented, or that which is presented doesn\'t match
that which is expected for the given `client_id`, the authorization
server returns a normal OAuth 2.0 error response per [Section
5.2](https://www.rfc-editor.org/rfc/rfc6749#section-5.2){.relref} of
\[[RFC6749](#RFC6749){.xref}\] with the `invalid_client` error code to
indicate failed client authentication.[¶](#section-2-3){.pilcrow}

::: {#pki_method}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [PKI Mutual-TLS Method](#name-pki-mutual-tls-method){.section-name .selfRef} {#name-pki-mutual-tls-method}

The PKI (public key infrastructure) method of mutual-TLS OAuth client
authentication adheres to the way in which X.509 certificates are
traditionally used for authentication. It relies on a validated
certificate chain \[[RFC5280](#RFC5280){.xref}\] and a single subject
distinguished name (DN) or a single subject alternative name (SAN) to
authenticate the client. Only one subject name value of any type is used
for each client. The TLS handshake is utilized to validate the client\'s
possession of the private key corresponding to the public key in the
certificate and to validate the corresponding certificate chain. The
client is successfully authenticated if the subject information in the
certificate matches the single expected subject configured or registered
for that particular client (note that a predictable treatment of DN
values, such as the distinguishedNameMatch rule from
\[[RFC4517](#RFC4517){.xref}\], is needed in comparing the
certificate\'s subject DN to the client\'s registered DN). Revocation
checking is possible with the PKI method but if and how to check a
certificate\'s revocation status is a deployment decision at the
discretion of the authorization server. Clients can rotate their X.509
certificates without the need to modify the respective authentication
data at the authorization server by obtaining a new certificate with the
same subject from a trusted certificate authority
(CA).[¶](#section-2.1-1){.pilcrow}

::: {#metadata_auth_value_pki}
::: {#section-2.1.1 .section}
#### [2.1.1.](#section-2.1.1){.section-number .selfRef} [PKI Method Metadata Value](#name-pki-method-metadata-value){.section-name .selfRef} {#name-pki-method-metadata-value}

For the PKI method of mutual-TLS client authentication, this
specification defines and registers the following authentication method
metadata value into the \"OAuth Token Endpoint Authentication Methods\"
registry
\[[IANA.OAuth.Parameters](#IANA.OAuth.Parameters){.xref}\].[¶](#section-2.1.1-1){.pilcrow}

tls_client_auth
:   Indicates that client authentication to the authorization server
    will occur with mutual TLS utilizing the PKI method of associating a
    certificate to a client.[¶](#section-2.1.1-2.2){.pilcrow}
:::
:::

::: {#client_metadata_pki}
::: {#section-2.1.2 .section}
#### [2.1.2.](#section-2.1.2){.section-number .selfRef} [Client Registration Metadata](#name-client-registration-metadat){.section-name .selfRef} {#name-client-registration-metadat}

In order to convey the expected subject of the certificate, the
following metadata parameters are introduced for the OAuth 2.0 Dynamic
Client Registration Protocol \[[RFC7591](#RFC7591){.xref}\] in support
of the PKI method of mutual-TLS client authentication. A client using
the `tls_client_auth` authentication method [MUST]{.bcp14} use exactly
one of the below metadata parameters to indicate the certificate subject
value that the authorization server is to expect when authenticating the
respective client.[¶](#section-2.1.2-1){.pilcrow}

tls_client_auth_subject_dn
:   A string representation \-- as defined in
    \[[RFC4514](#RFC4514){.xref}\] \-- of the expected subject
    distinguished name of the certificate that the OAuth client will use
    in mutual-TLS authentication.[¶](#section-2.1.2-2.2){.pilcrow}

tls_client_auth_san_dns
:   A string containing the value of an expected dNSName SAN entry in
    the certificate that the OAuth client will use in mutual-TLS
    authentication.[¶](#section-2.1.2-2.4){.pilcrow}

tls_client_auth_san_uri
:   A string containing the value of an expected
    uniformResourceIdentifier SAN entry in the certificate that the
    OAuth client will use in mutual-TLS
    authentication.[¶](#section-2.1.2-2.6){.pilcrow}

tls_client_auth_san_ip
:   A string representation of an IP address in either dotted decimal
    notation (for IPv4) or colon-delimited hexadecimal (for IPv6, as
    defined in \[[RFC5952](#RFC5952){.xref}\]) that is expected to be
    present as an iPAddress SAN entry in the certificate that the OAuth
    client will use in mutual-TLS authentication. Per [Section
    8](https://www.rfc-editor.org/rfc/rfc5952#section-8){.relref} of
    \[[RFC5952](#RFC5952){.xref}\], the IP address comparison of the
    value in this parameter and the SAN entry in the certificate is to
    be done in binary format.[¶](#section-2.1.2-2.8){.pilcrow}

tls_client_auth_san_email
:   A string containing the value of an expected rfc822Name SAN entry in
    the certificate that the OAuth client will use in mutual-TLS
    authentication.[¶](#section-2.1.2-2.10){.pilcrow}
:::
:::
:::
:::

::: {#self_signed_method}
::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [Self-Signed Certificate Mutual-TLS Method](#name-self-signed-certificate-mut){.section-name .selfRef} {#name-self-signed-certificate-mut}

This method of mutual-TLS OAuth client authentication is intended to
support client authentication using self-signed certificates. As a
prerequisite, the client registers its X.509 certificates (using `jwks`
defined in \[[RFC7591](#RFC7591){.xref}\]) or a reference to a trusted
source for its X.509 certificates (using `jwks_uri` from
\[[RFC7591](#RFC7591){.xref}\]) with the authorization server. During
authentication, TLS is utilized to validate the client\'s possession of
the private key corresponding to the public key presented within the
certificate in the respective TLS handshake. In contrast to the PKI
method, the client\'s certificate chain is not validated by the server
in this case. The client is successfully authenticated if the
certificate that it presented during the handshake matches one of the
certificates configured or registered for that particular client. The
Self-Signed Certificate method allows the use of mutual TLS to
authenticate clients without the need to maintain a PKI. When used in
conjunction with a `jwks_uri` for the client, it also allows the client
to rotate its X.509 certificates without the need to change its
respective authentication data directly with the authorization
server.[¶](#section-2.2-1){.pilcrow}

::: {#metadata_auth_value_self_signed}
::: {#section-2.2.1 .section}
#### [2.2.1.](#section-2.2.1){.section-number .selfRef} [Self-Signed Method Metadata Value](#name-self-signed-method-metadata){.section-name .selfRef} {#name-self-signed-method-metadata}

For the Self-Signed Certificate method of mutual-TLS client
authentication, this specification defines and registers the following
authentication method metadata value into the \"OAuth Token Endpoint
Authentication Methods\" registry
\[[IANA.OAuth.Parameters](#IANA.OAuth.Parameters){.xref}\].[¶](#section-2.2.1-1){.pilcrow}

self_signed_tls_client_auth
:   Indicates that client authentication to the authorization server
    will occur using mutual TLS with the client utilizing a self-signed
    certificate.[¶](#section-2.2.1-2.2){.pilcrow}
:::
:::

::: {#client_metadata_self_signed}
::: {#section-2.2.2 .section}
#### [2.2.2.](#section-2.2.2){.section-number .selfRef} [Client Registration Metadata](#name-client-registration-metadata){.section-name .selfRef} {#name-client-registration-metadata}

For the Self-Signed Certificate method of binding a certificate with a
client using mutual-TLS client authentication, the existing `jwks_uri`
or `jwks` metadata parameters from \[[RFC7591](#RFC7591){.xref}\] are
used to convey the client\'s certificates via JSON Web Key (JWK) in a
JWK Set \[[RFC7517](#RFC7517){.xref}\]. The `jwks` metadata parameter is
a JWK Set containing the client\'s public keys as an array of JWKs,
while the `jwks_uri` parameter is a URL that references a client\'s JWK
Set. A certificate is represented with the `x5c` parameter of an
individual JWK within the set. Note that the members of the JWK
representing the public key (e.g., \"n\" and \"e\" for RSA, \"x\" and
\"y\" for Elliptic Curve (EC)) are required parameters per
\[[RFC7518](#RFC7518){.xref}\] so will be present even though they are
not utilized in this context. Also note that [Section
4.7](https://www.rfc-editor.org/rfc/rfc7517#section-4.7){.relref} of
\[[RFC7517](#RFC7517){.xref}\] requires that the key in the first
certificate of the `x5c` parameter match the public key represented by
those other members of the JWK.[¶](#section-2.2.2-1){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#CertificateBoundAccessTokens}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Mutual-TLS Client Certificate-Bound Access Tokens](#name-mutual-tls-client-certifica){.section-name .selfRef} {#name-mutual-tls-client-certifica}

When mutual TLS is used by the client on the connection to the token
endpoint, the authorization server is able to bind the issued access
token to the client certificate. Such a binding is accomplished by
associating the certificate with the token in a way that can be accessed
by the protected resource, such as embedding the certificate hash in the
issued access token directly, using the syntax described in [Section
3.1](#x5t){.xref}, or through token introspection as described in
[Section 3.2](#introspect){.xref}. Binding the access token to the
client certificate in that fashion has the benefit of decoupling that
binding from the client\'s authentication with the authorization server,
which enables mutual TLS during protected resource access to serve
purely as a proof-of-possession mechanism. Other methods of associating
a certificate with an access token are possible, per agreement by the
authorization server and the protected resource, but are beyond the
scope of this specification.[¶](#section-3-1){.pilcrow}

In order for a resource server to use certificate-bound access tokens,
it must have advance knowledge that mutual TLS is to be used for some or
all resource accesses. In particular, the access token itself cannot be
used as input to the decision of whether or not to request mutual TLS
because (from the TLS perspective) it is \"Application Data\", only
exchanged after the TLS handshake has been completed, and the initial
CertificateRequest occurs during the handshake, before the Application
Data is available. Although subsequent opportunities for a TLS client to
present a certificate may be available, e.g., via TLS 1.2 renegotiation
\[[RFC5246](#RFC5246){.xref}\] or TLS 1.3 post-handshake authentication
\[[RFC8446](#RFC8446){.xref}\], this document makes no provision for
their usage. It is expected to be common that a mutual-TLS-using
resource server will require mutual TLS for all resources hosted
thereupon or will serve mutual-TLS-protected and regular resources on
separate hostname and port combinations, though other workflows are
possible. How resource server policy is synchronized with the
authorization server (AS) is out of scope for this
document.[¶](#section-3-2){.pilcrow}

Within the scope of a mutual-TLS-protected resource-access flow, the
client makes protected resource requests, as described in
\[[RFC6750](#RFC6750){.xref}\], however, those requests [MUST]{.bcp14}
be made over a mutually authenticated TLS connection using the same
certificate that was used for mutual TLS at the token
endpoint.[¶](#section-3-3){.pilcrow}

The protected resource [MUST]{.bcp14} obtain, from its TLS
implementation layer, the client certificate used for mutual TLS and
[MUST]{.bcp14} verify that the certificate matches the certificate
associated with the access token. If they do not match, the resource
access attempt [MUST]{.bcp14} be rejected with an error, per
\[[RFC6750](#RFC6750){.xref}\], using an HTTP 401 status code and the
`invalid_token` error code.[¶](#section-3-4){.pilcrow}

Metadata to convey server and client capabilities for mutual-TLS client
certificate-bound access tokens is defined in Sections
[3.3](#server_metadata_at){.xref} and [3.4](#client_metadata_at){.xref},
respectively.[¶](#section-3-5){.pilcrow}

::: {#x5t}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [JWT Certificate Thumbprint Confirmation Method](#name-jwt-certificate-thumbprint-){.section-name .selfRef} {#name-jwt-certificate-thumbprint-}

When access tokens are represented as JSON Web Tokens (JWT)
\[[RFC7519](#RFC7519){.xref}\], the certificate hash information
[SHOULD]{.bcp14} be represented using the `x5t#S256` confirmation method
member defined herein.[¶](#section-3.1-1){.pilcrow}

To represent the hash of a certificate in a JWT, this specification
defines the new JWT Confirmation Method \[[RFC7800](#RFC7800){.xref}\]
member `x5t#S256` for the X.509 Certificate SHA-256 Thumbprint. The
value of the `x5t#S256` member is a base64url-encoded
\[[RFC4648](#RFC4648){.xref}\] SHA-256 \[[SHS](#SHS){.xref}\] hash
(a.k.a., thumbprint, fingerprint, or digest) of the DER encoding
\[[X690](#X690){.xref}\] of the X.509 certificate
\[[RFC5280](#RFC5280){.xref}\]. The base64url-encoded value
[MUST]{.bcp14} omit all trailing pad \'=\' characters and [MUST
NOT]{.bcp14} include any line breaks, whitespace, or other additional
characters.[¶](#section-3.1-2){.pilcrow}

The following is an example of a JWT payload containing an `x5t#S256`
certificate thumbprint confirmation method. The new JWT content
introduced by this specification is the `cnf` confirmation method claim
at the bottom of the example that has the `x5t#S256` confirmation method
member containing the value that is the hash of the client certificate
to which the access token is bound.[¶](#section-3.1-3){.pilcrow}

[]{#name-example-jwt-claims-set-with}

::: {#eg_x5ts256jwt}
::: {#section-3.1-4.1}
``` {.sourcecode .lang-json}
  {
    "iss": "https://server.example.com",
    "sub": "ty.webb@example.com",
    "exp": 1493726400,
    "nbf": 1493722800,
    "cnf":{
      "x5t#S256": "bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2"
    }
  }
```
:::

[Figure 2](#figure-2){.selfRef}: [Example JWT Claims Set with an X.509
Certificate Thumbprint Confirmation
Method](#name-example-jwt-claims-set-with){.selfRef}
:::
:::
:::

::: {#introspect}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Confirmation Method for Token Introspection](#name-confirmation-method-for-tok){.section-name .selfRef} {#name-confirmation-method-for-tok}

OAuth 2.0 Token Introspection \[[RFC7662](#RFC7662){.xref}\] defines a
method for a protected resource to query an authorization server about
the active state of an access token as well as to determine
metainformation about the token.[¶](#section-3.2-1){.pilcrow}

For a mutual-TLS client certificate-bound access token, the hash of the
certificate to which the token is bound is conveyed to the protected
resource as metainformation in a token introspection response. The hash
is conveyed using the same `cnf` with `x5t#S256` member structure as the
certificate SHA-256 thumbprint confirmation method, described in
[Section 3.1](#x5t){.xref}, as a top-level member of the introspection
response JSON. The protected resource compares that certificate hash to
a hash of the client certificate used for mutual-TLS authentication and
rejects the request if they do not match.[¶](#section-3.2-2){.pilcrow}

The following is an example of an introspection response for an active
token with an `x5t#S256` certificate thumbprint confirmation method. The
new introspection response content introduced by this specification is
the `cnf` confirmation method at the bottom of the example that has the
`x5t#S256` confirmation method member containing the value that is the
hash of the client certificate to which the access token is
bound.[¶](#section-3.2-3){.pilcrow}

[]{#name-example-introspection-respo}

::: {#eg_x5ts256intro}
::: {#section-3.2-4.1 .artwork .art-text .alignLeft}
      HTTP/1.1 200 OK
      Content-Type: application/json

      {
        "active": true,
        "iss": "https://server.example.com",
        "sub": "ty.webb@example.com",
        "exp": 1493726400,
        "nbf": 1493722800,
        "cnf":{
          "x5t#S256": "bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2"
        }
      }
:::

[Figure 3](#figure-3){.selfRef}: [Example Introspection Response for a
Certificate-Bound Access
Token](#name-example-introspection-respo){.selfRef}
:::
:::
:::

::: {#server_metadata_at}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Authorization Server Metadata](#name-authorization-server-metada){.section-name .selfRef} {#name-authorization-server-metada}

This document introduces the following new authorization server metadata
\[[RFC8414](#RFC8414){.xref}\] parameter to signal the server\'s
capability to issue certificate-bound access
tokens:[¶](#section-3.3-1){.pilcrow}

tls_client_certificate_bound_access_tokens
:   [OPTIONAL]{.bcp14}. Boolean value indicating server support for
    mutual-TLS client certificate-bound access tokens. If omitted, the
    default value is `false`.[¶](#section-3.3-2.2){.pilcrow}
:::
:::

::: {#client_metadata_at}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [Client Registration Metadata](#name-client-registration-metadata-2){.section-name .selfRef} {#name-client-registration-metadata-2}

The following new client metadata parameter is introduced to convey the
client\'s intention to use certificate-bound access
tokens:[¶](#section-3.4-1){.pilcrow}

tls_client_certificate_bound_access_tokens
:   [OPTIONAL]{.bcp14}. Boolean value used to indicate the client\'s
    intention to use mutual-TLS client certificate-bound access tokens.
    If omitted, the default value is
    `false`.[¶](#section-3.4-2.2){.pilcrow}

Note that if a client that has indicated the intention to use mutual-TLS
client certificate-bound tokens makes a request to the token endpoint
over a non-mutual-TLS connection, it is at the authorization server\'s
discretion as to whether to return an error or issue an unbound
token.[¶](#section-3.4-3){.pilcrow}
:::
:::
:::
:::

::: {#PubClient}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Public Clients and Certificate-Bound Tokens](#name-public-clients-and-certific){.section-name .selfRef} {#name-public-clients-and-certific}

Mutual-TLS OAuth client authentication and certificate-bound access
tokens can be used independently of each other. Use of certificate-bound
access tokens without mutual-TLS OAuth client authentication, for
example, is possible in support of binding access tokens to a TLS client
certificate for public clients (those without authentication credentials
associated with the `client_id`). The authorization server would
configure the TLS stack in the same manner as for the Self-Signed
Certificate method such that it does not verify that the certificate
presented by the client during the handshake is signed by a trusted CA.
Individual instances of a client would create a self-signed certificate
for mutual TLS with both the authorization server and resource server.
The authorization server would not use the mutual-TLS certificate to
authenticate the client at the OAuth layer but would bind the issued
access token to the certificate for which the client has proven
possession of the corresponding private key. The access token is then
bound to the certificate and can only be used by the client possessing
the certificate and corresponding private key and utilizing them to
negotiate mutual TLS on connections to the resource server. When the
authorization server issues a refresh token to such a client, it
[SHOULD]{.bcp14} also bind the refresh token to the respective
certificate and check the binding when the refresh token is presented to
get new access tokens. The implementation details of the binding of the
refresh token are at the discretion of the authorization
server.[¶](#section-4-1){.pilcrow}
:::
:::

::: {#endpointAliases}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Metadata for Mutual-TLS Endpoint Aliases](#name-metadata-for-mutual-tls-end){.section-name .selfRef} {#name-metadata-for-mutual-tls-end}

The process of negotiating client certificate-based mutual TLS involves
a TLS server requesting a certificate from the TLS client (the client
does not provide one unsolicited). Although a server can be configured
such that client certificates are optional, meaning that the connection
is allowed to continue when the client does not provide a certificate,
the act of a server requesting a certificate can result in undesirable
behavior from some clients. This is particularly true of web browsers as
TLS clients, which will typically present the end user with an intrusive
certificate selection interface when the server requests a
certificate.[¶](#section-5-1){.pilcrow}

Authorization servers supporting both clients using mutual TLS and
conventional clients [MAY]{.bcp14} chose to isolate the server side
mutual-TLS behavior to only clients intending to do mutual TLS, thus
avoiding any undesirable effects it might have on conventional clients.
The following authorization server metadata parameter is introduced to
facilitate such separation:[¶](#section-5-2){.pilcrow}

mtls_endpoint_aliases
:   [OPTIONAL]{.bcp14}. A JSON object containing alternative
    authorization server endpoints that, when present, an OAuth client
    intending to do mutual TLS uses in preference to the conventional
    endpoints. The parameter value itself consists of one or more
    endpoint parameters, such as `token_endpoint`,
    `revocation_endpoint`, `introspection_endpoint`, etc.,
    conventionally defined for the top level of authorization server
    metadata. An OAuth client intending to do mutual TLS (for OAuth
    client authentication and/or to acquire or use certificate-bound
    tokens) when making a request directly to the authorization server
    [MUST]{.bcp14} use the alias URL of the endpoint within the
    `mtls_endpoint_aliases`, when present, in preference to the endpoint
    URL of the same name at the top level of metadata. When an endpoint
    is not present in `mtls_endpoint_aliases`, then the client uses the
    conventional endpoint URL defined at the top level of the
    authorization server metadata. Metadata parameters within
    `mtls_endpoint_aliases` that do not define endpoints to which an
    OAuth client makes a direct request have no meaning and
    [SHOULD]{.bcp14} be ignored.[¶](#section-5-3.2){.pilcrow}

Below is an example of an authorization server metadata document with
the `mtls_endpoint_aliases` parameter, which indicates aliases for the
token, revocation, and introspection endpoints that an OAuth client
intending to do mutual TLS would use in preference to the conventional
token, revocation, and introspection endpoints. Note that the endpoints
in `mtls_endpoint_aliases` use a different host than their conventional
counterparts, which allows the authorization server (via TLS
`server_name` extension \[[RFC6066](#RFC6066){.xref}\] or actual
distinct hosts) to differentiate its TLS behavior as
appropriate.[¶](#section-5-4){.pilcrow}

[]{#name-example-authorization-serve}

::: {#as-meta}
::: {#section-5-5.1}
``` {.sourcecode .lang-json}
{
  "issuer": "https://server.example.com",
  "authorization_endpoint": "https://server.example.com/authz",
  "token_endpoint": "https://server.example.com/token",
  "introspection_endpoint": "https://server.example.com/introspect",
  "revocation_endpoint": "https://server.example.com/revo",
  "jwks_uri": "https://server.example.com/jwks",
  "response_types_supported": ["code"],
  "response_modes_supported": ["fragment","query","form_post"],
  "grant_types_supported": ["authorization_code", "refresh_token"],
  "token_endpoint_auth_methods_supported":
                  ["tls_client_auth","client_secret_basic","none"],
  "tls_client_certificate_bound_access_tokens": true,
  "mtls_endpoint_aliases": {
    "token_endpoint": "https://mtls.example.com/token",
    "revocation_endpoint": "https://mtls.example.com/revo",
    "introspection_endpoint": "https://mtls.example.com/introspect"
  }
}
```
:::

[Figure 4](#figure-4){.selfRef}: [Example Authorization Server Metadata
with Mutual-TLS Endpoint
Aliases](#name-example-authorization-serve){.selfRef}
:::
:::
:::

::: {#Impl}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Implementation Considerations](#name-implementation-consideratio){.section-name .selfRef} {#name-implementation-consideratio}

::: {#ImplAS}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Authorization Server](#name-authorization-server){.section-name .selfRef} {#name-authorization-server}

The authorization server needs to set up its TLS configuration
appropriately for the OAuth client authentication methods it
supports.[¶](#section-6.1-1){.pilcrow}

An authorization server that supports mutual-TLS client authentication
and other client authentication methods or public clients in parallel
would make mutual TLS optional (i.e., allowing a handshake to continue
after the server requests a client certificate but the client does not
send one).[¶](#section-6.1-2){.pilcrow}

In order to support the Self-Signed Certificate method alone, the
authorization server would configure the TLS stack in such a way that it
does not verify whether the certificate presented by the client during
the handshake is signed by a trusted CA
certificate.[¶](#section-6.1-3){.pilcrow}

As described in [Section 3](#CertificateBoundAccessTokens){.xref}, the
authorization server binds the issued access token to the TLS client
certificate, which means that it will only issue certificate-bound
tokens for a certificate that the client has proven possession of the
corresponding private key.[¶](#section-6.1-4){.pilcrow}

The authorization server may also consider hosting the token endpoint
and other endpoints requiring client authentication on a separate host
name or port in order to prevent unintended impact on the TLS behavior
of its other endpoints, e.g., the authorization endpoint. As described
in [Section 5](#endpointAliases){.xref}, it may further isolate any
potential impact of the server requesting client certificates by
offering a distinct set of endpoints on a separate host or port, which
are aliases for the originals that a client intending to do mutual TLS
will use in preference to the conventional
endpoints.[¶](#section-6.1-5){.pilcrow}
:::
:::

::: {#ImplRS}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Resource Server](#name-resource-server){.section-name .selfRef} {#name-resource-server}

OAuth divides the roles and responsibilities such that the resource
server relies on the authorization server to perform client
authentication and obtain resource-owner (end-user) authorization. The
resource server makes authorization decisions based on the access token
presented by the client but does not directly authenticate the client
per se. The manner in which an access token is bound to the client
certificate and how a protected resource verifies the
proof-of-possession decouples that from the specific method that the
client used to authenticate with the authorization server. Mutual TLS
during protected resource access can, therefore, serve purely as a
proof-of-possession mechanism. As such, it is not necessary for the
resource server to validate the trust chain of the client\'s certificate
in any of the methods defined in this document. The resource server
would, therefore, configure the TLS stack in a way that it does not
verify whether the certificate presented by the client during the
handshake is signed by a trusted CA
certificate.[¶](#section-6.2-1){.pilcrow}
:::
:::

::: {#ImplExp}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Certificate Expiration and Bound Access Tokens](#name-certificate-expiration-and-){.section-name .selfRef} {#name-certificate-expiration-and-}

As described in [Section 3](#CertificateBoundAccessTokens){.xref}, an
access token is bound to a specific client certificate, which means that
the same certificate must be used for mutual TLS on protected resource
access. It also implies that access tokens are invalidated when a client
updates the certificate, which can be handled similarly to expired
access tokens where the client requests a new access token (typically
with a refresh token) and retries the protected resource
request.[¶](#section-6.3-1){.pilcrow}
:::
:::

::: {#ImplImplicit}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [Implicit Grant Unsupported](#name-implicit-grant-unsupported){.section-name .selfRef} {#name-implicit-grant-unsupported}

This document describes binding an access token to the client
certificate presented on the TLS connection from the client to the
authorization server\'s token endpoint, however, such binding of access
tokens issued directly from the authorization endpoint via the implicit
grant flow is explicitly out of scope. End users interact directly with
the authorization endpoint using a web browser, and the use of client
certificates in user\'s browsers bring operational and usability issues
that make it undesirable to support certificate-bound access tokens
issued in the implicit grant flow. Implementations wanting to employ
certificate-bound access tokens should utilize grant types that involve
the client making an access token request directly to the token endpoint
(e.g., the authorization code and refresh token grant
types).[¶](#section-6.4-1){.pilcrow}
:::
:::

::: {#TTRP}
::: {#section-6.5 .section}
### [6.5.](#section-6.5){.section-number .selfRef} [TLS Termination](#name-tls-termination){.section-name .selfRef} {#name-tls-termination}

An authorization server or resource server [MAY]{.bcp14} choose to
terminate TLS connections at a load balancer, reverse proxy, or other
network intermediary. How the client certificate metadata is securely
communicated between the intermediary and the application server, in
this case, is out of scope of this
specification.[¶](#section-6.5-1){.pilcrow}
:::
:::
:::
:::

::: {#Security}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Certificate-Bound Refresh Tokens](#name-certificate-bound-refresh-t){.section-name .selfRef} {#name-certificate-bound-refresh-t}

The OAuth 2.0 Authorization Framework \[[RFC6749](#RFC6749){.xref}\]
requires that an authorization server (AS) bind refresh tokens to the
client to which they were issued and that confidential clients (those
having established authentication credentials with the AS) authenticate
to the AS when presenting a refresh token. As a result, refresh tokens
are indirectly certificate-bound by way of the client ID and the
associated requirement for (certificate-based) authentication to the AS
when issued to clients utilizing the `tls_client_auth` or
`self_signed_tls_client_auth` methods of client authentication. [Section
4](#PubClient){.xref} describes certificate-bound refresh tokens issued
to public clients (those without authentication credentials associated
with the `client_id`).[¶](#section-7.1-1){.pilcrow}
:::

::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Certificate Thumbprint Binding](#name-certificate-thumbprint-bind){.section-name .selfRef} {#name-certificate-thumbprint-bind}

The binding between the certificate and access token specified in
[Section 3.1](#x5t){.xref} uses a cryptographic hash of the certificate.
It relies on the hash function having sufficient second-preimage
resistance so as to make it computationally infeasible to find or create
another certificate that produces to the same hash output value. The
SHA-256 hash function was used because it meets the aforementioned
requirement while being widely available. If, in the future, certificate
thumbprints need to be computed using hash function(s) other than
SHA-256, it is suggested that, for additional related JWT confirmation
methods, members be defined for that purpose and registered in the IANA
\"JWT Confirmation Methods\" registry
\[[IANA.JWT.Claims](#IANA.JWT.Claims){.xref}\] for JWT `cnf` member
values.[¶](#section-7.2-1){.pilcrow}

Community knowledge about the strength of various algorithms and
feasible attacks can change suddenly, and experience shows that a
document about security is a point-in-time statement. Readers are
advised to seek out any errata or updates that apply to this
document.[¶](#section-7.2-2){.pilcrow}
:::

::: {#TLSV}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [TLS Versions and Best Practices](#name-tls-versions-and-best-pract){.section-name .selfRef} {#name-tls-versions-and-best-pract}

This document is applicable with any TLS version supporting
certificate-based client authentication. Both [TLS 1.3](#RFC8446){.xref}
\[[RFC8446](#RFC8446){.xref}\] and [TLS 1.2](#RFC5246){.xref}
\[[RFC5246](#RFC5246){.xref}\] are cited herein, because, at the time of
writing, 1.3 is the newest version, while 1.2 is the most widely
deployed. General implementation and security considerations for TLS,
including version recommendations, can be found in
\[[BCP195](#BCP195){.xref}\].[¶](#section-7.3-1){.pilcrow}

TLS certificate validation (for both client and server certificates)
requires a local database of trusted certificate authorities (CAs).
Decisions about what CAs to trust and how to make such a determination
of trust are out of scope for this
document.[¶](#section-7.3-2){.pilcrow}
:::
:::

::: {#certspoofing}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [X.509 Certificate Spoofing](#name-x509-certificate-spoofing){.section-name .selfRef} {#name-x509-certificate-spoofing}

If the PKI method of client authentication is used, an attacker could
try to impersonate a client using a certificate with the same subject
(DN or SAN) but issued by a different CA that the authorization server
trusts. To cope with that threat, the authorization server
[SHOULD]{.bcp14} only accept, as trust anchors, a limited number of CAs
whose certificate issuance policy meets its security requirements. There
is an assumption then that the client and server agree out of band on
the set of trust anchors that the server uses to create and validate the
certificate chain. Without this assumption the use of a subject to
identify the client certificate would open the server up to certificate
spoofing attacks.[¶](#section-7.4-1){.pilcrow}
:::
:::

::: {#section-7.5 .section}
### [7.5.](#section-7.5){.section-number .selfRef} [X.509 Certificate Parsing and Validation Complexity](#name-x509-certificate-parsing-an){.section-name .selfRef} {#name-x509-certificate-parsing-an}

Parsing and validation of X.509 certificates and certificate chains is
complex, and implementation mistakes have previously exposed security
vulnerabilities. Complexities of validation include (but are not limited
to) \[[CX5P](#CX5P){.xref}\] \[[DCW](#DCW){.xref}\]
\[[RFC5280](#RFC5280){.xref}\]:[¶](#section-7.5-1){.pilcrow}

-   [checking of basic constraints, basic and extended key usage
    constraints, validity periods, and critical
    extensions;[¶](#section-7.5-2.1){.pilcrow}]{#section-7.5-2.1}
-   [handling of embedded NUL bytes in ASN.1 counted-length strings and
    non-canonical or non-normalized string representations in subject
    names;[¶](#section-7.5-2.2){.pilcrow}]{#section-7.5-2.2}
-   [handling of wildcard patterns in subject
    names;[¶](#section-7.5-2.3){.pilcrow}]{#section-7.5-2.3}
-   [recursive verification of certificate chains and checking
    certificate
    revocation.[¶](#section-7.5-2.4){.pilcrow}]{#section-7.5-2.4}

For these reasons, implementors [SHOULD]{.bcp14} use an established and
well-tested X.509 library (such as one used by an established TLS
library) for validation of X.509 certificate chains and [SHOULD
NOT]{.bcp14} attempt to write their own X.509 certificate validation
procedures.[¶](#section-7.5-3){.pilcrow}
:::
:::
:::

::: {#Privacy}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Privacy Considerations](#name-privacy-considerations){.section-name .selfRef} {#name-privacy-considerations}

In TLS versions prior to 1.3, the client\'s certificate is sent
unencrypted in the initial handshake and can potentially be used by
third parties to monitor, track, and correlate client activity. This is
likely of little concern for clients that act on behalf of a significant
number of end users because individual user activity will not be
discernible amidst the client activity as a whole. However, clients that
act on behalf of a single end user, such as a native application on a
mobile device, should use TLS version 1.3 whenever possible or consider
the potential privacy implications of using mutual TLS on earlier
versions.[¶](#section-8-1){.pilcrow}
:::
:::

::: {#IANA}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [JWT Confirmation Methods Registration](#name-jwt-confirmation-methods-re){.section-name .selfRef} {#name-jwt-confirmation-methods-re}

Per this specification, the following value has been registered in the
IANA \"JWT Confirmation Methods\" registry
\[[IANA.JWT.Claims](#IANA.JWT.Claims){.xref}\] for JWT `cnf` member
values established by
\[[RFC7800](#RFC7800){.xref}\].[¶](#section-9.1-1){.pilcrow}

Confirmation Method Value:
:   `x5t#S256`[¶](#section-9.1-2.2){.pilcrow}

Confirmation Method Description:
:   X.509 Certificate SHA-256 Thumbprint[¶](#section-9.1-2.4){.pilcrow}

Change Controller:
:   IESG[¶](#section-9.1-2.6){.pilcrow}

Specification Document(s):
:   [Section 3.1](#x5t){.xref} of RFC
    8705[¶](#section-9.1-2.8){.pilcrow}
:::

::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Authorization Server Metadata Registration](#name-authorization-server-metadat){.section-name .selfRef} {#name-authorization-server-metadat}

Per this specification, the following values have been registered in the
IANA \"OAuth Authorization Server Metadata\" registry
\[[IANA.OAuth.Parameters](#IANA.OAuth.Parameters){.xref}\] established
by \[[RFC8414](#RFC8414){.xref}\].[¶](#section-9.2-1){.pilcrow}

Metadata Name:
:   `tls_client_certificate_bound_access_tokens`[¶](#section-9.2-2.2){.pilcrow}

Metadata Description:
:   Indicates authorization server support for mutual-TLS client
    certificate-bound access tokens.[¶](#section-9.2-2.4){.pilcrow}

Change Controller:
:   IESG[¶](#section-9.2-2.6){.pilcrow}

Specification Document(s):
:   [Section 3.3](#server_metadata_at){.xref} of RFC
    8705[¶](#section-9.2-2.8){.pilcrow}

```{=html}
<!-- -->
```

Metadata Name:
:   `mtls_endpoint_aliases`[¶](#section-9.2-3.2){.pilcrow}

Metadata Description:
:   JSON object containing alternative authorization server endpoints,
    which a client intending to do mutual TLS will use in preference to
    the conventional endpoints.[¶](#section-9.2-3.4){.pilcrow}

Change Controller:
:   IESG[¶](#section-9.2-3.6){.pilcrow}

Specification Document(s):
:   [Section 5](#endpointAliases){.xref} of RFC
    8705[¶](#section-9.2-3.8){.pilcrow}
:::

::: {#section-9.3 .section}
### [9.3.](#section-9.3){.section-number .selfRef} [Token Endpoint Authentication Method Registration](#name-token-endpoint-authenticati){.section-name .selfRef} {#name-token-endpoint-authenticati}

Per this specification, the following values have been registered in the
IANA \"OAuth Token Endpoint Authentication Methods\" registry
\[[IANA.OAuth.Parameters](#IANA.OAuth.Parameters){.xref}\] established
by \[[RFC7591](#RFC7591){.xref}\].[¶](#section-9.3-1){.pilcrow}

Token Endpoint Authentication Method Name:
:   `tls_client_auth`[¶](#section-9.3-2.2){.pilcrow}

Change Controller:
:   IESG[¶](#section-9.3-2.4){.pilcrow}

Specification Document(s):
:   [Section 2.1.1](#metadata_auth_value_pki){.xref} of RFC
    8705[¶](#section-9.3-2.6){.pilcrow}

```{=html}
<!-- -->
```

Token Endpoint Authentication Method Name:\
:   `self_signed_tls_client_​auth`[¶](#section-9.3-3.2){.pilcrow}

Change Controller:
:   IESG[¶](#section-9.3-3.4){.pilcrow}

Specification Document(s):
:   [Section 2.2.1](#metadata_auth_value_self_signed){.xref} of RFC
    8705[¶](#section-9.3-3.6){.pilcrow}
:::

::: {#section-9.4 .section}
### [9.4.](#section-9.4){.section-number .selfRef} [Token Introspection Response Registration](#name-token-introspection-respons){.section-name .selfRef} {#name-token-introspection-respons}

\"Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs)\"
\[[RFC7800](#RFC7800){.xref}\] defined the `cnf` (confirmation) claim
that enables confirmation key information to be carried in a JWT.
However, the same proof-of-possession semantics are also useful for
introspected access tokens whereby the protected resource obtains the
confirmation key data as metainformation of a token introspection
response and uses that information in verifying proof-of-possession.
Therefore, this specification defines and registers proof-of-possession
semantics for OAuth 2.0 Token Introspection
\[[RFC7662](#RFC7662){.xref}\] using the `cnf` structure. When included
as a top-level member of an OAuth token introspection response, `cnf`
has the same semantics and format as the claim of the same name defined
in \[[RFC7800](#RFC7800){.xref}\]. While this specification only
explicitly uses the `x5t#S256` confirmation method member (see [Section
3.2](#introspect){.xref}), it needs to define and register the
higher-level `cnf` structure as an introspection response member in
order to define and use the more specific certificate thumbprint
confirmation method.[¶](#section-9.4-1){.pilcrow}

As such, the following values have been registered in the IANA \"OAuth
Token Introspection Response\" registry
\[[IANA.OAuth.Parameters](#IANA.OAuth.Parameters){.xref}\] established
by \[[RFC7662](#RFC7662){.xref}\].[¶](#section-9.4-2){.pilcrow}

Claim Name:
:   `cnf`[¶](#section-9.4-3.2){.pilcrow}

Claim Description:
:   Confirmation[¶](#section-9.4-3.4){.pilcrow}

Change Controller:
:   IESG[¶](#section-9.4-3.6){.pilcrow}

Specification Document(s):
:   \[[RFC7800](#RFC7800){.xref}\] and RFC
    8705[¶](#section-9.4-3.8){.pilcrow}
:::

::: {#section-9.5 .section}
### [9.5.](#section-9.5){.section-number .selfRef} [Dynamic Client Registration Metadata Registration](#name-dynamic-client-registration){.section-name .selfRef} {#name-dynamic-client-registration}

Per this specification, the following client metadata definitions have
been registered in the IANA \"OAuth Dynamic Client Registration
Metadata\" registry
\[[IANA.OAuth.Parameters](#IANA.OAuth.Parameters){.xref}\] established
by \[[RFC7591](#RFC7591){.xref}\]:[¶](#section-9.5-1){.pilcrow}

Client Metadata Name:
:   `tls_client_certificate_bound_access_tokens`[¶](#section-9.5-2.2){.pilcrow}

Client Metadata Description:
:   Indicates the client\'s intention to use mutual-TLS client
    certificate-bound access tokens.[¶](#section-9.5-2.4){.pilcrow}

Change Controller:
:   IESG[¶](#section-9.5-2.6){.pilcrow}

Specification Document(s):
:   [Section 3.4](#client_metadata_at){.xref} of RFC
    8705[¶](#section-9.5-2.8){.pilcrow}

```{=html}
<!-- -->
```

Client Metadata Name:
:   `tls_client_auth_subject_dn`[¶](#section-9.5-3.2){.pilcrow}

Client Metadata Description:
:   String value specifying the expected subject DN of the client
    certificate.[¶](#section-9.5-3.4){.pilcrow}

Change Controller:
:   IESG[¶](#section-9.5-3.6){.pilcrow}

Specification Document(s):
:   [Section 2.1.2](#client_metadata_pki){.xref} of RFC
    8705[¶](#section-9.5-3.8){.pilcrow}

```{=html}
<!-- -->
```

Client Metadata Name:
:   `tls_client_auth_san_dns`[¶](#section-9.5-4.2){.pilcrow}

Client Metadata Description:
:   String value specifying the expected dNSName SAN entry in the client
    certificate.[¶](#section-9.5-4.4){.pilcrow}

Change Controller:
:   IESG[¶](#section-9.5-4.6){.pilcrow}

Specification Document(s):
:   [Section 2.1.2](#client_metadata_pki){.xref} of RFC
    8705[¶](#section-9.5-4.8){.pilcrow}

```{=html}
<!-- -->
```

Client Metadata Name:
:   `tls_client_auth_san_uri`[¶](#section-9.5-5.2){.pilcrow}

Client Metadata Description:
:   String value specifying the expected uniformResourceIdentifier SAN
    entry in the client certificate.[¶](#section-9.5-5.4){.pilcrow}

Change Controller:
:   IESG[¶](#section-9.5-5.6){.pilcrow}

Specification Document(s):
:   [Section 2.1.2](#client_metadata_pki){.xref} of RFC
    8705[¶](#section-9.5-5.8){.pilcrow}

```{=html}
<!-- -->
```

Client Metadata Name:
:   `tls_client_auth_san_ip`[¶](#section-9.5-6.2){.pilcrow}

Client Metadata Description:
:   String value specifying the expected iPAddress SAN entry in the
    client certificate.[¶](#section-9.5-6.4){.pilcrow}

Change Controller:
:   IESG[¶](#section-9.5-6.6){.pilcrow}

Specification Document(s):
:   [Section 2.1.2](#client_metadata_pki){.xref} of RFC
    8705[¶](#section-9.5-6.8){.pilcrow}

```{=html}
<!-- -->
```

Client Metadata Name:
:   `tls_client_auth_san_email`[¶](#section-9.5-7.2){.pilcrow}

Client Metadata Description:
:   String value specifying the expected rfc822Name SAN entry in the
    client certificate.[¶](#section-9.5-7.4){.pilcrow}

Change Controller:
:   IESG[¶](#section-9.5-7.6){.pilcrow}

Specification Document(s):
:   [Section 2.1.2](#client_metadata_pki){.xref} of RFC
    8705[¶](#section-9.5-7.8){.pilcrow}
:::
:::
:::

::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-10.1 .section}
### [10.1.](#section-10.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[BCP195\]
:   [Sheffer, Y.]{.refAuthor}[, Holz, R.]{.refAuthor}[, and P.
    Saint-Andre]{.refAuthor}, [\"Recommendations for Secure Use of
    Transport Layer Security (TLS) and Datagram Transport Layer Security
    (DTLS)\"]{.refTitle}, [BCP 195]{.seriesInfo}, [RFC
    7525]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/bcp195>\>.

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.

\[RFC4514\]
:   [Zeilenga, K., Ed.]{.refAuthor}, [\"Lightweight Directory Access
    Protocol (LDAP): String Representation of Distinguished
    Names\"]{.refTitle}, [RFC 4514]{.seriesInfo}, [DOI
    10.17487/RFC4514]{.seriesInfo}, June 2006,
    \<<https://www.rfc-editor.org/info/rfc4514>\>.

\[RFC4648\]
:   [Josefsson, S.]{.refAuthor}, [\"The Base16, Base32, and Base64 Data
    Encodings\"]{.refTitle}, [RFC 4648]{.seriesInfo}, [DOI
    10.17487/RFC4648]{.seriesInfo}, October 2006,
    \<<https://www.rfc-editor.org/info/rfc4648>\>.

\[RFC5246\]
:   [Dierks, T.]{.refAuthor}[ and E. Rescorla]{.refAuthor}, [\"The
    Transport Layer Security (TLS) Protocol Version 1.2\"]{.refTitle},
    [RFC 5246]{.seriesInfo}, [DOI 10.17487/RFC5246]{.seriesInfo}, August
    2008, \<<https://www.rfc-editor.org/info/rfc5246>\>.

\[RFC5280\]
:   [Cooper, D.]{.refAuthor}[, Santesson, S.]{.refAuthor}[,
    Farrell, S.]{.refAuthor}[, Boeyen, S.]{.refAuthor}[,
    Housley, R.]{.refAuthor}[, and W. Polk]{.refAuthor}, [\"Internet
    X.509 Public Key Infrastructure Certificate and Certificate
    Revocation List (CRL) Profile\"]{.refTitle}, [RFC
    5280]{.seriesInfo}, [DOI 10.17487/RFC5280]{.seriesInfo}, May 2008,
    \<<https://www.rfc-editor.org/info/rfc5280>\>.

\[RFC6749\]
:   [Hardt, D., Ed.]{.refAuthor}, [\"The OAuth 2.0 Authorization
    Framework\"]{.refTitle}, [RFC 6749]{.seriesInfo}, [DOI
    10.17487/RFC6749]{.seriesInfo}, October 2012,
    \<<https://www.rfc-editor.org/info/rfc6749>\>.

\[RFC6750\]
:   [Jones, M.]{.refAuthor}[ and D. Hardt]{.refAuthor}, [\"The OAuth 2.0
    Authorization Framework: Bearer Token Usage\"]{.refTitle}, [RFC
    6750]{.seriesInfo}, [DOI 10.17487/RFC6750]{.seriesInfo}, October
    2012, \<<https://www.rfc-editor.org/info/rfc6750>\>.

\[RFC7517\]
:   [Jones, M.]{.refAuthor}, [\"JSON Web Key (JWK)\"]{.refTitle}, [RFC
    7517]{.seriesInfo}, [DOI 10.17487/RFC7517]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7517>\>.

\[RFC7519\]
:   [Jones, M.]{.refAuthor}[, Bradley, J.]{.refAuthor}[, and N.
    Sakimura]{.refAuthor}, [\"JSON Web Token (JWT)\"]{.refTitle}, [RFC
    7519]{.seriesInfo}, [DOI 10.17487/RFC7519]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7519>\>.

\[RFC7591\]
:   [Richer, J., Ed.]{.refAuthor}[, Jones, M.]{.refAuthor}[,
    Bradley, J.]{.refAuthor}[, Machulak, M.]{.refAuthor}[, and P.
    Hunt]{.refAuthor}, [\"OAuth 2.0 Dynamic Client Registration
    Protocol\"]{.refTitle}, [RFC 7591]{.seriesInfo}, [DOI
    10.17487/RFC7591]{.seriesInfo}, July 2015,
    \<<https://www.rfc-editor.org/info/rfc7591>\>.

\[RFC7662\]
:   [Richer, J., Ed.]{.refAuthor}, [\"OAuth 2.0 Token
    Introspection\"]{.refTitle}, [RFC 7662]{.seriesInfo}, [DOI
    10.17487/RFC7662]{.seriesInfo}, October 2015,
    \<<https://www.rfc-editor.org/info/rfc7662>\>.

\[RFC7800\]
:   [Jones, M.]{.refAuthor}[, Bradley, J.]{.refAuthor}[, and H.
    Tschofenig]{.refAuthor}, [\"Proof-of-Possession Key Semantics for
    JSON Web Tokens (JWTs)\"]{.refTitle}, [RFC 7800]{.seriesInfo}, [DOI
    10.17487/RFC7800]{.seriesInfo}, April 2016,
    \<<https://www.rfc-editor.org/info/rfc7800>\>.

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.

\[RFC8414\]
:   [Jones, M.]{.refAuthor}[, Sakimura, N.]{.refAuthor}[, and J.
    Bradley]{.refAuthor}, [\"OAuth 2.0 Authorization Server
    Metadata\"]{.refTitle}, [RFC 8414]{.seriesInfo}, [DOI
    10.17487/RFC8414]{.seriesInfo}, June 2018,
    \<<https://www.rfc-editor.org/info/rfc8414>\>.

\[RFC8446\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.

\[SHS\]
:   [National Institute of Standards and Technology (NIST)]{.refAuthor},
    [\"Secure Hash Standard (SHS)\"]{.refTitle}, [FIPS PUB
    180-4]{.seriesInfo}, [DOI 10.6028/NIST.FIPS.180-4]{.seriesInfo},
    August 2015,
    \<<https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf>\>.

\[X690\]
:   [ITU-T]{.refAuthor}, [\"Information Technology - ASN.1 encoding
    rules: Specification of Basic Encoding Rules (BER), Canonical
    Encoding Rules (CER) and Distinguished Encoding Rules
    (DER)\"]{.refTitle}, [ITU-T Recommendation X.690]{.seriesInfo},
    August 2015.
:::

::: {#section-10.2 .section}
### [10.2.](#section-10.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[CX5P\]
:   [Wong, D.]{.refAuthor}, [\"Common x509 certificate
    validation/creation pitfalls\"]{.refTitle}, September 2016,
    \<<https://www.cryptologie.net/article/374/common-x509-certificate-validationcreation-pitfalls>\>.

\[DCW\]
:   [Georgiev, M.]{.refAuthor}[, Iyengar, S.]{.refAuthor}[,
    Jana, S.]{.refAuthor}[, Anubhai, R.]{.refAuthor}[,
    Boneh, D.]{.refAuthor}[, and V. Shmatikov]{.refAuthor}, [\"The Most
    Dangerous Code in the World: Validating SSL Certificates in
    Non-Browser Software\"]{.refTitle}, [DOI
    10.1145/2382196.2382204]{.seriesInfo}, October 2012,
    \<[http://www.cs.utexas.edu/\~shmat/shmat_ccs12.pdf](https://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf)\>.

\[IANA.JWT.Claims\]
:   [IANA]{.refAuthor}, [\"JSON Web Token Claims\"]{.refTitle},
    \<<https://www.iana.org/assignments/jwt>\>.

\[IANA.OAuth.Parameters\]
:   [IANA]{.refAuthor}, [\"OAuth Parameters\"]{.refTitle},
    \<<https://www.iana.org/assignments/oauth-parameters>\>.

\[OpenID.CIBA\]
:   [Fernandez, G.]{.refAuthor}[, Walter, F.]{.refAuthor}[,
    Nennker, A.]{.refAuthor}[, Tonge, D.]{.refAuthor}[, and B.
    Campbell]{.refAuthor}, [\"OpenID Connect Client Initiated
    Backchannel Authentication Flow - Core 1.0\"]{.refTitle}, 16 January
    2019,
    \<<https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html>\>.

\[RFC4517\]
:   [Legg, S., Ed.]{.refAuthor}, [\"Lightweight Directory Access
    Protocol (LDAP): Syntaxes and Matching Rules\"]{.refTitle}, [RFC
    4517]{.seriesInfo}, [DOI 10.17487/RFC4517]{.seriesInfo}, June 2006,
    \<<https://www.rfc-editor.org/info/rfc4517>\>.

\[RFC5952\]
:   [Kawamura, S.]{.refAuthor}[ and M. Kawashima]{.refAuthor}, [\"A
    Recommendation for IPv6 Address Text Representation\"]{.refTitle},
    [RFC 5952]{.seriesInfo}, [DOI 10.17487/RFC5952]{.seriesInfo}, August
    2010, \<<https://www.rfc-editor.org/info/rfc5952>\>.

\[RFC6066\]
:   [Eastlake 3rd, D.]{.refAuthor}, [\"Transport Layer Security (TLS)
    Extensions: Extension Definitions\"]{.refTitle}, [RFC
    6066]{.seriesInfo}, [DOI 10.17487/RFC6066]{.seriesInfo}, January
    2011, \<<https://www.rfc-editor.org/info/rfc6066>\>.

\[RFC7009\]
:   [Lodderstedt, T., Ed.]{.refAuthor}[, Dronia, S.]{.refAuthor}[,
    and M. Scurtescu]{.refAuthor}, [\"OAuth 2.0 Token
    Revocation\"]{.refTitle}, [RFC 7009]{.seriesInfo}, [DOI
    10.17487/RFC7009]{.seriesInfo}, August 2013,
    \<<https://www.rfc-editor.org/info/rfc7009>\>.

\[RFC7518\]
:   [Jones, M.]{.refAuthor}, [\"JSON Web Algorithms (JWA)\"]{.refTitle},
    [RFC 7518]{.seriesInfo}, [DOI 10.17487/RFC7518]{.seriesInfo}, May
    2015, \<<https://www.rfc-editor.org/info/rfc7518>\>.

\[TOKEN\]
:   [Jones, M.]{.refAuthor}[, Campbell, B.]{.refAuthor}[,
    Bradley, J.]{.refAuthor}[, and W. Denniss]{.refAuthor}, [\"OAuth 2.0
    Token Binding\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-oauth-token-binding-08]{.seriesInfo}, 19
    October 2018,
    \<<https://tools.ietf.org/html/draft-ietf-oauth-token-binding-08>\>.
:::
:::

::: {#example}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Example \"cnf\" Claim, Certificate, and JWK](#name-example-cnf-claim-certifica){.section-name .selfRef} {#name-example-cnf-claim-certifica}

For reference, an `x5t#S256` value and the X.509 certificate from which
it was calculated are provided in the following examples, Figures
[5](#cnf){.xref} and [6](#pem){.xref}, respectively. A JWK
representation of the certificate\'s public key along with the `x5c`
member is also provided in [Figure
7](#jwk){.xref}.[¶](#section-appendix.a-1){.pilcrow}

[]{#name-x5ts256-confirmation-claim}

::: {#cnf}
::: {#section-appendix.a-2.1}
``` {.sourcecode .lang-json}
"cnf":{"x5t#S256":"A4DtL2JmUMhAsvJj5tKyn64SqzmuXbMrJa0n761y5v0"}
```
:::

[Figure 5](#figure-5){.selfRef}: [x5t#S256 Confirmation
Claim](#name-x5ts256-confirmation-claim){.selfRef}
:::

[]{#name-pem-encoded-self-signed-cer}

::: {#pem}
::: {#section-appendix.a-3.1 .artwork .art-text .alignLeft}
    -----BEGIN CERTIFICATE-----
    MIIBBjCBrAIBAjAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDDARtdGxzMB4XDTE4MTAx
    ODEyMzcwOVoXDTIyMDUwMjEyMzcwOVowDzENMAsGA1UEAwwEbXRsczBZMBMGByqG
    SM49AgEGCCqGSM49AwEHA0IABNcnyxwqV6hY8QnhxxzFQ03C7HKW9OylMbnQZjjJ
    /Au08/coZwxS7LfA4vOLS9WuneIXhbGGWvsDSb0tH6IxLm8wCgYIKoZIzj0EAwID
    SQAwRgIhAP0RC1E+vwJD/D1AGHGzuri+hlV/PpQEKTWUVeORWz83AiEA5x2eXZOV
    bUlJSGQgjwD5vaUaKlLR50Q2DmFfQj1L+SY=
    -----END CERTIFICATE-----
:::

[Figure 6](#figure-6){.selfRef}: [PEM Encoded Self-Signed
Certificate](#name-pem-encoded-self-signed-cer){.selfRef}
:::

[]{#name-json-web-key}

::: {#jwk}
::: {#section-appendix.a-4.1}
``` {.sourcecode .lang-json}
{
 "kty":"EC",
 "x":"1yfLHCpXqFjxCeHHHMVDTcLscpb07KUxudBmOMn8C7Q",
 "y":"8_coZwxS7LfA4vOLS9WuneIXhbGGWvsDSb0tH6IxLm8",
 "crv":"P-256",
 "x5c":[
  "MIIBBjCBrAIBAjAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDDARtdGxzMB4XDTE4MTA
   xODEyMzcwOVoXDTIyMDUwMjEyMzcwOVowDzENMAsGA1UEAwwEbXRsczBZMBMGBy
   qGSM49AgEGCCqGSM49AwEHA0IABNcnyxwqV6hY8QnhxxzFQ03C7HKW9OylMbnQZ
   jjJ/Au08/coZwxS7LfA4vOLS9WuneIXhbGGWvsDSb0tH6IxLm8wCgYIKoZIzj0E
   AwIDSQAwRgIhAP0RC1E+vwJD/D1AGHGzuri+hlV/PpQEKTWUVeORWz83AiEA5x2
   eXZOVbUlJSGQgjwD5vaUaKlLR50Q2DmFfQj1L+SY="
   ]
 }
```
:::

[Figure 7](#figure-7){.selfRef}: [JSON Web
Key](#name-json-web-key){.selfRef}
:::
:::
:::

::: {#relation}
::: {#section-appendix.b .section}
## [Appendix B.](#section-appendix.b){.section-number .selfRef} [Relationship to Token Binding](#name-relationship-to-token-bindi){.section-name .selfRef} {#name-relationship-to-token-bindi}

OAuth 2.0 Token Binding
\[[TOKEN](#I-D.ietf-oauth-token-binding){.xref}\] enables the
application of Token Binding to the various artifacts and tokens
employed throughout OAuth. That includes binding of an access token to a
Token Binding key, which bears some similarities in motivation and
design to the mutual-TLS client certificate-bound access tokens defined
in this document. Both documents define what is often called a
proof-of-possession security mechanism for access tokens, whereby a
client must demonstrate possession of cryptographic keying material when
accessing a protected resource. The details differ somewhat between the
two documents but both have the authorization server bind the access
token that it issues to an asymmetric key pair held by the client. The
client then proves possession of the private key from that pair with
respect to the TLS connection over which the protected resource is
accessed.[¶](#section-appendix.b-1){.pilcrow}

Token Binding uses bare keys that are generated on the client, which
avoids many of the difficulties of creating, distributing, and managing
certificates used in this specification. However, at the time of
writing, Token Binding is fairly new, and there is relatively little
support for it in available application development platforms and
tooling. Until better support for the underlying core Token Binding
specifications exists, practical implementations of OAuth 2.0 Token
Binding are infeasible. Mutual TLS, on the other hand, has been around
for some time and enjoys widespread support in web servers and
development platforms. As a consequence, OAuth 2.0 Mutual-TLS Client
Authentication and Certificate-Bound Access Tokens can be built and
deployed now using existing platforms and tools. In the future, the two
specifications are likely to be deployed in parallel for solving similar
problems in different environments. Authorization servers may even
support both specifications simultaneously using different
proof-of-possession mechanisms for tokens issued to different
clients.[¶](#section-appendix.b-2){.pilcrow}
:::
:::

::: {#Acknowledgements}
::: {#section-appendix.c .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

Scott \"not Tomlinson\" Tomilson and [Matt Peterson]{.contact-name} were
involved in design and development work on a mutual-TLS OAuth client
authentication implementation that predates this document. Experience
and learning from that work informed some of the content of this
document.[¶](#section-appendix.c-1){.pilcrow}

This specification was developed within the OAuth Working Group under
the chairmanship of [Hannes Tschofenig]{.contact-name} and [Rifaat
Shekh-Yusef]{.contact-name} with [Eric Rescorla]{.contact-name},
[Benjamin Kaduk]{.contact-name}, and [Roman Danyliw]{.contact-name}
serving as Security Area Directors. Additionally, the following
individuals contributed ideas, feedback, and wording that helped shape
this specification: [Vittorio Bertocci]{.contact-name}, [Sergey
Beryozkin]{.contact-name}, [Ralph Bragg]{.contact-name}, [Sophie
Bremer]{.contact-name}, [Roman Danyliw]{.contact-name}, [Vladimir
Dzhuvinov]{.contact-name}, [Samuel Erdtman]{.contact-name}, [Evan
Gilman]{.contact-name}, [Leif Johansson]{.contact-name}, [Michael
Jones]{.contact-name}, [Phil Hunt]{.contact-name}, [Benjamin
Kaduk]{.contact-name}, [Takahiko Kawasaki]{.contact-name}, [Sean
Leonard]{.contact-name}, [Kepeng Li]{.contact-name}, [Neil
Madden]{.contact-name}, [James Manger]{.contact-name}, [Jim
Manico]{.contact-name}, [Nov Matake]{.contact-name}, [Sascha
Preibisch]{.contact-name}, [Eric Rescorla]{.contact-name}, [Justin
Richer]{.contact-name}, [Vincent Roca]{.contact-name}, [Filip
Skokan]{.contact-name}, [Dave Tonge]{.contact-name}, and [Hannes
Tschofenig]{.contact-name}.[¶](#section-appendix.c-2){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.d .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Brian Campbell]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Ping Identity]{.org}
:::

::: email
Email: <brian.d.campbell@gmail.com>
:::

::: {.left dir="auto"}
[John Bradley]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Yubico]{.org}
:::

::: email
Email: <ve7jtb@ve7jtb.com>
:::

::: url
URI: <http://www.thread-safe.com/>
:::

::: {.left dir="auto"}
[Nat Sakimura]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Nomura Research Institute]{.org}
:::

::: email
Email: <n-sakimura@nri.co.jp>
:::

::: url
URI: <https://nat.sakimura.org/>
:::

::: {.left dir="auto"}
[Torsten Lodderstedt]{.fn .nameRole}
:::

::: {.left dir="auto"}
[YES.com AG]{.org}
:::

::: email
Email: <torsten@lodderstedt.net>
:::
:::
:::
