  RFC 8894   SCEP            September 2020
  ---------- --------------- ----------------
  Gutmann    Informational   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8894](https://www.rfc-editor.org/rfc/rfc8894){.eref}

Category:
:   Informational

Published:
:   September 2020

ISSN:
:   2070-1721

Author:

:   ::: author
    ::: author-name
    P. Gutmann
    :::

    ::: org
    University of Auckland
    :::
    :::
:::

# RFC 8894 {#rfcnum}

# Simple Certificate Enrolment Protocol {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document specifies the Simple Certificate Enrolment Protocol
(SCEP), a PKI protocol that leverages existing technology by using
Cryptographic Message Syntax (CMS, formerly known as PKCS #7) and PKCS
#10 over HTTP. SCEP is the evolution of the enrolment protocol sponsored
by Cisco Systems, which enjoys wide support in both client and server
implementations, as well as being relied upon by numerous other industry
standards that work with certificates.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for informational
purposes.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Not all documents approved
by the IESG are candidates for any level of Internet Standard; see
Section 2 of RFC 7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8894>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}

This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November 10,
2008. The person(s) controlling the copyright in some of this material
may not have granted the IETF Trust the right to allow modifications of
such material outside the IETF Standards Process. Without obtaining an
adequate license from the person(s) controlling the copyright in such
materials, this document may not be modified outside the IETF Standards
Process, and derivative works of it may not be created outside the IETF
Standards Process, except to format it for publication as an RFC or to
translate it into languages other than
English.[¶](#section-boilerplate.2-3){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Conventions Used in This
        Document](#name-conventions-used-in-this-do){.xref}[¶](#section-toc.1-1.1.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [SCEP
    Overview](#name-scep-overview){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [SCEP
        Entities](#name-scep-entities){.xref}[¶](#section-toc.1-1.2.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.2.2.1.2.1}
            [2.1.1](#section-2.1.1){.xref}.  [Client](#name-client){.xref}[¶](#section-toc.1-1.2.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.2.2.1.2.2}
            [2.1.2](#section-2.1.2){.xref}.  [Certificate
            Authority](#name-certificate-authority){.xref}[¶](#section-toc.1-1.2.2.1.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [CA Certificate
        Distribution](#name-ca-certificate-distribution){.xref}[¶](#section-toc.1-1.2.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.3}
        [2.3](#section-2.3){.xref}.  [Client
        Authentication](#name-client-authentication){.xref}[¶](#section-toc.1-1.2.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.4}
        [2.4](#section-2.4){.xref}.  [Enrolment
        Authorisation](#name-enrolment-authorisation){.xref}[¶](#section-toc.1-1.2.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.5}
        [2.5](#section-2.5){.xref}.  [Certificate
        Enrolment/Renewal](#name-certificate-enrolment-renew){.xref}[¶](#section-toc.1-1.2.2.5.1){.pilcrow}

        -   ::: {#section-toc.1-1.2.2.5.2.1}
            [2.5.1](#section-2.5.1){.xref}.  [Client State
            Transitions](#name-client-state-transitions){.xref}[¶](#section-toc.1-1.2.2.5.2.1.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.2.2.6}
        [2.6](#section-2.6){.xref}.  [Certificate
        Access](#name-certificate-access){.xref}[¶](#section-toc.1-1.2.2.6.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.7}
        [2.7](#section-2.7){.xref}.  [CRL
        Access](#name-crl-access){.xref}[¶](#section-toc.1-1.2.2.7.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.8}
        [2.8](#section-2.8){.xref}.  [Certificate
        Revocation](#name-certificate-revocation){.xref}[¶](#section-toc.1-1.2.2.8.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.9}
        [2.9](#section-2.9){.xref}.  [Mandatory-to-Implement
        Functionality](#name-mandatory-to-implement-func){.xref}[¶](#section-toc.1-1.2.2.9.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [SCEP Secure Message
    Objects](#name-scep-secure-message-objects){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [SCEP Message Object
        Processing](#name-scep-message-object-process){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [SCEP
        pkiMessage](#name-scep-pkimessage){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.3.2.2.2.1}
            [3.2.1](#section-3.2.1){.xref}.  [Signed Transaction
            Attributes](#name-signed-transaction-attribut){.xref}[¶](#section-toc.1-1.3.2.2.2.1.1){.pilcrow}

            -   ::: {#section-toc.1-1.3.2.2.2.1.2.1}
                [3.2.1.1](#section-3.2.1.1){.xref}.  [transactionID](#name-transactionid){.xref}[¶](#section-toc.1-1.3.2.2.2.1.2.1.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.3.2.2.2.1.2.2}
                [3.2.1.2](#section-3.2.1.2){.xref}.  [messageType](#name-messagetype){.xref}[¶](#section-toc.1-1.3.2.2.2.1.2.2.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.3.2.2.2.1.2.3}
                [3.2.1.3](#section-3.2.1.3){.xref}.  [pkiStatus](#name-pkistatus){.xref}[¶](#section-toc.1-1.3.2.2.2.1.2.3.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.3.2.2.2.1.2.4}
                [3.2.1.4](#section-3.2.1.4){.xref}.  [failInfo and
                failInfoText](#name-failinfo-and-failinfotext){.xref}[¶](#section-toc.1-1.3.2.2.2.1.2.4.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.3.2.2.2.1.2.5}
                [3.2.1.5](#section-3.2.1.5){.xref}.  [senderNonce and
                recipientNonce](#name-sendernonce-and-recipientno){.xref}[¶](#section-toc.1-1.3.2.2.2.1.2.5.1){.pilcrow}
                :::
            :::

        -   ::: {#section-toc.1-1.3.2.2.2.2}
            [3.2.2](#section-3.2.2){.xref}.  [SCEP
            pkcsPKIEnvelope](#name-scep-pkcspkienvelope){.xref}[¶](#section-toc.1-1.3.2.2.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [SCEP pkiMessage
        types](#name-scep-pkimessage-types){.xref}[¶](#section-toc.1-1.3.2.3.1){.pilcrow}

        -   ::: {#section-toc.1-1.3.2.3.2.1}
            [3.3.1](#section-3.3.1){.xref}.  [PKCSReq/RenewalReq](#name-pkcsreq-renewalreq){.xref}[¶](#section-toc.1-1.3.2.3.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.2}
            [3.3.2](#section-3.3.2){.xref}.  [CertRep](#name-certrep){.xref}[¶](#section-toc.1-1.3.2.3.2.2.1){.pilcrow}

            -   ::: {#section-toc.1-1.3.2.3.2.2.2.1}
                [3.3.2.1](#section-3.3.2.1){.xref}.  [CertRep
                SUCCESS](#name-certrep-success){.xref}[¶](#section-toc.1-1.3.2.3.2.2.2.1.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.3.2.3.2.2.2.2}
                [3.3.2.2](#section-3.3.2.2){.xref}.  [CertRep
                FAILURE](#name-certrep-failure){.xref}[¶](#section-toc.1-1.3.2.3.2.2.2.2.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.3.2.3.2.2.2.3}
                [3.3.2.3](#section-3.3.2.3){.xref}.  [CertRep
                PENDING](#name-certrep-pending){.xref}[¶](#section-toc.1-1.3.2.3.2.2.2.3.1){.pilcrow}
                :::
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.3}
            [3.3.3](#section-3.3.3){.xref}.  [CertPoll
            (GetCertInitial)](#name-certpoll-getcertinitial){.xref}[¶](#section-toc.1-1.3.2.3.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.4}
            [3.3.4](#section-3.3.4){.xref}.  [GetCert and
            GetCRL](#name-getcert-and-getcrl){.xref}[¶](#section-toc.1-1.3.2.3.2.4.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [Degenerate certificates-only CMS
        SignedData](#name-degenerate-certificates-onl){.xref}[¶](#section-toc.1-1.3.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.5}
        [3.5](#section-3.5){.xref}.  [CA
        Capabilities](#name-ca-capabilities){.xref}[¶](#section-toc.1-1.3.2.5.1){.pilcrow}

        -   ::: {#section-toc.1-1.3.2.5.2.1}
            [3.5.1](#section-3.5.1){.xref}.  [GetCACaps HTTP Message
            Format](#name-getcacaps-http-message-form){.xref}[¶](#section-toc.1-1.3.2.5.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.5.2.2}
            [3.5.2](#section-3.5.2){.xref}.  [CA Capabilities Response
            Format](#name-ca-capabilities-response-fo){.xref}[¶](#section-toc.1-1.3.2.5.2.2.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [SCEP
    Transactions](#name-scep-transactions){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [HTTP POST and GET Message
        Formats](#name-http-post-and-get-message-f){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Get CA
        Certificate](#name-get-ca-certificate){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.4.2.2.2.1}
            [4.2.1](#section-4.2.1){.xref}.  [Get CA Certificate
            Response Message
            Format](#name-get-ca-certificate-response){.xref}[¶](#section-toc.1-1.4.2.2.2.1.1){.pilcrow}

            -   ::: {#section-toc.1-1.4.2.2.2.1.2.1}
                [4.2.1.1](#section-4.2.1.1){.xref}.  [CA Certificate
                Response Message
                Format](#name-ca-certificate-response-mes){.xref}[¶](#section-toc.1-1.4.2.2.2.1.2.1.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.4.2.2.2.1.2.2}
                [4.2.1.2](#section-4.2.1.2){.xref}.  [CA Certificate
                Chain Response Message
                Format](#name-ca-certificate-chain-respon){.xref}[¶](#section-toc.1-1.4.2.2.2.1.2.2.1){.pilcrow}
                :::
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Certificate
        Enrolment/Renewal](#name-certificate-enrolment-renewa){.xref}[¶](#section-toc.1-1.4.2.3.1){.pilcrow}

        -   ::: {#section-toc.1-1.4.2.3.2.1}
            [4.3.1](#section-4.3.1){.xref}.  [Certificate
            Enrolment/Renewal Response
            Message](#name-certificate-enrolment-renewal){.xref}[¶](#section-toc.1-1.4.2.3.2.1.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Poll for Client Initial
        Certificate](#name-poll-for-client-initial-cer){.xref}[¶](#section-toc.1-1.4.2.4.1){.pilcrow}

        -   ::: {#section-toc.1-1.4.2.4.2.1}
            [4.4.1](#section-4.4.1){.xref}.  [Polling Response Message
            Format](#name-polling-response-message-fo){.xref}[¶](#section-toc.1-1.4.2.4.2.1.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [Certificate
        Access](#name-certificate-access-2){.xref}[¶](#section-toc.1-1.4.2.5.1){.pilcrow}

        -   ::: {#section-toc.1-1.4.2.5.2.1}
            [4.5.1](#section-4.5.1){.xref}.  [Certificate Access
            Response Message
            Format](#name-certificate-access-response){.xref}[¶](#section-toc.1-1.4.2.5.2.1.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.6}
        [4.6](#section-4.6){.xref}.  [CRL
        Access](#name-crl-access-2){.xref}[¶](#section-toc.1-1.4.2.6.1){.pilcrow}

        -   ::: {#section-toc.1-1.4.2.6.2.1}
            [4.6.1](#section-4.6.1){.xref}.  [CRL Access Response
            Message
            Format](#name-crl-access-response-message){.xref}[¶](#section-toc.1-1.4.2.6.2.1.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.7}
        [4.7](#section-4.7){.xref}.  [Get Next Certificate Authority
        Certificate](#name-get-next-certificate-author){.xref}[¶](#section-toc.1-1.4.2.7.1){.pilcrow}

        -   ::: {#section-toc.1-1.4.2.7.2.1}
            [4.7.1](#section-4.7.1){.xref}.  [Get Next CA Response
            Message
            Format](#name-get-next-ca-response-messag){.xref}[¶](#section-toc.1-1.4.2.7.2.1.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [SCEP Transaction
    Examples](#name-scep-transaction-examples){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Successful
        Transactions](#name-successful-transactions){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Transactions with
        Errors](#name-transactions-with-errors){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Registration of the
        application/x-x509-ca-cert Media
        Type](#name-registration-of-the-applica){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Registration of the
        application/x-x509-ca-ra-cert Media
        Type](#name-registration-of-the-applicat){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Registration of the
        application/x-x509-next-ca-cert Media
        Type](#name-registration-of-the-applicati){.xref}[¶](#section-toc.1-1.6.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [Registration of the
        application/x-pki-message Media
        Type](#name-registration-of-the-applicatio){.xref}[¶](#section-toc.1-1.6.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [General
        Security](#name-general-security){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Use of the CA Private
        Key](#name-use-of-the-ca-private-key){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [ChallengePassword Shared Secret
        Value](#name-challengepassword-shared-se){.xref}[¶](#section-toc.1-1.7.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [Lack of Certificate Issue
        Confirmation](#name-lack-of-certificate-issue-c){.xref}[¶](#section-toc.1-1.7.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.5}
        [7.5](#section-7.5){.xref}.  [GetCACaps
        Issues](#name-getcacaps-issues){.xref}[¶](#section-toc.1-1.7.2.5.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.6}
        [7.6](#section-7.6){.xref}.  [Lack of PoP in Renewal
        Requests](#name-lack-of-pop-in-renewal-requ){.xref}[¶](#section-toc.1-1.7.2.6.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.7}
        [7.7](#section-7.7){.xref}.  [Traffic
        Monitoring](#name-traffic-monitoring){.xref}[¶](#section-toc.1-1.7.2.7.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.8}
        [7.8](#section-7.8){.xref}.  [Unnecessary
        Cryptography](#name-unnecessary-cryptography){.xref}[¶](#section-toc.1-1.7.2.8.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.9}
        [7.9](#section-7.9){.xref}.  [Use of
        SHA-1](#name-use-of-sha-1){.xref}[¶](#section-toc.1-1.7.2.9.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.10}
        [7.10](#section-7.10){.xref}. [Use of
        HTTP](#name-use-of-http){.xref}[¶](#section-toc.1-1.7.2.10.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [References](#name-references){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.8.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.8.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [Appendix A](#section-appendix.a){.xref}.  [Background
    Notes](#name-background-notes){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [](#section-appendix.b){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [](#section-appendix.c){.xref}[Author\'s
    Address](#name-authors-address){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

X.509 certificates serve as the basis for several standardised security
protocols such as [TLS](#RFC8446){.xref} \[[RFC8446](#RFC8446){.xref}\],
[S/MIME](#RFC8551){.xref} \[[RFC8551](#RFC8551){.xref}\], and
[IKE/IPsec](#RFC7296){.xref} \[[RFC7296](#RFC7296){.xref}\]. When an
X.509 certificate is issued, there typically is a need for a certificate
management protocol to enable a PKI client to request or renew a
certificate from a Certificate Authority (CA). This specification
defines a protocol, the Simple Certificate Enrolment Protocol (SCEP),
for certificate management and certificate and CRL
queries.[¶](#section-1-1){.pilcrow}

The SCEP protocol supports the following general
operations:[¶](#section-1-2){.pilcrow}

-   [CA public key
    distribution[¶](#section-1-3.1){.pilcrow}]{#section-1-3.1}
-   [Certificate enrolment and
    issue[¶](#section-1-3.2){.pilcrow}]{#section-1-3.2}
-   [Certificate renewal[¶](#section-1-3.3){.pilcrow}]{#section-1-3.3}
-   [Certificate query[¶](#section-1-3.4){.pilcrow}]{#section-1-3.4}
-   [CRL query[¶](#section-1-3.5){.pilcrow}]{#section-1-3.5}

SCEP makes extensive use of [CMS](#RFC5652){.xref}
\[[RFC5652](#RFC5652){.xref}\] and [PKCS #10](#RFC2986){.xref}
\[[RFC2986](#RFC2986){.xref}\].[¶](#section-1-4){.pilcrow}

::: {#mustshouldmay}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Conventions Used in This Document](#name-conventions-used-in-this-do){.section-name .selfRef} {#name-conventions-used-in-this-do}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-1){.pilcrow}

This document uses the Augmented Backus-Naur Form (ABNF) notation as
specified in \[[RFC5234](#RFC5234){.xref}\] for defining formal syntax
of commands. Non-terminals not defined in \[[RFC5234](#RFC5234){.xref}\]
are defined in [Section
4.1](#HTTP-GET-POST){.xref}.[¶](#section-1.1-2){.pilcrow}
:::
:::
:::
:::

::: {#overview}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [SCEP Overview](#name-scep-overview){.section-name .selfRef} {#name-scep-overview}

This section provides an overview of the functionality of
SCEP.[¶](#section-2-1){.pilcrow}

::: {#overview-entities}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [SCEP Entities](#name-scep-entities){.section-name .selfRef} {#name-scep-entities}

The entity types defined in SCEP are a client requesting a certificate
and a Certificate Authority (CA) that issues the certificate. These are
described in the following sections.[¶](#section-2.1-1){.pilcrow}

::: {#overview-client}
::: {#section-2.1.1 .section}
#### [2.1.1.](#section-2.1.1){.section-number .selfRef} [Client](#name-client){.section-name .selfRef} {#name-client}

A client [MUST]{.bcp14} have the following information locally
configured:[¶](#section-2.1.1-1){.pilcrow}

1.  [The CA\'s fully qualified domain name or IP
    address.[¶](#section-2.1.1-2.1){.pilcrow}]{#section-2.1.1-2.1}
2.  [Any identification and/or authorisation information required by the
    CA before a certificate will be issued, as described in [Section
    3.3.1](#PKCSReq){.xref}.[¶](#section-2.1.1-2.2){.pilcrow}]{#section-2.1.1-2.2}
3.  [The identifying information that is used for authentication of the
    CA in [Section 4.2.1](#GetCACert-resp){.xref}, typically a
    certificate
    fingerprint.[¶](#section-2.1.1-2.3){.pilcrow}]{#section-2.1.1-2.3}
:::
:::

::: {#overview-ca}
::: {#section-2.1.2 .section}
#### [2.1.2.](#section-2.1.2){.section-number .selfRef} [Certificate Authority](#name-certificate-authority){.section-name .selfRef} {#name-certificate-authority}

A SCEP CA is the entity that signs client certificates. A CA may enforce
policies and apply them to certificate requests, and it may reject a
request for any reason.[¶](#section-2.1.2-1){.pilcrow}

Since the client is expected to perform signature verification and
optionally encryption using the CA certificate, the keyUsage extension
in the CA certificate [MUST]{.bcp14} indicate that it is valid for
digitalSignature and keyEncipherment (if the key is to be used for
en/decryption) alongside the usual CA usages of keyCertSign and/or
cRLSign.[¶](#section-2.1.2-2){.pilcrow}
:::
:::
:::
:::

::: {#overview-cert-dist}
::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [CA Certificate Distribution](#name-ca-certificate-distribution){.section-name .selfRef} {#name-ca-certificate-distribution}

If the CA certificate(s) have not previously been acquired by the client
through some other means, the client [MUST]{.bcp14} retrieve them before
any PKI operation ([Section 3](#message-obj){.xref}) can be started.
Since no public key has yet been exchanged between the client and the
CA, the messages cannot be secured using CMS, and the CA certificate
request and response data is instead transferred in the
clear.[¶](#section-2.2-1){.pilcrow}

If an intermediate CA is in use, a certificates-only CMS SignedData
message with a certificate chain consisting of all CA certificates is
returned. Otherwise, the CA certificate itself is
returned.[¶](#section-2.2-2){.pilcrow}

The CA certificate [MAY]{.bcp14} be provided out of band to the client.
Alternatively, the CA certificate fingerprint [MAY]{.bcp14} be used to
authenticate a CA certificate distributed by the GetCACert response
([Section 4.2](#GetCACert){.xref}) or via [HTTP certificate-store
access](#RFC4387){.xref} \[[RFC4387](#RFC4387){.xref}\]. The fingerprint
is created by calculating a SHA-256 hash over the whole CA certificate.
(For legacy reasons, a SHA-1 hash may be used by some
implementations.)[¶](#section-2.2-3){.pilcrow}

After the client gets the CA certificate, it [SHOULD]{.bcp14}
authenticate it in some manner unless this is deemed unnecessary, for
example, because the device is being provisioned inside a trusted
environment. For example, the client could compare the certificate\'s
fingerprint with locally configured, out-of-band distributed,
identifying information, or by some equivalent means such as a direct
comparison with a locally stored copy of the
certificate.[¶](#section-2.2-4){.pilcrow}

Intermediate CA certificates, if any, are signed by a higher-level CA,
so there is no need to authenticate them against the out-of-band data.
Since intermediate CA certificates are rolled over more frequently than
long-lived top-level CA certificates, clients [MUST]{.bcp14} verify
intermediate-level CA certificates before use during protocol exchanges
in case the intermediate CA certificate has expired or otherwise been
invalidated.[¶](#section-2.2-5){.pilcrow}

When a CA certificate expires, certificates that have been signed by it
may no longer be regarded as valid. CA key rollover provides a mechanism
by which the CA can distribute a new CA certificate that will be valid
in the future once the current certificate has expired. This is done via
the GetNextCACert message ([Section
4.7](#get-next-CA){.xref}).[¶](#section-2.2-6){.pilcrow}
:::
:::

::: {#overview-req-auth}
::: {#section-2.3 .section}
### [2.3.](#section-2.3){.section-number .selfRef} [Client Authentication](#name-client-authentication){.section-name .selfRef} {#name-client-authentication}

As with every protocol that uses public-key cryptography, the
association between the public keys used in the protocol and the
identities with which they are associated must be authenticated in a
cryptographically secure manner. Communications between the client and
the CA are secured using SCEP Secure Message Objects as explained in
[Section 3](#message-obj){.xref}, which specifies how CMS is used to
encrypt and sign the data. In order to perform the signing operation,
the client uses an appropriate local
certificate:[¶](#section-2.3-1){.pilcrow}

1.  [If the client does not have an appropriate existing certificate,
    then a locally generated self-signed certificate [MUST]{.bcp14} be
    used. The keyUsage extension in the certificate [MUST]{.bcp14}
    indicate that it is valid for digitalSignature and keyEncipherment
    (if available). The self-signed certificate [SHOULD]{.bcp14} use the
    same subject name and key as in the PKCS #10 request. In this case,
    the messageType is PKCSReq (see [Section
    3.2.1.2](#messageType){.xref}).[¶](#section-2.3-2.1){.pilcrow}]{#section-2.3-2.1}
2.  [If the client already has a certificate issued by the SCEP CA, and
    the CA supports renewal (see [Section
    2.5](#overview-cert-enrol){.xref}), that certificate
    [SHOULD]{.bcp14} be used. In this case, the messageType is
    RenewalReq (see [Section
    3.2.1.2](#messageType){.xref}).[¶](#section-2.3-2.2){.pilcrow}]{#section-2.3-2.2}
3.  [Alternatively, if the client has no certificate issued by the SCEP
    CA but has credentials from an alternate CA, then the certificate
    issued by the alternate CA [MAY]{.bcp14} be used in a renewal
    request as described above. The SCEP CA\'s policy will determine
    whether the request can be accepted or
    not.[¶](#section-2.3-2.3){.pilcrow}]{#section-2.3-2.3}

Note that although the above text describes several different types of
operations, for historical reasons, most implementations always apply
the first one, even if an existing certificate already exists. For this
reason, support for the first case is mandatory while support for the
latter ones are optional (see [Section
2.9](#MTI){.xref}).[¶](#section-2.3-3){.pilcrow}

During the certificate-enrolment process, the client [MUST]{.bcp14} use
the selected certificate\'s key when signing the CMS envelope (see
[Section 3](#message-obj){.xref}). This certificate will be either the
self-signed one matching the PKCS #10 request or the CA-issued one used
to authorise a renewal, and it [MUST]{.bcp14} be included in the
signedData certificates field (possibly as part of a full certificate
chain). If the key being certified allows encryption, then the CA\'s
CertResp will use the same certificate\'s public key when encrypting the
response.[¶](#section-2.3-4){.pilcrow}

Note that, in the case of renewal operations, this means that the
request will be signed and authenticated with the key in the previously
issued certificate rather than the key in the PKCS #10 request, and the
response may similarly be returned encrypted with the key in the
previously issued certificate. This has security implications; see
[Section 7.6](#security-no-pop){.xref}.[¶](#section-2.3-5){.pilcrow}
:::
:::

::: {#overview-enrol-auth}
::: {#section-2.4 .section}
### [2.4.](#section-2.4){.section-number .selfRef} [Enrolment Authorisation](#name-enrolment-authorisation){.section-name .selfRef} {#name-enrolment-authorisation}

[PKCS #10](#RFC2986){.xref} \[[RFC2986](#RFC2986){.xref}\] specifies a
[PKCS #9](#RFC2985){.xref} \[[RFC2985](#RFC2985){.xref}\]
challengePassword attribute to be sent as part of the enrolment request.
When utilising the challengePassword, the CA distributes a shared secret
to the client, which will be used to authenticate the request from the
client. It is [RECOMMENDED]{.bcp14} that the challengePassword be a
one-time authenticator value to limit the ability of an attacker who can
capture the authenticator from the client or CA and reuse it to request
further certificates.[¶](#section-2.4-1){.pilcrow}

Inclusion of the challengePassword by the SCEP client is
[RECOMMENDED]{.bcp14}; however, its omission allows for unauthenticated
authorisation of enrolment requests (which may, however, require manual
approval of each certificate issue if other security measures to control
issue aren\'t in place; see below). Inclusion is [OPTIONAL]{.bcp14} for
renewal requests that are authenticated by being signed with an existing
certificate. The CMS envelope protects the privacy of the
challengePassword.[¶](#section-2.4-2){.pilcrow}

A client that is performing certificate renewal as per [Section
2.5](#overview-cert-enrol){.xref} [SHOULD]{.bcp14} omit the
challengePassword but [MAY]{.bcp14} send the originally distributed
shared secret in the challengePassword attribute. The SCEP CA
[MAY]{.bcp14} authenticate the request using the challengePassword in
addition to the previously issued certificate that signs the request.
The SCEP CA [MUST NOT]{.bcp14} attempt to authenticate a client based on
a self-signed certificate unless it has been verified through
out-of-band means such as a certificate
fingerprint.[¶](#section-2.4-3){.pilcrow}

To perform the authorisation in manual mode, the client\'s request is
placed in the PENDING state until the CA operator authorises or rejects
it. Manual authorisation is used when the client has only a self-signed
certificate that hasn\'t been previously authenticated by the CA and/or
a challengePassword is not available. The SCEP CA [MAY]{.bcp14} either
reject unauthorised requests or mark them for manual authorisation
according to CA policy.[¶](#section-2.4-4){.pilcrow}
:::
:::

::: {#overview-cert-enrol}
::: {#section-2.5 .section}
### [2.5.](#section-2.5){.section-number .selfRef} [Certificate Enrolment/Renewal](#name-certificate-enrolment-renew){.section-name .selfRef} {#name-certificate-enrolment-renew}

A client starts an enrolment transaction ([Section
3.3.1](#PKCSReq){.xref}) by creating a certificate request using PKCS
#10 and sends the request to the CA enveloped using CMS ([Section
3](#message-obj){.xref}).[¶](#section-2.5-1){.pilcrow}

If the CA supports certificate renewal and the CA policy permits, then a
new certificate with new validity dates can be issued, even though the
old one is still valid. To renew an existing certificate, the client
uses the RenewalReq message (see [Section
3.3](#pkiMessage-types){.xref}) and signs it with the existing client
certificate. The client [SHOULD]{.bcp14} use a new keypair when
requesting a new certificate but [MAY]{.bcp14} request a new certificate
using the old keypair.[¶](#section-2.5-2){.pilcrow}

If the CA returns a CertRep message ([Section 3.3.2](#CertRep){.xref})
with status set to PENDING, the client enters into polling mode by
periodically sending a CertPoll message ([Section
3.3.3](#CertPoll){.xref}) to the CA until the CA operator completes the
manual authentication (approving or denying the request). The frequency
of the polling operation is a CA/client configuration issue and may
range from seconds or minutes when the issue process is automatic but
not instantaneous, through to hours or days if the certificate-issue
operation requires manual approval.[¶](#section-2.5-3){.pilcrow}

If polling mode is being used, then the client will send a single
PKCSReq/RenewalReq message ([Section 3.3.1](#PKCSReq){.xref}), followed
by 0 or more CertPoll messages ([Section 3.3.3](#CertPoll){.xref}). The
CA will, in return, send 0 or more CertRep messages ([Section
3.3.2](#CertRep){.xref}) with status set to PENDING in response to
CertPolls, followed by a single CertRep message ([Section
3.3.2](#CertRep){.xref}) with status set to either SUCCESS or
FAILURE.[¶](#section-2.5-4){.pilcrow}

::: {#overview-client-state}
::: {#section-2.5.1 .section}
#### [2.5.1.](#section-2.5.1){.section-number .selfRef} [Client State Transitions](#name-client-state-transitions){.section-name .selfRef} {#name-client-state-transitions}

The client state transitions during the SCEP process are indicated in
[Figure 1](#state-diagram){.xref}.[¶](#section-2.5.1-1){.pilcrow}

[]{#name-state-transition-diagram}

::: {#state-diagram}
::: {#section-2.5.1-2.1 .artwork .art-text .alignLeft}
                                    CertPoll
                                  +-----<----+
                                  |          |
                                  |          | CertRep(PENDING)
                                  |          |
    [CERT-NONEXISTENT] ------> [CERT-REQ-PENDING] --------> [CERT-ISSUED]
          ^            PKCSReq    |           CertRep(SUCCESS)
          |          RenewalReq   |
          |                       |
          +-----------------------+
          CertRep(FAILURE) or
          Max-time/max-polls exceeded
:::

[Figure 1](#figure-1){.selfRef}: [State Transition
Diagram](#name-state-transition-diagram){.selfRef}
:::

The certificate-issue process starts at state CERT-NONEXISTENT. Sending
a PKCSReq/RenewalReq message changes the state to
CERT-REQ-PENDING.[¶](#section-2.5.1-3){.pilcrow}

If the CA returns a CertRep message with pkiStatus set to SUCCESS, then
the state changes to CERT-ISSUED.[¶](#section-2.5.1-4){.pilcrow}

If the CA returns a CertRep message with pkiStatus set to FAILURE or
there is no response, then the state reverts back to
CERT-NONEXISTENT.[¶](#section-2.5.1-5){.pilcrow}

If the CA returns a CertRep message with pkiStatus set to PENDING, then
the client will keep polling by sending a CertPoll message until either
a CertRep message with status set to SUCCESS or FAILURE is received, a
timeout occurs, or the maximum number of polls has been
exceeded.[¶](#section-2.5.1-6){.pilcrow}

[Figure 2](#automatic){.xref} shows a successful transaction in
automatic mode[¶](#section-2.5.1-7){.pilcrow}

[]{#name-automatic-mode}

::: {#automatic}
::: {#section-2.5.1-8.1 .artwork .art-text .alignLeft}
        CLIENT                              CA SERVER

    PKCSReq: PKI cert. enrolment message
    --------------------------------> CertRep: pkiStatus = SUCCESS
                                      Certificate attached
                                      <------------------------------
    Receive issued certificate.
:::

[Figure 2](#figure-2){.selfRef}: [Automatic
Mode](#name-automatic-mode){.selfRef}
:::

[Figure 3](#manual){.xref} shows a successful transaction in manual
mode:[¶](#section-2.5.1-9){.pilcrow}

[]{#name-manual-mode}

::: {#manual}
::: {#section-2.5.1-10.1 .artwork .art-text .alignLeft}
        CLIENT                              CA SERVER

    PKCSReq: PKI cert. enrolment message
    --------------------------------> CertRep: pkiStatus = PENDING
                                      <------------------------------
    CertPoll: Polling message
    --------------------------------> CertRep: pkiStatus = PENDING
                                      <------------------------------
    ................ <Manual identity authentication> ...............

    CertPoll: Polling message
    --------------------------------> CertRep: pkiStatus = SUCCESS
                                      Certificate attached
                                      <------------------------------
    Receive issued certificate.
:::

[Figure 3](#figure-3){.selfRef}: [Manual
Mode](#name-manual-mode){.selfRef}
:::
:::
:::
:::
:::

::: {#overview-cert-access}
::: {#section-2.6 .section}
### [2.6.](#section-2.6){.section-number .selfRef} [Certificate Access](#name-certificate-access){.section-name .selfRef} {#name-certificate-access}

A certificate query message is defined for clients to retrieve a copy of
their own certificate from the CA. It allows clients that do not store
their certificates locally to obtain a copy when needed. This
functionality is not intended to provide a general-purpose
certificate-access service, which may be achieved instead via [HTTP
certificate-store access](#RFC4387){.xref}
\[[RFC4387](#RFC4387){.xref}\] or Lightweight Directory Access Protocol
(LDAP).[¶](#section-2.6-1){.pilcrow}

To retrieve a certificate from the CA, a client sends a request
consisting of the certificate\'s issuer name and serial number. This
assumes that the client has saved the issuer name and the serial number
of the issued certificate from the previous enrolment transaction. The
transaction to retrieve a certificate consists of one GetCert ([Section
3.3.4](#GetCertCRL){.xref}) message and one CertRep ([Section
3.3.2](#CertRep){.xref}) message, as shown in [Figure
4](#retrieve){.xref}.[¶](#section-2.6-2){.pilcrow}

[]{#name-retrieving-a-certificate}

::: {#retrieve}
::: {#section-2.6-3.1 .artwork .art-text .alignLeft}
       CLIENT                               CA SERVER

    GetCert: PKI certificate query message
    -------------------------------> CertRep: pkiStatus = SUCCESS
                                     Certificate attached
                                     <-----------------------------
    Receive the certificate.
:::

[Figure 4](#figure-4){.selfRef}: [Retrieving a
Certificate](#name-retrieving-a-certificate){.selfRef}
:::
:::
:::

::: {#overview-CRL-access}
::: {#section-2.7 .section}
### [2.7.](#section-2.7){.section-number .selfRef} [CRL Access](#name-crl-access){.section-name .selfRef} {#name-crl-access}

SCEP clients [MAY]{.bcp14} request a CRL via one of three
methods:[¶](#section-2.7-1){.pilcrow}

1.  [If the CA supports the [CRL Distribution Points (CRLDPs)
    extension](#RFC5280){.xref} \[[RFC5280](#RFC5280){.xref}\] in issued
    certificates, then the CRL [MAY]{.bcp14} be retrieved via the
    mechanism specified in the
    CRLDP.[¶](#section-2.7-2.1){.pilcrow}]{#section-2.7-2.1}
2.  [If the CA supports [HTTP certificate-store access](#RFC4387){.xref}
    \[[RFC4387](#RFC4387){.xref}\], then the CRL [MAY]{.bcp14} be
    retrieved via the [AuthorityInfoAcces](#RFC5280){.xref}
    \[[RFC5280](#RFC5280){.xref}\] location specified in the
    certificate.[¶](#section-2.7-2.2){.pilcrow}]{#section-2.7-2.2}
3.  [Only if the CA does not support CRLDPs or HTTP access should a CRL
    query be composed by creating a GetCRL message consisting of the
    issuer name and serial number from the certificate whose revocation
    status is being
    queried.[¶](#section-2.7-2.3){.pilcrow}]{#section-2.7-2.3}

The message is sent to the SCEP CA in the same way as the other SCEP
requests. The transaction to retrieve a CRL consists of one GetCRL PKI
message and one CertRep PKI message, which contains only the CRL (no
certificates) in a degenerate certificates-only CMS SignedData message
([Section 3.4](#certs-only){.xref}), as shown in [Figure
5](#retrieve-CRL){.xref}.[¶](#section-2.7-3){.pilcrow}

[]{#name-retrieving-a-crl}

::: {#retrieve-CRL}
::: {#section-2.7-4.1 .artwork .art-text .alignLeft}
           CLIENT                           CA SERVER

       GetCRL: PKI CRL query message
    ---------------------------------->
                                      CertRep: CRL attached
                                      <-----------------------------
    Receive the CRL
:::

[Figure 5](#figure-5){.selfRef}: [Retrieving a
CRL](#name-retrieving-a-crl){.selfRef}
:::
:::
:::

::: {#overview-cert-rev}
::: {#section-2.8 .section}
### [2.8.](#section-2.8){.section-number .selfRef} [Certificate Revocation](#name-certificate-revocation){.section-name .selfRef} {#name-certificate-revocation}

SCEP does not specify a method to request certificate revocation. In
order to revoke a certificate, the client must contact the CA using a
non-SCEP-defined mechanism.[¶](#section-2.8-1){.pilcrow}
:::
:::

::: {#MTI}
::: {#section-2.9 .section}
### [2.9.](#section-2.9){.section-number .selfRef} [Mandatory-to-Implement Functionality](#name-mandatory-to-implement-func){.section-name .selfRef} {#name-mandatory-to-implement-func}

At a minimum, all SCEP implementations compliant with this specification
[MUST]{.bcp14} support [GetCACaps](#CA-caps-HTTP){.xref} ([Section
3.5.1](#CA-caps-HTTP){.xref}), [GetCACert](#GetCACert){.xref} ([Section
4.2](#GetCACert){.xref}), [PKCSReq](#PKCSReq){.xref} ([Section
3.3.1](#PKCSReq){.xref}) (and its associated response messages),
communication of binary data via [HTTP POST](#HTTP-GET-POST){.xref}
([Section 4.1](#HTTP-GET-POST){.xref}), and the
[AES128-CBC](#AES){.xref} \[[AES](#AES){.xref}\] and
[SHA-256](#SHA2){.xref} \[[SHA2](#SHA2){.xref}\] algorithms to secure
[pkiMessages](#pkiMessage){.xref} ([Section
3.2](#pkiMessage){.xref}).[¶](#section-2.9-1){.pilcrow}

For historical reasons, implementations [MAY]{.bcp14} support
communications of binary data via [HTTP GET](#HTTP-GET-POST){.xref}
([Section 4.1](#HTTP-GET-POST){.xref}), and the triple DES-CBC and SHA-1
algorithms to secure [pkiMessages](#pkiMessage){.xref} ([Section
3.2](#pkiMessage){.xref}). Implementations [MUST NOT]{.bcp14} support
the obsolete and/or insecure single DES and MD5 algorithms used in
earlier versions of this specification, since the unsecured nature of
GetCACaps means that an in-path attacker can trivially roll back the
encryption used to these insecure algorithms; see [Section
7.5](#security-getcacaps){.xref}.[¶](#section-2.9-2){.pilcrow}
:::
:::
:::
:::

::: {#message-obj}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [SCEP Secure Message Objects](#name-scep-secure-message-objects){.section-name .selfRef} {#name-scep-secure-message-objects}

CMS is a general enveloping mechanism that enables both signed and
encrypted transmission of arbitrary data. SCEP messages that require
confidentiality use two layers of CMS, as shown using ASN.1-like
pseudocode in [Figure 6](#cms-layering){.xref}. By applying both
enveloping and signing transformations, the SCEP message is protected
both for the integrity of its end-to-end transaction information and the
confidentiality of its information portion.[¶](#section-3-1){.pilcrow}

[]{#name-cms-layering}

::: {#cms-layering}
::: {#section-3-2.1}
``` {.sourcecode .lang-pseudocode}
pkiMessage {
  contentType = signedData { pkcs-7 2 },
  content {
    digestAlgorithms,
    encapsulatedContentInfo {
      eContentType = data { pkcs-7 1 },
      eContent {           -- pkcsPKIEnvelope, optional
        contentType = envelopedData { pkcs-7 3 },
        content {
          recipientInfo,
          encryptedContentInfo {
            contentType = data { pkcs-7 1 },
            contentEncrAlgorithm,
            encryptedContent {
              messageData  -- Typically PKCS #10 request
              }
            }
          }
        }
      },
    certificates,          -- Optional
    crls,                  -- Optional
    signerInfo {
      signedAttrs {
        transactionID,
        messageType,
        pkiStatus,
        failInfo,          -- Optional
        senderNonce / recipientNonce,
        },
      signature
      }
    }
  }
```
:::

[Figure 6](#figure-6){.selfRef}: [CMS
Layering](#name-cms-layering){.selfRef}
:::

When a particular SCEP message carries data, this data is carried in the
messageData. CertRep messages will lack any signed content and consist
only of a pkcsPKIEnvelope ([Section
3.2.2](#pkcsPKIEnvelope){.xref}).[¶](#section-3-3){.pilcrow}

The remainder of this document will refer only to \"messageData\", but
it is understood to always be encapsulated in the pkcsPKIEnvelope
([Section 3.2.2](#pkcsPKIEnvelope){.xref}). The format of the data in
the messageData is defined by the messageType attribute (see [Section
3.2](#pkiMessage){.xref}) of the SignedData. If there is no messageData
to be transmitted, the entire pkcsPKIEnvelope [MUST]{.bcp14} be
omitted.[¶](#section-3-4){.pilcrow}

Samples of SCEP messages are available through the [JSCEP
project](#JSCEP){.xref} \[[JSCEP](#JSCEP){.xref}\] in the src/samples
directory.[¶](#section-3-5){.pilcrow}

::: {#message-processing}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [SCEP Message Object Processing](#name-scep-message-object-process){.section-name .selfRef} {#name-scep-message-object-process}

Creating a SCEP message consists of several stages. The content to be
conveyed (in other words, the messageData) is first encrypted, and the
encrypted content is then signed.[¶](#section-3.1-1){.pilcrow}

The form of encryption to be applied depends on the capabilities of the
recipient\'s public key. If the key is encryption capable (for example,
RSA), then the messageData is encrypted using the recipient\'s public
key with the CMS KeyTransRecipientInfo mechanism. If the key is not
encryption capable (for example, DSA or ECDSA), then the messageData is
encrypted using the challengePassword with the CMS PasswordRecipientInfo
mechanism.[¶](#section-3.1-2){.pilcrow}

Once the messageData has been encrypted, it is signed with the sender\'s
public key. This completes the SCEP message, which is then sent to the
recipient.[¶](#section-3.1-3){.pilcrow}

Note that some early implementations of this specification dealt with
keys that were not encryption capable by omitting the encryption stage,
based on the text in [Section 3](#message-obj){.xref} that indicated
that \"the EnvelopedData is omitted\". This alternative processing
mechanism [SHOULD NOT]{.bcp14} be used since it exposes in cleartext the
challengePassword used to authorise the certificate
issue.[¶](#section-3.1-4){.pilcrow}
:::
:::

::: {#pkiMessage}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [SCEP pkiMessage](#name-scep-pkimessage){.section-name .selfRef} {#name-scep-pkimessage}

The basic building block of all secured SCEP messages is the SCEP
pkiMessage. It consists of a CMS SignedData content type. The following
restrictions apply:[¶](#section-3.2-1){.pilcrow}

-   [The eContentType in encapsulatedContentInfo [MUST]{.bcp14} be data
    ({pkcs-7 1}).[¶](#section-3.2-2.1){.pilcrow}]{#section-3.2-2.1}
-   [The signed content, if present (FAILURE and PENDING CertRep
    messages will lack any signed content), [MUST]{.bcp14} be a
    pkcsPKIEnvelope ([Section 3.2.2](#pkcsPKIEnvelope){.xref}) and
    [MUST]{.bcp14} match the messageType
    attribute.[¶](#section-3.2-2.2){.pilcrow}]{#section-3.2-2.2}
-   [The SignerInfo [MUST]{.bcp14} contain a set of
    authenticatedAttributes ([Section
    3.2.1](#signed-attrs){.xref}).[¶](#section-3.2-2.3){.pilcrow}]{#section-3.2-2.3}

::: {#signed-attrs}
::: {#section-3.2.1 .section}
#### [3.2.1.](#section-3.2.1){.section-number .selfRef} [Signed Transaction Attributes](#name-signed-transaction-attribut){.section-name .selfRef} {#name-signed-transaction-attribut}

At a minimum, all messages [MUST]{.bcp14} contain the following
authenticatedAttributes:[¶](#section-3.2.1-1){.pilcrow}

-   [A transactionID attribute (see [Section
    3.2.1.1](#transactionID){.xref}).[¶](#section-3.2.1-2.1){.pilcrow}]{#section-3.2.1-2.1}
-   [A messageType attribute (see [Section
    3.2.1.2](#messageType){.xref}).[¶](#section-3.2.1-2.2){.pilcrow}]{#section-3.2.1-2.2}
-   [A fresh senderNonce attribute (see [Section
    3.2.1.5](#nonces){.xref}). However, note the comment about
    senderNonces and polling in [Section
    3.3.2](#CertRep){.xref}[¶](#section-3.2.1-2.3){.pilcrow}]{#section-3.2.1-2.3}
-   [Any attributes required by
    CMS.[¶](#section-3.2.1-2.4){.pilcrow}]{#section-3.2.1-2.4}

If the message is a CertRep, it [MUST]{.bcp14} also include the
following authenticatedAttributes:[¶](#section-3.2.1-3){.pilcrow}

-   [A pkiStatus attribute (see [Section
    3.2.1.3](#pkiStatus){.xref}).[¶](#section-3.2.1-4.1){.pilcrow}]{#section-3.2.1-4.1}
-   [failInfo and optional failInfoText attributes (see [Section
    3.2.1.4](#failInfo){.xref}) if pkiStatus =
    FAILURE.[¶](#section-3.2.1-4.2){.pilcrow}]{#section-3.2.1-4.2}
-   [A recipientNonce attribute (see [Section 3.2.1.5](#nonces){.xref})
    copied from the senderNonce in the request that this is a response
    to.[¶](#section-3.2.1-4.3){.pilcrow}]{#section-3.2.1-4.3}

The following transaction attributes are encoded as authenticated
attributes and carried in the SignerInfo for this
SignedData.[¶](#section-3.2.1-5){.pilcrow}

[]{#name-scep-attributes}

  Attribute        Encoding          Comment
  ---------------- ----------------- -------------------------------------------------
  transactionID    PrintableString   Unique ID for this transaction as a text string
  messageType      PrintableString   Decimal value as a numeric text string
  pkiStatus        PrintableString   Decimal value as a numeric text string
  failInfo         PrintableString   Decimal value as a numeric text string
  failInfoText     UTF8String        Descriptive text for the failInfo value
  senderNonce      OCTET STRING      Random nonce as a 16-byte binary data string
  recipientNonce   OCTET STRING      Random nonce as a 16-byte binary data string

  : [Table 1](#table-1){.selfRef}: [SCEP
  Attributes](#name-scep-attributes){.selfRef}

The OIDs used for these attributes are as
follows:[¶](#section-3.2.1-7){.pilcrow}

[]{#name-scep-attribute-oids}

  Name                   ASN.1 Definition
  ---------------------- ---------------------------------------------------------
  id-VeriSign            OBJECT_IDENTIFIER ::= {2 16 US(840) 1 VeriSign(113733)}
  id-pki                 OBJECT_IDENTIFIER ::= {id-VeriSign pki(1)}
  id-attributes          OBJECT_IDENTIFIER ::= {id-pki attributes(9)}
  id-transactionID       OBJECT_IDENTIFIER ::= {id-attributes transactionID(7)}
  id-messageType         OBJECT_IDENTIFIER ::= {id-attributes messageType(2)}
  id-pkiStatus           OBJECT_IDENTIFIER ::= {id-attributes pkiStatus(3)}
  id-failInfo            OBJECT_IDENTIFIER ::= {id-attributes failInfo(4)}
  id-senderNonce         OBJECT_IDENTIFIER ::= {id-attributes senderNonce(5)}
  id-recipientNonce      OBJECT_IDENTIFIER ::= {id-attributes recipientNonce(6)}
  id-scep                OBJECT IDENTIFIER ::= {id-pkix 24}
  id-scep-failInfoText   OBJECT IDENTIFIER ::= {id-scep 1}

  : [Table 2](#table-2){.selfRef}: [SCEP Attribute
  OIDs](#name-scep-attribute-oids){.selfRef}

The attributes are detailed in the following
sections.[¶](#section-3.2.1-9){.pilcrow}

::: {#transactionID}
::: {#section-3.2.1.1 .section}
##### [3.2.1.1.](#section-3.2.1.1){.section-number .selfRef} [transactionID](#name-transactionid){.section-name .selfRef} {#name-transactionid}

A PKI operation is a transaction consisting of the messages exchanged
between a client and the CA. The transactionID is a text string provided
by the client when starting a transaction. The client [MUST]{.bcp14} use
a unique string as the transaction identifier, encoded as a
PrintableString, which [MUST]{.bcp14} be used for all PKI messages
exchanged for a given operation, such as a certificate
issue.[¶](#section-3.2.1.1-1){.pilcrow}

Note that the transactionID must be unique, but not necessarily randomly
generated. For example, it may be a value assigned by the CA to allow
the client to be identified by their transactionID, using a value such
as the client device\'s Extended Unique Identifier (EUI), Remote
Terminal Unit (RTU) ID, or a similar unique identifier. This can be
useful when the client doesn\'t have a preassigned Distinguished Name
through which the CA can identify their request \-- for example, when
enrolling Supervisory Control and Data Acquisition (SCADA)
devices.[¶](#section-3.2.1.1-2){.pilcrow}
:::
:::

::: {#messageType}
::: {#section-3.2.1.2 .section}
##### [3.2.1.2.](#section-3.2.1.2){.section-number .selfRef} [messageType](#name-messagetype){.section-name .selfRef} {#name-messagetype}

The messageType attribute specifies the type of operation performed by
the transaction. This attribute [MUST]{.bcp14} be included in all PKI
messages. The following message types are
defined:[¶](#section-3.2.1.2-1){.pilcrow}

[]{#name-scep-message-types}

::: {#scep-message-types}
  Value   Name         Description
  ------- ------------ --------------------------------------------------------------------------
  0       Reserved     
  3       CertRep      Response to certificate or CRL request.
  17      RenewalReq   PKCS #10 certificate request authenticated with an existing certificate.
  19      PKCSReq      PKCS #10 certificate request authenticated with a shared secret.
  20      CertPoll     Certificate polling in manual enrolment.
  21      GetCert      Retrieve a certificate.
  22      GetCRL       Retrieve a CRL.

  : [Table 3](#table-3){.selfRef}: [SCEP Message
  Types](#name-scep-message-types){.selfRef}
:::

Message types not defined above [MUST]{.bcp14} be treated as errors
unless their use has been negotiated through
[GetCACaps](#CA-caps-HTTP){.xref} ([Section
3.5.1](#CA-caps-HTTP){.xref}).[¶](#section-3.2.1.2-3){.pilcrow}
:::
:::

::: {#pkiStatus}
::: {#section-3.2.1.3 .section}
##### [3.2.1.3.](#section-3.2.1.3){.section-number .selfRef} [pkiStatus](#name-pkistatus){.section-name .selfRef} {#name-pkistatus}

All response messages [MUST]{.bcp14} include transaction status
information, which is defined as a pkiStatus
attribute:[¶](#section-3.2.1.3-1){.pilcrow}

[]{#name-pkistatus-attributes}

::: {#tab-pkiStatus}
  Value   Name      Description
  ------- --------- --------------------------------------------------------------------------------------------------------------------------------------------
  0       SUCCESS   Request granted.
  2       FAILURE   Request rejected. In this case, the failInfo attribute, as defined in [Section 3.2.1.4](#failInfo){.xref}, [MUST]{.bcp14} also be present.
  3       PENDING   Request pending for manual approval.

  : [Table 4](#table-4){.selfRef}: [pkiStatus
  Attributes](#name-pkistatus-attributes){.selfRef}
:::

PKI status values not defined above [MUST]{.bcp14} be treated as errors
unless their use has been negotiated through
[GetCACaps](#CA-caps-HTTP){.xref} ([Section
3.5.1](#CA-caps-HTTP){.xref}).[¶](#section-3.2.1.3-3){.pilcrow}
:::
:::

::: {#failInfo}
::: {#section-3.2.1.4 .section}
##### [3.2.1.4.](#section-3.2.1.4){.section-number .selfRef} [failInfo and failInfoText](#name-failinfo-and-failinfotext){.section-name .selfRef} {#name-failinfo-and-failinfotext}

The failInfo attribute [MUST]{.bcp14} contain one of the following
failure reasons:[¶](#section-3.2.1.4-1){.pilcrow}

[]{#name-failinfo-attributes}

::: {#tab-failInfo}
  Value   Name              Description
  ------- ----------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  0       badAlg            Unrecognised or unsupported algorithm.
  1       badMessageCheck   Integrity check (meaning signature verification of the CMS message) failed.
  2       badRequest        Transaction not permitted or supported.
  3       badTime           The signingTime attribute from the CMS authenticatedAttributes was not sufficiently close to the system time. This condition may occur if the CA is concerned about replays of old messages.
  4       badCertId         No certificate could be identified matching the provided criteria.

  : [Table 5](#table-5){.selfRef}: [failInfo
  Attributes](#name-failinfo-attributes){.selfRef}
:::

Failure reasons not defined above [MUST]{.bcp14} be treated as errors
unless their use has been negotiated through
[GetCACaps](#CA-caps-HTTP){.xref} ([Section
3.5.1](#CA-caps-HTTP){.xref}).[¶](#section-3.2.1.4-3){.pilcrow}

The failInfoText is a free-form UTF-8 text string that provides further
information in the case of pkiStatus = FAILURE. In particular, it may be
used to provide details on why a certificate request was not granted
that go beyond what\'s provided by the near-universal failInfo =
badRequest status. Since this is a free-form text string intended for
interpretation by humans, implementations [SHOULD NOT]{.bcp14} assume
that it has any type of machine-processable
content.[¶](#section-3.2.1.4-4){.pilcrow}
:::
:::

::: {#nonces}
::: {#section-3.2.1.5 .section}
##### [3.2.1.5.](#section-3.2.1.5){.section-number .selfRef} [senderNonce and recipientNonce](#name-sendernonce-and-recipientno){.section-name .selfRef} {#name-sendernonce-and-recipientno}

The senderNonce and recipientNonce attributes are each a 16-byte random
number generated for each transaction. These are intended to prevent
replay attacks.[¶](#section-3.2.1.5-1){.pilcrow}

When a sender sends a PKI message to a recipient, a fresh senderNonce
[MUST]{.bcp14} be included in the message. The recipient [MUST]{.bcp14}
copy the senderNonce into the recipientNonce of the reply as a proof of
liveliness. The original sender [MUST]{.bcp14} verify that the
recipientNonce of the reply matches the senderNonce it sent in the
request. If the nonce does not match, then the message [MUST]{.bcp14} be
rejected.[¶](#section-3.2.1.5-2){.pilcrow}

Note that since SCEP exchanges consist of a single request followed by a
single response, the use of distinct sender and recipient nonces is
redundant, since the client sends a nonce in its request and the CA
responds with the same nonce in its reply. In effect, there\'s just a
single nonce, identified as senderNonce in the client\'s request and
recipientNonce in the CA\'s reply.[¶](#section-3.2.1.5-3){.pilcrow}
:::
:::
:::
:::

::: {#pkcsPKIEnvelope}
::: {#section-3.2.2 .section}
#### [3.2.2.](#section-3.2.2){.section-number .selfRef} [SCEP pkcsPKIEnvelope](#name-scep-pkcspkienvelope){.section-name .selfRef} {#name-scep-pkcspkienvelope}

The information portion of a SCEP message is carried inside an
EnvelopedData content type, as defined in CMS, with the following
restrictions:[¶](#section-3.2.2-1){.pilcrow}

-   [contentType in encryptedContentInfo [MUST]{.bcp14} be data ({pkcs-7
    1}).[¶](#section-3.2.2-2.1){.pilcrow}]{#section-3.2.2-2.1}
-   [encryptedContent [MUST]{.bcp14} be the SCEP message being
    transported (see [Section 4](#SCEP-trans){.xref}) and [MUST]{.bcp14}
    match the messageType authenticated Attribute in the
    pkiMessage.[¶](#section-3.2.2-2.2){.pilcrow}]{#section-3.2.2-2.2}
:::
:::
:::
:::

::: {#pkiMessage-types}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [SCEP pkiMessage types](#name-scep-pkimessage-types){.section-name .selfRef} {#name-scep-pkimessage-types}

All of the messages in this section are pkiMessages ([Section
3.2](#pkiMessage){.xref}), where the type of the message [MUST]{.bcp14}
be specified in the \"messageType\" authenticated Attribute. Each
section defines a valid message type, the corresponding messageData
formats, and mandatory authenticated attributes for that
type.[¶](#section-3.3-1){.pilcrow}

::: {#PKCSReq}
::: {#section-3.3.1 .section}
#### [3.3.1.](#section-3.3.1){.section-number .selfRef} [PKCSReq/RenewalReq](#name-pkcsreq-renewalreq){.section-name .selfRef} {#name-pkcsreq-renewalreq}

The messageData for this type consists of a PKCS #10 Certificate
Request. The certificate request [MUST]{.bcp14} contain at least the
following items:[¶](#section-3.3.1-1){.pilcrow}

-   [The subject Distinguished
    Name.[¶](#section-3.3.1-2.1){.pilcrow}]{#section-3.3.1-2.1}
-   [The subject public
    key.[¶](#section-3.3.1-2.2){.pilcrow}]{#section-3.3.1-2.2}
-   [For a PKCSReq, if authorisation based on a shared secret is being
    used, a challengePassword
    attribute.[¶](#section-3.3.1-2.3){.pilcrow}]{#section-3.3.1-2.3}

In addition, the message must contain the authenticatedAttributes
specified in [Section
3.2.1](#signed-attrs){.xref}.[¶](#section-3.3.1-3){.pilcrow}
:::
:::

::: {#CertRep}
::: {#section-3.3.2 .section}
#### [3.3.2.](#section-3.3.2){.section-number .selfRef} [CertRep](#name-certrep){.section-name .selfRef} {#name-certrep}

The messageData for this type consists of a degenerate certificates-only
CMS SignedData message ([Section 3.4](#certs-only){.xref}). The exact
content required for the reply depends on the type of request that this
message is a response to. The request types are detailed in Sections
[3.3.2.1](#CertRep-success){.xref} and [4](#SCEP-trans){.xref}. In
addition, the message must contain the authenticatedAttributes specified
in [Section 3.2.1](#signed-attrs){.xref}.[¶](#section-3.3.2-1){.pilcrow}

Earlier draft versions of this specification required that this message
include a senderNonce alongside the recipientNonce, which was to be used
to chain to subsequent polling operations. However, if a single message
was lost during the potentially extended interval over which polling
could take place (see [Section 5](#state-trans){.xref} for an example of
this), then if the implementation were to enforce this requirement, the
overall transaction would fail, even though nothing had actually gone
wrong. Because of this issue, implementations mostly ignored the
requirement to either carry this nonce over to subsequent polling
messages or verify its presence. More recent versions of the
specification no longer require the chaining of nonces across polling
operations.[¶](#section-3.3.2-2){.pilcrow}

::: {#CertRep-success}
::: {#section-3.3.2.1 .section}
##### [3.3.2.1.](#section-3.3.2.1){.section-number .selfRef} [CertRep SUCCESS](#name-certrep-success){.section-name .selfRef} {#name-certrep-success}

When the pkiStatus attribute is set to SUCCESS, the messageData for this
message consists of a degenerate certificates-only CMS SignedData
message ([Section 3.4](#certs-only){.xref}). The content of this
degenerate certificates-only SignedData message depends on what the
original request was, as outlined in [Table
6](#success){.xref}.[¶](#section-3.3.2.1-1){.pilcrow}

[]{#name-certrep-response-types}

::: {#success}
  Request-type   Reply-contents
  -------------- -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PKCSReq        The reply [MUST]{.bcp14} contain at least the issued certificate in the certificates field of the SignedData. The reply [MAY]{.bcp14} contain additional certificates, but the issued certificate [MUST]{.bcp14} be the leaf certificate.
  RenewalReq     Same as PKCSReq
  CertPoll       Same as PKCSReq
  GetCert        The reply [MUST]{.bcp14} contain at least the requested certificate in the certificates field of the SignedData. The reply [MAY]{.bcp14} contain additional certificates, but the requested certificate [MUST]{.bcp14} be the leaf certificate.
  GetCRL         The reply [MUST]{.bcp14} contain the CRL in the crls field of the SignedData.

  : [Table 6](#table-6){.selfRef}: [CertRep Response
  Types](#name-certrep-response-types){.selfRef}
:::
:::
:::

::: {#CertRep-failure}
::: {#section-3.3.2.2 .section}
##### [3.3.2.2.](#section-3.3.2.2){.section-number .selfRef} [CertRep FAILURE](#name-certrep-failure){.section-name .selfRef} {#name-certrep-failure}

When the pkiStatus attribute is set to FAILURE, the reply [MUST]{.bcp14}
also contain a failInfo ([Section 3.2.1.4](#failInfo){.xref}) attribute
set to the appropriate error condition describing the failure. The reply
[MAY]{.bcp14} also contain a failInfoText attribute providing extended
details on why the operation failed, typically to expand on the catchall
failInfo = badRequest status. The pkcsPKIEnvelope ([Section
3.2.2](#pkcsPKIEnvelope){.xref}) [MUST]{.bcp14} be
omitted.[¶](#section-3.3.2.2-1){.pilcrow}
:::
:::

::: {#CertRep-pending}
::: {#section-3.3.2.3 .section}
##### [3.3.2.3.](#section-3.3.2.3){.section-number .selfRef} [CertRep PENDING](#name-certrep-pending){.section-name .selfRef} {#name-certrep-pending}

When the pkiStatus attribute is set to PENDING, the pkcsPKIEnvelope
([Section 3.2.2](#pkcsPKIEnvelope){.xref}) [MUST]{.bcp14} be
omitted.[¶](#section-3.3.2.3-1){.pilcrow}
:::
:::
:::
:::

::: {#CertPoll}
::: {#section-3.3.3 .section}
#### [3.3.3.](#section-3.3.3){.section-number .selfRef} [CertPoll (GetCertInitial)](#name-certpoll-getcertinitial){.section-name .selfRef} {#name-certpoll-getcertinitial}

This message is used for certificate polling. For unknown reasons, it
was referred to as \"GetCertInitial\" in earlier draft versions of this
specification. The messageData for this type consists of an
IssuerAndSubject:[¶](#section-3.3.3-1){.pilcrow}

::: {#section-3.3.3-2}
``` sourcecode
issuerAndSubject ::= SEQUENCE {
    issuer     Name,
    subject    Name
    }
```

[¶](#section-3.3.3-2){.pilcrow}
:::

The issuer is set to the subjectName of the CA (in other words, the
intended issuerName of the certificate that\'s being requested). The
subject is set to the subjectName used when requesting the
certificate.[¶](#section-3.3.3-3){.pilcrow}

Note that both of these fields are redundant; the CA is identified by
the recipientInfo in the pkcsPKIEnvelope (or in most cases, simply by
the server that the message is being sent to), and the
client/transaction being polled is identified by the transactionID. Both
of these fields can be processed by the CA without going through the
cryptographically expensive process of unwrapping and processing the
issuerAndSubject. For this reason, implementations [SHOULD]{.bcp14}
assume that the polling operation will be controlled by the
recipientInfo and transactionID rather than the contents of the
messageData. In addition, the message must contain the
authenticatedAttributes specified in [Section
3.2.1](#signed-attrs){.xref}.[¶](#section-3.3.3-4){.pilcrow}
:::
:::

::: {#GetCertCRL}
::: {#section-3.3.4 .section}
#### [3.3.4.](#section-3.3.4){.section-number .selfRef} [GetCert and GetCRL](#name-getcert-and-getcrl){.section-name .selfRef} {#name-getcert-and-getcrl}

The messageData for these types consist of an IssuerAndSerialNumber, as
defined in CMS, that uniquely identifies the certificate being
requested, either the certificate itself for GetCert or its revocation
status via a CRL for GetCRL. In addition, the message must contain the
authenticatedAttributes specified in [Section
3.2.1](#signed-attrs){.xref}.[¶](#section-3.3.4-1){.pilcrow}

These message types, while included here for completeness, apply
unnecessary cryptography and messaging overhead to the simple task of
transferring a certificate or CRL (see [Section
7.8](#security-unnecessary){.xref}). Implementations [SHOULD]{.bcp14}
prefer [HTTP certificate-store access](#RFC4387){.xref}
\[[RFC4387](#RFC4387){.xref}\] or LDAP over the use of these
messages.[¶](#section-3.3.4-2){.pilcrow}
:::
:::
:::
:::

::: {#certs-only}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [Degenerate certificates-only CMS SignedData](#name-degenerate-certificates-onl){.section-name .selfRef} {#name-degenerate-certificates-onl}

CMS includes a degenerate case of the SignedData content type in which
there are no signers. The use of such a degenerate case is to
disseminate certificates and CRLs. For SCEP, the content field of the
ContentInfo value of a degenerate certificates-only SignedData
[MUST]{.bcp14} be omitted. When carrying certificates, the certificates
are included in the certificates field of the SignedData. When carrying
a CRL, the CRL is included in the crls field of the
SignedData.[¶](#section-3.4-1){.pilcrow}
:::
:::

::: {#CA-caps}
::: {#section-3.5 .section}
### [3.5.](#section-3.5){.section-number .selfRef} [CA Capabilities](#name-ca-capabilities){.section-name .selfRef} {#name-ca-capabilities}

In order to provide support for future enhancements to the protocol, CAs
[MUST]{.bcp14} implement the GetCACaps message to allow clients to query
which functionality is available from the
CA.[¶](#section-3.5-1){.pilcrow}

::: {#CA-caps-HTTP}
::: {#section-3.5.1 .section}
#### [3.5.1.](#section-3.5.1){.section-number .selfRef} [GetCACaps HTTP Message Format](#name-getcacaps-http-message-form){.section-name .selfRef} {#name-getcacaps-http-message-form}

This message requests capabilities from a CA, with the format as
described in [Section
4.1](#HTTP-GET-POST){.xref}:[¶](#section-3.5.1-1){.pilcrow}

::: {#section-3.5.1-2}
``` sourcecode
"GET" SP SCEPPATH "?operation=GetCACaps" SP HTTP-version CRLF
```

[¶](#section-3.5.1-2){.pilcrow}
:::
:::
:::

::: {#CA-caps-resp}
::: {#section-3.5.2 .section}
#### [3.5.2.](#section-3.5.2){.section-number .selfRef} [CA Capabilities Response Format](#name-ca-capabilities-response-fo){.section-name .selfRef} {#name-ca-capabilities-response-fo}

The response for a GetCACaps message is a list of CA capabilities, in
plain text and in any order, separated by \<CR>\<LF> or \<LF>
characters. This specification defines the following keywords (quotation
marks are not sent):[¶](#section-3.5.2-1){.pilcrow}

[]{#name-getcacaps-response-keywords}

::: {#keywords}
  Keyword            Description
  ------------------ -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  AES                CA supports the AES128-CBC encryption algorithm.
  DES3               CA supports the triple DES-CBC encryption algorithm.
  GetNextCACert      CA supports the GetNextCACert message.
  POSTPKIOperation   CA supports PKIOPeration messages sent via HTTP POST.
  Renewal            CA supports the Renewal CA operation.
  SHA-1              CA supports the SHA-1 hashing algorithm.
  SHA-256            CA supports the SHA-256 hashing algorithm.
  SHA-512            CA supports the SHA-512 hashing algorithm.
  SCEPStandard       CA supports all mandatory-to-implement sections of the SCEP standard. This keyword implies \"AES\", \"POSTPKIOperation\", and \"SHA-256\", as well as the provisions of [Section 2.9](#MTI){.xref}.

  : [Table 7](#table-7){.selfRef}: [GetCACaps Response
  Keywords](#name-getcacaps-response-keywords){.selfRef}
:::

[Table 7](#keywords){.xref} lists all of the keywords that are defined
in this specification. A CA [MAY]{.bcp14} provide additional keywords
advertising further capabilities and functionality. A client
[MUST]{.bcp14} be able to accept and ignore any unknown keywords that
might be sent by a CA.[¶](#section-3.5.2-3){.pilcrow}

The CA [MUST]{.bcp14} use the text case specified here, but clients
[SHOULD]{.bcp14} ignore the text case when processing this message.
Clients [MUST]{.bcp14} accept the standard HTTP-style text delimited by
\<CR>\<LF> as well as the text delimited by \<LF> specified in an
earlier draft version of this
specification.[¶](#section-3.5.2-4){.pilcrow}

The client [SHOULD]{.bcp14} use SHA-256 in preference to SHA-1 hashing
and AES128-CBC in preference to triple DES-CBC if they are supported by
the CA. Although the CMS format allows any form of AES and SHA-2 to be
specified, in the interests of interoperability the de facto universal
standards of AES128-CBC and SHA-256 [SHOULD]{.bcp14} be
used.[¶](#section-3.5.2-5){.pilcrow}

Announcing some of these capabilities individually is redundant, since
they\'re required as mandatory-to-implement functionality (see [Section
2.9](#MTI){.xref}) whose presence as a whole is signalled by the
\"SCEPStandard\" capability. However, it may be useful to announce them
in order to deal with older implementations that would otherwise default
to obsolete, insecure algorithms and
mechanisms.[¶](#section-3.5.2-6){.pilcrow}

If the CA supports none of the above capabilities, it [SHOULD]{.bcp14}
return an empty message. A CA [MAY]{.bcp14} simply return an HTTP error.
A client that receives an empty message or an HTTP error
[SHOULD]{.bcp14} interpret the response as if none of the capabilities
listed are supported by the CA.[¶](#section-3.5.2-7){.pilcrow}

Note that at least one widely deployed server implementation supports
several of the above operations but doesn\'t support the GetCACaps
message to indicate that it supports them, and it will close the
connection if sent a GetCACaps message. This means that the equivalent
of GetCACaps must be performed through server fingerprinting, which can
be done using the ID string \"Microsoft-IIS\". Newer versions of the
same server, if sent a SCEP request using AES and SHA-2, will respond
with an invalid response that can\'t be decrypted, requiring the use of
3DES and SHA-1 in order to obtain a response that can be processed, even
if AES and/or SHA-2 are allegedly supported. In addition, the server
will generate CA certificates that only have one, but not both, of the
keyEncipherment and digitalSignature keyUsage flags set, requiring that
the client ignore the keyUsage flags in order to use the certificates
for SCEP.[¶](#section-3.5.2-8){.pilcrow}

The Content-type of the reply [SHOULD]{.bcp14} be \"text/plain\".
Clients [SHOULD]{.bcp14} ignore the Content-type, as older
implementations of SCEP may send various
Content-types.[¶](#section-3.5.2-9){.pilcrow}

Example:[¶](#section-3.5.2-10){.pilcrow}

::: {#section-3.5.2-11}
``` sourcecode
GET /cgi-bin/pkiclient.exe?operation=GetCACaps HTTP/1.1
```

[¶](#section-3.5.2-11){.pilcrow}
:::

might return:[¶](#section-3.5.2-12){.pilcrow}

::: {#section-3.5.2-13}
``` sourcecode
AES
GetNextCACert
POSTPKIOperation
SCEPStandard
SHA-256
```

[¶](#section-3.5.2-13){.pilcrow}
:::

This means that the CA supports modern crypto algorithms, and the
GetNextCACert message allows PKIOperation messages (PKCSReq/RenewalReq,
GetCert, CertPoll, \...) to be sent using HTTP POST and is compliant
with the final version of the SCEP
standard.[¶](#section-3.5.2-14){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#SCEP-trans}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [SCEP Transactions](#name-scep-transactions){.section-name .selfRef} {#name-scep-transactions}

This section describes the SCEP Transactions and their
[HTTP](#RFC7230){.xref} \[[RFC7230](#RFC7230){.xref}\] transport
mechanism.[¶](#section-4-1){.pilcrow}

Note that SCEP doesn\'t follow best current practices on usage of HTTP.
In particular, it recommends ignoring some media types and hard-codes
specific URI paths. Guidance on the appropriate application of HTTP in
these circumstances may be found in
\[[HTTP](#I-D.ietf-httpbis-bcp56bis){.xref}\].[¶](#section-4-2){.pilcrow}

::: {#HTTP-GET-POST}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [HTTP POST and GET Message Formats](#name-http-post-and-get-message-f){.section-name .selfRef} {#name-http-post-and-get-message-f}

SCEP uses the HTTP POST and GET methods \[[RFC7230](#RFC7230){.xref}\]
to exchange information with the CA. The following defines the ABNF
syntax of HTTP POST and GET methods sent from a client to a
CA:[¶](#section-4.1-1){.pilcrow}

::: {#section-4.1-2}
``` {.sourcecode .lang-abnf}
POSTREQUEST = "POST" SP SCEPPATH "?operation=" OPERATION
              SP HTTP-version CRLF

GETREQUEST = "GET" SP SCEPPATH "?operation=" OPERATION
             "&message=" MESSAGE SP HTTP-version CRLF
```

[¶](#section-4.1-2){.pilcrow}
:::

where:[¶](#section-4.1-3){.pilcrow}

-   [SCEPPATH is the HTTP URL path for accessing the CA. Clients
    [SHOULD]{.bcp14} set SCEPPATH to the fixed string
    \"/cgi-bin/pkiclient.exe\" unless directed to do otherwise by the
    CA.[¶](#section-4.1-4.1){.pilcrow}]{#section-4.1-4.1}
-   [OPERATION depends on the SCEP transaction and is defined in the
    following
    sections.[¶](#section-4.1-4.2){.pilcrow}]{#section-4.1-4.2}
-   [HTTP-version is the HTTP version string, which is \"HTTP/1.1\" for
    \[[RFC7230](#RFC7230){.xref}\].[¶](#section-4.1-4.3){.pilcrow}]{#section-4.1-4.3}
-   [SP and CRLF are space and carriage return/linefeed, as defined in
    \[[RFC5234](#RFC5234){.xref}\].[¶](#section-4.1-4.4){.pilcrow}]{#section-4.1-4.4}

The CA will typically ignore SCEPPATH, since it\'s unlikely to be
issuing certificates via a web server. Clients [SHOULD]{.bcp14} set
SCEPPATH to the fixed string \"/cgi-bin/pkiclient.exe\" unless directed
to do otherwise by the CA. The CA [SHOULD]{.bcp14} ignore the SCEPPATH
unless its precise format is critical to the CA\'s
operation.[¶](#section-4.1-5){.pilcrow}

Early SCEP drafts performed all communications via GET messages,
including non-idempotent ones that should have been sent via POST
messages; see \[[HTTP](#I-D.ietf-httpbis-bcp56bis){.xref}\] for details.
This has caused problems because of the way that the (supposedly)
idempotent GET interacts with caches and proxies, and because the
extremely large GET requests created by encoding CMS messages may be
truncated in transit. These issues are typically not visible when
testing on a LAN, but crop up during deployment over WANs. If the remote
CA supports POST, the CMS-encoded SCEP messages [MUST]{.bcp14} be sent
via HTTP POST instead of HTTP GET. This applies to any SCEP message
except GetCACert, GetNextCACert, and GetCACaps and avoids the need for
base64 and URL encoding that\'s required for GET messaging. The client
can verify that the CA supports SCEP messages via POST by looking for
the \"SCEPStandard\" or \"POSTPKIOperation\" capability (see [Section
3.5.2](#CA-caps-resp){.xref}).[¶](#section-4.1-6){.pilcrow}

If a client or CA uses HTTP GET and encounters HTTP-related problems
such as messages being truncated, seeing errors such as HTTP 414
(\"Request-URI too long\"), or simply having the message not
sent/received at all when standard requests to the server (for example,
via a web browser) work, then this is a symptom of the problematic use
of HTTP GET. The solution to this problem is to update the
implementation to use HTTP POST instead. In addition, when using GET,
it\'s recommended to test the implementation from as many different
network locations as possible to determine whether the use of GET will
cause problems with communications.[¶](#section-4.1-7){.pilcrow}

When using GET messages to communicate binary data, base64 encoding as
specified in [Section
4](https://www.rfc-editor.org/rfc/rfc4648#section-4){.relref} of
\[[RFC4648](#RFC4648){.xref}\] [MUST]{.bcp14} be used. The
base64-encoded data is distinct from \"base64url\" and may contain URI
reserved characters; thus, it [MUST]{.bcp14} be escaped as specified in
\[[RFC3986](#RFC3986){.xref}\] in addition to being base64 encoded.
Finally, the encoded data is inserted into the MESSAGE portion of the
HTTP GET request.[¶](#section-4.1-8){.pilcrow}
:::
:::

::: {#GetCACert}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Get CA Certificate](#name-get-ca-certificate){.section-name .selfRef} {#name-get-ca-certificate}

To get the CA certificate(s), the client sends a GetCACert message to
the CA. The OPERATION [MUST]{.bcp14} be set to \"GetCACert\". There is
no request data associated with this
message.[¶](#section-4.2-1){.pilcrow}

::: {#GetCACert-resp}
::: {#section-4.2.1 .section}
#### [4.2.1.](#section-4.2.1){.section-number .selfRef} [Get CA Certificate Response Message Format](#name-get-ca-certificate-response){.section-name .selfRef} {#name-get-ca-certificate-response}

The response for GetCACert is different between the case where the CA
directly communicates with the client during the enrolment and the case
where an intermediate CA exists and the client communicates with this CA
during the enrolment.[¶](#section-4.2.1-1){.pilcrow}

::: {#GetCACert-resp-format}
::: {#section-4.2.1.1 .section}
##### [4.2.1.1.](#section-4.2.1.1){.section-number .selfRef} [CA Certificate Response Message Format](#name-ca-certificate-response-mes){.section-name .selfRef} {#name-ca-certificate-response-mes}

If the CA does not have any intermediate CA certificates, the response
consists of a single X.509 CA certificate. The response will have a
Content-Type of
\"application/x-x509-ca-cert\".[¶](#section-4.2.1.1-1){.pilcrow}

::: {#section-4.2.1.1-2}
``` sourcecode
"Content-Type: application/x-x509-ca-cert"

<binary X.509>
```

[¶](#section-4.2.1.1-2){.pilcrow}
:::
:::
:::

::: {#GetCACertChain-resp-format}
::: {#section-4.2.1.2 .section}
##### [4.2.1.2.](#section-4.2.1.2){.section-number .selfRef} [CA Certificate Chain Response Message Format](#name-ca-certificate-chain-respon){.section-name .selfRef} {#name-ca-certificate-chain-respon}

If the CA has intermediate CA certificates, the response consists of a
degenerate certificates-only CMS SignedData message ([Section
3.4](#certs-only){.xref}) containing the certificates, with the
intermediate CA certificate(s) as the leaf certificate(s). The response
will have a Content-Type of \"application/x-x509-ca-ra-cert\". Note that
this designation is used for historical reasons due to its use in older
versions of this specification \-- no special meaning should be attached
to the label.[¶](#section-4.2.1.2-1){.pilcrow}

::: {#section-4.2.1.2-2}
``` sourcecode
"Content-Type: application/x-x509-ca-ra-cert"

<binary CMS>
```

[¶](#section-4.2.1.2-2){.pilcrow}
:::
:::
:::
:::
:::
:::
:::

::: {#cert-enrolment}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Certificate Enrolment/Renewal](#name-certificate-enrolment-renewa){.section-name .selfRef} {#name-certificate-enrolment-renewa}

A PKCSReq/RenewalReq ([Section 3.3.1](#PKCSReq){.xref}) message is used
to perform a certificate enrolment or renewal transaction. The OPERATION
[MUST]{.bcp14} be set to \"PKIOperation\". Note that when used with HTTP
POST, the only OPERATION possible is \"PKIOperation\", so many CAs
don\'t check this value or even notice its absence. When implemented
using HTTP POST, the message is sent with a Content-Type of
\"application/x-pki-message\" and might look as
follows:[¶](#section-4.3-1){.pilcrow}

::: {#section-4.3-2}
``` sourcecode
POST /cgi-bin/pkiclient.exe?operation=PKIOperation HTTP/1.1
Content-Length: <length of data>
Content-Type: application/x-pki-message

<binary CMS data>
```

[¶](#section-4.3-2){.pilcrow}
:::

When implemented using HTTP GET, this might look as
follows:[¶](#section-4.3-3){.pilcrow}

::: {#section-4.3-4}
``` sourcecode
GET /cgi-bin/pkiclient.exe?operation=PKIOperation& \
message=MIAGCSqGSIb3DQEHA6CAMIACAQAxgDCBzAIBADB2MG \
IxETAPBgNVBAcTCE......AAAAAA== HTTP/1.1
```

[¶](#section-4.3-4){.pilcrow}
:::

::: {#cert-enrolment-resp}
::: {#section-4.3.1 .section}
#### [4.3.1.](#section-4.3.1){.section-number .selfRef} [Certificate Enrolment/Renewal Response Message](#name-certificate-enrolment-renewal){.section-name .selfRef} {#name-certificate-enrolment-renewal}

If the request is granted, a CertRep SUCCESS message ([Section
3.3.2.1](#CertRep-success){.xref}) is returned. If the request is
rejected, a CertRep FAILURE message ([Section
3.3.2.2](#CertRep-failure){.xref}) is returned. If the CA is configured
to manually authenticate the client, a CertRep PENDING message ([Section
3.3.2.3](#CertRep-pending){.xref}) [MAY]{.bcp14} be returned. The CA
[MAY]{.bcp14} return a PENDING for other
reasons.[¶](#section-4.3.1-1){.pilcrow}

The response will have a Content-Type of
\"application/x-pki-message\".[¶](#section-4.3.1-2){.pilcrow}

::: {#section-4.3.1-3}
``` sourcecode
"Content-Type: application/x-pki-message"

<binary CertRep message>
```

[¶](#section-4.3.1-3){.pilcrow}
:::
:::
:::
:::
:::

::: {#poll-resp}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Poll for Client Initial Certificate](#name-poll-for-client-initial-cer){.section-name .selfRef} {#name-poll-for-client-initial-cer}

When the client receives a CertRep message with pkiStatus set to
PENDING, it will enter the polling state by periodically sending
CertPoll messages to the CA until either the request is granted and the
certificate is sent back or the request is rejected or some
preconfigured time limit for polling or maximum number of polls is
exceeded. The OPERATION [MUST]{.bcp14} be set to
\"PKIOperation\".[¶](#section-4.4-1){.pilcrow}

CertPoll messages exchanged during the polling period [MUST]{.bcp14}
carry the same transactionID attribute as the previous
PKCSReq/RenewalReq. A CA receiving a CertPoll for which it does not have
a matching PKCSReq/RenewalReq [MUST]{.bcp14} reject this
request.[¶](#section-4.4-2){.pilcrow}

Since at this time the certificate has not been issued, the client can
only use its own subject name (which was contained in the original PKCS#
10 sent via PKCSReq/RenewalReq) to identify the polled certificate
request (but see the note on identification during polling in [Section
3.3.3](#CertPoll){.xref}). In theory, there can be multiple outstanding
requests from one client (for example, if different keys and different
key usages were used to request multiple certificates), so the
transactionID must also be included to disambiguate between multiple
requests. In practice, however, the client [SHOULD NOT]{.bcp14} have
multiple requests outstanding at any one time, since this tends to
confuse some CAs.[¶](#section-4.4-3){.pilcrow}

::: {#poll-resp-format}
::: {#section-4.4.1 .section}
#### [4.4.1.](#section-4.4.1){.section-number .selfRef} [Polling Response Message Format](#name-polling-response-message-fo){.section-name .selfRef} {#name-polling-response-message-fo}

The response messages for CertPoll are the same as in [Section
4.3.1](#cert-enrolment-resp){.xref}.[¶](#section-4.4.1-1){.pilcrow}
:::
:::
:::
:::

::: {#cert-access}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [Certificate Access](#name-certificate-access-2){.section-name .selfRef} {#name-certificate-access-2}

A client can query an issued certificate from the SCEP CA, as long as
the client knows the issuer name and the issuer-assigned certificate
serial number.[¶](#section-4.5-1){.pilcrow}

This transaction consists of one GetCert ([Section
3.3.4](#GetCertCRL){.xref}) message sent to the CA by a client and one
CertRep ([Section 3.3.2](#CertRep){.xref}) message sent back from the
CA. The OPERATION [MUST]{.bcp14} be set to
\"PKIOperation\".[¶](#section-4.5-2){.pilcrow}

::: {#cert-access-resp}
::: {#section-4.5.1 .section}
#### [4.5.1.](#section-4.5.1){.section-number .selfRef} [Certificate Access Response Message Format](#name-certificate-access-response){.section-name .selfRef} {#name-certificate-access-response}

In this case, the CertRep from the CA is same as in [Section
4.3.1](#cert-enrolment-resp){.xref}, except that the CA will either
grant the request (SUCCESS) or reject it
(FAILURE).[¶](#section-4.5.1-1){.pilcrow}
:::
:::
:::
:::

::: {#CRL-access}
::: {#section-4.6 .section}
### [4.6.](#section-4.6){.section-number .selfRef} [CRL Access](#name-crl-access-2){.section-name .selfRef} {#name-crl-access-2}

Clients can request a CRL from the SCEP CA, as described in [Section
2.7](#overview-CRL-access){.xref}. The OPERATION [MUST]{.bcp14} be set
to \"PKIOperation\".[¶](#section-4.6-1){.pilcrow}

::: {#CRL-access-resp}
::: {#section-4.6.1 .section}
#### [4.6.1.](#section-4.6.1){.section-number .selfRef} [CRL Access Response Message Format](#name-crl-access-response-message){.section-name .selfRef} {#name-crl-access-response-message}

The CRL is sent back to the client in a CertRep ([Section
3.3.2](#CertRep){.xref}) message. The information portion of this
message is a degenerate certificates-only SignedData ([Section
3.4](#certs-only){.xref}) that contains only the most recent CRL in the
crls field of the SignedData.[¶](#section-4.6.1-1){.pilcrow}
:::
:::
:::
:::

::: {#get-next-CA}
::: {#section-4.7 .section}
### [4.7.](#section-4.7){.section-number .selfRef} [Get Next Certificate Authority Certificate](#name-get-next-certificate-author){.section-name .selfRef} {#name-get-next-certificate-author}

When a CA certificate is about to expire, clients need to retrieve the
CA\'s next CA certificate (i.e., the rollover certificate). This is done
via the GetNextCACert message. The OPERATION [MUST]{.bcp14} be set to
\"GetNextCACert\". There is no request data associated with this
message.[¶](#section-4.7-1){.pilcrow}

::: {#get-next-CA-format}
::: {#section-4.7.1 .section}
#### [4.7.1.](#section-4.7.1){.section-number .selfRef} [Get Next CA Response Message Format](#name-get-next-ca-response-messag){.section-name .selfRef} {#name-get-next-ca-response-messag}

The response consists of a SignedData CMS message, signed by the current
CA signing key. Clients [MUST]{.bcp14} validate the signature on the
message before trusting any of its contents. The response will have a
Content-Type of
\"application/x-x509-next-ca-cert\".[¶](#section-4.7.1-1){.pilcrow}

::: {#section-4.7.1-2}
``` sourcecode
"Content-Type: application/x-x509-next-ca-cert"

<binary CMS>
```

[¶](#section-4.7.1-2){.pilcrow}
:::

The content of the SignedData message is a degenerate certificates-only
SignedData message ([Section 3.4](#certs-only){.xref}) containing the
new CA certificate(s) to be used when the current CA certificate
expires.[¶](#section-4.7.1-3){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#state-trans}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [SCEP Transaction Examples](#name-scep-transaction-examples){.section-name .selfRef} {#name-scep-transaction-examples}

The following section gives several examples of client-to-CA
transactions. Client actions are indicated in the left column, CA
actions are indicated in the right column, and the transactionID is
given in parentheses. For ease of reading, small integer values have
been used; in practice, full transaction IDs would be used. The first
transaction, for example, would read like
this:[¶](#section-5-1){.pilcrow}

> Client Sends PKCSReq message with transactionID 1 to the CA. The CA
> signs the certificate and constructs a CertRep Message containing the
> signed certificate with a transaction ID 1. The client receives the
> message and installs the certificate
> locally.[¶](#section-5-2){.pilcrow}

::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Successful Transactions](#name-successful-transactions){.section-name .selfRef} {#name-successful-transactions}

[]{#name-successful-enrolment-case-a}

::: {#section-5.1-1.1 .artwork .art-text .alignLeft}
    PKCSReq (1)             ----------> CA issues certificate
                            <---------- CertRep (1) SUCCESS
    Client installs certificate
:::

[Figure 7](#figure-7){.selfRef}: [Successful Enrolment Case: Automatic
Processing](#name-successful-enrolment-case-a){.selfRef}

[]{#name-successful-enrolment-case-m}

::: {#section-5.1-2.1 .artwork .art-text .alignLeft}
    PKCSReq (2)             ----------> Cert request goes into queue
                            <---------- CertRep (2) PENDING
    CertPoll (2)            ----------> Still pending
                            <---------- CertRep (2) PENDING
    CertPoll (2)            ----------> CA issues certificate
                            <---------- CertRep (2) SUCCESS
    Client installs certificate
:::

[Figure 8](#figure-8){.selfRef}: [Successful Enrolment Case: Manual
Authentication Required](#name-successful-enrolment-case-m){.selfRef}

[]{#name-ca-certificate-rollover-cas}

::: {#section-5.1-3.1 .artwork .art-text .alignLeft}
    GetNextCACert         ---------->
                          <---------- New CA certificate

    PKCSReq*              ----------> CA issues certificate with
                                      new key
                          <---------- CertRep SUCCESS
    Client stores certificate
    for installation when
    existing certificate expires.
:::

[Figure 9](#figure-9){.selfRef}: [CA Certificate Rollover
Case](#name-ca-certificate-rollover-cas){.selfRef}

\* Enveloped for the new CA certificate. The CA will use the envelope to
determine which key to use to issue the client
certificate.[¶](#section-5.1-4){.pilcrow}
:::

::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Transactions with Errors](#name-transactions-with-errors){.section-name .selfRef} {#name-transactions-with-errors}

In the case of polled transactions that aren\'t completed automatically,
there are two potential options for dealing with a transaction that\'s
interrupted due to network or software/hardware issues. The first is for
the client to preserve its transaction state and resume the CertPoll
polling when normal service is restored. The second is for the client to
begin a new transaction by sending a new PKCSReq/RenewalReq, rather than
continuing the previous CertPoll. Both options have their own advantages
and disadvantages.[¶](#section-5.2-1){.pilcrow}

The CertPoll continuation requires that the client maintain its
transaction state for the time when it resumes polling. This is
relatively simple if the problem is a brief network outage, but less
simple when the problem is a client crash and restart. In addition, the
CA may treat a lost network connection as the end of a transaction, so
that a new connection followed by a CertPoll will be treated as an
error.[¶](#section-5.2-2){.pilcrow}

The PKCSReq/RenewalReq continuation doesn\'t require any state to be
maintained, since it\'s a new transaction. However, it may cause
problems on the CA side if the certificate was successfully issued but
the client never received it, since the resumed transaction attempt will
appear to be a request for a duplicate certificate (see [Section
7.4](#security-no-conf){.xref} for more on why this is a problem). In
this case, the CA may refuse the transaction or require manual
intervention to remove/revoke the previous certificate before the client
can request another one.[¶](#section-5.2-3){.pilcrow}

Since the new-transaction resume is more robust in the presence of
errors and doesn\'t require special-case handling by either the client
or CA, clients [SHOULD]{.bcp14} use the new-transaction option in
preference to the resumed-CertPoll option to recover from
errors.[¶](#section-5.2-4){.pilcrow}

Resync Case 1: Client resyncs via new PKCSReq
(recommended):[¶](#section-5.2-5){.pilcrow}

[]{#name-resync-case-1}

::: {#section-5.2-6.1 .artwork .art-text .alignLeft}
    PKCSReq (3)           ----------> Cert request goes into queue
                          <---------- CertRep (3) PENDING
    CertPoll (3)          ----------> Still pending
                            X-------- CertRep(3) PENDING
    (Network outage)
    (Client reconnects)
    PKCSReq (4)           ---------->
                          <---------- CertRep (4) PENDING
    etc...
:::

[Figure 10](#figure-10){.selfRef}: [Resync Case
1](#name-resync-case-1){.selfRef}

Resync Case 2: Client resyncs via resumed CertPoll after a network
outage (not recommended; use PKCSReq to
resync):[¶](#section-5.2-7){.pilcrow}

[]{#name-resync-case-2}

::: {#section-5.2-8.1 .artwork .art-text .alignLeft}
    PKCSReq (5)           ----------> Cert request goes into queue
                          <---------- CertRep (5) PENDING
    CertPoll (5)          ----------> Still pending
                            X-------- CertRep(5) PENDING
    (Network outage)
    (Client reconnects)
    CertPoll (5)          ----------> CA issues certificate
                          <---------- CertRep (5) SUCCESS
    Client installs certificate
:::

[Figure 11](#figure-11){.selfRef}: [Resync Case
2](#name-resync-case-2){.selfRef}

Resync Case 3: Special-case variation of Case 2 where the CertRep
SUCCESS rather than the CertRep PENDING is lost
(recommended):[¶](#section-5.2-9){.pilcrow}

[]{#name-resync-case-3}

::: {#section-5.2-10.1 .artwork .art-text .alignLeft}
    PKCSReq (6)           ----------> Cert request goes into queue
                          <---------- CertRep (6) PENDING
    CertPoll (6)          ----------> Still pending
                          <---------- CertRep (6) PENDING
    CertPoll (6)          ----------> CA issues certificate
                            X-------- CertRep(6) SUCCESS
    (Network outage)
    (Client reconnects)
    PKCSReq (7)           ----------> There is already a valid
                                      certificate with this
                                      Distinguished Name (DN).
                          <---------- CertRep (7) FAILURE
                                      Admin revokes certificate
    PKCSReq (8)           ----------> CA issues new certificate
                          <---------- CertRep (8) SUCCESS
    Client installs certificate
:::

[Figure 12](#figure-12){.selfRef}: [Resync Case
3](#name-resync-case-3){.selfRef}

Resync Case 4: Special-case variation of Case 1 where the CertRep
SUCCESS rather than the CertRep PENDING is lost (not recommended; use
PKCSReq to resync):[¶](#section-5.2-11){.pilcrow}

[]{#name-resync-case-4}

::: {#section-5.2-12.1 .artwork .art-text .alignLeft}
    PKCSReq (9)           ----------> Cert request goes into queue
                          <---------- CertRep (9) PENDING
    CertPoll (9)          ----------> Still pending
                          <---------- CertRep (9) PENDING
    CertPoll (9)          ----------> CA issues certificate
                            X-------- CertRep(9) SIGNED CERT
    (Network outage)
    (Client reconnects)
    CertPoll (9)          ----------> Certificate already issued
                          <---------- CertRep (9) SUCCESS
    Client installs certificate
:::

[Figure 13](#figure-13){.selfRef}: [Resync Case
4](#name-resync-case-4){.selfRef}

As these examples indicate, resumption from an error via a resumed
CertPoll is tricky due to the state that needs to be held by both the
client and/or the CA. A PKCSReq/RenewalReq resume is the easiest to
implement, since it\'s stateless and is identical for both polled and
nonpolled transactions, whereas a CertPoll resume treats the two
differently. (A nonpolled transaction is resumed with a
PKCSReq/RenewalReq; a polled transaction is resumed with a CertPoll.)
For this reason, error recovery [SHOULD]{.bcp14} be handled via a new
PKCSReq rather than a resumed CertPoll.[¶](#section-5.2-13){.pilcrow}
:::
:::
:::

::: {#iana}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

An object identifier for an arc to assign SCEP Attribute Identifiers has
been assigned in the \"SMI Security for PKIX\" registry (1.3.6.1.5.5.7).
This object identifer, Simple Certificate Enrollment Protocol
Attributes, is denoted as id-scep:[¶](#section-6-1){.pilcrow}

::: {#section-6-2}
``` sourcecode
id-scep OBJECT IDENTIFIER ::= { id-pkix 24 }
```

[¶](#section-6-2){.pilcrow}
:::

IANA created the \"SMI Security for SCEP Attribute Identifiers\"
registry (1.3.6.1.5.5.7.24) with the following entries with references
to this document:[¶](#section-6-3){.pilcrow}

::: {#section-6-4}
``` sourcecode
id-scep-failInfoText OBJECT IDENTIFIER ::= { id-scep 1 }
```

[¶](#section-6-4){.pilcrow}
:::

Entries in the registry are assigned according to the \"Specification
Required\" policy defined in
\[[RFC8126](#RFC8126){.xref}\].[¶](#section-6-5){.pilcrow}

[Section 3.2.1.2](#messageType){.xref} describes an \"SCEP Message
Type\" registry, and [Section 3.5](#CA-caps){.xref} describes an \"SCEP
CA Capabilities\" registry; these registries are maintained by IANA and
define a number of such code-point identifiers. Entries in the registry
are assigned according to the \"Specification Required\" policy defined
in \[[RFC8126](#RFC8126){.xref}\].[¶](#section-6-6){.pilcrow}

The \"SCEP Message Types\" registry has \"Value\", \"Name\",
\"Description\", and \"Reference\" columns. The \"Value\" entry is a
small positive integer; value \"0\" is
reserved.[¶](#section-6-7){.pilcrow}

The \"SCEP CA Capabilities\" registry has \"Keyword\", \"Description\",
and \"Reference\" columns. Although implementations [SHOULD]{.bcp14} use
the \"SCEP CA Capabilities\" registry, SCEP is often employed in
situations where this isn\'t possible. In this case, private-use CA
capabilities may be specified using a unique prefix such as an
organisation identifier or domain name under the control of the entity
that defines the capability. For example, the prefix would be
\"Example.com-\", and the complete capability would be
\"Example.com-CapabilityName\".[¶](#section-6-8){.pilcrow}

IANA has registered four media types as defined in this
document:[¶](#section-6-9){.pilcrow}

-   [application/x-x509-ca-cert[¶](#section-6-10.1){.pilcrow}]{#section-6-10.1}
-   [application/x-x509-ca-ra-cert[¶](#section-6-10.2){.pilcrow}]{#section-6-10.2}
-   [application/x-x509-next-ca-cert[¶](#section-6-10.3){.pilcrow}]{#section-6-10.3}
-   [application/x-pki-message[¶](#section-6-10.4){.pilcrow}]{#section-6-10.4}

Note that these are grandfathered media types registered as per
[Appendix A](https://www.rfc-editor.org/rfc/rfc6838#appendix-A){.relref}
of \[[RFC6838](#RFC6838){.xref}\]. Templates for registrations are
specified below.[¶](#section-6-11){.pilcrow}

::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Registration of the application/x-x509-ca-cert Media Type](#name-registration-of-the-applica){.section-name .selfRef} {#name-registration-of-the-applica}

[]{.break}

Type name:
:   application[¶](#section-6.1-1.2){.pilcrow}
:   

Subtype name:
:   x-x509-ca-cert[¶](#section-6.1-1.4){.pilcrow}
:   

Required parameters:
:   none[¶](#section-6.1-1.6){.pilcrow}
:   

Optional parameters:
:   none[¶](#section-6.1-1.8){.pilcrow}
:   

Encoding considerations:
:   binary[¶](#section-6.1-1.10){.pilcrow}
:   

Security considerations:
:   This media type contains a certificate; see the Security
    Considerations section of \[[RFC5280](#RFC5280){.xref}\]. There is
    no executable content.[¶](#section-6.1-1.12){.pilcrow}
:   

Interoperability considerations:
:   This is a grandfathered registration of an alias to
    application/pkix-cert (basically a single DER-encoded Certification
    Authority certificate), which is only used in
    SCEP.[¶](#section-6.1-1.14){.pilcrow}
:   

Published specification:
:   RFC 8894[¶](#section-6.1-1.16){.pilcrow}
:   

Applications that use this media type:
:   SCEP uses this media type when returning a CA
    certificate.[¶](#section-6.1-1.18){.pilcrow}
:   

Fragment identifier considerations:
:   N/A[¶](#section-6.1-1.20){.pilcrow}
:   

Additional information:

:   \

    []{.break}

    Deprecated alias names for this type:
    :   N/A[¶](#section-6.1-1.22.2.2){.pilcrow}
    :   

    Magic number(s):
    :   none[¶](#section-6.1-1.22.2.4){.pilcrow}
    :   

    File extension(s):
    :   N/A[¶](#section-6.1-1.22.2.6){.pilcrow}
    :   

    Macintosh file type code(s):
    :   N/A[¶](#section-6.1-1.22.2.8){.pilcrow}
    :   

:   

Person and email address to contact for further information:
:   See the Authors\' Addresses section of RFC
    8894.[¶](#section-6.1-1.24){.pilcrow}
:   

Intended usage:
:   LIMITED USE[¶](#section-6.1-1.26){.pilcrow}
:   

Restrictions on usage:
:   SCEP protocol[¶](#section-6.1-1.28){.pilcrow}
:   

Author:
:   See the Authors\' Addresses section of RFC
    8894[¶](#section-6.1-1.30){.pilcrow}
:   

Change controller:
:   IETF[¶](#section-6.1-1.32){.pilcrow}
:   

Provisional registration?
:   No[¶](#section-6.1-1.34){.pilcrow}
:   
:::

::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Registration of the application/x-x509-ca-ra-cert Media Type](#name-registration-of-the-applicat){.section-name .selfRef} {#name-registration-of-the-applicat}

[]{.break}

Type name:
:   application[¶](#section-6.2-1.2){.pilcrow}
:   

Subtype name:
:   x-x509-ca-ra-cert[¶](#section-6.2-1.4){.pilcrow}
:   

Required parameters:
:   none[¶](#section-6.2-1.6){.pilcrow}
:   

Optional parameters:
:   none[¶](#section-6.2-1.8){.pilcrow}
:   

Encoding considerations:
:   binary[¶](#section-6.2-1.10){.pilcrow}
:   

Security considerations:
:   This media type consists of a degenerate certificates-only CMS
    SignedData message ([Section 3.4](#certs-only){.xref}) containing
    the certificates, with the intermediate CA certificate(s) as the
    leaf certificate(s). There is no executable
    content.[¶](#section-6.2-1.12){.pilcrow}
:   

Interoperability considerations:
:   This is a grandfathered registration that is only used in
    SCEP.[¶](#section-6.2-1.14){.pilcrow}
:   

Published specification:
:   RFC 8894[¶](#section-6.2-1.16){.pilcrow}
:   

Applications that use this media type:
:   SCEP uses this media type when returning CA Certificate Chain
    Response.[¶](#section-6.2-1.18){.pilcrow}
:   

Fragment identifier considerations:
:   N/A[¶](#section-6.2-1.20){.pilcrow}
:   

Additional information:

:   \

    []{.break}

    Deprecated alias names for this type:
    :   N/A[¶](#section-6.2-1.22.2.2){.pilcrow}
    :   

    Magic number(s):
    :   none[¶](#section-6.2-1.22.2.4){.pilcrow}
    :   

    File extension(s):
    :   N/A[¶](#section-6.2-1.22.2.6){.pilcrow}
    :   

    Macintosh file type code(s):
    :   N/A[¶](#section-6.2-1.22.2.8){.pilcrow}
    :   

:   

Person and email address to contact for further information:
:   See the Authors\' Addresses section of RFC
    8894.[¶](#section-6.2-1.24){.pilcrow}
:   

Intended usage:
:   LIMITED USE[¶](#section-6.2-1.26){.pilcrow}
:   

Restrictions on usage:
:   SCEP protocol[¶](#section-6.2-1.28){.pilcrow}
:   

Author:
:   See the Authors\' Addresses section of RFC
    8894.[¶](#section-6.2-1.30){.pilcrow}
:   

Change controller:
:   IETF[¶](#section-6.2-1.32){.pilcrow}
:   

Provisional registration?
:   no[¶](#section-6.2-1.34){.pilcrow}
:   
:::

::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Registration of the application/x-x509-next-ca-cert Media Type](#name-registration-of-the-applicati){.section-name .selfRef} {#name-registration-of-the-applicati}

[]{.break}

Type name:
:   application[¶](#section-6.3-1.2){.pilcrow}
:   

Subtype name:
:   x-x509-next-ca-cert[¶](#section-6.3-1.4){.pilcrow}
:   

Required parameters:
:   none[¶](#section-6.3-1.6){.pilcrow}
:   

Optional parameters:
:   none[¶](#section-6.3-1.8){.pilcrow}
:   

Encoding considerations:
:   binary[¶](#section-6.3-1.10){.pilcrow}
:   

Security considerations:
:   This media type consists of a SignedData CMS message, signed by the
    current CA signing key. There is no executable
    content.[¶](#section-6.3-1.12){.pilcrow}
:   

Interoperability considerations:
:   This is a grandfathered registration that is only used in
    SCEP.[¶](#section-6.3-1.14){.pilcrow}
:   

Published specification:
:   RFC 8894[¶](#section-6.3-1.16){.pilcrow}
:   

Applications that use this media type:
:   SCEP uses this media type when returning a Get Next CA
    response.[¶](#section-6.3-1.18){.pilcrow}
:   

Fragment identifier considerations:
:   N/A[¶](#section-6.3-1.20){.pilcrow}
:   

Additional information:

:   \

    []{.break}

    Deprecated alias names for this type:
    :   N/A[¶](#section-6.3-1.22.2.2){.pilcrow}
    :   

    Magic number(s):
    :   none[¶](#section-6.3-1.22.2.4){.pilcrow}
    :   

    File extension(s):
    :   N/A[¶](#section-6.3-1.22.2.6){.pilcrow}
    :   

    Macintosh file type code(s):
    :   N/A[¶](#section-6.3-1.22.2.8){.pilcrow}
    :   

:   

Person and email address to contact for further information:
:   See the Authors\' Addresses section of RFC
    8894.[¶](#section-6.3-1.24){.pilcrow}
:   

Intended usage:
:   LIMITED USE[¶](#section-6.3-1.26){.pilcrow}
:   

Restrictions on usage:
:   SCEP protocol[¶](#section-6.3-1.28){.pilcrow}
:   

Author:
:   See the Authors\' Addresses section of RFC
    8894.[¶](#section-6.3-1.30){.pilcrow}
:   

Change controller:
:   IETF[¶](#section-6.3-1.32){.pilcrow}
:   

Provisional registration?
:   no[¶](#section-6.3-1.34){.pilcrow}
:   
:::

::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [Registration of the application/x-pki-message Media Type](#name-registration-of-the-applicatio){.section-name .selfRef} {#name-registration-of-the-applicatio}

[]{.break}

Type name:
:   application[¶](#section-6.4-1.2){.pilcrow}
:   

Subtype name:
:   x-pki-message[¶](#section-6.4-1.4){.pilcrow}
:   

Required parameters:
:   none[¶](#section-6.4-1.6){.pilcrow}
:   

Optional parameters:
:   none[¶](#section-6.4-1.8){.pilcrow}
:   

Encoding considerations:
:   binary[¶](#section-6.4-1.10){.pilcrow}
:   

Security considerations:
:   This media type consists of a degenerate certificates-only CMS
    SignedData message. There is no executable
    content.[¶](#section-6.4-1.12){.pilcrow}
:   

Interoperability considerations:
:   This is a grandfathered registration that is only used in
    SCEP.[¶](#section-6.4-1.14){.pilcrow}
:   

Published specification:
:   RFC 8894[¶](#section-6.4-1.16){.pilcrow}
:   

Applications that use this media type:
:   SCEP uses this media type when returning a Certificate
    Enrolment/Renewal Response.[¶](#section-6.4-1.18){.pilcrow}
:   

Fragment identifier considerations:
:   N/A[¶](#section-6.4-1.20){.pilcrow}
:   

Additional information:

:   \

    []{.break}

    Deprecated alias names for this type:
    :   N/A[¶](#section-6.4-1.22.2.2){.pilcrow}
    :   

    Magic number(s):
    :   none[¶](#section-6.4-1.22.2.4){.pilcrow}
    :   

    File extension(s):
    :   N/A[¶](#section-6.4-1.22.2.6){.pilcrow}
    :   

    Macintosh file type code(s):
    :   N/A[¶](#section-6.4-1.22.2.8){.pilcrow}
    :   

:   

Person and email address to contact for further information:
:   See the Authors\' Addresses section of RFC
    8894.[¶](#section-6.4-1.24){.pilcrow}
:   

Intended usage:
:   LIMITED USE[¶](#section-6.4-1.26){.pilcrow}
:   

Restrictions on usage:
:   SCEP protocol[¶](#section-6.4-1.28){.pilcrow}
:   

Author:
:   See the Authors\' Addresses section of RFC
    8894.[¶](#section-6.4-1.30){.pilcrow}
:   

Change controller:
:   IETF[¶](#section-6.4-1.32){.pilcrow}
:   

Provisional registration?
:   no[¶](#section-6.4-1.34){.pilcrow}
:   
:::
:::
:::

::: {#security}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

The security goal of SCEP is that no adversary can subvert the public
key/identity binding from that intended. An adversary is any entity
other than the client and the CA participating in the
protocol.[¶](#section-7-1){.pilcrow}

This goal is met through the use of CMS and PKCS #10 encryption and
digital signatures using authenticated public keys. The CA\'s public key
is authenticated via out-of-band means such as the checking of the CA
fingerprint, and the SCEP client\'s public key is authenticated through
manual or preshared secret authentication.[¶](#section-7-2){.pilcrow}

::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [General Security](#name-general-security){.section-name .selfRef} {#name-general-security}

Common key-management considerations such as keeping private keys truly
private and using adequate lengths for symmetric and asymmetric keys
must be followed in order to maintain the security of this protocol.
This is especially true for CA keys which, when compromised, compromise
the security of all relying parties.[¶](#section-7.1-1){.pilcrow}
:::

::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Use of the CA Private Key](#name-use-of-the-ca-private-key){.section-name .selfRef} {#name-use-of-the-ca-private-key}

A CA private key is generally meant for, and usually flagged as, being
usable for certificate (and CRL) signing exclusively rather than data
signing or encryption. The SCEP protocol, however, uses the CA private
key to both sign and optionally encrypt CMS transport messages. This is
generally considered undesirable, as it widens the possibility of an
implementation weakness and provides an additional location where the
private key must be used (and hence is slightly more vulnerable to
exposure) and where a side-channel attack might be
applied.[¶](#section-7.2-1){.pilcrow}
:::

::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [ChallengePassword Shared Secret Value](#name-challengepassword-shared-se){.section-name .selfRef} {#name-challengepassword-shared-se}

The security measures that should be applied to the challengePassword
shared secret depend on the manner in which SCEP is employed. In the
simplest case, with SCEP used to provision devices with certificates in
the manufacturing facility, the physical security of the facility may be
enough to protect the certificate issue process with no additional
measures explicitly required. In general, though, the security of the
issue process depends on the security employed around the use of the
challengePassword shared secret. While it\'s not possible to enumerate
every situation in which SCEP may be utilised, the following security
measures should be considered.[¶](#section-7.3-1){.pilcrow}

-   [The challengePassword, despite its name, shouldn\'t be a
    conventional password but a high-entropy shared-secret
    authentication string. Using the base64 encoding of a keying value
    generated or exchanged as part of standard device authentication
    protocols like the Extensible Authentication Protocol (EAP) or DNP3
    Secure Authentication (DNP3-SA) makes for a good challengePassword.
    The use of high-entropy shared secrets is particularly important
    when the PasswordRecipientInfo option is used to encrypt SCEP
    messages; see [Section
    3.1](#message-processing){.xref}.[¶](#section-7.3-2.1){.pilcrow}]{#section-7.3-2.1}
-   [If feasible, the challengePassword should be a one-time value used
    to authenticate the issue of a single certificate (subsequent
    certificate requests will be authenticated by being signed with the
    initial certificate). If the challengePassword is single use, then
    the arrival of subsequent requests using the same challengePassword
    can then be used to indicate a security
    breach.[¶](#section-7.3-2.2){.pilcrow}]{#section-7.3-2.2}
-   [The lifetime of a challengePassword can be limited, so that it can
    be used during initial device provisioning but will have expired at
    a later date if an attacker manages to compromise the
    challengePassword value \-- for example, by compromising the device
    that it\'s stored
    in.[¶](#section-7.3-2.3){.pilcrow}]{#section-7.3-2.3}
-   [The CA should take appropriate measures to protect the
    challengePassword. Examples of possible measures include: physical
    security measures; storing it as a salted iterated hash or
    equivalent memory-hard function; storing it as a keyed MAC value if
    it\'s not being used for encryption; and storing it in encrypted
    form if it is being used for
    encryption.[¶](#section-7.3-2.4){.pilcrow}]{#section-7.3-2.4}
:::

::: {#security-no-conf}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [Lack of Certificate Issue Confirmation](#name-lack-of-certificate-issue-c){.section-name .selfRef} {#name-lack-of-certificate-issue-c}

SCEP provides no confirmation that the issued certificate was
successfully received and processed by the client. This means that if
the CertRep message is lost or can\'t be processed by the client, then
the CA will consider the certificate successfully issued while the
client won\'t. If this situation is of concern, then the correct
issuance of the certificate will need to be verified by out-of-band
means, for example, through the client sending a message signed by the
newly issued certificate to the CA. This also provides the proof of
possession that\'s not present in the case of a renewal operation; see
[Section 7.6](#security-no-pop){.xref}.[¶](#section-7.4-1){.pilcrow}
:::
:::

::: {#security-getcacaps}
::: {#section-7.5 .section}
### [7.5.](#section-7.5){.section-number .selfRef} [GetCACaps Issues](#name-getcacaps-issues){.section-name .selfRef} {#name-getcacaps-issues}

The GetCACaps response is not authenticated by the CA. This allows an
attacker to perform downgrade attacks on the cryptographic capabilities
of the client/CA exchange. In particular, if the server were to support
MD5 and single DES, then an in-path attacker could trivially roll back
the encryption to use these insecure algorithms. By taking advantage of
the presence of large amounts of static known plaintext in the SCEP
messages, as of 2017, a DES rainbow table attack can recover most
encryption keys in under a minute, and MD5 chosen-prefix collisions can
be calculated for a few tens of cents of computing time using tools like
HashClash. It is for this reason that this specification makes single
DES and MD5 a [MUST NOT]{.bcp14} feature. Note that all known servers
support at least triple DES and SHA-1 (regardless of whether \"DES3\"
and \"SHA-1\" are indicated in GetCACaps), so there should never be a
reason to fall all the way back to single DES and
MD5.[¶](#section-7.5-1){.pilcrow}

One simple countermeasure to a GetCACaps downgrade attack is for clients
that are operating in an environment where on-path attacks are possible
and that expect the \"SCEPStandard\" capability to be indicated by the
CA but don\'t see it in the GetCACaps response to treat its absence as a
security issue, and either discontinue the exchange or continue as if
\"SCEPStandard\" had been returned. This requires a certain trade-off
between compatibility with old servers and security against active
attacks.[¶](#section-7.5-2){.pilcrow}
:::
:::

::: {#security-no-pop}
::: {#section-7.6 .section}
### [7.6.](#section-7.6){.section-number .selfRef} [Lack of PoP in Renewal Requests](#name-lack-of-pop-in-renewal-requ){.section-name .selfRef} {#name-lack-of-pop-in-renewal-requ}

Renewal operations (but not standard certificate-issue operations) are
processed via a previously issued certificate and its associated private
key, not the key in the PKCS #10 request. This means that a client no
longer demonstrates proof of possession (PoP) of the private key
corresponding to the public key in the PKCS #10 request. It is therefore
possible for a client to recertify an existing key used by a third
party, so that two or more certificates exist for the same key. By
switching out the certificate in a signature, an attacker can appear to
have a piece of data signed by their certificate rather than the
original signer\'s certificate. This, and other, attacks are described
in [S/MIME ESS](#RFC2634){.xref}
\[[RFC2634](#RFC2634){.xref}\].[¶](#section-7.6-1){.pilcrow}

Avoiding these types of attacks requires situation-specific measures.
For example, CMS/SMIME implementations may use the ESSCertID attribute
from [S/MIME ESS](#RFC2634){.xref} \[[RFC2634](#RFC2634){.xref}\] or its
successor, [S/MIME ESSv2](#RFC5035){.xref}
\[[RFC5035](#RFC5035){.xref}\], to unambiguously identify the signing
certificate. However, since other mechanisms and protocols that the
certificates will be used with typically don\'t defend against this
problem, it\'s unclear whether this is an actual issue with
SCEP.[¶](#section-7.6-2){.pilcrow}
:::
:::

::: {#traffic-monitoring}
::: {#section-7.7 .section}
### [7.7.](#section-7.7){.section-number .selfRef} [Traffic Monitoring](#name-traffic-monitoring){.section-name .selfRef} {#name-traffic-monitoring}

SCEP messages are signed with certificates that may contain identifying
information. If these are sent over the public Internet and real
identity information (rather than placeholder values or arbitrary device
IDs) is included in the signing certificate data, an attacker may be
able to monitor the identities of the entities submitting the
certificate requests. If this is an issue, then
\[[RFC7258](#RFC7258){.xref}\] should be consulted for
guidance.[¶](#section-7.7-1){.pilcrow}
:::
:::

::: {#security-unnecessary}
::: {#section-7.8 .section}
### [7.8.](#section-7.8){.section-number .selfRef} [Unnecessary Cryptography](#name-unnecessary-cryptography){.section-name .selfRef} {#name-unnecessary-cryptography}

Some of the SCEP exchanges use unnecessary signing and encryption
operations. In particular, the GetCert and GetCRL exchanges are
encrypted and signed in both directions. The information requested is
public, and thus encrypting the requests is of questionable value. In
addition, CRLs and certificates sent in responses are already signed by
the CA and can be verified by the recipient without requiring additional
signing and encryption. More lightweight means of retrieving
certificates and CRLs such as [HTTP certificate-store
access](#RFC4387){.xref} \[[RFC4387](#RFC4387){.xref}\] and LDAP are
recommended for this reason.[¶](#section-7.8-1){.pilcrow}
:::
:::

::: {#security-sha1}
::: {#section-7.9 .section}
### [7.9.](#section-7.9){.section-number .selfRef} [Use of SHA-1](#name-use-of-sha-1){.section-name .selfRef} {#name-use-of-sha-1}

The majority of the large number of devices that use SCEP today default
to SHA-1, with many supporting only that hash algorithm with no ability
to upgrade to a newer one. SHA-1 is no longer regarded as secure in all
situations, but as used in SCEP, it\'s still safe. There are three
reasons for this. The first is that attacking SCEP would require
creating a fully general SHA-1 collision in close to real time alongside
breaking AES (more specifically, it would require creating a fully
general SHA-1 collision for the PKCS #10 request, breaking the AES
encryption around the PKCS #10 request, and then creating a second SHA-1
collision for the signature on the encrypted data), which won\'t be
feasible for a long time.[¶](#section-7.9-1){.pilcrow}

The second reason is that the signature over the message \-- in other
words, the SHA-1 hash that isn\'t protected by encryption \-- doesn\'t
serve any critical cryptographic purpose: The PKCS #10 data itself is
authenticated through its own signature, protected by encryption, and
the overall request is authorised by the (encrypted) shared secret. The
sole exception to this will be the small number of implementations that
support the Renewal operation, which may be authorised purely through a
signature, but presumably any implementation recent enough to support
Renewal also supports SHA-2. Any legacy implementation that supports the
historic core SCEP protocol would not be
affected.[¶](#section-7.9-2){.pilcrow}

The third reason is that SCEP uses the same key for encryption and
signing, so that even if an attacker were able to capture an outgoing
renewal request that didn\'t include a shared secret (in other words,
one that was only authorised through a signature), break the AES
encryption, forge the SHA-1 hash in real time, and forward the forged
request to the CA, they couldn\'t decrypt the returned certificate,
which is protected with the same key that was used to generate the
signature. While [Section 7.8](#security-unnecessary){.xref} points out
that SCEP uses unnecessary cryptography in places, the additional level
of security provided by the extra crypto makes it immune to any issues
with SHA-1.[¶](#section-7.9-3){.pilcrow}

This doesn\'t mean that SCEP implementations should continue to use
SHA-1 in perpetuity, merely that there\'s no need for a panicked switch
to SHA-2.[¶](#section-7.9-4){.pilcrow}
:::
:::

::: {#section-7.10 .section}
### [7.10.](#section-7.10){.section-number .selfRef} [Use of HTTP](#name-use-of-http){.section-name .selfRef} {#name-use-of-http}

SCEP is an encrypted, authenticated certificate enrollment protocol that
uses HTTP as a simple transport mechanism. Since SCEP messages are
already cryptographically secured, it does not require transport layer
security. Where HTTPS is elected, a performance hit may result from the
TLS overhead, operational problems may result due to the more complex
configuration, and potential security vulnerability may result due to
the addition of an entire TLS protocol stack alongside the basic SCEP
protocol.[¶](#section-7.10-1){.pilcrow}

In particular, experience has shown that the issue of configuring
certificates, CAs, and trust for both TLS and SCEP often leads to
interoperability problems because different certificates and trust
models are used in each. Use of HTTPS to authenticate the server does
not enable omission of the ChallengePassword or similar authenticator in
the SCEP message on the assumption that using HTTPS instead of HTTP will
somehow make this insecure usage secure again. HTTPS is not soy sauce
for security and is unnecessary for SCEP, which uses cryptographically
secured messages and does not require transport layer
security.[¶](#section-7.10-2){.pilcrow}
:::
:::
:::

::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[AES\]
:   [Technology, U. N. I. O. S. A.]{.refAuthor}, [\"The Advanced
    Encryption Standard (AES)\"]{.refTitle}, [FIPS 197]{.seriesInfo},
    [DOI 10.6028/NIST.FIPS.197]{.seriesInfo}, November 2001,
    \<<https://doi.org/10.6028/NIST.FIPS.197>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC2985\]
:   [Nystrom, M.]{.refAuthor}[ and B. Kaliski]{.refAuthor}, [\"PKCS #9:
    Selected Object Classes and Attribute Types Version
    2.0\"]{.refTitle}, [RFC 2985]{.seriesInfo}, [DOI
    10.17487/RFC2985]{.seriesInfo}, November 2000,
    \<<https://www.rfc-editor.org/info/rfc2985>\>.
:   

\[RFC2986\]
:   [Nystrom, M.]{.refAuthor}[ and B. Kaliski]{.refAuthor}, [\"PKCS #10:
    Certification Request Syntax Specification Version
    1.7\"]{.refTitle}, [RFC 2986]{.seriesInfo}, [DOI
    10.17487/RFC2986]{.seriesInfo}, November 2000,
    \<<https://www.rfc-editor.org/info/rfc2986>\>.
:   

\[RFC3986\]
:   [Berners-Lee, T.]{.refAuthor}[, Fielding, R.]{.refAuthor}[, and L.
    Masinter]{.refAuthor}, [\"Uniform Resource Identifier (URI): Generic
    Syntax\"]{.refTitle}, [STD 66]{.seriesInfo}, [RFC
    3986]{.seriesInfo}, [DOI 10.17487/RFC3986]{.seriesInfo}, January
    2005, \<<https://www.rfc-editor.org/info/rfc3986>\>.
:   

\[RFC4648\]
:   [Josefsson, S.]{.refAuthor}, [\"The Base16, Base32, and Base64 Data
    Encodings\"]{.refTitle}, [RFC 4648]{.seriesInfo}, [DOI
    10.17487/RFC4648]{.seriesInfo}, October 2006,
    \<<https://www.rfc-editor.org/info/rfc4648>\>.
:   

\[RFC5234\]
:   [Crocker, D., Ed.]{.refAuthor}[ and P. Overell]{.refAuthor},
    [\"Augmented BNF for Syntax Specifications: ABNF\"]{.refTitle}, [STD
    68]{.seriesInfo}, [RFC 5234]{.seriesInfo}, [DOI
    10.17487/RFC5234]{.seriesInfo}, January 2008,
    \<<https://www.rfc-editor.org/info/rfc5234>\>.
:   

\[RFC5280\]
:   [Cooper, D.]{.refAuthor}[, Santesson, S.]{.refAuthor}[,
    Farrell, S.]{.refAuthor}[, Boeyen, S.]{.refAuthor}[,
    Housley, R.]{.refAuthor}[, and W. Polk]{.refAuthor}, [\"Internet
    X.509 Public Key Infrastructure Certificate and Certificate
    Revocation List (CRL) Profile\"]{.refTitle}, [RFC
    5280]{.seriesInfo}, [DOI 10.17487/RFC5280]{.seriesInfo}, May 2008,
    \<<https://www.rfc-editor.org/info/rfc5280>\>.
:   

\[RFC5652\]
:   [Housley, R.]{.refAuthor}, [\"Cryptographic Message Syntax
    (CMS)\"]{.refTitle}, [STD 70]{.seriesInfo}, [RFC 5652]{.seriesInfo},
    [DOI 10.17487/RFC5652]{.seriesInfo}, September 2009,
    \<<https://www.rfc-editor.org/info/rfc5652>\>.
:   

\[RFC6838\]
:   [Freed, N.]{.refAuthor}[, Klensin, J.]{.refAuthor}[, and T.
    Hansen]{.refAuthor}, [\"Media Type Specifications and Registration
    Procedures\"]{.refTitle}, [BCP 13]{.seriesInfo}, [RFC
    6838]{.seriesInfo}, [DOI 10.17487/RFC6838]{.seriesInfo}, January
    2013, \<<https://www.rfc-editor.org/info/rfc6838>\>.
:   

\[RFC7230\]
:   [Fielding, R., Ed.]{.refAuthor}[ and J. Reschke, Ed.]{.refAuthor},
    [\"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and
    Routing\"]{.refTitle}, [RFC 7230]{.seriesInfo}, [DOI
    10.17487/RFC7230]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7230>\>.
:   

\[RFC7258\]
:   [Farrell, S.]{.refAuthor}[ and H. Tschofenig]{.refAuthor},
    [\"Pervasive Monitoring Is an Attack\"]{.refTitle}, [BCP
    188]{.seriesInfo}, [RFC 7258]{.seriesInfo}, [DOI
    10.17487/RFC7258]{.seriesInfo}, May 2014,
    \<<https://www.rfc-editor.org/info/rfc7258>\>.
:   

\[RFC8126\]
:   [Cotton, M.]{.refAuthor}[, Leiba, B.]{.refAuthor}[, and T.
    Narten]{.refAuthor}, [\"Guidelines for Writing an IANA
    Considerations Section in RFCs\"]{.refTitle}, [BCP 26]{.seriesInfo},
    [RFC 8126]{.seriesInfo}, [DOI 10.17487/RFC8126]{.seriesInfo}, June
    2017, \<<https://www.rfc-editor.org/info/rfc8126>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[SHA2\]
:   [Technology, U. N. I. O. S. A.]{.refAuthor}, [\"Secure Hash Standard
    (SHS)\"]{.refTitle}, [FIPS 180-3]{.seriesInfo}, October 2008.
:   
:::

::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[HTTP\]
:   [Nottingham, M.]{.refAuthor}, [\"Building Protocols with
    HTTP\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-httpbis-bcp56bis-09]{.seriesInfo},
    November 1, 2019,
    \<<https://tools.ietf.org/html/draft-ietf-httpbis-bcp56bis-09>\>.
:   

\[JSCEP\]
:   [\"A Java implementation of the Simple Certificate Enrolment
    Protocol\"]{.refTitle}, [commit 7410332]{.seriesInfo}, January 2020,
    \<<https://github.com/jscep/jscep>\>.
:   

\[RFC2634\]
:   [Hoffman, P., Ed.]{.refAuthor}, [\"Enhanced Security Services for
    S/MIME\"]{.refTitle}, [RFC 2634]{.seriesInfo}, [DOI
    10.17487/RFC2634]{.seriesInfo}, June 1999,
    \<<https://www.rfc-editor.org/info/rfc2634>\>.
:   

\[RFC4387\]
:   [Gutmann, P., Ed.]{.refAuthor}, [\"Internet X.509 Public Key
    Infrastructure Operational Protocols: Certificate Store Access via
    HTTP\"]{.refTitle}, [RFC 4387]{.seriesInfo}, [DOI
    10.17487/RFC4387]{.seriesInfo}, February 2006,
    \<<https://www.rfc-editor.org/info/rfc4387>\>.
:   

\[RFC5035\]
:   [Schaad, J.]{.refAuthor}, [\"Enhanced Security Services (ESS)
    Update: Adding CertID Algorithm Agility\"]{.refTitle}, [RFC
    5035]{.seriesInfo}, [DOI 10.17487/RFC5035]{.seriesInfo}, August
    2007, \<<https://www.rfc-editor.org/info/rfc5035>\>.
:   

\[RFC7296\]
:   [Kaufman, C.]{.refAuthor}[, Hoffman, P.]{.refAuthor}[,
    Nir, Y.]{.refAuthor}[, Eronen, P.]{.refAuthor}[, and T.
    Kivinen]{.refAuthor}, [\"Internet Key Exchange Protocol Version 2
    (IKEv2)\"]{.refTitle}, [STD 79]{.seriesInfo}, [RFC
    7296]{.seriesInfo}, [DOI 10.17487/RFC7296]{.seriesInfo}, October
    2014, \<<https://www.rfc-editor.org/info/rfc7296>\>.
:   

\[RFC8446\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   

\[RFC8551\]
:   [Schaad, J.]{.refAuthor}[, Ramsdell, B.]{.refAuthor}[, and S.
    Turner]{.refAuthor}, [\"Secure/Multipurpose Internet Mail Extensions
    (S/MIME) Version 4.0 Message Specification\"]{.refTitle}, [RFC
    8551]{.seriesInfo}, [DOI 10.17487/RFC8551]{.seriesInfo}, April 2019,
    \<<https://www.rfc-editor.org/info/rfc8551>\>.
:   
:::
:::

::: {#background}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Background Notes](#name-background-notes){.section-name .selfRef} {#name-background-notes}

This specification has spent over twenty years in the draft stage. Its
original goal, provisioning IPsec routers with certificates, has long
since changed to general device/embedded system/IoT use. To fit this
role, extra features were bolted on in a haphazard manner through the
addition of a growing list of appendices and by inserting additional,
often conflicting, paragraphs in various locations in the body text.
Since existing features were never updated as newer ones were added, the
specification accumulated large amounts of historical baggage over time.
If OpenPGP was described as \"a museum of 1990s crypto\", then the SCEP
document was its graveyard.[¶](#section-appendix.a-1){.pilcrow}

About five years ago, the specification, which even at that point had
seen only sporadic reposts of the existing document, was more or less
abandoned by its original sponsors. Due to its widespread use in large
segments of the industry, the specification was rebooted in 2015,
cleaning up fifteen years\' worth of accumulated cruft, fixing errors,
clarifying ambiguities, and bringing the algorithms and standards used
into the current century (prior to the update, the de facto
lowest-common-denominator algorithms used for interoperability were the
insecure forty-year-old single DES and broken MD5 hash
algorithms).[¶](#section-appendix.a-2){.pilcrow}

Note that although the text of the current specification has changed
significantly due to the consolidation of features and appendices into
the main document, the protocol that it describes is identical on the
wire to the original (with the unavoidable exception of the switch from
single DES and MD5 to AES and SHA-2). The only two changes introduced,
the \"SCEPStandard\" indicator in GetCACaps and the failInfoText
attribute, are both optional values and would be ignored by older
implementations that don\'t support them, or can be omitted from
messages if they are found to cause
problems.[¶](#section-appendix.a-3){.pilcrow}

Other changes include:[¶](#section-appendix.a-4){.pilcrow}

-   [Resolved contradictions in the text \-- for example, a requirement
    given as a [MUST]{.bcp14} in one paragraph and a [SHOULD]{.bcp14} in
    the next, a [MUST NOT]{.bcp14} in one paragraph and a [MAY]{.bcp14}
    a few paragraphs later, a [SHOULD NOT]{.bcp14} contradicted later by
    a [MAY]{.bcp14}, and so
    on.[¶](#section-appendix.a-5.1){.pilcrow}]{#section-appendix.a-5.1}
-   [Merged several later fragmentary addenda placed in appendices (for
    example, the handling of certificate renewal) with the body of the
    text.[¶](#section-appendix.a-5.2){.pilcrow}]{#section-appendix.a-5.2}
-   [Merged the \"SCEP Transactions\" and \"SCEP Transport\" sections,
    since the latter mostly duplicated (with occasional inconsistencies)
    the
    former.[¶](#section-appendix.a-5.3){.pilcrow}]{#section-appendix.a-5.3}
-   [Updated the algorithms to ones dating from at least this
    century.[¶](#section-appendix.a-5.4){.pilcrow}]{#section-appendix.a-5.4}
-   [Did the same for normative references to other
    standards.[¶](#section-appendix.a-5.5){.pilcrow}]{#section-appendix.a-5.5}
-   [Updated the text to use consistent terminology for the client and
    CA rather than a mixture of client, requester, requesting system,
    end entity, server, certificate authority, certification authority,
    and
    CA.[¶](#section-appendix.a-5.6){.pilcrow}]{#section-appendix.a-5.6}
-   [Corrected incorrect references to other standards, e.g.,
    IssuerAndSerial -\>
    IssuerAndSerialNumber.[¶](#section-appendix.a-5.7){.pilcrow}]{#section-appendix.a-5.7}
-   [Corrected errors such as a statement that when both signature and
    encryption certificates existed, the signature certificate was used
    for
    encryption.[¶](#section-appendix.a-5.8){.pilcrow}]{#section-appendix.a-5.8}
-   [Condensed redundant discussions of the same topic spread across
    multiple sections into a single location. For example, the
    description of intermediate CA handling previously existed in three
    different locations, with slightly different requirements in each
    one.[¶](#section-appendix.a-5.9){.pilcrow}]{#section-appendix.a-5.9}
-   [Added a description of how pkiMessages were processed, which was
    never made explicit in the original specification. This led to
    creative interpretations that had security problems but were
    employed anyway due to the lack of specific guidance on what to
    do.[¶](#section-appendix.a-5.10){.pilcrow}]{#section-appendix.a-5.10}
-   [Relaxed some requirements that didn\'t serve any obvious purpose
    and that major implementations didn\'t seem to be enforcing. For
    example, the requirement that the self-signed certificate used with
    a request [MUST]{.bcp14} contain a subject name that matched the one
    in the PKCS #10 request was relaxed to a [SHOULD]{.bcp14}, because a
    number of implementations either ignored the issue entirely or at
    worst performed some minor action like creating a log entry, after
    which they continued
    anyway.[¶](#section-appendix.a-5.11){.pilcrow}]{#section-appendix.a-5.11}
-   [Removed discussion of the transactionID from the security
    considerations, since the instructions there were directly
    contradicted by the discussion of the use of the transactionID in
    [Section
    5](#state-trans){.xref}.[¶](#section-appendix.a-5.12){.pilcrow}]{#section-appendix.a-5.12}
-   [Added a requirement that the signed message include the signing
    certificate(s) in the signedData certificates field. This was
    implicit in the original specification (without it, the message
    couldn\'t be verified by the CA) and was handled by the fact that
    most PKCS #7/CMS libraries do this by default, but was never
    explicitly
    mentioned.[¶](#section-appendix.a-5.13){.pilcrow}]{#section-appendix.a-5.13}
-   [Clarified sections that were unclear or even made no sense \-- for
    example, the requirement for a \"hash on the public key\" \[sic\]
    encoded as a
    PrintableString.[¶](#section-appendix.a-5.14){.pilcrow}]{#section-appendix.a-5.14}
-   [Renamed \"RA certificates\" to \"intermediate CA certificates\".
    The original document at some point added mention of RA certificates
    without specifying how the client was to determine that an RA was in
    use, how the RA operations were identified in the protocol, or how
    it was used. It\'s unclear whether what was meant was a true RA or
    merely an intermediate CA, as opposed to the default practice of
    having certificates issued directly from a single root CA
    certificate. This update uses the term \"intermediate CA
    certificates\", since this seems to have been the original intent of
    the
    text.[¶](#section-appendix.a-5.15){.pilcrow}]{#section-appendix.a-5.15}
-   [Redid the PKIMessage diagram to match what was specified in CMS;
    the original diagram omitted a number of fields and nested data
    structures, which meant that the diagram didn\'t match either the
    text or the CMS
    specification.[¶](#section-appendix.a-5.16){.pilcrow}]{#section-appendix.a-5.16}
-   [Removed the requirement for a CertPoll to contain a recipientNonce,
    since CertPoll is a client message and will never be sent in
    response to a message containing a senderNonce. See also the note in
    [Section
    3.3.2](#CertRep){.xref}.[¶](#section-appendix.a-5.17){.pilcrow}]{#section-appendix.a-5.17}
-   [Clarified certificate renewal. This represents a capability that
    was bolted onto the original protocol with (at best) vaguely defined
    semantics, including a requirement by the CA to guess whether a
    particular request was a renewal or not. In response to developer
    feedback that they either avoided renewal entirely because of this
    uncertainty or hard-coded in particular behaviour on a per-CA basis,
    this specification explicitly identifies renewal requests as such
    and provides proper semantics for
    them.[¶](#section-appendix.a-5.18){.pilcrow}]{#section-appendix.a-5.18}
-   [Corrected the requirement that \"undefined message types are
    treated as an error\", since this negates the effect of GetCACaps,
    which is used to define new message types. In particular, operations
    such as GetCACaps \"Renewal\" would be impossible if enforced as
    written, because the Renewal operation was an undefined message type
    at the
    time.[¶](#section-appendix.a-5.19){.pilcrow}]{#section-appendix.a-5.19}
-   [In line with the above, added IANA registries for several entries
    that had previously been defined in an ad hoc manner in different
    locations in the
    text.[¶](#section-appendix.a-5.20){.pilcrow}]{#section-appendix.a-5.20}
-   [Added the \"SCEPStandard\" keyword to GetCACaps to indicate that
    the CA complies with the final version of the SCEP standard, since
    the definition of what constitutes SCEP standards compliance has
    changed significantly over the
    years.[¶](#section-appendix.a-5.21){.pilcrow}]{#section-appendix.a-5.21}
-   [Added the optional failInfoText attribute to deal with the fact
    that failInfo was incapable of adequately communicating to clients
    why a certificate request operation had been
    rejected.[¶](#section-appendix.a-5.22){.pilcrow}]{#section-appendix.a-5.22}
-   [Removed the discussion in the security considerations of revocation
    issues, since SCEP doesn\'t support revocation as part of the
    protocol.[¶](#section-appendix.a-5.23){.pilcrow}]{#section-appendix.a-5.23}
-   [Clarified the use of nonces, which if applied as originally
    specified would have made the use of polling in the presence of a
    lost message
    impossible.[¶](#section-appendix.a-5.24){.pilcrow}]{#section-appendix.a-5.24}
-   [Removed the discussion of generating a given transactionID by
    hashing the public key, since this implied that there was some
    special significance in the value generated this way. Since it was
    neither a [MUST]{.bcp14} nor a [MAY]{.bcp14}, it was unsound to
    imply that servers could rely on the value being generated a certain
    way. In addition, it wouldn\'t work if multiple transactions as
    discussed in [Section 4.4](#poll-resp){.xref} were initiated, since
    the deterministic generation via hashing would lead to duplicate
    transactionIDs.[¶](#section-appendix.a-5.25){.pilcrow}]{#section-appendix.a-5.25}
-   [Added examples of SCEP messages to give implementers something to
    aim
    for.[¶](#section-appendix.a-5.26){.pilcrow}]{#section-appendix.a-5.26}
:::
:::

::: {#ack}
::: {#section-appendix.b .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

The editor would like to thank all of the previous editors, authors, and
contributors for their work maintaining the document over the years:
[Cheryl Madson]{.contact-name}, [Xiaoyi Liu]{.contact-name}, [David
McGrew]{.contact-name}, [David Cooper]{.contact-name}, [Andy
Nourse]{.contact-name}, [Max Pritikin]{.contact-name}, [Jan
Vilhuber]{.contact-name}, and others. The IETF reviewers provided much
useful feedback that helped improve the document, and in particular
spotted a number of things that were present in SCEP through established
practice rather than by being explicitly described in the text. Numerous
other people have contributed during the long life cycle of the
document, and all deserve thanks. In addition, several PKCS #7 / CMS
libraries contributed to interoperability by doing the right thing
despite what earlier SCEP documents
required.[¶](#section-appendix.b-1){.pilcrow}

The authors of earlier draft versions of this document would like to
thank [Peter William]{.contact-name} of ValiCert, Inc. (formerly of
VeriSign, Inc.), [Alex Deacon]{.contact-name} of VeriSign, Inc., and
[Christopher Welles]{.contact-name} of IRE, Inc. for their contributions
to early versions of this protocol and this
document.[¶](#section-appendix.b-2){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.c .section}
## [Author\'s Address](#name-authors-address){.section-name .selfRef} {#name-authors-address}

::: {.left dir="auto"}
[Peter Gutmann]{.fn .nameRole}
:::

::: {.left dir="auto"}
[University of Auckland]{.org}
:::

::: {.left dir="auto"}
[Department of Computer Science]{.street-address}
:::

::: {.left dir="auto"}
[Auckland]{.locality}
:::

::: {.left dir="auto"}
[New Zealand]{.country-name}
:::

::: email
Email: <pgut001@cs.auckland.ac.nz>
:::
:::
:::
