  RFC 9113             HTTP/2            June 2022
  -------------------- ----------------- -----------
  Thomson & Benfield   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9113](https://www.rfc-editor.org/rfc/rfc9113){.eref}

Obsoletes:
:   [7540](https://www.rfc-editor.org/rfc/rfc7540){.eref},
    [8740](https://www.rfc-editor.org/rfc/rfc8740){.eref}

Category:
:   Standards Track

Published:
:   June 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    M. Thomson, [Ed.]{.editor}
    :::

    ::: org
    Mozilla
    :::
    :::

    ::: author
    ::: author-name
    C. Benfield, [Ed.]{.editor}
    :::

    ::: org
    Apple Inc.
    :::
    :::
:::

# RFC 9113 {#rfcnum}

# HTTP/2 {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This specification describes an optimized expression of the semantics of
the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2
(HTTP/2). HTTP/2 enables a more efficient use of network resources and a
reduced latency by introducing field compression and allowing multiple
concurrent exchanges on the same
connection.[¶](#section-abstract-1){.pilcrow}

This document obsoletes RFCs 7540 and
8740.[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9113>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [HTTP/2 Protocol
    Overview](#name-http-2-protocol-overview){.xref}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Document
        Organization](#name-document-organization){.xref}
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [Conventions and
        Terminology](#name-conventions-and-terminology){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Starting
    HTTP/2](#name-starting-http-2){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [HTTP/2 Version
        Identification](#name-http-2-version-identificati){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Starting HTTP/2 for \"`https`\"
        URIs](#name-starting-http-2-for-https-u){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Starting HTTP/2 with Prior
        Knowledge](#name-starting-http-2-with-prior-){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [HTTP/2 Connection
        Preface](#name-http-2-connection-preface){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [HTTP Frames](#name-http-frames){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Frame
        Format](#name-frame-format){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Frame
        Size](#name-frame-size){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Field Section Compression and
        Decompression](#name-field-section-compression-a){.xref}

        -   ::: {#section-toc.1-1.4.2.3.2.1}
            [4.3.1](#section-4.3.1){.xref}.  [Compression
            State](#name-compression-state){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Streams and
    Multiplexing](#name-streams-and-multiplexing){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Stream
        States](#name-stream-states){.xref}

        -   ::: {#section-toc.1-1.5.2.1.2.1}
            [5.1.1](#section-5.1.1){.xref}.  [Stream
            Identifiers](#name-stream-identifiers){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.2}
            [5.1.2](#section-5.1.2){.xref}.  [Stream
            Concurrency](#name-stream-concurrency){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Flow
        Control](#name-flow-control){.xref}

        -   ::: {#section-toc.1-1.5.2.2.2.1}
            [5.2.1](#section-5.2.1){.xref}.  [Flow-Control
            Principles](#name-flow-control-principles){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.2}
            [5.2.2](#section-5.2.2){.xref}.  [Appropriate Use of Flow
            Control](#name-appropriate-use-of-flow-con){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.3}
            [5.2.3](#section-5.2.3){.xref}.  [Flow-Control
            Performance](#name-flow-control-performance){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Prioritization](#name-prioritization){.xref}

        -   ::: {#section-toc.1-1.5.2.3.2.1}
            [5.3.1](#section-5.3.1){.xref}.  [Background on Priority in
            RFC 7540](#name-background-on-priority-in-r){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.2}
            [5.3.2](#section-5.3.2){.xref}.  [Priority Signaling in This
            Document](#name-priority-signaling-in-this-){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [Error
        Handling](#name-error-handling){.xref}

        -   ::: {#section-toc.1-1.5.2.4.2.1}
            [5.4.1](#section-5.4.1){.xref}.  [Connection Error
            Handling](#name-connection-error-handling){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.4.2.2}
            [5.4.2](#section-5.4.2){.xref}.  [Stream Error
            Handling](#name-stream-error-handling){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.4.2.3}
            [5.4.3](#section-5.4.3){.xref}.  [Connection
            Termination](#name-connection-termination){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [Extending
        HTTP/2](#name-extending-http-2){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Frame
    Definitions](#name-frame-definitions){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [DATA](#name-data){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [HEADERS](#name-headers){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [PRIORITY](#name-priority){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [RST_STREAM](#name-rst_stream){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.5}
        [6.5](#section-6.5){.xref}.  [SETTINGS](#name-settings){.xref}

        -   ::: {#section-toc.1-1.6.2.5.2.1}
            [6.5.1](#section-6.5.1){.xref}.  [SETTINGS
            Format](#name-settings-format){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.5.2.2}
            [6.5.2](#section-6.5.2){.xref}.  [Defined
            Settings](#name-defined-settings){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.5.2.3}
            [6.5.3](#section-6.5.3){.xref}.  [Settings
            Synchronization](#name-settings-synchronization){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.6.2.6}
        [6.6](#section-6.6){.xref}.  [PUSH_PROMISE](#name-push_promise){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.7}
        [6.7](#section-6.7){.xref}.  [PING](#name-ping){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.8}
        [6.8](#section-6.8){.xref}.  [GOAWAY](#name-goaway){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.9}
        [6.9](#section-6.9){.xref}.  [WINDOW_UPDATE](#name-window_update){.xref}

        -   ::: {#section-toc.1-1.6.2.9.2.1}
            [6.9.1](#section-6.9.1){.xref}.  [The Flow-Control
            Window](#name-the-flow-control-window){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.9.2.2}
            [6.9.2](#section-6.9.2){.xref}.  [Initial Flow-Control
            Window Size](#name-initial-flow-control-window){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.9.2.3}
            [6.9.3](#section-6.9.3){.xref}.  [Reducing the Stream Window
            Size](#name-reducing-the-stream-window-){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.6.2.10}
        [6.10](#section-6.10){.xref}. [CONTINUATION](#name-continuation){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Error Codes](#name-error-codes){.xref}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Expressing HTTP Semantics in
    HTTP/2](#name-expressing-http-semantics-i){.xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [HTTP Message
        Framing](#name-http-message-framing){.xref}

        -   ::: {#section-toc.1-1.8.2.1.2.1}
            [8.1.1](#section-8.1.1){.xref}.  [Malformed
            Messages](#name-malformed-messages){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [HTTP
        Fields](#name-http-fields){.xref}

        -   ::: {#section-toc.1-1.8.2.2.2.1}
            [8.2.1](#section-8.2.1){.xref}.  [Field
            Validity](#name-field-validity){.xref}
            :::

        -   ::: {#section-toc.1-1.8.2.2.2.2}
            [8.2.2](#section-8.2.2){.xref}.  [Connection-Specific Header
            Fields](#name-connection-specific-header-){.xref}
            :::

        -   ::: {#section-toc.1-1.8.2.2.2.3}
            [8.2.3](#section-8.2.3){.xref}.  [Compressing the Cookie
            Header Field](#name-compressing-the-cookie-head){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [8.3](#section-8.3){.xref}.  [HTTP Control
        Data](#name-http-control-data){.xref}

        -   ::: {#section-toc.1-1.8.2.3.2.1}
            [8.3.1](#section-8.3.1){.xref}.  [Request Pseudo-Header
            Fields](#name-request-pseudo-header-field){.xref}
            :::

        -   ::: {#section-toc.1-1.8.2.3.2.2}
            [8.3.2](#section-8.3.2){.xref}.  [Response Pseudo-Header
            Fields](#name-response-pseudo-header-fiel){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.8.2.4}
        [8.4](#section-8.4){.xref}.  [Server
        Push](#name-server-push){.xref}

        -   ::: {#section-toc.1-1.8.2.4.2.1}
            [8.4.1](#section-8.4.1){.xref}.  [Push
            Requests](#name-push-requests){.xref}
            :::

        -   ::: {#section-toc.1-1.8.2.4.2.2}
            [8.4.2](#section-8.4.2){.xref}.  [Push
            Responses](#name-push-responses){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.8.2.5}
        [8.5](#section-8.5){.xref}.  [The CONNECT
        Method](#name-the-connect-method){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.6}
        [8.6](#section-8.6){.xref}.  [The Upgrade Header
        Field](#name-the-upgrade-header-field){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.7}
        [8.7](#section-8.7){.xref}.  [Request
        Reliability](#name-request-reliability){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.8}
        [8.8](#section-8.8){.xref}.  [Examples](#name-examples){.xref}

        -   ::: {#section-toc.1-1.8.2.8.2.1}
            [8.8.1](#section-8.8.1){.xref}.  [Simple
            Request](#name-simple-request){.xref}
            :::

        -   ::: {#section-toc.1-1.8.2.8.2.2}
            [8.8.2](#section-8.8.2){.xref}.  [Simple
            Response](#name-simple-response){.xref}
            :::

        -   ::: {#section-toc.1-1.8.2.8.2.3}
            [8.8.3](#section-8.8.3){.xref}.  [Complex
            Request](#name-complex-request){.xref}
            :::

        -   ::: {#section-toc.1-1.8.2.8.2.4}
            [8.8.4](#section-8.8.4){.xref}.  [Response with
            Body](#name-response-with-body){.xref}
            :::

        -   ::: {#section-toc.1-1.8.2.8.2.5}
            [8.8.5](#section-8.8.5){.xref}.  [Informational
            Responses](#name-informational-responses){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [HTTP/2
    Connections](#name-http-2-connections){.xref}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Connection
        Management](#name-connection-management){.xref}

        -   ::: {#section-toc.1-1.9.2.1.2.1}
            [9.1.1](#section-9.1.1){.xref}.  [Connection
            Reuse](#name-connection-reuse){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Use of TLS
        Features](#name-use-of-tls-features){.xref}

        -   ::: {#section-toc.1-1.9.2.2.2.1}
            [9.2.1](#section-9.2.1){.xref}.  [TLS 1.2
            Features](#name-tls-12-features){.xref}
            :::

        -   ::: {#section-toc.1-1.9.2.2.2.2}
            [9.2.2](#section-9.2.2){.xref}.  [TLS 1.2 Cipher
            Suites](#name-tls-12-cipher-suites){.xref}
            :::

        -   ::: {#section-toc.1-1.9.2.2.2.3}
            [9.2.3](#section-9.2.3){.xref}.  [TLS 1.3
            Features](#name-tls-13-features){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.10.2.1}
        [10.1](#section-10.1){.xref}.  [Server
        Authority](#name-server-authority){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [10.2](#section-10.2){.xref}.  [Cross-Protocol
        Attacks](#name-cross-protocol-attacks){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.3}
        [10.3](#section-10.3){.xref}.  [Intermediary Encapsulation
        Attacks](#name-intermediary-encapsulation-){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.4}
        [10.4](#section-10.4){.xref}.  [Cacheability of Pushed
        Responses](#name-cacheability-of-pushed-resp){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.5}
        [10.5](#section-10.5){.xref}.  [Denial-of-Service
        Considerations](#name-denial-of-service-considera){.xref}

        -   ::: {#section-toc.1-1.10.2.5.2.1}
            [10.5.1](#section-10.5.1){.xref}.  [Limits on Field Block
            Size](#name-limits-on-field-block-size){.xref}
            :::

        -   ::: {#section-toc.1-1.10.2.5.2.2}
            [10.5.2](#section-10.5.2){.xref}.  [CONNECT
            Issues](#name-connect-issues){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.10.2.6}
        [10.6](#section-10.6){.xref}.  [Use of
        Compression](#name-use-of-compression){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.7}
        [10.7](#section-10.7){.xref}.  [Use of
        Padding](#name-use-of-padding){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.8}
        [10.8](#section-10.8){.xref}.  [Privacy
        Considerations](#name-privacy-considerations){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.9}
        [10.9](#section-10.9){.xref}.  [Remote Timing
        Attacks](#name-remote-timing-attacks){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}

    -   ::: {#section-toc.1-1.11.2.1}
        [11.1](#section-11.1){.xref}.  [HTTP2-Settings Header Field
        Registration](#name-http2-settings-header-field){.xref}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [11.2](#section-11.2){.xref}.  [The h2c Upgrade
        Token](#name-the-h2c-upgrade-token){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.12.2.1}
        [12.1](#section-12.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [12.2](#section-12.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [Appendix A](#appendix-A){.xref}.  [Prohibited TLS 1.2 Cipher
    Suites](#name-prohibited-tls-12-cipher-su){.xref}
    :::

-   ::: {#section-toc.1-1.14}
    [Appendix B](#appendix-B){.xref}.  [Changes from RFC
    7540](#name-changes-from-rfc-7540){.xref}
    :::

-   ::: {#section-toc.1-1.15}
    [](#appendix-C){.xref}[Acknowledgments](#name-acknowledgments){.xref}
    :::

-   ::: {#section-toc.1-1.16}
    [](#appendix-D){.xref}[Contributors](#name-contributors){.xref}
    :::

-   ::: {#section-toc.1-1.17}
    [](#appendix-E){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#intro}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The performance of applications using the Hypertext Transfer Protocol
(HTTP, \[[HTTP](#RFC9110){.xref}\]) is linked to how each version of
HTTP uses the underlying transport, and the conditions under which the
transport operates.[¶](#section-1-1){.pilcrow}

Making multiple concurrent requests can reduce latency and improve
application performance. HTTP/1.0 allowed only one request to be
outstanding at a time on a given TCP \[[TCP](#RFC0793){.xref}\]
connection. HTTP/1.1 \[[HTTP/1.1](#RFC9112){.xref}\] added request
pipelining, but this only partially addressed request concurrency and
still suffers from application-layer head-of-line blocking. Therefore,
HTTP/1.0 and HTTP/1.1 clients use multiple connections to a server to
make concurrent requests.[¶](#section-1-2){.pilcrow}

Furthermore, HTTP fields are often repetitive and verbose, causing
unnecessary network traffic as well as causing the initial TCP
congestion window to quickly fill. This can result in excessive latency
when multiple requests are made on a new TCP
connection.[¶](#section-1-3){.pilcrow}

HTTP/2 addresses these issues by defining an optimized mapping of
HTTP\'s semantics to an underlying connection. Specifically, it allows
interleaving of messages on the same connection and uses an efficient
coding for HTTP fields. It also allows prioritization of requests,
letting more important requests complete more quickly, further improving
performance.[¶](#section-1-4){.pilcrow}

The resulting protocol is more friendly to the network because fewer TCP
connections can be used in comparison to HTTP/1.x. This means less
competition with other flows and longer-lived connections, which in turn
lead to better utilization of available network capacity. Note, however,
that TCP head-of-line blocking is not addressed by this
protocol.[¶](#section-1-5){.pilcrow}

Finally, HTTP/2 also enables more efficient processing of messages
through use of binary message framing.[¶](#section-1-6){.pilcrow}

This document obsoletes RFCs 7540 and 8740. [Appendix
B](#revision-updates){.xref} lists notable
changes.[¶](#section-1-7){.pilcrow}
:::
:::

::: {#Overview}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [HTTP/2 Protocol Overview](#name-http-2-protocol-overview){.section-name .selfRef} {#name-http-2-protocol-overview}

HTTP/2 provides an optimized transport for HTTP semantics. HTTP/2
supports all of the core features of HTTP but aims to be more efficient
than HTTP/1.1.[¶](#section-2-1){.pilcrow}

HTTP/2 is a connection-oriented application-layer protocol that runs
over a TCP connection (\[[TCP](#RFC0793){.xref}\]). The client is the
TCP connection initiator.[¶](#section-2-2){.pilcrow}

The basic protocol unit in HTTP/2 is a [frame](#FrameHeader){.xref}
([Section 4.1](#FrameHeader){.xref}). Each frame type serves a different
purpose. For example, [HEADERS](#HEADERS){.xref} and
[DATA](#DATA){.xref} frames form the basis of [HTTP requests and
responses](#HttpFraming){.xref} ([Section 8.1](#HttpFraming){.xref});
other frame types like [SETTINGS](#SETTINGS){.xref},
[WINDOW_UPDATE](#WINDOW_UPDATE){.xref}, and
[PUSH_PROMISE](#PUSH_PROMISE){.xref} are used in support of other HTTP/2
features.[¶](#section-2-3){.pilcrow}

Multiplexing of requests is achieved by having each HTTP
request/response exchange associated with its own
[stream](#StreamsLayer){.xref} ([Section 5](#StreamsLayer){.xref}).
Streams are largely independent of each other, so a blocked or stalled
request or response does not prevent progress on other
streams.[¶](#section-2-4){.pilcrow}

Effective use of multiplexing depends on flow control and
prioritization. [Flow control](#FlowControl){.xref} ([Section
5.2](#FlowControl){.xref}) ensures that it is possible to efficiently
use multiplexed streams by restricting data that is transmitted to what
the receiver is able to handle. [Prioritization](#StreamPriority){.xref}
([Section 5.3](#StreamPriority){.xref}) ensures that limited resources
are used most effectively. This revision of HTTP/2 deprecates the
priority signaling scheme from
\[[RFC7540](#RFC7540){.xref}\].[¶](#section-2-5){.pilcrow}

Because HTTP fields used in a connection can contain large amounts of
redundant data, frames that contain them are
[compressed](#FieldBlock){.xref} ([Section 4.3](#FieldBlock){.xref}).
This has especially advantageous impact upon request sizes in the common
case, allowing many requests to be compressed into one
packet.[¶](#section-2-6){.pilcrow}

Finally, HTTP/2 adds a new, optional interaction mode whereby a server
can [push responses to a client](#PushResources){.xref} ([Section
8.4](#PushResources){.xref}). This is intended to allow a server to
speculatively send data to a client that the server anticipates the
client will need, trading off some network usage against a potential
latency gain. The server does this by synthesizing a request, which it
sends as a [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame. The server is
then able to send a response to the synthetic request on a separate
stream.[¶](#section-2-7){.pilcrow}

::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Document Organization](#name-document-organization){.section-name .selfRef} {#name-document-organization}

The HTTP/2 specification is split into four
parts:[¶](#section-2.1-1){.pilcrow}

-   [[Starting HTTP/2](#starting){.xref} ([Section 3](#starting){.xref})
    covers how an HTTP/2 connection is
    initiated.[¶](#section-2.1-2.1){.pilcrow}]{#section-2.1-2.1}
-   [The [frame](#FramingLayer){.xref} ([Section
    4](#FramingLayer){.xref}) and [stream](#StreamsLayer){.xref}
    ([Section 5](#StreamsLayer){.xref}) layers describe the way HTTP/2
    frames are structured and formed into multiplexed
    streams.[¶](#section-2.1-2.2){.pilcrow}]{#section-2.1-2.2}
-   [[Frame](#FrameTypes){.xref} ([Section 6](#FrameTypes){.xref}) and
    [error](#ErrorCodes){.xref} ([Section 7](#ErrorCodes){.xref})
    definitions include details of the frame and error types used in
    HTTP/2.[¶](#section-2.1-2.3){.pilcrow}]{#section-2.1-2.3}
-   [[HTTP mappings](#HttpLayer){.xref} ([Section 8](#HttpLayer){.xref})
    and [additional requirements](#HttpExtra){.xref} ([Section
    9](#HttpExtra){.xref}) describe how HTTP semantics are expressed
    using frames and
    streams.[¶](#section-2.1-2.4){.pilcrow}]{#section-2.1-2.4}

While some of the frame- and stream-layer concepts are isolated from
HTTP, this specification does not define a completely generic frame
layer. The frame and stream layers are tailored to the needs of
HTTP.[¶](#section-2.1-3){.pilcrow}
:::

::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [Conventions and Terminology](#name-conventions-and-terminology){.section-name .selfRef} {#name-conventions-and-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2.2-1){.pilcrow}

All numeric values are in network byte order. Values are unsigned unless
otherwise indicated. Literal values are provided in decimal or
hexadecimal as appropriate. Hexadecimal literals are prefixed with
\"`0x`\" to distinguish them from decimal
literals.[¶](#section-2.2-2){.pilcrow}

This specification describes binary formats using the conventions
described in [Section
1.3](https://www.rfc-editor.org/rfc/rfc9000#section-1.3){.relref} of RFC
9000 \[[QUIC](#RFC9000){.xref}\]. Note that this format uses network
byte order and that high-valued bits are listed before low-valued
bits.[¶](#section-2.2-3){.pilcrow}

The following terms are used:[¶](#section-2.2-4){.pilcrow}

[]{.break}

client:
:   The endpoint that initiates an HTTP/2 connection. Clients send HTTP
    requests and receive HTTP responses.[¶](#section-2.2-5.2){.pilcrow}
:   

connection:
:   A transport-layer connection between two
    endpoints.[¶](#section-2.2-5.4){.pilcrow}
:   

connection error:
:   An error that affects the entire HTTP/2
    connection.[¶](#section-2.2-5.6){.pilcrow}
:   

endpoint:
:   Either the client or server of the
    connection.[¶](#section-2.2-5.8){.pilcrow}
:   

frame:
:   The smallest unit of communication within an HTTP/2 connection,
    consisting of a header and a variable-length sequence of octets
    structured according to the frame
    type.[¶](#section-2.2-5.10){.pilcrow}
:   

peer:
:   An endpoint. When discussing a particular endpoint, \"peer\" refers
    to the endpoint that is remote to the primary subject of
    discussion.[¶](#section-2.2-5.12){.pilcrow}
:   

receiver:
:   An endpoint that is receiving
    frames.[¶](#section-2.2-5.14){.pilcrow}
:   

sender:
:   An endpoint that is transmitting
    frames.[¶](#section-2.2-5.16){.pilcrow}
:   

server:
:   The endpoint that accepts an HTTP/2 connection. Servers receive HTTP
    requests and send HTTP responses.[¶](#section-2.2-5.18){.pilcrow}
:   

stream:
:   A bidirectional flow of frames within the HTTP/2
    connection.[¶](#section-2.2-5.20){.pilcrow}
:   

stream error:
:   An error on the individual HTTP/2
    stream.[¶](#section-2.2-5.22){.pilcrow}
:   

Finally, the terms \"gateway\", \"intermediary\", \"proxy\", and
\"tunnel\" are defined in [Section
3.7](https://www.rfc-editor.org/rfc/rfc9110#section-3.7){.relref} of
\[[HTTP](#RFC9110){.xref}\]. Intermediaries act as both client and
server at different times.[¶](#section-2.2-6){.pilcrow}

The term \"content\" as it applies to message bodies is defined in
[Section
6.4](https://www.rfc-editor.org/rfc/rfc9110#section-6.4){.relref} of
\[[HTTP](#RFC9110){.xref}\].[¶](#section-2.2-7){.pilcrow}
:::
:::
:::

::: {#starting}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Starting HTTP/2](#name-starting-http-2){.section-name .selfRef} {#name-starting-http-2}

Implementations that generate HTTP requests need to discover whether a
server supports HTTP/2.[¶](#section-3-1){.pilcrow}

HTTP/2 uses the \"`http`\" and \"`https`\" URI schemes defined in
[Section
4.2](https://www.rfc-editor.org/rfc/rfc9110#section-4.2){.relref} of
\[[HTTP](#RFC9110){.xref}\], with the same default port numbers as
HTTP/1.1 \[[HTTP/1.1](#RFC9112){.xref}\]. These URIs do not include any
indication about what HTTP versions an upstream server (the immediate
peer to which the client wishes to establish a connection)
supports.[¶](#section-3-2){.pilcrow}

The means by which support for HTTP/2 is determined is different for
\"`http`\" and \"`https`\" URIs. Discovery for \"`https`\" URIs is
described in [Section 3.2](#discover-https){.xref}. HTTP/2 support for
\"`http`\" URIs can only be discovered by out-of-band means and requires
prior knowledge of the support as described in [Section
3.3](#known-http){.xref}.[¶](#section-3-3){.pilcrow}

::: {#versioning}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [HTTP/2 Version Identification](#name-http-2-version-identificati){.section-name .selfRef} {#name-http-2-version-identificati}

The protocol defined in this document has two identifiers. Creating a
connection based on either implies the use of the transport, framing,
and message semantics described in this
document.[¶](#section-3.1-1){.pilcrow}

-   ::: {#section-3.1-2.1}
    The string \"h2\" identifies the protocol where HTTP/2 uses
    Transport Layer Security (TLS); see [Section 9.2](#TLSUsage){.xref}.
    This identifier is used in the [TLS Application-Layer Protocol
    Negotiation (ALPN) extension](#RFC7301){.xref}
    \[[TLS-ALPN](#RFC7301){.xref}\] field and in any place where HTTP/2
    over TLS is identified.[¶](#section-3.1-2.1.1){.pilcrow}

    The \"h2\" string is serialized into an ALPN protocol identifier as
    the two-octet sequence: 0x68, 0x32.[¶](#section-3.1-2.1.2){.pilcrow}
    :::

-   ::: {#section-3.1-2.2}
    The \"h2c\" string was previously used as a token for use in the
    HTTP Upgrade mechanism\'s Upgrade header field ([Section
    7.8](https://www.rfc-editor.org/rfc/rfc9110#section-7.8){.relref} of
    \[[HTTP](#RFC9110){.xref}\]). This usage was never widely deployed
    and is deprecated by this document. The same applies to the
    HTTP2-Settings header field, which was used with the upgrade to
    \"h2c\".[¶](#section-3.1-2.2.1){.pilcrow}
    :::
:::
:::

::: {#discover-https}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Starting HTTP/2 for \"`https`\" URIs](#name-starting-http-2-for-https-u){.section-name .selfRef} {#name-starting-http-2-for-https-u}

A client that makes a request to an \"`https`\" URI uses
[TLS](#RFC8446){.xref} \[[TLS13](#RFC8446){.xref}\] with the [ALPN
extension](#RFC7301){.xref}
\[[TLS-ALPN](#RFC7301){.xref}\].[¶](#section-3.2-1){.pilcrow}

HTTP/2 over TLS uses the \"h2\" protocol identifier. The \"h2c\"
protocol identifier [MUST NOT]{.bcp14} be sent by a client or selected
by a server; the \"h2c\" protocol identifier describes a protocol that
does not use TLS.[¶](#section-3.2-2){.pilcrow}

Once TLS negotiation is complete, both the client and the server
[MUST]{.bcp14} send a [connection preface](#preface){.xref} ([Section
3.4](#preface){.xref}).[¶](#section-3.2-3){.pilcrow}
:::
:::

::: {#known-http}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Starting HTTP/2 with Prior Knowledge](#name-starting-http-2-with-prior-){.section-name .selfRef} {#name-starting-http-2-with-prior-}

A client can learn that a particular server supports HTTP/2 by other
means. For example, a client could be configured with knowledge that a
server supports HTTP/2.[¶](#section-3.3-1){.pilcrow}

A client that knows that a server supports HTTP/2 can establish a TCP
connection and send the [connection preface](#preface){.xref} ([Section
3.4](#preface){.xref}) followed by HTTP/2 frames. Servers can identify
these connections by the presence of the connection preface. This only
affects the establishment of HTTP/2 connections over cleartext TCP;
HTTP/2 connections over TLS [MUST]{.bcp14} use [protocol negotiation in
TLS](#RFC7301){.xref}
\[[TLS-ALPN](#RFC7301){.xref}\].[¶](#section-3.3-2){.pilcrow}

Likewise, the server [MUST]{.bcp14} send a [connection
preface](#preface){.xref} ([Section
3.4](#preface){.xref}).[¶](#section-3.3-3){.pilcrow}

Without additional information, prior support for HTTP/2 is not a strong
signal that a given server will support HTTP/2 for future connections.
For example, it is possible for server configurations to change, for
configurations to differ between instances in clustered servers, or for
network conditions to change.[¶](#section-3.3-4){.pilcrow}
:::
:::

::: {#preface}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [HTTP/2 Connection Preface](#name-http-2-connection-preface){.section-name .selfRef} {#name-http-2-connection-preface}

In HTTP/2, each endpoint is required to send a connection preface as a
final confirmation of the protocol in use and to establish the initial
settings for the HTTP/2 connection. The client and server each send a
different connection preface.[¶](#section-3.4-1){.pilcrow}

The client connection preface starts with a sequence of 24 octets, which
in hex notation is:[¶](#section-3.4-2){.pilcrow}

::: {#section-3.4-3 .alignLeft .art-inline .art-text .artwork}
      0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a

[¶](#section-3.4-3){.pilcrow}
:::

That is, the connection preface starts with the string
\"`PRI *           HTTP/2.0\r\n\r\nSM\r\n\r\n`\". This sequence
[MUST]{.bcp14} be followed by a [SETTINGS](#SETTINGS){.xref} frame
([Section 6.5](#SETTINGS){.xref}), which [MAY]{.bcp14} be empty. The
client sends the client connection preface as the first application data
octets of a connection.[¶](#section-3.4-4){.pilcrow}

Note: The client connection preface is selected so that a large
proportion of HTTP/1.1 or HTTP/1.0 servers and intermediaries do not
attempt to process further frames. Note that this does not address the
concerns raised in
\[[TALKING](#TALKING){.xref}\].[¶](#section-3.4-5.1){.pilcrow}

The server connection preface consists of a potentially empty
[SETTINGS](#SETTINGS){.xref} frame ([Section 6.5](#SETTINGS){.xref})
that [MUST]{.bcp14} be the first frame the server sends in the HTTP/2
connection.[¶](#section-3.4-6){.pilcrow}

The [SETTINGS](#SETTINGS){.xref} frames received from a peer as part of
the connection preface [MUST]{.bcp14} be acknowledged (see [Section
6.5.3](#SettingsSync){.xref}) after sending the connection
preface.[¶](#section-3.4-7){.pilcrow}

To avoid unnecessary latency, clients are permitted to send additional
frames to the server immediately after sending the client connection
preface, without waiting to receive the server connection preface. It is
important to note, however, that the server connection preface
[SETTINGS](#SETTINGS){.xref} frame might include settings that
necessarily alter how a client is expected to communicate with the
server. Upon receiving the [SETTINGS](#SETTINGS){.xref} frame, the
client is expected to honor any settings established. In some
configurations, it is possible for the server to transmit
[SETTINGS](#SETTINGS){.xref} before the client sends additional frames,
providing an opportunity to avoid this
issue.[¶](#section-3.4-8){.pilcrow}

Clients and servers [MUST]{.bcp14} treat an invalid connection preface
as a [connection error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}. A [GOAWAY](#GOAWAY){.xref}
frame ([Section 6.8](#GOAWAY){.xref}) [MAY]{.bcp14} be omitted in this
case, since an invalid preface indicates that the peer is not using
HTTP/2.[¶](#section-3.4-9){.pilcrow}
:::
:::
:::
:::

::: {#FramingLayer}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [HTTP Frames](#name-http-frames){.section-name .selfRef} {#name-http-frames}

Once the HTTP/2 connection is established, endpoints can begin
exchanging frames.[¶](#section-4-1){.pilcrow}

::: {#FrameHeader}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Frame Format](#name-frame-format){.section-name .selfRef} {#name-frame-format}

All frames begin with a fixed 9-octet header followed by a
variable-length frame payload.[¶](#section-4.1-1){.pilcrow}

[]{#name-frame-layout}

::: {#FrameLayout}
::: {#section-4.1-2.1 .alignLeft .art-inline .art-text .artwork}
    HTTP Frame {
      Length (24),
      Type (8),

      Flags (8),

      Reserved (1),
      Stream Identifier (31),

      Frame Payload (..),
    }
:::

[Figure 1](#figure-1){.selfRef}: [Frame
Layout](#name-frame-layout){.selfRef}
:::

The fields of the frame header are defined
as:[¶](#section-4.1-3){.pilcrow}

[]{.break}

Length:

:   The length of the frame payload expressed as an unsigned 24-bit
    integer in units of octets. Values greater than 2^14^ (16,384) [MUST
    NOT]{.bcp14} be sent unless the receiver has set a larger value for
    [SETTINGS_MAX_FRAME_SIZE](#SETTINGS_MAX_FRAME_SIZE){.xref}.[¶](#section-4.1-4.2.1){.pilcrow}

    The 9 octets of the frame header are not included in this
    value.[¶](#section-4.1-4.2.2){.pilcrow}

:   

Type:

:   The 8-bit type of the frame. The frame type determines the format
    and semantics of the frame. Frames defined in this document are
    listed in [Section 6](#FrameTypes){.xref}. Implementations
    [MUST]{.bcp14} ignore and discard frames of unknown
    types.[¶](#section-4.1-4.4.1){.pilcrow}

:   

Flags:

:   An 8-bit field reserved for boolean flags specific to the frame
    type.[¶](#section-4.1-4.6.1){.pilcrow}

    Flags are assigned semantics specific to the indicated frame type.
    Unused flags are those that have no defined semantics for a
    particular frame type. Unused flags [MUST]{.bcp14} be ignored on
    receipt and [MUST]{.bcp14} be left unset (0x00) when
    sending.[¶](#section-4.1-4.6.2){.pilcrow}

:   

Reserved:

:   A reserved 1-bit field. The semantics of this bit are undefined, and
    the bit [MUST]{.bcp14} remain unset (0x00) when sending and
    [MUST]{.bcp14} be ignored when
    receiving.[¶](#section-4.1-4.8.1){.pilcrow}

:   

Stream Identifier:

:   A stream identifier (see [Section 5.1.1](#StreamIdentifiers){.xref})
    expressed as an unsigned 31-bit integer. The value 0x00 is reserved
    for frames that are associated with the connection as a whole as
    opposed to an individual stream.[¶](#section-4.1-4.10.1){.pilcrow}

:   

The structure and content of the frame payload are dependent entirely on
the frame type.[¶](#section-4.1-5){.pilcrow}
:::
:::

::: {#FrameSize}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Frame Size](#name-frame-size){.section-name .selfRef} {#name-frame-size}

The size of a frame payload is limited by the maximum size that a
receiver advertises in the
[SETTINGS_MAX_FRAME_SIZE](#SETTINGS_MAX_FRAME_SIZE){.xref} setting. This
setting can have any value between 2^14^ (16,384) and 2^24^-1
(16,777,215) octets, inclusive.[¶](#section-4.2-1){.pilcrow}

All implementations [MUST]{.bcp14} be capable of receiving and minimally
processing frames up to 2^14^ octets in length, plus the 9-octet [frame
header](#FrameHeader){.xref} ([Section 4.1](#FrameHeader){.xref}). The
size of the frame header is not included when describing frame
sizes.[¶](#section-4.2-2){.pilcrow}

Note: Certain frame types, such as [PING](#PING){.xref} ([Section
6.7](#PING){.xref}), impose additional limits on the amount of frame
payload data allowed.[¶](#section-4.2-3.1){.pilcrow}

An endpoint [MUST]{.bcp14} send an error code of
[FRAME_SIZE_ERROR](#FRAME_SIZE_ERROR){.xref} if a frame exceeds the size
defined in [SETTINGS_MAX_FRAME_SIZE](#SETTINGS_MAX_FRAME_SIZE){.xref},
exceeds any limit defined for the frame type, or is too small to contain
mandatory frame data. A frame size error in a frame that could alter the
state of the entire connection [MUST]{.bcp14} be treated as a
[connection error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}); this includes any frame
carrying a [field block](#FieldBlock){.xref} ([Section
4.3](#FieldBlock){.xref}) (that is, [HEADERS](#HEADERS){.xref},
[PUSH_PROMISE](#PUSH_PROMISE){.xref}, and
[CONTINUATION](#CONTINUATION){.xref}), a [SETTINGS](#SETTINGS){.xref}
frame, and any frame with a stream identifier of
0.[¶](#section-4.2-4){.pilcrow}

Endpoints are not obligated to use all available space in a frame.
Responsiveness can be improved by using frames that are smaller than the
permitted maximum size. Sending large frames can result in delays in
sending time-sensitive frames (such as [RST_STREAM](#RST_STREAM){.xref},
[WINDOW_UPDATE](#WINDOW_UPDATE){.xref}, or
[PRIORITY](#PRIORITY){.xref}), which, if blocked by the transmission of
a large frame, could affect performance.[¶](#section-4.2-5){.pilcrow}
:::
:::

::: {#FieldBlock}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Field Section Compression and Decompression](#name-field-section-compression-a){.section-name .selfRef} {#name-field-section-compression-a}

Field section compression is the process of compressing a set of field
lines ([Section
5.2](https://www.rfc-editor.org/rfc/rfc9110#section-5.2){.relref} of
\[[HTTP](#RFC9110){.xref}\]) to form a field block. Field section
decompression is the process of decoding a field block into a set of
field lines. Details of HTTP/2 field section compression and
decompression are defined in \[[COMPRESSION](#RFC7541){.xref}\], which,
for historical reasons, refers to these processes as header compression
and decompression.[¶](#section-4.3-1){.pilcrow}

Each field block carries all of the compressed field lines of a single
field section. Header sections also include control data associated with
the message in the form of [pseudo-header
fields](#PseudoHeaderFields){.xref} ([Section
8.3](#PseudoHeaderFields){.xref}) that use the same format as a field
line.[¶](#section-4.3-2){.pilcrow}

Note: [RFC 7540](#RFC7540){.xref} \[[RFC7540](#RFC7540){.xref}\] used
the term \"header block\" in place of the more generic \"field
block\".[¶](#section-4.3-3.1){.pilcrow}

Field blocks carry control data and header sections for requests,
responses, promised requests, and pushed responses (see [Section
8.4](#PushResources){.xref}). All these messages, except for interim
responses and requests contained in [PUSH_PROMISE](#PUSH_PROMISE){.xref}
([Section 6.6](#PUSH_PROMISE){.xref}) frames, can optionally include a
field block that carries a trailer section.[¶](#section-4.3-4){.pilcrow}

A field section is a collection of field lines. Each of the field lines
in a field block carries a single value. The serialized field block is
then divided into one or more octet sequences, called field block
fragments. The first field block fragment is transmitted within the
frame payload of [HEADERS](#HEADERS){.xref} ([Section
6.2](#HEADERS){.xref}) or [PUSH_PROMISE](#PUSH_PROMISE){.xref} ([Section
6.6](#PUSH_PROMISE){.xref}), each of which could be followed by
[CONTINUATION](#CONTINUATION){.xref} ([Section
6.10](#CONTINUATION){.xref}) frames to carry subsequent field block
fragments.[¶](#section-4.3-5){.pilcrow}

The [Cookie header field](#RFC6265){.xref} \[[COOKIE](#RFC6265){.xref}\]
is treated specially by the HTTP mapping (see [Section
8.2.3](#CompressCookie){.xref}).[¶](#section-4.3-6){.pilcrow}

A receiving endpoint reassembles the field block by concatenating its
fragments and then decompresses the block to reconstruct the field
section.[¶](#section-4.3-7){.pilcrow}

A complete field section consists of
either:[¶](#section-4.3-8){.pilcrow}

-   [a single [HEADERS](#HEADERS){.xref} or
    [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame, with the END_HEADERS
    flag set, or[¶](#section-4.3-9.1){.pilcrow}]{#section-4.3-9.1}
-   [a [HEADERS](#HEADERS){.xref} or
    [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame with the END_HEADERS flag
    unset and one or more [CONTINUATION](#CONTINUATION){.xref} frames,
    where the last [CONTINUATION](#CONTINUATION){.xref} frame has the
    END_HEADERS flag
    set.[¶](#section-4.3-9.2){.pilcrow}]{#section-4.3-9.2}

Each field block is processed as a discrete unit. Field blocks
[MUST]{.bcp14} be transmitted as a contiguous sequence of frames, with
no interleaved frames of any other type or from any other stream. The
last frame in a sequence of [HEADERS](#HEADERS){.xref} or
[CONTINUATION](#CONTINUATION){.xref} frames has the END_HEADERS flag
set. The last frame in a sequence of
[PUSH_PROMISE](#PUSH_PROMISE){.xref} or
[CONTINUATION](#CONTINUATION){.xref} frames has the END_HEADERS flag
set. This allows a field block to be logically equivalent to a single
frame.[¶](#section-4.3-10){.pilcrow}

Field block fragments can only be sent as the frame payload of
[HEADERS](#HEADERS){.xref}, [PUSH_PROMISE](#PUSH_PROMISE){.xref}, or
[CONTINUATION](#CONTINUATION){.xref} frames because these frames carry
data that can modify the compression context maintained by a receiver.
An endpoint receiving [HEADERS](#HEADERS){.xref},
[PUSH_PROMISE](#PUSH_PROMISE){.xref}, or
[CONTINUATION](#CONTINUATION){.xref} frames needs to reassemble field
blocks and perform decompression even if the frames are to be discarded.
A receiver [MUST]{.bcp14} terminate the connection with a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[COMPRESSION_ERROR](#COMPRESSION_ERROR){.xref} if it does not decompress
a field block.[¶](#section-4.3-11){.pilcrow}

A decoding error in a field block [MUST]{.bcp14} be treated as a
[connection error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[COMPRESSION_ERROR](#COMPRESSION_ERROR){.xref}.[¶](#section-4.3-12){.pilcrow}

::: {#dynamic-table}
::: {#section-4.3.1 .section}
#### [4.3.1.](#section-4.3.1){.section-number .selfRef} [Compression State](#name-compression-state){.section-name .selfRef} {#name-compression-state}

Field compression is stateful. Each endpoint has an HPACK encoder
context and an HPACK decoder context that are used for encoding and
decoding all field blocks on a connection. [Section
4](https://www.rfc-editor.org/rfc/rfc7541#section-4){.relref} of
\[[COMPRESSION](#RFC7541){.xref}\] defines the dynamic table, which is
the primary state for each context.[¶](#section-4.3.1-1){.pilcrow}

The dynamic table has a maximum size that is set by an HPACK decoder. An
endpoint communicates the size chosen by its HPACK decoder context using
the SETTINGS_HEADER_TABLE_SIZE setting; see [Section
6.5.2](#SettingValues){.xref}. When a connection is established, the
dynamic table size for the HPACK decoder and encoder at both endpoints
starts at 4,096 bytes, the initial value of the
SETTINGS_HEADER_TABLE_SIZE setting.[¶](#section-4.3.1-2){.pilcrow}

Any change to the maximum value set using SETTINGS_HEADER_TABLE_SIZE
takes effect when the endpoint [acknowledges
settings](#SettingsSync){.xref} ([Section 6.5.3](#SettingsSync){.xref}).
The HPACK encoder at that endpoint can set the dynamic table to any size
up to the maximum value set by the decoder. An HPACK encoder declares
the size of the dynamic table with a Dynamic Table Size Update
instruction ([Section
6.3](https://www.rfc-editor.org/rfc/rfc7541#section-6.3){.relref} of
\[[COMPRESSION](#RFC7541){.xref}\]).[¶](#section-4.3.1-3){.pilcrow}

Once an endpoint acknowledges a change to SETTINGS_HEADER_TABLE_SIZE
that reduces the maximum below the current size of the dynamic table,
its HPACK encoder [MUST]{.bcp14} start the next field block with a
Dynamic Table Size Update instruction that sets the dynamic table to a
size that is less than or equal to the reduced maximum; see [Section
4.2](https://www.rfc-editor.org/rfc/rfc7541#section-4.2){.relref} of
\[[COMPRESSION](#RFC7541){.xref}\]. An endpoint [MUST]{.bcp14} treat a
field block that follows an acknowledgment of the reduction to the
maximum dynamic table size as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[COMPRESSION_ERROR](#COMPRESSION_ERROR){.xref} if it does not start with
a conformant Dynamic Table Size Update
instruction.[¶](#section-4.3.1-4){.pilcrow}

Implementers are advised that reducing the value of
SETTINGS_HEADER_TABLE_SIZE is not widely interoperable. Use of the
connection preface to reduce the value below the initial value of 4,096
is somewhat better supported, but this might fail with some
implementations.[¶](#section-4.3.1-5.1){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#StreamsLayer}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Streams and Multiplexing](#name-streams-and-multiplexing){.section-name .selfRef} {#name-streams-and-multiplexing}

A \"stream\" is an independent, bidirectional sequence of frames
exchanged between the client and server within an HTTP/2 connection.
Streams have several important
characteristics:[¶](#section-5-1){.pilcrow}

-   [A single HTTP/2 connection can contain multiple concurrently open
    streams, with either endpoint interleaving frames from multiple
    streams.[¶](#section-5-2.1){.pilcrow}]{#section-5-2.1}
-   [Streams can be established and used unilaterally or shared by
    either endpoint.[¶](#section-5-2.2){.pilcrow}]{#section-5-2.2}
-   [Streams can be closed by either
    endpoint.[¶](#section-5-2.3){.pilcrow}]{#section-5-2.3}
-   [The order in which frames are sent is significant. Recipients
    process frames in the order they are received. In particular, the
    order of [HEADERS](#HEADERS){.xref} and [DATA](#DATA){.xref} frames
    is semantically
    significant.[¶](#section-5-2.4){.pilcrow}]{#section-5-2.4}
-   [Streams are identified by an integer. Stream identifiers are
    assigned to streams by the endpoint initiating the
    stream.[¶](#section-5-2.5){.pilcrow}]{#section-5-2.5}

::: {#StreamStates}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Stream States](#name-stream-states){.section-name .selfRef} {#name-stream-states}

The lifecycle of a stream is shown in [Figure
2](#StreamStatesFigure){.xref}.[¶](#section-5.1-1){.pilcrow}

[]{#name-stream-states-2}

::: {#StreamStatesFigure}
::: {#section-5.1-2.1}
::: {#section-5.1-2.1.1 .alignLeft .art-svg .artwork}
![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgaGVpZ2h0PSI0ODAiIHdpZHRoPSI0ODgiIHZpZXdib3g9IjAgMCA0ODggNDgwIiBjbGFzcz0iZGlhZ3JhbSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1mYW1pbHk9Im1vbm9zcGFjZSIgZm9udC1zaXplPSIxM3B4Ij4KICAgICAgICAgICAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDgsMTYpIj4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSAwLDExMiBMIDAsNDE2IiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gNTYsODAgTCA1NiwxNDQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSA1NiwyNDAgTCA1NiwzMDQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSA4OCwxNDQgTCA4OCwyMzIiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSA5NiwzMDQgTCA5NiwzODQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSAxNDQsODAgTCAxNDQsMTQ0IiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gMTQ0LDI0MCBMIDE0NCwzMDQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSAyMDAsMCBMIDIwMCw2NCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayI+PC9wYXRoPgogICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNIDIwMCwxNjAgTCAyMDAsMjI0IiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gMjAwLDM2OCBMIDIwMCw0MzIiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSAyMzIsNjQgTCAyMzIsMTUyIiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gMjMyLDIyNCBMIDIzMiwzNjAiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSAyNzIsMCBMIDI3Miw2NCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayI+PC9wYXRoPgogICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNIDI3MiwxNjAgTCAyNzIsMjI0IiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gMjcyLDM2OCBMIDI3Miw0MzIiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSAzMjgsODAgTCAzMjgsMTQ0IiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gMzI4LDI0MCBMIDMyOCwzMDQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSAzNzYsMzA0IEwgMzc2LDM4NCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayI+PC9wYXRoPgogICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNIDM4NCwxNDQgTCAzODQsMjMyIiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gNDE2LDgwIEwgNDE2LDE0NCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayI+PC9wYXRoPgogICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNIDQxNiwyNDAgTCA0MTYsMzA0IiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gNDcyLDExMiBMIDQ3Miw0MTYiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSAyMDAsMCBMIDI3MiwwIiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gMTI4LDMyIEwgMjAwLDMyIiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gMjcyLDMyIEwgMzQ0LDMyIiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gMjAwLDY0IEwgMjcyLDY0IiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gNTYsODAgTCAxNDQsODAiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSAzMjgsODAgTCA0MTYsODAiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSAwLDExMiBMIDU2LDExMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayI+PC9wYXRoPgogICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNIDQxNiwxMTIgTCA0NzIsMTEyIiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gNTYsMTQ0IEwgMTQ0LDE0NCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayI+PC9wYXRoPgogICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNIDMyOCwxNDQgTCA0MTYsMTQ0IiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gMjAwLDE2MCBMIDI3MiwxNjAiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSAxMzYsMTkyIEwgMjAwLDE5MiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayI+PC9wYXRoPgogICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNIDI3MiwxOTIgTCAzMzYsMTkyIiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gMjAwLDIyNCBMIDI3MiwyMjQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSA1NiwyNDAgTCAxNDQsMjQwIiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gMzI4LDI0MCBMIDQxNiwyNDAiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSA1NiwzMDQgTCAxNDQsMzA0IiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gMzI4LDMwNCBMIDQxNiwzMDQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSAyMDAsMzY4IEwgMjcyLDM2OCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayI+PC9wYXRoPgogICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNIDk2LDM4NCBMIDE5MiwzODQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSAyODAsMzg0IEwgMzc2LDM4NCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayI+PC9wYXRoPgogICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNIDAsNDE2IEwgMTkyLDQxNiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayI+PC9wYXRoPgogICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNIDI4MCw0MTYgTCA0NzIsNDE2IiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0gMjAwLDQzMiBMIDI3Miw0MzIiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTSAzMzYsMTkyIEwgMzU2LDIzMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayI+PC9wYXRoPgogICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNIDM0NCwzMiBMIDM2NCw3MiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayI+PC9wYXRoPgogICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNIDEwOCw3MiBMIDEyOCwzMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayI+PC9wYXRoPgogICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNIDExNiwyMzIgTCAxMzYsMTkyIiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgIDxwb2x5Z29uIGNsYXNzPSJhcnJvd2hlYWQiIHBvaW50cz0iMzkyLDIzMiAzODAsMjI2LjQgMzgwLDIzNy42IiBmaWxsPSJibGFjayIgdHJhbnNmb3JtPSJyb3RhdGUoOTAsMzg0LDIzMikiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgICAgPHBvbHlnb24gY2xhc3M9ImFycm93aGVhZCIgcG9pbnRzPSIzNzIsNzIgMzYwLDY2LjQgMzYwLDc3LjYiIGZpbGw9ImJsYWNrIiB0cmFuc2Zvcm09InJvdGF0ZSg2My40MzQ5NDg4MjI5MjIwMSwzNjQsNzIpIj48L3BvbHlnb24+CiAgICAgICAgICAgICAgICAgIDxwb2x5Z29uIGNsYXNzPSJhcnJvd2hlYWQiIHBvaW50cz0iMzY0LDIzMiAzNTIsMjI2LjQgMzUyLDIzNy42IiBmaWxsPSJibGFjayIgdHJhbnNmb3JtPSJyb3RhdGUoNjMuNDM0OTQ4ODIyOTIyMDEsMzU2LDIzMikiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgICAgPHBvbHlnb24gY2xhc3M9ImFycm93aGVhZCIgcG9pbnRzPSIyODgsNDE2IDI3Niw0MTAuNCAyNzYsNDIxLjYiIGZpbGw9ImJsYWNrIiB0cmFuc2Zvcm09InJvdGF0ZSgxODAsMjgwLDQxNikiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgICAgPHBvbHlnb24gY2xhc3M9ImFycm93aGVhZCIgcG9pbnRzPSIyODgsMzg0IDI3NiwzNzguNCAyNzYsMzg5LjYiIGZpbGw9ImJsYWNrIiB0cmFuc2Zvcm09InJvdGF0ZSgxODAsMjgwLDM4NCkiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgICAgPHBvbHlnb24gY2xhc3M9ImFycm93aGVhZCIgcG9pbnRzPSIyNDAsMzYwIDIyOCwzNTQuNCAyMjgsMzY1LjYiIGZpbGw9ImJsYWNrIiB0cmFuc2Zvcm09InJvdGF0ZSg5MCwyMzIsMzYwKSI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgICA8cG9seWdvbiBjbGFzcz0iYXJyb3doZWFkIiBwb2ludHM9IjI0MCwxNTIgMjI4LDE0Ni40IDIyOCwxNTcuNiIgZmlsbD0iYmxhY2siIHRyYW5zZm9ybT0icm90YXRlKDkwLDIzMiwxNTIpIj48L3BvbHlnb24+CiAgICAgICAgICAgICAgICAgIDxwb2x5Z29uIGNsYXNzPSJhcnJvd2hlYWQiIHBvaW50cz0iMjAwLDQxNiAxODgsNDEwLjQgMTg4LDQyMS42IiBmaWxsPSJibGFjayIgdHJhbnNmb3JtPSJyb3RhdGUoMCwxOTIsNDE2KSI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgICA8cG9seWdvbiBjbGFzcz0iYXJyb3doZWFkIiBwb2ludHM9IjIwMCwzODQgMTg4LDM3OC40IDE4OCwzODkuNiIgZmlsbD0iYmxhY2siIHRyYW5zZm9ybT0icm90YXRlKDAsMTkyLDM4NCkiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgICAgPHBvbHlnb24gY2xhc3M9ImFycm93aGVhZCIgcG9pbnRzPSIxMjQsMjMyIDExMiwyMjYuNCAxMTIsMjM3LjYiIGZpbGw9ImJsYWNrIiB0cmFuc2Zvcm09InJvdGF0ZSgxMTYuNTY1MDUxMTc3MDc3OTksMTE2LDIzMikiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgICAgPHBvbHlnb24gY2xhc3M9ImFycm93aGVhZCIgcG9pbnRzPSIxMTYsNzIgMTA0LDY2LjQgMTA0LDc3LjYiIGZpbGw9ImJsYWNrIiB0cmFuc2Zvcm09InJvdGF0ZSgxMTYuNTY1MDUxMTc3MDc3OTksMTA4LDcyKSI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgICA8cG9seWdvbiBjbGFzcz0iYXJyb3doZWFkIiBwb2ludHM9Ijk2LDIzMiA4NCwyMjYuNCA4NCwyMzcuNiIgZmlsbD0iYmxhY2siIHRyYW5zZm9ybT0icm90YXRlKDkwLDg4LDIzMikiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgICAgPGcgY2xhc3M9InRleHQiPgogICAgICAgICAgICAgICAgICAgIDx0ZXh0IHg9IjE2MCIgeT0iMjAiPnNlbmQgUFA8L3RleHQ+CiAgICAgICAgICAgICAgICAgICAgPHRleHQgeD0iMzEyIiB5PSIyMCI+cmVjdiBQUDwvdGV4dD4KICAgICAgICAgICAgICAgICAgICA8dGV4dCB4PSIyMzYiIHk9IjM2Ij5pZGxlPC90ZXh0PgogICAgICAgICAgICAgICAgICAgIDx0ZXh0IHg9IjI3NiIgeT0iMTAwIj5zZW5kIEggLzwvdGV4dD4KICAgICAgICAgICAgICAgICAgICA8dGV4dCB4PSIxMDAiIHk9IjExNiI+cmVzZXJ2ZWQ8L3RleHQ+CiAgICAgICAgICAgICAgICAgICAgPHRleHQgeD0iMjY4IiB5PSIxMTYiPnJlY3YgSDwvdGV4dD4KICAgICAgICAgICAgICAgICAgICA8dGV4dCB4PSIzNzIiIHk9IjExNiI+cmVzZXJ2ZWQ8L3RleHQ+CiAgICAgICAgICAgICAgICAgICAgPHRleHQgeD0iOTYiIHk9IjEzMiI+KGxvY2FsKTwvdGV4dD4KICAgICAgICAgICAgICAgICAgICA8dGV4dCB4PSIzNzIiIHk9IjEzMiI+KHJlbW90ZSk8L3RleHQ+CiAgICAgICAgICAgICAgICAgICAgPHRleHQgeD0iMTYwIiB5PSIxODAiPnJlY3YgRVM8L3RleHQ+CiAgICAgICAgICAgICAgICAgICAgPHRleHQgeD0iMzEyIiB5PSIxODAiPnNlbmQgRVM8L3RleHQ+CiAgICAgICAgICAgICAgICAgICAgPHRleHQgeD0iNTIiIHk9IjE5NiI+c2VuZCBIPC90ZXh0PgogICAgICAgICAgICAgICAgICAgIDx0ZXh0IHg9IjIzNiIgeT0iMTk2Ij5vcGVuPC90ZXh0PgogICAgICAgICAgICAgICAgICAgIDx0ZXh0IHg9IjQyMCIgeT0iMTk2Ij5yZWN2IEg8L3RleHQ+CiAgICAgICAgICAgICAgICAgICAgPHRleHQgeD0iMTAwIiB5PSIyNjAiPmhhbGYtPC90ZXh0PgogICAgICAgICAgICAgICAgICAgIDx0ZXh0IHg9IjM3MiIgeT0iMjYwIj5oYWxmLTwvdGV4dD4KICAgICAgICAgICAgICAgICAgICA8dGV4dCB4PSIxMDAiIHk9IjI3NiI+Y2xvc2VkPC90ZXh0PgogICAgICAgICAgICAgICAgICAgIDx0ZXh0IHg9IjI3NiIgeT0iMjc2Ij5zZW5kIFIgLzwvdGV4dD4KICAgICAgICAgICAgICAgICAgICA8dGV4dCB4PSIzNzIiIHk9IjI3NiI+Y2xvc2VkPC90ZXh0PgogICAgICAgICAgICAgICAgICAgIDx0ZXh0IHg9IjEwMCIgeT0iMjkyIj4ocmVtb3RlKTwvdGV4dD4KICAgICAgICAgICAgICAgICAgICA8dGV4dCB4PSIyNjgiIHk9IjI5MiI+cmVjdiBSPC90ZXh0PgogICAgICAgICAgICAgICAgICAgIDx0ZXh0IHg9IjM2OCIgeT0iMjkyIj4obG9jYWwpPC90ZXh0PgogICAgICAgICAgICAgICAgICAgIDx0ZXh0IHg9IjE0NCIgeT0iMzQwIj5zZW5kIEVTIC88L3RleHQ+CiAgICAgICAgICAgICAgICAgICAgPHRleHQgeD0iMzI4IiB5PSIzNDAiPnJlY3YgRVMgLzwvdGV4dD4KICAgICAgICAgICAgICAgICAgICA8dGV4dCB4PSIxNDgiIHk9IjM1NiI+c2VuZCBSIC88L3RleHQ+CiAgICAgICAgICAgICAgICAgICAgPHRleHQgeD0iMzMyIiB5PSIzNTYiPnNlbmQgUiAvPC90ZXh0PgogICAgICAgICAgICAgICAgICAgIDx0ZXh0IHg9IjE0MCIgeT0iMzcyIj5yZWN2IFI8L3RleHQ+CiAgICAgICAgICAgICAgICAgICAgPHRleHQgeD0iMzI0IiB5PSIzNzIiPnJlY3YgUjwvdGV4dD4KICAgICAgICAgICAgICAgICAgICA8dGV4dCB4PSI0NCIgeT0iMzg4Ij5zZW5kIFIgLzwvdGV4dD4KICAgICAgICAgICAgICAgICAgICA8dGV4dCB4PSI0MjgiIHk9IjM4OCI+c2VuZCBSIC88L3RleHQ+CiAgICAgICAgICAgICAgICAgICAgPHRleHQgeD0iMzYiIHk9IjQwNCI+cmVjdiBSPC90ZXh0PgogICAgICAgICAgICAgICAgICAgIDx0ZXh0IHg9IjIzNiIgeT0iNDA0Ij5jbG9zZWQ8L3RleHQ+CiAgICAgICAgICAgICAgICAgICAgPHRleHQgeD0iNDIwIiB5PSI0MDQiPnJlY3YgUjwvdGV4dD4KICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgIDwvc3ZnPg==){.diagram}[¶](#section-5.1-2.1.1){.pilcrow}
:::
:::

[Figure 2](#figure-2){.selfRef}: [Stream
States](#name-stream-states-2){.selfRef}
:::

[]{.break}

`send`:
:   endpoint sends this frame[¶](#section-5.1-3.2){.pilcrow}
:   

`recv`:
:   endpoint receives this frame[¶](#section-5.1-3.4){.pilcrow}
:   

`H`:
:   [HEADERS](#HEADERS){.xref} frame (with implied
    [CONTINUATION](#CONTINUATION){.xref}
    frames)[¶](#section-5.1-3.6){.pilcrow}
:   

`ES`:
:   END_STREAM flag[¶](#section-5.1-3.8){.pilcrow}
:   

`R`:
:   [RST_STREAM](#RST_STREAM){.xref}
    frame[¶](#section-5.1-3.10){.pilcrow}
:   

`PP`:
:   [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame (with implied
    [CONTINUATION](#CONTINUATION){.xref} frames); state transitions are
    for the promised stream[¶](#section-5.1-3.12){.pilcrow}
:   

Note that this diagram shows stream state transitions and the frames and
flags that affect those transitions only. In this regard,
[CONTINUATION](#CONTINUATION){.xref} frames do not result in state
transitions; they are effectively part of the [HEADERS](#HEADERS){.xref}
or [PUSH_PROMISE](#PUSH_PROMISE){.xref} that they follow. For the
purpose of state transitions, the END_STREAM flag is processed as a
separate event to the frame that bears it; a [HEADERS](#HEADERS){.xref}
frame with the END_STREAM flag set can cause two state
transitions.[¶](#section-5.1-4){.pilcrow}

Both endpoints have a subjective view of the state of a stream that
could be different when frames are in transit. Endpoints do not
coordinate the creation of streams; they are created unilaterally by
either endpoint. The negative consequences of a mismatch in states are
limited to the \"closed\" state after sending
[RST_STREAM](#RST_STREAM){.xref}, where frames might be received for
some time after closing.[¶](#section-5.1-5){.pilcrow}

Streams have the following states:[¶](#section-5.1-6){.pilcrow}

[]{.break}

idle:

:   All streams start in the \"idle\"
    state.[¶](#section-5.1-7.2.1){.pilcrow}

    The following transitions are valid from this
    state:[¶](#section-5.1-7.2.2){.pilcrow}

    -   [Sending a [HEADERS](#HEADERS){.xref} frame as a client, or
        receiving a HEADERS frame as a server, causes the stream to
        become \"open\". The stream identifier is selected as described
        in [Section 5.1.1](#StreamIdentifiers){.xref}. The same
        [HEADERS](#HEADERS){.xref} frame can also cause a stream to
        immediately become
        \"half-closed\".[¶](#section-5.1-7.2.3.1){.pilcrow}]{#section-5.1-7.2.3.1}
    -   [Sending a [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame on another
        stream reserves the idle stream that is identified for later
        use. The stream state for the reserved stream transitions to
        \"reserved (local)\". Only a server may send
        [PUSH_PROMISE](#PUSH_PROMISE){.xref}
        frames.[¶](#section-5.1-7.2.3.2){.pilcrow}]{#section-5.1-7.2.3.2}
    -   [Receiving a [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame on
        another stream reserves an idle stream that is identified for
        later use. The stream state for the reserved stream transitions
        to \"reserved (remote)\". Only a client may receive
        [PUSH_PROMISE](#PUSH_PROMISE){.xref}
        frames.[¶](#section-5.1-7.2.3.3){.pilcrow}]{#section-5.1-7.2.3.3}
    -   [Note that the [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame is not
        sent on the idle stream but references the newly reserved stream
        in the Promised Stream ID
        field.[¶](#section-5.1-7.2.3.4){.pilcrow}]{#section-5.1-7.2.3.4}
    -   [Opening a stream with a higher-valued stream identifier causes
        the stream to transition immediately to a \"closed\" state; note
        that this transition is not shown in the
        diagram.[¶](#section-5.1-7.2.3.5){.pilcrow}]{#section-5.1-7.2.3.5}

    Receiving any frame other than [HEADERS](#HEADERS){.xref} or
    [PRIORITY](#PRIORITY){.xref} on a stream in this state
    [MUST]{.bcp14} be treated as a [connection
    error](#ConnectionErrorHandler){.xref} ([Section
    5.4.1](#ConnectionErrorHandler){.xref}) of type
    [PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}. If this stream is
    initiated by the server, as described in [Section
    5.1.1](#StreamIdentifiers){.xref}, then receiving a
    [HEADERS](#HEADERS){.xref} frame [MUST]{.bcp14} also be treated as a
    [connection error](#ConnectionErrorHandler){.xref} ([Section
    5.4.1](#ConnectionErrorHandler){.xref}) of type
    [PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-5.1-7.2.4){.pilcrow}

:   

reserved (local):

:   A stream in the \"reserved (local)\" state is one that has been
    promised by sending a [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame. A
    [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame reserves an idle stream
    by associating the stream with an open stream that was initiated by
    the remote peer (see [Section
    8.4](#PushResources){.xref}).[¶](#section-5.1-7.4.1){.pilcrow}

    In this state, only the following transitions are
    possible:[¶](#section-5.1-7.4.2){.pilcrow}

    -   [The endpoint can send a [HEADERS](#HEADERS){.xref} frame. This
        causes the stream to open in a \"half-closed (remote)\"
        state.[¶](#section-5.1-7.4.3.1){.pilcrow}]{#section-5.1-7.4.3.1}
    -   [Either endpoint can send a [RST_STREAM](#RST_STREAM){.xref}
        frame to cause the stream to become \"closed\". This releases
        the stream
        reservation.[¶](#section-5.1-7.4.3.2){.pilcrow}]{#section-5.1-7.4.3.2}

    An endpoint [MUST NOT]{.bcp14} send any type of frame other than
    [HEADERS](#HEADERS){.xref}, [RST_STREAM](#RST_STREAM){.xref}, or
    [PRIORITY](#PRIORITY){.xref} in this
    state.[¶](#section-5.1-7.4.4){.pilcrow}

    A [PRIORITY](#PRIORITY){.xref} or
    [WINDOW_UPDATE](#WINDOW_UPDATE){.xref} frame [MAY]{.bcp14} be
    received in this state. Receiving any type of frame other than
    [RST_STREAM](#RST_STREAM){.xref}, [PRIORITY](#PRIORITY){.xref}, or
    [WINDOW_UPDATE](#WINDOW_UPDATE){.xref} on a stream in this state
    [MUST]{.bcp14} be treated as a [connection
    error](#ConnectionErrorHandler){.xref} ([Section
    5.4.1](#ConnectionErrorHandler){.xref}) of type
    [PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-5.1-7.4.5){.pilcrow}

:   

reserved (remote):

:   A stream in the \"reserved (remote)\" state has been reserved by a
    remote peer.[¶](#section-5.1-7.6.1){.pilcrow}

    In this state, only the following transitions are
    possible:[¶](#section-5.1-7.6.2){.pilcrow}

    -   [Receiving a [HEADERS](#HEADERS){.xref} frame causes the stream
        to transition to \"half-closed
        (local)\".[¶](#section-5.1-7.6.3.1){.pilcrow}]{#section-5.1-7.6.3.1}
    -   [Either endpoint can send a [RST_STREAM](#RST_STREAM){.xref}
        frame to cause the stream to become \"closed\". This releases
        the stream
        reservation.[¶](#section-5.1-7.6.3.2){.pilcrow}]{#section-5.1-7.6.3.2}

    An endpoint [MUST NOT]{.bcp14} send any type of frame other than
    [RST_STREAM](#RST_STREAM){.xref},
    [WINDOW_UPDATE](#WINDOW_UPDATE){.xref}, or
    [PRIORITY](#PRIORITY){.xref} in this
    state.[¶](#section-5.1-7.6.4){.pilcrow}

    Receiving any type of frame other than [HEADERS](#HEADERS){.xref},
    [RST_STREAM](#RST_STREAM){.xref}, or [PRIORITY](#PRIORITY){.xref} on
    a stream in this state [MUST]{.bcp14} be treated as a [connection
    error](#ConnectionErrorHandler){.xref} ([Section
    5.4.1](#ConnectionErrorHandler){.xref}) of type
    [PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-5.1-7.6.5){.pilcrow}

:   

open:

:   A stream in the \"open\" state may be used by both peers to send
    frames of any type. In this state, sending peers observe advertised
    [stream-level flow-control limits](#FlowControl){.xref} ([Section
    5.2](#FlowControl){.xref}).[¶](#section-5.1-7.8.1){.pilcrow}

    From this state, either endpoint can send a frame with an END_STREAM
    flag set, which causes the stream to transition into one of the
    \"half-closed\" states. An endpoint sending an END_STREAM flag
    causes the stream state to become \"half-closed (local)\"; an
    endpoint receiving an END_STREAM flag causes the stream state to
    become \"half-closed (remote)\".[¶](#section-5.1-7.8.2){.pilcrow}

    Either endpoint can send a [RST_STREAM](#RST_STREAM){.xref} frame
    from this state, causing it to transition immediately to
    \"closed\".[¶](#section-5.1-7.8.3){.pilcrow}

:   

half-closed (local):

:   A stream that is in the \"half-closed (local)\" state cannot be used
    for sending frames other than
    [WINDOW_UPDATE](#WINDOW_UPDATE){.xref},
    [PRIORITY](#PRIORITY){.xref}, and
    [RST_STREAM](#RST_STREAM){.xref}.[¶](#section-5.1-7.10.1){.pilcrow}

    A stream transitions from this state to \"closed\" when a frame is
    received with the END_STREAM flag set or when either peer sends a
    [RST_STREAM](#RST_STREAM){.xref}
    frame.[¶](#section-5.1-7.10.2){.pilcrow}

    An endpoint can receive any type of frame in this state. Providing
    flow-control credit using [WINDOW_UPDATE](#WINDOW_UPDATE){.xref}
    frames is necessary to continue receiving flow-controlled frames. In
    this state, a receiver can ignore
    [WINDOW_UPDATE](#WINDOW_UPDATE){.xref} frames, which might arrive
    for a short period after a frame with the END_STREAM flag set is
    sent.[¶](#section-5.1-7.10.3){.pilcrow}

    [PRIORITY](#PRIORITY){.xref} frames can be received in this
    state.[¶](#section-5.1-7.10.4){.pilcrow}

:   

half-closed (remote):

:   A stream that is \"half-closed (remote)\" is no longer being used by
    the peer to send frames. In this state, an endpoint is no longer
    obligated to maintain a receiver flow-control
    window.[¶](#section-5.1-7.12.1){.pilcrow}

    If an endpoint receives additional frames, other than
    [WINDOW_UPDATE](#WINDOW_UPDATE){.xref},
    [PRIORITY](#PRIORITY){.xref}, or [RST_STREAM](#RST_STREAM){.xref},
    for a stream that is in this state, it [MUST]{.bcp14} respond with a
    [stream error](#StreamErrorHandler){.xref} ([Section
    5.4.2](#StreamErrorHandler){.xref}) of type
    [STREAM_CLOSED](#STREAM_CLOSED){.xref}.[¶](#section-5.1-7.12.2){.pilcrow}

    A stream that is \"half-closed (remote)\" can be used by the
    endpoint to send frames of any type. In this state, the endpoint
    continues to observe advertised [stream-level flow-control
    limits](#FlowControl){.xref} ([Section
    5.2](#FlowControl){.xref}).[¶](#section-5.1-7.12.3){.pilcrow}

    A stream can transition from this state to \"closed\" by sending a
    frame with the END_STREAM flag set or when either peer sends a
    [RST_STREAM](#RST_STREAM){.xref}
    frame.[¶](#section-5.1-7.12.4){.pilcrow}

:   

closed:

:   The \"closed\" state is the terminal
    state.[¶](#section-5.1-7.14.1){.pilcrow}

    A stream enters the \"closed\" state after an endpoint both sends
    and receives a frame with an END_STREAM flag set. A stream also
    enters the \"closed\" state after an endpoint either sends or
    receives a [RST_STREAM](#RST_STREAM){.xref}
    frame.[¶](#section-5.1-7.14.2){.pilcrow}

    An endpoint [MUST NOT]{.bcp14} send frames other than
    [PRIORITY](#PRIORITY){.xref} on a closed stream. An endpoint
    [MAY]{.bcp14} treat receipt of any other type of frame on a closed
    stream as a [connection error](#ConnectionErrorHandler){.xref}
    ([Section 5.4.1](#ConnectionErrorHandler){.xref}) of type
    [STREAM_CLOSED](#STREAM_CLOSED){.xref}, except as noted
    below.[¶](#section-5.1-7.14.3){.pilcrow}

    An endpoint that sends a frame with the END_STREAM flag set or a
    [RST_STREAM](#RST_STREAM){.xref} frame might receive a
    [WINDOW_UPDATE](#WINDOW_UPDATE){.xref} or
    [RST_STREAM](#RST_STREAM){.xref} frame from its peer in the time
    before the peer receives and processes the frame that closes the
    stream.[¶](#section-5.1-7.14.4){.pilcrow}

    An endpoint that sends a [RST_STREAM](#RST_STREAM){.xref} frame on a
    stream that is in the \"open\" or \"half-closed (local)\" state
    could receive any type of frame. The peer might have sent or
    enqueued for sending these frames before processing the
    [RST_STREAM](#RST_STREAM){.xref} frame. An endpoint [MUST]{.bcp14}
    minimally process and then discard any frames it receives in this
    state. This means updating header compression state for
    [HEADERS](#HEADERS){.xref} and [PUSH_PROMISE](#PUSH_PROMISE){.xref}
    frames. Receiving a [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame also
    causes the promised stream to become \"reserved (remote)\", even
    when the [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame is received on a
    closed stream. Additionally, the content of [DATA](#DATA){.xref}
    frames counts toward the connection flow-control
    window.[¶](#section-5.1-7.14.5){.pilcrow}

    An endpoint can perform this minimal processing for all streams that
    are in the \"closed\" state. Endpoints [MAY]{.bcp14} use other
    signals to detect that a peer has received the frames that caused
    the stream to enter the \"closed\" state and treat receipt of any
    frame other than [PRIORITY](#PRIORITY){.xref} as a [connection
    error](#ConnectionErrorHandler){.xref} ([Section
    5.4.1](#ConnectionErrorHandler){.xref}) of type
    [PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}. Endpoints can use frames
    that indicate that the peer has received the closing signal to drive
    this. Endpoints [SHOULD NOT]{.bcp14} use timers for this purpose.
    For example, an endpoint that sends a [SETTINGS](#SETTINGS){.xref}
    frame after closing a stream can safely treat receipt of a
    [DATA](#DATA){.xref} frame on that stream as an error after
    receiving an acknowledgment of the settings. Other things that might
    be used are [PING](#PING){.xref} frames, receiving data on streams
    that were created after closing the stream, or responses to requests
    created after closing the stream.[¶](#section-5.1-7.14.6){.pilcrow}

:   

In the absence of more specific rules, implementations [SHOULD]{.bcp14}
treat the receipt of a frame that is not expressly permitted in the
description of a state as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}. Note that
[PRIORITY](#PRIORITY){.xref} can be sent and received in any stream
state.[¶](#section-5.1-8){.pilcrow}

The rules in this section only apply to frames defined in this document.
Receipt of frames for which the semantics are unknown cannot be treated
as an error, as the conditions for sending and receiving those frames
are also unknown; see [Section
5.5](#extensibility){.xref}.[¶](#section-5.1-9){.pilcrow}

An example of the state transitions for an HTTP request/response
exchange can be found in [Section 8.8](#HttpExamples){.xref}. An example
of the state transitions for server push can be found in
Sections [8.4.1](#PushRequests){.xref} and
[8.4.2](#PushResponses){.xref}.[¶](#section-5.1-10){.pilcrow}

::: {#StreamIdentifiers}
::: {#section-5.1.1 .section}
#### [5.1.1.](#section-5.1.1){.section-number .selfRef} [Stream Identifiers](#name-stream-identifiers){.section-name .selfRef} {#name-stream-identifiers}

Streams are identified by an unsigned 31-bit integer. Streams initiated
by a client [MUST]{.bcp14} use odd-numbered stream identifiers; those
initiated by the server [MUST]{.bcp14} use even-numbered stream
identifiers. A stream identifier of zero (0x00) is used for connection
control messages; the stream identifier of zero cannot be used to
establish a new stream.[¶](#section-5.1.1-1){.pilcrow}

The identifier of a newly established stream [MUST]{.bcp14} be
numerically greater than all streams that the initiating endpoint has
opened or reserved. This governs streams that are opened using a
[HEADERS](#HEADERS){.xref} frame and streams that are reserved using
[PUSH_PROMISE](#PUSH_PROMISE){.xref}. An endpoint that receives an
unexpected stream identifier [MUST]{.bcp14} respond with a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-5.1.1-2){.pilcrow}

A [HEADERS](#HEADERS){.xref} frame will transition the client-initiated
stream identified by the stream identifier in the frame header from
\"idle\" to \"open\". A [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame will
transition the server-initiated stream identified by the Promised Stream
ID field in the frame payload from \"idle\" to \"reserved (local)\" or
\"reserved (remote)\". When a stream transitions out of the \"idle\"
state, all streams in the \"idle\" state that might have been opened by
the peer with a lower-valued stream identifier immediately transition to
\"closed\". That is, an endpoint may skip a stream identifier, with the
effect being that the skipped stream is immediately
closed.[¶](#section-5.1.1-3){.pilcrow}

Stream identifiers cannot be reused. Long-lived connections can result
in an endpoint exhausting the available range of stream identifiers. A
client that is unable to establish a new stream identifier can establish
a new connection for new streams. A server that is unable to establish a
new stream identifier can send a [GOAWAY](#GOAWAY){.xref} frame so that
the client is forced to open a new connection for new
streams.[¶](#section-5.1.1-4){.pilcrow}
:::
:::

::: {#section-5.1.2 .section}
#### [5.1.2.](#section-5.1.2){.section-number .selfRef} [Stream Concurrency](#name-stream-concurrency){.section-name .selfRef} {#name-stream-concurrency}

A peer can limit the number of concurrently active streams using the
[SETTINGS_MAX_CONCURRENT_STREAMS](#SETTINGS_MAX_CONCURRENT_STREAMS){.xref}
parameter (see [Section 6.5.2](#SettingValues){.xref}) within a
[SETTINGS](#SETTINGS){.xref} frame. The maximum concurrent streams
setting is specific to each endpoint and applies only to the peer that
receives the setting. That is, clients specify the maximum number of
concurrent streams the server can initiate, and servers specify the
maximum number of concurrent streams the client can
initiate.[¶](#section-5.1.2-1){.pilcrow}

Streams that are in the \"open\" state or in either of the
\"half-closed\" states count toward the maximum number of streams that
an endpoint is permitted to open. Streams in any of these three states
count toward the limit advertised in the
[SETTINGS_MAX_CONCURRENT_STREAMS](#SETTINGS_MAX_CONCURRENT_STREAMS){.xref}
setting. Streams in either of the \"reserved\" states do not count
toward the stream limit.[¶](#section-5.1.2-2){.pilcrow}

Endpoints [MUST NOT]{.bcp14} exceed the limit set by their peer. An
endpoint that receives a [HEADERS](#HEADERS){.xref} frame that causes
its advertised concurrent stream limit to be exceeded [MUST]{.bcp14}
treat this as a [stream error](#StreamErrorHandler){.xref} ([Section
5.4.2](#StreamErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref} or
[REFUSED_STREAM](#REFUSED_STREAM){.xref}. The choice of error code
determines whether the endpoint wishes to enable automatic retry (see
[Section 8.7](#Reliability){.xref} for
details).[¶](#section-5.1.2-3){.pilcrow}

An endpoint that wishes to reduce the value of
[SETTINGS_MAX_CONCURRENT_STREAMS](#SETTINGS_MAX_CONCURRENT_STREAMS){.xref}
to a value that is below the current number of open streams can either
close streams that exceed the new value or allow streams to
complete.[¶](#section-5.1.2-4){.pilcrow}
:::
:::
:::

::: {#FlowControl}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Flow Control](#name-flow-control){.section-name .selfRef} {#name-flow-control}

Using streams for multiplexing introduces contention over use of the TCP
connection, resulting in blocked streams. A flow-control scheme ensures
that streams on the same connection do not destructively interfere with
each other. Flow control is used for both individual streams and the
connection as a whole.[¶](#section-5.2-1){.pilcrow}

HTTP/2 provides for flow control through use of the [WINDOW_UPDATE
frame](#WINDOW_UPDATE){.xref} ([Section
6.9](#WINDOW_UPDATE){.xref}).[¶](#section-5.2-2){.pilcrow}

::: {#fc-principles}
::: {#section-5.2.1 .section}
#### [5.2.1.](#section-5.2.1){.section-number .selfRef} [Flow-Control Principles](#name-flow-control-principles){.section-name .selfRef} {#name-flow-control-principles}

HTTP/2 stream flow control aims to allow a variety of flow-control
algorithms to be used without requiring protocol changes. Flow control
in HTTP/2 has the following
characteristics:[¶](#section-5.2.1-1){.pilcrow}

1.  [Flow control is specific to a connection. HTTP/2 flow control
    operates between the endpoints of a single hop and not over the
    entire end-to-end
    path.[¶](#section-5.2.1-2.1){.pilcrow}]{#section-5.2.1-2.1}
2.  [Flow control is based on [WINDOW_UPDATE](#WINDOW_UPDATE){.xref}
    frames. Receivers advertise how many octets they are prepared to
    receive on a stream and for the entire connection. This is a
    credit-based
    scheme.[¶](#section-5.2.1-2.2){.pilcrow}]{#section-5.2.1-2.2}
3.  [Flow control is directional with overall control provided by the
    receiver. A receiver [MAY]{.bcp14} choose to set any window size
    that it desires for each stream and for the entire connection. A
    sender [MUST]{.bcp14} respect flow-control limits imposed by a
    receiver. Clients, servers, and intermediaries all independently
    advertise their flow-control window as a receiver and abide by the
    flow-control limits set by their peer when
    sending.[¶](#section-5.2.1-2.3){.pilcrow}]{#section-5.2.1-2.3}
4.  [The initial value for the flow-control window is 65,535 octets for
    both new streams and the overall
    connection.[¶](#section-5.2.1-2.4){.pilcrow}]{#section-5.2.1-2.4}
5.  [The frame type determines whether flow control applies to a frame.
    Of the frames specified in this document, only [DATA](#DATA){.xref}
    frames are subject to flow control; all other frame types do not
    consume space in the advertised flow-control window. This ensures
    that important control frames are not blocked by flow
    control.[¶](#section-5.2.1-2.5){.pilcrow}]{#section-5.2.1-2.5}
6.  [An endpoint can choose to disable its own flow control, but an
    endpoint cannot ignore flow-control signals from its
    peer.[¶](#section-5.2.1-2.6){.pilcrow}]{#section-5.2.1-2.6}
7.  [HTTP/2 defines only the format and semantics of the
    [WINDOW_UPDATE](#WINDOW_UPDATE){.xref} frame ([Section
    6.9](#WINDOW_UPDATE){.xref}). This document does not stipulate how a
    receiver decides when to send this frame or the value that it sends,
    nor does it specify how a sender chooses to send packets.
    Implementations are able to select any algorithm that suits their
    needs.[¶](#section-5.2.1-2.7){.pilcrow}]{#section-5.2.1-2.7}

Implementations are also responsible for prioritizing the sending of
requests and responses, choosing how to avoid head-of-line blocking for
requests, and managing the creation of new streams. Algorithm choices
for these could interact with any flow-control
algorithm.[¶](#section-5.2.1-3){.pilcrow}
:::
:::

::: {#DisableFlowControl}
::: {#section-5.2.2 .section}
#### [5.2.2.](#section-5.2.2){.section-number .selfRef} [Appropriate Use of Flow Control](#name-appropriate-use-of-flow-con){.section-name .selfRef} {#name-appropriate-use-of-flow-con}

Flow control is defined to protect endpoints that are operating under
resource constraints. For example, a proxy needs to share memory between
many connections and also might have a slow upstream connection and a
fast downstream one. Flow control addresses cases where the receiver is
unable to process data on one stream yet wants to continue to process
other streams in the same connection.[¶](#section-5.2.2-1){.pilcrow}

Deployments that do not require this capability can advertise a
flow-control window of the maximum size (2^31^-1) and can maintain this
window by sending a [WINDOW_UPDATE](#WINDOW_UPDATE){.xref} frame when
any data is received. This effectively disables flow control for that
receiver. Conversely, a sender is always subject to the flow-control
window advertised by the receiver.[¶](#section-5.2.2-2){.pilcrow}

Deployments with constrained resources (for example, memory) can employ
flow control to limit the amount of memory a peer can consume. Note,
however, that this can lead to suboptimal use of available network
resources if flow control is enabled without knowledge of the bandwidth
\* delay product (see
\[[RFC7323](#RFC7323){.xref}\]).[¶](#section-5.2.2-3){.pilcrow}

Even with full awareness of the current bandwidth \* delay product,
implementation of flow control can be difficult. Endpoints
[MUST]{.bcp14} read and process HTTP/2 frames from the TCP receive
buffer as soon as data is available. Failure to read promptly could lead
to a deadlock when critical frames, such as
[WINDOW_UPDATE](#WINDOW_UPDATE){.xref}, are not read and acted upon.
Reading frames promptly does not expose endpoints to resource exhaustion
attacks, as HTTP/2 flow control limits resource
commitments.[¶](#section-5.2.2-4){.pilcrow}
:::
:::

::: {#FlowControlPerformance}
::: {#section-5.2.3 .section}
#### [5.2.3.](#section-5.2.3){.section-number .selfRef} [Flow-Control Performance](#name-flow-control-performance){.section-name .selfRef} {#name-flow-control-performance}

If an endpoint cannot ensure that its peer always has available
flow-control window space that is greater than the peer\'s bandwidth \*
delay product on this connection, its receive throughput will be limited
by HTTP/2 flow control. This will result in degraded
performance.[¶](#section-5.2.3-1){.pilcrow}

Sending timely [WINDOW_UPDATE](#WINDOW_UPDATE){.xref} frames can improve
performance. Endpoints will want to balance the need to improve receive
throughput with the need to manage resource exhaustion risks and should
take careful note of [Section 10.5](#dos){.xref} in defining their
strategy to manage window sizes.[¶](#section-5.2.3-2){.pilcrow}
:::
:::
:::
:::

::: {#StreamPriority}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Prioritization](#name-prioritization){.section-name .selfRef} {#name-prioritization}

In a multiplexed protocol like HTTP/2, prioritizing allocation of
bandwidth and computation resources to streams can be critical to
attaining good performance. A poor prioritization scheme can result in
HTTP/2 providing poor performance. With no parallelism at the TCP layer,
performance could be significantly worse than
HTTP/1.1.[¶](#section-5.3-1){.pilcrow}

A good prioritization scheme benefits from the application of contextual
knowledge such as the content of resources, how resources are
interrelated, and how those resources will be used by a peer. In
particular, clients can possess knowledge about the priority of requests
that is relevant to server prioritization. In those cases, having
clients provide priority information can improve
performance.[¶](#section-5.3-2){.pilcrow}

::: {#PriorityHistory}
::: {#section-5.3.1 .section}
#### [5.3.1.](#section-5.3.1){.section-number .selfRef} [Background on Priority in RFC 7540](#name-background-on-priority-in-r){.section-name .selfRef} {#name-background-on-priority-in-r}

RFC 7540 defined a rich system for signaling priority of requests.
However, this system proved to be complex, and it was not uniformly
implemented.[¶](#section-5.3.1-1){.pilcrow}

The flexible scheme meant that it was possible for clients to express
priorities in very different ways, with little consistency in the
approaches that were adopted. For servers, implementing generic support
for the scheme was complex. Implementation of priorities was uneven in
both clients and servers. Many server deployments ignored client signals
when prioritizing their handling of
requests.[¶](#section-5.3.1-2){.pilcrow}

In short, the prioritization signaling in [RFC 7540](#RFC7540){.xref}
\[[RFC7540](#RFC7540){.xref}\] was not
successful.[¶](#section-5.3.1-3){.pilcrow}
:::
:::

::: {#PriorityHere}
::: {#section-5.3.2 .section}
#### [5.3.2.](#section-5.3.2){.section-number .selfRef} [Priority Signaling in This Document](#name-priority-signaling-in-this-){.section-name .selfRef} {#name-priority-signaling-in-this-}

This update to HTTP/2 deprecates the priority signaling defined in [RFC
7540](#RFC7540){.xref} \[[RFC7540](#RFC7540){.xref}\]. The bulk of the
text related to priority signals is not included in this document. The
description of frame fields and some of the mandatory handling is
retained to ensure that implementations of this document remain
interoperable with implementations that use the priority signaling
described in RFC 7540.[¶](#section-5.3.2-1){.pilcrow}

A thorough description of the RFC 7540 priority scheme remains in
[Section
5.3](https://www.rfc-editor.org/rfc/rfc7540#section-5.3){.relref} of
\[[RFC7540](#RFC7540){.xref}\].[¶](#section-5.3.2-2){.pilcrow}

Signaling priority information is necessary to attain good performance
in many cases. Where signaling priority information is important,
endpoints are encouraged to use an alternative scheme, such as the
scheme described in
\[[HTTP-PRIORITY](#RFC9218){.xref}\].[¶](#section-5.3.2-3){.pilcrow}

Though the priority signaling from RFC 7540 was not widely adopted, the
information it provides can still be useful in the absence of better
information. Endpoints that receive priority signals in
[HEADERS](#HEADERS){.xref} or [PRIORITY](#PRIORITY){.xref} frames can
benefit from applying that information. In particular, implementations
that consume these signals would not benefit from discarding these
priority signals in the absence of
alternatives.[¶](#section-5.3.2-4){.pilcrow}

Servers [SHOULD]{.bcp14} use other contextual information in determining
priority of requests in the absence of any priority signals. Servers
[MAY]{.bcp14} interpret the complete absence of signals as an indication
that the client has not implemented the feature. The defaults described
in [Section
5.3.5](https://www.rfc-editor.org/rfc/rfc7540#section-5.3.5){.relref} of
\[[RFC7540](#RFC7540){.xref}\] are known to have poor performance under
most conditions, and their use is unlikely to be
deliberate.[¶](#section-5.3.2-5){.pilcrow}
:::
:::
:::
:::

::: {#ErrorHandler}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [Error Handling](#name-error-handling){.section-name .selfRef} {#name-error-handling}

HTTP/2 framing permits two classes of
errors:[¶](#section-5.4-1){.pilcrow}

-   [An error condition that renders the entire connection unusable is a
    connection error.[¶](#section-5.4-2.1){.pilcrow}]{#section-5.4-2.1}
-   [An error in an individual stream is a stream
    error.[¶](#section-5.4-2.2){.pilcrow}]{#section-5.4-2.2}

A list of error codes is included in [Section
7](#ErrorCodes){.xref}.[¶](#section-5.4-3){.pilcrow}

It is possible that an endpoint will encounter frames that would cause
multiple errors. Implementations [MAY]{.bcp14} discover multiple errors
during processing, but they [SHOULD]{.bcp14} report at most one stream
and one connection error as a result.[¶](#section-5.4-4){.pilcrow}

The first stream error reported for a given stream prevents any other
errors on that stream from being reported. In comparison, the protocol
permits multiple [GOAWAY](#GOAWAY){.xref} frames, though an endpoint
[SHOULD]{.bcp14} report just one type of connection error unless an
error is encountered during graceful shutdown. If this occurs, an
endpoint [MAY]{.bcp14} send an additional GOAWAY frame with the new
error code, in addition to any prior GOAWAY that contained
[NO_ERROR](#NO_ERROR){.xref}.[¶](#section-5.4-5){.pilcrow}

If an endpoint detects multiple different errors, it [MAY]{.bcp14}
choose to report any one of those errors. If a frame causes a connection
error, that error [MUST]{.bcp14} be reported. Additionally, an endpoint
[MAY]{.bcp14} use any applicable error code when it detects an error
condition; a generic error code (such as
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref} or
[INTERNAL_ERROR](#INTERNAL_ERROR){.xref}) can always be used in place of
more specific error codes.[¶](#section-5.4-6){.pilcrow}

::: {#ConnectionErrorHandler}
::: {#section-5.4.1 .section}
#### [5.4.1.](#section-5.4.1){.section-number .selfRef} [Connection Error Handling](#name-connection-error-handling){.section-name .selfRef} {#name-connection-error-handling}

A connection error is any error that prevents further processing of the
frame layer or corrupts any connection
state.[¶](#section-5.4.1-1){.pilcrow}

An endpoint that encounters a connection error [SHOULD]{.bcp14} first
send a [GOAWAY](#GOAWAY){.xref} frame ([Section 6.8](#GOAWAY){.xref})
with the stream identifier of the last stream that it successfully
received from its peer. The [GOAWAY](#GOAWAY){.xref} frame includes an
[error code](#ErrorCodes){.xref} ([Section 7](#ErrorCodes){.xref}) that
indicates why the connection is terminating. After sending the
[GOAWAY](#GOAWAY){.xref} frame for an error condition, the endpoint
[MUST]{.bcp14} close the TCP connection.[¶](#section-5.4.1-2){.pilcrow}

It is possible that the [GOAWAY](#GOAWAY){.xref} will not be reliably
received by the receiving endpoint. In the event of a connection error,
[GOAWAY](#GOAWAY){.xref} only provides a best-effort attempt to
communicate with the peer about why the connection is being
terminated.[¶](#section-5.4.1-3){.pilcrow}

An endpoint can end a connection at any time. In particular, an endpoint
[MAY]{.bcp14} choose to treat a stream error as a connection error.
Endpoints [SHOULD]{.bcp14} send a [GOAWAY](#GOAWAY){.xref} frame when
ending a connection, providing that circumstances permit
it.[¶](#section-5.4.1-4){.pilcrow}
:::
:::

::: {#StreamErrorHandler}
::: {#section-5.4.2 .section}
#### [5.4.2.](#section-5.4.2){.section-number .selfRef} [Stream Error Handling](#name-stream-error-handling){.section-name .selfRef} {#name-stream-error-handling}

A stream error is an error related to a specific stream that does not
affect processing of other streams.[¶](#section-5.4.2-1){.pilcrow}

An endpoint that detects a stream error sends a
[RST_STREAM](#RST_STREAM){.xref} frame ([Section
6.4](#RST_STREAM){.xref}) that contains the stream identifier of the
stream where the error occurred. The [RST_STREAM](#RST_STREAM){.xref}
frame includes an error code that indicates the type of
error.[¶](#section-5.4.2-2){.pilcrow}

A [RST_STREAM](#RST_STREAM){.xref} is the last frame that an endpoint
can send on a stream. The peer that sends the
[RST_STREAM](#RST_STREAM){.xref} frame [MUST]{.bcp14} be prepared to
receive any frames that were sent or enqueued for sending by the remote
peer. These frames can be ignored, except where they modify connection
state (such as the state maintained for [field section
compression](#FieldBlock){.xref} ([Section 4.3](#FieldBlock){.xref}) or
flow control).[¶](#section-5.4.2-3){.pilcrow}

Normally, an endpoint [SHOULD NOT]{.bcp14} send more than one
[RST_STREAM](#RST_STREAM){.xref} frame for any stream. However, an
endpoint [MAY]{.bcp14} send additional [RST_STREAM](#RST_STREAM){.xref}
frames if it receives frames on a closed stream after more than a
round-trip time. This behavior is permitted to deal with misbehaving
implementations.[¶](#section-5.4.2-4){.pilcrow}

To avoid looping, an endpoint [MUST NOT]{.bcp14} send a
[RST_STREAM](#RST_STREAM){.xref} in response to a
[RST_STREAM](#RST_STREAM){.xref} frame.[¶](#section-5.4.2-5){.pilcrow}
:::
:::

::: {#section-5.4.3 .section}
#### [5.4.3.](#section-5.4.3){.section-number .selfRef} [Connection Termination](#name-connection-termination){.section-name .selfRef} {#name-connection-termination}

If the TCP connection is closed or reset while streams remain in the
\"open\" or \"half-closed\" states, then the affected streams cannot be
automatically retried (see [Section 8.7](#Reliability){.xref} for
details).[¶](#section-5.4.3-1){.pilcrow}
:::
:::
:::

::: {#extensibility}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [Extending HTTP/2](#name-extending-http-2){.section-name .selfRef} {#name-extending-http-2}

HTTP/2 permits extension of the protocol. Within the limitations
described in this section, protocol extensions can be used to provide
additional services or alter any aspect of the protocol. Extensions are
effective only within the scope of a single HTTP/2
connection.[¶](#section-5.5-1){.pilcrow}

This applies to the protocol elements defined in this document. This
does not affect the existing options for extending HTTP, such as
defining new methods, status codes, or fields (see [Section
16](https://www.rfc-editor.org/rfc/rfc9110#section-16){.relref} of
\[[HTTP](#RFC9110){.xref}\]).[¶](#section-5.5-2){.pilcrow}

Extensions are permitted to use new [frame types](#FrameHeader){.xref}
([Section 4.1](#FrameHeader){.xref}), new [settings](#SETTINGS){.xref}
([Section 6.5](#SETTINGS){.xref}), or new [error
codes](#ErrorCodes){.xref} ([Section 7](#ErrorCodes){.xref}). Registries
for managing these extension points are defined in [Section
11](https://www.rfc-editor.org/rfc/rfc7540#section-11){.relref} of
\[[RFC7540](#RFC7540){.xref}\].[¶](#section-5.5-3){.pilcrow}

Implementations [MUST]{.bcp14} ignore unknown or unsupported values in
all extensible protocol elements. Implementations [MUST]{.bcp14} discard
frames that have unknown or unsupported types. This means that any of
these extension points can be safely used by extensions without prior
arrangement or negotiation. However, extension frames that appear in the
middle of a [field block](#FieldBlock){.xref} ([Section
4.3](#FieldBlock){.xref}) are not permitted; these [MUST]{.bcp14} be
treated as a [connection error](#ConnectionErrorHandler){.xref}
([Section 5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-5.5-4){.pilcrow}

Extensions [SHOULD]{.bcp14} avoid changing protocol elements defined in
this document or elements for which no extension mechanism is defined.
This includes changes to the layout of frames, additions or changes to
the way that frames are composed into [HTTP
messages](#HttpFraming){.xref} ([Section 8.1](#HttpFraming){.xref}), the
definition of pseudo-header fields, or changes to any protocol element
that a compliant endpoint might treat as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}).[¶](#section-5.5-5){.pilcrow}

An extension that changes existing protocol elements or state
[MUST]{.bcp14} be negotiated before being used. For example, an
extension that changes the layout of the [HEADERS](#HEADERS){.xref}
frame cannot be used until the peer has given a positive signal that
this is acceptable. In this case, it could also be necessary to
coordinate when the revised layout comes into effect. For example,
treating frames other than [DATA](#DATA){.xref} frames as flow
controlled requires a change in semantics that both endpoints need to
understand, so this can only be done through
negotiation.[¶](#section-5.5-6){.pilcrow}

This document doesn\'t mandate a specific method for negotiating the use
of an extension but notes that a [setting](#SettingValues){.xref}
([Section 6.5.2](#SettingValues){.xref}) could be used for that purpose.
If both peers set a value that indicates willingness to use the
extension, then the extension can be used. If a setting is used for
extension negotiation, the initial value [MUST]{.bcp14} be defined in
such a fashion that the extension is initially
disabled.[¶](#section-5.5-7){.pilcrow}
:::
:::
:::
:::

::: {#FrameTypes}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Frame Definitions](#name-frame-definitions){.section-name .selfRef} {#name-frame-definitions}

This specification defines a number of frame types, each identified by a
unique 8-bit type code. Each frame type serves a distinct purpose in the
establishment and management of either the connection as a whole or
individual streams.[¶](#section-6-1){.pilcrow}

The transmission of specific frame types can alter the state of a
connection. If endpoints fail to maintain a synchronized view of the
connection state, successful communication within the connection will no
longer be possible. Therefore, it is important that endpoints have a
shared comprehension of how the state is affected by the use of any
given frame.[¶](#section-6-2){.pilcrow}

::: {#DATA}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [DATA](#name-data){.section-name .selfRef} {#name-data}

DATA frames (type=0x00) convey arbitrary, variable-length sequences of
octets associated with a stream. One or more DATA frames are used, for
instance, to carry HTTP request or response message
contents.[¶](#section-6.1-1){.pilcrow}

DATA frames [MAY]{.bcp14} also contain padding. Padding can be added to
DATA frames to obscure the size of messages. Padding is a security
feature; see [Section
10.7](#padding){.xref}.[¶](#section-6.1-2){.pilcrow}

[]{#name-data-frame-format}

::: {#DATAFrameFormat}
::: {#section-6.1-3.1 .alignLeft .art-inline .art-text .artwork}
    DATA Frame {
      Length (24),
      Type (8) = 0x00,

      Unused Flags (4),
      PADDED Flag (1),
      Unused Flags (2),
      END_STREAM Flag (1),

      Reserved (1),
      Stream Identifier (31),

      [Pad Length (8)],
      Data (..),
      Padding (..2040),
    }
:::

[Figure 3](#figure-3){.selfRef}: [DATA Frame
Format](#name-data-frame-format){.selfRef}
:::

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields
are described in [Section 4](#FramingLayer){.xref}. The DATA frame
contains the following additional fields:[¶](#section-6.1-4){.pilcrow}

[]{.break}

Pad Length:
:   An 8-bit field containing the length of the frame padding in units
    of octets. This field is conditional and is only present if the
    PADDED flag is set.[¶](#section-6.1-5.2){.pilcrow}
:   

Data:
:   Application data. The amount of data is the remainder of the frame
    payload after subtracting the length of the other fields that are
    present.[¶](#section-6.1-5.4){.pilcrow}
:   

Padding:
:   Padding octets that contain no application semantic value. Padding
    octets [MUST]{.bcp14} be set to zero when sending. A receiver is not
    obligated to verify padding but [MAY]{.bcp14} treat non-zero padding
    as a [connection error](#ConnectionErrorHandler){.xref} ([Section
    5.4.1](#ConnectionErrorHandler){.xref}) of type
    [PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.1-5.6){.pilcrow}
:   

The DATA frame defines the following flags:[¶](#section-6.1-6){.pilcrow}

[]{.break}

PADDED (0x08):
:   When set, the PADDED flag indicates that the Pad Length field and
    any padding that it describes are
    present.[¶](#section-6.1-7.2){.pilcrow}
:   

END_STREAM (0x01):
:   When set, the END_STREAM flag indicates that this frame is the last
    that the endpoint will send for the identified stream. Setting this
    flag causes the stream to enter one of [the \"half-closed\" states
    or the \"closed\" state](#StreamStates){.xref} ([Section
    5.1](#StreamStates){.xref}).[¶](#section-6.1-7.4){.pilcrow}
:   

Note: An endpoint that learns of stream closure after sending all data
can close a stream by sending a STREAM frame with a zero-length Data
field and the END_STREAM flag set. This is only possible if the endpoint
does not send trailers, as the END_STREAM flag appears on a HEADERS
frame in that case; see [Section
8.1](#HttpFraming){.xref}.[¶](#section-6.1-8.1){.pilcrow}

DATA frames [MUST]{.bcp14} be associated with a stream. If a DATA frame
is received whose Stream Identifier field is 0x00, the recipient
[MUST]{.bcp14} respond with a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.1-9){.pilcrow}

DATA frames are subject to flow control and can only be sent when a
stream is in the \"open\" or \"half-closed (remote)\" state. The entire
DATA frame payload is included in flow control, including the Pad Length
and Padding fields if present. If a DATA frame is received whose stream
is not in the \"open\" or \"half-closed (local)\" state, the recipient
[MUST]{.bcp14} respond with a [stream error](#StreamErrorHandler){.xref}
([Section 5.4.2](#StreamErrorHandler){.xref}) of type
[STREAM_CLOSED](#STREAM_CLOSED){.xref}.[¶](#section-6.1-10){.pilcrow}

The total number of padding octets is determined by the value of the Pad
Length field. If the length of the padding is the length of the frame
payload or greater, the recipient [MUST]{.bcp14} treat this as a
[connection error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.1-11){.pilcrow}

Note: A frame can be increased in size by one octet by including a Pad
Length field with a value of zero.[¶](#section-6.1-12.1){.pilcrow}
:::
:::

::: {#HEADERS}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [HEADERS](#name-headers){.section-name .selfRef} {#name-headers}

The HEADERS frame (type=0x01) is used to [open a
stream](#StreamStates){.xref} ([Section 5.1](#StreamStates){.xref}), and
additionally carries a field block fragment. Despite the name, a HEADERS
frame can carry a header section or a trailer section. HEADERS frames
can be sent on a stream in the \"idle\", \"reserved (local)\", \"open\",
or \"half-closed (remote)\" state.[¶](#section-6.2-1){.pilcrow}

[]{#name-headers-frame-format}

::: {#HEADERSFrameFormat}
::: {#section-6.2-2.1 .alignLeft .art-inline .art-text .artwork}
    HEADERS Frame {
      Length (24),
      Type (8) = 0x01,

      Unused Flags (2),
      PRIORITY Flag (1),
      Unused Flag (1),
      PADDED Flag (1),
      END_HEADERS Flag (1),
      Unused Flag (1),
      END_STREAM Flag (1),

      Reserved (1),
      Stream Identifier (31),

      [Pad Length (8)],
      [Exclusive (1)],
      [Stream Dependency (31)],
      [Weight (8)],
      Field Block Fragment (..),
      Padding (..2040),
    }
:::

[Figure 4](#figure-4){.selfRef}: [HEADERS Frame
Format](#name-headers-frame-format){.selfRef}
:::

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields
are described in [Section 4](#FramingLayer){.xref}. The HEADERS frame
payload has the following additional
fields:[¶](#section-6.2-3){.pilcrow}

[]{.break}

Pad Length:
:   An 8-bit field containing the length of the frame padding in units
    of octets. This field is only present if the PADDED flag is
    set.[¶](#section-6.2-4.2){.pilcrow}
:   

Exclusive:
:   A single-bit flag. This field is only present if the PRIORITY flag
    is set. Priority signals in HEADERS frames are deprecated; see
    [Section
    5.3.2](#PriorityHere){.xref}.[¶](#section-6.2-4.4){.pilcrow}
:   

Stream Dependency:
:   A 31-bit stream identifier. This field is only present if the
    PRIORITY flag is set.[¶](#section-6.2-4.6){.pilcrow}
:   

Weight:
:   An unsigned 8-bit integer. This field is only present if the
    PRIORITY flag is set.[¶](#section-6.2-4.8){.pilcrow}
:   

Field Block Fragment:
:   A [field block fragment](#FieldBlock){.xref} ([Section
    4.3](#FieldBlock){.xref}).[¶](#section-6.2-4.10){.pilcrow}
:   

Padding:
:   Padding octets that contain no application semantic value. Padding
    octets [MUST]{.bcp14} be set to zero when sending. A receiver is not
    obligated to verify padding but [MAY]{.bcp14} treat non-zero padding
    as a [connection error](#ConnectionErrorHandler){.xref} ([Section
    5.4.1](#ConnectionErrorHandler){.xref}) of type
    [PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.2-4.12){.pilcrow}
:   

The HEADERS frame defines the following
flags:[¶](#section-6.2-5){.pilcrow}

[]{.break}

PRIORITY (0x20):

:   When set, the PRIORITY flag indicates that the Exclusive, Stream
    Dependency, and Weight fields are
    present.[¶](#section-6.2-6.2.1){.pilcrow}

:   

PADDED (0x08):

:   When set, the PADDED flag indicates that the Pad Length field and
    any padding that it describes are
    present.[¶](#section-6.2-6.4.1){.pilcrow}

:   

END_HEADERS (0x04):

:   When set, the END_HEADERS flag indicates that this frame contains an
    entire [field block](#FieldBlock){.xref} ([Section
    4.3](#FieldBlock){.xref}) and is not followed by any
    [CONTINUATION](#CONTINUATION){.xref}
    frames.[¶](#section-6.2-6.6.1){.pilcrow}

    A HEADERS frame without the END_HEADERS flag set [MUST]{.bcp14} be
    followed by a [CONTINUATION](#CONTINUATION){.xref} frame for the
    same stream. A receiver [MUST]{.bcp14} treat the receipt of any
    other type of frame or a frame on a different stream as a
    [connection error](#ConnectionErrorHandler){.xref} ([Section
    5.4.1](#ConnectionErrorHandler){.xref}) of type
    [PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.2-6.6.2){.pilcrow}

:   

END_STREAM (0x01):

:   When set, the END_STREAM flag indicates that the [field
    block](#FieldBlock){.xref} ([Section 4.3](#FieldBlock){.xref}) is
    the last that the endpoint will send for the identified
    stream.[¶](#section-6.2-6.8.1){.pilcrow}

    A HEADERS frame with the END_STREAM flag set signals the end of a
    stream. However, a HEADERS frame with the END_STREAM flag set can be
    followed by [CONTINUATION](#CONTINUATION){.xref} frames on the same
    stream. Logically, the [CONTINUATION](#CONTINUATION){.xref} frames
    are part of the HEADERS frame.[¶](#section-6.2-6.8.2){.pilcrow}

:   

The frame payload of a HEADERS frame contains a [field block
fragment](#FieldBlock){.xref} ([Section 4.3](#FieldBlock){.xref}). A
field block that does not fit within a HEADERS frame is continued in a
[CONTINUATION frame](#CONTINUATION){.xref} ([Section
6.10](#CONTINUATION){.xref}).[¶](#section-6.2-7){.pilcrow}

HEADERS frames [MUST]{.bcp14} be associated with a stream. If a HEADERS
frame is received whose Stream Identifier field is 0x00, the recipient
[MUST]{.bcp14} respond with a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.2-8){.pilcrow}

The HEADERS frame changes the connection state as described in [Section
4.3](#FieldBlock){.xref}.[¶](#section-6.2-9){.pilcrow}

The total number of padding octets is determined by the value of the Pad
Length field. If the length of the padding is the length of the frame
payload or greater, the recipient [MUST]{.bcp14} treat this as a
[connection error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.2-10){.pilcrow}

Note: A frame can be increased in size by one octet by including a Pad
Length field with a value of zero.[¶](#section-6.2-11.1){.pilcrow}
:::
:::

::: {#PRIORITY}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [PRIORITY](#name-priority){.section-name .selfRef} {#name-priority}

The PRIORITY frame (type=0x02) is deprecated; see [Section
5.3.2](#PriorityHere){.xref}. A PRIORITY frame can be sent in any stream
state, including idle or closed streams.[¶](#section-6.3-1){.pilcrow}

[]{#name-priority-frame-format}

::: {#PRIORITYFrameFormat}
::: {#section-6.3-2.1 .alignLeft .art-inline .art-text .artwork}
    PRIORITY Frame {
      Length (24) = 0x05,
      Type (8) = 0x02,

      Unused Flags (8),

      Reserved (1),
      Stream Identifier (31),

      Exclusive (1),
      Stream Dependency (31),
      Weight (8),
    }
:::

[Figure 5](#figure-5){.selfRef}: [PRIORITY Frame
Format](#name-priority-frame-format){.selfRef}
:::

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields
are described in [Section 4](#FramingLayer){.xref}. The frame payload of
a PRIORITY frame contains the following additional
fields:[¶](#section-6.3-3){.pilcrow}

[]{.break}

Exclusive:
:   A single-bit flag.[¶](#section-6.3-4.2){.pilcrow}
:   

Stream Dependency:
:   A 31-bit stream identifier.[¶](#section-6.3-4.4){.pilcrow}
:   

Weight:
:   An unsigned 8-bit integer.[¶](#section-6.3-4.6){.pilcrow}
:   

The PRIORITY frame does not define any
flags.[¶](#section-6.3-5){.pilcrow}

The PRIORITY frame always identifies a stream. If a PRIORITY frame is
received with a stream identifier of 0x00, the recipient [MUST]{.bcp14}
respond with a [connection error](#ConnectionErrorHandler){.xref}
([Section 5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.3-6){.pilcrow}

Sending or receiving a PRIORITY frame does not affect the state of any
stream ([Section 5.1](#StreamStates){.xref}). The PRIORITY frame can be
sent on a stream in any state, including \"idle\" or \"closed\". A
PRIORITY frame cannot be sent between consecutive frames that comprise a
single [field block](#FieldBlock){.xref} ([Section
4.3](#FieldBlock){.xref}).[¶](#section-6.3-7){.pilcrow}

A PRIORITY frame with a length other than 5 octets [MUST]{.bcp14} be
treated as a [stream error](#StreamErrorHandler){.xref} ([Section
5.4.2](#StreamErrorHandler){.xref}) of type
[FRAME_SIZE_ERROR](#FRAME_SIZE_ERROR){.xref}.[¶](#section-6.3-8){.pilcrow}
:::
:::

::: {#RST_STREAM}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [RST_STREAM](#name-rst_stream){.section-name .selfRef} {#name-rst_stream}

The RST_STREAM frame (type=0x03) allows for immediate termination of a
stream. RST_STREAM is sent to request cancellation of a stream or to
indicate that an error condition has
occurred.[¶](#section-6.4-1){.pilcrow}

[]{#name-rst_stream-frame-format}

::: {#RST_STREAMFrameFormat}
::: {#section-6.4-2.1 .alignLeft .art-inline .art-text .artwork}
    RST_STREAM Frame {
      Length (24) = 0x04,
      Type (8) = 0x03,

      Unused Flags (8),

      Reserved (1),
      Stream Identifier (31),

      Error Code (32),
    }
:::

[Figure 6](#figure-6){.selfRef}: [RST_STREAM Frame
Format](#name-rst_stream-frame-format){.selfRef}
:::

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields
are described in [Section 4](#FramingLayer){.xref}. Additionally, the
RST_STREAM frame contains a single unsigned, 32-bit integer identifying
the [error code](#ErrorCodes){.xref} ([Section 7](#ErrorCodes){.xref}).
The error code indicates why the stream is being
terminated.[¶](#section-6.4-3){.pilcrow}

The RST_STREAM frame does not define any
flags.[¶](#section-6.4-4){.pilcrow}

The RST_STREAM frame fully terminates the referenced stream and causes
it to enter the \"closed\" state. After receiving a RST_STREAM on a
stream, the receiver [MUST NOT]{.bcp14} send additional frames for that
stream, except for [PRIORITY](#PRIORITY){.xref}. However, after sending
the RST_STREAM, the sending endpoint [MUST]{.bcp14} be prepared to
receive and process additional frames sent on the stream that might have
been sent by the peer prior to the arrival of the
RST_STREAM.[¶](#section-6.4-5){.pilcrow}

RST_STREAM frames [MUST]{.bcp14} be associated with a stream. If a
RST_STREAM frame is received with a stream identifier of 0x00, the
recipient [MUST]{.bcp14} treat this as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.4-6){.pilcrow}

RST_STREAM frames [MUST NOT]{.bcp14} be sent for a stream in the
\"idle\" state. If a RST_STREAM frame identifying an idle stream is
received, the recipient [MUST]{.bcp14} treat this as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.4-7){.pilcrow}

A RST_STREAM frame with a length other than 4 octets [MUST]{.bcp14} be
treated as a [connection error](#ConnectionErrorHandler){.xref}
([Section 5.4.1](#ConnectionErrorHandler){.xref}) of type
[FRAME_SIZE_ERROR](#FRAME_SIZE_ERROR){.xref}.[¶](#section-6.4-8){.pilcrow}
:::
:::

::: {#SETTINGS}
::: {#section-6.5 .section}
### [6.5.](#section-6.5){.section-number .selfRef} [SETTINGS](#name-settings){.section-name .selfRef} {#name-settings}

The SETTINGS frame (type=0x04) conveys configuration parameters that
affect how endpoints communicate, such as preferences and constraints on
peer behavior. The SETTINGS frame is also used to acknowledge the
receipt of those settings. Individually, a configuration parameter from
a SETTINGS frame is referred to as a
\"setting\".[¶](#section-6.5-1){.pilcrow}

Settings are not negotiated; they describe characteristics of the
sending peer, which are used by the receiving peer. Different values for
the same setting can be advertised by each peer. For example, a client
might set a high initial flow-control window, whereas a server might set
a lower value to conserve resources.[¶](#section-6.5-2){.pilcrow}

A SETTINGS frame [MUST]{.bcp14} be sent by both endpoints at the start
of a connection and [MAY]{.bcp14} be sent at any other time by either
endpoint over the lifetime of the connection. Implementations
[MUST]{.bcp14} support all of the settings defined by this
specification.[¶](#section-6.5-3){.pilcrow}

Each parameter in a SETTINGS frame replaces any existing value for that
parameter. Settings are processed in the order in which they appear, and
a receiver of a SETTINGS frame does not need to maintain any state other
than the current value of each setting. Therefore, the value of a
SETTINGS parameter is the last value that is seen by a
receiver.[¶](#section-6.5-4){.pilcrow}

SETTINGS frames are acknowledged by the receiving peer. To enable this,
the SETTINGS frame defines the ACK flag:[¶](#section-6.5-5){.pilcrow}

[]{.break}

ACK (0x01):
:   When set, the ACK flag indicates that this frame acknowledges
    receipt and application of the peer\'s SETTINGS frame. When this bit
    is set, the frame payload of the SETTINGS frame [MUST]{.bcp14} be
    empty. Receipt of a SETTINGS frame with the ACK flag set and a
    length field value other than 0 [MUST]{.bcp14} be treated as a
    [connection error](#ConnectionErrorHandler){.xref} ([Section
    5.4.1](#ConnectionErrorHandler){.xref}) of type
    [FRAME_SIZE_ERROR](#FRAME_SIZE_ERROR){.xref}. For more information,
    see [Section 6.5.3](#SettingsSync){.xref} (\"[Settings
    Synchronization](#SettingsSync){.xref}\").[¶](#section-6.5-6.2){.pilcrow}
:   

SETTINGS frames always apply to a connection, never a single stream. The
stream identifier for a SETTINGS frame [MUST]{.bcp14} be zero (0x00). If
an endpoint receives a SETTINGS frame whose Stream Identifier field is
anything other than 0x00, the endpoint [MUST]{.bcp14} respond with a
[connection error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.5-7){.pilcrow}

The SETTINGS frame affects connection state. A badly formed or
incomplete SETTINGS frame [MUST]{.bcp14} be treated as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.5-8){.pilcrow}

A SETTINGS frame with a length other than a multiple of 6 octets
[MUST]{.bcp14} be treated as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[FRAME_SIZE_ERROR](#FRAME_SIZE_ERROR){.xref}.[¶](#section-6.5-9){.pilcrow}

::: {#SettingFormat}
::: {#section-6.5.1 .section}
#### [6.5.1.](#section-6.5.1){.section-number .selfRef} [SETTINGS Format](#name-settings-format){.section-name .selfRef} {#name-settings-format}

The frame payload of a SETTINGS frame consists of zero or more settings,
each consisting of an unsigned 16-bit setting identifier and an unsigned
32-bit value.[¶](#section-6.5.1-1){.pilcrow}

[]{#name-settings-frame-format}

::: {#SettingFrameFormat}
::: {#section-6.5.1-2.1 .alignLeft .art-inline .art-text .artwork}
    SETTINGS Frame {
      Length (24),
      Type (8) = 0x04,

      Unused Flags (7),
      ACK Flag (1),

      Reserved (1),
      Stream Identifier (31) = 0,

      Setting (48) ...,
    }

    Setting {
      Identifier (16),
      Value (32),
    }
:::

[Figure 7](#figure-7){.selfRef}: [SETTINGS Frame
Format](#name-settings-frame-format){.selfRef}
:::

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields
are described in [Section 4](#FramingLayer){.xref}. The frame payload of
a SETTINGS frame contains any number of Setting fields, each of which
consists of:[¶](#section-6.5.1-3){.pilcrow}

[]{.break}

Identifier:
:   A 16-bit setting identifier; see [Section
    6.5.2](#SettingValues){.xref}.[¶](#section-6.5.1-4.2){.pilcrow}
:   

Value:
:   A 32-bit value for the setting.[¶](#section-6.5.1-4.4){.pilcrow}
:   
:::
:::

::: {#SettingValues}
::: {#section-6.5.2 .section}
#### [6.5.2.](#section-6.5.2){.section-number .selfRef} [Defined Settings](#name-defined-settings){.section-name .selfRef} {#name-defined-settings}

The following settings are defined:[¶](#section-6.5.2-1){.pilcrow}

[]{.break}

::: {#SETTINGS_HEADER_TABLE_SIZE}
SETTINGS_HEADER_TABLE_SIZE (0x01):
:::

This setting allows the sender to inform the remote endpoint of the
maximum size of the compression table used to decode field blocks, in
units of octets. The encoder can select any size equal to or less than
this value by using signaling specific to the compression format inside
a field block (see \[[COMPRESSION](#RFC7541){.xref}\]). The initial
value is 4,096 octets.[¶](#section-6.5.2-2.2.1){.pilcrow}

::: {#SETTINGS_ENABLE_PUSH}
SETTINGS_ENABLE_PUSH (0x02):
:::

This setting can be used to enable or disable server push. A server
[MUST NOT]{.bcp14} send a [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame if
it receives this parameter set to a value of 0; see [Section
8.4](#PushResources){.xref}. A client that has both set this parameter
to 0 and had it acknowledged [MUST]{.bcp14} treat the receipt of a
[PUSH_PROMISE](#PUSH_PROMISE){.xref} frame as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.5.2-2.4.1){.pilcrow}

The initial value of SETTINGS_ENABLE_PUSH is 1. For a client, this value
indicates that it is willing to receive PUSH_PROMISE frames. For a
server, this initial value has no effect, and is equivalent to the value
0. Any value other than 0 or 1 [MUST]{.bcp14} be treated as a
[connection error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.5.2-2.4.2){.pilcrow}

A server [MUST NOT]{.bcp14} explicitly set this value to 1. A server
[MAY]{.bcp14} choose to omit this setting when it sends a SETTINGS
frame, but if a server does include a value, it [MUST]{.bcp14} be 0. A
client [MUST]{.bcp14} treat receipt of a SETTINGS frame with
SETTINGS_ENABLE_PUSH set to 1 as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.5.2-2.4.3){.pilcrow}

::: {#SETTINGS_MAX_CONCURRENT_STREAMS}
SETTINGS_MAX_CONCURRENT_STREAMS (0x03):
:::

This setting indicates the maximum number of concurrent streams that the
sender will allow. This limit is directional: it applies to the number
of streams that the sender permits the receiver to create. Initially,
there is no limit to this value. It is recommended that this value be no
smaller than 100, so as to not unnecessarily limit
parallelism.[¶](#section-6.5.2-2.6.1){.pilcrow}

A value of 0 for SETTINGS_MAX_CONCURRENT_STREAMS [SHOULD NOT]{.bcp14} be
treated as special by endpoints. A zero value does prevent the creation
of new streams; however, this can also happen for any limit that is
exhausted with active streams. Servers [SHOULD]{.bcp14} only set a zero
value for short durations; if a server does not wish to accept requests,
closing the connection is more
appropriate.[¶](#section-6.5.2-2.6.2){.pilcrow}

::: {#SETTINGS_INITIAL_WINDOW_SIZE}
SETTINGS_INITIAL_WINDOW_SIZE (0x04):
:::

This setting indicates the sender\'s initial window size (in units of
octets) for stream-level flow control. The initial value is 2^16^-1
(65,535) octets.[¶](#section-6.5.2-2.8.1){.pilcrow}

This setting affects the window size of all streams (see [Section
6.9.2](#InitialWindowSize){.xref}).[¶](#section-6.5.2-2.8.2){.pilcrow}

Values above the maximum flow-control window size of 2^31^-1
[MUST]{.bcp14} be treated as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[FLOW_CONTROL_ERROR](#FLOW_CONTROL_ERROR){.xref}.[¶](#section-6.5.2-2.8.3){.pilcrow}

::: {#SETTINGS_MAX_FRAME_SIZE}
SETTINGS_MAX_FRAME_SIZE (0x05):
:::

This setting indicates the size of the largest frame payload that the
sender is willing to receive, in units of
octets.[¶](#section-6.5.2-2.10.1){.pilcrow}

The initial value is 2^14^ (16,384) octets. The value advertised by an
endpoint [MUST]{.bcp14} be between this initial value and the maximum
allowed frame size (2^24^-1 or 16,777,215 octets), inclusive. Values
outside this range [MUST]{.bcp14} be treated as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.5.2-2.10.2){.pilcrow}

::: {#SETTINGS_MAX_HEADER_LIST_SIZE}
SETTINGS_MAX_HEADER_LIST_SIZE (0x06):
:::

This advisory setting informs a peer of the maximum field section size
that the sender is prepared to accept, in units of octets. The value is
based on the uncompressed size of field lines, including the length of
the name and value in units of octets plus an overhead of 32 octets for
each field line.[¶](#section-6.5.2-2.12.1){.pilcrow}

For any given request, a lower limit than what is advertised
[MAY]{.bcp14} be enforced. The initial value of this setting is
unlimited.[¶](#section-6.5.2-2.12.2){.pilcrow}

An endpoint that receives a SETTINGS frame with any unknown or
unsupported identifier [MUST]{.bcp14} ignore that
setting.[¶](#section-6.5.2-3){.pilcrow}
:::
:::

::: {#SettingsSync}
::: {#section-6.5.3 .section}
#### [6.5.3.](#section-6.5.3){.section-number .selfRef} [Settings Synchronization](#name-settings-synchronization){.section-name .selfRef} {#name-settings-synchronization}

Most values in SETTINGS benefit from or require an understanding of when
the peer has received and applied the changed parameter values. In order
to provide such synchronization timepoints, the recipient of a SETTINGS
frame in which the ACK flag is not set [MUST]{.bcp14} apply the updated
settings as soon as possible upon receipt. SETTINGS frames are
acknowledged in the order in which they are
received.[¶](#section-6.5.3-1){.pilcrow}

The values in the SETTINGS frame [MUST]{.bcp14} be processed in the
order they appear, with no other frame processing between values.
Unsupported settings [MUST]{.bcp14} be ignored. Once all values have
been processed, the recipient [MUST]{.bcp14} immediately emit a SETTINGS
frame with the ACK flag set. Upon receiving a SETTINGS frame with the
ACK flag set, the sender of the altered settings can rely on the values
from the oldest unacknowledged SETTINGS frame having been
applied.[¶](#section-6.5.3-2){.pilcrow}

If the sender of a SETTINGS frame does not receive an acknowledgment
within a reasonable amount of time, it [MAY]{.bcp14} issue a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[SETTINGS_TIMEOUT](#SETTINGS_TIMEOUT){.xref}. In setting a timeout, some
allowance needs to be made for processing delays at the peer; a timeout
that is solely based on the round-trip time between endpoints might
result in spurious errors.[¶](#section-6.5.3-3){.pilcrow}
:::
:::
:::
:::

::: {#PUSH_PROMISE}
::: {#section-6.6 .section}
### [6.6.](#section-6.6){.section-number .selfRef} [PUSH_PROMISE](#name-push_promise){.section-name .selfRef} {#name-push_promise}

The PUSH_PROMISE frame (type=0x05) is used to notify the peer endpoint
in advance of streams the sender intends to initiate. The PUSH_PROMISE
frame includes the unsigned 31-bit identifier of the stream the endpoint
plans to create along with a field section that provides additional
context for the stream. [Section 8.4](#PushResources){.xref} contains a
thorough description of the use of PUSH_PROMISE
frames.[¶](#section-6.6-1){.pilcrow}

[]{#name-push_promise-frame-format}

::: {#PUSH_PROMISEFrameFormat}
::: {#section-6.6-2.1 .alignLeft .art-inline .art-text .artwork}
    PUSH_PROMISE Frame {
      Length (24),
      Type (8) = 0x05,

      Unused Flags (4),
      PADDED Flag (1),
      END_HEADERS Flag (1),
      Unused Flags (2),

      Reserved (1),
      Stream Identifier (31),

      [Pad Length (8)],
      Reserved (1),
      Promised Stream ID (31),
      Field Block Fragment (..),
      Padding (..2040),
    }
:::

[Figure 8](#figure-8){.selfRef}: [PUSH_PROMISE Frame
Format](#name-push_promise-frame-format){.selfRef}
:::

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields
are described in [Section 4](#FramingLayer){.xref}. The PUSH_PROMISE
frame payload has the following additional
fields:[¶](#section-6.6-3){.pilcrow}

[]{.break}

Pad Length:
:   An 8-bit field containing the length of the frame padding in units
    of octets. This field is only present if the PADDED flag is
    set.[¶](#section-6.6-4.2){.pilcrow}
:   

Promised Stream ID:
:   An unsigned 31-bit integer that identifies the stream that is
    reserved by the PUSH_PROMISE. The promised stream identifier
    [MUST]{.bcp14} be a valid choice for the next stream sent by the
    sender (see \"new stream identifier\" in [Section
    5.1.1](#StreamIdentifiers){.xref}).[¶](#section-6.6-4.4){.pilcrow}
:   

Field Block Fragment:
:   A [field block fragment](#FieldBlock){.xref} ([Section
    4.3](#FieldBlock){.xref}) containing the request control data and a
    header section.[¶](#section-6.6-4.6){.pilcrow}
:   

Padding:
:   Padding octets that contain no application semantic value. Padding
    octets [MUST]{.bcp14} be set to zero when sending. A receiver is not
    obligated to verify padding but [MAY]{.bcp14} treat non-zero padding
    as a [connection error](#ConnectionErrorHandler){.xref} ([Section
    5.4.1](#ConnectionErrorHandler){.xref}) of type
    [PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.6-4.8){.pilcrow}
:   

The PUSH_PROMISE frame defines the following
flags:[¶](#section-6.6-5){.pilcrow}

[]{.break}

PADDED (0x08):

:   When set, the PADDED flag indicates that the Pad Length field and
    any padding that it describes are
    present.[¶](#section-6.6-6.2.1){.pilcrow}

:   

END_HEADERS (0x04):

:   When set, the END_HEADERS flag indicates that this frame contains an
    entire [field block](#FieldBlock){.xref} ([Section
    4.3](#FieldBlock){.xref}) and is not followed by any
    [CONTINUATION](#CONTINUATION){.xref}
    frames.[¶](#section-6.6-6.4.1){.pilcrow}

    A PUSH_PROMISE frame without the END_HEADERS flag set [MUST]{.bcp14}
    be followed by a CONTINUATION frame for the same stream. A receiver
    [MUST]{.bcp14} treat the receipt of any other type of frame or a
    frame on a different stream as a [connection
    error](#ConnectionErrorHandler){.xref} ([Section
    5.4.1](#ConnectionErrorHandler){.xref}) of type
    [PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.6-6.4.2){.pilcrow}

:   

PUSH_PROMISE frames [MUST]{.bcp14} only be sent on a peer-initiated
stream that is in either the \"open\" or \"half-closed (remote)\" state.
The stream identifier of a PUSH_PROMISE frame indicates the stream it is
associated with. If the Stream Identifier field specifies the value
0x00, a recipient [MUST]{.bcp14} respond with a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.6-7){.pilcrow}

Promised streams are not required to be used in the order they are
promised. The PUSH_PROMISE only reserves stream identifiers for later
use.[¶](#section-6.6-8){.pilcrow}

PUSH_PROMISE [MUST NOT]{.bcp14} be sent if the
[SETTINGS_ENABLE_PUSH](#SETTINGS_ENABLE_PUSH){.xref} setting of the peer
endpoint is set to 0. An endpoint that has set this setting and has
received acknowledgment [MUST]{.bcp14} treat the receipt of a
PUSH_PROMISE frame as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.6-9){.pilcrow}

Recipients of PUSH_PROMISE frames can choose to reject promised streams
by returning a [RST_STREAM](#RST_STREAM){.xref} referencing the promised
stream identifier back to the sender of the
PUSH_PROMISE.[¶](#section-6.6-10){.pilcrow}

A PUSH_PROMISE frame modifies the connection state in two ways. First,
the inclusion of a [field block](#FieldBlock){.xref} ([Section
4.3](#FieldBlock){.xref}) potentially modifies the state maintained for
field section compression. Second, PUSH_PROMISE also reserves a stream
for later use, causing the promised stream to enter the \"reserved
(local)\" or \"reserved (remote)\" state. A sender [MUST NOT]{.bcp14}
send a PUSH_PROMISE on a stream unless that stream is either \"open\" or
\"half-closed (remote)\"; the sender [MUST]{.bcp14} ensure that the
promised stream is a valid choice for a [new stream
identifier](#StreamIdentifiers){.xref} ([Section
5.1.1](#StreamIdentifiers){.xref}) (that is, the promised stream
[MUST]{.bcp14} be in the \"idle\" state).[¶](#section-6.6-11){.pilcrow}

Since PUSH_PROMISE reserves a stream, ignoring a PUSH_PROMISE frame
causes the stream state to become indeterminate. A receiver
[MUST]{.bcp14} treat the receipt of a PUSH_PROMISE on a stream that is
neither \"open\" nor \"half-closed (local)\" as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}. However, an endpoint that has
sent [RST_STREAM](#RST_STREAM){.xref} on the associated stream
[MUST]{.bcp14} handle PUSH_PROMISE frames that might have been created
before the [RST_STREAM](#RST_STREAM){.xref} frame is received and
processed.[¶](#section-6.6-12){.pilcrow}

A receiver [MUST]{.bcp14} treat the receipt of a PUSH_PROMISE that
promises an [illegal stream identifier](#StreamIdentifiers){.xref}
([Section 5.1.1](#StreamIdentifiers){.xref}) as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}. Note that an illegal stream
identifier is an identifier for a stream that is not currently in the
\"idle\" state.[¶](#section-6.6-13){.pilcrow}

The total number of padding octets is determined by the value of the Pad
Length field. If the length of the padding is the length of the frame
payload or greater, the recipient [MUST]{.bcp14} treat this as a
[connection error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.6-14){.pilcrow}

Note: A frame can be increased in size by one octet by including a Pad
Length field with a value of zero.[¶](#section-6.6-15.1){.pilcrow}
:::
:::

::: {#PING}
::: {#section-6.7 .section}
### [6.7.](#section-6.7){.section-number .selfRef} [PING](#name-ping){.section-name .selfRef} {#name-ping}

The PING frame (type=0x06) is a mechanism for measuring a minimal
round-trip time from the sender, as well as determining whether an idle
connection is still functional. PING frames can be sent from any
endpoint.[¶](#section-6.7-1){.pilcrow}

[]{#name-ping-frame-format}

::: {#PINGFrameFormat}
::: {#section-6.7-2.1 .alignLeft .art-inline .art-text .artwork}
    PING Frame {
      Length (24) = 0x08,
      Type (8) = 0x06,

      Unused Flags (7),
      ACK Flag (1),

      Reserved (1),
      Stream Identifier (31) = 0,

      Opaque Data (64),
    }
:::

[Figure 9](#figure-9){.selfRef}: [PING Frame
Format](#name-ping-frame-format){.selfRef}
:::

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields
are described in [Section
4](#FramingLayer){.xref}.[¶](#section-6.7-3){.pilcrow}

In addition to the frame header, PING frames [MUST]{.bcp14} contain 8
octets of opaque data in the frame payload. A sender can include any
value it chooses and use those octets in any
fashion.[¶](#section-6.7-4){.pilcrow}

Receivers of a PING frame that does not include an ACK flag
[MUST]{.bcp14} send a PING frame with the ACK flag set in response, with
an identical frame payload. PING responses [SHOULD]{.bcp14} be given
higher priority than any other frame.[¶](#section-6.7-5){.pilcrow}

The PING frame defines the following flags:[¶](#section-6.7-6){.pilcrow}

[]{.break}

ACK (0x01):
:   When set, the ACK flag indicates that this PING frame is a PING
    response. An endpoint [MUST]{.bcp14} set this flag in PING
    responses. An endpoint [MUST NOT]{.bcp14} respond to PING frames
    containing this flag.[¶](#section-6.7-7.2){.pilcrow}
:   

PING frames are not associated with any individual stream. If a PING
frame is received with a Stream Identifier field value other than 0x00,
the recipient [MUST]{.bcp14} respond with a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.7-8){.pilcrow}

Receipt of a PING frame with a length field value other than 8
[MUST]{.bcp14} be treated as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[FRAME_SIZE_ERROR](#FRAME_SIZE_ERROR){.xref}.[¶](#section-6.7-9){.pilcrow}
:::
:::

::: {#GOAWAY}
::: {#section-6.8 .section}
### [6.8.](#section-6.8){.section-number .selfRef} [GOAWAY](#name-goaway){.section-name .selfRef} {#name-goaway}

The GOAWAY frame (type=0x07) is used to initiate shutdown of a
connection or to signal serious error conditions. GOAWAY allows an
endpoint to gracefully stop accepting new streams while still finishing
processing of previously established streams. This enables
administrative actions, like server
maintenance.[¶](#section-6.8-1){.pilcrow}

There is an inherent race condition between an endpoint starting new
streams and the remote peer sending a GOAWAY frame. To deal with this
case, the GOAWAY contains the stream identifier of the last
peer-initiated stream that was or might be processed on the sending
endpoint in this connection. For instance, if the server sends a GOAWAY
frame, the identified stream is the highest-numbered stream initiated by
the client.[¶](#section-6.8-2){.pilcrow}

Once the GOAWAY is sent, the sender will ignore frames sent on streams
initiated by the receiver if the stream has an identifier higher than
the included last stream identifier. Receivers of a GOAWAY frame [MUST
NOT]{.bcp14} open additional streams on the connection, although a new
connection can be established for new
streams.[¶](#section-6.8-3){.pilcrow}

If the receiver of the GOAWAY has sent data on streams with a higher
stream identifier than what is indicated in the GOAWAY frame, those
streams are not or will not be processed. The receiver of the GOAWAY
frame can treat the streams as though they had never been created at
all, thereby allowing those streams to be retried later on a new
connection.[¶](#section-6.8-4){.pilcrow}

Endpoints [SHOULD]{.bcp14} always send a GOAWAY frame before closing a
connection so that the remote peer can know whether a stream has been
partially processed or not. For example, if an HTTP client sends a POST
at the same time that a server closes a connection, the client cannot
know if the server started to process that POST request if the server
does not send a GOAWAY frame to indicate what streams it might have
acted on.[¶](#section-6.8-5){.pilcrow}

An endpoint might choose to close a connection without sending a GOAWAY
for misbehaving peers.[¶](#section-6.8-6){.pilcrow}

A GOAWAY frame might not immediately precede closing of the connection;
a receiver of a GOAWAY that has no more use for the connection
[SHOULD]{.bcp14} still send a GOAWAY frame before terminating the
connection.[¶](#section-6.8-7){.pilcrow}

[]{#name-goaway-frame-format}

::: {#GOAWAYFrameFormat}
::: {#section-6.8-8.1 .alignLeft .art-inline .art-text .artwork}
    GOAWAY Frame {
      Length (24),
      Type (8) = 0x07,

      Unused Flags (8),

      Reserved (1),
      Stream Identifier (31) = 0,

      Reserved (1),
      Last-Stream-ID (31),
      Error Code (32),
      Additional Debug Data (..),
    }
:::

[Figure 10](#figure-10){.selfRef}: [GOAWAY Frame
Format](#name-goaway-frame-format){.selfRef}
:::

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields
are described in [Section
4](#FramingLayer){.xref}.[¶](#section-6.8-9){.pilcrow}

The GOAWAY frame does not define any
flags.[¶](#section-6.8-10){.pilcrow}

The GOAWAY frame applies to the connection, not a specific stream. An
endpoint [MUST]{.bcp14} treat a [GOAWAY](#GOAWAY){.xref} frame with a
stream identifier other than 0x00 as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.8-11){.pilcrow}

The last stream identifier in the GOAWAY frame contains the
highest-numbered stream identifier for which the sender of the GOAWAY
frame might have taken some action on or might yet take action on. All
streams up to and including the identified stream might have been
processed in some way. The last stream identifier can be set to 0 if no
streams were processed.[¶](#section-6.8-12){.pilcrow}

Note: In this context, \"processed\" means that some data from the
stream was passed to some higher layer of software that might have taken
some action as a result.[¶](#section-6.8-13.1){.pilcrow}

If a connection terminates without a GOAWAY frame, the last stream
identifier is effectively the highest possible stream
identifier.[¶](#section-6.8-14){.pilcrow}

On streams with lower- or equal-numbered identifiers that were not
closed completely prior to the connection being closed, reattempting
requests, transactions, or any protocol activity is not possible, except
for idempotent actions like HTTP GET, PUT, or DELETE. Any protocol
activity that uses higher-numbered streams can be safely retried using a
new connection.[¶](#section-6.8-15){.pilcrow}

Activity on streams numbered lower than or equal to the last stream
identifier might still complete successfully. The sender of a GOAWAY
frame might gracefully shut down a connection by sending a GOAWAY frame,
maintaining the connection in an \"open\" state until all in-progress
streams complete.[¶](#section-6.8-16){.pilcrow}

An endpoint [MAY]{.bcp14} send multiple GOAWAY frames if circumstances
change. For instance, an endpoint that sends GOAWAY with
[NO_ERROR](#NO_ERROR){.xref} during graceful shutdown could subsequently
encounter a condition that requires immediate termination of the
connection. The last stream identifier from the last GOAWAY frame
received indicates which streams could have been acted upon. Endpoints
[MUST NOT]{.bcp14} increase the value they send in the last stream
identifier, since the peers might already have retried unprocessed
requests on another connection.[¶](#section-6.8-17){.pilcrow}

A client that is unable to retry requests loses all requests that are in
flight when the server closes the connection. This is especially true
for intermediaries that might not be serving clients using HTTP/2. A
server that is attempting to gracefully shut down a connection
[SHOULD]{.bcp14} send an initial GOAWAY frame with the last stream
identifier set to 2^31^-1 and a [NO_ERROR](#NO_ERROR){.xref} code. This
signals to the client that a shutdown is imminent and that initiating
further requests is prohibited. After allowing time for any in-flight
stream creation (at least one round-trip time), the server [MAY]{.bcp14}
send another GOAWAY frame with an updated last stream identifier. This
ensures that a connection can be cleanly shut down without losing
requests.[¶](#section-6.8-18){.pilcrow}

After sending a GOAWAY frame, the sender can discard frames for streams
initiated by the receiver with identifiers higher than the identified
last stream. However, any frames that alter connection state cannot be
completely ignored. For instance, [HEADERS](#HEADERS){.xref},
[PUSH_PROMISE](#PUSH_PROMISE){.xref}, and
[CONTINUATION](#CONTINUATION){.xref} frames [MUST]{.bcp14} be minimally
processed to ensure that the state maintained for field section
compression is consistent (see [Section 4.3](#FieldBlock){.xref});
similarly, DATA frames [MUST]{.bcp14} be counted toward the connection
flow-control window. Failure to process these frames can cause flow
control or field section compression state to become
unsynchronized.[¶](#section-6.8-19){.pilcrow}

The GOAWAY frame also contains a 32-bit [error code](#ErrorCodes){.xref}
([Section 7](#ErrorCodes){.xref}) that contains the reason for closing
the connection.[¶](#section-6.8-20){.pilcrow}

Endpoints [MAY]{.bcp14} append opaque data to the frame payload of any
GOAWAY frame. Additional debug data is intended for diagnostic purposes
only and carries no semantic value. Debug information could contain
security- or privacy-sensitive data. Logged or otherwise persistently
stored debug data [MUST]{.bcp14} have adequate safeguards to prevent
unauthorized access.[¶](#section-6.8-21){.pilcrow}
:::
:::

::: {#WINDOW_UPDATE}
::: {#section-6.9 .section}
### [6.9.](#section-6.9){.section-number .selfRef} [WINDOW_UPDATE](#name-window_update){.section-name .selfRef} {#name-window_update}

The WINDOW_UPDATE frame (type=0x08) is used to implement flow control;
see [Section 5.2](#FlowControl){.xref} for an
overview.[¶](#section-6.9-1){.pilcrow}

Flow control operates at two levels: on each individual stream and on
the entire connection.[¶](#section-6.9-2){.pilcrow}

Both types of flow control are hop by hop, that is, only between the two
endpoints. Intermediaries do not forward WINDOW_UPDATE frames between
dependent connections. However, throttling of data transfer by any
receiver can indirectly cause the propagation of flow-control
information toward the original sender.[¶](#section-6.9-3){.pilcrow}

Flow control only applies to frames that are identified as being subject
to flow control. Of the frame types defined in this document, this
includes only [DATA](#DATA){.xref} frames. Frames that are exempt from
flow control [MUST]{.bcp14} be accepted and processed, unless the
receiver is unable to assign resources to handling the frame. A receiver
[MAY]{.bcp14} respond with a [stream error](#StreamErrorHandler){.xref}
([Section 5.4.2](#StreamErrorHandler){.xref}) or [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[FLOW_CONTROL_ERROR](#FLOW_CONTROL_ERROR){.xref} if it is unable to
accept a frame.[¶](#section-6.9-4){.pilcrow}

[]{#name-window_update-frame-format}

::: {#WINDOW_UPDATEFrameFormat}
::: {#section-6.9-5.1 .alignLeft .art-inline .art-text .artwork}
    WINDOW_UPDATE Frame {
      Length (24) = 0x04,
      Type (8) = 0x08,

      Unused Flags (8),

      Reserved (1),
      Stream Identifier (31),

      Reserved (1),
      Window Size Increment (31),
    }
:::

[Figure 11](#figure-11){.selfRef}: [WINDOW_UPDATE Frame
Format](#name-window_update-frame-format){.selfRef}
:::

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields
are described in [Section 4](#FramingLayer){.xref}. The frame payload of
a WINDOW_UPDATE frame is one reserved bit plus an unsigned 31-bit
integer indicating the number of octets that the sender can transmit in
addition to the existing flow-control window. The legal range for the
increment to the flow-control window is 1 to 2^31^-1 (2,147,483,647)
octets.[¶](#section-6.9-6){.pilcrow}

The WINDOW_UPDATE frame does not define any
flags.[¶](#section-6.9-7){.pilcrow}

The WINDOW_UPDATE frame can be specific to a stream or to the entire
connection. In the former case, the frame\'s stream identifier indicates
the affected stream; in the latter, the value \"0\" indicates that the
entire connection is the subject of the
frame.[¶](#section-6.9-8){.pilcrow}

A receiver [MUST]{.bcp14} treat the receipt of a WINDOW_UPDATE frame
with a flow-control window increment of 0 as a [stream
error](#StreamErrorHandler){.xref} ([Section
5.4.2](#StreamErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}; errors on the connection
flow-control window [MUST]{.bcp14} be treated as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}).[¶](#section-6.9-9){.pilcrow}

WINDOW_UPDATE can be sent by a peer that has sent a frame with the
END_STREAM flag set. This means that a receiver could receive a
WINDOW_UPDATE frame on a stream in a \"half-closed (remote)\" or
\"closed\" state. A receiver [MUST NOT]{.bcp14} treat this as an error
(see [Section 5.1](#StreamStates){.xref}).[¶](#section-6.9-10){.pilcrow}

A receiver that receives a flow-controlled frame [MUST]{.bcp14} always
account for its contribution against the connection flow-control window,
unless the receiver treats this as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}). This is necessary even if the
frame is in error. The sender counts the frame toward the flow-control
window, but if the receiver does not, the flow-control window at the
sender and receiver can become different.[¶](#section-6.9-11){.pilcrow}

A WINDOW_UPDATE frame with a length other than 4 octets [MUST]{.bcp14}
be treated as a [connection error](#ConnectionErrorHandler){.xref}
([Section 5.4.1](#ConnectionErrorHandler){.xref}) of type
[FRAME_SIZE_ERROR](#FRAME_SIZE_ERROR){.xref}.[¶](#section-6.9-12){.pilcrow}

::: {#section-6.9.1 .section}
#### [6.9.1.](#section-6.9.1){.section-number .selfRef} [The Flow-Control Window](#name-the-flow-control-window){.section-name .selfRef} {#name-the-flow-control-window}

Flow control in HTTP/2 is implemented using a window kept by each sender
on every stream. The flow-control window is a simple integer value that
indicates how many octets of data the sender is permitted to transmit;
as such, its size is a measure of the buffering capacity of the
receiver.[¶](#section-6.9.1-1){.pilcrow}

Two flow-control windows are applicable: the stream flow-control window
and the connection flow-control window. The sender [MUST NOT]{.bcp14}
send a flow-controlled frame with a length that exceeds the space
available in either of the flow-control windows advertised by the
receiver. Frames with zero length with the END_STREAM flag set (that is,
an empty [DATA](#DATA){.xref} frame) [MAY]{.bcp14} be sent if there is
no available space in either flow-control
window.[¶](#section-6.9.1-2){.pilcrow}

For flow-control calculations, the 9-octet frame header is not
counted.[¶](#section-6.9.1-3){.pilcrow}

After sending a flow-controlled frame, the sender reduces the space
available in both windows by the length of the transmitted
frame.[¶](#section-6.9.1-4){.pilcrow}

The receiver of a frame sends a WINDOW_UPDATE frame as it consumes data
and frees up space in flow-control windows. Separate WINDOW_UPDATE
frames are sent for the stream- and connection-level flow-control
windows. Receivers are advised to have mechanisms in place to avoid
sending WINDOW_UPDATE frames with very small increments; see [Section
4.2.3.3](https://www.rfc-editor.org/rfc/rfc1122#section-4.2.3.3){.relref}
of \[[RFC1122](#RFC1122){.xref}\].[¶](#section-6.9.1-5){.pilcrow}

A sender that receives a WINDOW_UPDATE frame updates the corresponding
window by the amount specified in the
frame.[¶](#section-6.9.1-6){.pilcrow}

A sender [MUST NOT]{.bcp14} allow a flow-control window to exceed
2^31^-1 octets. If a sender receives a WINDOW_UPDATE that causes a
flow-control window to exceed this maximum, it [MUST]{.bcp14} terminate
either the stream or the connection, as appropriate. For streams, the
sender sends a [RST_STREAM](#RST_STREAM){.xref} with an error code of
[FLOW_CONTROL_ERROR](#FLOW_CONTROL_ERROR){.xref}; for the connection, a
[GOAWAY](#GOAWAY){.xref} frame with an error code of
[FLOW_CONTROL_ERROR](#FLOW_CONTROL_ERROR){.xref} is
sent.[¶](#section-6.9.1-7){.pilcrow}

Flow-controlled frames from the sender and WINDOW_UPDATE frames from the
receiver are completely asynchronous with respect to each other. This
property allows a receiver to aggressively update the window size kept
by the sender to prevent streams from
stalling.[¶](#section-6.9.1-8){.pilcrow}
:::

::: {#InitialWindowSize}
::: {#section-6.9.2 .section}
#### [6.9.2.](#section-6.9.2){.section-number .selfRef} [Initial Flow-Control Window Size](#name-initial-flow-control-window){.section-name .selfRef} {#name-initial-flow-control-window}

When an HTTP/2 connection is first established, new streams are created
with an initial flow-control window size of 65,535 octets. The
connection flow-control window is also 65,535 octets. Both endpoints can
adjust the initial window size for new streams by including a value for
[SETTINGS_INITIAL_WINDOW_SIZE](#SETTINGS_INITIAL_WINDOW_SIZE){.xref} in
the [SETTINGS](#SETTINGS){.xref} frame. The connection flow-control
window can only be changed using WINDOW_UPDATE
frames.[¶](#section-6.9.2-1){.pilcrow}

Prior to receiving a [SETTINGS](#SETTINGS){.xref} frame that sets a
value for
[SETTINGS_INITIAL_WINDOW_SIZE](#SETTINGS_INITIAL_WINDOW_SIZE){.xref}, an
endpoint can only use the default initial window size when sending
flow-controlled frames. Similarly, the connection flow-control window is
set based on the default initial window size until a WINDOW_UPDATE frame
is received.[¶](#section-6.9.2-2){.pilcrow}

In addition to changing the flow-control window for streams that are not
yet active, a [SETTINGS](#SETTINGS){.xref} frame can alter the initial
flow-control window size for streams with active flow-control windows
(that is, streams in the \"open\" or \"half-closed (remote)\" state).
When the value of
[SETTINGS_INITIAL_WINDOW_SIZE](#SETTINGS_INITIAL_WINDOW_SIZE){.xref}
changes, a receiver [MUST]{.bcp14} adjust the size of all stream
flow-control windows that it maintains by the difference between the new
value and the old value.[¶](#section-6.9.2-3){.pilcrow}

A change to
[SETTINGS_INITIAL_WINDOW_SIZE](#SETTINGS_INITIAL_WINDOW_SIZE){.xref} can
cause the available space in a flow-control window to become negative. A
sender [MUST]{.bcp14} track the negative flow-control window and [MUST
NOT]{.bcp14} send new flow-controlled frames until it receives
WINDOW_UPDATE frames that cause the flow-control window to become
positive.[¶](#section-6.9.2-4){.pilcrow}

For example, if the client sends 60 KB immediately on connection
establishment and the server sets the initial window size to be 16 KB,
the client will recalculate the available flow-control window to be -44
KB on receipt of the [SETTINGS](#SETTINGS){.xref} frame. The client
retains a negative flow-control window until WINDOW_UPDATE frames
restore the window to being positive, after which the client can resume
sending.[¶](#section-6.9.2-5){.pilcrow}

A [SETTINGS](#SETTINGS){.xref} frame cannot alter the connection
flow-control window.[¶](#section-6.9.2-6){.pilcrow}

An endpoint [MUST]{.bcp14} treat a change to
[SETTINGS_INITIAL_WINDOW_SIZE](#SETTINGS_INITIAL_WINDOW_SIZE){.xref}
that causes any flow-control window to exceed the maximum size as a
[connection error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[FLOW_CONTROL_ERROR](#FLOW_CONTROL_ERROR){.xref}.[¶](#section-6.9.2-7){.pilcrow}
:::
:::

::: {#section-6.9.3 .section}
#### [6.9.3.](#section-6.9.3){.section-number .selfRef} [Reducing the Stream Window Size](#name-reducing-the-stream-window-){.section-name .selfRef} {#name-reducing-the-stream-window-}

A receiver that wishes to use a smaller flow-control window than the
current size can send a new [SETTINGS](#SETTINGS){.xref} frame. However,
the receiver [MUST]{.bcp14} be prepared to receive data that exceeds
this window size, since the sender might send data that exceeds the
lower limit prior to processing the [SETTINGS](#SETTINGS){.xref}
frame.[¶](#section-6.9.3-1){.pilcrow}

After sending a SETTINGS frame that reduces the initial flow-control
window size, a receiver [MAY]{.bcp14} continue to process streams that
exceed flow-control limits. Allowing streams to continue does not allow
the receiver to immediately reduce the space it reserves for
flow-control windows. Progress on these streams can also stall, since
[WINDOW_UPDATE](#WINDOW_UPDATE){.xref} frames are needed to allow the
sender to resume sending. The receiver [MAY]{.bcp14} instead send a
[RST_STREAM](#RST_STREAM){.xref} with an error code of
[FLOW_CONTROL_ERROR](#FLOW_CONTROL_ERROR){.xref} for the affected
streams.[¶](#section-6.9.3-2){.pilcrow}
:::
:::
:::

::: {#CONTINUATION}
::: {#section-6.10 .section}
### [6.10.](#section-6.10){.section-number .selfRef} [CONTINUATION](#name-continuation){.section-name .selfRef} {#name-continuation}

The CONTINUATION frame (type=0x09) is used to continue a sequence of
[field block fragments](#FieldBlock){.xref} ([Section
4.3](#FieldBlock){.xref}). Any number of CONTINUATION frames can be
sent, as long as the preceding frame is on the same stream and is a
[HEADERS](#HEADERS){.xref}, [PUSH_PROMISE](#PUSH_PROMISE){.xref}, or
CONTINUATION frame without the END_HEADERS flag
set.[¶](#section-6.10-1){.pilcrow}

[]{#name-continuation-frame-format}

::: {#CONTINUATIONFrameFormat}
::: {#section-6.10-2.1 .alignLeft .art-inline .art-text .artwork}
    CONTINUATION Frame {
      Length (24),
      Type (8) = 0x09,

      Unused Flags (5),
      END_HEADERS Flag (1),
      Unused Flags (2),

      Reserved (1),
      Stream Identifier (31),

      Field Block Fragment (..),
    }
:::

[Figure 12](#figure-12){.selfRef}: [CONTINUATION Frame
Format](#name-continuation-frame-format){.selfRef}
:::

The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields
are described in [Section 4](#FramingLayer){.xref}. The CONTINUATION
frame payload contains a [field block fragment](#FieldBlock){.xref}
([Section 4.3](#FieldBlock){.xref}).[¶](#section-6.10-3){.pilcrow}

The CONTINUATION frame defines the following
flag:[¶](#section-6.10-4){.pilcrow}

[]{.break}

END_HEADERS (0x04):

:   When set, the END_HEADERS flag indicates that this frame ends a
    [field block](#FieldBlock){.xref} ([Section
    4.3](#FieldBlock){.xref}).[¶](#section-6.10-5.2.1){.pilcrow}

    If the END_HEADERS flag is not set, this frame [MUST]{.bcp14} be
    followed by another CONTINUATION frame. A receiver [MUST]{.bcp14}
    treat the receipt of any other type of frame or a frame on a
    different stream as a [connection
    error](#ConnectionErrorHandler){.xref} ([Section
    5.4.1](#ConnectionErrorHandler){.xref}) of type
    [PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.10-5.2.2){.pilcrow}

:   

The CONTINUATION frame changes the connection state as defined in
[Section 4.3](#FieldBlock){.xref}.[¶](#section-6.10-6){.pilcrow}

CONTINUATION frames [MUST]{.bcp14} be associated with a stream. If a
CONTINUATION frame is received with a Stream Identifier field of 0x00,
the recipient [MUST]{.bcp14} respond with a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
PROTOCOL_ERROR.[¶](#section-6.10-7){.pilcrow}

A CONTINUATION frame [MUST]{.bcp14} be preceded by a
[HEADERS](#HEADERS){.xref}, [PUSH_PROMISE](#PUSH_PROMISE){.xref} or
CONTINUATION frame without the END_HEADERS flag set. A recipient that
observes violation of this rule [MUST]{.bcp14} respond with a
[connection error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-6.10-8){.pilcrow}
:::
:::
:::
:::

::: {#ErrorCodes}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Error Codes](#name-error-codes){.section-name .selfRef} {#name-error-codes}

Error codes are 32-bit fields that are used in
[RST_STREAM](#RST_STREAM){.xref} and [GOAWAY](#GOAWAY){.xref} frames to
convey the reasons for the stream or connection
error.[¶](#section-7-1){.pilcrow}

Error codes share a common code space. Some error codes apply only to
either streams or the entire connection and have no defined semantics in
the other context.[¶](#section-7-2){.pilcrow}

The following error codes are defined:[¶](#section-7-3){.pilcrow}

[]{.break}

NO_ERROR (0x00):

:   ::: {#NO_ERROR}
    The associated condition is not a result of an error. For example, a
    [GOAWAY](#GOAWAY){.xref} might include this code to indicate
    graceful shutdown of a connection.[¶](#NO_ERROR){.pilcrow}
    :::

:   

PROTOCOL_ERROR (0x01):

:   ::: {#PROTOCOL_ERROR}
    The endpoint detected an unspecific protocol error. This error is
    for use when a more specific error code is not
    available.[¶](#PROTOCOL_ERROR){.pilcrow}
    :::

:   

INTERNAL_ERROR (0x02):

:   ::: {#INTERNAL_ERROR}
    The endpoint encountered an unexpected internal
    error.[¶](#INTERNAL_ERROR){.pilcrow}
    :::

:   

FLOW_CONTROL_ERROR (0x03):

:   ::: {#FLOW_CONTROL_ERROR}
    The endpoint detected that its peer violated the flow-control
    protocol.[¶](#FLOW_CONTROL_ERROR){.pilcrow}
    :::

:   

SETTINGS_TIMEOUT (0x04):

:   ::: {#SETTINGS_TIMEOUT}
    The endpoint sent a [SETTINGS](#SETTINGS){.xref} frame but did not
    receive a response in a timely manner. See [Section
    6.5.3](#SettingsSync){.xref} (\"Settings
    Synchronization\").[¶](#SETTINGS_TIMEOUT){.pilcrow}
    :::

:   

STREAM_CLOSED (0x05):

:   ::: {#STREAM_CLOSED}
    The endpoint received a frame after a stream was
    half-closed.[¶](#STREAM_CLOSED){.pilcrow}
    :::

:   

FRAME_SIZE_ERROR (0x06):

:   ::: {#FRAME_SIZE_ERROR}
    The endpoint received a frame with an invalid
    size.[¶](#FRAME_SIZE_ERROR){.pilcrow}
    :::

:   

REFUSED_STREAM (0x07):

:   ::: {#REFUSED_STREAM}
    The endpoint refused the stream prior to performing any application
    processing (see [Section 8.7](#Reliability){.xref} for
    details).[¶](#REFUSED_STREAM){.pilcrow}
    :::

:   

CANCEL (0x08):

:   ::: {#CANCEL}
    The endpoint uses this error code to indicate that the stream is no
    longer needed.[¶](#CANCEL){.pilcrow}
    :::

:   

COMPRESSION_ERROR (0x09):

:   ::: {#COMPRESSION_ERROR}
    The endpoint is unable to maintain the field section compression
    context for the connection.[¶](#COMPRESSION_ERROR){.pilcrow}
    :::

:   

CONNECT_ERROR (0x0a):

:   ::: {#CONNECT_ERROR}
    The connection established in response to a [CONNECT
    request](#CONNECT){.xref} ([Section 8.5](#CONNECT){.xref}) was reset
    or abnormally closed.[¶](#CONNECT_ERROR){.pilcrow}
    :::

:   

ENHANCE_YOUR_CALM (0x0b):

:   ::: {#ENHANCE_YOUR_CALM}
    The endpoint detected that its peer is exhibiting a behavior that
    might be generating excessive load.[¶](#ENHANCE_YOUR_CALM){.pilcrow}
    :::

:   

INADEQUATE_SECURITY (0x0c):

:   ::: {#INADEQUATE_SECURITY}
    The underlying transport has properties that do not meet minimum
    security requirements (see [Section
    9.2](#TLSUsage){.xref}).[¶](#INADEQUATE_SECURITY){.pilcrow}
    :::

:   

HTTP_1\_1_REQUIRED (0x0d):

:   ::: {#HTTP_1_1_REQUIRED}
    The endpoint requires that HTTP/1.1 be used instead of
    HTTP/2.[¶](#HTTP_1_1_REQUIRED){.pilcrow}
    :::

:   

Unknown or unsupported error codes [MUST NOT]{.bcp14} trigger any
special behavior. These [MAY]{.bcp14} be treated by an implementation as
being equivalent to
[INTERNAL_ERROR](#INTERNAL_ERROR){.xref}.[¶](#section-7-5){.pilcrow}
:::
:::

::: {#HttpLayer}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Expressing HTTP Semantics in HTTP/2](#name-expressing-http-semantics-i){.section-name .selfRef} {#name-expressing-http-semantics-i}

HTTP/2 is an instantiation of the HTTP message abstraction ([Section
6](https://www.rfc-editor.org/rfc/rfc9110#section-6){.relref} of
\[[HTTP](#RFC9110){.xref}\]).[¶](#section-8-1){.pilcrow}

::: {#HttpFraming}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [HTTP Message Framing](#name-http-message-framing){.section-name .selfRef} {#name-http-message-framing}

A client sends an HTTP request on a new stream, using a previously
unused [stream identifier](#StreamIdentifiers){.xref} ([Section
5.1.1](#StreamIdentifiers){.xref}). A server sends an HTTP response on
the same stream as the request.[¶](#section-8.1-1){.pilcrow}

An HTTP message (request or response) consists
of:[¶](#section-8.1-2){.pilcrow}

1.  [one [HEADERS](#HEADERS){.xref} frame (followed by zero or more
    [CONTINUATION](#CONTINUATION){.xref} frames) containing the header
    section (see [Section
    6.3](https://www.rfc-editor.org/rfc/rfc9110#section-6.3){.relref} of
    \[[HTTP](#RFC9110){.xref}\]),[¶](#section-8.1-3.1){.pilcrow}]{#section-8.1-3.1}
2.  [zero or more [DATA](#DATA){.xref} frames containing the message
    content (see [Section
    6.4](https://www.rfc-editor.org/rfc/rfc9110#section-6.4){.relref} of
    \[[HTTP](#RFC9110){.xref}\]),
    and[¶](#section-8.1-3.2){.pilcrow}]{#section-8.1-3.2}
3.  [optionally, one [HEADERS](#HEADERS){.xref} frame (followed by zero
    or more [CONTINUATION](#CONTINUATION){.xref} frames) containing the
    trailer section, if present (see [Section
    6.5](https://www.rfc-editor.org/rfc/rfc9110#section-6.5){.relref} of
    \[[HTTP](#RFC9110){.xref}\]).[¶](#section-8.1-3.3){.pilcrow}]{#section-8.1-3.3}

For a response only, a server [MAY]{.bcp14} send any number of interim
responses before the [HEADERS](#HEADERS){.xref} frame containing a final
response. An interim response consists of a [HEADERS](#HEADERS){.xref}
frame (which might be followed by zero or more
[CONTINUATION](#CONTINUATION){.xref} frames) containing the control data
and header section of an interim (1xx) HTTP response (see [Section
15](https://www.rfc-editor.org/rfc/rfc9110#section-15){.relref} of
\[[HTTP](#RFC9110){.xref}\]). A [HEADERS](#HEADERS){.xref} frame with
the END_STREAM flag set that carries an informational status code is
[malformed](#malformed){.xref} ([Section
8.1.1](#malformed){.xref}).[¶](#section-8.1-4){.pilcrow}

The last frame in the sequence bears an END_STREAM flag, noting that a
[HEADERS](#HEADERS){.xref} frame with the END_STREAM flag set can be
followed by [CONTINUATION](#CONTINUATION){.xref} frames that carry any
remaining fragments of the field block.[¶](#section-8.1-5){.pilcrow}

Other frames (from any stream) [MUST NOT]{.bcp14} occur between the
[HEADERS](#HEADERS){.xref} frame and any
[CONTINUATION](#CONTINUATION){.xref} frames that might
follow.[¶](#section-8.1-6){.pilcrow}

HTTP/2 uses DATA frames to carry message content. The `chunked` transfer
encoding defined in [Section
7.1](https://www.rfc-editor.org/rfc/rfc9112#section-7.1){.relref} of
\[[HTTP/1.1](#RFC9112){.xref}\] cannot be used in HTTP/2; see [Section
8.2.2](#ConnectionSpecific){.xref}.[¶](#section-8.1-7){.pilcrow}

Trailer fields are carried in a field block that also terminates the
stream. That is, trailer fields comprise a sequence starting with a
[HEADERS](#HEADERS){.xref} frame, followed by zero or more
[CONTINUATION](#CONTINUATION){.xref} frames, where the
[HEADERS](#HEADERS){.xref} frame bears an END_STREAM flag. Trailers
[MUST NOT]{.bcp14} include [pseudo-header
fields](#PseudoHeaderFields){.xref} ([Section
8.3](#PseudoHeaderFields){.xref}). An endpoint that receives
pseudo-header fields in trailers [MUST]{.bcp14} treat the request or
response as [malformed](#malformed){.xref} ([Section
8.1.1](#malformed){.xref}).[¶](#section-8.1-8){.pilcrow}

An endpoint that receives a [HEADERS](#HEADERS){.xref} frame without the
END_STREAM flag set after receiving the [HEADERS](#HEADERS){.xref} frame
that opens a request or after receiving a final (non-informational)
status code [MUST]{.bcp14} treat the corresponding request or response
as [malformed](#malformed){.xref} ([Section
8.1.1](#malformed){.xref}).[¶](#section-8.1-9){.pilcrow}

An HTTP request/response exchange fully consumes a single stream. A
request starts with the [HEADERS](#HEADERS){.xref} frame that puts the
stream into the \"open\" state. The request ends with a frame with the
END_STREAM flag set, which causes the stream to become \"half-closed
(local)\" for the client and \"half-closed (remote)\" for the server. A
response stream starts with zero or more interim responses in
[HEADERS](#HEADERS){.xref} frames, followed by a
[HEADERS](#HEADERS){.xref} frame containing a final status
code.[¶](#section-8.1-10){.pilcrow}

An HTTP response is complete after the server sends \-- or the client
receives \-- a frame with the END_STREAM flag set (including any
[CONTINUATION](#CONTINUATION){.xref} frames needed to complete a field
block). A server can send a complete response prior to the client
sending an entire request if the response does not depend on any portion
of the request that has not been sent and received. When this is true, a
server [MAY]{.bcp14} request that the client abort transmission of a
request without error by sending a [RST_STREAM](#RST_STREAM){.xref} with
an error code of [NO_ERROR](#NO_ERROR){.xref} after sending a complete
response (i.e., a frame with the END_STREAM flag set). Clients [MUST
NOT]{.bcp14} discard responses as a result of receiving such a
[RST_STREAM](#RST_STREAM){.xref}, though clients can always discard
responses at their discretion for other
reasons.[¶](#section-8.1-11){.pilcrow}

::: {#malformed}
::: {#section-8.1.1 .section}
#### [8.1.1.](#section-8.1.1){.section-number .selfRef} [Malformed Messages](#name-malformed-messages){.section-name .selfRef} {#name-malformed-messages}

A malformed request or response is one that is an otherwise valid
sequence of HTTP/2 frames but is invalid due to the presence of
extraneous frames, prohibited fields or pseudo-header fields, the
absence of mandatory pseudo-header fields, the inclusion of uppercase
field names, or invalid field names and/or values (in certain
circumstances; see [Section
8.2](#HttpHeaders){.xref}).[¶](#section-8.1.1-1){.pilcrow}

A request or response that includes message content can include a
`content-length` header field. A request or response is also malformed
if the value of a `content-length` header field does not equal the sum
of the [DATA](#DATA){.xref} frame payload lengths that form the content,
unless the message is defined as having no content. For example, 204 or
304 responses contain no content, as does the response to a HEAD
request. A response that is defined to have no content, as described in
[Section
6.4.1](https://www.rfc-editor.org/rfc/rfc9110#section-6.4.1){.relref} of
\[[HTTP](#RFC9110){.xref}\], [MAY]{.bcp14} have a non-zero
`content-length` header field, even though no content is included in
[DATA](#DATA){.xref} frames.[¶](#section-8.1.1-2){.pilcrow}

Intermediaries that process HTTP requests or responses (i.e., any
intermediary not acting as a tunnel) [MUST NOT]{.bcp14} forward a
malformed request or response. Malformed requests or responses that are
detected [MUST]{.bcp14} be treated as a [stream
error](#StreamErrorHandler){.xref} ([Section
5.4.2](#StreamErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-8.1.1-3){.pilcrow}

For malformed requests, a server [MAY]{.bcp14} send an HTTP response
prior to closing or resetting the stream. Clients [MUST NOT]{.bcp14}
accept a malformed response.[¶](#section-8.1.1-4){.pilcrow}

Endpoints that progressively process messages might have performed some
processing before identifying a request or response as malformed. For
instance, it might be possible to generate an informational or 404
status code without having received a complete request. Similarly,
intermediaries might forward incomplete messages before detecting
errors. A server [MAY]{.bcp14} generate a final response before
receiving an entire request when the response does not depend on the
remainder of the request being correct.[¶](#section-8.1.1-5){.pilcrow}

These requirements are intended to protect against several types of
common attacks against HTTP; they are deliberately strict because being
permissive can expose implementations to these
vulnerabilities.[¶](#section-8.1.1-6){.pilcrow}
:::
:::
:::
:::

::: {#HttpHeaders}
::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [HTTP Fields](#name-http-fields){.section-name .selfRef} {#name-http-fields}

HTTP fields ([Section
5](https://www.rfc-editor.org/rfc/rfc9110#section-5){.relref} of
\[[HTTP](#RFC9110){.xref}\]) are conveyed by HTTP/2 in the HEADERS,
CONTINUATION, and PUSH_PROMISE frames, compressed with
[HPACK](#RFC7541){.xref}
\[[COMPRESSION](#RFC7541){.xref}\].[¶](#section-8.2-1){.pilcrow}

Field names [MUST]{.bcp14} be converted to lowercase when constructing
an HTTP/2 message.[¶](#section-8.2-2){.pilcrow}

::: {#section-8.2.1 .section}
#### [8.2.1.](#section-8.2.1){.section-number .selfRef} [Field Validity](#name-field-validity){.section-name .selfRef} {#name-field-validity}

The definitions of field names and values in HTTP prohibit some
characters that HPACK might be able to convey. HTTP/2 implementations
[SHOULD]{.bcp14} validate field names and values according to their
definitions in Sections
[5.1](https://www.rfc-editor.org/rfc/rfc9110#section-5.1){.relref} and
[5.5](https://www.rfc-editor.org/rfc/rfc9110#section-5.5){.relref} of
\[[HTTP](#RFC9110){.xref}\], respectively, and treat messages that
contain prohibited characters as [malformed](#malformed){.xref}
([Section 8.1.1](#malformed){.xref}).[¶](#section-8.2.1-1){.pilcrow}

Failure to validate fields can be exploited for request smuggling
attacks. In particular, unvalidated fields might enable attacks when
messages are forwarded using [HTTP/1.1](#RFC9112){.xref}
\[[HTTP/1.1](#RFC9112){.xref}\], where characters such as carriage
return (CR), line feed (LF), and COLON are used as delimiters.
Implementations [MUST]{.bcp14} perform the following minimal validation
of field names and values:[¶](#section-8.2.1-2){.pilcrow}

-   [A field name [MUST NOT]{.bcp14} contain characters in the ranges
    0x00-0x20, 0x41-0x5a, or 0x7f-0xff (all ranges inclusive). This
    specifically excludes all non-visible ASCII characters, ASCII SP
    (0x20), and uppercase characters (\'A\' to \'Z\', ASCII 0x41 to
    0x5a).[¶](#section-8.2.1-3.1){.pilcrow}]{#section-8.2.1-3.1}
-   [With the exception of [pseudo-header
    fields](#PseudoHeaderFields){.xref} ([Section
    8.3](#PseudoHeaderFields){.xref}), which have a name that starts
    with a single colon, field names [MUST NOT]{.bcp14} include a colon
    (ASCII COLON,
    0x3a).[¶](#section-8.2.1-3.2){.pilcrow}]{#section-8.2.1-3.2}
-   [A field value [MUST NOT]{.bcp14} contain the zero value (ASCII NUL,
    0x00), line feed (ASCII LF, 0x0a), or carriage return (ASCII CR,
    0x0d) at any
    position.[¶](#section-8.2.1-3.3){.pilcrow}]{#section-8.2.1-3.3}
-   [A field value [MUST NOT]{.bcp14} start or end with an ASCII
    whitespace character (ASCII SP or HTAB, 0x20 or
    0x09).[¶](#section-8.2.1-3.4){.pilcrow}]{#section-8.2.1-3.4}

Note: An implementation that validates fields according to the
definitions in Sections
[5.1](https://www.rfc-editor.org/rfc/rfc9110#section-5.1){.relref} and
[5.5](https://www.rfc-editor.org/rfc/rfc9110#section-5.5){.relref} of
\[[HTTP](#RFC9110){.xref}\] only needs an additional check that field
names do not include uppercase
characters.[¶](#section-8.2.1-4.1){.pilcrow}

A request or response that contains a field that violates any of these
conditions [MUST]{.bcp14} be treated as [malformed](#malformed){.xref}
([Section 8.1.1](#malformed){.xref}). In particular, an intermediary
that does not process fields when forwarding messages [MUST NOT]{.bcp14}
forward fields that contain any of the values that are listed as
prohibited above.[¶](#section-8.2.1-5){.pilcrow}

When a request message violates one of these requirements, an
implementation [SHOULD]{.bcp14} generate a 400 (Bad Request) status code
(see [Section
15.5.1](https://www.rfc-editor.org/rfc/rfc9110#section-15.5.1){.relref}
of \[[HTTP](#RFC9110){.xref}\]), unless a more suitable status code is
defined or the status code cannot be sent (e.g., because the error
occurs in a trailer field).[¶](#section-8.2.1-6){.pilcrow}

Note: Field values that are not valid according to the definition of the
corresponding field do not cause a request to be
[malformed](#malformed){.xref}; the requirements above only apply to the
generic syntax for fields as defined in [Section
5](https://www.rfc-editor.org/rfc/rfc9110#section-5){.relref} of
\[[HTTP](#RFC9110){.xref}\].[¶](#section-8.2.1-7.1){.pilcrow}
:::

::: {#ConnectionSpecific}
::: {#section-8.2.2 .section}
#### [8.2.2.](#section-8.2.2){.section-number .selfRef} [Connection-Specific Header Fields](#name-connection-specific-header-){.section-name .selfRef} {#name-connection-specific-header-}

HTTP/2 does not use the `Connection` header field ([Section
7.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1){.relref} of
\[[HTTP](#RFC9110){.xref}\]) to indicate connection-specific header
fields; in this protocol, connection-specific metadata is conveyed by
other means. An endpoint [MUST NOT]{.bcp14} generate an HTTP/2 message
containing connection-specific header fields. This includes the
`Connection` header field and those listed as having connection-specific
semantics in [Section
7.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1){.relref} of
\[[HTTP](#RFC9110){.xref}\] (that is, `Proxy-Connection`, `Keep-Alive`,
`Transfer-Encoding`, and `Upgrade`). Any message containing
connection-specific header fields [MUST]{.bcp14} be treated as
[malformed](#malformed){.xref} ([Section
8.1.1](#malformed){.xref}).[¶](#section-8.2.2-1){.pilcrow}

The only exception to this is the TE header field, which [MAY]{.bcp14}
be present in an HTTP/2 request; when it is, it [MUST NOT]{.bcp14}
contain any value other than
\"trailers\".[¶](#section-8.2.2-2){.pilcrow}

An intermediary transforming an HTTP/1.x message to HTTP/2
[MUST]{.bcp14} remove connection-specific header fields as discussed in
[Section
7.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1){.relref} of
\[[HTTP](#RFC9110){.xref}\], or their messages will be treated by other
HTTP/2 endpoints as [malformed](#malformed){.xref} ([Section
8.1.1](#malformed){.xref}).[¶](#section-8.2.2-3){.pilcrow}

Note: HTTP/2 purposefully does not support upgrade to another protocol.
The handshake methods described in [Section 3](#starting){.xref} are
believed sufficient to negotiate the use of alternative
protocols.[¶](#section-8.2.2-4.1){.pilcrow}
:::
:::

::: {#CompressCookie}
::: {#section-8.2.3 .section}
#### [8.2.3.](#section-8.2.3){.section-number .selfRef} [Compressing the Cookie Header Field](#name-compressing-the-cookie-head){.section-name .selfRef} {#name-compressing-the-cookie-head}

The [Cookie header field](#RFC6265){.xref} \[[COOKIE](#RFC6265){.xref}\]
uses a semicolon (\";\") to delimit cookie-pairs (or \"crumbs\"). This
header field contains multiple values, but does not use a COMMA (\",\")
as a separator, thereby preventing cookie-pairs from being sent on
multiple field lines (see [Section
5.2](https://www.rfc-editor.org/rfc/rfc9110#section-5.2){.relref} of
\[[HTTP](#RFC9110){.xref}\]). This can significantly reduce compression
efficiency, as updates to individual cookie-pairs would invalidate any
field lines that are stored in the HPACK
table.[¶](#section-8.2.3-1){.pilcrow}

To allow for better compression efficiency, the Cookie header field
[MAY]{.bcp14} be split into separate header fields, each with one or
more cookie-pairs. If there are multiple Cookie header fields after
decompression, these [MUST]{.bcp14} be concatenated into a single octet
string using the two-octet delimiter of 0x3b, 0x20 (the ASCII string \";
\") before being passed into a non-HTTP/2 context, such as an HTTP/1.1
connection, or a generic HTTP server
application.[¶](#section-8.2.3-2){.pilcrow}

Therefore, the following two lists of Cookie header fields are
semantically equivalent.[¶](#section-8.2.3-3){.pilcrow}

::: {#section-8.2.3-4 .alignLeft .art-inline .art-text .artwork}
    cookie: a=b; c=d; e=f

    cookie: a=b
    cookie: c=d
    cookie: e=f

[¶](#section-8.2.3-4){.pilcrow}
:::
:::
:::
:::
:::

::: {#PseudoHeaderFields}
::: {#section-8.3 .section}
### [8.3.](#section-8.3){.section-number .selfRef} [HTTP Control Data](#name-http-control-data){.section-name .selfRef} {#name-http-control-data}

HTTP/2 uses special pseudo-header fields beginning with a \':\'
character (ASCII 0x3a) to convey message control data (see [Section
6.2](https://www.rfc-editor.org/rfc/rfc9110#section-6.2){.relref} of
\[[HTTP](#RFC9110){.xref}\]).[¶](#section-8.3-1){.pilcrow}

Pseudo-header fields are not HTTP header fields. Endpoints [MUST
NOT]{.bcp14} generate pseudo-header fields other than those defined in
this document. Note that an extension could negotiate the use of
additional pseudo-header fields; see [Section
5.5](#extensibility){.xref}.[¶](#section-8.3-2){.pilcrow}

Pseudo-header fields are only valid in the context in which they are
defined. Pseudo-header fields defined for requests [MUST NOT]{.bcp14}
appear in responses; pseudo-header fields defined for responses [MUST
NOT]{.bcp14} appear in requests. Pseudo-header fields [MUST NOT]{.bcp14}
appear in a trailer section. Endpoints [MUST]{.bcp14} treat a request or
response that contains undefined or invalid pseudo-header fields as
[malformed](#malformed){.xref} ([Section
8.1.1](#malformed){.xref}).[¶](#section-8.3-3){.pilcrow}

All pseudo-header fields [MUST]{.bcp14} appear in a field block before
all regular field lines. Any request or response that contains a
pseudo-header field that appears in a field block after a regular field
line [MUST]{.bcp14} be treated as [malformed](#malformed){.xref}
([Section 8.1.1](#malformed){.xref}).[¶](#section-8.3-4){.pilcrow}

The same pseudo-header field name [MUST NOT]{.bcp14} appear more than
once in a field block. A field block for an HTTP request or response
that contains a repeated pseudo-header field name [MUST]{.bcp14} be
treated as [malformed](#malformed){.xref} ([Section
8.1.1](#malformed){.xref}).[¶](#section-8.3-5){.pilcrow}

::: {#HttpRequest}
::: {#section-8.3.1 .section}
#### [8.3.1.](#section-8.3.1){.section-number .selfRef} [Request Pseudo-Header Fields](#name-request-pseudo-header-field){.section-name .selfRef} {#name-request-pseudo-header-field}

The following pseudo-header fields are defined for HTTP/2
requests:[¶](#section-8.3.1-1){.pilcrow}

-   ::: {#section-8.3.1-2.1}
    The \"`:method`\" pseudo-header field includes the HTTP method
    ([Section
    9](https://www.rfc-editor.org/rfc/rfc9110#section-9){.relref} of
    \[[HTTP](#RFC9110){.xref}\]).[¶](#section-8.3.1-2.1.1){.pilcrow}
    :::

-   ::: {#section-8.3.1-2.2}
    The \"`:scheme`\" pseudo-header field includes the scheme portion of
    the request target. The scheme is taken from the target URI
    ([Section
    3.1](https://www.rfc-editor.org/rfc/rfc3986#section-3.1){.relref} of
    \[[RFC3986](#RFC3986){.xref}\]) when generating a request directly,
    or from the scheme of a translated request (for example, see
    [Section
    3.3](https://www.rfc-editor.org/rfc/rfc9112#section-3.3){.relref} of
    \[[HTTP/1.1](#RFC9112){.xref}\]). Scheme is omitted for [CONNECT
    requests](#CONNECT){.xref} ([Section
    8.5](#CONNECT){.xref}).[¶](#section-8.3.1-2.2.1){.pilcrow}

    \"`:scheme`\" is not restricted to \"`http`\" and \"`https`\"
    schemed URIs. A proxy or gateway can translate requests for non-HTTP
    schemes, enabling the use of HTTP to interact with non-HTTP
    services.[¶](#section-8.3.1-2.2.2){.pilcrow}
    :::

-   ::: {#section-8.3.1-2.3}
    The \"`:authority`\" pseudo-header field conveys the authority
    portion ([Section
    3.2](https://www.rfc-editor.org/rfc/rfc3986#section-3.2){.relref} of
    \[[RFC3986](#RFC3986){.xref}\]) of the target URI ([Section
    7.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.1){.relref} of
    \[[HTTP](#RFC9110){.xref}\]). The recipient of an HTTP/2 request
    [MUST NOT]{.bcp14} use the `Host` header field to determine the
    target URI if \"`:authority`\" is
    present.[¶](#section-8.3.1-2.3.1){.pilcrow}

    Clients that generate HTTP/2 requests directly [MUST]{.bcp14} use
    the \"`:authority`\" pseudo-header field to convey authority
    information, unless there is no authority information to convey (in
    which case it [MUST NOT]{.bcp14} generate
    \"`:authority`\").[¶](#section-8.3.1-2.3.2){.pilcrow}

    Clients [MUST NOT]{.bcp14} generate a request with a `Host` header
    field that differs from the \"`:authority`\" pseudo-header field. A
    server [SHOULD]{.bcp14} treat a request as malformed if it contains
    a `Host` header field that identifies an entity that differs from
    the entity in the \"`:authority`\" pseudo-header field. The values
    of fields need to be normalized to compare them (see [Section
    6.2](https://www.rfc-editor.org/rfc/rfc3986#section-6.2){.relref} of
    \[[RFC3986](#RFC3986){.xref}\]). An origin server can apply any
    normalization method, whereas other servers [MUST]{.bcp14} perform
    scheme-based normalization (see [Section
    6.2.3](https://www.rfc-editor.org/rfc/rfc3986#section-6.2.3){.relref}
    of \[[RFC3986](#RFC3986){.xref}\]) of the two
    fields.[¶](#section-8.3.1-2.3.3){.pilcrow}

    An intermediary that forwards a request over HTTP/2 [MUST]{.bcp14}
    construct an \"`:authority`\" pseudo-header field using the
    authority information from the control data of the original request,
    unless the original request\'s target URI does not contain authority
    information (in which case it [MUST NOT]{.bcp14} generate
    \"`:authority`\"). Note that the `Host` header field is not the sole
    source of this information; see [Section
    7.2](https://www.rfc-editor.org/rfc/rfc9110#section-7.2){.relref} of
    \[[HTTP](#RFC9110){.xref}\].[¶](#section-8.3.1-2.3.4){.pilcrow}

    An intermediary that needs to generate a `Host` header field (which
    might be necessary to construct an HTTP/1.1 request) [MUST]{.bcp14}
    use the value from the \"`:authority`\" pseudo-header field as the
    value of the `Host` field, unless the intermediary also changes the
    request target. This replaces any existing `Host` field to avoid
    potential vulnerabilities in HTTP
    routing.[¶](#section-8.3.1-2.3.5){.pilcrow}

    An intermediary that forwards a request over HTTP/2 [MAY]{.bcp14}
    retain any `Host` header field.[¶](#section-8.3.1-2.3.6){.pilcrow}

    Note that request targets for CONNECT or asterisk-form OPTIONS
    requests never include authority information; see Sections
    [7.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.1){.relref}
    and
    [7.2](https://www.rfc-editor.org/rfc/rfc9110#section-7.2){.relref}
    of \[[HTTP](#RFC9110){.xref}\].[¶](#section-8.3.1-2.3.7){.pilcrow}

    \"`:authority`\" [MUST NOT]{.bcp14} include the deprecated userinfo
    subcomponent for \"`http`\" or \"`https`\" schemed
    URIs.[¶](#section-8.3.1-2.3.8){.pilcrow}
    :::

-   ::: {#section-8.3.1-2.4}
    The \"`:path`\" pseudo-header field includes the path and query
    parts of the target URI (the `absolute-path` production and,
    optionally, a \'?\' character followed by the `query` production;
    see [Section
    4.1](https://www.rfc-editor.org/rfc/rfc9110#section-4.1){.relref} of
    \[[HTTP](#RFC9110){.xref}\]). A request in asterisk form (for
    OPTIONS) includes the value \'\*\' for the \"`:path`\" pseudo-header
    field.[¶](#section-8.3.1-2.4.1){.pilcrow}

    This pseudo-header field [MUST NOT]{.bcp14} be empty for \"`http`\"
    or \"`https`\" URIs; \"`http`\" or \"`https`\" URIs that do not
    contain a path component [MUST]{.bcp14} include a value of \'/\'.
    The exceptions to this rule are:[¶](#section-8.3.1-2.4.2){.pilcrow}

    -   [an OPTIONS request for an \"`http`\" or \"`https`\" URI that
        does not include a path component; these [MUST]{.bcp14} include
        a \"`:path`\" pseudo-header field with a value of \'\*\' (see
        [Section
        7.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.1){.relref}
        of
        \[[HTTP](#RFC9110){.xref}\]).[¶](#section-8.3.1-2.4.3.1){.pilcrow}]{#section-8.3.1-2.4.3.1}
    -   [[CONNECT requests](#CONNECT){.xref} ([Section
        8.5](#CONNECT){.xref}), where the \"`:path`\" pseudo-header
        field is
        omitted.[¶](#section-8.3.1-2.4.3.2){.pilcrow}]{#section-8.3.1-2.4.3.2}
    :::

All HTTP/2 requests [MUST]{.bcp14} include exactly one valid value for
the \"`:method`\", \"`:scheme`\", and \"`:path`\" pseudo-header fields,
unless they are [CONNECT requests](#CONNECT){.xref} ([Section
8.5](#CONNECT){.xref}). An HTTP request that omits mandatory
pseudo-header fields is [malformed](#malformed){.xref} ([Section
8.1.1](#malformed){.xref}).[¶](#section-8.3.1-3){.pilcrow}

Individual HTTP/2 requests do not carry an explicit indicator of
protocol version. All HTTP/2 requests implicitly have a protocol version
of \"2.0\" (see [Section
6.2](https://www.rfc-editor.org/rfc/rfc9110#section-6.2){.relref} of
\[[HTTP](#RFC9110){.xref}\]).[¶](#section-8.3.1-4){.pilcrow}
:::
:::

::: {#HttpResponse}
::: {#section-8.3.2 .section}
#### [8.3.2.](#section-8.3.2){.section-number .selfRef} [Response Pseudo-Header Fields](#name-response-pseudo-header-fiel){.section-name .selfRef} {#name-response-pseudo-header-fiel}

For HTTP/2 responses, a single \"`:status`\" pseudo-header field is
defined that carries the HTTP status code field (see [Section
15](https://www.rfc-editor.org/rfc/rfc9110#section-15){.relref} of
\[[HTTP](#RFC9110){.xref}\]). This pseudo-header field [MUST]{.bcp14} be
included in all responses, including interim responses; otherwise, the
response is [malformed](#malformed){.xref} ([Section
8.1.1](#malformed){.xref}).[¶](#section-8.3.2-1){.pilcrow}

HTTP/2 responses implicitly have a protocol version of
\"2.0\".[¶](#section-8.3.2-2){.pilcrow}
:::
:::
:::
:::

::: {#PushResources}
::: {#section-8.4 .section}
### [8.4.](#section-8.4){.section-number .selfRef} [Server Push](#name-server-push){.section-name .selfRef} {#name-server-push}

HTTP/2 allows a server to preemptively send (or \"push\") responses
(along with corresponding \"promised\" requests) to a client in
association with a previous client-initiated
request.[¶](#section-8.4-1){.pilcrow}

Server push was designed to allow a server to improve client-perceived
performance by predicting what requests will follow those that it
receives, thereby removing a round trip for them. For example, a request
for HTML is often followed by requests for stylesheets and scripts
referenced by that page. When these requests are pushed, the client does
not need to wait to receive the references to them in the HTML and issue
separate requests.[¶](#section-8.4-2){.pilcrow}

In practice, server push is difficult to use effectively, because it
requires the server to correctly anticipate the additional requests the
client will make, taking into account factors such as caching, content
negotiation, and user behavior. Errors in prediction can lead to
performance degradation, due to the opportunity cost that the additional
data on the wire represents. In particular, pushing any significant
amount of data can cause contention issues with responses that are more
important.[¶](#section-8.4-3){.pilcrow}

A client can request that server push be disabled, though this is
negotiated for each hop independently. The
[SETTINGS_ENABLE_PUSH](#SETTINGS_ENABLE_PUSH){.xref} setting can be set
to 0 to indicate that server push is
disabled.[¶](#section-8.4-4){.pilcrow}

Promised requests [MUST]{.bcp14} be safe (see [Section
9.2.1](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.1){.relref} of
\[[HTTP](#RFC9110){.xref}\]) and cacheable (see [Section
9.2.3](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.3){.relref} of
\[[HTTP](#RFC9110){.xref}\]). Promised requests cannot include any
content or a trailer section. Clients that receive a promised request
that is not cacheable, that is not known to be safe, or that indicates
the presence of request content [MUST]{.bcp14} reset the promised stream
with a [stream error](#StreamErrorHandler){.xref} ([Section
5.4.2](#StreamErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}. Note that this could result in
the promised stream being reset if the client does not recognize a newly
defined method as being safe.[¶](#section-8.4-5){.pilcrow}

Pushed responses that are cacheable (see [Section
3](https://www.rfc-editor.org/rfc/rfc9111#section-3){.relref} of
\[[CACHING](#RFC9111){.xref}\]) can be stored by the client, if it
implements an HTTP cache. Pushed responses are considered successfully
validated on the origin server (e.g., if the \"no-cache\" cache response
directive is present; see [Section
5.2.2.4](https://www.rfc-editor.org/rfc/rfc9111#section-5.2.2.4){.relref}
of \[[CACHING](#RFC9111){.xref}\]) while the stream identified by the
promised stream identifier is still open.[¶](#section-8.4-6){.pilcrow}

Pushed responses that are not cacheable [MUST NOT]{.bcp14} be stored by
any HTTP cache. They [MAY]{.bcp14} be made available to the application
separately.[¶](#section-8.4-7){.pilcrow}

The server [MUST]{.bcp14} include a value in the \"`:authority`\"
pseudo-header field for which the server is authoritative (see [Section
10.1](#authority){.xref}). A client [MUST]{.bcp14} treat a
[PUSH_PROMISE](#PUSH_PROMISE){.xref} for which the server is not
authoritative as a [stream error](#StreamErrorHandler){.xref} ([Section
5.4.2](#StreamErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-8.4-8){.pilcrow}

An intermediary can receive pushes from the server and choose not to
forward them on to the client. In other words, how to make use of the
pushed information is up to that intermediary. Equally, the intermediary
might choose to make additional pushes to the client, without any action
taken by the server.[¶](#section-8.4-9){.pilcrow}

A client cannot push. Thus, servers [MUST]{.bcp14} treat the receipt of
a [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}. A server cannot set the
[SETTINGS_ENABLE_PUSH](#SETTINGS_ENABLE_PUSH){.xref} setting to a value
other than 0 (see [Section
6.5.2](#SettingValues){.xref}).[¶](#section-8.4-10){.pilcrow}

::: {#PushRequests}
::: {#section-8.4.1 .section}
#### [8.4.1.](#section-8.4.1){.section-number .selfRef} [Push Requests](#name-push-requests){.section-name .selfRef} {#name-push-requests}

Server push is semantically equivalent to a server responding to a
request; however, in this case, that request is also sent by the server,
as a [PUSH_PROMISE](#PUSH_PROMISE){.xref}
frame.[¶](#section-8.4.1-1){.pilcrow}

The [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame includes a field block
that contains control data and a complete set of request header fields
that the server attributes to the request. It is not possible to push a
response to a request that includes message
content.[¶](#section-8.4.1-2){.pilcrow}

Promised requests are always associated with an explicit request from
the client. The [PUSH_PROMISE](#PUSH_PROMISE){.xref} frames sent by the
server are sent on that explicit request\'s stream. The
[PUSH_PROMISE](#PUSH_PROMISE){.xref} frame also includes a promised
stream identifier, chosen from the stream identifiers available to the
server (see [Section
5.1.1](#StreamIdentifiers){.xref}).[¶](#section-8.4.1-3){.pilcrow}

The header fields in [PUSH_PROMISE](#PUSH_PROMISE){.xref} and any
subsequent [CONTINUATION](#CONTINUATION){.xref} frames [MUST]{.bcp14} be
a valid and complete set of [request header fields](#HttpRequest){.xref}
([Section 8.3.1](#HttpRequest){.xref}). The server [MUST]{.bcp14}
include a method in the \"`:method`\" pseudo-header field that is safe
and cacheable. If a client receives a
[PUSH_PROMISE](#PUSH_PROMISE){.xref} that does not include a complete
and valid set of header fields or the \"`:method`\" pseudo-header field
identifies a method that is not safe, it [MUST]{.bcp14} respond on the
promised stream with a [stream error](#StreamErrorHandler){.xref}
([Section 5.4.2](#StreamErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-8.4.1-4){.pilcrow}

The server [SHOULD]{.bcp14} send [PUSH_PROMISE](#PUSH_PROMISE){.xref}
([Section 6.6](#PUSH_PROMISE){.xref}) frames prior to sending any frames
that reference the promised responses. This avoids a race where clients
issue requests prior to receiving any
[PUSH_PROMISE](#PUSH_PROMISE){.xref}
frames.[¶](#section-8.4.1-5){.pilcrow}

For example, if the server receives a request for a document containing
embedded links to multiple image files and the server chooses to push
those additional images to the client, sending
[PUSH_PROMISE](#PUSH_PROMISE){.xref} frames before the
[DATA](#DATA){.xref} frames that contain the image links ensures that
the client is able to see that a resource will be pushed before
discovering embedded links. Similarly, if the server pushes resources
referenced by the field block (for instance, in Link header fields),
sending a [PUSH_PROMISE](#PUSH_PROMISE){.xref} before sending the header
ensures that clients do not request those
resources.[¶](#section-8.4.1-6){.pilcrow}

[PUSH_PROMISE](#PUSH_PROMISE){.xref} frames [MUST NOT]{.bcp14} be sent
by the client.[¶](#section-8.4.1-7){.pilcrow}

[PUSH_PROMISE](#PUSH_PROMISE){.xref} frames can be sent by the server on
any client-initiated stream, but the stream [MUST]{.bcp14} be in either
the \"open\" or \"half-closed (remote)\" state with respect to the
server. [PUSH_PROMISE](#PUSH_PROMISE){.xref} frames are interspersed
with the frames that comprise a response, though they cannot be
interspersed with [HEADERS](#HEADERS){.xref} and
[CONTINUATION](#CONTINUATION){.xref} frames that comprise a single field
block.[¶](#section-8.4.1-8){.pilcrow}

Sending a [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame creates a new
stream and puts the stream into the \"reserved (local)\" state for the
server and the \"reserved (remote)\" state for the
client.[¶](#section-8.4.1-9){.pilcrow}
:::
:::

::: {#PushResponses}
::: {#section-8.4.2 .section}
#### [8.4.2.](#section-8.4.2){.section-number .selfRef} [Push Responses](#name-push-responses){.section-name .selfRef} {#name-push-responses}

After sending the [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame, the server
can begin delivering the pushed response as a
[response](#HttpResponse){.xref} ([Section 8.3.2](#HttpResponse){.xref})
on a server-initiated stream that uses the promised stream identifier.
The server uses this stream to transmit an HTTP response, using the same
sequence of frames as that defined in [Section
8.1](#HttpFraming){.xref}. This stream becomes [\"half-closed\" to the
client](#StreamStates){.xref} ([Section 5.1](#StreamStates){.xref})
after the initial [HEADERS](#HEADERS){.xref} frame is
sent.[¶](#section-8.4.2-1){.pilcrow}

Once a client receives a [PUSH_PROMISE](#PUSH_PROMISE){.xref} frame and
chooses to accept the pushed response, the client [SHOULD NOT]{.bcp14}
issue any requests for the promised response until after the promised
stream has closed.[¶](#section-8.4.2-2){.pilcrow}

If the client determines, for any reason, that it does not wish to
receive the pushed response from the server or if the server takes too
long to begin sending the promised response, the client can send a
[RST_STREAM](#RST_STREAM){.xref} frame, using either the
[CANCEL](#CANCEL){.xref} or [REFUSED_STREAM](#REFUSED_STREAM){.xref}
code and referencing the pushed stream\'s
identifier.[¶](#section-8.4.2-3){.pilcrow}

A client can use the
[SETTINGS_MAX_CONCURRENT_STREAMS](#SETTINGS_MAX_CONCURRENT_STREAMS){.xref}
setting to limit the number of responses that can be concurrently pushed
by a server. Advertising a
[SETTINGS_MAX_CONCURRENT_STREAMS](#SETTINGS_MAX_CONCURRENT_STREAMS){.xref}
value of zero prevents the server from opening the streams necessary to
push responses. However, this does not prevent the server from reserving
streams using [PUSH_PROMISE](#PUSH_PROMISE){.xref} frames, because
reserved streams do not count toward the concurrent stream limit.
Clients that do not wish to receive pushed resources need to reset any
unwanted reserved streams or set
[SETTINGS_ENABLE_PUSH](#SETTINGS_ENABLE_PUSH){.xref} to
0.[¶](#section-8.4.2-4){.pilcrow}

Clients receiving a pushed response [MUST]{.bcp14} validate that either
the server is authoritative (see [Section 10.1](#authority){.xref}) or
the proxy that provided the pushed response is configured for the
corresponding request. For example, a server that offers a certificate
for only the `example.com` DNS-ID (see \[[RFC6125](#RFC6125){.xref}\])
is not permitted to push a response for
\<`https://www.example.org/doc`\>.[¶](#section-8.4.2-5){.pilcrow}

The response for a [PUSH_PROMISE](#PUSH_PROMISE){.xref} stream begins
with a [HEADERS](#HEADERS){.xref} frame, which immediately puts the
stream into the \"half-closed (remote)\" state for the server and
\"half-closed (local)\" state for the client, and ends with a frame with
the END_STREAM flag set, which places the stream in the \"closed\"
state.[¶](#section-8.4.2-6){.pilcrow}

Note: The client never sends a frame with the END_STREAM flag set for a
server push.[¶](#section-8.4.2-7.1){.pilcrow}
:::
:::
:::
:::

::: {#CONNECT}
::: {#section-8.5 .section}
### [8.5.](#section-8.5){.section-number .selfRef} [The CONNECT Method](#name-the-connect-method){.section-name .selfRef} {#name-the-connect-method}

The CONNECT method ([Section
9.3.6](https://www.rfc-editor.org/rfc/rfc9110#section-9.3.6){.relref} of
\[[HTTP](#RFC9110){.xref}\]) is used to convert an HTTP connection into
a tunnel to a remote host. CONNECT is primarily used with HTTP proxies
to establish a TLS session with an origin server for the purposes of
interacting with \"`https`\" resources.[¶](#section-8.5-1){.pilcrow}

In HTTP/2, the CONNECT method establishes a tunnel over a single HTTP/2
stream to a remote host, rather than converting the entire connection to
a tunnel. A CONNECT header section is constructed as defined in [Section
8.3.1](#HttpRequest){.xref} (\"[Request Pseudo-Header
Fields](#HttpRequest){.xref}\"), with a few differences.
Specifically:[¶](#section-8.5-2){.pilcrow}

-   [The \"`:method`\" pseudo-header field is set to
    `CONNECT`.[¶](#section-8.5-3.1){.pilcrow}]{#section-8.5-3.1}
-   [The \"`:scheme`\" and \"`:path`\" pseudo-header fields
    [MUST]{.bcp14} be
    omitted.[¶](#section-8.5-3.2){.pilcrow}]{#section-8.5-3.2}
-   [The \"`:authority`\" pseudo-header field contains the host and port
    to connect to (equivalent to the authority-form of the
    request-target of CONNECT requests; see [Section
    3.2.3](https://www.rfc-editor.org/rfc/rfc9112#section-3.2.3){.relref}
    of
    \[[HTTP/1.1](#RFC9112){.xref}\]).[¶](#section-8.5-3.3){.pilcrow}]{#section-8.5-3.3}

A CONNECT request that does not conform to these restrictions is
[malformed](#malformed){.xref} ([Section
8.1.1](#malformed){.xref}).[¶](#section-8.5-4){.pilcrow}

A proxy that supports CONNECT establishes a [TCP
connection](#RFC0793){.xref} \[[TCP](#RFC0793){.xref}\] to the host and
port identified in the \"`:authority`\" pseudo-header field. Once this
connection is successfully established, the proxy sends a
[HEADERS](#HEADERS){.xref} frame containing a 2xx-series status code to
the client, as defined in [Section
9.3.6](https://www.rfc-editor.org/rfc/rfc9110#section-9.3.6){.relref} of
\[[HTTP](#RFC9110){.xref}\].[¶](#section-8.5-5){.pilcrow}

After the initial [HEADERS](#HEADERS){.xref} frame sent by each peer,
all subsequent [DATA](#DATA){.xref} frames correspond to data sent on
the TCP connection. The frame payload of any [DATA](#DATA){.xref} frames
sent by the client is transmitted by the proxy to the TCP server; data
received from the TCP server is assembled into [DATA](#DATA){.xref}
frames by the proxy. Frame types other than [DATA](#DATA){.xref} or
stream management frames ([RST_STREAM](#RST_STREAM){.xref},
[WINDOW_UPDATE](#WINDOW_UPDATE){.xref}, and
[PRIORITY](#PRIORITY){.xref}) [MUST NOT]{.bcp14} be sent on a connected
stream and [MUST]{.bcp14} be treated as a [stream
error](#StreamErrorHandler){.xref} ([Section
5.4.2](#StreamErrorHandler){.xref}) if
received.[¶](#section-8.5-6){.pilcrow}

The TCP connection can be closed by either peer. The END_STREAM flag on
a [DATA](#DATA){.xref} frame is treated as being equivalent to the TCP
FIN bit. A client is expected to send a [DATA](#DATA){.xref} frame with
the END_STREAM flag set after receiving a frame with the END_STREAM flag
set. A proxy that receives a [DATA](#DATA){.xref} frame with the
END_STREAM flag set sends the attached data with the FIN bit set on the
last TCP segment. A proxy that receives a TCP segment with the FIN bit
set sends a [DATA](#DATA){.xref} frame with the END_STREAM flag set.
Note that the final TCP segment or [DATA](#DATA){.xref} frame could be
empty.[¶](#section-8.5-7){.pilcrow}

A TCP connection error is signaled with
[RST_STREAM](#RST_STREAM){.xref}. A proxy treats any error in the TCP
connection, which includes receiving a TCP segment with the RST bit set,
as a [stream error](#StreamErrorHandler){.xref} ([Section
5.4.2](#StreamErrorHandler){.xref}) of type
[CONNECT_ERROR](#CONNECT_ERROR){.xref}. Correspondingly, a proxy
[MUST]{.bcp14} send a TCP segment with the RST bit set if it detects an
error with the stream or the HTTP/2
connection.[¶](#section-8.5-8){.pilcrow}
:::
:::

::: {#informational-responses}
::: {#section-8.6 .section}
### [8.6.](#section-8.6){.section-number .selfRef} [The Upgrade Header Field](#name-the-upgrade-header-field){.section-name .selfRef} {#name-the-upgrade-header-field}

HTTP/2 does not support the 101 (Switching Protocols) informational
status code ([Section
15.2.2](https://www.rfc-editor.org/rfc/rfc9110#section-15.2.2){.relref}
of \[[HTTP](#RFC9110){.xref}\]).[¶](#section-8.6-1){.pilcrow}

The semantics of 101 (Switching Protocols) aren\'t applicable to a
multiplexed protocol. Similar functionality might be enabled through the
use of [extended CONNECT](#RFC8441){.xref}
\[[RFC8441](#RFC8441){.xref}\], and other protocols are able to use the
same mechanisms that HTTP/2 uses to negotiate their use (see [Section
3](#starting){.xref}).[¶](#section-8.6-2){.pilcrow}
:::
:::

::: {#Reliability}
::: {#section-8.7 .section}
### [8.7.](#section-8.7){.section-number .selfRef} [Request Reliability](#name-request-reliability){.section-name .selfRef} {#name-request-reliability}

In general, an HTTP client is unable to retry a non-idempotent request
when an error occurs because there is no means to determine the nature
of the error (see [Section
9.2.2](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.2){.relref} of
\[[HTTP](#RFC9110){.xref}\]). It is possible that some server processing
occurred prior to the error, which could result in undesirable effects
if the request were reattempted.[¶](#section-8.7-1){.pilcrow}

HTTP/2 provides two mechanisms for providing a guarantee to a client
that a request has not been processed:[¶](#section-8.7-2){.pilcrow}

-   [The [GOAWAY](#GOAWAY){.xref} frame indicates the highest stream
    number that might have been processed. Requests on streams with
    higher numbers are therefore guaranteed to be safe to
    retry.[¶](#section-8.7-3.1){.pilcrow}]{#section-8.7-3.1}
-   [The [REFUSED_STREAM](#REFUSED_STREAM){.xref} error code can be
    included in a [RST_STREAM](#RST_STREAM){.xref} frame to indicate
    that the stream is being closed prior to any processing having
    occurred. Any request that was sent on the reset stream can be
    safely retried.[¶](#section-8.7-3.2){.pilcrow}]{#section-8.7-3.2}

Requests that have not been processed have not failed; clients
[MAY]{.bcp14} automatically retry them, even those with non-idempotent
methods.[¶](#section-8.7-4){.pilcrow}

A server [MUST NOT]{.bcp14} indicate that a stream has not been
processed unless it can guarantee that fact. If frames that are on a
stream are passed to the application layer for any stream, then
[REFUSED_STREAM](#REFUSED_STREAM){.xref} [MUST NOT]{.bcp14} be used for
that stream, and a [GOAWAY](#GOAWAY){.xref} frame [MUST]{.bcp14} include
a stream identifier that is greater than or equal to the given stream
identifier.[¶](#section-8.7-5){.pilcrow}

In addition to these mechanisms, the [PING](#PING){.xref} frame provides
a way for a client to easily test a connection. Connections that remain
idle can become broken, because some middleboxes (for instance, network
address translators or load balancers) silently discard connection
bindings. The [PING](#PING){.xref} frame allows a client to safely test
whether a connection is still active without sending a
request.[¶](#section-8.7-6){.pilcrow}
:::
:::

::: {#HttpExamples}
::: {#section-8.8 .section}
### [8.8.](#section-8.8){.section-number .selfRef} [Examples](#name-examples){.section-name .selfRef} {#name-examples}

This section shows HTTP/1.1 requests and responses, with illustrations
of equivalent HTTP/2 requests and
responses.[¶](#section-8.8-1){.pilcrow}

::: {#section-8.8.1 .section}
#### [8.8.1.](#section-8.8.1){.section-number .selfRef} [Simple Request](#name-simple-request){.section-name .selfRef} {#name-simple-request}

An HTTP GET request includes control data and a request header with no
message content and is therefore transmitted as a single
[HEADERS](#HEADERS){.xref} frame, followed by zero or more
[CONTINUATION](#CONTINUATION){.xref} frames containing the serialized
block of request header fields. The [HEADERS](#HEADERS){.xref} frame in
the following has both the END_HEADERS and END_STREAM flags set; no
[CONTINUATION](#CONTINUATION){.xref} frames are
sent.[¶](#section-8.8.1-1){.pilcrow}

::: {#section-8.8.1-2 .alignLeft .art-inline .art-text .artwork}
      GET /resource HTTP/1.1           HEADERS
      Host: example.org          ==>     + END_STREAM
      Accept: image/jpeg                 + END_HEADERS
                                           :method = GET
                                           :scheme = https
                                           :authority = example.org
                                           :path = /resource
                                           host = example.org
                                           accept = image/jpeg

[¶](#section-8.8.1-2){.pilcrow}
:::
:::

::: {#section-8.8.2 .section}
#### [8.8.2.](#section-8.8.2){.section-number .selfRef} [Simple Response](#name-simple-response){.section-name .selfRef} {#name-simple-response}

Similarly, a response that includes only control data and a response
header is transmitted as a [HEADERS](#HEADERS){.xref} frame (again,
followed by zero or more [CONTINUATION](#CONTINUATION){.xref} frames)
containing the serialized block of response header
fields.[¶](#section-8.8.2-1){.pilcrow}

::: {#section-8.8.2-2 .alignLeft .art-inline .art-text .artwork}
      HTTP/1.1 304 Not Modified        HEADERS
      ETag: "xyzzy"              ==>     + END_STREAM
      Expires: Thu, 23 Jan ...           + END_HEADERS
                                           :status = 304
                                           etag = "xyzzy"
                                           expires = Thu, 23 Jan ...

[¶](#section-8.8.2-2){.pilcrow}
:::
:::

::: {#section-8.8.3 .section}
#### [8.8.3.](#section-8.8.3){.section-number .selfRef} [Complex Request](#name-complex-request){.section-name .selfRef} {#name-complex-request}

An HTTP POST request that includes control data and a request header
with message content is transmitted as one [HEADERS](#HEADERS){.xref}
frame, followed by zero or more [CONTINUATION](#CONTINUATION){.xref}
frames containing the request header, followed by one or more
[DATA](#DATA){.xref} frames, with the last
[CONTINUATION](#CONTINUATION){.xref} (or [HEADERS](#HEADERS){.xref})
frame having the END_HEADERS flag set and the final [DATA](#DATA){.xref}
frame having the END_STREAM flag set:[¶](#section-8.8.3-1){.pilcrow}

::: {#section-8.8.3-2 .alignLeft .art-inline .art-text .artwork}
      POST /resource HTTP/1.1          HEADERS
      Host: example.org          ==>     - END_STREAM
      Content-Type: image/jpeg           - END_HEADERS
      Content-Length: 123                  :method = POST
                                           :authority = example.org
                                           :path = /resource
      {binary data}                        :scheme = https

                                       CONTINUATION
                                         + END_HEADERS
                                           content-type = image/jpeg
                                           host = example.org
                                           content-length = 123

                                       DATA
                                         + END_STREAM
                                       {binary data}

[¶](#section-8.8.3-2){.pilcrow}
:::

Note that data contributing to any given field line could be spread
between field block fragments. The allocation of field lines to frames
in this example is illustrative only.[¶](#section-8.8.3-3){.pilcrow}
:::

::: {#section-8.8.4 .section}
#### [8.8.4.](#section-8.8.4){.section-number .selfRef} [Response with Body](#name-response-with-body){.section-name .selfRef} {#name-response-with-body}

A response that includes control data and a response header with message
content is transmitted as a [HEADERS](#HEADERS){.xref} frame, followed
by zero or more [CONTINUATION](#CONTINUATION){.xref} frames, followed by
one or more [DATA](#DATA){.xref} frames, with the last
[DATA](#DATA){.xref} frame in the sequence having the END_STREAM flag
set:[¶](#section-8.8.4-1){.pilcrow}

::: {#section-8.8.4-2 .alignLeft .art-inline .art-text .artwork}
      HTTP/1.1 200 OK                  HEADERS
      Content-Type: image/jpeg   ==>     - END_STREAM
      Content-Length: 123                + END_HEADERS
                                           :status = 200
      {binary data}                        content-type = image/jpeg
                                           content-length = 123

                                       DATA
                                         + END_STREAM
                                       {binary data}

[¶](#section-8.8.4-2){.pilcrow}
:::
:::

::: {#section-8.8.5 .section}
#### [8.8.5.](#section-8.8.5){.section-number .selfRef} [Informational Responses](#name-informational-responses){.section-name .selfRef} {#name-informational-responses}

An informational response using a 1xx status code other than 101 is
transmitted as a [HEADERS](#HEADERS){.xref} frame, followed by zero or
more [CONTINUATION](#CONTINUATION){.xref}
frames.[¶](#section-8.8.5-1){.pilcrow}

A trailer section is sent as a field block after both the request or
response field block and all the [DATA](#DATA){.xref} frames have been
sent. The [HEADERS](#HEADERS){.xref} frame starting the field block that
comprises the trailer section has the END_STREAM flag
set.[¶](#section-8.8.5-2){.pilcrow}

The following example includes both a 100 (Continue) status code, which
is sent in response to a request containing a \"100-continue\" token in
the Expect header field, and a trailer
section:[¶](#section-8.8.5-3){.pilcrow}

::: {#section-8.8.5-4 .alignLeft .art-inline .art-text .artwork}
      HTTP/1.1 100 Continue            HEADERS
      Extension-Field: bar       ==>     - END_STREAM
                                         + END_HEADERS
                                           :status = 100
                                           extension-field = bar

      HTTP/1.1 200 OK                  HEADERS
      Content-Type: image/jpeg   ==>     - END_STREAM
      Transfer-Encoding: chunked         + END_HEADERS
      Trailer: Foo                         :status = 200
                                           content-type = image/jpeg
      123                                  trailer = Foo
      {binary data}
      0                                DATA
      Foo: bar                           - END_STREAM
                                       {binary data}

                                       HEADERS
                                         + END_STREAM
                                         + END_HEADERS
                                           foo = bar

[¶](#section-8.8.5-4){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#HttpExtra}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [HTTP/2 Connections](#name-http-2-connections){.section-name .selfRef} {#name-http-2-connections}

This section outlines attributes of HTTP that improve interoperability,
reduce exposure to known security vulnerabilities, or reduce the
potential for implementation variation.[¶](#section-9-1){.pilcrow}

::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Connection Management](#name-connection-management){.section-name .selfRef} {#name-connection-management}

HTTP/2 connections are persistent. For best performance, it is expected
that clients will not close connections until it is determined that no
further communication with a server is necessary (for example, when a
user navigates away from a particular web page) or until the server
closes the connection.[¶](#section-9.1-1){.pilcrow}

Clients [SHOULD NOT]{.bcp14} open more than one HTTP/2 connection to a
given host and port pair, where the host is derived from a URI, a
selected [alternative service](#RFC7838){.xref}
\[[ALT-SVC](#RFC7838){.xref}\], or a configured
proxy.[¶](#section-9.1-2){.pilcrow}

A client can create additional connections as replacements, either to
replace connections that are near to exhausting the available [stream
identifier space](#StreamIdentifiers){.xref} ([Section
5.1.1](#StreamIdentifiers){.xref}), to refresh the keying material for a
TLS connection, or to replace connections that have encountered
[errors](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}).[¶](#section-9.1-3){.pilcrow}

A client [MAY]{.bcp14} open multiple connections to the same IP address
and TCP port using different [Server Name Indication](#RFC6066){.xref}
\[[TLS-EXT](#RFC6066){.xref}\] values or to provide different TLS client
certificates but [SHOULD]{.bcp14} avoid creating multiple connections
with the same configuration.[¶](#section-9.1-4){.pilcrow}

Servers are encouraged to maintain open connections for as long as
possible but are permitted to terminate idle connections if necessary.
When either endpoint chooses to close the transport-layer TCP
connection, the terminating endpoint [SHOULD]{.bcp14} first send a
[GOAWAY](#GOAWAY){.xref} ([Section 6.8](#GOAWAY){.xref}) frame so that
both endpoints can reliably determine whether previously sent frames
have been processed and gracefully complete or terminate any necessary
remaining tasks.[¶](#section-9.1-5){.pilcrow}

::: {#reuse}
::: {#section-9.1.1 .section}
#### [9.1.1.](#section-9.1.1){.section-number .selfRef} [Connection Reuse](#name-connection-reuse){.section-name .selfRef} {#name-connection-reuse}

Connections that are made to an origin server, either directly or
through a tunnel created using the [CONNECT method](#CONNECT){.xref}
([Section 8.5](#CONNECT){.xref}), [MAY]{.bcp14} be reused for requests
with multiple different URI authority components. A connection can be
reused as long as the origin server is
[authoritative](#authority){.xref} ([Section 10.1](#authority){.xref}).
For TCP connections without TLS, this depends on the host having
resolved to the same IP address.[¶](#section-9.1.1-1){.pilcrow}

For \"`https`\" resources, connection reuse additionally depends on
having a certificate that is valid for the host in the URI. The
certificate presented by the server [MUST]{.bcp14} satisfy any checks
that the client would perform when forming a new TLS connection for the
host in the URI. A single certificate can be used to establish authority
for multiple origins. [Section
4.3](https://www.rfc-editor.org/rfc/rfc9110#section-4.3){.relref} of
\[[HTTP](#RFC9110){.xref}\] describes how a client determines whether a
server is authoritative for a URI.[¶](#section-9.1.1-2){.pilcrow}

In some deployments, reusing a connection for multiple origins can
result in requests being directed to the wrong origin server. For
example, TLS termination might be performed by a middlebox that uses the
TLS [Server Name Indication](#RFC6066){.xref}
\[[TLS-EXT](#RFC6066){.xref}\] extension to select an origin server.
This means that it is possible for clients to send requests to servers
that might not be the intended target for the request, even though the
server is otherwise authoritative.[¶](#section-9.1.1-3){.pilcrow}

A server that does not wish clients to reuse connections can indicate
that it is not authoritative for a request by sending a 421 (Misdirected
Request) status code in response to the request (see [Section
15.5.20](https://www.rfc-editor.org/rfc/rfc9110#section-15.5.20){.relref}
of \[[HTTP](#RFC9110){.xref}\]).[¶](#section-9.1.1-4){.pilcrow}

A client that is configured to use a proxy over HTTP/2 directs requests
to that proxy through a single connection. That is, all requests sent
via a proxy reuse the connection to the
proxy.[¶](#section-9.1.1-5){.pilcrow}
:::
:::
:::

::: {#TLSUsage}
::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Use of TLS Features](#name-use-of-tls-features){.section-name .selfRef} {#name-use-of-tls-features}

Implementations of HTTP/2 [MUST]{.bcp14} use [TLS version
1.2](#RFC5246){.xref} \[[TLS12](#RFC5246){.xref}\] or higher for HTTP/2
over TLS. The general TLS usage guidance in
\[[TLSBCP](#RFC7525){.xref}\] [SHOULD]{.bcp14} be followed, with some
additional restrictions that are specific to
HTTP/2.[¶](#section-9.2-1){.pilcrow}

The TLS implementation [MUST]{.bcp14} support the [Server Name
Indication (SNI)](#RFC6066){.xref} \[[TLS-EXT](#RFC6066){.xref}\]
extension to TLS. If the server is identified by a [domain
name](#RFC8499){.xref} \[[DNS-TERMS](#RFC8499){.xref}\], clients
[MUST]{.bcp14} send the server_name TLS extension unless an alternative
mechanism to indicate the target host is
used.[¶](#section-9.2-2){.pilcrow}

Requirements for deployments of HTTP/2 that negotiate [TLS
1.3](#RFC8446){.xref} \[[TLS13](#RFC8446){.xref}\] are included in
[Section 9.2.3](#tls13features){.xref}. Deployments of TLS 1.2 are
subject to the requirements in Sections [9.2.1](#tls12features){.xref}
and [9.2.2](#tls12ciphers){.xref}. Implementations are encouraged to
provide defaults that comply, but it is recognized that deployments are
ultimately responsible for compliance.[¶](#section-9.2-3){.pilcrow}

::: {#tls12features}
::: {#section-9.2.1 .section}
#### [9.2.1.](#section-9.2.1){.section-number .selfRef} [TLS 1.2 Features](#name-tls-12-features){.section-name .selfRef} {#name-tls-12-features}

This section describes restrictions on the TLS 1.2 feature set that can
be used with HTTP/2. Due to deployment limitations, it might not be
possible to fail TLS negotiation when these restrictions are not met. An
endpoint [MAY]{.bcp14} immediately terminate an HTTP/2 connection that
does not meet these TLS requirements with a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[INADEQUATE_SECURITY](#INADEQUATE_SECURITY){.xref}.[¶](#section-9.2.1-1){.pilcrow}

A deployment of HTTP/2 over TLS 1.2 [MUST]{.bcp14} disable compression.
TLS compression can lead to the exposure of information that would not
otherwise be revealed \[[RFC3749](#RFC3749){.xref}\]. Generic
compression is unnecessary, since HTTP/2 provides compression features
that are more aware of context and therefore likely to be more
appropriate for use for performance, security, or other
reasons.[¶](#section-9.2.1-2){.pilcrow}

A deployment of HTTP/2 over TLS 1.2 [MUST]{.bcp14} disable
renegotiation. An endpoint [MUST]{.bcp14} treat a TLS renegotiation as a
[connection error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}. Note that disabling
renegotiation can result in long-lived connections becoming unusable due
to limits on the number of messages the underlying cipher suite can
encipher.[¶](#section-9.2.1-3){.pilcrow}

An endpoint [MAY]{.bcp14} use renegotiation to provide confidentiality
protection for client credentials offered in the handshake, but any
renegotiation [MUST]{.bcp14} occur prior to sending the connection
preface. A server [SHOULD]{.bcp14} request a client certificate if it
sees a renegotiation request immediately after establishing a
connection.[¶](#section-9.2.1-4){.pilcrow}

This effectively prevents the use of renegotiation in response to a
request for a specific protected resource. A future specification might
provide a way to support this use case. Alternatively, a server might
use an [error](#ErrorHandler){.xref} ([Section
5.4](#ErrorHandler){.xref}) of type
[HTTP_1\_1_REQUIRED](#HTTP_1_1_REQUIRED){.xref} to request that the
client use a protocol that supports
renegotiation.[¶](#section-9.2.1-5){.pilcrow}

Implementations [MUST]{.bcp14} support ephemeral key exchange sizes of
at least 2048 bits for cipher suites that use ephemeral finite field
Diffie-Hellman (DHE) ([Section
8.1.2](https://www.rfc-editor.org/rfc/rfc5246#section-8.1.2){.relref} of
\[[TLS12](#RFC5246){.xref}\]) and 224 bits for cipher suites that use
ephemeral elliptic curve Diffie-Hellman (ECDHE)
\[[RFC8422](#RFC8422){.xref}\]. Clients [MUST]{.bcp14} accept DHE sizes
of up to 4096 bits. Endpoints [MAY]{.bcp14} treat negotiation of key
sizes smaller than the lower limits as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[INADEQUATE_SECURITY](#INADEQUATE_SECURITY){.xref}.[¶](#section-9.2.1-6){.pilcrow}
:::
:::

::: {#tls12ciphers}
::: {#section-9.2.2 .section}
#### [9.2.2.](#section-9.2.2){.section-number .selfRef} [TLS 1.2 Cipher Suites](#name-tls-12-cipher-suites){.section-name .selfRef} {#name-tls-12-cipher-suites}

A deployment of HTTP/2 over TLS 1.2 [SHOULD NOT]{.bcp14} use any of the
prohibited cipher suites listed in [Appendix
A](#BadCipherSuites){.xref}.[¶](#section-9.2.2-1){.pilcrow}

Endpoints [MAY]{.bcp14} choose to generate a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[INADEQUATE_SECURITY](#INADEQUATE_SECURITY){.xref} if one of the
prohibited cipher suites is negotiated. A deployment that chooses to use
a prohibited cipher suite risks triggering a connection error unless the
set of potential peers is known to accept that cipher
suite.[¶](#section-9.2.2-2){.pilcrow}

Implementations [MUST NOT]{.bcp14} generate this error in reaction to
the negotiation of a cipher suite that is not prohibited. Consequently,
when clients offer a cipher suite that is not prohibited, they have to
be prepared to use that cipher suite with
HTTP/2.[¶](#section-9.2.2-3){.pilcrow}

The list of prohibited cipher suites includes the cipher suite that TLS
1.2 makes mandatory, which means that TLS 1.2 deployments could have
non-intersecting sets of permitted cipher suites. To avoid this problem,
which causes TLS handshake failures, deployments of HTTP/2 that use TLS
1.2 [MUST]{.bcp14} support TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
\[[TLS-ECDHE](#RFC5289){.xref}\] with the P-256 elliptic curve
\[[RFC8422](#RFC8422){.xref}\].[¶](#section-9.2.2-4){.pilcrow}

Note that clients might advertise support of cipher suites that are
prohibited in order to allow for connection to servers that do not
support HTTP/2. This allows servers to select HTTP/1.1 with a cipher
suite that is prohibited in HTTP/2. However, this can result in HTTP/2
being negotiated with a prohibited cipher suite if the application
protocol and cipher suite are independently
selected.[¶](#section-9.2.2-5){.pilcrow}
:::
:::

::: {#tls13features}
::: {#section-9.2.3 .section}
#### [9.2.3.](#section-9.2.3){.section-number .selfRef} [TLS 1.3 Features](#name-tls-13-features){.section-name .selfRef} {#name-tls-13-features}

TLS 1.3 includes a number of features not available in earlier versions.
This section discusses the use of these
features.[¶](#section-9.2.3-1){.pilcrow}

HTTP/2 servers [MUST NOT]{.bcp14} send post-handshake TLS 1.3
CertificateRequest messages. HTTP/2 clients [MUST]{.bcp14} treat a TLS
post-handshake CertificateRequest message as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[PROTOCOL_ERROR](#PROTOCOL_ERROR){.xref}.[¶](#section-9.2.3-2){.pilcrow}

The prohibition on post-handshake authentication applies even if the
client offered the \"post_handshake_auth\" TLS extension. Post-handshake
authentication support might be advertised independently of
[ALPN](#RFC7301){.xref} \[[TLS-ALPN](#RFC7301){.xref}\]. Clients might
offer the capability for use in other protocols, but inclusion of the
extension cannot imply support within
HTTP/2.[¶](#section-9.2.3-3){.pilcrow}

\[[TLS13](#RFC8446){.xref}\] defines other post-handshake messages,
NewSessionTicket and KeyUpdate, which can be used as they have no direct
interaction with HTTP/2. Unless the use of a new type of TLS message
depends on an interaction with the application-layer protocol, that TLS
message can be sent after the handshake
completes.[¶](#section-9.2.3-4){.pilcrow}

TLS early data [MAY]{.bcp14} be used to send requests, provided that the
guidance in \[[RFC8470](#RFC8470){.xref}\] is observed. Clients send
requests in early data assuming initial values for all server
settings.[¶](#section-9.2.3-5){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#security}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

The use of TLS is necessary to provide many of the security properties
of this protocol. Many of the claims in this section do not hold unless
TLS is used as described in [Section
9.2](#TLSUsage){.xref}.[¶](#section-10-1){.pilcrow}

::: {#authority}
::: {#section-10.1 .section}
### [10.1.](#section-10.1){.section-number .selfRef} [Server Authority](#name-server-authority){.section-name .selfRef} {#name-server-authority}

HTTP/2 relies on the HTTP definition of authority for determining
whether a server is authoritative in providing a given response (see
[Section
4.3](https://www.rfc-editor.org/rfc/rfc9110#section-4.3){.relref} of
\[[HTTP](#RFC9110){.xref}\]). This relies on local name resolution for
the \"`http`\" URI scheme and the authenticated server identity for the
\"`https`\" scheme.[¶](#section-10.1-1){.pilcrow}
:::
:::

::: {#section-10.2 .section}
### [10.2.](#section-10.2){.section-number .selfRef} [Cross-Protocol Attacks](#name-cross-protocol-attacks){.section-name .selfRef} {#name-cross-protocol-attacks}

In a cross-protocol attack, an attacker causes a client to initiate a
transaction in one protocol toward a server that understands a different
protocol. An attacker might be able to cause the transaction to appear
as a valid transaction in the second protocol. In combination with the
capabilities of the web context, this can be used to interact with
poorly protected servers in private
networks.[¶](#section-10.2-1){.pilcrow}

Completing a TLS handshake with an ALPN identifier for HTTP/2 can be
considered sufficient protection against cross-protocol attacks. ALPN
provides a positive indication that a server is willing to proceed with
HTTP/2, which prevents attacks on other TLS-based
protocols.[¶](#section-10.2-2){.pilcrow}

The encryption in TLS makes it difficult for attackers to control the
data that could be used in a cross-protocol attack on a cleartext
protocol.[¶](#section-10.2-3){.pilcrow}

The cleartext version of HTTP/2 has minimal protection against
cross-protocol attacks. The [connection preface](#preface){.xref}
([Section 3.4](#preface){.xref}) contains a string that is designed to
confuse HTTP/1.1 servers, but no special protection is offered for other
protocols.[¶](#section-10.2-4){.pilcrow}
:::

::: {#section-10.3 .section}
### [10.3.](#section-10.3){.section-number .selfRef} [Intermediary Encapsulation Attacks](#name-intermediary-encapsulation-){.section-name .selfRef} {#name-intermediary-encapsulation-}

HPACK permits encoding of field names and values that might be treated
as delimiters in other HTTP versions. An intermediary that translates an
HTTP/2 request or response [MUST]{.bcp14} validate fields according to
the rules in [Section 8.2](#HttpHeaders){.xref} before translating a
message to another HTTP version. Translating a field that includes
invalid delimiters could be used to cause recipients to incorrectly
interpret a message, which could be exploited by an
attacker.[¶](#section-10.3-1){.pilcrow}

[Section 8.2](#HttpHeaders){.xref} does not include specific rules for
validation of pseudo-header fields. If the values of these fields are
used, additional validation is necessary. This is particularly important
where \"`:scheme`\", \"`:authority`\", and \"`:path`\" are combined to
form a single URI string \[[RFC3986](#RFC3986){.xref}\]. Similar
problems might occur when that URI or just \"`:path`\" is combined with
\"`:method`\" to construct a request line (as in [Section
3](https://www.rfc-editor.org/rfc/rfc9112#section-3){.relref} of
\[[HTTP/1.1](#RFC9112){.xref}\]). Simple concatenation is not secure
unless the input values are fully
validated.[¶](#section-10.3-2){.pilcrow}

An intermediary can reject fields that contain invalid field names or
values for other reasons \-- in particular, those fields that do not
conform to the HTTP ABNF grammar from [Section
5](https://www.rfc-editor.org/rfc/rfc9110#section-5){.relref} of
\[[HTTP](#RFC9110){.xref}\]. Intermediaries that do not perform any
validation of fields other than the minimum required by [Section
8.2](#HttpHeaders){.xref} could forward messages that contain invalid
field names or values.[¶](#section-10.3-3){.pilcrow}

An intermediary that receives any fields that require removal before
forwarding (see [Section
7.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1){.relref} of
\[[HTTP](#RFC9110){.xref}\]) [MUST]{.bcp14} remove or replace those
header fields when forwarding messages. Additionally, intermediaries
should take care when forwarding messages containing `Content-Length`
fields to ensure that the message is [well-formed](#malformed){.xref}
([Section 8.1.1](#malformed){.xref}). This ensures that if the message
is translated into HTTP/1.1 at any point, the framing will be
correct.[¶](#section-10.3-4){.pilcrow}
:::

::: {#section-10.4 .section}
### [10.4.](#section-10.4){.section-number .selfRef} [Cacheability of Pushed Responses](#name-cacheability-of-pushed-resp){.section-name .selfRef} {#name-cacheability-of-pushed-resp}

Pushed responses do not have an explicit request from the client; the
request is provided by the server in the
[PUSH_PROMISE](#PUSH_PROMISE){.xref}
frame.[¶](#section-10.4-1){.pilcrow}

Caching responses that are pushed is possible based on the guidance
provided by the origin server in the Cache-Control header field.
However, this can cause issues if a single server hosts more than one
tenant. For example, a server might offer multiple users each a small
portion of its URI space.[¶](#section-10.4-2){.pilcrow}

Where multiple tenants share space on the same server, that server
[MUST]{.bcp14} ensure that tenants are not able to push representations
of resources that they do not have authority over. Failure to enforce
this would allow a tenant to provide a representation that would be
served out of cache, overriding the actual representation that the
authoritative tenant provides.[¶](#section-10.4-3){.pilcrow}

Pushed responses for which an origin server is not authoritative (see
[Section 10.1](#authority){.xref}) [MUST NOT]{.bcp14} be used or
cached.[¶](#section-10.4-4){.pilcrow}
:::

::: {#dos}
::: {#section-10.5 .section}
### [10.5.](#section-10.5){.section-number .selfRef} [Denial-of-Service Considerations](#name-denial-of-service-considera){.section-name .selfRef} {#name-denial-of-service-considera}

An HTTP/2 connection can demand a greater commitment of resources to
operate than an HTTP/1.1 connection. Both field section compression and
flow control depend on a commitment of a greater amount of state.
Settings for these features ensure that memory commitments for these
features are strictly bounded.[¶](#section-10.5-1){.pilcrow}

The number of [PUSH_PROMISE](#PUSH_PROMISE){.xref} frames is not
constrained in the same fashion. A client that accepts server push
[SHOULD]{.bcp14} limit the number of streams it allows to be in the
\"reserved (remote)\" state. An excessive number of server push streams
can be treated as a [stream error](#StreamErrorHandler){.xref} ([Section
5.4.2](#StreamErrorHandler){.xref}) of type
[ENHANCE_YOUR_CALM](#ENHANCE_YOUR_CALM){.xref}.[¶](#section-10.5-2){.pilcrow}

A number of HTTP/2 implementations were found to be vulnerable to denial
of service \[[NFLX-2019-002](#NFLX-2019-002){.xref}\]. Below is a list
of known ways that implementations might be subject to denial-of-service
attacks:[¶](#section-10.5-3){.pilcrow}

-   ::: {#section-10.5-4.1}
    Inefficient tracking of outstanding outbound frames can lead to
    overload if an adversary can cause large numbers of frames to be
    enqueued for sending. A peer could use one of several techniques to
    cause large numbers of frames to be
    generated:[¶](#section-10.5-4.1.1){.pilcrow}

    -   [Providing tiny increments to flow control in
        [WINDOW_UPDATE](#WINDOW_UPDATE){.xref} frames can cause a sender
        to generate a large number of [DATA](#DATA){.xref}
        frames.[¶](#section-10.5-4.1.2.1){.pilcrow}]{#section-10.5-4.1.2.1}
    -   [An endpoint is required to respond to a [PING](#PING){.xref}
        frame.[¶](#section-10.5-4.1.2.2){.pilcrow}]{#section-10.5-4.1.2.2}
    -   [Each [SETTINGS](#SETTINGS){.xref} frame requires
        acknowledgment.[¶](#section-10.5-4.1.2.3){.pilcrow}]{#section-10.5-4.1.2.3}
    -   [An invalid request (or server push) can cause a peer to send
        [RST_STREAM](#RST_STREAM){.xref} frames in
        response.[¶](#section-10.5-4.1.2.4){.pilcrow}]{#section-10.5-4.1.2.4}
    :::

-   [An attacker can provide large amounts of flow-control credit at the
    HTTP/2 layer but withhold credit at the TCP layer, preventing frames
    from being sent. An endpoint that constructs and remembers frames
    for sending without considering TCP limits might be subject to
    resource
    exhaustion.[¶](#section-10.5-4.2){.pilcrow}]{#section-10.5-4.2}

-   [Large numbers of small or empty frames can be abused to cause a
    peer to expend time processing frame headers. Caution is required
    here as some uses of small frames are entirely legitimate, such as
    the sending of an empty [DATA](#DATA){.xref} or
    [CONTINUATION](#CONTINUATION){.xref} frame at the end of a
    stream.[¶](#section-10.5-4.3){.pilcrow}]{#section-10.5-4.3}

-   [The [SETTINGS](#SETTINGS){.xref} frame might also be abused to
    cause a peer to expend additional processing time. This might be
    done by pointlessly changing settings, sending multiple undefined
    settings, or changing the same setting multiple times in the same
    frame.[¶](#section-10.5-4.4){.pilcrow}]{#section-10.5-4.4}

-   [Handling reprioritization with [PRIORITY](#PRIORITY){.xref} frames
    can require significant processing time and can lead to overload if
    many [PRIORITY](#PRIORITY){.xref} frames are
    sent.[¶](#section-10.5-4.5){.pilcrow}]{#section-10.5-4.5}

-   [Field section compression also provides opportunities for an
    attacker to waste processing resources; see [Section
    7](https://www.rfc-editor.org/rfc/rfc7541#section-7){.relref} of
    \[[COMPRESSION](#RFC7541){.xref}\] for more details on potential
    abuses.[¶](#section-10.5-4.6){.pilcrow}]{#section-10.5-4.6}

-   [Limits in [SETTINGS](#SETTINGS){.xref} cannot be reduced
    instantaneously, which leaves an endpoint exposed to behavior from a
    peer that could exceed the new limits. In particular, immediately
    after establishing a connection, limits set by a server are not
    known to clients and could be exceeded without being an obvious
    protocol
    violation.[¶](#section-10.5-4.7){.pilcrow}]{#section-10.5-4.7}

Most of the features that might be exploited for denial of service \--
such as [SETTINGS](#SETTINGS){.xref} changes, small frames, field
section compression \-- have legitimate uses. These features become a
burden only when they are used unnecessarily or to
excess.[¶](#section-10.5-5){.pilcrow}

An endpoint that doesn\'t monitor use of these features exposes itself
to a risk of denial of service. Implementations [SHOULD]{.bcp14} track
the use of these features and set limits on their use. An endpoint
[MAY]{.bcp14} treat activity that is suspicious as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[ENHANCE_YOUR_CALM](#ENHANCE_YOUR_CALM){.xref}.[¶](#section-10.5-6){.pilcrow}

::: {#MaxFieldBlock}
::: {#section-10.5.1 .section}
#### [10.5.1.](#section-10.5.1){.section-number .selfRef} [Limits on Field Block Size](#name-limits-on-field-block-size){.section-name .selfRef} {#name-limits-on-field-block-size}

A large [field block](#FieldBlock){.xref} ([Section
4.3](#FieldBlock){.xref}) can cause an implementation to commit a large
amount of state. Field lines that are critical for routing can appear
toward the end of a field block, which prevents streaming of fields to
their ultimate destination. This ordering and other reasons, such as
ensuring cache correctness, mean that an endpoint might need to buffer
the entire field block. Since there is no hard limit to the size of a
field block, some endpoints could be forced to commit a large amount of
available memory for field blocks.[¶](#section-10.5.1-1){.pilcrow}

An endpoint can use the
[SETTINGS_MAX_HEADER_LIST_SIZE](#SETTINGS_MAX_HEADER_LIST_SIZE){.xref}
to advise peers of limits that might apply on the size of uncompressed
field blocks. This setting is only advisory, so endpoints [MAY]{.bcp14}
choose to send field blocks that exceed this limit and risk the request
or response being treated as malformed. This setting is specific to a
connection, so any request or response could encounter a hop with a
lower, unknown limit. An intermediary can attempt to avoid this problem
by passing on values presented by different peers, but they are not
obliged to do so.[¶](#section-10.5.1-2){.pilcrow}

A server that receives a larger field block than it is willing to handle
can send an HTTP 431 (Request Header Fields Too Large) status code
\[[RFC6585](#RFC6585){.xref}\]. A client can discard responses that it
cannot process. The field block [MUST]{.bcp14} be processed to ensure a
consistent connection state, unless the connection is
closed.[¶](#section-10.5.1-3){.pilcrow}
:::
:::

::: {#connectDos}
::: {#section-10.5.2 .section}
#### [10.5.2.](#section-10.5.2){.section-number .selfRef} [CONNECT Issues](#name-connect-issues){.section-name .selfRef} {#name-connect-issues}

The CONNECT method can be used to create disproportionate load on a
proxy, since stream creation is relatively inexpensive when compared to
the creation and maintenance of a TCP connection. A proxy might also
maintain some resources for a TCP connection beyond the closing of the
stream that carries the CONNECT request, since the outgoing TCP
connection remains in the TIME_WAIT state. Therefore, a proxy cannot
rely on
[SETTINGS_MAX_CONCURRENT_STREAMS](#SETTINGS_MAX_CONCURRENT_STREAMS){.xref}
alone to limit the resources consumed by CONNECT
requests.[¶](#section-10.5.2-1){.pilcrow}
:::
:::
:::
:::

::: {#section-10.6 .section}
### [10.6.](#section-10.6){.section-number .selfRef} [Use of Compression](#name-use-of-compression){.section-name .selfRef} {#name-use-of-compression}

Compression can allow an attacker to recover secret data when it is
compressed in the same context as data under attacker control. HTTP/2
enables compression of field lines ([Section 4.3](#FieldBlock){.xref});
the following concerns also apply to the use of HTTP compressed
content-codings ([Section
8.4.1](https://www.rfc-editor.org/rfc/rfc9110#section-8.4.1){.relref} of
\[[HTTP](#RFC9110){.xref}\]).[¶](#section-10.6-1){.pilcrow}

There are demonstrable attacks on compression that exploit the
characteristics of the Web (e.g., \[[BREACH](#BREACH){.xref}\]). The
attacker induces multiple requests containing varying plaintext,
observing the length of the resulting ciphertext in each, which reveals
a shorter length when a guess about the secret is
correct.[¶](#section-10.6-2){.pilcrow}

Implementations communicating on a secure channel [MUST NOT]{.bcp14}
compress content that includes both confidential and attacker-controlled
data unless separate compression dictionaries are used for each source
of data. Compression [MUST NOT]{.bcp14} be used if the source of data
cannot be reliably determined. Generic stream compression, such as that
provided by TLS, [MUST NOT]{.bcp14} be used with HTTP/2 (see [Section
9.2](#TLSUsage){.xref}).[¶](#section-10.6-3){.pilcrow}

Further considerations regarding the compression of header fields are
described in
\[[COMPRESSION](#RFC7541){.xref}\].[¶](#section-10.6-4){.pilcrow}
:::

::: {#padding}
::: {#section-10.7 .section}
### [10.7.](#section-10.7){.section-number .selfRef} [Use of Padding](#name-use-of-padding){.section-name .selfRef} {#name-use-of-padding}

Padding within HTTP/2 is not intended as a replacement for general
purpose padding, such as that provided by [TLS](#RFC8446){.xref}
\[[TLS13](#RFC8446){.xref}\]. Redundant padding could even be
counterproductive. Correct application can depend on having specific
knowledge of the data that is being
padded.[¶](#section-10.7-1){.pilcrow}

To mitigate attacks that rely on compression, disabling or limiting
compression might be preferable to padding as a
countermeasure.[¶](#section-10.7-2){.pilcrow}

Padding can be used to obscure the exact size of frame content and is
provided to mitigate specific attacks within HTTP \-- for example,
attacks where compressed content includes both attacker-controlled
plaintext and secret data (e.g.,
\[[BREACH](#BREACH){.xref}\]).[¶](#section-10.7-3){.pilcrow}

Use of padding can result in less protection than might seem immediately
obvious. At best, padding only makes it more difficult for an attacker
to infer length information by increasing the number of frames an
attacker has to observe. Incorrectly implemented padding schemes can be
easily defeated. In particular, randomized padding with a predictable
distribution provides very little protection; similarly, padding frame
payloads to a fixed size exposes information as frame payload sizes
cross the fixed-sized boundary, which could be possible if an attacker
can control plaintext.[¶](#section-10.7-4){.pilcrow}

Intermediaries [SHOULD]{.bcp14} retain padding for [DATA](#DATA){.xref}
frames but [MAY]{.bcp14} drop padding for [HEADERS](#HEADERS){.xref} and
[PUSH_PROMISE](#PUSH_PROMISE){.xref} frames. A valid reason for an
intermediary to change the amount of padding of frames is to improve the
protections that padding provides.[¶](#section-10.7-5){.pilcrow}
:::
:::

::: {#section-10.8 .section}
### [10.8.](#section-10.8){.section-number .selfRef} [Privacy Considerations](#name-privacy-considerations){.section-name .selfRef} {#name-privacy-considerations}

Several characteristics of HTTP/2 provide an observer an opportunity to
correlate actions of a single client or server over time. These include
the values of settings, the manner in which flow-control windows are
managed, the way priorities are allocated to streams, the timing of
reactions to stimulus, and the handling of any features that are
controlled by settings.[¶](#section-10.8-1){.pilcrow}

As far as these create observable differences in behavior, they could be
used as a basis for fingerprinting a specific client, as defined in
[Section
3.2](https://www.rfc-editor.org/rfc/rfc6973#section-3.2){.relref} of
\[[PRIVACY](#RFC6973){.xref}\].[¶](#section-10.8-2){.pilcrow}

HTTP/2\'s preference for using a single TCP connection allows
correlation of a user\'s activity on a site. Reusing connections for
different origins allows tracking across those
origins.[¶](#section-10.8-3){.pilcrow}

Because the PING and SETTINGS frames solicit immediate responses, they
can be used by an endpoint to measure latency to their peer. This might
have privacy implications in certain
scenarios.[¶](#section-10.8-4){.pilcrow}
:::

::: {#section-10.9 .section}
### [10.9.](#section-10.9){.section-number .selfRef} [Remote Timing Attacks](#name-remote-timing-attacks){.section-name .selfRef} {#name-remote-timing-attacks}

Remote timing attacks extract secrets from servers by observing
variations in the time that servers take when processing requests that
use secrets. HTTP/2 enables concurrent request creation and processing,
which can give attackers better control over when request processing
commences. Multiple HTTP/2 requests can be included in the same IP
packet or TLS record. HTTP/2 can therefore make remote timing attacks
more efficient by eliminating variability in request delivery, leaving
only request order and the delivery of responses as sources of timing
variability.[¶](#section-10.9-1){.pilcrow}

Ensuring that processing time is not dependent on the value of a secret
is the best defense against any form of timing
attack.[¶](#section-10.9-2){.pilcrow}
:::
:::
:::

::: {#iana}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This revision of HTTP/2 marks the `HTTP2-Settings` header field and the
`h2c` upgrade token, both defined in \[[RFC7540](#RFC7540){.xref}\], as
obsolete.[¶](#section-11-1){.pilcrow}

[Section 11](https://www.rfc-editor.org/rfc/rfc7540#section-11){.relref}
of \[[RFC7540](#RFC7540){.xref}\] registered the `h2` and `h2c` ALPN
identifiers along with the `PRI` HTTP method. RFC 7540 also established
a registry for frame types, settings, and error codes. These
registrations and registries apply to HTTP/2, but are not redefined in
this document.[¶](#section-11-2){.pilcrow}

IANA has updated references to RFC 7540 in the following registries to
refer to this document: \"TLS Application-Layer Protocol Negotiation
(ALPN) Protocol IDs\", \"HTTP/2 Frame Type\", \"HTTP/2 Settings\",
\"HTTP/2 Error Code\", and \"HTTP Method Registry\". The registration of
the `PRI` method has been updated to refer to [Section
3.4](#preface){.xref}; all other section numbers have not
changed.[¶](#section-11-3){.pilcrow}

IANA has changed the policy on those portions of the \"HTTP/2 Frame
Type\" and \"HTTP/2 Settings\" registries that were reserved for
Experimental Use in RFC 7540. These portions of the registries shall
operate on the same policy as the remainder of each
registry.[¶](#section-11-4){.pilcrow}

::: {#HTTP2-Settings}
::: {#section-11.1 .section}
### [11.1.](#section-11.1){.section-number .selfRef} [HTTP2-Settings Header Field Registration](#name-http2-settings-header-field){.section-name .selfRef} {#name-http2-settings-header-field}

This section marks the `HTTP2-Settings` header field registered by
[Section
11.5](https://www.rfc-editor.org/rfc/rfc7540#section-11.5){.relref} of
\[[RFC7540](#RFC7540){.xref}\] in the \"Hypertext Transfer Protocol
(HTTP) Field Name Registry\" as obsolete. This capability has been
removed: see [Section 3.1](#versioning){.xref}. The registration is
updated to include the details as required by [Section
18.4](https://www.rfc-editor.org/rfc/rfc9110#section-18.4){.relref} of
\[[HTTP](#RFC9110){.xref}\]:[¶](#section-11.1-1){.pilcrow}

[]{.break}

Field Name:
:   HTTP2-Settings[¶](#section-11.1-2.2){.pilcrow}
:   

Status:
:   obsoleted[¶](#section-11.1-2.4){.pilcrow}
:   

Reference:
:   [Section
    3.2.1](https://www.rfc-editor.org/rfc/rfc7540#section-3.2.1){.relref}
    of \[[RFC7540](#RFC7540){.xref}\][¶](#section-11.1-2.6){.pilcrow}
:   

Comments:
:   Obsolete; see [Section 11.1](#HTTP2-Settings){.xref} of this
    document.[¶](#section-11.1-2.8){.pilcrow}
:   
:::
:::

::: {#iana-h2c}
::: {#section-11.2 .section}
### [11.2.](#section-11.2){.section-number .selfRef} [The h2c Upgrade Token](#name-the-h2c-upgrade-token){.section-name .selfRef} {#name-the-h2c-upgrade-token}

This section records the `h2c` upgrade token registered by [Section
11.8](https://www.rfc-editor.org/rfc/rfc7540#section-11.8){.relref} of
\[[RFC7540](#RFC7540){.xref}\] in the \"Hypertext Transfer Protocol
(HTTP) Upgrade Token Registry\" as obsolete. This capability has been
removed: see [Section 3.1](#versioning){.xref}. The registration is
updated as follows:[¶](#section-11.2-1){.pilcrow}

[]{.break}

Value:
:   h2c[¶](#section-11.2-2.2){.pilcrow}
:   

Description:
:   (OBSOLETE) Hypertext Transfer Protocol version 2
    (HTTP/2)[¶](#section-11.2-2.4){.pilcrow}
:   

Expected Version Tokens:
:   None[¶](#section-11.2-2.6){.pilcrow}
:   

Reference:
:   [Section 3.1](#versioning){.xref} of this
    document[¶](#section-11.2-2.8){.pilcrow}
:   
:::
:::
:::
:::

::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-12.1 .section}
### [12.1.](#section-12.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[CACHING\]
:   [Fielding, R., Ed.]{.refAuthor}, [Nottingham, M., Ed.]{.refAuthor},
    and [J. Reschke, Ed.]{.refAuthor}, [\"HTTP Caching\"]{.refTitle},
    [STD 98]{.seriesInfo}, [RFC 9111]{.seriesInfo}, [DOI
    10.17487/RFC9111]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9111>\>.
:   

\[COMPRESSION\]
:   [Peon, R.]{.refAuthor} and [H. Ruellan]{.refAuthor}, [\"HPACK:
    Header Compression for HTTP/2\"]{.refTitle}, [RFC
    7541]{.seriesInfo}, [DOI 10.17487/RFC7541]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7541>\>.
:   

\[COOKIE\]
:   [Barth, A.]{.refAuthor}, [\"HTTP State Management
    Mechanism\"]{.refTitle}, [RFC 6265]{.seriesInfo}, [DOI
    10.17487/RFC6265]{.seriesInfo}, April 2011,
    \<<https://www.rfc-editor.org/info/rfc6265>\>.
:   

\[HTTP\]
:   [Fielding, R., Ed.]{.refAuthor}, [Nottingham, M., Ed.]{.refAuthor},
    and [J. Reschke, Ed.]{.refAuthor}, [\"HTTP Semantics\"]{.refTitle},
    [STD 97]{.seriesInfo}, [RFC 9110]{.seriesInfo}, [DOI
    10.17487/RFC9110]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9110>\>.
:   

\[QUIC\]
:   [Iyengar, J., Ed.]{.refAuthor} and [M. Thomson, Ed.]{.refAuthor},
    [\"QUIC: A UDP-Based Multiplexed and Secure Transport\"]{.refTitle},
    [RFC 9000]{.seriesInfo}, [DOI 10.17487/RFC9000]{.seriesInfo}, May
    2021, \<<https://www.rfc-editor.org/info/rfc9000>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC3986\]
:   [Berners-Lee, T.]{.refAuthor}, [Fielding, R.]{.refAuthor}, and [L.
    Masinter]{.refAuthor}, [\"Uniform Resource Identifier (URI): Generic
    Syntax\"]{.refTitle}, [STD 66]{.seriesInfo}, [RFC
    3986]{.seriesInfo}, [DOI 10.17487/RFC3986]{.seriesInfo}, January
    2005, \<<https://www.rfc-editor.org/info/rfc3986>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8422\]
:   [Nir, Y.]{.refAuthor}, [Josefsson, S.]{.refAuthor}, and [M.
    Pegourie-Gonnard]{.refAuthor}, [\"Elliptic Curve Cryptography (ECC)
    Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and
    Earlier\"]{.refTitle}, [RFC 8422]{.seriesInfo}, [DOI
    10.17487/RFC8422]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8422>\>.
:   

\[RFC8470\]
:   [Thomson, M.]{.refAuthor}, [Nottingham, M.]{.refAuthor}, and [W.
    Tarreau]{.refAuthor}, [\"Using Early Data in HTTP\"]{.refTitle},
    [RFC 8470]{.seriesInfo}, [DOI 10.17487/RFC8470]{.seriesInfo},
    September 2018, \<<https://www.rfc-editor.org/info/rfc8470>\>.
:   

\[TCP\]
:   [Postel, J.]{.refAuthor}, [\"Transmission Control
    Protocol\"]{.refTitle}, [STD 7]{.seriesInfo}, [RFC
    793]{.seriesInfo}, [DOI 10.17487/RFC0793]{.seriesInfo}, September
    1981, \<<https://www.rfc-editor.org/info/rfc793>\>.
:   

\[TLS-ALPN\]
:   [Friedl, S.]{.refAuthor}, [Popov, A.]{.refAuthor},
    [Langley, A.]{.refAuthor}, and [E. Stephan]{.refAuthor},
    [\"Transport Layer Security (TLS) Application-Layer Protocol
    Negotiation Extension\"]{.refTitle}, [RFC 7301]{.seriesInfo}, [DOI
    10.17487/RFC7301]{.seriesInfo}, July 2014,
    \<<https://www.rfc-editor.org/info/rfc7301>\>.
:   

\[TLS-ECDHE\]
:   [Rescorla, E.]{.refAuthor}, [\"TLS Elliptic Curve Cipher Suites with
    SHA-256/384 and AES Galois Counter Mode (GCM)\"]{.refTitle}, [RFC
    5289]{.seriesInfo}, [DOI 10.17487/RFC5289]{.seriesInfo}, August
    2008, \<<https://www.rfc-editor.org/info/rfc5289>\>.
:   

\[TLS-EXT\]
:   [Eastlake 3rd, D.]{.refAuthor}, [\"Transport Layer Security (TLS)
    Extensions: Extension Definitions\"]{.refTitle}, [RFC
    6066]{.seriesInfo}, [DOI 10.17487/RFC6066]{.seriesInfo}, January
    2011, \<<https://www.rfc-editor.org/info/rfc6066>\>.
:   

\[TLS12\]
:   [Dierks, T.]{.refAuthor} and [E. Rescorla]{.refAuthor}, [\"The
    Transport Layer Security (TLS) Protocol Version 1.2\"]{.refTitle},
    [RFC 5246]{.seriesInfo}, [DOI 10.17487/RFC5246]{.seriesInfo}, August
    2008, \<<https://www.rfc-editor.org/info/rfc5246>\>.
:   

\[TLS13\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   

\[TLSBCP\]
:   [Sheffer, Y.]{.refAuthor}, [Holz, R.]{.refAuthor}, and [P.
    Saint-Andre]{.refAuthor}, [\"Recommendations for Secure Use of
    Transport Layer Security (TLS) and Datagram Transport Layer Security
    (DTLS)\"]{.refTitle}, [BCP 195]{.seriesInfo}, [RFC
    7525]{.seriesInfo}, [DOI 10.17487/RFC7525]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7525>\>.
:   
:::

::: {#section-12.2 .section}
### [12.2.](#section-12.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[ALT-SVC\]
:   [Nottingham, M.]{.refAuthor}, [McManus, P.]{.refAuthor}, and [J.
    Reschke]{.refAuthor}, [\"HTTP Alternative Services\"]{.refTitle},
    [RFC 7838]{.seriesInfo}, [DOI 10.17487/RFC7838]{.seriesInfo}, April
    2016, \<<https://www.rfc-editor.org/info/rfc7838>\>.
:   

\[BREACH\]
:   [Gluck, Y.]{.refAuthor}, [Harris, N.]{.refAuthor}, and [A.
    Prado]{.refAuthor}, [\"BREACH: Reviving the CRIME
    Attack\"]{.refTitle}, 12 July 2013,
    \<<https://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf>\>.
:   

\[DNS-TERMS\]
:   [Hoffman, P.]{.refAuthor}, [Sullivan, A.]{.refAuthor}, and [K.
    Fujiwara]{.refAuthor}, [\"DNS Terminology\"]{.refTitle}, [BCP
    219]{.seriesInfo}, [RFC 8499]{.seriesInfo}, [DOI
    10.17487/RFC8499]{.seriesInfo}, January 2019,
    \<<https://www.rfc-editor.org/info/rfc8499>\>.
:   

\[HTTP-PRIORITY\]
:   [Oku, K.]{.refAuthor} and [L. Pardue]{.refAuthor}, [\"Extensible
    Prioritization Scheme for HTTP\"]{.refTitle}, [RFC
    9218]{.seriesInfo}, [DOI 10.17487/RFC9218]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9218>\>.
:   

\[HTTP/1.1\]
:   [Fielding, R., Ed.]{.refAuthor}, [Nottingham, M., Ed.]{.refAuthor},
    and [J. Reschke, Ed.]{.refAuthor}, [\"HTTP/1.1\"]{.refTitle}, [STD
    99]{.seriesInfo}, [RFC 9112]{.seriesInfo}, [DOI
    10.17487/RFC9112]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9112>\>.
:   

\[NFLX-2019-002\]
:   [Netflix]{.refAuthor}, [\"HTTP/2 Denial of Service
    Advisory\"]{.refTitle}, 13 August 2019,
    \<<https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md>\>.
:   

\[PRIVACY\]
:   [Cooper, A.]{.refAuthor}, [Tschofenig, H.]{.refAuthor},
    [Aboba, B.]{.refAuthor}, [Peterson, J.]{.refAuthor},
    [Morris, J.]{.refAuthor}, [Hansen, M.]{.refAuthor}, and [R.
    Smith]{.refAuthor}, [\"Privacy Considerations for Internet
    Protocols\"]{.refTitle}, [RFC 6973]{.seriesInfo}, [DOI
    10.17487/RFC6973]{.seriesInfo}, July 2013,
    \<<https://www.rfc-editor.org/info/rfc6973>\>.
:   

\[RFC1122\]
:   [Braden, R., Ed.]{.refAuthor}, [\"Requirements for Internet Hosts -
    Communication Layers\"]{.refTitle}, [STD 3]{.seriesInfo}, [RFC
    1122]{.seriesInfo}, [DOI 10.17487/RFC1122]{.seriesInfo}, October
    1989, \<<https://www.rfc-editor.org/info/rfc1122>\>.
:   

\[RFC3749\]
:   [Hollenbeck, S.]{.refAuthor}, [\"Transport Layer Security Protocol
    Compression Methods\"]{.refTitle}, [RFC 3749]{.seriesInfo}, [DOI
    10.17487/RFC3749]{.seriesInfo}, May 2004,
    \<<https://www.rfc-editor.org/info/rfc3749>\>.
:   

\[RFC6125\]
:   [Saint-Andre, P.]{.refAuthor} and [J. Hodges]{.refAuthor},
    [\"Representation and Verification of Domain-Based Application
    Service Identity within Internet Public Key Infrastructure Using
    X.509 (PKIX) Certificates in the Context of Transport Layer Security
    (TLS)\"]{.refTitle}, [RFC 6125]{.seriesInfo}, [DOI
    10.17487/RFC6125]{.seriesInfo}, March 2011,
    \<<https://www.rfc-editor.org/info/rfc6125>\>.
:   

\[RFC6585\]
:   [Nottingham, M.]{.refAuthor} and [R. Fielding]{.refAuthor},
    [\"Additional HTTP Status Codes\"]{.refTitle}, [RFC
    6585]{.seriesInfo}, [DOI 10.17487/RFC6585]{.seriesInfo}, April 2012,
    \<<https://www.rfc-editor.org/info/rfc6585>\>.
:   

\[RFC7323\]
:   [Borman, D.]{.refAuthor}, [Braden, B.]{.refAuthor},
    [Jacobson, V.]{.refAuthor}, and [R. Scheffenegger, Ed.]{.refAuthor},
    [\"TCP Extensions for High Performance\"]{.refTitle}, [RFC
    7323]{.seriesInfo}, [DOI 10.17487/RFC7323]{.seriesInfo}, September
    2014, \<<https://www.rfc-editor.org/info/rfc7323>\>.
:   

\[RFC7540\]
:   [Belshe, M.]{.refAuthor}, [Peon, R.]{.refAuthor}, and [M. Thomson,
    Ed.]{.refAuthor}, [\"Hypertext Transfer Protocol Version 2
    (HTTP/2)\"]{.refTitle}, [RFC 7540]{.seriesInfo}, [DOI
    10.17487/RFC7540]{.seriesInfo}, May 2015,
    \<<https://www.rfc-editor.org/info/rfc7540>\>.
:   

\[RFC8441\]
:   [McManus, P.]{.refAuthor}, [\"Bootstrapping WebSockets with
    HTTP/2\"]{.refTitle}, [RFC 8441]{.seriesInfo}, [DOI
    10.17487/RFC8441]{.seriesInfo}, September 2018,
    \<<https://www.rfc-editor.org/info/rfc8441>\>.
:   

\[RFC8740\]
:   [Benjamin, D.]{.refAuthor}, [\"Using TLS 1.3 with
    HTTP/2\"]{.refTitle}, [RFC 8740]{.seriesInfo}, [DOI
    10.17487/RFC8740]{.seriesInfo}, February 2020,
    \<<https://www.rfc-editor.org/info/rfc8740>\>.
:   

\[TALKING\]
:   [Huang, L.]{.refAuthor}, [Chen, E.]{.refAuthor},
    [Barth, A.]{.refAuthor}, [Rescorla, E.]{.refAuthor}, and [C.
    Jackson]{.refAuthor}, [\"Talking to Yourself for Fun and
    Profit\"]{.refTitle}, 2011,
    \<<https://www.adambarth.com/papers/2011/huang-chen-barth-rescorla-jackson.pdf>\>.
:   
:::
:::

::: {#BadCipherSuites}
::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [Prohibited TLS 1.2 Cipher Suites](#name-prohibited-tls-12-cipher-su){.section-name .selfRef} {#name-prohibited-tls-12-cipher-su}

An HTTP/2 implementation [MAY]{.bcp14} treat the negotiation of any of
the following cipher suites with TLS 1.2 as a [connection
error](#ConnectionErrorHandler){.xref} ([Section
5.4.1](#ConnectionErrorHandler){.xref}) of type
[INADEQUATE_SECURITY](#INADEQUATE_SECURITY){.xref}:[¶](#appendix-A-1){.pilcrow}

-   [TLS_NULL_WITH_NULL_NULL[¶](#appendix-A-2.1){.pilcrow}]{#appendix-A-2.1}
-   [TLS_RSA_WITH_NULL_MD5[¶](#appendix-A-2.2){.pilcrow}]{#appendix-A-2.2}
-   [TLS_RSA_WITH_NULL_SHA[¶](#appendix-A-2.3){.pilcrow}]{#appendix-A-2.3}
-   [TLS_RSA_EXPORT_WITH_RC4_40_MD5[¶](#appendix-A-2.4){.pilcrow}]{#appendix-A-2.4}
-   [TLS_RSA_WITH_RC4_128_MD5[¶](#appendix-A-2.5){.pilcrow}]{#appendix-A-2.5}
-   [TLS_RSA_WITH_RC4_128_SHA[¶](#appendix-A-2.6){.pilcrow}]{#appendix-A-2.6}
-   [TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5[¶](#appendix-A-2.7){.pilcrow}]{#appendix-A-2.7}
-   [TLS_RSA_WITH_IDEA_CBC_SHA[¶](#appendix-A-2.8){.pilcrow}]{#appendix-A-2.8}
-   [TLS_RSA_EXPORT_WITH_DES40_CBC_SHA[¶](#appendix-A-2.9){.pilcrow}]{#appendix-A-2.9}
-   [TLS_RSA_WITH_DES_CBC_SHA[¶](#appendix-A-2.10){.pilcrow}]{#appendix-A-2.10}
-   [TLS_RSA_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.11){.pilcrow}]{#appendix-A-2.11}
-   [TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA[¶](#appendix-A-2.12){.pilcrow}]{#appendix-A-2.12}
-   [TLS_DH_DSS_WITH_DES_CBC_SHA[¶](#appendix-A-2.13){.pilcrow}]{#appendix-A-2.13}
-   [TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.14){.pilcrow}]{#appendix-A-2.14}
-   [TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA[¶](#appendix-A-2.15){.pilcrow}]{#appendix-A-2.15}
-   [TLS_DH_RSA_WITH_DES_CBC_SHA[¶](#appendix-A-2.16){.pilcrow}]{#appendix-A-2.16}
-   [TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.17){.pilcrow}]{#appendix-A-2.17}
-   [TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA[¶](#appendix-A-2.18){.pilcrow}]{#appendix-A-2.18}
-   [TLS_DHE_DSS_WITH_DES_CBC_SHA[¶](#appendix-A-2.19){.pilcrow}]{#appendix-A-2.19}
-   [TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.20){.pilcrow}]{#appendix-A-2.20}
-   [TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA[¶](#appendix-A-2.21){.pilcrow}]{#appendix-A-2.21}
-   [TLS_DHE_RSA_WITH_DES_CBC_SHA[¶](#appendix-A-2.22){.pilcrow}]{#appendix-A-2.22}
-   [TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.23){.pilcrow}]{#appendix-A-2.23}
-   [TLS_DH_anon_EXPORT_WITH_RC4_40_MD5[¶](#appendix-A-2.24){.pilcrow}]{#appendix-A-2.24}
-   [TLS_DH_anon_WITH_RC4_128_MD5[¶](#appendix-A-2.25){.pilcrow}]{#appendix-A-2.25}
-   [TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA[¶](#appendix-A-2.26){.pilcrow}]{#appendix-A-2.26}
-   [TLS_DH_anon_WITH_DES_CBC_SHA[¶](#appendix-A-2.27){.pilcrow}]{#appendix-A-2.27}
-   [TLS_DH_anon_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.28){.pilcrow}]{#appendix-A-2.28}
-   [TLS_KRB5_WITH_DES_CBC_SHA[¶](#appendix-A-2.29){.pilcrow}]{#appendix-A-2.29}
-   [TLS_KRB5_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.30){.pilcrow}]{#appendix-A-2.30}
-   [TLS_KRB5_WITH_RC4_128_SHA[¶](#appendix-A-2.31){.pilcrow}]{#appendix-A-2.31}
-   [TLS_KRB5_WITH_IDEA_CBC_SHA[¶](#appendix-A-2.32){.pilcrow}]{#appendix-A-2.32}
-   [TLS_KRB5_WITH_DES_CBC_MD5[¶](#appendix-A-2.33){.pilcrow}]{#appendix-A-2.33}
-   [TLS_KRB5_WITH_3DES_EDE_CBC_MD5[¶](#appendix-A-2.34){.pilcrow}]{#appendix-A-2.34}
-   [TLS_KRB5_WITH_RC4_128_MD5[¶](#appendix-A-2.35){.pilcrow}]{#appendix-A-2.35}
-   [TLS_KRB5_WITH_IDEA_CBC_MD5[¶](#appendix-A-2.36){.pilcrow}]{#appendix-A-2.36}
-   [TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA[¶](#appendix-A-2.37){.pilcrow}]{#appendix-A-2.37}
-   [TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA[¶](#appendix-A-2.38){.pilcrow}]{#appendix-A-2.38}
-   [TLS_KRB5_EXPORT_WITH_RC4_40_SHA[¶](#appendix-A-2.39){.pilcrow}]{#appendix-A-2.39}
-   [TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5[¶](#appendix-A-2.40){.pilcrow}]{#appendix-A-2.40}
-   [TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5[¶](#appendix-A-2.41){.pilcrow}]{#appendix-A-2.41}
-   [TLS_KRB5_EXPORT_WITH_RC4_40_MD5[¶](#appendix-A-2.42){.pilcrow}]{#appendix-A-2.42}
-   [TLS_PSK_WITH_NULL_SHA[¶](#appendix-A-2.43){.pilcrow}]{#appendix-A-2.43}
-   [TLS_DHE_PSK_WITH_NULL_SHA[¶](#appendix-A-2.44){.pilcrow}]{#appendix-A-2.44}
-   [TLS_RSA_PSK_WITH_NULL_SHA[¶](#appendix-A-2.45){.pilcrow}]{#appendix-A-2.45}
-   [TLS_RSA_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.46){.pilcrow}]{#appendix-A-2.46}
-   [TLS_DH_DSS_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.47){.pilcrow}]{#appendix-A-2.47}
-   [TLS_DH_RSA_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.48){.pilcrow}]{#appendix-A-2.48}
-   [TLS_DHE_DSS_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.49){.pilcrow}]{#appendix-A-2.49}
-   [TLS_DHE_RSA_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.50){.pilcrow}]{#appendix-A-2.50}
-   [TLS_DH_anon_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.51){.pilcrow}]{#appendix-A-2.51}
-   [TLS_RSA_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.52){.pilcrow}]{#appendix-A-2.52}
-   [TLS_DH_DSS_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.53){.pilcrow}]{#appendix-A-2.53}
-   [TLS_DH_RSA_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.54){.pilcrow}]{#appendix-A-2.54}
-   [TLS_DHE_DSS_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.55){.pilcrow}]{#appendix-A-2.55}
-   [TLS_DHE_RSA_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.56){.pilcrow}]{#appendix-A-2.56}
-   [TLS_DH_anon_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.57){.pilcrow}]{#appendix-A-2.57}
-   [TLS_RSA_WITH_NULL_SHA256[¶](#appendix-A-2.58){.pilcrow}]{#appendix-A-2.58}
-   [TLS_RSA_WITH_AES_128_CBC_SHA256[¶](#appendix-A-2.59){.pilcrow}]{#appendix-A-2.59}
-   [TLS_RSA_WITH_AES_256_CBC_SHA256[¶](#appendix-A-2.60){.pilcrow}]{#appendix-A-2.60}
-   [TLS_DH_DSS_WITH_AES_128_CBC_SHA256[¶](#appendix-A-2.61){.pilcrow}]{#appendix-A-2.61}
-   [TLS_DH_RSA_WITH_AES_128_CBC_SHA256[¶](#appendix-A-2.62){.pilcrow}]{#appendix-A-2.62}
-   [TLS_DHE_DSS_WITH_AES_128_CBC_SHA256[¶](#appendix-A-2.63){.pilcrow}]{#appendix-A-2.63}
-   [TLS_RSA_WITH_CAMELLIA_128_CBC_SHA[¶](#appendix-A-2.64){.pilcrow}]{#appendix-A-2.64}
-   [TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA[¶](#appendix-A-2.65){.pilcrow}]{#appendix-A-2.65}
-   [TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA[¶](#appendix-A-2.66){.pilcrow}]{#appendix-A-2.66}
-   [TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA[¶](#appendix-A-2.67){.pilcrow}]{#appendix-A-2.67}
-   [TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA[¶](#appendix-A-2.68){.pilcrow}]{#appendix-A-2.68}
-   [TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA[¶](#appendix-A-2.69){.pilcrow}]{#appendix-A-2.69}
-   [TLS_DHE_RSA_WITH_AES_128_CBC_SHA256[¶](#appendix-A-2.70){.pilcrow}]{#appendix-A-2.70}
-   [TLS_DH_DSS_WITH_AES_256_CBC_SHA256[¶](#appendix-A-2.71){.pilcrow}]{#appendix-A-2.71}
-   [TLS_DH_RSA_WITH_AES_256_CBC_SHA256[¶](#appendix-A-2.72){.pilcrow}]{#appendix-A-2.72}
-   [TLS_DHE_DSS_WITH_AES_256_CBC_SHA256[¶](#appendix-A-2.73){.pilcrow}]{#appendix-A-2.73}
-   [TLS_DHE_RSA_WITH_AES_256_CBC_SHA256[¶](#appendix-A-2.74){.pilcrow}]{#appendix-A-2.74}
-   [TLS_DH_anon_WITH_AES_128_CBC_SHA256[¶](#appendix-A-2.75){.pilcrow}]{#appendix-A-2.75}
-   [TLS_DH_anon_WITH_AES_256_CBC_SHA256[¶](#appendix-A-2.76){.pilcrow}]{#appendix-A-2.76}
-   [TLS_RSA_WITH_CAMELLIA_256_CBC_SHA[¶](#appendix-A-2.77){.pilcrow}]{#appendix-A-2.77}
-   [TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA[¶](#appendix-A-2.78){.pilcrow}]{#appendix-A-2.78}
-   [TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA[¶](#appendix-A-2.79){.pilcrow}]{#appendix-A-2.79}
-   [TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA[¶](#appendix-A-2.80){.pilcrow}]{#appendix-A-2.80}
-   [TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA[¶](#appendix-A-2.81){.pilcrow}]{#appendix-A-2.81}
-   [TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA[¶](#appendix-A-2.82){.pilcrow}]{#appendix-A-2.82}
-   [TLS_PSK_WITH_RC4_128_SHA[¶](#appendix-A-2.83){.pilcrow}]{#appendix-A-2.83}
-   [TLS_PSK_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.84){.pilcrow}]{#appendix-A-2.84}
-   [TLS_PSK_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.85){.pilcrow}]{#appendix-A-2.85}
-   [TLS_PSK_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.86){.pilcrow}]{#appendix-A-2.86}
-   [TLS_DHE_PSK_WITH_RC4_128_SHA[¶](#appendix-A-2.87){.pilcrow}]{#appendix-A-2.87}
-   [TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.88){.pilcrow}]{#appendix-A-2.88}
-   [TLS_DHE_PSK_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.89){.pilcrow}]{#appendix-A-2.89}
-   [TLS_DHE_PSK_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.90){.pilcrow}]{#appendix-A-2.90}
-   [TLS_RSA_PSK_WITH_RC4_128_SHA[¶](#appendix-A-2.91){.pilcrow}]{#appendix-A-2.91}
-   [TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.92){.pilcrow}]{#appendix-A-2.92}
-   [TLS_RSA_PSK_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.93){.pilcrow}]{#appendix-A-2.93}
-   [TLS_RSA_PSK_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.94){.pilcrow}]{#appendix-A-2.94}
-   [TLS_RSA_WITH_SEED_CBC_SHA[¶](#appendix-A-2.95){.pilcrow}]{#appendix-A-2.95}
-   [TLS_DH_DSS_WITH_SEED_CBC_SHA[¶](#appendix-A-2.96){.pilcrow}]{#appendix-A-2.96}
-   [TLS_DH_RSA_WITH_SEED_CBC_SHA[¶](#appendix-A-2.97){.pilcrow}]{#appendix-A-2.97}
-   [TLS_DHE_DSS_WITH_SEED_CBC_SHA[¶](#appendix-A-2.98){.pilcrow}]{#appendix-A-2.98}
-   [TLS_DHE_RSA_WITH_SEED_CBC_SHA[¶](#appendix-A-2.99){.pilcrow}]{#appendix-A-2.99}
-   [TLS_DH_anon_WITH_SEED_CBC_SHA[¶](#appendix-A-2.100){.pilcrow}]{#appendix-A-2.100}
-   [TLS_RSA_WITH_AES_128_GCM_SHA256[¶](#appendix-A-2.101){.pilcrow}]{#appendix-A-2.101}
-   [TLS_RSA_WITH_AES_256_GCM_SHA384[¶](#appendix-A-2.102){.pilcrow}]{#appendix-A-2.102}
-   [TLS_DH_RSA_WITH_AES_128_GCM_SHA256[¶](#appendix-A-2.103){.pilcrow}]{#appendix-A-2.103}
-   [TLS_DH_RSA_WITH_AES_256_GCM_SHA384[¶](#appendix-A-2.104){.pilcrow}]{#appendix-A-2.104}
-   [TLS_DH_DSS_WITH_AES_128_GCM_SHA256[¶](#appendix-A-2.105){.pilcrow}]{#appendix-A-2.105}
-   [TLS_DH_DSS_WITH_AES_256_GCM_SHA384[¶](#appendix-A-2.106){.pilcrow}]{#appendix-A-2.106}
-   [TLS_DH_anon_WITH_AES_128_GCM_SHA256[¶](#appendix-A-2.107){.pilcrow}]{#appendix-A-2.107}
-   [TLS_DH_anon_WITH_AES_256_GCM_SHA384[¶](#appendix-A-2.108){.pilcrow}]{#appendix-A-2.108}
-   [TLS_PSK_WITH_AES_128_GCM_SHA256[¶](#appendix-A-2.109){.pilcrow}]{#appendix-A-2.109}
-   [TLS_PSK_WITH_AES_256_GCM_SHA384[¶](#appendix-A-2.110){.pilcrow}]{#appendix-A-2.110}
-   [TLS_RSA_PSK_WITH_AES_128_GCM_SHA256[¶](#appendix-A-2.111){.pilcrow}]{#appendix-A-2.111}
-   [TLS_RSA_PSK_WITH_AES_256_GCM_SHA384[¶](#appendix-A-2.112){.pilcrow}]{#appendix-A-2.112}
-   [TLS_PSK_WITH_AES_128_CBC_SHA256[¶](#appendix-A-2.113){.pilcrow}]{#appendix-A-2.113}
-   [TLS_PSK_WITH_AES_256_CBC_SHA384[¶](#appendix-A-2.114){.pilcrow}]{#appendix-A-2.114}
-   [TLS_PSK_WITH_NULL_SHA256[¶](#appendix-A-2.115){.pilcrow}]{#appendix-A-2.115}
-   [TLS_PSK_WITH_NULL_SHA384[¶](#appendix-A-2.116){.pilcrow}]{#appendix-A-2.116}
-   [TLS_DHE_PSK_WITH_AES_128_CBC_SHA256[¶](#appendix-A-2.117){.pilcrow}]{#appendix-A-2.117}
-   [TLS_DHE_PSK_WITH_AES_256_CBC_SHA384[¶](#appendix-A-2.118){.pilcrow}]{#appendix-A-2.118}
-   [TLS_DHE_PSK_WITH_NULL_SHA256[¶](#appendix-A-2.119){.pilcrow}]{#appendix-A-2.119}
-   [TLS_DHE_PSK_WITH_NULL_SHA384[¶](#appendix-A-2.120){.pilcrow}]{#appendix-A-2.120}
-   [TLS_RSA_PSK_WITH_AES_128_CBC_SHA256[¶](#appendix-A-2.121){.pilcrow}]{#appendix-A-2.121}
-   [TLS_RSA_PSK_WITH_AES_256_CBC_SHA384[¶](#appendix-A-2.122){.pilcrow}]{#appendix-A-2.122}
-   [TLS_RSA_PSK_WITH_NULL_SHA256[¶](#appendix-A-2.123){.pilcrow}]{#appendix-A-2.123}
-   [TLS_RSA_PSK_WITH_NULL_SHA384[¶](#appendix-A-2.124){.pilcrow}]{#appendix-A-2.124}
-   [TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256[¶](#appendix-A-2.125){.pilcrow}]{#appendix-A-2.125}
-   [TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256[¶](#appendix-A-2.126){.pilcrow}]{#appendix-A-2.126}
-   [TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256[¶](#appendix-A-2.127){.pilcrow}]{#appendix-A-2.127}
-   [TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256[¶](#appendix-A-2.128){.pilcrow}]{#appendix-A-2.128}
-   [TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256[¶](#appendix-A-2.129){.pilcrow}]{#appendix-A-2.129}
-   [TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256[¶](#appendix-A-2.130){.pilcrow}]{#appendix-A-2.130}
-   [TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256[¶](#appendix-A-2.131){.pilcrow}]{#appendix-A-2.131}
-   [TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256[¶](#appendix-A-2.132){.pilcrow}]{#appendix-A-2.132}
-   [TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256[¶](#appendix-A-2.133){.pilcrow}]{#appendix-A-2.133}
-   [TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256[¶](#appendix-A-2.134){.pilcrow}]{#appendix-A-2.134}
-   [TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256[¶](#appendix-A-2.135){.pilcrow}]{#appendix-A-2.135}
-   [TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256[¶](#appendix-A-2.136){.pilcrow}]{#appendix-A-2.136}
-   [TLS_EMPTY_RENEGOTIATION_INFO_SCSV[¶](#appendix-A-2.137){.pilcrow}]{#appendix-A-2.137}
-   [TLS_ECDH_ECDSA_WITH_NULL_SHA[¶](#appendix-A-2.138){.pilcrow}]{#appendix-A-2.138}
-   [TLS_ECDH_ECDSA_WITH_RC4_128_SHA[¶](#appendix-A-2.139){.pilcrow}]{#appendix-A-2.139}
-   [TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.140){.pilcrow}]{#appendix-A-2.140}
-   [TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.141){.pilcrow}]{#appendix-A-2.141}
-   [TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.142){.pilcrow}]{#appendix-A-2.142}
-   [TLS_ECDHE_ECDSA_WITH_NULL_SHA[¶](#appendix-A-2.143){.pilcrow}]{#appendix-A-2.143}
-   [TLS_ECDHE_ECDSA_WITH_RC4_128_SHA[¶](#appendix-A-2.144){.pilcrow}]{#appendix-A-2.144}
-   [TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.145){.pilcrow}]{#appendix-A-2.145}
-   [TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.146){.pilcrow}]{#appendix-A-2.146}
-   [TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.147){.pilcrow}]{#appendix-A-2.147}
-   [TLS_ECDH_RSA_WITH_NULL_SHA[¶](#appendix-A-2.148){.pilcrow}]{#appendix-A-2.148}
-   [TLS_ECDH_RSA_WITH_RC4_128_SHA[¶](#appendix-A-2.149){.pilcrow}]{#appendix-A-2.149}
-   [TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.150){.pilcrow}]{#appendix-A-2.150}
-   [TLS_ECDH_RSA_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.151){.pilcrow}]{#appendix-A-2.151}
-   [TLS_ECDH_RSA_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.152){.pilcrow}]{#appendix-A-2.152}
-   [TLS_ECDHE_RSA_WITH_NULL_SHA[¶](#appendix-A-2.153){.pilcrow}]{#appendix-A-2.153}
-   [TLS_ECDHE_RSA_WITH_RC4_128_SHA[¶](#appendix-A-2.154){.pilcrow}]{#appendix-A-2.154}
-   [TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.155){.pilcrow}]{#appendix-A-2.155}
-   [TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.156){.pilcrow}]{#appendix-A-2.156}
-   [TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.157){.pilcrow}]{#appendix-A-2.157}
-   [TLS_ECDH_anon_WITH_NULL_SHA[¶](#appendix-A-2.158){.pilcrow}]{#appendix-A-2.158}
-   [TLS_ECDH_anon_WITH_RC4_128_SHA[¶](#appendix-A-2.159){.pilcrow}]{#appendix-A-2.159}
-   [TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.160){.pilcrow}]{#appendix-A-2.160}
-   [TLS_ECDH_anon_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.161){.pilcrow}]{#appendix-A-2.161}
-   [TLS_ECDH_anon_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.162){.pilcrow}]{#appendix-A-2.162}
-   [TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.163){.pilcrow}]{#appendix-A-2.163}
-   [TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.164){.pilcrow}]{#appendix-A-2.164}
-   [TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.165){.pilcrow}]{#appendix-A-2.165}
-   [TLS_SRP_SHA_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.166){.pilcrow}]{#appendix-A-2.166}
-   [TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.167){.pilcrow}]{#appendix-A-2.167}
-   [TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.168){.pilcrow}]{#appendix-A-2.168}
-   [TLS_SRP_SHA_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.169){.pilcrow}]{#appendix-A-2.169}
-   [TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.170){.pilcrow}]{#appendix-A-2.170}
-   [TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.171){.pilcrow}]{#appendix-A-2.171}
-   [TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256[¶](#appendix-A-2.172){.pilcrow}]{#appendix-A-2.172}
-   [TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384[¶](#appendix-A-2.173){.pilcrow}]{#appendix-A-2.173}
-   [TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256[¶](#appendix-A-2.174){.pilcrow}]{#appendix-A-2.174}
-   [TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384[¶](#appendix-A-2.175){.pilcrow}]{#appendix-A-2.175}
-   [TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256[¶](#appendix-A-2.176){.pilcrow}]{#appendix-A-2.176}
-   [TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384[¶](#appendix-A-2.177){.pilcrow}]{#appendix-A-2.177}
-   [TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256[¶](#appendix-A-2.178){.pilcrow}]{#appendix-A-2.178}
-   [TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384[¶](#appendix-A-2.179){.pilcrow}]{#appendix-A-2.179}
-   [TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256[¶](#appendix-A-2.180){.pilcrow}]{#appendix-A-2.180}
-   [TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384[¶](#appendix-A-2.181){.pilcrow}]{#appendix-A-2.181}
-   [TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256[¶](#appendix-A-2.182){.pilcrow}]{#appendix-A-2.182}
-   [TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384[¶](#appendix-A-2.183){.pilcrow}]{#appendix-A-2.183}
-   [TLS_ECDHE_PSK_WITH_RC4_128_SHA[¶](#appendix-A-2.184){.pilcrow}]{#appendix-A-2.184}
-   [TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA[¶](#appendix-A-2.185){.pilcrow}]{#appendix-A-2.185}
-   [TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA[¶](#appendix-A-2.186){.pilcrow}]{#appendix-A-2.186}
-   [TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA[¶](#appendix-A-2.187){.pilcrow}]{#appendix-A-2.187}
-   [TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256[¶](#appendix-A-2.188){.pilcrow}]{#appendix-A-2.188}
-   [TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384[¶](#appendix-A-2.189){.pilcrow}]{#appendix-A-2.189}
-   [TLS_ECDHE_PSK_WITH_NULL_SHA[¶](#appendix-A-2.190){.pilcrow}]{#appendix-A-2.190}
-   [TLS_ECDHE_PSK_WITH_NULL_SHA256[¶](#appendix-A-2.191){.pilcrow}]{#appendix-A-2.191}
-   [TLS_ECDHE_PSK_WITH_NULL_SHA384[¶](#appendix-A-2.192){.pilcrow}]{#appendix-A-2.192}
-   [TLS_RSA_WITH_ARIA_128_CBC_SHA256[¶](#appendix-A-2.193){.pilcrow}]{#appendix-A-2.193}
-   [TLS_RSA_WITH_ARIA_256_CBC_SHA384[¶](#appendix-A-2.194){.pilcrow}]{#appendix-A-2.194}
-   [TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256[¶](#appendix-A-2.195){.pilcrow}]{#appendix-A-2.195}
-   [TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384[¶](#appendix-A-2.196){.pilcrow}]{#appendix-A-2.196}
-   [TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256[¶](#appendix-A-2.197){.pilcrow}]{#appendix-A-2.197}
-   [TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384[¶](#appendix-A-2.198){.pilcrow}]{#appendix-A-2.198}
-   [TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256[¶](#appendix-A-2.199){.pilcrow}]{#appendix-A-2.199}
-   [TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384[¶](#appendix-A-2.200){.pilcrow}]{#appendix-A-2.200}
-   [TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256[¶](#appendix-A-2.201){.pilcrow}]{#appendix-A-2.201}
-   [TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384[¶](#appendix-A-2.202){.pilcrow}]{#appendix-A-2.202}
-   [TLS_DH_anon_WITH_ARIA_128_CBC_SHA256[¶](#appendix-A-2.203){.pilcrow}]{#appendix-A-2.203}
-   [TLS_DH_anon_WITH_ARIA_256_CBC_SHA384[¶](#appendix-A-2.204){.pilcrow}]{#appendix-A-2.204}
-   [TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256[¶](#appendix-A-2.205){.pilcrow}]{#appendix-A-2.205}
-   [TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384[¶](#appendix-A-2.206){.pilcrow}]{#appendix-A-2.206}
-   [TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256[¶](#appendix-A-2.207){.pilcrow}]{#appendix-A-2.207}
-   [TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384[¶](#appendix-A-2.208){.pilcrow}]{#appendix-A-2.208}
-   [TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256[¶](#appendix-A-2.209){.pilcrow}]{#appendix-A-2.209}
-   [TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384[¶](#appendix-A-2.210){.pilcrow}]{#appendix-A-2.210}
-   [TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256[¶](#appendix-A-2.211){.pilcrow}]{#appendix-A-2.211}
-   [TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384[¶](#appendix-A-2.212){.pilcrow}]{#appendix-A-2.212}
-   [TLS_RSA_WITH_ARIA_128_GCM_SHA256[¶](#appendix-A-2.213){.pilcrow}]{#appendix-A-2.213}
-   [TLS_RSA_WITH_ARIA_256_GCM_SHA384[¶](#appendix-A-2.214){.pilcrow}]{#appendix-A-2.214}
-   [TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256[¶](#appendix-A-2.215){.pilcrow}]{#appendix-A-2.215}
-   [TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384[¶](#appendix-A-2.216){.pilcrow}]{#appendix-A-2.216}
-   [TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256[¶](#appendix-A-2.217){.pilcrow}]{#appendix-A-2.217}
-   [TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384[¶](#appendix-A-2.218){.pilcrow}]{#appendix-A-2.218}
-   [TLS_DH_anon_WITH_ARIA_128_GCM_SHA256[¶](#appendix-A-2.219){.pilcrow}]{#appendix-A-2.219}
-   [TLS_DH_anon_WITH_ARIA_256_GCM_SHA384[¶](#appendix-A-2.220){.pilcrow}]{#appendix-A-2.220}
-   [TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256[¶](#appendix-A-2.221){.pilcrow}]{#appendix-A-2.221}
-   [TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384[¶](#appendix-A-2.222){.pilcrow}]{#appendix-A-2.222}
-   [TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256[¶](#appendix-A-2.223){.pilcrow}]{#appendix-A-2.223}
-   [TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384[¶](#appendix-A-2.224){.pilcrow}]{#appendix-A-2.224}
-   [TLS_PSK_WITH_ARIA_128_CBC_SHA256[¶](#appendix-A-2.225){.pilcrow}]{#appendix-A-2.225}
-   [TLS_PSK_WITH_ARIA_256_CBC_SHA384[¶](#appendix-A-2.226){.pilcrow}]{#appendix-A-2.226}
-   [TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256[¶](#appendix-A-2.227){.pilcrow}]{#appendix-A-2.227}
-   [TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384[¶](#appendix-A-2.228){.pilcrow}]{#appendix-A-2.228}
-   [TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256[¶](#appendix-A-2.229){.pilcrow}]{#appendix-A-2.229}
-   [TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384[¶](#appendix-A-2.230){.pilcrow}]{#appendix-A-2.230}
-   [TLS_PSK_WITH_ARIA_128_GCM_SHA256[¶](#appendix-A-2.231){.pilcrow}]{#appendix-A-2.231}
-   [TLS_PSK_WITH_ARIA_256_GCM_SHA384[¶](#appendix-A-2.232){.pilcrow}]{#appendix-A-2.232}
-   [TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256[¶](#appendix-A-2.233){.pilcrow}]{#appendix-A-2.233}
-   [TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384[¶](#appendix-A-2.234){.pilcrow}]{#appendix-A-2.234}
-   [TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256[¶](#appendix-A-2.235){.pilcrow}]{#appendix-A-2.235}
-   [TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384[¶](#appendix-A-2.236){.pilcrow}]{#appendix-A-2.236}
-   [TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256[¶](#appendix-A-2.237){.pilcrow}]{#appendix-A-2.237}
-   [TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384[¶](#appendix-A-2.238){.pilcrow}]{#appendix-A-2.238}
-   [TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256[¶](#appendix-A-2.239){.pilcrow}]{#appendix-A-2.239}
-   [TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384[¶](#appendix-A-2.240){.pilcrow}]{#appendix-A-2.240}
-   [TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256[¶](#appendix-A-2.241){.pilcrow}]{#appendix-A-2.241}
-   [TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384[¶](#appendix-A-2.242){.pilcrow}]{#appendix-A-2.242}
-   [TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256[¶](#appendix-A-2.243){.pilcrow}]{#appendix-A-2.243}
-   [TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384[¶](#appendix-A-2.244){.pilcrow}]{#appendix-A-2.244}
-   [TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256[¶](#appendix-A-2.245){.pilcrow}]{#appendix-A-2.245}
-   [TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384[¶](#appendix-A-2.246){.pilcrow}]{#appendix-A-2.246}
-   [TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256[¶](#appendix-A-2.247){.pilcrow}]{#appendix-A-2.247}
-   [TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384[¶](#appendix-A-2.248){.pilcrow}]{#appendix-A-2.248}
-   [TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256[¶](#appendix-A-2.249){.pilcrow}]{#appendix-A-2.249}
-   [TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384[¶](#appendix-A-2.250){.pilcrow}]{#appendix-A-2.250}
-   [TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256[¶](#appendix-A-2.251){.pilcrow}]{#appendix-A-2.251}
-   [TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384[¶](#appendix-A-2.252){.pilcrow}]{#appendix-A-2.252}
-   [TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256[¶](#appendix-A-2.253){.pilcrow}]{#appendix-A-2.253}
-   [TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384[¶](#appendix-A-2.254){.pilcrow}]{#appendix-A-2.254}
-   [TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256[¶](#appendix-A-2.255){.pilcrow}]{#appendix-A-2.255}
-   [TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384[¶](#appendix-A-2.256){.pilcrow}]{#appendix-A-2.256}
-   [TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256[¶](#appendix-A-2.257){.pilcrow}]{#appendix-A-2.257}
-   [TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384[¶](#appendix-A-2.258){.pilcrow}]{#appendix-A-2.258}
-   [TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256[¶](#appendix-A-2.259){.pilcrow}]{#appendix-A-2.259}
-   [TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384[¶](#appendix-A-2.260){.pilcrow}]{#appendix-A-2.260}
-   [TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256[¶](#appendix-A-2.261){.pilcrow}]{#appendix-A-2.261}
-   [TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384[¶](#appendix-A-2.262){.pilcrow}]{#appendix-A-2.262}
-   [TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256[¶](#appendix-A-2.263){.pilcrow}]{#appendix-A-2.263}
-   [TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384[¶](#appendix-A-2.264){.pilcrow}]{#appendix-A-2.264}
-   [TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256[¶](#appendix-A-2.265){.pilcrow}]{#appendix-A-2.265}
-   [TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384[¶](#appendix-A-2.266){.pilcrow}]{#appendix-A-2.266}
-   [TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256[¶](#appendix-A-2.267){.pilcrow}]{#appendix-A-2.267}
-   [TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384[¶](#appendix-A-2.268){.pilcrow}]{#appendix-A-2.268}
-   [TLS_RSA_WITH_AES_128_CCM[¶](#appendix-A-2.269){.pilcrow}]{#appendix-A-2.269}
-   [TLS_RSA_WITH_AES_256_CCM[¶](#appendix-A-2.270){.pilcrow}]{#appendix-A-2.270}
-   [TLS_RSA_WITH_AES_128_CCM_8[¶](#appendix-A-2.271){.pilcrow}]{#appendix-A-2.271}
-   [TLS_RSA_WITH_AES_256_CCM_8[¶](#appendix-A-2.272){.pilcrow}]{#appendix-A-2.272}
-   [TLS_PSK_WITH_AES_128_CCM[¶](#appendix-A-2.273){.pilcrow}]{#appendix-A-2.273}
-   [TLS_PSK_WITH_AES_256_CCM[¶](#appendix-A-2.274){.pilcrow}]{#appendix-A-2.274}
-   [TLS_PSK_WITH_AES_128_CCM_8[¶](#appendix-A-2.275){.pilcrow}]{#appendix-A-2.275}
-   [TLS_PSK_WITH_AES_256_CCM_8[¶](#appendix-A-2.276){.pilcrow}]{#appendix-A-2.276}

Note: This list was assembled from the set of registered TLS cipher
suites when \[[RFC7540](#RFC7540){.xref}\] was developed. This list
includes those cipher suites that do not offer an ephemeral key exchange
and those that are based on the TLS null, stream, or block cipher type
(as defined in [Section
6.2.3](https://www.rfc-editor.org/rfc/rfc5246#section-6.2.3){.relref} of
\[[TLS12](#RFC5246){.xref}\]). Additional cipher suites with these
properties could be defined; these would not be explicitly
prohibited.[¶](#appendix-A-3.1){.pilcrow}

For more details, see [Section
9.2.2](#tls12ciphers){.xref}.[¶](#appendix-A-4){.pilcrow}
:::
:::

::: {#revision-updates}
::: {#appendix-B .section}
## [Appendix B.](#appendix-B){.section-number .selfRef} [Changes from RFC 7540](#name-changes-from-rfc-7540){.section-name .selfRef} {#name-changes-from-rfc-7540}

This revision includes the following substantive
changes:[¶](#appendix-B-1){.pilcrow}

-   [Use of TLS 1.3 was defined based on \[[RFC8740](#RFC8740){.xref}\],
    which this document
    obsoletes.[¶](#appendix-B-2.1){.pilcrow}]{#appendix-B-2.1}
-   [The priority scheme defined in RFC 7540 is deprecated. Definitions
    for the format of the [PRIORITY](#PRIORITY){.xref} frame and the
    priority fields in the [HEADERS](#HEADERS){.xref} frame have been
    retained, plus the rules governing when [PRIORITY](#PRIORITY){.xref}
    frames can be sent and received, but the semantics of these fields
    are only described in RFC 7540. The priority signaling scheme from
    RFC 7540 was not successful. Using the simpler signaling in
    \[[HTTP-PRIORITY](#RFC9218){.xref}\] is
    recommended.[¶](#appendix-B-2.2){.pilcrow}]{#appendix-B-2.2}
-   [The HTTP/1.1 Upgrade mechanism is deprecated and no longer
    specified in this document. It was never widely deployed, with
    plaintext HTTP/2 users choosing to use the prior-knowledge
    implementation
    instead.[¶](#appendix-B-2.3){.pilcrow}]{#appendix-B-2.3}
-   [Validation for field names and values has been narrowed. The
    validation that is mandatory for intermediaries is precisely
    defined, and error reporting for requests has been amended to
    encourage sending 400-series status
    codes.[¶](#appendix-B-2.4){.pilcrow}]{#appendix-B-2.4}
-   [The ranges of codepoints for settings and frame types that were
    reserved for Experimental Use are now available for general
    use.[¶](#appendix-B-2.5){.pilcrow}]{#appendix-B-2.5}
-   [Connection-specific header fields \-- which are prohibited \-- are
    more precisely and comprehensively
    identified.[¶](#appendix-B-2.6){.pilcrow}]{#appendix-B-2.6}
-   [`Host` and \"`:authority`\" are no longer permitted to
    disagree.[¶](#appendix-B-2.7){.pilcrow}]{#appendix-B-2.7}
-   [Rules for sending Dynamic Table Size Update instructions after
    changes in settings have been clarified in [Section
    4.3.1](#dynamic-table){.xref}.[¶](#appendix-B-2.8){.pilcrow}]{#appendix-B-2.8}

Editorial changes are also included. In particular, changes to
terminology and document structure are in response to updates to [core
HTTP semantics](#RFC9110){.xref} \[[HTTP](#RFC9110){.xref}\]. Those
documents now include some concepts that were first defined in RFC 7540,
such as the 421 status code or connection
coalescing.[¶](#appendix-B-3){.pilcrow}
:::
:::

::: {#appendix-C .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

Credit for non-trivial input to this document is owed to a large number
of people who have contributed to the HTTP Working Group over the years.
\[[RFC7540](#RFC7540){.xref}\] contains a more extensive list of people
that deserve acknowledgment for their
contributions.[¶](#appendix-C-1){.pilcrow}
:::

::: {#appendix-D .section}
## [Contributors](#name-contributors){.section-name .selfRef} {#name-contributors}

[Mike Belshe]{.contact-name} and [Roberto Peon]{.contact-name} authored
the text that this document is based on.[¶](#appendix-D-1){.pilcrow}
:::

::: {#authors-addresses}
::: {#appendix-E .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Martin Thomson ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Mozilla]{.org}
:::

::: {.left dir="auto"}
[Australia]{.country-name}
:::

::: email
Email: <mt@lowentropy.net>
:::

::: {.left dir="auto"}
[Cory Benfield ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Apple Inc.]{.org}
:::

::: email
Email: <cbenfield@apple.com>
:::
:::
:::
