  RFC 8974              Extended Tokens in CoAP   January 2021
  --------------------- ------------------------- --------------
  Hartke & Richardson   Standards Track           \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8974](https://www.rfc-editor.org/rfc/rfc8974){.eref}

Updates:
:   [7252](https://www.rfc-editor.org/rfc/rfc7252){.eref},
    [8323](https://www.rfc-editor.org/rfc/rfc8323){.eref}

Category:
:   Standards Track

Published:
:   January 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    K. Hartke
    :::

    ::: org
    Ericsson
    :::
    :::

    ::: author
    ::: author-name
    M. Richardson
    :::

    ::: org
    Sandelman
    :::
    :::
:::

# RFC 8974 {#rfcnum}

# Extended Tokens and Stateless Clients in the Constrained Application Protocol (CoAP) {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document provides considerations for alleviating Constrained
Application Protocol (CoAP) clients and intermediaries of keeping
per-request state. To facilitate this, this document additionally
introduces a new, optional CoAP protocol extension for extended token
lengths.[¶](#section-abstract-1){.pilcrow}

This document updates RFCs 7252 and 8323 with an extended definition of
the \"TKL\" field in the CoAP message
header.[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8974>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.1.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Extended
    Tokens](#name-extended-tokens){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Extended Token Length (TKL)
        Field](#name-extended-token-length-tkl-f){.xref}[¶](#section-toc.1-1.2.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [Discovering
        Support](#name-discovering-support){.xref}[¶](#section-toc.1-1.2.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.2.2.2.2.1}
            [2.2.1](#section-2.2.1){.xref}.  [Extended-Token-Length
            Capability
            Option](#name-extended-token-length-capab){.xref}[¶](#section-toc.1-1.2.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.2.2.2.2.2}
            [2.2.2](#section-2.2.2){.xref}.  [Trial and
            Error](#name-trial-and-error){.xref}[¶](#section-toc.1-1.2.2.2.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.2.2.3}
        [2.3](#section-2.3){.xref}.  [Intermediaries](#name-intermediaries){.xref}[¶](#section-toc.1-1.2.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Stateless
    Clients](#name-stateless-clients){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Serializing Client
        State](#name-serializing-client-state){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Using Extended
        Tokens](#name-using-extended-tokens){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Transmitting
        Messages](#name-transmitting-messages){.xref}[¶](#section-toc.1-1.3.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Stateless
    Intermediaries](#name-stateless-intermediaries){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Observing
        Resources](#name-observing-resources){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Block-Wise
        Transfers](#name-block-wise-transfers){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Gateway
        Timeouts](#name-gateway-timeouts){.xref}[¶](#section-toc.1-1.4.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Extended
        Tokens](#name-extended-tokens-2){.xref}[¶](#section-toc.1-1.4.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Extended
        Tokens](#name-extended-tokens-3){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Stateless Clients and
        Intermediaries](#name-stateless-clients-and-inter){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [CoAP Signaling Option
        Number](#name-coap-signaling-option-numbe){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [References](#name-references){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [Appendix A](#section-appendix.a){.xref}.  [Updated Message
    Formats](#name-updated-message-formats){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}

    -   ::: {#section-toc.1-1.8.2.1}
        [A.1](#section-a.1){.xref}.  [CoAP over
        UDP](#name-coap-over-udp){.xref}[¶](#section-toc.1-1.8.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [A.2](#section-a.2){.xref}.  [CoAP over
        TCP/TLS](#name-coap-over-tcp-tls){.xref}[¶](#section-toc.1-1.8.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [A.3](#section-a.3){.xref}.  [CoAP over
        WebSockets](#name-coap-over-websockets){.xref}[¶](#section-toc.1-1.8.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [](#section-appendix.b){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [](#section-appendix.c){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The Constrained Application Protocol (CoAP)
\[[RFC7252](#RFC7252){.xref}\] is a RESTful application-layer protocol
for [constrained environments](#RFC7228){.xref}
\[[RFC7228](#RFC7228){.xref}\]. In CoAP, clients (or intermediaries in
the client role) make requests to servers (or intermediaries in the
server role), which satisfy the requests by returning
responses.[¶](#section-1-1){.pilcrow}

While a request is ongoing, a client typically needs to keep some state
that it requires for processing the response when that arrives.
Identification of this state is done in CoAP by means of a token: an
opaque sequence of bytes that is chosen by the client and included in
the CoAP request and that is returned by the server verbatim in any
resulting CoAP response ([Figure
1](#stateful-exchange){.xref}).[¶](#section-1-2){.pilcrow}

[]{#name-token-as-an-identifier-for-}

::: {#stateful-exchange}
::: {#section-1-3.1 .artwork .art-text .alignCenter}
    +-----------------+     request with     +------------+
    |        |        |   state identifier   |            |
    |        |        |       as token       |            |
    |    .-<-+->------|--------------------->|------.     |
    |   _|_           |                      |      |     |
    |  /   \ stored   |                      |      |     |
    |  \___/ state    |                      |      |     |
    |    |            |                      |      |     |
    |    '->-+-<------|<---------------------|------'     |
    |        |        |     response with    |            |
    |        v        |   token echoed back  |            |
    +-----------------+                      +------------+
          Client                                 Server
:::

[Figure 1](#figure-1){.selfRef}: [Token as an Identifier for Request
State](#name-token-as-an-identifier-for-){.selfRef}
:::

In some scenarios, it can be beneficial to reduce the amount of state
that is stored at the client at the cost of increased message sizes. A
client can opt into this by serializing (parts of) its state into the
token itself and then recovering this state from the token in the
response ([Figure
2](#stateless-exchange){.xref}).[¶](#section-1-4){.pilcrow}

[]{#name-token-as-serialization-of-r}

::: {#stateless-exchange}
::: {#section-1-5.1 .artwork .art-text .alignCenter}
    +-----------------+     request with     +------------+
    |        |        |   serialized state   |            |
    |        |        |       as token       |            |
    |        +--------|=====================>|------.     |
    |                 |                      |      |     |
    |    look ma,     |                      |      |     |
    |    no state!    |                      |      |     |
    |                 |                      |      |     |
    |        +--------|<=====================|------'     |
    |        |        |     response with    |            |
    |        v        |   token echoed back  |            |
    +-----------------+                      +------------+
          Client                                 Server
:::

[Figure 2](#figure-2){.selfRef}: [Token as Serialization of Request
State](#name-token-as-serialization-of-r){.selfRef}
:::

[Section 3](#stateless-clients){.xref} of this document provides
considerations for clients becoming \"stateless\" in this way. (The term
\"stateless\" is in quotes here, because it\'s a bit oversimplified.
Such clients still need to maintain per-server state and other kinds of
state. So it would be more accurate to just say that the clients are
avoiding per-request state.)[¶](#section-1-6){.pilcrow}

[Section 4](#stateless-intermediaries){.xref} of this document extends
the considerations for clients to intermediaries, which may want to
avoid keeping state for not only the requests they send to servers but
also the requests they receive from clients.[¶](#section-1-7){.pilcrow}

The serialization of state into tokens is limited by the fact that both
[CoAP over UDP](#RFC7252){.xref} \[[RFC7252](#RFC7252){.xref}\] and
[CoAP over reliable transports](#RFC8323){.xref}
\[[RFC8323](#RFC8323){.xref}\] restrict the maximum token length to 8
bytes. To overcome this limitation, [Section 2](#extended-tokens){.xref}
of this document introduces a CoAP protocol extension for extended token
lengths.[¶](#section-1-8){.pilcrow}

While the use case (avoiding per-request state) and the mechanism
(extended token lengths) presented in this document are closely related,
each can be used independently of the other. Some implementations may be
able to fit their state in just 8 bytes; some implementations may have
other use cases for extended token lengths.[¶](#section-1-9){.pilcrow}

::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

In this document, the term \"stateless\" refers to an implementation
strategy for a client (or intermediary in the client role) that does not
require it to keep state for the individual requests it sends to a
server (or intermediary in the server role). The client still needs to
keep state for each server it communicates with (e.g., for token
generation, message retransmission, and congestion
control).[¶](#section-1.1-1){.pilcrow}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-2){.pilcrow}
:::
:::
:::

::: {#extended-tokens}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Extended Tokens](#name-extended-tokens){.section-name .selfRef} {#name-extended-tokens}

This document updates the message formats defined for [CoAP over
UDP](#RFC7252){.xref} \[[RFC7252](#RFC7252){.xref}\] and [CoAP over TCP,
TLS, and WebSockets](#RFC8323){.xref} \[[RFC8323](#RFC8323){.xref}\]
with a new definition of the \"TKL\" field.[¶](#section-2-1){.pilcrow}

::: {#tkl-field}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Extended Token Length (TKL) Field](#name-extended-token-length-tkl-f){.section-name .selfRef} {#name-extended-token-length-tkl-f}

The definition of the \"TKL\" field is updated as
follows:[¶](#section-2.1-1){.pilcrow}

[]{.break}

Token Length (TKL):

:   4-bit unsigned integer. A value between 0 and 12, inclusive,
    indicates the length of the variable-length \"Token\" field in
    bytes. The other three values are reserved for special
    constructs:[¶](#section-2.1-2.2.1){.pilcrow}

    []{.break}

    13:
    :   An 8-bit unsigned integer directly precedes the \"Token\" field
        and indicates the length of the \"Token\" field minus
        13.[¶](#section-2.1-2.2.2.2){.pilcrow}
    :   

    14:
    :   A 16-bit unsigned integer in network byte order directly
        precedes the \"Token\" field and indicates the length of the
        \"Token\" field minus 269.[¶](#section-2.1-2.2.2.4){.pilcrow}
    :   

    15:
    :   Reserved. This value [MUST NOT]{.bcp14} be sent and
        [MUST]{.bcp14} be processed as a message-format
        error.[¶](#section-2.1-2.2.2.6){.pilcrow}
    :   

:   

All other fields retain their definitions.[¶](#section-2.1-3){.pilcrow}

The updated message formats are illustrated in [Appendix
A](#message-formats){.xref}.[¶](#section-2.1-4){.pilcrow}

The new definition of the \"TKL\" field increases the maximum token
length that can be represented in a message to 65804 bytes. However, the
maximum token length that sender and recipient implementations support
may be shorter. For example, a constrained node of [Class
1](#RFC7228){.xref} \[[RFC7228](#RFC7228){.xref}\] might support
extended token lengths only up to 32 bytes.[¶](#section-2.1-5){.pilcrow}

In CoAP over UDP, it is often beneficial to keep CoAP messages small
enough to avoid IP fragmentation. The maximum practical token length may
therefore also be influenced by the Path MTU (PMTU). See [Section
4.6](https://www.rfc-editor.org/rfc/rfc7252#section-4.6){.relref} of
\[[RFC7252](#RFC7252){.xref}\] for details.[¶](#section-2.1-6){.pilcrow}
:::
:::

::: {#discovery}
::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [Discovering Support](#name-discovering-support){.section-name .selfRef} {#name-discovering-support}

Extended token lengths require support from server implementations.
Support can be discovered by a client implementation in one of two
ways:[¶](#section-2.2-1){.pilcrow}

-   [Where Capabilities and Settings Messages (CSMs) are available, such
    as in CoAP over TCP, support can be discovered using the
    Extended-Token-Length Capability Option defined in [Section
    2.2.1](#capability-option){.xref}.[¶](#section-2.2-2.1){.pilcrow}]{#section-2.2-2.1}
-   [Otherwise, such as in CoAP over UDP, support can only be discovered
    by trial and error, as described in [Section
    2.2.2](#trial-and-error){.xref}.[¶](#section-2.2-2.2){.pilcrow}]{#section-2.2-2.2}

::: {#capability-option}
::: {#section-2.2.1 .section}
#### [2.2.1.](#section-2.2.1){.section-number .selfRef} [Extended-Token-Length Capability Option](#name-extended-token-length-capab){.section-name .selfRef} {#name-extended-token-length-capab}

A server can use the elective Extended-Token-Length Capability Option to
indicate the maximum token length it can accept in
requests.[¶](#section-2.2.1-1){.pilcrow}

[]{#name-the-extended-token-length-c}

::: {#capability-option-definition}
  \#   C   R   Applies to   Name                    Format   Length   Base Value
  ---- --- --- ------------ ----------------------- -------- -------- ------------
  6            CSM          Extended-Token-Length   uint     0-3      8

  : [Table 1](#table-1){.selfRef}: [The Extended-Token-Length Capability
  Option](#name-the-extended-token-length-c){.selfRef}
:::

C=Critical, R=Repeatable[¶](#section-2.2.1-3){.pilcrow}

As per [Section
3](https://www.rfc-editor.org/rfc/rfc7252#section-3){.relref} of
\[[RFC7252](#RFC7252){.xref}\], the base value (and the value used when
this option is not implemented) is 8.[¶](#section-2.2.1-4){.pilcrow}

The active value of the Extended-Token-Length Option is replaced each
time the option is sent with a modified value. Its starting value is its
base value.[¶](#section-2.2.1-5){.pilcrow}

The option value [MUST NOT]{.bcp14} be less than 8 or greater than
65804. If an option value less than 8 is received, the option
[MUST]{.bcp14} be ignored. If an option value greater than 65804 is
received, the option value [MUST]{.bcp14} be set to
65804.[¶](#section-2.2.1-6){.pilcrow}

Any option value greater than 8 implies support for the new definition
of the \"TKL\" field specified in [Section 2.1](#tkl-field){.xref}.
Indication of support by a server does not oblige a client to actually
make use of token lengths greater than 8.[¶](#section-2.2.1-7){.pilcrow}

If a server receives a request with a token of a length greater than
what it indicated in its Extended-Token-Length Option, it [MUST]{.bcp14}
handle the request as a message-format
error.[¶](#section-2.2.1-8){.pilcrow}

If a server receives a request with a token of a length less than, or
equal to, what it indicated in its Extended-Token-Length Option but is
unwilling or unable to handle the token at that time, it [MUST
NOT]{.bcp14} handle the request as a message-format error. Instead, it
[SHOULD]{.bcp14} return a 5.03 (Service Unavailable)
response.[¶](#section-2.2.1-9){.pilcrow}

The Extended-Token-Length Capability Option does not apply to responses.
The sender of a request is simply expected not to use a token of a
length greater than it is willing to accept in a
response.[¶](#section-2.2.1-10){.pilcrow}
:::
:::

::: {#trial-and-error}
::: {#section-2.2.2 .section}
#### [2.2.2.](#section-2.2.2){.section-number .selfRef} [Trial and Error](#name-trial-and-error){.section-name .selfRef} {#name-trial-and-error}

A server implementation that does not support the updated definition of
the \"TKL\" field specified in [Section 2.1](#tkl-field){.xref} will
consider a request with a \"TKL\" field value outside the range 0 to 8
to be a message-format error and reject it ([Section
3](https://www.rfc-editor.org/rfc/rfc7252#section-3){.relref} of
\[[RFC7252](#RFC7252){.xref}\]). A client can therefore determine
support by sending a request with an extended token length and checking
whether or not it is rejected by the
server.[¶](#section-2.2.2-1){.pilcrow}

In CoAP over UDP, the way a request message is rejected depends on the
message type. A Confirmable message with a message-format error is
rejected with a Reset message ([Section
4.2](https://www.rfc-editor.org/rfc/rfc7252#section-4.2){.relref} of
\[[RFC7252](#RFC7252){.xref}\]). A Non-confirmable message with a
message-format error is either rejected with a Reset message or just
silently ignored ([Section
4.3](https://www.rfc-editor.org/rfc/rfc7252#section-4.3){.relref} of
\[[RFC7252](#RFC7252){.xref}\]). To reliably get a Reset message, it is
therefore [REQUIRED]{.bcp14} that clients use a Confirmable message for
determining support.[¶](#section-2.2.2-2){.pilcrow}

As per RFC 7252, Reset messages are empty and do not contain a token;
they only return the Message ID ([Figure
3](#trial-and-error-illustration){.xref}). They also do not contain any
indication of what caused a message-format error. To avoid any
ambiguity, it is therefore [RECOMMENDED]{.bcp14} that clients use a
request that has no potential message-format error other than the
extended token length.[¶](#section-2.2.2-3){.pilcrow}

[]{#name-a-confirmable-request-with-}

::: {#trial-and-error-illustration}
::: {#section-2.2.2-4.1 .artwork .art-text .alignCenter}
    +-----------------+   request message    +------------+
    |        |        |    with extended     |            |
    |        |        |     token length     |            |
    |    .-<-+->------|--------------------->|------.     |
    |   _|_           |                      |      |     |
    |  /   \ stored   |                      |      |     |
    |  \___/ state    |                      |      |     |
    |    |            |                      |      |     |
    |    '->-+-<------|<---------------------|------'     |
    |        |        |     Reset message    |            |
    |        v        |   with only message  |            |
    +-----------------+    ID echoed back    +------------+
          Client                                 Server
:::

[Figure 3](#figure-3){.selfRef}: [A Confirmable Request with an Extended
Token Is Rejected with a Reset Message If the Server Does Not Have
Support](#name-a-confirmable-request-with-){.selfRef}
:::

An example of a suitable request is a GET request in a Confirmable
message that includes only an If-None-Match option and a token of the
greatest length that the client intends to use. Any response with the
same token echoed back indicates that tokens up to that length are
supported by the server.[¶](#section-2.2.2-5){.pilcrow}

Since network addresses may change, a client [SHOULD NOT]{.bcp14} assume
that extended token lengths are supported by a server for an unlimited
duration. Unless additional information is available, the client should
assume that addresses (and therefore extended token lengths) are valid
for a minimum of 1800 s and a maximum of 86400 s (1 day). A client may
use additional forms of input into this determination. For instance, a
client may assume a server that is in the same subnet as the client has
a similar address lifetime as the client. The client may use DHCP lease
times or Router Advertisements to set the limits. For servers that are
not local, if the server was looked up using DNS, then the DNS resource
record will have a Time To Live (TTL), and the extended token length
should be kept for only that amount of
time.[¶](#section-2.2.2-6){.pilcrow}

If a server supports extended token lengths but receives a request with
a token of a length it is unwilling or unable to handle, it [MUST
NOT]{.bcp14} reject the message, as that would imply that extended token
lengths are not supported at all. Instead, if the server cannot handle
the request at the time, it [SHOULD]{.bcp14} return a 5.03 (Service
Unavailable) response; if the server will never be able to handle the
request (e.g., because the token is too large), it [SHOULD]{.bcp14}
return a 4.00 (Bad Request) response.[¶](#section-2.2.2-7){.pilcrow}

Design Note: The requirement to return an error response when a token
cannot be handled might seem somewhat contradictory, as returning the
error response requires the server also to return the token it cannot
handle. However, processing a request usually involves a number of steps
from receiving the message to passing it to application logic. The idea
is that a server implementing this extension supports large tokens at
least in its first few processing steps, enough to return an error
response rather than a Reset message.[¶](#section-2.2.2-8.1){.pilcrow}

Design Note: To prevent the trial-and-error-based discovery from
becoming too complicated, no effort is made to indicate the maximum
supported token length. A client implementation would probably already
choose the shortest token possible for the task (such as being
stateless, as described in [Section 3](#stateless-clients){.xref}), so
it would probably not be able to reduce the length any further anyway
should a server indicate a lower limit.[¶](#section-2.2.2-9.1){.pilcrow}
:::
:::
:::
:::

::: {#hop-by-hop}
::: {#section-2.3 .section}
### [2.3.](#section-2.3){.section-number .selfRef} [Intermediaries](#name-intermediaries){.section-name .selfRef} {#name-intermediaries}

Tokens are a hop-by-hop feature: if there are one or more intermediaries
between a client and a server, every token is scoped to the exchange
between a node in the client role and the node in the server role that
it is immediately interacting with.[¶](#section-2.3-1){.pilcrow}

When an intermediary receives a request, the only requirement is that it
echoes the token back in any resulting response. There is no requirement
or expectation that an intermediary passes a client\'s token on to a
server or that an intermediary uses extended token lengths itself in its
request to satisfy a request with an extended token length. Discovery
needs to be performed for each hop where extended token lengths are to
be used.[¶](#section-2.3-2){.pilcrow}
:::
:::
:::
:::

::: {#stateless-clients}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Stateless Clients](#name-stateless-clients){.section-name .selfRef} {#name-stateless-clients}

A client can be alleviated of keeping per-request state as
follows:[¶](#section-3-1){.pilcrow}

1.  [The client serializes (parts of) its per-request state into a
    sequence of bytes and sends those bytes as the token of its request
    to the server.[¶](#section-3-2.1){.pilcrow}]{#section-3-2.1}
2.  [The server returns the token verbatim in the response to the
    client, which allows the client to recover the state and process the
    response as if it had kept the state
    locally.[¶](#section-3-2.2){.pilcrow}]{#section-3-2.2}

As servers are just expected to return any token verbatim to the client,
this implementation strategy for clients does not impact the
interoperability of client and server implementations. However, there
are a number of significant, nonobvious implications (e.g., related to
security and other CoAP protocol features) that client implementations
need take into consideration.[¶](#section-3-3){.pilcrow}

The following subsections discuss some of these
considerations.[¶](#section-3-4){.pilcrow}

::: {#serialized-state}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Serializing Client State](#name-serializing-client-state){.section-name .selfRef} {#name-serializing-client-state}

The format of the serialized state is generally an implementation detail
of the client and opaque to the server. However, serialized state
information is an attractive target for both unwanted nodes (e.g.,
on-path attackers) and wanted nodes (e.g., any configured forward proxy)
on the path. The serialization format therefore needs to include
security measures such as the following:[¶](#section-3.1-1){.pilcrow}

-   [A client [SHOULD]{.bcp14} protect the integrity of the state
    information serialized in a
    token.[¶](#section-3.1-2.1){.pilcrow}]{#section-3.1-2.1}
-   [Even when the integrity of the serialized state is protected, an
    attacker may still replay a response, making the client believe it
    sent the same request twice. For this reason, the client
    [SHOULD]{.bcp14} implement replay protection (e.g., by using
    sequence numbers and a replay window). For replay protection,
    integrity protection is
    [REQUIRED]{.bcp14}.[¶](#section-3.1-2.2){.pilcrow}]{#section-3.1-2.2}
-   [If processing a response without keeping request state is sensitive
    to the time elapsed since sending the request, then the client
    [SHOULD]{.bcp14} include freshness information (e.g., a timestamp)
    in the serialized state and reject any response where the freshness
    information is insufficiently
    fresh.[¶](#section-3.1-2.3){.pilcrow}]{#section-3.1-2.3}
-   [Information in the serialized state may be privacy sensitive. A
    client [SHOULD]{.bcp14} encrypt the serialized state if it contains
    privacy-sensitive information that an attacker would not get
    otherwise.[¶](#section-3.1-2.4){.pilcrow}]{#section-3.1-2.4}
-   [When a client changes the format of the serialized state, it
    [SHOULD]{.bcp14} prevent false interoperability with the previous
    format (e.g., by changing the key used for integrity protection or
    changing a field in the serialized
    state).[¶](#section-3.1-2.5){.pilcrow}]{#section-3.1-2.5}
:::
:::

::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Using Extended Tokens](#name-using-extended-tokens){.section-name .selfRef} {#name-using-extended-tokens}

A client that depends on support for extended token lengths ([Section
2](#extended-tokens){.xref}) from the server to avoid keeping request
state needs to perform a discovery of support ([Section
2.2](#discovery){.xref}) before it can be
stateless.[¶](#section-3.2-1){.pilcrow}

This discovery [MUST]{.bcp14} be performed in a stateful way, i.e.,
keeping state for the request ([Figure 4](#stateful-discovery){.xref}).
If the client was stateless from the start, and the server does not
support extended tokens, then no error message could be processed, since
the state would neither be present at the client nor returned in the
Reset message ([Figure
5](#stateless-discovery){.xref}).[¶](#section-3.2-2){.pilcrow}

[]{#name-depending-on-extended-token}

::: {#stateful-discovery}
::: {#section-3.2-3.1 .artwork .art-text .alignCenter}
    +-----------------+    dummy request     +------------+
    |        |        |    with extended     |            |
    |        |        |        token         |            |
    |    .-<-+->------|=====================>|------.     |
    |   _|_           |                      |      |     |
    |  /   \ stored   |                      |      |     |
    |  \___/ state    |                      |      |     |
    |    |            |                      |      |     |
    |    '->-+-<------|<=====================|------'     |
    |        |        |     response with    |            |
    |        |        |    extended token    |            |
    |        |        |      echoed back     |            |
    |        |        |                      |            |
    |        |        |                      |            |
    |        |        |     request with     |            |
    |        |        |   serialized state   |            |
    |        |        |       as token       |            |
    |        +--------|=====================>|------.     |
    |                 |                      |      |     |
    |    look ma,     |                      |      |     |
    |    no state!    |                      |      |     |
    |                 |                      |      |     |
    |        +--------|<=====================|------'     |
    |        |        |     response with    |            |
    |        v        |   token echoed back  |            |
    +-----------------+                      +------------+
          Client                                 Server
:::

[Figure 4](#figure-4){.selfRef}: [Depending on Extended Tokens for Being
Stateless First Requires a Successful Stateful Discovery of
Support](#name-depending-on-extended-token){.selfRef}
:::

[]{#name-stateless-discovery-of-supp}

::: {#stateless-discovery}
::: {#section-3.2-4.1 .artwork .art-text .alignCenter}
    +-----------------+    dummy request     +------------+
    |        |        |    with extended     |            |
    |        |        |        token         |            |
    |        +--------|=====================>|------.     |
    |                 |                      |      |     |
    |                 |                      |      |     |
    |                 |                      |      |     |
    |                 |                      |      |     |
    |              ???|<---------------------|------'     |
    |                 |     Reset message    |            |
    |                 |   with only message  |            |
    +-----------------+    ID echoed back    +------------+
          Client                                 Server
:::

[Figure 5](#figure-5){.selfRef}: [Stateless Discovery of Support Does
Not Work](#name-stateless-discovery-of-supp){.selfRef}
:::

In environments where support can be reliably discovered through some
other means, the discovery of support is [OPTIONAL]{.bcp14}. An example
for this is the [Constrained Join Protocol (CoJP) in a 6TiSCH
network](#I-D.ietf-6tisch-minimal-security){.xref}
\[[6TISCH-MIN-SEC](#I-D.ietf-6tisch-minimal-security){.xref}\], where
support for extended tokens is required from all relevant
parties.[¶](#section-3.2-5){.pilcrow}
:::

::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Transmitting Messages](#name-transmitting-messages){.section-name .selfRef} {#name-transmitting-messages}

In [CoAP over UDP](#RFC7252){.xref} \[[RFC7252](#RFC7252){.xref}\], a
client has the choice between Confirmable and Non-confirmable messages
for requests. When using Non-confirmable messages, a client does not
have to keep any message-exchange state, which can help in the goal of
avoiding state. When using Confirmable messages, a client needs to keep
message-exchange state for performing retransmissions and handling
Acknowledgement and Reset messages, however. Non-confirmable messages
are therefore better suited for avoiding state. In any case, a client
still needs to keep congestion-control state, i.e., maintain state for
each node it communicates with and enforce limits like
NSTART.[¶](#section-3.3-1){.pilcrow}

As per [Section
5.2](https://www.rfc-editor.org/rfc/rfc7252#section-5.2){.relref} of
\[[RFC7252](#RFC7252){.xref}\], a client must be prepared to receive a
response as a piggybacked response, a separate response, or a
Non-confirmable response, regardless of the message type used for the
request. A stateless client [MUST]{.bcp14} handle these response types
as follows:[¶](#section-3.3-2){.pilcrow}

-   [If a piggybacked response passes the checks for token integrity and
    freshness ([Section 3.1](#serialized-state){.xref}), the client
    processes the message as specified in RFC 7252; otherwise, it
    processes the acknowledgement portion of the message as specified in
    RFC 7252 and silently discards the response
    portion.[¶](#section-3.3-3.1){.pilcrow}]{#section-3.3-3.1}
-   [If a separate response passes the checks for token integrity and
    freshness, the client processes the message as specified in RFC
    7252; otherwise, it rejects the message as specified in [Section
    4.2](https://www.rfc-editor.org/rfc/rfc7252#section-4.2){.relref} of
    \[[RFC7252](#RFC7252){.xref}\].[¶](#section-3.3-3.2){.pilcrow}]{#section-3.3-3.2}
-   [If a Non-confirmable response passes the checks for token integrity
    and freshness, the client processes the message as specified in RFC
    7252; otherwise, it rejects the message as specified in [Section
    4.3](https://www.rfc-editor.org/rfc/rfc7252#section-4.3){.relref} of
    \[[RFC7252](#RFC7252){.xref}\].[¶](#section-3.3-3.3){.pilcrow}]{#section-3.3-3.3}
:::
:::
:::

::: {#stateless-intermediaries}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Stateless Intermediaries](#name-stateless-intermediaries){.section-name .selfRef} {#name-stateless-intermediaries}

Tokens are a hop-by-hop feature. If a client makes a request to an
intermediary, that intermediary needs to store the client\'s token
(along with the client\'s transport address) while it makes its own
request towards the origin server and waits for the response. When the
intermediary receives the response, it looks up the client\'s token and
transport address for the received request and sends an appropriate
response to the client.[¶](#section-4-1){.pilcrow}

An intermediary might want to be \"stateless\" not only in its role as a
client but also in its role as a server, i.e., be alleviated of storing
the client information for the requests it
receives.[¶](#section-4-2){.pilcrow}

Such an intermediary can be implemented by serializing the client
information along with the request state into the token towards the
origin server. When the intermediary receives the response, it can
recover the client information from the token and use it to satisfy the
client\'s request; therefore, the intermediary doesn\'t need to store
the information itself.[¶](#section-4-3){.pilcrow}

The following subsections discuss some considerations for this
approach.[¶](#section-4-4){.pilcrow}

::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Observing Resources](#name-observing-resources){.section-name .selfRef} {#name-observing-resources}

One drawback of the approach is that an intermediary, without keeping
request state, is unable to aggregate multiple requests for the same
target resource, which can significantly reduce efficiency. In
particular, when clients observe \[[RFC7641](#RFC7641){.xref}\] the same
resource, aggregating requests is [REQUIRED]{.bcp14} ([Section
3.1](https://www.rfc-editor.org/rfc/rfc7641#section-3.1){.relref} of
\[[RFC7641](#RFC7641){.xref}\]). This requirement cannot be satisfied
without keeping request state.[¶](#section-4.1-1){.pilcrow}

Furthermore, an intermediary that does not keep track of the clients
observing a resource is not able to determine whether these clients are
still interested in receiving further notifications ([Section
3.5](https://www.rfc-editor.org/rfc/rfc7641#section-3.5){.relref} of
\[[RFC7641](#RFC7641){.xref}\]) or want to cancel an observation
([Section
3.6](https://www.rfc-editor.org/rfc/rfc7641#section-3.6){.relref} of
\[[RFC7641](#RFC7641){.xref}\]).[¶](#section-4.1-2){.pilcrow}

Therefore, an intermediary [MUST NOT]{.bcp14} include an Observe Option
in requests it sends without keeping both the request state for the
requests it sends and the client information for the requests it
receives.[¶](#section-4.1-3){.pilcrow}
:::

::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Block-Wise Transfers](#name-block-wise-transfers){.section-name .selfRef} {#name-block-wise-transfers}

When using [block-wise transfers](#RFC7959){.xref}
\[[RFC7959](#RFC7959){.xref}\], a server might not be able to
distinguish blocks originating from different clients once they have
been forwarded by an intermediary. Intermediaries need to ensure that
this does not lead to inconsistent resource state by keeping distinct
block-wise request operations on the same resource apart, e.g.,
utilizing the [Request-Tag
Option](#I-D.ietf-core-echo-request-tag){.xref}
\[[ECHO-REQUEST-TAG](#I-D.ietf-core-echo-request-tag){.xref}\].[¶](#section-4.2-1){.pilcrow}
:::

::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Gateway Timeouts](#name-gateway-timeouts){.section-name .selfRef} {#name-gateway-timeouts}

As per [Section
5.7.1](https://www.rfc-editor.org/rfc/rfc7252#section-5.7.1){.relref} of
\[[RFC7252](#RFC7252){.xref}\], an intermediary is [REQUIRED]{.bcp14} to
return a 5.04 (Gateway Timeout) response if it cannot obtain a response
within a timeout. However, if an intermediary does not keep the client
information for the requests it receives, it cannot return such a
response. Therefore, in this case, the gateway cannot return such a
response and as such cannot implement such a
timeout.[¶](#section-4.3-1){.pilcrow}
:::

::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Extended Tokens](#name-extended-tokens-2){.section-name .selfRef} {#name-extended-tokens-2}

A client may make use of extended token lengths in a request to an
intermediary that wants to be \"stateless\". This means that such an
intermediary may have to serialize potentially very large client
information into its token towards the origin server. The tokens can
grow even further when it progresses along a chain of intermediaries
that all want to be \"stateless\".[¶](#section-4.4-1){.pilcrow}

Intermediaries [SHOULD]{.bcp14} limit the size of client information
they are serializing into their own tokens. An intermediary can do this,
for example, by limiting the extended token lengths it accepts from its
clients (see [Section 2.2](#discovery){.xref}) or by keeping the client
information locally when the client information exceeds the limit (i.e.,
not being \"stateless\").[¶](#section-4.4-2){.pilcrow}
:::
:::
:::

::: {#security}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Extended Tokens](#name-extended-tokens-3){.section-name .selfRef} {#name-extended-tokens-3}

Tokens significantly larger than the 8 bytes specified in RFC 7252 have
implications \-- in particular, for nodes with constrained memory size
\-- that need to be mitigated. A node in the server role supporting
extended token lengths may be vulnerable to a denial of service when an
attacker (either on-path or a malicious client) sends large tokens to
fill up the memory of the node. Implementations need to be prepared to
handle such messages.[¶](#section-5.1-1){.pilcrow}
:::

::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Stateless Clients and Intermediaries](#name-stateless-clients-and-inter){.section-name .selfRef} {#name-stateless-clients-and-inter}

Transporting the state needed by a client to process a response as
serialized state information in the token has several significant and
nonobvious security and privacy implications that need to be mitigated;
see [Section 3.1](#serialized-state){.xref} for
recommendations.[¶](#section-5.2-1){.pilcrow}

In addition to the format requirements outlined there, implementations
need to ensure that they are not vulnerable to maliciously crafted,
delayed, or replayed tokens.[¶](#section-5.2-2){.pilcrow}

It is generally expected that the use of encryption, integrity
protection, and replay protection for serialized state is
appropriate.[¶](#section-5.2-3){.pilcrow}

In the absence of integrity and replay protection, an on-path attacker
or rogue server/intermediary could return a state (either one modified
in a reply, or an unsolicited one) that could alter the internal state
of the client.[¶](#section-5.2-4){.pilcrow}

It is for this reason that at least the use of integrity protection on
the token is always recommended.[¶](#section-5.2-5){.pilcrow}

It may be that in some very specific cases, as a result of a careful and
detailed analysis of any potential attacks, it is decided that such
cryptographic protections do not add value. The authors of this document
have not found such a use case as yet, but this is a local
decision.[¶](#section-5.2-6){.pilcrow}

It should further be emphasized that the encrypted state is created by
the sending node and decrypted by the same node when receiving a
response. The key is not shared with any other system. Therefore, the
choice of encryption scheme and the generation of the key for this
system is purely a local matter.[¶](#section-5.2-7){.pilcrow}

When encryption is used, the use of [AES-CCM](#RFC3610){.xref}
\[[RFC3610](#RFC3610){.xref}\] with a 64-bit tag is recommended,
combined with a sequence number and a replay window. This choice is
informed by available hardware acceleration of on many constrained
systems. If a different algorithm is available accelerated on the
sender, with similar or stronger strength, then it [SHOULD]{.bcp14} be
preferred. Where privacy of the state is not required, and encryption is
not needed, [HMAC-SHA-256](#RFC6234){.xref}
\[[RFC6234](#RFC6234){.xref}\], combined with a sequence number and a
replay window, may be used.[¶](#section-5.2-8){.pilcrow}

This size of the replay window depends upon the number of requests that
need to be outstanding. This can be determined from the rate at which
new ones are made and the expected time period during which responses
are expected.[¶](#section-5.2-9){.pilcrow}

For instance, given a CoAP MAX_TRANSMIT_WAIT of 93 s ([Section
4.8.2](https://www.rfc-editor.org/rfc/rfc7252#section-4.8.2){.relref} of
\[[RFC7252](#RFC7252){.xref}\]), any request that is not answered within
93 s will be considered to have failed. At a request rate of one request
per 10 s, at most 10 (ceil(9.3)) requests can be outstanding at a time,
and any convenient replay window larger than 20 will work. As replay
windows are often implemented with a sliding window and a bit, the use
of a 32-bit window would be sufficient.[¶](#section-5.2-10){.pilcrow}

For use cases where requests are being relayed from another node, the
request rate may be estimated by the total link capacity allocated for
that kind of traffic. An alternate view would consider how many IPv6
Neighbor Cache Entries (NCEs) the system can afford to allocate for this
use.[¶](#section-5.2-11){.pilcrow}

When using an encryption mode that depends on a nonce, such as AES-CCM,
repeated use of the same nonce under the same key causes the cipher to
fail catastrophically.[¶](#section-5.2-12){.pilcrow}

If a nonce is ever used for more than one encryption operation with the
same key, then the same key stream gets used to encrypt both plaintexts,
and the confidentiality guarantees are voided. Devices with low-quality
entropy sources \-- as is typical with constrained devices, which
incidentally happen to be a natural candidate for the stateless
mechanism described in this document \-- need to carefully pick a
nonce-generation mechanism that provides the above uniqueness
guarantee.[¶](#section-5.2-13){.pilcrow}

\[[RFC8613](#RFC8613){.xref}\], Appendix B.1.1 (\"Sender Sequence
Number\") provides a model for how to maintain nonrepeating nonces
without causing excessive wear of flash
memory.[¶](#section-5.2-14){.pilcrow}
:::
:::
:::

::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [CoAP Signaling Option Number](#name-coap-signaling-option-numbe){.section-name .selfRef} {#name-coap-signaling-option-numbe}

The following entry has been added to the \"CoAP Signaling Option
Numbers\" registry within the \"CoRE Parameters\"
registry.[¶](#section-6.1-1){.pilcrow}

[]{#name-coap-signaling-option-number}

  Applies to   Number   Name                    Reference
  ------------ -------- ----------------------- -----------
  7.01         6        Extended-Token-Length   RFC 8974

  : [Table 2](#table-2){.selfRef}: [CoAP Signaling Option
  Number](#name-coap-signaling-option-number){.selfRef}
:::
:::

::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC7252\]
:   [Shelby, Z.]{.refAuthor}[, Hartke, K.]{.refAuthor}[, and C.
    Bormann]{.refAuthor}, [\"The Constrained Application Protocol
    (CoAP)\"]{.refTitle}, [RFC 7252]{.seriesInfo}, [DOI
    10.17487/RFC7252]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7252>\>.
:   

\[RFC7641\]
:   [Hartke, K.]{.refAuthor}, [\"Observing Resources in the Constrained
    Application Protocol (CoAP)\"]{.refTitle}, [RFC 7641]{.seriesInfo},
    [DOI 10.17487/RFC7641]{.seriesInfo}, September 2015,
    \<<https://www.rfc-editor.org/info/rfc7641>\>.
:   

\[RFC7959\]
:   [Bormann, C.]{.refAuthor}[ and Z. Shelby, Ed.]{.refAuthor},
    [\"Block-Wise Transfers in the Constrained Application Protocol
    (CoAP)\"]{.refTitle}, [RFC 7959]{.seriesInfo}, [DOI
    10.17487/RFC7959]{.seriesInfo}, August 2016,
    \<<https://www.rfc-editor.org/info/rfc7959>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8323\]
:   [Bormann, C.]{.refAuthor}[, Lemay, S.]{.refAuthor}[,
    Tschofenig, H.]{.refAuthor}[, Hartke, K.]{.refAuthor}[,
    Silverajan, B.]{.refAuthor}[, and B. Raymor, Ed.]{.refAuthor},
    [\"CoAP (Constrained Application Protocol) over TCP, TLS, and
    WebSockets\"]{.refTitle}, [RFC 8323]{.seriesInfo}, [DOI
    10.17487/RFC8323]{.seriesInfo}, February 2018,
    \<<https://www.rfc-editor.org/info/rfc8323>\>.
:   
:::

::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[6TISCH-MIN-SEC\]
:   [Vucinic, M.]{.refAuthor}[, Simon, J.]{.refAuthor}[,
    Pister, K.]{.refAuthor}[, and M. Richardson]{.refAuthor},
    [\"Constrained Join Protocol (CoJP) for 6TiSCH\"]{.refTitle}, [Work
    in Progress]{.refContent}, [Internet-Draft,
    draft-ietf-6tisch-minimal-security-15]{.seriesInfo}, 10 December
    2019,
    \<<https://tools.ietf.org/html/draft-ietf-6tisch-minimal-security-15>\>.
:   

\[ECHO-REQUEST-TAG\]
:   [Amsüss, C.]{.refAuthor}[, Mattsson, J. P.]{.refAuthor}[, and G.
    Selander]{.refAuthor}, [\"CoAP: Echo, Request-Tag, and Token
    Processing\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-core-echo-request-tag-11]{.seriesInfo},
    2 November 2020,
    \<<https://tools.ietf.org/html/draft-ietf-core-echo-request-tag-11>\>.
:   

\[RFC3610\]
:   [Whiting, D.]{.refAuthor}[, Housley, R.]{.refAuthor}[, and N.
    Ferguson]{.refAuthor}, [\"Counter with CBC-MAC (CCM)\"]{.refTitle},
    [RFC 3610]{.seriesInfo}, [DOI 10.17487/RFC3610]{.seriesInfo},
    September 2003, \<<https://www.rfc-editor.org/info/rfc3610>\>.
:   

\[RFC6234\]
:   [Eastlake 3rd, D.]{.refAuthor}[ and T. Hansen]{.refAuthor}, [\"US
    Secure Hash Algorithms (SHA and SHA-based HMAC and
    HKDF)\"]{.refTitle}, [RFC 6234]{.seriesInfo}, [DOI
    10.17487/RFC6234]{.seriesInfo}, May 2011,
    \<<https://www.rfc-editor.org/info/rfc6234>\>.
:   

\[RFC7228\]
:   [Bormann, C.]{.refAuthor}[, Ersue, M.]{.refAuthor}[, and A.
    Keranen]{.refAuthor}, [\"Terminology for Constrained-Node
    Networks\"]{.refTitle}, [RFC 7228]{.seriesInfo}, [DOI
    10.17487/RFC7228]{.seriesInfo}, May 2014,
    \<<https://www.rfc-editor.org/info/rfc7228>\>.
:   

\[RFC8613\]
:   [Selander, G.]{.refAuthor}[, Mattsson, J.]{.refAuthor}[,
    Palombini, F.]{.refAuthor}[, and L. Seitz]{.refAuthor}, [\"Object
    Security for Constrained RESTful Environments
    (OSCORE)\"]{.refTitle}, [RFC 8613]{.seriesInfo}, [DOI
    10.17487/RFC8613]{.seriesInfo}, July 2019,
    \<<https://www.rfc-editor.org/info/rfc8613>\>.
:   
:::
:::

::: {#message-formats}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Updated Message Formats](#name-updated-message-formats){.section-name .selfRef} {#name-updated-message-formats}

In [Section 2](#extended-tokens){.xref}, this document updates the CoAP
message formats by specifying a new definition of the \"TKL\" field in
the message header. As an alternative presentation of this update, this
appendix shows the CoAP message formats for [CoAP over
UDP](#RFC7252){.xref} \[[RFC7252](#RFC7252){.xref}\] and [CoAP over TCP,
TLS, and WebSockets](#RFC8323){.xref} \[[RFC8323](#RFC8323){.xref}\]
with the new definition applied.[¶](#section-appendix.a-1){.pilcrow}

::: {#section-a.1 .section}
## [A.1.](#section-a.1){.section-number .selfRef} [CoAP over UDP](#name-coap-over-udp){.section-name .selfRef} {#name-coap-over-udp}

::: {#section-a.1-1 .artwork .art-text .alignCenter}
                    0   1   2   3   4   5   6   7
                  +-------+-------+---------------+
                  |       |       |               |
                  |  Ver  |   T   |      TKL      |   1 byte
                  |       |       |               |
                  +-------+-------+---------------+
                  |                               |
                  |             Code              |   1 byte
                  |                               |
                  +-------------------------------+
                  |                               |
                  |                               |
                  |                               |
                  +-         Message ID          -+   2 bytes
                  |                               |
                  |                               |
                  |                               |
                  +-------------------------------+
                  \                               \
                  /              TKL              /   0-2 bytes
                  \          (extended)           \
                  +-------------------------------+
                  \                               \
                  /             Token             /   0-65804 bytes
                  \                               \
                  +-------------------------------+
                  \                               \
                  /                               /
                  \                               \
                  /            Options            /   0 or more bytes
                  \                               \
                  /                               /
                  \                               \
                  +---------------+---------------+
                  |               |               |
                  |      15       |       15      |   1 byte (if payload)
                  |               |               |
                  +---------------+---------------+
                  \                               \
                  /                               /
                  \                               \
                  /            Payload            /   0 or more bytes
                  \                               \
                  /                               /
                  \                               \
                  +-------------------------------+

[¶](#section-a.1-1){.pilcrow}
:::
:::

::: {#section-a.2 .section}
## [A.2.](#section-a.2){.section-number .selfRef} [CoAP over TCP/TLS](#name-coap-over-tcp-tls){.section-name .selfRef} {#name-coap-over-tcp-tls}

::: {#section-a.2-1 .artwork .art-text .alignCenter}
                    0   1   2   3   4   5   6   7
                  +---------------+---------------+
                  |               |               |
                  |      Len      |      TKL      |   1 byte
                  |               |               |
                  +---------------+---------------+
                  \                               \
                  /              Len              /   0-4 bytes
                  \          (extended)           \
                  +-------------------------------+
                  |                               |
                  |             Code              |   1 byte
                  |                               |
                  +-------------------------------+
                  \                               \
                  /              TKL              /   0-2 bytes
                  \          (extended)           \
                  +-------------------------------+
                  \                               \
                  /             Token             /   0-65804 bytes
                  \                               \
                  +-------------------------------+
                  \                               \
                  /                               /
                  \                               \
                  /            Options            /   0 or more bytes
                  \                               \
                  /                               /
                  \                               \
                  +---------------+---------------+
                  |               |               |
                  |      15       |       15      |   1 byte (if payload)
                  |               |               |
                  +---------------+---------------+
                  \                               \
                  /                               /
                  \                               \
                  /            Payload            /   0 or more bytes
                  \                               \
                  /                               /
                  \                               \
                  +-------------------------------+

[¶](#section-a.2-1){.pilcrow}
:::
:::

::: {#section-a.3 .section}
## [A.3.](#section-a.3){.section-number .selfRef} [CoAP over WebSockets](#name-coap-over-websockets){.section-name .selfRef} {#name-coap-over-websockets}

::: {#section-a.3-1 .artwork .art-text .alignCenter}
                    0   1   2   3   4   5   6   7
                  +---------------+---------------+
                  |               |               |
                  |       0       |      TKL      |   1 byte
                  |               |               |
                  +---------------+---------------+
                  |                               |
                  |             Code              |   1 byte
                  |                               |
                  +-------------------------------+
                  \                               \
                  /              TKL              /   0-2 bytes
                  \          (extended)           \
                  +-------------------------------+
                  \                               \
                  /             Token             /   0-65804 bytes
                  \                               \
                  +-------------------------------+
                  \                               \
                  /                               /
                  \                               \
                  /            Options            /   0 or more bytes
                  \                               \
                  /                               /
                  \                               \
                  +---------------+---------------+
                  |               |               |
                  |      15       |       15      |   1 byte (if payload)
                  |               |               |
                  +---------------+---------------+
                  \                               \
                  /                               /
                  \                               \
                  /            Payload            /   0 or more bytes
                  \                               \
                  /                               /
                  \                               \
                  +-------------------------------+

[¶](#section-a.3-1){.pilcrow}
:::
:::
:::
:::

::: {#section-appendix.b .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

This document is based on the requirements of, and work on,
\"Constrained Join Protocol (CoJP) for 6TiSCH\" (January 2020) by
[Mališa Vučinić]{.contact-name}, [Jonathan Simon]{.contact-name}, [Kris
Pister]{.contact-name}, and [Michael
Richardson]{.contact-name}.[¶](#section-appendix.b-1){.pilcrow}

Thanks to [Christian Amsüss]{.contact-name}, [Carsten
Bormann]{.contact-name}, [Roman Danyliw]{.contact-name}, [Christer
Holmberg]{.contact-name}, [Benjamin Kaduk]{.contact-name}, [Ari
Keränen]{.contact-name}, [Erik Kline]{.contact-name}, [Murray
Kucherawy]{.contact-name}, [Warren Kumari]{.contact-name}, [Barry
Leiba]{.contact-name}, [David Mandelberg]{.contact-name}, [Dan
Romascanu]{.contact-name}, [Jim Schaad]{.contact-name}, [Göran
Selander]{.contact-name}, [Mališa Vučinić]{.contact-name}, [Éric
Vyncke]{.contact-name}, and [Robert Wilton]{.contact-name} for helpful
comments and discussions that have shaped the
document.[¶](#section-appendix.b-2){.pilcrow}

Special thanks to [John Mattsson]{.contact-name} for his contributions
to the security considerations of the document, and to [Thomas
Fossati]{.contact-name} for his in-depth review, copious comments, and
suggested text.[¶](#section-appendix.b-3){.pilcrow}
:::

::: {#authors-addresses}
::: {#section-appendix.c .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Klaus Hartke]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Ericsson]{.org}
:::

::: {.left dir="auto"}
[Torshamnsgatan 23]{.street-address}
:::

::: {.left dir="auto"}
SE-[16483]{.postal-code} [Stockholm]{.locality}
:::

::: {.left dir="auto"}
[Sweden]{.country-name}
:::

::: email
Email: <klaus.hartke@ericsson.com>
:::

::: {.left dir="auto"}
[Michael C. Richardson]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Sandelman Software Works]{.org}
:::

::: email
Email: <mcr+ietf@sandelman.ca>
:::

::: url
URI: <http://www.sandelman.ca/>
:::
:::
:::
