  RFC 9203            OSCORE Profile of ACE   August 2022
  ------------------- ----------------------- -------------
  Palombini, et al.   Standards Track         \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9203](https://www.rfc-editor.org/rfc/rfc9203){.eref}

Category:
:   Standards Track

Published:
:   August 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    F. Palombini
    :::

    ::: org
    Ericsson AB
    :::
    :::

    ::: author
    ::: author-name
    L. Seitz
    :::

    ::: org
    Combitech
    :::
    :::

    ::: author
    ::: author-name
    G. Selander
    :::

    ::: org
    Ericsson AB
    :::
    :::

    ::: author
    ::: author-name
    M. Gunnarsson
    :::

    ::: org
    RISE
    :::
    :::
:::

# RFC 9203 {#rfcnum}

# The Object Security for Constrained RESTful Environments (OSCORE) Profile of the Authentication and Authorization for Constrained Environments (ACE) Framework {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document specifies a profile for the Authentication and
Authorization for Constrained Environments (ACE) framework. It utilizes
Object Security for Constrained RESTful Environments (OSCORE) to provide
communication security and proof-of-possession for a key owned by the
client and bound to an OAuth 2.0 access
token.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9203>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Terminology](#name-terminology){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Protocol
    Overview](#name-protocol-overview){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Client-AS
    Communication](#name-client-as-communication){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [C-to-AS: POST to Token
        Endpoint](#name-c-to-as-post-to-token-endpo){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [AS-to-C: Access
        Token](#name-as-to-c-access-token){.xref}

        -   ::: {#section-toc.1-1.3.2.2.2.1}
            [3.2.1](#section-3.2.1){.xref}.  [The
            OSCORE_Input_Material](#name-the-oscore_input_material){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Client-RS
    Communication](#name-client-rs-communication){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [C-to-RS: POST to authz-info
        Endpoint](#name-c-to-rs-post-to-authz-info-){.xref}

        -   ::: {#section-toc.1-1.4.2.1.2.1}
            [4.1.1](#section-4.1.1){.xref}.  [The Nonce 1
            Parameter](#name-the-nonce-1-parameter){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.1.2.2}
            [4.1.2](#section-4.1.2){.xref}.  [The ace_client_recipientid
            Parameter](#name-the-ace_client_recipientid-){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [RS-to-C: 2.01
        (Created)](#name-rs-to-c-201-created){.xref}

        -   ::: {#section-toc.1-1.4.2.2.2.1}
            [4.2.1](#section-4.2.1){.xref}.  [The Nonce 2
            Parameter](#name-the-nonce-2-parameter){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.2}
            [4.2.2](#section-4.2.2){.xref}.  [The ace_server_recipientid
            Parameter](#name-the-ace_server_recipientid-){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [OSCORE
        Setup](#name-oscore-setup){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Access Rights
        Verification](#name-access-rights-verification){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Secure Communication with
    AS](#name-secure-communication-with-a){.xref}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Discarding the Security
    Context](#name-discarding-the-security-con){.xref}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Privacy
    Considerations](#name-privacy-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [ACE Profile
        Registry](#name-ace-profile-registry){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [OAuth Parameters
        Registry](#name-oauth-parameters-registry){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.3}
        [9.3](#section-9.3){.xref}.  [OAuth Parameters CBOR Mappings
        Registry](#name-oauth-parameters-cbor-mappi){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.4}
        [9.4](#section-9.4){.xref}.  [OSCORE Security Context Parameters
        Registry](#name-oscore-security-context-par){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.5}
        [9.5](#section-9.5){.xref}.  [CWT Confirmation Methods
        Registry](#name-cwt-confirmation-methods-re){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.6}
        [9.6](#section-9.6){.xref}.  [JWT Confirmation Methods
        Registry](#name-jwt-confirmation-methods-re){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.7}
        [9.7](#section-9.7){.xref}.  [Expert Review
        Instructions](#name-expert-review-instructions){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.10.2.1}
        [10.1](#section-10.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [10.2](#section-10.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [Appendix A](#appendix-A){.xref}.  [Profile
    Requirements](#name-profile-requirements){.xref}
    :::

-   ::: {#section-toc.1-1.12}
    [](#appendix-B){.xref}[Acknowledgments](#name-acknowledgments){.xref}
    :::

-   ::: {#section-toc.1-1.13}
    [](#appendix-C){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

This document specifies the `coap_oscore` profile of the ACE framework
\[[RFC9200](#RFC9200){.xref}\]. In this profile, a client (C) and a
resource server (RS) use the Constrained Application Protocol (CoAP)
\[[RFC7252](#RFC7252){.xref}\] to communicate. The client uses an access
token, bound to a symmetric key (the proof-of-possession (PoP) key) to
authorize its access to the resource server. Note that this profile uses
a symmetric-crypto-based scheme, where the symmetric secret is used as
input material for keying material derivation. In order to provide
communication security and PoP, the client and resource server use
Object Security for Constrained RESTful Environments (OSCORE) as defined
in \[[RFC8613](#RFC8613){.xref}\]. Note that the PoP is not achieved
through a dedicated protocol element but rather occurs after the first
message exchange using OSCORE.[¶](#section-1-1){.pilcrow}

OSCORE specifies how to use CBOR Object Signing and Encryption (COSE)
\[[RFC9052](#RFC9052){.xref}\] \[[RFC9053](#RFC9053){.xref}\] to secure
CoAP messages. Note that OSCORE can be used to secure CoAP messages, as
well as HTTP and combinations of HTTP and CoAP; a profile of ACE similar
to the one described in this document, with the difference of using HTTP
instead of CoAP as the communication protocol, could be specified
analogously to this one.[¶](#section-1-2){.pilcrow}

::: {#terminology}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-1){.pilcrow}

Certain security-related terms such as \"authentication\",
\"authorization\", \"confidentiality\", \"(data) integrity\", \"Message
Authentication Code (MAC)\", \"Hash-based Message Authentication Code
(HMAC)\", and \"verify\" are taken from
\[[RFC4949](#RFC4949){.xref}\].[¶](#section-1.1-2){.pilcrow}

RESTful terminology follows HTTP
\[[RFC9110](#RFC9110){.xref}\].[¶](#section-1.1-3){.pilcrow}

Readers are expected to be familiar with the terms and concepts defined
in OSCORE \[[RFC8613](#RFC8613){.xref}\], such as \"security context\"
and \"Recipient ID\".[¶](#section-1.1-4){.pilcrow}

Terminology for entities in the architecture is defined in OAuth 2.0
\[[RFC6749](#RFC6749){.xref}\], such as client (C), resource server
(RS), and authorization server (AS). It is assumed in this document that
a given resource on a specific RS is associated to a unique
AS.[¶](#section-1.1-5){.pilcrow}

Concise Binary Object Representation (CBOR)
\[[RFC8949](#RFC8949){.xref}\] and Concise Data Definition Language
(CDDL) \[[RFC8610](#RFC8610){.xref}\] are used in this document. CDDL
predefined type names, especially \"bstr\" for CBOR byte strings and
\"tstr\" for CBOR text strings, are used extensively in this
document.[¶](#section-1.1-6){.pilcrow}

Note that the term \"endpoint\" is used as in
\[[RFC9200](#RFC9200){.xref}\], following its OAuth definition, which is
to denote resources such as token and introspect at the AS and
authz-info at the RS. The CoAP definition, which is \"\[a\]n entity
participating in the CoAP protocol\" \[[RFC7252](#RFC7252){.xref}\], is
not used in this document.[¶](#section-1.1-7){.pilcrow}

Throughout this document, examples for CBOR data items are expressed in
CBOR extended diagnostic notation as defined in [Section
8](https://www.rfc-editor.org/rfc/rfc8949#section-8){.relref} of
\[[RFC8949](#RFC8949){.xref}\] and [Appendix
G](https://www.rfc-editor.org/rfc/rfc8610#appendix-G){.relref} of
\[[RFC8610](#RFC8610){.xref}\] (\"diagnostic notation\"), unless noted
otherwise. We often use diagnostic notation comments to provide a
textual representation of the numeric parameter names and
values.[¶](#section-1.1-8){.pilcrow}

In this document, the term \"base64-encoded\" refers to URL-Safe base64
encoding (see [Section
5](https://www.rfc-editor.org/rfc/rfc4648#section-5){.relref} of
\[[RFC4648](#RFC4648){.xref}\]) without
padding.[¶](#section-1.1-9){.pilcrow}
:::
:::
:::
:::

::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Protocol Overview](#name-protocol-overview){.section-name .selfRef} {#name-protocol-overview}

This section gives an overview of how to use the ACE Framework
\[[RFC9200](#RFC9200){.xref}\] to secure the communication between a
client and a resource server using OSCORE
\[[RFC8613](#RFC8613){.xref}\]. The parameters needed by the client to
negotiate the use of this profile with the AS, as well as the OSCORE
setup process, are described in detail in the following
sections.[¶](#section-2-1){.pilcrow}

The RS maintains a collection of OSCORE security contexts with
associated authorization information for all the clients that it is
communicating with. The authorization information is maintained as
policy that is used as input to processing requests from those
clients.[¶](#section-2-2){.pilcrow}

This profile requires a client to retrieve an access token from the AS
for the resource it wants to access on an RS, by sending an access token
request to the token endpoint, as specified in [Section
5.8](https://www.rfc-editor.org/rfc/rfc9200#section-5.8){.relref} of
\[[RFC9200](#RFC9200){.xref}\]. The access token request and response
[MUST]{.bcp14} be confidentiality protected and ensure authenticity. The
use of OSCORE between the client and AS is [RECOMMENDED]{.bcp14} in this
profile, to reduce the number of libraries the client has to support,
but other protocols fulfilling the security requirements defined in
[Section 5](https://www.rfc-editor.org/rfc/rfc9200#section-5){.relref}
of \[[RFC9200](#RFC9200){.xref}\] [MAY]{.bcp14} alternatively be used,
such as TLS \[[RFC8446](#RFC8446){.xref}\] or DTLS
\[[RFC9147](#RFC9147){.xref}\].[¶](#section-2-3){.pilcrow}

Once the client has retrieved the access token, it generates a nonce N1,
as defined in this document (see [Section 4.1.1](#nonce1){.xref}). The
client also generates its own OSCORE Recipient ID, ID1 (see [Section
3.1](https://www.rfc-editor.org/rfc/rfc8613#section-3.1){.relref} of
\[[RFC8613](#RFC8613){.xref}\]), for use with the keying material
associated to the RS. The client posts the token, N1, and its Recipient
ID to the RS using the authz-info endpoint and mechanisms specified in
[Section
5.8](https://www.rfc-editor.org/rfc/rfc9200#section-5.8){.relref} of
\[[RFC9200](#RFC9200){.xref}\] and Content-Format =
application/ace+cbor. When using this profile, the communication with
the authz-info endpoint is not protected, except for the update of
access rights.[¶](#section-2-4){.pilcrow}

If the access token is valid, the RS replies to this request with a 2.01
(Created) response with Content-Format = application/ace+cbor, which
contains a nonce N2 and its newly generated OSCORE Recipient ID, ID2,
for use with the keying material associated to the client. Moreover, the
server concatenates the input salt received in the token, N1, and N2 to
obtain the Master Salt of the OSCORE security context (see [Section
3](https://www.rfc-editor.org/rfc/rfc8613#section-3){.relref} of
\[[RFC8613](#RFC8613){.xref}\]). The RS then derives the complete
security context associated with the received token from the Master
Salt; the OSCORE Recipient ID generated by the client (set as its OSCORE
Sender ID); its own OSCORE Recipient ID; plus the parameters received in
the access token from the AS, following [Section
3.2](https://www.rfc-editor.org/rfc/rfc8613#section-3.2){.relref} of
\[[RFC8613](#RFC8613){.xref}\].[¶](#section-2-5){.pilcrow}

In a similar way, after receiving the nonce N2, the client concatenates
the input salt, N1, and N2 to obtain the Master Salt of the OSCORE
security context. The client then derives the complete security context
from the Master Salt; the OSCORE Recipient ID generated by the RS (set
as its OSCORE Sender ID); its own OSCORE Recipient ID; plus the
parameters received from the AS.[¶](#section-2-6){.pilcrow}

Finally, the client starts the communication with the RS by sending a
request protected with OSCORE to the RS. If the request is successfully
verified, the server stores the complete security context state that is
ready for use in protecting messages and uses it in the response, and in
further communications with the client, until token deletion due to, for
example, expiration. This security context is discarded when a token
(whether the same or a different one) is used to successfully derive a
new security context for that client.[¶](#section-2-7){.pilcrow}

The use of nonces N1 and N2 during the exchange prevents the reuse of an
Authenticated Encryption with Associated Data (AEAD) nonce/key pair for
two different messages. Reuse might otherwise occur when the client and
RS derive a new security context from an existing (non-expired) access
token, as might occur when either party has just rebooted, and that
might lead to loss of both confidentiality and integrity. Instead, by
using the exchanged nonces N1 and N2 as part of the Master Salt, the
request to the authz-info endpoint posting the same token results in a
different security context, by OSCORE construction, since even though
the Master Secret, Sender ID, and Recipient ID are the same, the Master
Salt is different (see [Section
3.2.1](https://www.rfc-editor.org/rfc/rfc8613#section-3.2.1){.relref} of
\[[RFC8613](#RFC8613){.xref}\]). If the exchanged nonces were reused, a
node reusing a non-expired old token would be susceptible to on-path
attackers provoking the creation of an OSCORE message using an old AEAD
key and nonce.[¶](#section-2-8){.pilcrow}

After the whole message exchange has taken place, the client can contact
the AS to request an update of its access rights, sending a similar
request to the token endpoint that also includes an identifier so that
the AS can find the correct OSCORE Input Material it has previously
shared with the client. This specific identifier, encoded as a byte
string, is assigned by the AS to be unique in the sets of its OSCORE
Input Materials, and it is not used as input material to derive the full
OSCORE security context.[¶](#section-2-9){.pilcrow}

An overview of the profile flow for the OSCORE profile is given in
[Figure 1](#prof-overview){.xref}. The names of messages coincide with
those of \[[RFC9200](#RFC9200){.xref}\] when
applicable.[¶](#section-2-10){.pilcrow}

[]{#name-protocol-overview-2}

::: {#prof-overview}
::: {#section-2-11.1 .alignLeft .art-text .artwork}
       C                            RS                   AS
       |                            |                     |
       | ----- POST /token  ----------------------------> |
       |                            |                     |
       | <---------------------------- Access Token ----- |
       |                           + Access Information   |
       | ---- POST /authz-info ---> |                     |
       |   (access_token, N1, ID1)  |                     |
       |                            |                     |
       | <- 2.01 Created (N2, ID2)- |                     |
       |                            |                     |
     /Sec Context             /Sec Context                |
       derivation/              derivation/               |
       |                            |                     |
       | ---- OSCORE Request -----> |                     |
       |                            |                     |
       |                    /proof-of-possession          |
       |                    Sec Context storage/          |
       |                            |                     |
       | <--- OSCORE Response ----- |                     |
       |                            |                     |
    /proof-of-possession            |                     |
    Sec Context storage/            |                     |
       |                            |                     |
       | ---- OSCORE Request -----> |                     |
       |                            |                     |
       | <--- OSCORE Response ----- |                     |
       |                            |                     |
       |           ...              |                     |
:::

[Figure 1](#figure-1){.selfRef}: [Protocol
Overview](#name-protocol-overview-2){.selfRef}
:::
:::

::: {#client-as}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Client-AS Communication](#name-client-as-communication){.section-name .selfRef} {#name-client-as-communication}

The following subsections describe the details of the POST request and
response to the token endpoint between the client and AS. [Section
3.2](https://www.rfc-editor.org/rfc/rfc8613#section-3.2){.relref} of
\[[RFC8613](#RFC8613){.xref}\] defines how to derive a security context
based on a shared Master Secret and a set of other parameters,
established between the client and server, which the client receives
from the AS in this exchange. The PoP key included in the response from
the AS [MUST]{.bcp14} be used as a Master Secret in
OSCORE.[¶](#section-3-1){.pilcrow}

::: {#c-as}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [C-to-AS: POST to Token Endpoint](#name-c-to-as-post-to-token-endpo){.section-name .selfRef} {#name-c-to-as-post-to-token-endpo}

The client-to-AS request is specified in [Section
5.8.1](https://www.rfc-editor.org/rfc/rfc9200#section-5.8.1){.relref} of
\[[RFC9200](#RFC9200){.xref}\].[¶](#section-3.1-1){.pilcrow}

The client must send this POST request to the token endpoint over a
secure channel that guarantees authentication, message integrity, and
confidentiality (see [Section
5](#introsp){.xref}).[¶](#section-3.1-2){.pilcrow}

An example of such a request is shown in [Figure
2](#ex0){.xref}.[¶](#section-3.1-3){.pilcrow}

[]{#name-example-c-to-as-post-token-}

::: {#ex0}
::: {#section-3.1-4.1}
``` {.lang-cbor-diag .sourcecode}
    Header: POST (Code=0.02)
    Uri-Host: "as.example.com"
    Uri-Path: "token"
    Content-Format: application/ace+cbor
    Payload:
    {
      / audience / 5 : "tempSensor4711",
         / scope / 9 : "read"
    }
```
:::

[Figure 2](#figure-2){.selfRef}: [Example C-to-AS POST /token Request
for an Access Token Bound to a Symmetric
Key](#name-example-c-to-as-post-token-){.selfRef}
:::

If the client wants to update its access rights without changing an
existing OSCORE security context, it [MUST]{.bcp14} include a `req_cnf`
object in its POST request to the token endpoint, with the `kid` field
carrying a CBOR byte string containing the OSCORE Input Material
identifier (assigned as discussed in [Section 3.2](#as-c){.xref}). This
identifier, together with other information such as audience (see
[Section
5.8.1](https://www.rfc-editor.org/rfc/rfc9200#section-5.8.1){.relref} of
\[[RFC9200](#RFC9200){.xref}\]), can be used by the AS to determine the
shared secret bound to the proof-of-possession token; therefore, it
[MUST]{.bcp14} identify a symmetric key that was previously generated by
the AS as a shared secret for the communication between the client and
the RS. The AS [MUST]{.bcp14} verify that the received value identifies
a proof-of-possession key that has previously been issued to the
requesting client. If that is not the case, the client-to-AS request
[MUST]{.bcp14} be declined with the error code `invalid_request` as
defined in [Section
5.8.3](https://www.rfc-editor.org/rfc/rfc9200#section-5.8.3){.relref} of
\[[RFC9200](#RFC9200){.xref}\].[¶](#section-3.1-5){.pilcrow}

An example of such a request is shown in [Figure
3](#ex7){.xref}.[¶](#section-3.1-6){.pilcrow}

[]{#name-example-c-to-as-post-token-r}

::: {#ex7}
::: {#section-3.1-7.1}
``` {.lang-cbor-diag .sourcecode}
    Header: POST (Code=0.02)
    Uri-Host: "as.example.com"
    Uri-Path: "token"
    Content-Format: application/ace+cbor
    Payload:
    {
      / audience / 5 : "tempSensor4711",
         / scope / 9 : "write",
       / req_cnf / 4 : {
             / kid / 3 : h'01'
      }
    }
```
:::

[Figure 3](#figure-3){.selfRef}: [Example C-to-AS POST /token Request
for Updating Rights to an Access Token Bound to a Symmetric
Key](#name-example-c-to-as-post-token-r){.selfRef}
:::
:::
:::

::: {#as-c}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [AS-to-C: Access Token](#name-as-to-c-access-token){.section-name .selfRef} {#name-as-to-c-access-token}

After verifying the POST request to the token endpoint and that the
client is authorized to obtain an access token corresponding to its
access token request, the AS responds as defined in [Section
5.8.2](https://www.rfc-editor.org/rfc/rfc9200#section-5.8.2){.relref} of
\[[RFC9200](#RFC9200){.xref}\]. If the client request was invalid, or
not authorized, the AS returns an error response as described in
[Section
5.8.3](https://www.rfc-editor.org/rfc/rfc9200#section-5.8.3){.relref} of
\[[RFC9200](#RFC9200){.xref}\].[¶](#section-3.2-1){.pilcrow}

The AS can signal that the use of OSCORE is [REQUIRED]{.bcp14} for a
specific access token by including the `ace_profile` parameter with the
value `coap_oscore` in the access token response. This means that the
client [MUST]{.bcp14} use OSCORE towards all resource servers for which
this access token is valid, and follow [Section
4.3](#oscore-setup){.xref} to derive the security context to run OSCORE.
Usually, it is assumed that constrained devices will be preconfigured
with the necessary profile, so that this kind of profile signaling can
be omitted.[¶](#section-3.2-2){.pilcrow}

Moreover, the AS [MUST]{.bcp14} send the following
data:[¶](#section-3.2-3){.pilcrow}

-   [a Master Secret[¶](#section-3.2-4.1){.pilcrow}]{#section-3.2-4.1}
-   [an identifier of the OSCORE Input
    Material[¶](#section-3.2-4.2){.pilcrow}]{#section-3.2-4.2}

Additionally, the AS [MAY]{.bcp14} send the following data, in the same
response.[¶](#section-3.2-5){.pilcrow}

-   [a context
    identifier[¶](#section-3.2-6.1){.pilcrow}]{#section-3.2-6.1}
-   [an AEAD algorithm[¶](#section-3.2-6.2){.pilcrow}]{#section-3.2-6.2}
-   [an HMAC-based key derivation function (HKDF) algorithm
    \[[RFC5869](#RFC5869){.xref}\]. It is specified by the HMAC
    algorithm value; see [Section
    3.1](https://www.rfc-editor.org/rfc/rfc9053#section-3.1){.relref} of
    \[[RFC9053](#RFC9053){.xref}\].[¶](#section-3.2-6.3){.pilcrow}]{#section-3.2-6.3}
-   [a salt[¶](#section-3.2-6.4){.pilcrow}]{#section-3.2-6.4}
-   [the OSCORE version
    number[¶](#section-3.2-6.5){.pilcrow}]{#section-3.2-6.5}

This data is transported in the OSCORE_Input_Material. The
OSCORE_Input_Material is a CBOR map object, defined in [Section
3.2.1](#oscore-sec-ctx){.xref}. This object is transported in the `cnf`
parameter of the access token response, as defined in [Section
3.2](https://www.rfc-editor.org/rfc/rfc9201#section-3.2){.relref} of
\[[RFC9201](#RFC9201){.xref}\], as the value of a field named `osc`,
which is registered in Sections [9.5](#osc-cwt){.xref} and
[9.6](#osc-jwt){.xref}.[¶](#section-3.2-7){.pilcrow}

The AS [MAY]{.bcp14} assign an identifier to the context (context
identifier). This identifier is used as ID Context in the OSCORE context
as described in [Section
3.1](https://www.rfc-editor.org/rfc/rfc8613#section-3.1){.relref} of
\[[RFC8613](#RFC8613){.xref}\]. If assigned, these parameters
[MUST]{.bcp14} be communicated as the `contextId` field in the
OSCORE_Input_Material. The application needs to consider that this
identifier is sent in the clear and may reveal information about the
endpoints, as mentioned in [Section
12.8](https://www.rfc-editor.org/rfc/rfc8613#section-12.8){.relref} of
\[[RFC8613](#RFC8613){.xref}\].[¶](#section-3.2-8){.pilcrow}

The Master Secret and the identifier of the OSCORE_Input_Material
[MUST]{.bcp14} be communicated as the `ms` and `id` field in the `osc`
field in the `cnf` parameter of the access token response. If included,
the following are sent: the AEAD algorithm in the `alg` parameter in the
OSCORE_Input_Material; the HKDF algorithm in the `hkdf` parameter of the
OSCORE_Input_Material; a salt in the `salt` parameter of the
OSCORE_Input_Material; and the OSCORE version in the `version` parameter
of the OSCORE_Input_Material.[¶](#section-3.2-9){.pilcrow}

The same parameters [MUST]{.bcp14} be included in the claims associated
with the access token. The OSCORE Master Secret [MUST]{.bcp14} be
encrypted by the authorization server so that only the resource server
can decrypt it (see [Section
6.1](https://www.rfc-editor.org/rfc/rfc9200#section-6.1){.relref} of
\[[RFC9200](#RFC9200){.xref}\]). The use of a CBOR Web Token (CWT)
protected with COSE_Encrypt/COSE_Encrypt0 as specified in
\[[RFC8392](#RFC8392){.xref}\] is [RECOMMENDED]{.bcp14} in this profile.
If the token is a CWT, the same OSCORE_Input_Material structure defined
above [MUST]{.bcp14} be placed in the `osc` field of the `cnf` claim of
this token.[¶](#section-3.2-10){.pilcrow}

The AS [MUST]{.bcp14} send a different OSCORE_Input_Material (and
therefore different access tokens) to different authorized clients, in
order for the RS to differentiate between
clients.[¶](#section-3.2-11){.pilcrow}

[Figure 4](#ex1){.xref} shows an example of an AS response. The access
token has been truncated for readability.[¶](#section-3.2-12){.pilcrow}

[]{#name-example-as-to-c-access-toke}

::: {#ex1}
::: {#section-3.2-13.1}
``` {.lang-cbor-diag .sourcecode}
    Header: Created (Code=2.01)
    Content-Type: application/ace+cbor
    Payload:
    {
      / access_token / 1 : h'8343a1010aa2044c53/...
       (remainder of access token (CWT) omitted for brevity)/',
      / ace_profile / 38 : / coap_oscore / 2,
        / expires_in / 2 : 3600,
               / cnf / 8 : {
                 / osc / 4 : {
                    / id / 0 : h'01',
                    / ms / 2 : h'f9af838368e353e78888e1426bd94e6f'
        }
      }
    }
```
:::

[Figure 4](#figure-4){.selfRef}: [Example AS-to-C Access Token Response
with an OSCORE Profile](#name-example-as-to-c-access-toke){.selfRef}
:::

[Figure 5](#ex2){.xref} shows an example CWT Claims Set, including the
relevant OSCORE parameters in the `cnf`
claim.[¶](#section-3.2-14){.pilcrow}

[]{#name-example-cwt-claims-set-with}

::: {#ex2}
::: {#section-3.2-15.1}
``` {.lang-cbor-diag .sourcecode}
{
    / aud / 3 : "tempSensorInLivingRoom",
    / iat / 6 : 1360189224,
    / exp / 4 : 1360289224,
  / scope / 9 :  "temperature_g firmware_p",
    / cnf / 8 : {
      / osc / 4 : {
         / id / 0 : h'01',
         / ms / 2 : h'f9af838368e353e78888e1426bd94e6f'
    }
  }
}
```
:::

[Figure 5](#figure-5){.selfRef}: [Example CWT Claims Set with OSCORE
Parameters](#name-example-cwt-claims-set-with){.selfRef}
:::

The same CWT Claims Set as in [Figure 5](#ex2){.xref}, using the value
abbreviations defined in \[[RFC9200](#RFC9200){.xref}\] and
\[[RFC8747](#RFC8747){.xref}\] and encoded in CBOR, is shown in [Figure
6](#ex2-cbor){.xref}. The bytes in hexadecimal are reported in the first
column, while their corresponding CBOR meaning is reported after the `#`
sign on the second column, for
readability.[¶](#section-3.2-16){.pilcrow}

[]{#name-example-cwt-claims-set-with-}

::: {#ex2-cbor}
::: {#section-3.2-17.1}
``` {.lang-cbor-pretty .sourcecode}
A5                              # map(5)
   03                           # unsigned(3)
   76                           # text(22)
      74656D7053656E736F72496E4C6976696E67526F6F6D
                                # "tempSensorInLivingRoom"
   06                           # unsigned(6)
   1A 5112D728                  # unsigned(1360189224)
   04                           # unsigned(4)
   1A 51145DC8                  # unsigned(1360289224)
   09                           # unsigned(9)
   78 18                        # text(24)
      74656D70657261747572655F67206669726D776172655F70
                                # "temperature_g firmware_p"
   08                           # unsigned(8)
      A1                        # map(1)
         04                     # unsigned(4)
            A2                  # map(2)
               00               # unsigned(0)
               41               # bytes(1)
                  01
               02               # unsigned(2)
               50               # bytes(16)
                  F9AF838368E353E78888E1426BD94E6F
```
:::

[Figure 6](#figure-6){.selfRef}: [Example CWT Claims Set with OSCORE
Parameters Using CBOR
Encoding](#name-example-cwt-claims-set-with-){.selfRef}
:::

If the client has requested an update to its access rights using the
same OSCORE security context, which is valid and authorized, the AS
[MUST]{.bcp14} omit the `cnf` parameter in the response and
[MUST]{.bcp14} carry the OSCORE Input Material identifier in the `kid`
field in the `cnf` claim of the token. This identifier needs to be
included in the token in order for the RS to identify the correct OSCORE
Input Material.[¶](#section-3.2-18){.pilcrow}

[Figure 7](#ex5){.xref} shows an example of such an AS response. The
access token has been truncated for
readability.[¶](#section-3.2-19){.pilcrow}

[]{#name-example-as-to-c-access-token}

::: {#ex5}
::: {#section-3.2-20.1}
``` {.lang-cbor-diag .sourcecode}
    Header: Created (Code=2.01)
    Content-Type: application/ace+cbor
    Payload:
    {
      / access_token / 1 : h'8343a1010aa2044c53/ ...
       (remainder of access token (CWT) omitted for brevity)/',
      / ace_profile / 38 : / coap_oscore / 2,
        / expires_in / 2 : 3600
    }
```
:::

[Figure 7](#figure-7){.selfRef}: [Example AS-to-C Access Token Response
with an OSCORE Profile for the Update of Access
Rights](#name-example-as-to-c-access-token){.selfRef}
:::

[Figure 8](#ex6){.xref} shows an example CWT Claims Set that contains
the necessary OSCORE parameters in the `cnf` claim for the update of
access rights.[¶](#section-3.2-21){.pilcrow}

[]{#name-example-cwt-claims-set-with-o}

::: {#ex6}
::: {#section-3.2-22.1}
``` {.lang-cbor-diag .sourcecode}
  {
      / aud / 3 : "tempSensorInLivingRoom",
      / iat / 6 : 1360189224,
      / exp / 4 : 1360289224,
    / scope / 9 :  "temperature_h",
      / cnf / 8 : {
        / kid / 3 : h'01'
    }
  }
```
:::

[Figure 8](#figure-8){.selfRef}: [Example CWT Claims Set with OSCORE
Parameters for the Update of Access
Rights](#name-example-cwt-claims-set-with-o){.selfRef}
:::

::: {#oscore-sec-ctx}
::: {#section-3.2.1 .section}
#### [3.2.1.](#section-3.2.1){.section-number .selfRef} [The OSCORE_Input_Material](#name-the-oscore_input_material){.section-name .selfRef} {#name-the-oscore_input_material}

An OSCORE_Input_Material is an object that represents the input material
to derive an OSCORE security context, i.e., the local set of information
elements necessary to carry out the cryptographic operations in OSCORE
([Section
3.1](https://www.rfc-editor.org/rfc/rfc8613#section-3.1){.relref} of
\[[RFC8613](#RFC8613){.xref}\]). In particular, the
OSCORE_Input_Material is defined to be serialized and transported
between nodes, as specified by this document, but it can also be used by
other specifications if needed. The OSCORE_Input_Material can be encoded
as either a JSON object or a CBOR map. The set of common parameters that
can appear in an OSCORE_Input_Material can be found in the IANA \"OSCORE
Security Context Parameters\" registry ([Section
9.4](#sec-ctx-params-reg){.xref}), defined for extensibility, and the
initial set of parameters defined in this document is specified below.
All parameters are optional. [Table 1](#key-labels){.xref} provides a
summary of the OSCORE_Input_Material parameters defined in this
section.[¶](#section-3.2.1-1){.pilcrow}

[]{#name-oscore_input_material-param}

::: {#key-labels}
  name        CBOR label   CBOR type               registry                                                             description
  ----------- ------------ ----------------------- -------------------------------------------------------------------- --------------------------------------
  id          0            byte string                                                                                  OSCORE Input Material identifier
  version     1            unsigned integer                                                                             OSCORE version
  ms          2            byte string                                                                                  OSCORE Master Secret value
  hkdf        3            text string / integer   \[[COSE.Algorithms](#COSE.Algorithms){.xref}\] values (HMAC-based)   OSCORE HKDF value
  alg         4            text string / integer   \[[COSE.Algorithms](#COSE.Algorithms){.xref}\] values (AEAD)         OSCORE AEAD Algorithm value
  salt        5            byte string                                                                                  an input to OSCORE Master Salt value
  contextId   6            byte string                                                                                  OSCORE ID Context value

  : [Table 1](#table-1){.selfRef}: [OSCORE_Input_Material
  Parameters](#name-oscore_input_material-param){.selfRef}
:::

[]{.break}

id:
:   This parameter identifies the OSCORE_Input_Material and is encoded
    as a byte string. In JSON, the `id` value is a base64-encoded byte
    string. In CBOR, the `id` type is a byte string, and it has label
    0.[¶](#section-3.2.1-3.2){.pilcrow}
:   

version:
:   This parameter identifies the OSCORE version number, which is an
    unsigned integer. For more information about this field, see
    [Section
    5.4](https://www.rfc-editor.org/rfc/rfc8613#section-5.4){.relref} of
    \[[RFC8613](#RFC8613){.xref}\]. In JSON, the `version` value is an
    integer. In CBOR, the `version` type is an integer, and it has label
    1.[¶](#section-3.2.1-3.4){.pilcrow}
:   

ms:
:   This parameter identifies the OSCORE Master Secret value, which is a
    byte string. For more information about this field, see [Section
    3.1](https://www.rfc-editor.org/rfc/rfc8613#section-3.1){.relref} of
    \[[RFC8613](#RFC8613){.xref}\]. In JSON, the `ms` value is a
    base64-encoded byte string. In CBOR, the `ms` type is byte string,
    and it has label 2.[¶](#section-3.2.1-3.6){.pilcrow}
:   

hkdf:
:   This parameter identifies the OSCORE HKDF Algorithm. For more
    information about this field, see [Section
    3.1](https://www.rfc-editor.org/rfc/rfc8613#section-3.1){.relref} of
    \[[RFC8613](#RFC8613){.xref}\]. The values used [MUST]{.bcp14} be
    registered in the IANA \"COSE Algorithms\" registry (see
    \[[COSE.Algorithms](#COSE.Algorithms){.xref}\]) and [MUST]{.bcp14}
    be HMAC-based HKDF algorithms (see [Section
    3.1](https://www.rfc-editor.org/rfc/rfc9053#section-3.1){.relref} of
    \[[RFC9053](#RFC9053){.xref}\]). The value can be either the integer
    or the text-string value of the HMAC-based HKDF algorithm in the
    \"COSE Algorithms\" registry. In JSON, the `hkdf` value is a
    case-sensitive ASCII string or an integer. In CBOR, the `hkdf` type
    is a text string or integer, and it has label
    3.[¶](#section-3.2.1-3.8){.pilcrow}
:   

alg:
:   This parameter identifies the OSCORE AEAD Algorithm. For more
    information about this field, see [Section
    3.1](https://www.rfc-editor.org/rfc/rfc8613#section-3.1){.relref} of
    \[[RFC8613](#RFC8613){.xref}\]. The values used [MUST]{.bcp14} be
    registered in the IANA \"COSE Algorithms\" registry (see
    \[[COSE.Algorithms](#COSE.Algorithms){.xref}\]) and [MUST]{.bcp14}
    be AEAD algorithms. The value can be either the integer or the
    text-string value of the HMAC-based HKDF algorithm in the \"COSE
    Algorithms\" registry. In JSON, the `alg` value is a case-sensitive
    ASCII string or an integer. In CBOR, the `alg` type is a text string
    or integer, and it has label 4.[¶](#section-3.2.1-3.10){.pilcrow}
:   

salt:
:   This parameter identifies an input to the OSCORE Master Salt value,
    which is a byte string. For more information about this field, see
    [Section
    3.1](https://www.rfc-editor.org/rfc/rfc8613#section-3.1){.relref} of
    \[[RFC8613](#RFC8613){.xref}\]. In JSON, the `salt` value is a
    base64-encoded byte string. In CBOR, the `salt` type is a byte
    string, and it has label 5.[¶](#section-3.2.1-3.12){.pilcrow}
:   

contextId:
:   This parameter identifies the security context as a byte string.
    This identifier is used as OSCORE ID Context. For more information
    about this field, see [Section
    3.1](https://www.rfc-editor.org/rfc/rfc8613#section-3.1){.relref} of
    \[[RFC8613](#RFC8613){.xref}\]. In JSON, the `contextID` value is a
    base64-encoded byte string. In CBOR, the `contextID` type is a byte
    string, and it has label 6.[¶](#section-3.2.1-3.14){.pilcrow}
:   

An example of JSON OSCORE_Input_Material is given in [Figure
9](#JSON-osc){.xref}.[¶](#section-3.2.1-4){.pilcrow}

[]{#name-example-json-oscore_input_m}

::: {#JSON-osc}
::: {#section-3.2.1-5.1}
``` {.lang-json .sourcecode}
                "osc" : {
                  "alg" : "AES-CCM-16-64-128",
                   "id" : "AQ",
                   "ms" : "-a-Dg2jjU-eIiOFCa9lObw"
                }
```
:::

[Figure 9](#figure-9){.selfRef}: [Example JSON
OSCORE_Input_Material](#name-example-json-oscore_input_m){.selfRef}
:::

The CDDL grammar describing the CBOR OSCORE_Input_Material is shown in
[Figure 10](#CDDL-osc){.xref}.[¶](#section-3.2.1-6){.pilcrow}

[]{#name-cddl-grammar-of-the-oscore_}

::: {#CDDL-osc}
::: {#section-3.2.1-7.1}
``` {.lang-cddl .sourcecode}
OSCORE_Input_Material = {
    ? 0 => bstr,              ; id
    ? 1 => int,               ; version
    ? 2 => bstr,              ; ms
    ? 3 => tstr / int,        ; hkdf
    ? 4 => tstr / int,        ; alg
    ? 5 => bstr,              ; salt
    ? 6 => bstr,              ; contextId
    * (int / tstr) => any
}
```
:::

[Figure 10](#figure-10){.selfRef}: [CDDL Grammar of the
OSCORE_Input_Material](#name-cddl-grammar-of-the-oscore_){.selfRef}
:::
:::
:::
:::
:::
:::
:::

::: {#c-rs1}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Client-RS Communication](#name-client-rs-communication){.section-name .selfRef} {#name-client-rs-communication}

The following subsections describe the details of the POST request and
response to the authz-info endpoint between the client and RS. The
client generates a nonce N1 and an identifier ID1 that is unique in the
sets of its own Recipient IDs and posts them together with the token
that includes the materials (e.g., OSCORE parameters) received from the
AS to the RS. The RS then generates a nonce N2 and an identifier ID2
that is unique in the sets of its own Recipient IDs and uses [Section
3.2](https://www.rfc-editor.org/rfc/rfc8613#section-3.2){.relref} of
\[[RFC8613](#RFC8613){.xref}\] to derive a security context based on a
shared Master Secret, the two exchanged nonces, and the two identifiers,
established between the client and server. The exchanged nonces and
identifiers are encoded as a CBOR byte string if CBOR is used and as a
base64 string if JSON is used. This security context is used to protect
all future communication between the client and RS using OSCORE, as long
as the access token is valid.[¶](#section-4-1){.pilcrow}

Note that the RS and client authenticate each other by generating the
shared OSCORE security context using the PoP key as the Master Secret.
An attacker posting a valid token to the RS will not be able to generate
a valid OSCORE security context and thus will not be able to prove
possession of the PoP key. Additionally, the mutual authentication is
only achieved after the client has successfully verified a response from
the RS protected with the generated OSCORE security
context.[¶](#section-4-2){.pilcrow}

::: {#c-rs}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [C-to-RS: POST to authz-info Endpoint](#name-c-to-rs-post-to-authz-info-){.section-name .selfRef} {#name-c-to-rs-post-to-authz-info-}

The client [MUST]{.bcp14} generate a nonce value N1 that is very
unlikely to have been previously used with the same input keying
material. The use of a 64-bit long random number as the nonce\'s value
is [RECOMMENDED]{.bcp14} in this profile. The client [MUST]{.bcp14}
store the nonce N1 as long as the response from the RS is not received
and the access token related to it is still valid (to the best of the
client\'s knowledge).[¶](#section-4.1-1){.pilcrow}

The client generates its own Recipient ID, ID1, for the OSCORE security
context that it is establishing with the RS. By generating its own
Recipient ID, the client makes sure that it does not collide with any of
its Recipient IDs, nor with any other identifier ID1 if the client is
executing this exchange with a different RS at the same
time.[¶](#section-4.1-2){.pilcrow}

The client [MUST]{.bcp14} use CoAP and the authorization information
resource as described in [Section
5.8.1](https://www.rfc-editor.org/rfc/rfc9200#section-5.8.1){.relref} of
\[[RFC9200](#RFC9200){.xref}\] to transport the token, N1, and ID1 to
the RS.[¶](#section-4.1-3){.pilcrow}

Note that the use of the payload and the Content-Format is different
from what is described in [Section
5.8.1](https://www.rfc-editor.org/rfc/rfc9200#section-5.8.1){.relref} of
\[[RFC9200](#RFC9200){.xref}\], which only transports the token without
any CBOR wrapping. In this profile, the client [MUST]{.bcp14} wrap the
token, N1, and ID1 in a CBOR map. The client [MUST]{.bcp14} use the
Content-Format application/ace+cbor defined in [Section
8.16](https://www.rfc-editor.org/rfc/rfc9200#section-8.16){.relref} of
\[[RFC9200](#RFC9200){.xref}\]. The client [MUST]{.bcp14} include the
access token using the `access_token` parameter; N1 using the `nonce1`
parameter defined in [Section 4.1.1](#nonce1){.xref}; and ID1 using the
`ace_client_recipientid` parameter defined in [Section
4.1.2](#id1){.xref}.[¶](#section-4.1-4){.pilcrow}

The communication with the authz-info endpoint does not have to be
protected, except for the update of access rights case described
below.[¶](#section-4.1-5){.pilcrow}

Note that a client may be required to repost the access token in order
to complete a request, since an RS may delete a stored access token (and
associated security context) at any time, for example, due to all
storage space being consumed. This situation is detected by the client
when it receives an AS Request Creation Hints response. Reposting the
same access token will result in deriving a new OSCORE security context
to be used with the RS, as different exchanged nonces will be
used.[¶](#section-4.1-6){.pilcrow}

The client may also choose to repost the access token in order to update
its OSCORE security context. In that case, the client and the RS will
exchange newly generated nonces, renegotiate identifiers, and derive new
keying material. The client and RS might decide to keep the same
identifiers or renew them during the
renegotiation.[¶](#section-4.1-7){.pilcrow}

[Figure 11](#ex3){.xref} shows an example of the request sent from the
client to the RS. The access token has been truncated for
readability.[¶](#section-4.1-8){.pilcrow}

[]{#name-example-c-to-rs-post-authz-}

::: {#ex3}
::: {#section-4.1-9.1}
``` {.lang-cbor-diag .sourcecode}
      Header: POST (Code=0.02)
      Uri-Host: "rs.example.com"
      Uri-Path: "authz-info"
      Content-Format: application/ace+cbor
      Payload:
        {
                     / access_token / 1 : h'8343a1010aa2044c53/...
       (remainder of access token (CWT) omitted for brevity)/',
                          / nonce1 / 40 : h'018a278f7faab55a',
          / ace_client_recipientid / 43 : h'1645'
        }
```
:::

[Figure 11](#figure-11){.selfRef}: [Example C-to-RS POST /authz-info
Request Using CWT](#name-example-c-to-rs-post-authz-){.selfRef}
:::

If the client has already posted a valid token, has already established
a security association with the RS, and wants to update its access
rights, the client can do so by posting the new token (retrieved from
the AS and containing the update of access rights) to the /authz-info
endpoint. The client [MUST]{.bcp14} protect the request using the OSCORE
security context established during the first token exchange. The client
[MUST]{.bcp14} only send the `access_token` field in the CBOR map in the
payload; no nonce or identifier is sent. After proper verification (see
[Section 4.2](#rs-c){.xref}), the RS will replace the old token with the
new one, maintaining the same security
context.[¶](#section-4.1-10){.pilcrow}

::: {#nonce1}
::: {#section-4.1.1 .section}
#### [4.1.1.](#section-4.1.1){.section-number .selfRef} [The Nonce 1 Parameter](#name-the-nonce-1-parameter){.section-name .selfRef} {#name-the-nonce-1-parameter}

The `nonce1` parameter [MUST]{.bcp14} be sent from the client to the RS,
together with the access token, if the ACE profile used is
`coap_oscore`, and the message is not an update of access rights,
protected with an existing OSCORE security context. The parameter is
encoded as a byte string for CBOR-based interactions and as a string
(base64-encoded binary) for JSON-based interactions. This parameter is
registered in [Section
9.2](#iana-nonces-ids){.xref}.[¶](#section-4.1.1-1){.pilcrow}
:::
:::

::: {#id1}
::: {#section-4.1.2 .section}
#### [4.1.2.](#section-4.1.2){.section-number .selfRef} [The ace_client_recipientid Parameter](#name-the-ace_client_recipientid-){.section-name .selfRef} {#name-the-ace_client_recipientid-}

The `ace_client_recipientid` parameter [MUST]{.bcp14} be sent from the
client to the RS, together with the access token, if the ACE profile
used is `coap_oscore`, and the message is not an update of access
rights, protected with an existing OSCORE security context. The
parameter is encoded as a byte string for CBOR-based interactions and as
a string (base64-encoded binary) for JSON-based interactions. This
parameter is registered in [Section
9.2](#iana-nonces-ids){.xref}.[¶](#section-4.1.2-1){.pilcrow}
:::
:::
:::
:::

::: {#rs-c}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [RS-to-C: 2.01 (Created)](#name-rs-to-c-201-created){.section-name .selfRef} {#name-rs-to-c-201-created}

The RS [MUST]{.bcp14} follow the procedures defined in [Section
5.8.1](https://www.rfc-editor.org/rfc/rfc9200#section-5.8.1){.relref} of
\[[RFC9200](#RFC9200){.xref}\]: the RS must verify the validity of the
token. If the token is valid, the RS must respond to the POST request
with 2.01 (Created). If the token is valid but is associated to claims
that the RS cannot process (e.g., an unknown scope), or if any of the
expected parameters are missing (e.g., any of the mandatory parameters
from the AS or the identifier ID1), or if any parameters received in the
`osc` field are unrecognized, the RS must respond with an error response
code equivalent to the CoAP code 4.00 (Bad Request). In the latter two
cases, the RS may provide additional information in the error response,
in order to clarify what went wrong. The RS may make an introspection
request (see [Section
5.9.1](https://www.rfc-editor.org/rfc/rfc9200#section-5.9.1){.relref} of
\[[RFC9200](#RFC9200){.xref}\]) to validate the token before responding
to the POST request to the authz-info
endpoint.[¶](#section-4.2-1){.pilcrow}

Additionally, the RS [MUST]{.bcp14} generate a nonce N2 that is very
unlikely to have been previously used with the same input keying
material and its own Recipient ID, ID2. The RS makes sure that ID2 does
not collide with any of its Recipient IDs. The RS [MUST]{.bcp14} ensure
that ID2 is different from the value received in the
`ace_client_recipientid` parameter. The RS sends N2 and ID2 within the
2.01 (Created) response. The payload of the 2.01 (Created) response
[MUST]{.bcp14} be a CBOR map containing the `nonce2` parameter defined
in [Section 4.2.1](#nonce2){.xref}, set to N2, and the
`ace_server_recipientid` parameter defined in [Section
4.2.2](#id2){.xref}, set to ID2. The use of a 64-bit long random number
as the nonce\'s value is [RECOMMENDED]{.bcp14} in this profile. The RS
[MUST]{.bcp14} use the Content-Format application/ace+cbor defined in
[Section
8.16](https://www.rfc-editor.org/rfc/rfc9200#section-8.16){.relref} of
\[[RFC9200](#RFC9200){.xref}\].[¶](#section-4.2-2){.pilcrow}

[Figure 12](#ex4){.xref} shows an example of the response sent from the
RS to the client.[¶](#section-4.2-3){.pilcrow}

[]{#name-example-rs-to-c-201-created}

::: {#ex4}
::: {#section-4.2-4.1}
``` {.lang-cbor-diag .sourcecode}
      Header: Created (Code=2.01)
      Content-Format: application/ace+cbor
      Payload:
        {
                          / nonce2 / 42 : h'25a8991cd700ac01',
          / ace_server_recipientid / 44 : h'0000'
        }
```
:::

[Figure 12](#figure-12){.selfRef}: [Example RS-to-C 2.01 (Created)
Response](#name-example-rs-to-c-201-created){.selfRef}
:::

As specified in [Section
5.8.3](https://www.rfc-editor.org/rfc/rfc9200#section-5.8.3){.relref} of
\[[RFC9200](#RFC9200){.xref}\], the RS must notify the client with an
error response with code 4.01 (Unauthorized) for any long running
request before terminating the session, when the access token
expires.[¶](#section-4.2-5){.pilcrow}

If the RS receives the token in an OSCORE-protected message, it means
that the client is requesting an update of access rights. The RS
[MUST]{.bcp14} ignore any nonce and identifiers in the request, if any
were sent. The RS [MUST]{.bcp14} check that the `kid` of the `cnf` claim
of the new access token matches the identifier of the OSCORE Input
Material of the context used to protect the message. If that is the
case, the RS [MUST]{.bcp14} overwrite the old token and associate the
new token to the security context identified by the `kid` value in the
`cnf` claim. The RS [MUST]{.bcp14} respond with a 2.01 (Created)
response protected with the same security context, with no payload. If
any verification fails, the RS [MUST]{.bcp14} respond with a 4.01
(Unauthorized) error response.[¶](#section-4.2-6){.pilcrow}

As specified in [Section
5.8.1](https://www.rfc-editor.org/rfc/rfc9200#section-5.8.1){.relref} of
\[[RFC9200](#RFC9200){.xref}\], when receiving an updated access token
with updated authorization information from the client (see [Section
3.1](#c-as){.xref}), it is recommended that the RS overwrites the
previous token; that is, only the latest authorization information in
the token received by the RS is valid. This simplifies the process
needed by the RS to keep track of authorization information for a given
client.[¶](#section-4.2-7){.pilcrow}

::: {#nonce2}
::: {#section-4.2.1 .section}
#### [4.2.1.](#section-4.2.1){.section-number .selfRef} [The Nonce 2 Parameter](#name-the-nonce-2-parameter){.section-name .selfRef} {#name-the-nonce-2-parameter}

The `nonce2` parameter [MUST]{.bcp14} be sent from the RS to the client
if the ACE profile used is `coap_oscore` and the message is not a
response to an update of access rights, protected with an existing
OSCORE security context. The parameter is encoded as a byte string for
CBOR-based interactions and as a string (base64-encoded binary) for
JSON-based interactions. This parameter is registered in [Section
9.2](#iana-nonces-ids){.xref}[¶](#section-4.2.1-1){.pilcrow}
:::
:::

::: {#id2}
::: {#section-4.2.2 .section}
#### [4.2.2.](#section-4.2.2){.section-number .selfRef} [The ace_server_recipientid Parameter](#name-the-ace_server_recipientid-){.section-name .selfRef} {#name-the-ace_server_recipientid-}

The `ace_server_recipientid` parameter [MUST]{.bcp14} be sent from the
RS to the client if the ACE profile used is `coap_oscore` and the
message is not a response to an update of access rights, protected with
an existing OSCORE security context. The parameter is encoded as a byte
string for CBOR-based interactions and as a string (base64-encoded
binary) for JSON-based interactions. This parameter is registered in
[Section 9.2](#iana-nonces-ids){.xref}[¶](#section-4.2.2-1){.pilcrow}
:::
:::
:::
:::

::: {#oscore-setup}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [OSCORE Setup](#name-oscore-setup){.section-name .selfRef} {#name-oscore-setup}

Once the 2.01 (Created) response is received from the RS, following the
POST request to authz-info endpoint, the client [MUST]{.bcp14} extract
the bstr nonce N2 from the `nonce2` parameter in the CBOR map in the
payload of the response. Then, the client [MUST]{.bcp14} set the Master
Salt of the security context created to communicate with the RS to the
concatenation of salt, N1, and N2 in this order: Master Salt = salt \|
N1 \| N2, where \| denotes byte string concatenation, salt is the CBOR
byte string received from the AS in [Section 3.2](#as-c){.xref}, and N1
and N2 are the two nonces encoded as CBOR byte strings. An example of
Master Salt construction using CBOR encoding is given in [Figure
13](#ms-ex){.xref}.[¶](#section-4.3-1){.pilcrow}

[]{#name-example-of-master-salt-cons}

::: {#ms-ex}
::: {#section-4.3-2.1}
``` sourcecode
N1, N2, and input salt expressed in CBOR diagnostic notation:
      nonce1 = h'018a278f7faab55a'
      nonce2 = h'25a8991cd700ac01'
      input salt = h'f9af838368e353e78888e1426bd94e6f'

N1, N2, and input salt as CBOR encoded byte strings:
      nonce1 = 0x48018a278f7faab55a
      nonce2 = 0x4825a8991cd700ac01
      input salt = 0x50f9af838368e353e78888e1426bd94e6f

Master Salt = 0x50 f9af838368e353e78888e1426bd94e6f
                48 018a278f7faab55a 48 25a8991cd700ac01
```
:::

[Figure 13](#figure-13){.selfRef}: [Example of Master Salt Construction
Using CBOR Encoding](#name-example-of-master-salt-cons){.selfRef}
:::

If JSON is used instead of CBOR, the Master Salt of the security context
is the base64 encoding of the concatenation of the same parameters, each
of them prefixed by their size, encoded in 1 byte. When using JSON, the
nonces and input salt have a maximum size of 255 bytes. An example of
Master Salt construction using base64 encoding is given in [Figure
14](#ms-ex-2){.xref}.[¶](#section-4.3-3){.pilcrow}

[]{#name-example-of-master-salt-const}

::: {#ms-ex-2}
::: {#section-4.3-4.1}
``` sourcecode
N1, N2, and input salt values:
      nonce1 = 0x018a278f7faab55a (8 bytes)
      nonce2 = 0x25a8991cd700ac01 (8 bytes)
      input salt = 0xf9af838368e353e78888e1426bd94e6f (16 bytes)

Input to base64 encoding: 0x10 f9af838368e353e78888e1426bd94e6f
                            08 018a278f7faab55a 08 25a8991cd700ac01

Master Salt = b64'EPmvg4No41PniIjhQmvZTm8IAYonj3+qtVoIJaiZHNcArAE='
```
:::

[Figure 14](#figure-14){.selfRef}: [Example of Master Salt Construction
Using Base64 Encoding](#name-example-of-master-salt-const){.selfRef}
:::

The client [MUST]{.bcp14} set the Sender ID to the
`ace_server_recipientid` received in [Section 4.2](#rs-c){.xref} and set
the Recipient ID to the `ace_client_recipientid` sent in [Section
4.1](#c-rs){.xref}. The client [MUST]{.bcp14} set the Master Secret from
the parameter received from the AS in [Section 3.2](#as-c){.xref}. The
client [MUST]{.bcp14} set the AEAD algorithm, ID Context, HKDF, and
OSCORE version from the parameters received from the AS in [Section
3.2](#as-c){.xref}, if present. In case an optional parameter is
omitted, the default value [SHALL]{.bcp14} be used as described in
Sections
[3.2](https://www.rfc-editor.org/rfc/rfc8613#section-3.2){.relref} and
[5.4](https://www.rfc-editor.org/rfc/rfc8613#section-5.4){.relref} of
\[[RFC8613](#RFC8613){.xref}\]. After that, the client [MUST]{.bcp14}
derive the complete security context following [Section
3.2.1](https://www.rfc-editor.org/rfc/rfc8613#section-3.2.1){.relref} of
\[[RFC8613](#RFC8613){.xref}\]. From this point on, the client
[MUST]{.bcp14} use this security context to communicate with the RS when
accessing the resources as specified by the authorization
information.[¶](#section-4.3-5){.pilcrow}

If any of the expected parameters are missing (e.g., any of the
mandatory parameters from the AS or the RS), or if
`ace_client_recipientid` equals `ace_server_recipientid` (and as a
consequence, the Sender and Recipient Keys derived would be equal; see
[Section
3.3](https://www.rfc-editor.org/rfc/rfc8613#section-3.3){.relref} of
\[[RFC8613](#RFC8613){.xref}\]), then the client [MUST]{.bcp14} stop the
exchange and [MUST NOT]{.bcp14} derive the security context. The client
[MAY]{.bcp14} restart the exchange, to get the correct security
material.[¶](#section-4.3-6){.pilcrow}

The client then uses this security context to send requests to the RS
using OSCORE.[¶](#section-4.3-7){.pilcrow}

After sending the 2.01 (Created) response, the RS [MUST]{.bcp14} set the
Master Salt of the security context created to communicate with the
client to the concatenation of salt, N1, and N2 in the same way
described above. An example of Master Salt construction using CBOR
encoding is given in [Figure 13](#ms-ex){.xref} and using base64
encoding is given in [Figure 14](#ms-ex-2){.xref}. The RS [MUST]{.bcp14}
set the Sender ID from the `ace_client_recipientid` received in [Section
4.1](#c-rs){.xref} and set the Recipient ID from the
`ace_server_recipientid` sent in [Section 4.2](#rs-c){.xref}. The RS
[MUST]{.bcp14} set the Master Secret from the parameter received from
the AS and forwarded by the client in the access token in [Section
4.1](#c-rs){.xref} after validation of the token as specified in
[Section 4.2](#rs-c){.xref}. The RS [MUST]{.bcp14} set the AEAD
algorithm, ID Context, HKDF, and OSCORE version from the parameters
received from the AS and forwarded by the client in the access token in
[Section 4.1](#c-rs){.xref} after validation of the token as specified
in [Section 4.2](#rs-c){.xref}, if present. In case an optional
parameter is omitted, the default value [SHALL]{.bcp14} be used as
described in Sections
[3.2](https://www.rfc-editor.org/rfc/rfc8613#section-3.2){.relref} and
[5.4](https://www.rfc-editor.org/rfc/rfc8613#section-5.4){.relref} of
\[[RFC8613](#RFC8613){.xref}\]. After that, the RS [MUST]{.bcp14} derive
the complete security context following [Section
3.2.1](https://www.rfc-editor.org/rfc/rfc8613#section-3.2.1){.relref} of
\[[RFC8613](#RFC8613){.xref}\] and [MUST]{.bcp14} associate this
security context with the authorization information from the access
token.[¶](#section-4.3-8){.pilcrow}

The RS then uses this security context to verify requests and send
responses to the client using OSCORE. If OSCORE verification fails,
error responses are used, as specified in [Section
8](https://www.rfc-editor.org/rfc/rfc8613#section-8){.relref} of
\[[RFC8613](#RFC8613){.xref}\]. Additionally, if OSCORE verification
succeeds, the verification of access rights is performed as described in
[Section 4.4](#tok-ver){.xref}. The RS [MUST NOT]{.bcp14} use the
security context after the related token has expired and [MUST]{.bcp14}
respond with an unprotected 4.01 (Unauthorized) error message to
requests received that correspond to a security context with an expired
token.[¶](#section-4.3-9){.pilcrow}

Note that the ID Context can be assigned by the AS, communicated and set
in both the RS and client after the exchange specified in this profile
is executed. Subsequently, the client and RS can update their ID Context
by running a mechanism such as the one defined in [Appendix
B.2](https://www.rfc-editor.org/rfc/rfc8613#appendix-B.2){.relref} of
\[[RFC8613](#RFC8613){.xref}\] if they both support it and are
configured to do so. In that case, the ID Context in the OSCORE security
context will not match the `contextId` parameter of the corresponding
OSCORE_Input_Material. Running Appendix
[B.2](https://www.rfc-editor.org/rfc/rfc8613#appendix-B.2){.relref}
results in the keying material being updated in the security contexts of
the client and RS; this same result can also be achieved by the client
reposting the access token to the unprotected /authz-info endpoint at
the RS, as described in [Section 4.1](#c-rs){.xref}, but without
updating the ID Context.[¶](#section-4.3-10){.pilcrow}
:::
:::

::: {#tok-ver}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Access Rights Verification](#name-access-rights-verification){.section-name .selfRef} {#name-access-rights-verification}

The RS [MUST]{.bcp14} follow the procedures defined in [Section
5.8.2](https://www.rfc-editor.org/rfc/rfc9200#section-5.8.2){.relref} of
\[[RFC9200](#RFC9200){.xref}\]: if an RS receives an OSCORE-protected
request from a client, then the RS processes it according to
\[[RFC8613](#RFC8613){.xref}\]. If OSCORE verification succeeds, and the
target resource requires authorization, the RS retrieves the
authorization information using the access token associated to the
security context. The RS then must verify that the authorization
information covers the resource and the action
requested.[¶](#section-4.4-1){.pilcrow}
:::
:::
:::
:::

::: {#introsp}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Secure Communication with AS](#name-secure-communication-with-a){.section-name .selfRef} {#name-secure-communication-with-a}

As specified in the ACE framework ([Section
5.9](https://www.rfc-editor.org/rfc/rfc9200#section-5.9){.relref} of
\[[RFC9200](#RFC9200){.xref}\]), the requesting entity (RS and/or
client) and the AS communicates via the introspection or token endpoint.
The use of CoAP and OSCORE \[[RFC8613](#RFC8613){.xref}\] for this
communication is [RECOMMENDED]{.bcp14} in this profile; other protocols
fulfilling the security requirements defined in [Section
5](https://www.rfc-editor.org/rfc/rfc9200#section-5){.relref} of
\[[RFC9200](#RFC9200){.xref}\] (such as HTTP and DTLS or TLS)
[MAY]{.bcp14} be used instead.[¶](#section-5-1){.pilcrow}

If OSCORE is used, the requesting entity and the AS are expected to have
preestablished security contexts in place. How these security contexts
are established is out of scope for this profile. Furthermore, the
requesting entity and the AS communicate through the introspection
endpoint as specified in [Section
5.9](https://www.rfc-editor.org/rfc/rfc9200#section-5.9){.relref} of
\[[RFC9200](#RFC9200){.xref}\] and through the token endpoint as
specified in [Section
5.8](https://www.rfc-editor.org/rfc/rfc9200#section-5.8){.relref} of
\[[RFC9200](#RFC9200){.xref}\].[¶](#section-5-2){.pilcrow}
:::
:::

::: {#sec-ctx-discard}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Discarding the Security Context](#name-discarding-the-security-con){.section-name .selfRef} {#name-discarding-the-security-con}

There are a number of scenarios where a client or RS needs to discard
the OSCORE security context and acquire a new
one.[¶](#section-6-1){.pilcrow}

The client [MUST]{.bcp14} discard the current security context
associated with an RS when any of the following
occurs:[¶](#section-6-2){.pilcrow}

-   [the sequence number space
    ends.[¶](#section-6-3.1){.pilcrow}]{#section-6-3.1}
-   [the access token associated with the context becomes invalid due
    to, for example,
    expiration.[¶](#section-6-3.2){.pilcrow}]{#section-6-3.2}
-   [the client receives a number of 4.01 Unauthorized responses to
    OSCORE requests using the same security context. The exact number
    needs to be specified by the
    application.[¶](#section-6-3.3){.pilcrow}]{#section-6-3.3}
-   [the client receives a new nonce in the 2.01 (Created) response (see
    [Section 4.2](#rs-c){.xref}) to a POST request to the authz-info
    endpoint, when reposting a (non-expired) token associated to the
    existing context.[¶](#section-6-3.4){.pilcrow}]{#section-6-3.4}

The RS [MUST]{.bcp14} discard the current security context associated
with a client when any of the following
occurs:[¶](#section-6-4){.pilcrow}

-   [the sequence number space
    ends.[¶](#section-6-5.1){.pilcrow}]{#section-6-5.1}
-   [the access token associated with the context
    expires.[¶](#section-6-5.2){.pilcrow}]{#section-6-5.2}
-   [the client has successfully replaced the current security context
    with a newer one by posting an access token to the unprotected
    /authz-info endpoint at the RS, e.g., by reposting the same token,
    as specified in [Section
    4.1](#c-rs){.xref}.[¶](#section-6-5.3){.pilcrow}]{#section-6-5.3}

Whenever one more access token is successfully posted to the RS, and a
new security context is derived between the client and RS, messages in
transit that were protected with the previous security context might not
pass verification, as the old context is discarded. That means that
messages sent shortly before the client posts one more access tokens to
the RS might not successfully reach the destination. Analogously,
implementations may want to cancel CoAP observations at the RS
registered before the security context is replaced, or conversely, they
will need to implement a mechanism to ensure that those observations are
to be protected with the newly derived security
context.[¶](#section-6-6){.pilcrow}
:::
:::

::: {#sec-cons}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

This document specifies a profile for the ACE framework
\[[RFC9200](#RFC9200){.xref}\]. Thus, the general security
considerations from the framework also apply to this
profile.[¶](#section-7-1){.pilcrow}

Furthermore, the general security considerations of OSCORE
\[[RFC8613](#RFC8613){.xref}\] also apply to this specific use of the
OSCORE protocol.[¶](#section-7-2){.pilcrow}

As previously stated, the proof of possession in this profile is
performed by both parties verifying that they have established the same
security context, as specified in [Section 4.3](#oscore-setup){.xref},
which means that both the OSCORE request and the OSCORE response passes
verification. RS authentication requires both that the client trusts the
AS and that the OSCORE response from the RS passes
verification.[¶](#section-7-3){.pilcrow}

OSCORE is designed to secure point-to-point communication, providing a
secure binding between the request and the response(s). Thus, the basic
OSCORE protocol is not intended for use in point-to-multipoint
communication (e.g., multicast, publish-subscribe). Implementers of this
profile should make sure that their use case corresponds to the expected
use of OSCORE, to prevent weakening the security assurances provided by
OSCORE.[¶](#section-7-4){.pilcrow}

Since the use of nonces N1 and N2 during the exchange guarantees
uniqueness of AEAD keys and nonces, it is [REQUIRED]{.bcp14} that the
exchanged nonces are not reused with the same input keying material even
in case of reboots. The exchange of 64-bit random nonces is
[RECOMMENDED]{.bcp14} in this document. Considering the birthday
paradox, the average collision for each nonce will happen after 2^32^
messages, which is considerably more token provisionings than would be
expected for intended applications. If applications use something else,
such as a counter, they need to guarantee that reboot and loss of state
on either node does not provoke reuse. If that is not guaranteed, nodes
are susceptible to reuse of AEAD (nonce, key) pairs, especially since an
on-path attacker can cause the use of a previously exchanged client
nonce N1 for security context establishment by replaying the
corresponding client-to-server message.[¶](#section-7-5){.pilcrow}

In this profile, it is [RECOMMENDED]{.bcp14} that the RS maintains a
single access token for each client. The use of multiple access tokens
for a single client increases the strain on the resource server as it
must consider every access token and calculate the actual permissions of
the client. Also, tokens indicating different or disjoint permissions
from each other may lead the server to enforce wrong permissions. If one
of the access tokens expires earlier than others, the resulting
permissions may offer insufficient protection. Developers
[SHOULD]{.bcp14} avoid using multiple access tokens for the same
client.[¶](#section-7-6){.pilcrow}

If a single OSCORE Input Material is used with multiple RSs, the RSs can
impersonate the client to one of the other RSs and impersonate another
RS to the client. If a Master Secret is used with several clients, the
clients can impersonate RS to one of the other clients. Similarly, if
symmetric keys are used to integrity protect the token between AS and RS
and the token can be used with multiple RSs, the RSs can impersonate AS
to one of the other RSs. If the token key is used for any other
communication between the RSs and AS, the RSs can impersonate each other
to the AS.[¶](#section-7-7){.pilcrow}
:::
:::

::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Privacy Considerations](#name-privacy-considerations){.section-name .selfRef} {#name-privacy-considerations}

This document specifies a profile for the ACE framework
\[[RFC9200](#RFC9200){.xref}\]. Thus, the general privacy considerations
from the framework also apply to this
profile.[¶](#section-8-1){.pilcrow}

As this document uses OSCORE, the privacy considerations from
\[[RFC8613](#RFC8613){.xref}\] apply here as
well.[¶](#section-8-2){.pilcrow}

An unprotected response to an unauthorized request may disclose
information about the resource server and/or its existing relationship
with the client. It is advisable to include as little information as
possible in an unencrypted response. When an OSCORE security context
already exists between the client and the resource server, more detailed
information may be included.[¶](#section-8-3){.pilcrow}

The token is sent in the clear to the authz-info endpoint, so if a
client uses the same single token from multiple locations with multiple
resource servers, it can risk being tracked by the token\'s value even
when the access token is encrypted.[¶](#section-8-4){.pilcrow}

The nonces exchanged in the request and response to the authz-info
endpoint are also sent in the clear, so using random nonces is best for
privacy (as opposed to, e.g., a counter, which might leak some
information about the client).[¶](#section-8-5){.pilcrow}

The identifiers used in OSCORE, negotiated between the client and RS,
are privacy sensitive (see [Section
12.8](https://www.rfc-editor.org/rfc/rfc8613#section-12.8){.relref} of
\[[RFC8613](#RFC8613){.xref}\]) and could reveal information about the
client, or they may be used for correlating requests from one
client.[¶](#section-8-6){.pilcrow}

Note that some information might still leak after OSCORE is established,
due to observable message sizes, the source, and the destination
addresses.[¶](#section-8-7){.pilcrow}
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [ACE Profile Registry](#name-ace-profile-registry){.section-name .selfRef} {#name-ace-profile-registry}

The following registration has been made in the \"ACE Profiles\"
registry following the procedure specified in [Section
8.8](https://www.rfc-editor.org/rfc/rfc9200#section-8.8){.relref} of
\[[RFC9200](#RFC9200){.xref}\]:[¶](#section-9.1-1){.pilcrow}

[]{.break}

Name:
:   coap_oscore[¶](#section-9.1-2.2){.pilcrow}
:   

Description:
:   Profile for using OSCORE to secure communication between constrained
    nodes using the Authentication and Authorization for Constrained
    Environments framework.[¶](#section-9.1-2.4){.pilcrow}
:   

CBOR Value:
:   2[¶](#section-9.1-2.6){.pilcrow}
:   

Reference:
:   RFC 9203[¶](#section-9.1-2.8){.pilcrow}
:   
:::

::: {#iana-nonces-ids}
::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [OAuth Parameters Registry](#name-oauth-parameters-registry){.section-name .selfRef} {#name-oauth-parameters-registry}

The following registrations have been made in the \"OAuth Parameters\"
registry \[[IANA.OAuthParameters](#IANA.OAuthParameters){.xref}\]
following the procedure specified in [Section
11.2](https://www.rfc-editor.org/rfc/rfc6749#section-11.2){.relref} of
\[[RFC6749](#RFC6749){.xref}\]:[¶](#section-9.2-1){.pilcrow}

[]{.break}

Parameter name:
:   nonce1[¶](#section-9.2-2.2){.pilcrow}
:   

Parameter usage location:
:   client-rs request[¶](#section-9.2-2.4){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-9.2-2.6){.pilcrow}
:   

Specification Document(s):
:   RFC 9203[¶](#section-9.2-2.8){.pilcrow}
:   

[]{.break}

Parameter name:
:   nonce2[¶](#section-9.2-3.2){.pilcrow}
:   

Parameter usage location:
:   rs-client response[¶](#section-9.2-3.4){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-9.2-3.6){.pilcrow}
:   

Specification Document(s):
:   RFC 9203[¶](#section-9.2-3.8){.pilcrow}
:   

[]{.break}

Parameter name:
:   ace_client_recipientid[¶](#section-9.2-4.2){.pilcrow}
:   

Parameter usage location:
:   client-rs request[¶](#section-9.2-4.4){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-9.2-4.6){.pilcrow}
:   

Specification Document(s):
:   RFC 9203[¶](#section-9.2-4.8){.pilcrow}
:   

[]{.break}

Parameter name:
:   ace_server_recipientid[¶](#section-9.2-5.2){.pilcrow}
:   

Parameter usage location:
:   rs-client response[¶](#section-9.2-5.4){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-9.2-5.6){.pilcrow}
:   

Specification Document(s):
:   RFC 9203[¶](#section-9.2-5.8){.pilcrow}
:   
:::
:::

::: {#section-9.3 .section}
### [9.3.](#section-9.3){.section-number .selfRef} [OAuth Parameters CBOR Mappings Registry](#name-oauth-parameters-cbor-mappi){.section-name .selfRef} {#name-oauth-parameters-cbor-mappi}

The following registrations have been made in the \"OAuth Parameters
CBOR Mappings\" registry following the procedure specified in [Section
8.10](https://www.rfc-editor.org/rfc/rfc9200#section-8.10){.relref} of
\[[RFC9200](#RFC9200){.xref}\]:[¶](#section-9.3-1){.pilcrow}

[]{.break}

Name:
:   nonce1[¶](#section-9.3-2.2){.pilcrow}
:   

CBOR Key:
:   40[¶](#section-9.3-2.4){.pilcrow}
:   

Value Type:
:   bstr[¶](#section-9.3-2.6){.pilcrow}
:   

Reference:
:   RFC 9203[¶](#section-9.3-2.8){.pilcrow}
:   

[]{.break}

Name:
:   nonce2[¶](#section-9.3-3.2){.pilcrow}
:   

CBOR Key:
:   42[¶](#section-9.3-3.4){.pilcrow}
:   

Value Type:
:   bstr[¶](#section-9.3-3.6){.pilcrow}
:   

Reference:
:   RFC 9203[¶](#section-9.3-3.8){.pilcrow}
:   

[]{.break}

Name:
:   ace_client_recipientid[¶](#section-9.3-4.2){.pilcrow}
:   

CBOR Key:
:   43[¶](#section-9.3-4.4){.pilcrow}
:   

Value Type:
:   bstr[¶](#section-9.3-4.6){.pilcrow}
:   

Reference:
:   RFC 9203[¶](#section-9.3-4.8){.pilcrow}
:   

[]{.break}

Name:
:   ace_server_recipientid[¶](#section-9.3-5.2){.pilcrow}
:   

CBOR Key:
:   44[¶](#section-9.3-5.4){.pilcrow}
:   

Value Type:
:   bstr[¶](#section-9.3-5.6){.pilcrow}
:   

Reference:
:   RFC 9203[¶](#section-9.3-5.8){.pilcrow}
:   
:::

::: {#sec-ctx-params-reg}
::: {#section-9.4 .section}
### [9.4.](#section-9.4){.section-number .selfRef} [OSCORE Security Context Parameters Registry](#name-oscore-security-context-par){.section-name .selfRef} {#name-oscore-security-context-par}

IANA has created a new registry entitled \"OSCORE Security Context
Parameters\". The registration procedure depends on the range of CBOR
label values, following \[[RFC8126](#RFC8126){.xref}\]. Guidelines for
the experts are provided in [Section
9.7](#review){.xref}.[¶](#section-9.4-1){.pilcrow}

The columns of the registry are:[¶](#section-9.4-2){.pilcrow}

[]{.break}

Name:
:   The JSON name requested (e.g., \"ms\"). Because a core goal of this
    document is for the resulting representations to be compact, it is
    [RECOMMENDED]{.bcp14} that the name be short. This name is case
    sensitive. Names may not match other registered names in a
    case-insensitive manner unless the designated experts determine that
    there is a compelling reason to allow an exception. The name is not
    used in the CBOR encoding.[¶](#section-9.4-3.2){.pilcrow}
:   

CBOR Label:
:   The value to be used to identify this name. Map key labels
    [MUST]{.bcp14} be unique. The label can be a positive integer, a
    negative integer, or a string. Integer values between -256 and 255
    and strings of length 1 are designated as Standards Track document
    required. Integer values from -65536 to -257 and from 256 to 65535
    and strings of length 2 are designated as Specification Required.
    Integer values greater than 65535 and strings of length greater than
    2 are designated as Expert Review. Integer values less than -65536
    are marked as Private Use.[¶](#section-9.4-3.4){.pilcrow}
:   

CBOR Type:
:   This field contains the CBOR type for the
    field.[¶](#section-9.4-3.6){.pilcrow}
:   

Registry:
:   This field denotes the registry that values may come from, if one
    exists.[¶](#section-9.4-3.8){.pilcrow}
:   

Description:
:   This field contains a brief description for the
    field.[¶](#section-9.4-3.10){.pilcrow}
:   

Reference:
:   This contains a pointer to the public specification for the field,
    if one exists.[¶](#section-9.4-3.12){.pilcrow}
:   

This registry has been initially populated by the values in [Table
1](#key-labels){.xref}. The Reference column for all of these entries is
this document.[¶](#section-9.4-4){.pilcrow}
:::
:::

::: {#osc-cwt}
::: {#section-9.5 .section}
### [9.5.](#section-9.5){.section-number .selfRef} [CWT Confirmation Methods Registry](#name-cwt-confirmation-methods-re){.section-name .selfRef} {#name-cwt-confirmation-methods-re}

The following registration has been made in the \"CWT Confirmation
Methods\" registry
\[[IANA.CWTConfirmationMethods](#IANA.CWTConfirmationMethods){.xref}\]
following the procedure specified in [Section
7.2.1](https://www.rfc-editor.org/rfc/rfc8747#section-7.2.1){.relref} of
\[[RFC8747](#RFC8747){.xref}\]:[¶](#section-9.5-1){.pilcrow}

[]{.break}

Confirmation Method Name:
:   osc[¶](#section-9.5-2.2){.pilcrow}
:   

Confirmation Method Description:
:   OSCORE_Input_Material carrying the parameters for using OSCORE
    per-message security with implicit key
    confirmation[¶](#section-9.5-2.4){.pilcrow}
:   

JWT Confirmation Method Name:
:   osc[¶](#section-9.5-2.6){.pilcrow}
:   

Confirmation Key:
:   4[¶](#section-9.5-2.8){.pilcrow}
:   

Confirmation Value Type(s):
:   map[¶](#section-9.5-2.10){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-9.5-2.12){.pilcrow}
:   

Specification Document(s):
:   [Section 3.2.1](#oscore-sec-ctx){.xref} of RFC
    9203[¶](#section-9.5-2.14){.pilcrow}
:   
:::
:::

::: {#osc-jwt}
::: {#section-9.6 .section}
### [9.6.](#section-9.6){.section-number .selfRef} [JWT Confirmation Methods Registry](#name-jwt-confirmation-methods-re){.section-name .selfRef} {#name-jwt-confirmation-methods-re}

The following registration has been made in the \"JWT Confirmation
Methods\" registry
\[[IANA.JWTConfirmationMethods](#IANA.JWTConfirmationMethods){.xref}\]
following the procedure specified in [Section
6.2.1](https://www.rfc-editor.org/rfc/rfc7800#section-6.2.1){.relref} of
\[[RFC7800](#RFC7800){.xref}\]:[¶](#section-9.6-1){.pilcrow}

[]{.break}

Confirmation Method Value:
:   osc[¶](#section-9.6-2.2){.pilcrow}
:   

Confirmation Method Description:
:   OSCORE_Input_Material carrying the parameters for using OSCORE
    per-message security with implicit key
    confirmation[¶](#section-9.6-2.4){.pilcrow}
:   

Change Controller:
:   IETF[¶](#section-9.6-2.6){.pilcrow}
:   

Specification Document(s):
:   [Section 3.2.1](#oscore-sec-ctx){.xref} of RFC
    9203[¶](#section-9.6-2.8){.pilcrow}
:   
:::
:::

::: {#review}
::: {#section-9.7 .section}
### [9.7.](#section-9.7){.section-number .selfRef} [Expert Review Instructions](#name-expert-review-instructions){.section-name .selfRef} {#name-expert-review-instructions}

The IANA registry established in this document is defined to use the
Expert Review registration policy. This section gives some general
guidelines for what the experts should be looking for, but they are
being designated as experts for a reason, so they should be given
substantial latitude.[¶](#section-9.7-1){.pilcrow}

Expert reviewers should take into consideration the following
points:[¶](#section-9.7-2){.pilcrow}

-   [Point squatting should be discouraged. Reviewers are encouraged to
    get sufficient information for registration requests to ensure that
    the usage is not going to duplicate one that is already registered
    and that the point is likely to be used in deployments. The zones
    tagged as Private Use are intended for testing purposes and closed
    environments. Code points in other ranges should not be assigned for
    testing.[¶](#section-9.7-3.1){.pilcrow}]{#section-9.7-3.1}
-   [Specifications are required for the Standards Track range of point
    assignment. Specifications should exist for specification required
    ranges, but early assignment before a specification is available is
    considered to be permissible. Specifications are needed for the
    First Come First Served range if they are expected to be used
    outside of closed environments in an interoperable way. When
    specifications are not provided, the description provided needs to
    have sufficient information to identify what the point is being used
    for.[¶](#section-9.7-3.2){.pilcrow}]{#section-9.7-3.2}
-   [Experts should take into account the expected usage of fields when
    approving point assignment. The fact that there is a range for
    Standards Track documents does not mean that a Standards Track
    document cannot have points assigned outside of that range. The
    length of the encoded value should be weighed against how many code
    points of that length are left, the size of device it will be used
    on, and the number of code points left that encode to that
    size.[¶](#section-9.7-3.3){.pilcrow}]{#section-9.7-3.3}
:::
:::
:::

::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-10.1 .section}
### [10.1.](#section-10.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[COSE.Algorithms\]
:   [IANA]{.refAuthor}, [\"COSE Algorithms\"]{.refTitle},
    \<<https://www.iana.org/assignments/cose>\>.
:   

\[IANA.CWTConfirmationMethods\]
:   [IANA]{.refAuthor}, [\"CWT Confirmation Methods\"]{.refTitle},
    \<<https://www.iana.org/assignments/cwt>\>.
:   

\[IANA.JWTConfirmationMethods\]
:   [IANA]{.refAuthor}, [\"JWT Confirmation Methods\"]{.refTitle},
    \<<https://www.iana.org/assignments/jwt>\>.
:   

\[IANA.OAuthParameters\]
:   [IANA]{.refAuthor}, [\"OAuth Parameters\"]{.refTitle},
    \<<https://www.iana.org/assignments/oauth-parameters>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC4648\]
:   [Josefsson, S.]{.refAuthor}, [\"The Base16, Base32, and Base64 Data
    Encodings\"]{.refTitle}, [RFC 4648]{.seriesInfo}, [DOI
    10.17487/RFC4648]{.seriesInfo}, October 2006,
    \<<https://www.rfc-editor.org/info/rfc4648>\>.
:   

\[RFC5869\]
:   [Krawczyk, H.]{.refAuthor} and [P. Eronen]{.refAuthor},
    [\"HMAC-based Extract-and-Expand Key Derivation Function
    (HKDF)\"]{.refTitle}, [RFC 5869]{.seriesInfo}, [DOI
    10.17487/RFC5869]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5869>\>.
:   

\[RFC7252\]
:   [Shelby, Z.]{.refAuthor}, [Hartke, K.]{.refAuthor}, and [C.
    Bormann]{.refAuthor}, [\"The Constrained Application Protocol
    (CoAP)\"]{.refTitle}, [RFC 7252]{.seriesInfo}, [DOI
    10.17487/RFC7252]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7252>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8392\]
:   [Jones, M.]{.refAuthor}, [Wahlstroem, E.]{.refAuthor},
    [Erdtman, S.]{.refAuthor}, and [H. Tschofenig]{.refAuthor}, [\"CBOR
    Web Token (CWT)\"]{.refTitle}, [RFC 8392]{.seriesInfo}, [DOI
    10.17487/RFC8392]{.seriesInfo}, May 2018,
    \<<https://www.rfc-editor.org/info/rfc8392>\>.
:   

\[RFC8610\]
:   [Birkholz, H.]{.refAuthor}, [Vigano, C.]{.refAuthor}, and [C.
    Bormann]{.refAuthor}, [\"Concise Data Definition Language (CDDL): A
    Notational Convention to Express Concise Binary Object
    Representation (CBOR) and JSON Data Structures\"]{.refTitle}, [RFC
    8610]{.seriesInfo}, [DOI 10.17487/RFC8610]{.seriesInfo}, June 2019,
    \<<https://www.rfc-editor.org/info/rfc8610>\>.
:   

\[RFC8613\]
:   [Selander, G.]{.refAuthor}, [Mattsson, J.]{.refAuthor},
    [Palombini, F.]{.refAuthor}, and [L. Seitz]{.refAuthor}, [\"Object
    Security for Constrained RESTful Environments
    (OSCORE)\"]{.refTitle}, [RFC 8613]{.seriesInfo}, [DOI
    10.17487/RFC8613]{.seriesInfo}, July 2019,
    \<<https://www.rfc-editor.org/info/rfc8613>\>.
:   

\[RFC8949\]
:   [Bormann, C.]{.refAuthor} and [P. Hoffman]{.refAuthor}, [\"Concise
    Binary Object Representation (CBOR)\"]{.refTitle}, [STD
    94]{.seriesInfo}, [RFC 8949]{.seriesInfo}, [DOI
    10.17487/RFC8949]{.seriesInfo}, December 2020,
    \<<https://www.rfc-editor.org/info/rfc8949>\>.
:   

\[RFC9052\]
:   [Schaad, J.]{.refAuthor}, [\"CBOR Object Signing and Encryption
    (COSE): Structures and Process\"]{.refTitle}, [STD 96]{.seriesInfo},
    [RFC 9052]{.seriesInfo}, [DOI 10.17487/RFC9052]{.seriesInfo}, August
    2022, \<<https://www.rfc-editor.org/info/rfc9052>\>.
:   

\[RFC9053\]
:   [Schaad, J.]{.refAuthor}, [\"CBOR Object Signing and Encryption
    (COSE): Initial Algorithms\"]{.refTitle}, [RFC 9053]{.seriesInfo},
    [DOI 10.17487/RFC9053]{.seriesInfo}, August 2022,
    \<<https://www.rfc-editor.org/info/rfc9053>\>.
:   

\[RFC9200\]
:   [Seitz, L.]{.refAuthor}, [Selander, G.]{.refAuthor},
    [Wahlstroem, E.]{.refAuthor}, [Erdtman, S.]{.refAuthor}, and [H.
    Tschofenig]{.refAuthor}, [\"Authentication and Authorization for
    Constrained Environments Using the OAuth 2.0 Framework
    (ACE-OAuth)\"]{.refTitle}, [RFC 9200]{.seriesInfo}, [DOI
    10.17487/RFC9200]{.seriesInfo}, August 2022,
    \<<https://www.rfc-editor.org/info/rfc9200>\>.
:   

\[RFC9201\]
:   [Seitz, L.]{.refAuthor}, [\"Additional OAuth Parameters for
    Authentication and Authorization for Constrained Environments
    (ACE)\"]{.refTitle}, [RFC 9201]{.seriesInfo}, [DOI
    10.17487/RFC9201]{.seriesInfo}, August 2022,
    \<<https://www.rfc-editor.org/info/rfc9201>\>.
:   
:::

::: {#section-10.2 .section}
### [10.2.](#section-10.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[RFC4949\]
:   [Shirey, R.]{.refAuthor}, [\"Internet Security Glossary, Version
    2\"]{.refTitle}, [FYI 36]{.seriesInfo}, [RFC 4949]{.seriesInfo},
    [DOI 10.17487/RFC4949]{.seriesInfo}, August 2007,
    \<<https://www.rfc-editor.org/info/rfc4949>\>.
:   

\[RFC6749\]
:   [Hardt, D., Ed.]{.refAuthor}, [\"The OAuth 2.0 Authorization
    Framework\"]{.refTitle}, [RFC 6749]{.seriesInfo}, [DOI
    10.17487/RFC6749]{.seriesInfo}, October 2012,
    \<<https://www.rfc-editor.org/info/rfc6749>\>.
:   

\[RFC7800\]
:   [Jones, M.]{.refAuthor}, [Bradley, J.]{.refAuthor}, and [H.
    Tschofenig]{.refAuthor}, [\"Proof-of-Possession Key Semantics for
    JSON Web Tokens (JWTs)\"]{.refTitle}, [RFC 7800]{.seriesInfo}, [DOI
    10.17487/RFC7800]{.seriesInfo}, April 2016,
    \<<https://www.rfc-editor.org/info/rfc7800>\>.
:   

\[RFC8126\]
:   [Cotton, M.]{.refAuthor}, [Leiba, B.]{.refAuthor}, and [T.
    Narten]{.refAuthor}, [\"Guidelines for Writing an IANA
    Considerations Section in RFCs\"]{.refTitle}, [BCP 26]{.seriesInfo},
    [RFC 8126]{.seriesInfo}, [DOI 10.17487/RFC8126]{.seriesInfo}, June
    2017, \<<https://www.rfc-editor.org/info/rfc8126>\>.
:   

\[RFC8446\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   

\[RFC8747\]
:   [Jones, M.]{.refAuthor}, [Seitz, L.]{.refAuthor},
    [Selander, G.]{.refAuthor}, [Erdtman, S.]{.refAuthor}, and [H.
    Tschofenig]{.refAuthor}, [\"Proof-of-Possession Key Semantics for
    CBOR Web Tokens (CWTs)\"]{.refTitle}, [RFC 8747]{.seriesInfo}, [DOI
    10.17487/RFC8747]{.seriesInfo}, March 2020,
    \<<https://www.rfc-editor.org/info/rfc8747>\>.
:   

\[RFC9110\]
:   [Fielding, R., Ed.]{.refAuthor}, [Nottingham, M., Ed.]{.refAuthor},
    and [J. Reschke, Ed.]{.refAuthor}, [\"HTTP Semantics\"]{.refTitle},
    [STD 97]{.seriesInfo}, [RFC 9110]{.seriesInfo}, [DOI
    10.17487/RFC9110]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9110>\>.
:   

\[RFC9147\]
:   [Rescorla, E.]{.refAuthor}, [Tschofenig, H.]{.refAuthor}, and [N.
    Modadugu]{.refAuthor}, [\"The Datagram Transport Layer Security
    (DTLS) Protocol Version 1.3\"]{.refTitle}, [RFC 9147]{.seriesInfo},
    [DOI 10.17487/RFC9147]{.seriesInfo}, April 2022,
    \<<https://www.rfc-editor.org/info/rfc9147>\>.
:   
:::
:::

::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [Profile Requirements](#name-profile-requirements){.section-name .selfRef} {#name-profile-requirements}

This section lists the specifications of this profile based on the
requirements of the framework, as requested in [Appendix
C](https://www.rfc-editor.org/rfc/rfc9200#appendix-C){.relref} of
\[[RFC9200](#RFC9200){.xref}\].[¶](#appendix-A-1){.pilcrow}

-   [Optionally, define new methods for the client to discover the
    necessary permissions and AS for accessing a resource, different
    from the one proposed in \[[RFC9200](#RFC9200){.xref}\]: Not
    specified[¶](#appendix-A-2.1){.pilcrow}]{#appendix-A-2.1}
-   [Optionally, specify new grant types: Not
    specified[¶](#appendix-A-2.2){.pilcrow}]{#appendix-A-2.2}
-   [Optionally, define the use of client certificates as client
    credential type: Not
    specified[¶](#appendix-A-2.3){.pilcrow}]{#appendix-A-2.3}
-   [Specify the communication protocol the client and RS must use:
    CoAP[¶](#appendix-A-2.4){.pilcrow}]{#appendix-A-2.4}
-   [Specify the security protocol the client and RS must use to protect
    their communication:
    OSCORE[¶](#appendix-A-2.5){.pilcrow}]{#appendix-A-2.5}
-   [Specify how the client and the RS mutually authenticate: Implicitly
    by possession of a common OSCORE security context. Note that the
    mutual authentication is not completed before the client has
    verified an OSCORE response using this security
    context.[¶](#appendix-A-2.6){.pilcrow}]{#appendix-A-2.6}
-   [Specify the proof-of-possession protocol(s) and how to select one,
    if several are available. Also specify which key types (e.g.,
    symmetric/asymmetric) are supported by a specific proof-of-
    possession protocol: OSCORE algorithms; preestablished symmetric
    keys[¶](#appendix-A-2.7){.pilcrow}]{#appendix-A-2.7}
-   [Specify a unique ace_profile identifier:
    coap_oscore[¶](#appendix-A-2.8){.pilcrow}]{#appendix-A-2.8}
-   [If introspection is supported, specify the communication and
    security protocol for introspection: HTTP/CoAP (+
    TLS/DTLS/OSCORE)[¶](#appendix-A-2.9){.pilcrow}]{#appendix-A-2.9}
-   [Specify the communication and security protocol for interactions
    between client and AS: HTTP/CoAP (+
    TLS/DTLS/OSCORE)[¶](#appendix-A-2.10){.pilcrow}]{#appendix-A-2.10}
-   [Specify if/how the authz-info endpoint is protected, including how
    error responses are protected: Not
    protected[¶](#appendix-A-2.11){.pilcrow}]{#appendix-A-2.11}
-   [Optionally, define methods of token transport other than the
    authz-info endpoint: Not
    defined[¶](#appendix-A-2.12){.pilcrow}]{#appendix-A-2.12}
:::

::: {#appendix-B .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

The authors wish to thank [Jim Schaad]{.contact-name} and [Marco
Tiloca]{.contact-name} for the substantial input to this document, as
well as [Carsten Bormann]{.contact-name}, [Elwyn Davies]{.contact-name},
[Linda Dunbar]{.contact-name}, [Roman Danyliw]{.contact-name}, [Martin
Duke]{.contact-name}, [Lars Eggert]{.contact-name}, [Murray
Kucherawy]{.contact-name}, and [Zaheduzzaman Sarker]{.contact-name} for
their reviews and feedback. Special thanks to the responsible area
director [Benjamin Kaduk]{.contact-name} for his extensive review and
contributed text. [Ludwig Seitz]{.contact-name} worked on this document
as part of the CelticNext projects CyberWI and CRITISEC with funding
from Vinnova. The work on this document has been partly supported also
by the H2020 project SIFIS-Home (Grant agreement
952652).[¶](#appendix-B-1){.pilcrow}
:::

::: {#authors-addresses}
::: {#appendix-C .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Francesca Palombini]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Ericsson AB]{.org}
:::

::: email
Email: <francesca.palombini@ericsson.com>
:::

::: {.left dir="auto"}
[Ludwig Seitz]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Combitech]{.org}
:::

::: {.left dir="auto"}
[Djäknegatan 31]{.street-address}
:::

::: {.left dir="auto"}
SE-[211 35]{.postal-code} [Malmö]{.locality}
:::

::: {.left dir="auto"}
[Sweden]{.country-name}
:::

::: email
Email: <ludwig.seitz@combitech.com>
:::

::: {.left dir="auto"}
[Göran Selander]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Ericsson AB]{.org}
:::

::: email
Email: <goran.selander@ericsson.com>
:::

::: {.left dir="auto"}
[Martin Gunnarsson]{.fn .nameRole}
:::

::: {.left dir="auto"}
[RISE]{.org}
:::

::: {.left dir="auto"}
[Scheelevägen 17]{.street-address}
:::

::: {.left dir="auto"}
SE-[22370]{.postal-code} [Lund]{.locality}
:::

::: {.left dir="auto"}
[Sweden]{.country-name}
:::

::: email
Email: <martin.gunnarsson@ri.se>
:::
:::
:::
