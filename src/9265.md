  RFC 9265       FEC Coding and Congestion   July 2022
  -------------- --------------------------- -----------
  Kuhn, et al.   Informational               \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Research Task Force (IRTF)

RFC:
:   [9265](https://www.rfc-editor.org/rfc/rfc9265){.eref}

Category:
:   Informational

Published:
:   July 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    N. Kuhn
    :::

    ::: org
    CNES
    :::
    :::

    ::: author
    ::: author-name
    E. Lochin
    :::

    ::: org
    ENAC
    :::
    :::

    ::: author
    ::: author-name
    F. Michel
    :::

    ::: org
    UCLouvain
    :::
    :::

    ::: author
    ::: author-name
    M. Welzl
    :::

    ::: org
    University of Oslo
    :::
    :::
:::

# RFC 9265 {#rfcnum}

# Forward Erasure Correction (FEC) Coding and Congestion Control in Transport {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

Forward Erasure Correction (FEC) is a reliability mechanism that is
distinct and separate from the retransmission logic in reliable transfer
protocols such as TCP. FEC coding can help deal with losses at the end
of transfers or with networks having non-congestion losses. However, FEC
coding mechanisms should not hide congestion signals. This memo offers a
discussion of how FEC coding and congestion control can coexist. Another
objective is to encourage the research community to also consider
congestion control aspects when proposing and comparing FEC coding
solutions in communication systems.[¶](#section-abstract-1){.pilcrow}

This document is the product of the Coding for Efficient Network
Communications Research Group (NWCRG). The scope of the document is
end-to-end communications; FEC coding for tunnels is out of the scope of
the document.[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for informational
purposes.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Research Task Force (IRTF).
The IRTF publishes the results of Internet-related research and
development activities. These results might not be suitable for
deployment. This RFC represents the consensus of the Network Coding for
Efficient Network Communications Research Group of the Internet Research
Task Force (IRTF). Documents approved for publication by the IRSG are
not candidates for any level of Internet Standard; see Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9265>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Context](#name-context){.xref}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Fairness, Quantifying and Limiting
        Harm, and Policy
        Concerns](#name-fairness-quantifying-and-li){.xref}
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [Separate Channels, Separate
        Entities](#name-separate-channels-separate-){.xref}
        :::

    -   ::: {#section-toc.1-1.2.2.3}
        [2.3](#section-2.3){.xref}.  [Relation between Transport Layer
        and Application
        Requirements](#name-relation-between-transport-){.xref}
        :::

    -   ::: {#section-toc.1-1.2.2.4}
        [2.4](#section-2.4){.xref}.  [Scope of the Document Concerning
        Transport Multipath and Multistream
        Applications](#name-scope-of-the-document-conce){.xref}
        :::

    -   ::: {#section-toc.1-1.2.2.5}
        [2.5](#section-2.5){.xref}.  [Types of
        Coding](#name-types-of-coding){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [FEC above the
    Transport](#name-fec-above-the-transport){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Fairness and Impact on Non-coded
        Flows](#name-fairness-and-impact-on-non-){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Congestion Control and Recovered
        Symbols](#name-congestion-control-and-reco){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Interactions between Congestion
        Control and Coding
        Rates](#name-interactions-between-conges){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [On Useless Repair
        Symbols](#name-on-useless-repair-symbols){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.5}
        [3.5](#section-3.5){.xref}.  [On Partial Ordering at FEC
        Level](#name-on-partial-ordering-at-fec-){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.6}
        [3.6](#section-3.6){.xref}.  [On Partial Reliability at FEC
        Level](#name-on-partial-reliability-at-f){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.7}
        [3.7](#section-3.7){.xref}.  [On Multipath Transport and FEC
        Mechanism](#name-on-multipath-transport-and-){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [FEC within the
    Transport](#name-fec-within-the-transport){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Fairness and Impact on Non-coded
        Flows](#name-fairness-and-impact-on-non-c){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Interactions between Congestion
        Control and Coding
        Rates](#name-interactions-between-congest){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [On Useless Repair
        Symbols](#name-on-useless-repair-symbols-2){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [On Partial Ordering at FEC and/or
        Transport Level](#name-on-partial-ordering-at-fec-a){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.xref}.  [On Partial Reliability at FEC
        Level](#name-on-partial-reliability-at-fe){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.6}
        [4.6](#section-4.6){.xref}.  [On Transport Multipath and Subpath
        FEC Coding Rate](#name-on-transport-multipath-and-){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [FEC below the
    Transport](#name-fec-below-the-transport){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Fairness and Impact on Non-coded
        Flows](#name-fairness-and-impact-on-non-co){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Congestion Control and Recovered
        Symbols](#name-congestion-control-and-recov){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Interactions between Congestion
        Control and Coding
        Rates](#name-interactions-between-congesti){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [On Useless Repair
        Symbols](#name-on-useless-repair-symbols-3){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [On Partial Ordering at FEC Level
        with In-Order Delivery
        Transport](#name-on-partial-ordering-at-fec-l){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.6}
        [5.6](#section-5.6){.xref}.  [On Partial Reliability at FEC
        Level](#name-on-partial-reliability-at-fec){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.7}
        [5.7](#section-5.7){.xref}.  [FEC Not Aware of Transport
        Multipath](#name-fec-not-aware-of-transport-){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Research Recommendations and
    Questions](#name-research-recommendations-an){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Activities Related to Congestion
        Control and Coding](#name-activities-related-to-conge){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Open Research
        Questions](#name-open-research-questions){.xref}

        -   ::: {#section-toc.1-1.6.2.2.2.1}
            [6.2.1](#section-6.2.1){.xref}.  [Parameter
            Derivation](#name-parameter-derivation){.xref}
            :::

        -   ::: {#section-toc.1-1.6.2.2.2.2}
            [6.2.2](#section-6.2.2){.xref}.  [New Signaling Methods and
            Fairness](#name-new-signaling-methods-and-f){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Recommendations and Advice for
        Evaluating Coding
        Mechanisms](#name-recommendations-and-advice-){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Informative
    References](#name-informative-references){.xref}
    :::

-   ::: {#section-toc.1-1.10}
    [](#appendix-A){.xref}[Acknowledgements](#name-acknowledgements){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [](#appendix-B){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#sec_introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

There are cases where deploying FEC coding improves the performance of a
transmission. As an example, it may take time for a sender to detect
transfer tail losses (losses that occur at the end of a transfer where,
e.g., TCP obtains no more ACKs that would enable it to quickly repair
the loss via retransmission). Allowing the receiver to recover such
losses instead of having to rely on a retransmission could improve the
experience of applications using short flows. Another example is a
network where non-congestion losses are persistent and prevent a sender
from exploiting the link capacity.[¶](#section-1-1){.pilcrow}

Coding and the loss detection of congestion controls are two distinct
and separate reliability mechanisms. Since FEC coding repairs losses,
blindly applying FEC may easily lead to an implementation that also
hides a congestion signal from the sender. It is important to ensure
that such hiding of information does not occur, because loss may be the
only congestion signal available to the sender (e.g., TCP
\[[RFC5681](#RFC5681){.xref}\]).[¶](#section-1-2){.pilcrow}

FEC coding and congestion control can be seen as two separate channels.
In practice, implementations may mix the signals that are exchanged on
these channels. This memo offers a discussion of how FEC coding and
congestion control coexist. Another objective is to encourage the
research community to also consider congestion control aspects when
proposing and comparing FEC coding solutions in communication systems.
This document does not aim to propose guidelines for characterizing FEC
coding solutions.[¶](#section-1-3){.pilcrow}

We consider three architectures for end-to-end unicast data
transfer:[¶](#section-1-4){.pilcrow}

-   [with FEC coding in the application (above the transport) ([Section
    3](#sec_fec-above){.xref}),[¶](#section-1-5.1){.pilcrow}]{#section-1-5.1}
-   [within the transport ([Section 4](#sec_fec-in){.xref}),
    or[¶](#section-1-5.2){.pilcrow}]{#section-1-5.2}
-   [directly below the transport ([Section
    5](#sec_fec-below){.xref}).[¶](#section-1-5.3){.pilcrow}]{#section-1-5.3}

A typical scenario for the considerations in this document is a client
browsing the Web or watching a live video.[¶](#section-1-6){.pilcrow}

This document represents the collaborative work and consensus of the
Coding for Efficient Network Communications Research Group (NWCRG); it
is not an IETF product nor a standard. The document follows the
terminology proposed in the taxonomy document
\[[RFC8406](#RFC8406){.xref}\].[¶](#section-1-7){.pilcrow}
:::
:::

::: {#sec_notations}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Context](#name-context){.section-name .selfRef} {#name-context}

::: {#subsec_def_fairness}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Fairness, Quantifying and Limiting Harm, and Policy Concerns](#name-fairness-quantifying-and-li){.section-name .selfRef} {#name-fairness-quantifying-and-li}

Traffic from or to different end users may share various types of
bottlenecks. When such a shared bottleneck does not implement some form
of flow protection, the share of the available capacity between single
flows can help assess when one flow starves the
other.[¶](#section-2.1-1){.pilcrow}

As one example, for residential accesses, the data rate can be
guaranteed for the customer premises equipment but not necessarily for
the end user. The quality of service that guarantees fairness between
the different clients can be seen as a policy concern
\[[FLOW-RATE-FAIRNESS](#I-D.briscoe-tsvarea-fair){.xref}\].[¶](#section-2.1-2){.pilcrow}

While past efforts have focused on achieving fairness, quantifying and
limiting harm caused by new algorithms (or algorithms with coding) is
more practical \[[BEYONDJAIN](#BEYONDJAIN){.xref}\]. This document
considers fairness as the impact of the addition of coded flows on
non-coded flows when they share the same bottleneck. It is assumed that
the non-coded flows respond to congestion signals from the network. This
document does not contribute to the definition of fairness at a wider
scale.[¶](#section-2.1-3){.pilcrow}
:::
:::

::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [Separate Channels, Separate Entities](#name-separate-channels-separate-){.section-name .selfRef} {#name-separate-channels-separate-}

Figures [1](#fig_sep-channel-cc){.xref} and
[2](#fig_sep-channel-fec){.xref} present the notations that will be used
in this document and introduce the Forward Erasure Correction (FEC) and
Congestion Control (CC) channels. The FEC channel carries repair symbols
(from the sender to the receiver) and information from the receiver to
the sender (e.g., signaling which symbols have been recovered, loss rate
prior and/or after decoding, etc.). The CC channel carries network
packets from a sender to a receiver and packets signaling information
about the network (number of packets received vs. lost, Explicit
Congestion Notification (ECN) marks \[[RFC3168](#RFC3168){.xref}\],
etc.) from the receiver to the sender. The network packets that are sent
by the CC channel may be composed of source packets and/or repair
symbols.[¶](#section-2.2-1){.pilcrow}

[]{#name-congestion-control-cc-chann}

::: {#fig_sep-channel-cc}
::: {#section-2.2-2.1 .alignLeft .art-text .artwork}
     SENDER                                RECEIVER

    +------+                               +------+
    |      | -----   network packets  ---->|      |
    |  CC  |                               |  CC  |
    |      | <---  network information  ---|      |
    +------+                               +------+
:::

[Figure 1](#figure-1){.selfRef}: [Congestion Control (CC)
Channel](#name-congestion-control-cc-chann){.selfRef}
:::

[]{#name-forward-erasure-correction-}

::: {#fig_sep-channel-fec}
::: {#section-2.2-3.1 .alignLeft .art-text .artwork}
     SENDER                                RECEIVER

    +------+                               +------+
    |      |           source and/or       |      |
    |      | -----    repair symbols  ---->|      |
    | FEC  |                               | FEC  |
    |      |           signaling           |      |
    |      | <---   recovered symbols  ----|      |
    +------+                               +------+
:::

[Figure 2](#figure-2){.selfRef}: [Forward Erasure Correction (FEC)
Channel](#name-forward-erasure-correction-){.selfRef}
:::

Inside a host, the CC and FEC entities can be regarded as conceptually
separate:[¶](#section-2.2-4){.pilcrow}

[]{#name-separate-entities-sender-si}

::: {#fig_sep-entities-srv}
::: {#section-2.2-5.1 .alignLeft .art-text .artwork}
      |            ^             |             ^
      | source     | coding      |packets      | sending
      | packets    | rate        |requirements | rate (or
      v            |             v             | window)
    +---------------+source     +-----------------+
    |    FEC        |and/or     |    CC           |
    |               |repair     |                 |network
    |               |symbols    |                 |packets
    +---------------+==>        +-----------------+==>
      ^                                       ^
      | signaling                             | network
      | recovered symbols                     | information
:::

[Figure 3](#figure-3){.selfRef}: [Separate Entities
(Sender-Side)](#name-separate-entities-sender-si){.selfRef}
:::

[]{#name-separate-entities-receiver-}

::: {#fig_sep-entities-clt}
::: {#section-2.2-6.1 .alignLeft .art-text .artwork}
      |                                 |
      | source and/or                   | network
      | repair symbols                  | packets
      v                                 v
    +---------------+              +-----------------+
    |    FEC        |signaling     |    CC           |
    |               |recovered     |                 |network
    |               |symbols       |                 |information
    +---------------+==>           +-----------------+==>
:::

[Figure 4](#figure-4){.selfRef}: [Separate Entities
(Receiver-Side)](#name-separate-entities-receiver-){.selfRef}
:::

Figures [3](#fig_sep-entities-srv){.xref} and
[4](#fig_sep-entities-clt){.xref} provide more details than Figures
[1](#fig_sep-channel-cc){.xref} and [2](#fig_sep-channel-fec){.xref}.
Some elements are introduced:[¶](#section-2.2-7){.pilcrow}

[]{.break}

\'network information\' (input control plane for the transport including CC):
:   refers not only to the network information that is explicitly
    signaled from the receiver but all the information a congestion
    control obtains from a network.[¶](#section-2.2-8.2){.pilcrow}
:   

\'requirements\' (input control plane for the transport including CC):
:   refers to application requirements such as upper/lower rate bounds,
    periods of quiescence, or a priority.[¶](#section-2.2-8.4){.pilcrow}
:   

\'sending rate (or window)\' (output control plane for the transport including CC):
:   refers to the rate at which a congestion control decides to transmit
    packets based on \'network
    information\'.[¶](#section-2.2-8.6){.pilcrow}
:   

\'signaling recovered symbols\' (input control plane for the FEC):
:   refers to the information a FEC sender can obtain from a FEC
    receiver about the performance of the FEC solution as seen by the
    receiver.[¶](#section-2.2-8.8){.pilcrow}
:   

\'coding rate\' (output control plane for the FEC):
:   refers to the coding rate that is used by the FEC solution (i.e.,
    proportion of transmitted symbols that carry useful
    data).[¶](#section-2.2-8.10){.pilcrow}
:   

\'network packets\' (output data plane for the CC):
:   refers to the data that is transmitted by a CC sender to a CC
    receiver. The network packets may contain source and/or repair
    symbols.[¶](#section-2.2-8.12){.pilcrow}
:   

\'source and/or repair symbols\' (data plane for the FEC):
:   refers to the data that is transmitted by a FEC sender to a FEC
    receiver. The sender can decide to send source symbols only (meaning
    that the coding rate is 0), repair symbols only (if the solution
    decides not to send the original source symbols), or a mix of
    both.[¶](#section-2.2-8.14){.pilcrow}
:   

The inputs to FEC (incoming data packets without repair symbols and
signaling from the receiver about losses and/or recovered symbols) are
distinct from the inputs to CC. The latter calculates a sending rate or
window from network information, and it takes the packet to send as
input, sometimes along with application requirements such as upper/lower
rate bounds, periods of quiescence, or a priority. It is not clear that
the ACK signals feeding into a congestion control algorithm are useful
to FEC in their raw form, and vice versa; information about recovered
blocks may be quite irrelevant to a CC
algorithm.[¶](#section-2.2-9){.pilcrow}
:::

::: {#section-2.3 .section}
### [2.3.](#section-2.3){.section-number .selfRef} [Relation between Transport Layer and Application Requirements](#name-relation-between-transport-){.section-name .selfRef} {#name-relation-between-transport-}

The choice of the adequate transport layer may be related to application
requirements and the services offered by a transport protocol
\[[RFC8095](#RFC8095){.xref}\]:[¶](#section-2.3-1){.pilcrow}

The transport layer may implement a retransmission mechanism to
guarantee the reliability of a data transfer (e.g., TCP). Depending on
how the FEC and CC functions are scheduled (FEC above CC ([Section
3](#sec_fec-above){.xref}), FEC in CC ([Section 4](#sec_fec-in){.xref}),
and FEC below CC ([Section 5](#sec_fec-below){.xref})), the impact of
reliable transport on the FEC reliability mechanisms is
different.[¶](#section-2.3-2){.pilcrow}

The transport layer may provide an unreliable transport service (e.g.,
UDP or the Datagram Congestion Control Protocol (DCCP)
\[[RFC4340](#RFC4340){.xref}\]) or a partially reliable transport
service (e.g., the Stream Control Transmission Protocol (SCTP) with the
partial reliability extension \[[RFC3758](#RFC3758){.xref}\] or QUIC
with the unreliable datagram extension \[[RFC9221](#RFC9221){.xref}\]).
Depending on the amount of redundancy and network conditions, there
could be cases where it becomes impossible to carry traffic. This is
further discussed in [Section 3](#sec_fec-above){.xref} where a \"FEC
above CC\" case is assessed and in Sections [4](#sec_fec-in){.xref} and
[5](#sec_fec-below){.xref} where \"FEC in CC\" and \"FEC below CC\" are
assessed, respectively.[¶](#section-2.3-3){.pilcrow}
:::

::: {#section-2.4 .section}
### [2.4.](#section-2.4){.section-number .selfRef} [Scope of the Document Concerning Transport Multipath and Multistream Applications](#name-scope-of-the-document-conce){.section-name .selfRef} {#name-scope-of-the-document-conce}

The application layer can be composed of several streams above FEC and
transport-layer instances. The transport layer can exploit a multipath
mechanism. The different streams could exploit different paths between
the sender and the receiver. Moreover, a single-stream application could
also exploit a multipath transport mechanism. This section describes
what is in the scope of this document with regard to multistream
applications and multipath transport
protocols.[¶](#section-2.4-1){.pilcrow}

The different combinations between multistream applications and
multipath transport are the following: (1) one application-layer stream
as input packets above a combination of FEC and multipath (Mpath)
transport layers ([Figure 5](#fig_multi-scope-single-stream){.xref}) and
(2) multiple application-layer streams as input packets above a
combination of FEC and multipath (Mpath) or single path (Spath)
transport layers ([Figure 6](#fig_multi-scope-multi-stream){.xref}).
This document further details cases I (in [Section
3.7](#subsec_multipath_above){.xref}), II (in [Section
4.6](#subsec_multipath_in){.xref}), and III (in [Section
5.7](#subsec_multipath_below){.xref}) as illustrated in [Figure
5](#fig_multi-scope-single-stream){.xref}. Cases IV, V, and VI of
[Figure 6](#fig_multi-scope-multi-stream){.xref} are related to how
multiple streams are managed by a single transport or FEC layer; this
does not directly concern the interaction between FEC and the transport
and is out of the scope of this document.[¶](#section-2.4-2){.pilcrow}

[]{#name-transport-multipath-and-sin}

::: {#fig_multi-scope-single-stream}
::: {#section-2.4-3.1 .alignLeft .art-text .artwork}
          CASE I             CASE II            CASE III
     +---------------+  +---------------+  +---------------+
     |    Stream 1   |  |    Stream 2   |  |    Stream 3   |
     +---------------+  +---------------+  +---------------+

     +---------------+  +---------------+  +---------------+
     |      FEC      |  |      FEC      |  |Mpath Transport|
     +---------------+  |      in       |  +---------------+
                        |Mpath Transport|
     +---------------+  |               |  +-----+   +-----+
     |Mpath Transport|  |               |  |Flow1|...|FlowM|
     +---------------+  +---------------+  +-----+   +-----+

     +-----+   +-----+  +-----+   +-----+  +-----+   +-----+
     |Flow1|...|FlowM|  |Flow1|...|FlowM|  | FEC |...| FEC |
     +-----+   +-----+  +-----+   +-----+  +-----+   +-----+
:::

[Figure 5](#figure-5){.selfRef}: [Transport Multipath and Single-Stream
Applications - in the Scope of the
Document](#name-transport-multipath-and-sin){.selfRef}
:::

[]{#name-transport-single-path-trans}

::: {#fig_multi-scope-multi-stream}
::: {#section-2.4-4.1 .alignLeft .art-text .artwork}
          CASE IV                CASE  V                CASE VI
    +-------+   +-------+  +-------+   +-------+  +-------+   +-------+
    |Stream1|...|StreamM|  |Stream1|...|StreamM|  |Stream1|...|StreamM|
    +-------+   +-------+  +-------+   +-------+  +-------+   +-------+

    +-------------------+  +-------------------+  +-------------------+
    |                   |  |        FEC        |  |  Mpath Transport  |
    |        FEC        |  +-------------------+  +-------------------+
    |  above/in/below   |
    |  Spath Transport  |  +-------------------+  +-------------------+
    |                   |  |  Mpath Transport  |  |        FEC        |
    +-------------------+  +-------------------+  +-------------------+

    +-------------------+  +-----+       +-----+  +-----+       +-----+
    |        Flow       |  |Flow1|  ...  |FlowM|  |Flow1|  ...  |FlowM|
    +-------------------+  +-----+       +-----+  +-----+       +-----+
:::

[Figure 6](#figure-6){.selfRef}: [Transport Single Path, Transport
Multipath, and Multistream Applications - out of the Scope of the
Document](#name-transport-single-path-trans){.selfRef}
:::
:::

::: {#subsec_def_code}
::: {#section-2.5 .section}
### [2.5.](#section-2.5){.section-number .selfRef} [Types of Coding](#name-types-of-coding){.section-name .selfRef} {#name-types-of-coding}

\[[RFC8406](#RFC8406){.xref}\] summarizes recommended terminology for
Network Coding concepts and constructs. In particular, the document
identifies the following coding types (among many
others):[¶](#section-2.5-1){.pilcrow}

[]{.break}

Block Coding:
:   Coding technique where the input Flow must first be segmented into a
    sequence of blocks; FEC encoding and decoding are performed
    independently on a per-block basis.[¶](#section-2.5-2.2){.pilcrow}
:   

Sliding Window Coding:
:   General class of coding techniques that rely on a sliding encoding
    window.[¶](#section-2.5-2.4){.pilcrow}
:   

The decoding scheme may not be able to decode all the symbols. The
chance of decoding the erased packets depends on the size of the
encoding window, the coding rate, and the distribution of erasure in the
transmission channel. The FEC channel may let the client transmit
information related to the need of supplementary symbols to adapt the
level of reliability. Partial and full reliability could be
envisioned.[¶](#section-2.5-3){.pilcrow}

[]{.break}

Full reliability:
:   The receiver may hold symbols until the decoding of source symbols
    is possible. In particular, if the codec does not enable a subset of
    the system to be inverted, the receiver would have to wait for a
    certain minimum amount of repair packets before it can recover all
    the source symbols.[¶](#section-2.5-4.2){.pilcrow}
:   

Partial reliability:
:   The receiver cannot deliver source symbols that could not have been
    decoded to the upper layer. For a fixed size of encoding window (for
    Sliding Window Coding) or of blocks (for Block Coding) containing
    the source symbols, increasing the amount of repair symbols would
    increase the chances of recovering the erased symbols. However, this
    would have an impact on memory requirements, the cost of encoding
    and decoding processes, and the network
    overhead.[¶](#section-2.5-4.4){.pilcrow}
:   
:::
:::
:::
:::

::: {#sec_fec-above}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [FEC above the Transport](#name-fec-above-the-transport){.section-name .selfRef} {#name-fec-above-the-transport}

[]{#name-fec-above-the-transport-2}

::: {#fig_fec-above}
::: {#section-3-1.1 .alignLeft .art-text .artwork}
     | source                               ^ source
     | packets                              | packets
     v                                      |
    +-------------+                      +-------------+
    |FEC          |             signaling|FEC          |
    |             |             recovered|             |
    |             |               symbols|             |
    |             |                   <==|             |
    +-------------+                      +-------------+
     | source  ^                            ^ source
     | and/or  | sending                    | and/or
     | repair  | rate                       | repair
     | symbols | (or window)                | symbols
     v         |                            |
    +-------------+                      +-------------+
    |Transport    |               network|Transport    |
    |(incl. CC)   |           information|             |
    |             |network            <==|             |
    |             |packets               |             |
    +-------------+==>                   +-------------+

        SENDER                               RECEIVER
:::

[Figure 7](#figure-7){.selfRef}: [FEC above the
Transport](#name-fec-above-the-transport-2){.selfRef}
:::

[Figure 7](#fig_fec-above){.xref} presents an architecture where FEC
operates on top of the transport.[¶](#section-3-2){.pilcrow}

The advantage of this approach is that the FEC overhead does not
contribute to congestion in the network when congestion control is
implemented at the transport layer, because the repair symbols are sent
following the congestion window or rate determined by the CC mechanism.
This can result in an improved quality of experience for
latency-sensitive applications such as Voice over IP (VoIP) or any
not-fully reliable services.[¶](#section-3-3){.pilcrow}

This approach requires that the transport protocol does not implement a
fully reliable in-order data transfer service (e.g., like TCP). QUIC
with the unreliable datagram extension \[[RFC9221](#RFC9221){.xref}\] is
an example of a protocol for which this is relevant. In cases where the
partially reliable transport is blocked and a fallback to a reliable
transport is proposed, there is a risk for bad interactions between
reliability at the transport level and coding schemes. For reliable
transfers, coding usage does not guarantee better performance; instead,
it would mainly reduce goodput.[¶](#section-3-4){.pilcrow}

::: {#subsec_fairness_above}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Fairness and Impact on Non-coded Flows](#name-fairness-and-impact-on-non-){.section-name .selfRef} {#name-fairness-and-impact-on-non-}

The addition of coding within the flow does not influence the
interaction between coded and non-coded flows. This interaction would
mainly depend on the congestion controls associated with each
flow.[¶](#section-3.1-1){.pilcrow}
:::
:::

::: {#subsec_cc-recov-interaction_above}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Congestion Control and Recovered Symbols](#name-congestion-control-and-reco){.section-name .selfRef} {#name-congestion-control-and-reco}

The congestion control mechanism receives network packets and may not be
able to differentiate repair symbols from actual source ones. This
differentiation requires a transport protocol to provide more than the
services described in \[[RFC8095](#RFC8095){.xref}\], such as
specifically indicating what information has been repaired. The
relevance of adding coding at the application layer is related to the
needs of the application. For real-time applications using an unreliable
or partially reliable transport, this approach may reduce the number of
losses perceived by the application.[¶](#section-3.2-1){.pilcrow}
:::
:::

::: {#subsec_cc-nc-interaction_above}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Interactions between Congestion Control and Coding Rates](#name-interactions-between-conges){.section-name .selfRef} {#name-interactions-between-conges}

The coding rate applied at the application layer mainly depends on the
available rate or congestion window given by the congestion control
underneath. The coding rate could be adapted to avoid adding overhead
when the minimum required data rate of the application is not provided
by the congestion control underneath. When the congestion control allows
sending faster than the application needs, adding coding can reduce
packet losses and improve the quality of experience (provided that an
unreliable or partially reliable transport is
used).[¶](#section-3.3-1){.pilcrow}
:::
:::

::: {#subsec_cc-useless-interaction_above}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [On Useless Repair Symbols](#name-on-useless-repair-symbols){.section-name .selfRef} {#name-on-useless-repair-symbols}

The only case where adding useless repair symbols does not obviously
result in reduced goodput is when the application rate is limited (e.g.,
VoIP traffic). In this case, useless repair symbols would only impact
the amount of data generated in the network. Extra data in the network
can, however, increase the likelihood of increasing delay and/or packet
loss, which could provoke a congestion control reaction that would
degrade goodput.[¶](#section-3.4-1){.pilcrow}
:::
:::

::: {#subsec_partial_order_above}
::: {#section-3.5 .section}
### [3.5.](#section-3.5){.section-number .selfRef} [On Partial Ordering at FEC Level](#name-on-partial-ordering-at-fec-){.section-name .selfRef} {#name-on-partial-ordering-at-fec-}

Irrespective of the transport protocol, a FEC mechanism does not require
implementing a reordering mechanism if the application does not need it.
However, if the application needs in-order delivery of packets, a
reordering mechanism at the receiver is
required.[¶](#section-3.5-1){.pilcrow}
:::
:::

::: {#subsec_partial_rel_above}
::: {#section-3.6 .section}
### [3.6.](#section-3.6){.section-number .selfRef} [On Partial Reliability at FEC Level](#name-on-partial-reliability-at-f){.section-name .selfRef} {#name-on-partial-reliability-at-f}

The application may require partial reliability. In this case, the
coding rate of a FEC mechanism could be adapted based on inputs from the
application and the trade-off between latency and packet loss. Partial
reliability impacts the type of FEC and type of codec that can be used,
such as discussed in [Section
2.5](#subsec_def_code){.xref}.[¶](#section-3.6-1){.pilcrow}
:::
:::

::: {#subsec_multipath_above}
::: {#section-3.7 .section}
### [3.7.](#section-3.7){.section-number .selfRef} [On Multipath Transport and FEC Mechanism](#name-on-multipath-transport-and-){.section-name .selfRef} {#name-on-multipath-transport-and-}

Whether the transport protocol exploits multiple paths or not does not
have an impact on the FEC mechanism.[¶](#section-3.7-1){.pilcrow}
:::
:::
:::
:::

::: {#sec_fec-in}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [FEC within the Transport](#name-fec-within-the-transport){.section-name .selfRef} {#name-fec-within-the-transport}

[]{#name-fec-in-the-transport}

::: {#fig_fec-in}
::: {#section-4-1.1 .alignLeft .art-text .artwork}
     | source                               ^ source
     | packets                              | packets
     v                                      |
    +------------+                      +------------+
    | Transport  |                      | Transport  |
    |            |                      |            |
    | +---+ +--+ |             signaling| +---+ +--+ |
    | |FEC| |CC| |             recovered| |FEC| |CC| |
    | +---+ +--+ |               symbols| +---+ +--+ |
    |            |                   <==|            |
    |            |network        network|            |
    |            |packets    information|            |
    +------------+ ==>               <==+------------+

        SENDER                              RECEIVER
:::

[Figure 8](#figure-8){.selfRef}: [FEC in the
Transport](#name-fec-in-the-transport){.selfRef}
:::

[Figure 8](#fig_fec-in){.xref} presents an architecture where FEC
operates within the transport. The repair symbols are sent within what
the congestion window or calculated rate allows, such as in
\[[CTCP](#CTCP){.xref}\].[¶](#section-4-2){.pilcrow}

The advantage of this approach is that it allows a joint optimization of
CC and FEC. Moreover, the transmission of repair symbols does not add
congestion in potentially congested networks but helps repair lost
packets (such as tail losses). This joint optimization is the key to
prevent flows to consume the whole available capacity. The amount of
repair traffic injected should not lead to congestion. As denoted in
\[[FEC-CONGESTION-CONTROL](#I-D.singh-rmcat-adaptive-fec){.xref}\], an
increase of the repair ratio should be done conjointly with a decrease
of the source sending rate.[¶](#section-4-3){.pilcrow}

The drawback of this approach is that it may require specific signaling
and transport services that may not be described in
\[[RFC8095](#RFC8095){.xref}\]. Therefore, development and maintenance
may require specific efforts at both the transport and the coding
levels, and the design of the solution may end up being complex to suit
different deployment needs.[¶](#section-4-4){.pilcrow}

For reliable transfers, including redundancy reduces goodput for long
transfers, but the amount of repair symbols can be adapted, e.g.,
depending on the congestion window size. There is a trade-off between 1)
the capacity that could have been exploited by application data instead
of transmitting source packets and 2) the benefits derived from
transmitting repair symbols (e.g., unlocking the receive buffer if it is
limiting). The coding ratio needs to be carefully designed. For small
files, sending repair symbols when there is no more data to transmit
could help to reduce the transfer time. Sending repair symbols can avoid
the silence period between the transmission of the last packet in the
send buffer and 1) firing a retransmission of lost packets or 2) the
transmission of new packets.[¶](#section-4-5){.pilcrow}

Examples of the solution could be to add a given percentage of the
congestion window or rate as supplementary symbols or to send a fixed
amount of repair symbols at a fixed rate. The redundancy flow can be
decorrelated from the congestion control that manages source packets; a
separate congestion control entity could be introduced to manage the
amount of recovered symbols to transmit on the FEC channel. The separate
congestion control instances could be made to work together while
adhering to priorities, as in coupled congestion control for RTP media
\[[RFC8699](#RFC8699){.xref}\] in case all traffic can be assumed to
take the same path, or otherwise with a multipath congestion window
coupling mechanism as in Multipath TCP \[[RFC6356](#RFC6356){.xref}\].
Another possibility would be to exploit a lower-than-best-effort
congestion control \[[RFC6297](#RFC6297){.xref}\] for repair
symbols.[¶](#section-4-6){.pilcrow}

::: {#subsec_fairness_in}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Fairness and Impact on Non-coded Flows](#name-fairness-and-impact-on-non-c){.section-name .selfRef} {#name-fairness-and-impact-on-non-c}

Specific interaction between congestion controls and coding schemes can
be proposed (see Sections [4.2](#subsec_cc-nc-interaction_in){.xref} and
[4.3](#subsec_cc-useless-interaction_in){.xref}). If no specific
interaction is introduced, the coding scheme may hide congestion losses
from the congestion controller, and the description of [Section
5](#sec_fec-below){.xref} may apply.[¶](#section-4.1-1){.pilcrow}
:::
:::

::: {#subsec_cc-nc-interaction_in}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Interactions between Congestion Control and Coding Rates](#name-interactions-between-congest){.section-name .selfRef} {#name-interactions-between-congest}

The receiver can differentiate between source packets and repair
symbols. The receiver may indicate both the number of source packets
received and the repair symbols that were actually useful in the
recovery process of packets. The congestion control at the sender can
then exploit this information to tune congestion control
behavior.[¶](#section-4.2-1){.pilcrow}

There is an important flexibility in the trade-off, inherent to the use
of coding, between (1) reducing goodput when useless repair symbols are
transmitted and (2) helping to recover from losses earlier than with
retransmissions. The receiver may indicate to the sender the number of
packets that have been received or recovered. The sender may use this
information to tune the coding ratio. For example, coupling an increased
transmission rate with an increasing or decreasing coding rate could be
envisioned. A server may use a decreasing coding rate as a probe of the
channel capacity and adapt the congestion control transmission
rate.[¶](#section-4.2-2){.pilcrow}
:::
:::

::: {#subsec_cc-useless-interaction_in}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [On Useless Repair Symbols](#name-on-useless-repair-symbols-2){.section-name .selfRef} {#name-on-useless-repair-symbols-2}

The sender may exploit the information given by the receiver to reduce
the number of useless repair symbols and improve
goodput.[¶](#section-4.3-1){.pilcrow}
:::
:::

::: {#subsec_partial_order_in}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [On Partial Ordering at FEC and/or Transport Level](#name-on-partial-ordering-at-fec-a){.section-name .selfRef} {#name-on-partial-ordering-at-fec-a}

The application may require in-order delivery of packets. In this case,
both FEC and transport-layer mechanisms should guarantee that packets
are delivered in order. If partial ordering is requested by the
application, both the FEC and transport could relax the constraints
related to in-order delivery; partial ordering impacts both the
congestion control and the type of FEC and type of codec that can be
used.[¶](#section-4.4-1){.pilcrow}
:::
:::

::: {#subsec_partial_rel_in}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [On Partial Reliability at FEC Level](#name-on-partial-reliability-at-fe){.section-name .selfRef} {#name-on-partial-reliability-at-fe}

The application may require partial reliability. The reliability offered
by FEC may be sufficient with no retransmission required. This depends
on application needs and the trade-off between latency and loss. Partial
reliability impacts the type of FEC and type of codec that can be used,
such as discussed in [Section
2.5](#subsec_def_code){.xref}.[¶](#section-4.5-1){.pilcrow}
:::
:::

::: {#subsec_multipath_in}
::: {#section-4.6 .section}
### [4.6.](#section-4.6){.section-number .selfRef} [On Transport Multipath and Subpath FEC Coding Rate](#name-on-transport-multipath-and-){.section-name .selfRef} {#name-on-transport-multipath-and-}

The sender may adapt the coding rate of each of the single subpaths
whether the congestion control is coupled or not. There is an important
flexibility on how the coding rate is tuned depending on the
characteristics of each subpath.[¶](#section-4.6-1){.pilcrow}
:::
:::
:::
:::

::: {#sec_fec-below}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [FEC below the Transport](#name-fec-below-the-transport){.section-name .selfRef} {#name-fec-below-the-transport}

[]{#name-fec-below-the-transport-2}

::: {#fig_fec-below}
::: {#section-5-1.1 .alignLeft .art-text .artwork}
     | source                               ^ source
     | packets                              | packets
     v                                      |
    +--------------+                      +--------------+
    |Transport     |               network|Transport     |
    |(including CC)|           information|              |
    |              |                   <==|              |
    +--------------+                      +--------------+
     | network packets                      ^ network packets
     v                                      |
    +--------------+                      +--------------+
    | FEC          |source                |  FEC         |
    |              |and/or       signaling|              |
    |              |repair       recovered|              |
    |              |symbols        symbols|              |
    |              |==>                <==|              |
    +--------------+                      +--------------+

        SENDER                                RECEIVER
:::

[Figure 9](#figure-9){.selfRef}: [FEC below the
Transport](#name-fec-below-the-transport-2){.selfRef}
:::

[Figure 9](#fig_fec-below){.xref} presents an architecture where FEC is
applied end to end below the transport layer but above the link layer.
Note that it is common to apply FEC at the link layer on one or more of
the links that make up the end-to-end path. The application of FEC at
the link layer contributes to the total capacity that a link exposes to
upper layers, but it may not be visible to either the end-to-end sender
or the receiver, if the end-to-end sender and receiver are separated by
more than one link; this is therefore out of scope for this document.
This includes the use of FEC on top of a link layer in scenarios where
the link is known by configuration. In the scenario considered here, the
repair symbols are not visible to the end-to-end congestion controller
and may be sent on top of what is allowed by the congestion
control.[¶](#section-5-2){.pilcrow}

Including redundancy adds traffic without reducing goodput but incurs
potential fairness issues. The effective bit rate is higher than the
CC\'s computed fair share due to the transmission of repair symbols, and
losses are hidden from the transport. This may cause a problem for
loss-based congestion detection, but it is not a problem for delay-based
congestion detection.[¶](#section-5-3){.pilcrow}

The advantage of this approach is that it can result in performance
gains when there are persistent transmission losses along the
path.[¶](#section-5-4){.pilcrow}

The drawback of this approach is that it can induce congestion in
already congested networks. The coding ratio needs to be carefully
designed.[¶](#section-5-5){.pilcrow}

Examples of the solution could be to add a given percentage of the
congestion window or rate as supplementary symbols or to send a fixed
amount of repair symbols at a fixed rate. The redundancy flow can be
decorrelated from the congestion control that manages source packets; a
separate congestion control entity could be introduced to manage the
amount of recovered symbols to transmit on the FEC channel. The separate
congestion control instances could be made to work together while
adhering to priorities, as in coupled congestion control for RTP media
\[[RFC8699](#RFC8699){.xref}\] in case all traffic can be assumed to
take the same path, or otherwise with a multipath congestion window
coupling mechanism as in Multipath TCP \[[RFC6356](#RFC6356){.xref}\].
Another possibility would be to exploit a lower-than-best-effort
congestion control \[[RFC6297](#RFC6297){.xref}\] for repair
symbols.[¶](#section-5-6){.pilcrow}

::: {#subsec_fairness_below}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Fairness and Impact on Non-coded Flows](#name-fairness-and-impact-on-non-co){.section-name .selfRef} {#name-fairness-and-impact-on-non-co}

The coding scheme may hide congestion losses from the congestion
controller. There are cases where this can drastically reduce the
goodput of non-coded flows. Depending on the congestion control, it may
be possible to signal to the congestion control mechanism that there was
congestion (loss) even when a packet has been recovered, e.g., using
ECN, to reduce the impact on the non-coded flows (see [Section
5.2](#subsec_cc-recov-interaction_below){.xref} and
\[[TENTET](#TENTET){.xref}\]).[¶](#section-5.1-1){.pilcrow}
:::
:::

::: {#subsec_cc-recov-interaction_below}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Congestion Control and Recovered Symbols](#name-congestion-control-and-recov){.section-name .selfRef} {#name-congestion-control-and-recov}

The congestion control may not be aware of the existence of a coding
scheme underneath it. The congestion control may behave as if no coding
scheme had been introduced. The only way for a coding channel to
indicate that symbols have been lost but recovered is to exploit
existing signaling that is understood by the congestion control
mechanism. An example would be to indicate to a TCP sender that a packet
has been received, yet congestion has occurred, by using ECN signaling
\[[TENTET](#TENTET){.xref}\].[¶](#section-5.2-1){.pilcrow}
:::
:::

::: {#subsec_cc-nc-interaction_below}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Interactions between Congestion Control and Coding Rates](#name-interactions-between-congesti){.section-name .selfRef} {#name-interactions-between-congesti}

The coding rate can be tuned depending on the number of recovered
symbols and the rate at which the sender transmits data. If the coding
scheme is not aware of the congestion control implementation, it is hard
for the coding scheme to apply the relevant coding
rate.[¶](#section-5.3-1){.pilcrow}
:::
:::

::: {#subsec_cc-useless-interaction_below}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [On Useless Repair Symbols](#name-on-useless-repair-symbols-3){.section-name .selfRef} {#name-on-useless-repair-symbols-3}

Useless repair symbols only impact the load on the network without
actual gain for the coded flow. Using feedback signaling, FEC mechanisms
can measure the ratio between the number of symbols that were actually
used and the number of symbols that were useless, and adjust the coding
rate.[¶](#section-5.4-1){.pilcrow}
:::
:::

::: {#subsec_partial_order_below}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [On Partial Ordering at FEC Level with In-Order Delivery Transport](#name-on-partial-ordering-at-fec-l){.section-name .selfRef} {#name-on-partial-ordering-at-fec-l}

The transport above the FEC channel may support out-of-order delivery of
packets; reordering mechanisms at the receiver may not be necessary. In
cases where the transport requires in-order delivery, the FEC channel
may need to implement a reordering mechanism. Otherwise, spurious
retransmissions may occur at the transport
level.[¶](#section-5.5-1){.pilcrow}
:::
:::

::: {#subsec_partial_rel_below}
::: {#section-5.6 .section}
### [5.6.](#section-5.6){.section-number .selfRef} [On Partial Reliability at FEC Level](#name-on-partial-reliability-at-fec){.section-name .selfRef} {#name-on-partial-reliability-at-fec}

The transport or application layer above the FEC channel may require
partial reliability only. FEC may provide an unnecessary service unless
it is aware of the reliability requirements. Partial reliability impacts
the type of FEC and codec that can be used, such as discussed in
[Section 2.5](#subsec_def_code){.xref}.[¶](#section-5.6-1){.pilcrow}
:::
:::

::: {#subsec_multipath_below}
::: {#section-5.7 .section}
### [5.7.](#section-5.7){.section-number .selfRef} [FEC Not Aware of Transport Multipath](#name-fec-not-aware-of-transport-){.section-name .selfRef} {#name-fec-not-aware-of-transport-}

The transport may exploit multiple paths without the FEC channel being
aware of it. If FEC is aware that multiple paths are in use, FEC can be
applied to all subflows as an aggregate, or to each of the subflows
individually. If FEC is not aware that multiple paths are in use, FEC
can only be applied to each subflow individually. When FEC is applied to
all the flows as an aggregate, the varying characteristics of the
individual paths may lead to a risk for the coding rate to be inadequate
for the characteristics of the individual
paths.[¶](#section-5.7-1){.pilcrow}
:::
:::
:::
:::

::: {#sec_research}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Research Recommendations and Questions](#name-research-recommendations-an){.section-name .selfRef} {#name-research-recommendations-an}

This section provides a short state-of-the art overview of activities
related to congestion control and coding. The objective is to identify
open research questions and contribute to advice when evaluating coding
mechanisms.[¶](#section-6-1){.pilcrow}

::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Activities Related to Congestion Control and Coding](#name-activities-related-to-conge){.section-name .selfRef} {#name-activities-related-to-conge}

We map activities related to congestion control and coding with the
organization presented in this document:[¶](#section-6.1-1){.pilcrow}

[]{.break}

For the FEC above transport case:
:   \[[RFC8680](#RFC8680){.xref}\][¶](#section-6.1-2.2){.pilcrow}
:   

For the FEC within transport case:
:   \[[CODING-FOR-QUIC](#I-D.swett-nwcrg-coding-for-quic){.xref}\],
    \[[QUIC-FEC](#QUIC-FEC){.xref}\], and
    \[[RFC5109](#RFC5109){.xref}\][¶](#section-6.1-2.4){.pilcrow}
:   

For the FEC below transport case:
:   \[[NCTCP](#NCTCP){.xref}\] and
    \[[TETRYS](#I-D.detchart-nwcrg-tetrys){.xref}\][¶](#section-6.1-2.6){.pilcrow}
:   
:::

::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Open Research Questions](#name-open-research-questions){.section-name .selfRef} {#name-open-research-questions}

There is a general trade-off, inherent to the use of coding, between (1)
reducing goodput when useless repair symbols are transmitted and (2)
helping to recover from transmission and congestion
losses.[¶](#section-6.2-1){.pilcrow}

::: {#section-6.2.1 .section}
#### [6.2.1.](#section-6.2.1){.section-number .selfRef} [Parameter Derivation](#name-parameter-derivation){.section-name .selfRef} {#name-parameter-derivation}

There is a trade-off related to the amount of redundancy to add as a
function of the transport-layer protocol and application
requirements.[¶](#section-6.2.1-1){.pilcrow}

\[[RFC8095](#RFC8095){.xref}\] describes the mechanisms provided by
existing IETF protocols such as TCP, SCTP, or RTP.
\[[RFC8406](#RFC8406){.xref}\] describes the variety of coding
techniques. The number of combinations makes the determination of an
optimum parameters derivation very complex. This depends on application
requirements and deployment context.[¶](#section-6.2.1-2){.pilcrow}

[Appendix C](https://www.rfc-editor.org/rfc/rfc8681#appendix-C){.relref}
of \[[RFC8681](#RFC8681){.xref}\] describes how to tune the parameters
for a target use case. However, this discussion does not integrate
congestion-controlled end points.[¶](#section-6.2.1-3){.pilcrow}

[]{.break}

Research question 1:
:   \"Is there a way to dynamically adjust the codec characteristics
    depending on the transmission channel, the transport protocol, and
    application requirements?\"[¶](#section-6.2.1-4.2){.pilcrow}
:   

Research question 2:
:   \"Should we apply specific per-stream FEC mechanisms when multiple
    streams with different reliability needs are carried
    out?\"[¶](#section-6.2.1-4.4){.pilcrow}
:   
:::

::: {#section-6.2.2 .section}
#### [6.2.2.](#section-6.2.2){.section-number .selfRef} [New Signaling Methods and Fairness](#name-new-signaling-methods-and-f){.section-name .selfRef} {#name-new-signaling-methods-and-f}

Recovering lost symbols may hide congestion losses from the congestion
control. Disambiguating ACKed packets from rebuilt packets would help
the sender adapt its sending rate accordingly. There are opportunities
for introducing interaction between congestion control and coding
schemes to improve the quality of experience while guaranteeing fairness
with other flows.[¶](#section-6.2.2-1){.pilcrow}

Some existing solutions already propose to disambiguate ACKed packets
from rebuilt packets \[[QUIC-FEC](#QUIC-FEC){.xref}\]. New signaling
methods and FEC-recovery-aware congestion controls could be proposed.
This would allow the design of adaptive coding
rates.[¶](#section-6.2.2-2){.pilcrow}

[]{.break}

Research question 3:
:   \"Should we quantify the harm that a coded flow would induce on a
    non-coded flow? How can this be reduced while still benefiting from
    advantages brought by FEC?\"[¶](#section-6.2.2-3.2){.pilcrow}
:   

Research question 4:
:   \"If transport and FEC senders are collocated and close to the
    client, and FEC is applied only on the last mile, e.g., to ignore
    losses on a noisy wireless link, would this raise fairness
    issues?\"[¶](#section-6.2.2-3.4){.pilcrow}
:   

Research question 5:
:   \"Should we propose a generic API to allow dynamic interactions
    between a transport protocol and a coding scheme? This should
    consider existing APIs between application and transport
    layers.\"[¶](#section-6.2.2-3.6){.pilcrow}
:   
:::
:::

::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Recommendations and Advice for Evaluating Coding Mechanisms](#name-recommendations-and-advice-){.section-name .selfRef} {#name-recommendations-and-advice-}

[]{.break}

Research Recommendation 1:
:   \"From a congestion control point of view, a recovered packet must
    be considered as a lost packet. This does not apply to the usage of
    FEC on a path that is known to be
    lossy.\"[¶](#section-6.3-1.2){.pilcrow}
:   

Research Recommendation 2:
:   \"New research contributions should be mapped following the
    organization of this document (above, below, and in the congestion
    control) and should consider congestion control aspects when
    proposing and comparing FEC coding solutions in communication
    systems.\"[¶](#section-6.3-1.4){.pilcrow}
:   

Research Recommendation 3:
:   \"When a research work aims at improving throughput by hiding the
    packet loss signal from congestion control (e.g., because the path
    between the sender and receiver is known to consist of a noisy
    wireless link), the authors should 1) discuss the advantages of
    using the proposed FEC solution compared to replacing the congestion
    control by one that ignores a portion of the encountered losses
    and 2) critically discuss the impact of hiding packet loss from the
    congestion control mechanism.\"[¶](#section-6.3-1.6){.pilcrow}
:   
:::
:::
:::

::: {#sec_IANA}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-7-1){.pilcrow}
:::
:::

::: {#sec_ecurity}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

FEC and CC schemes can contribute to DoS attacks. Moreover, the
transmission of signaling messages from the client to the server should
be protected and reliable; otherwise, an attacker may compromise FEC
rate adaptation. Indeed, an attacker could either modify the values
indicated by the client or drop signaling
messages.[¶](#section-8-1){.pilcrow}

In case of FEC below the transport, the aggregate rate of source and
repair packets may exceed the rate at which a congestion control
mechanism allows an application to send. This could result in an
application obtaining more than its fair share of the network
capacity.[¶](#section-8-2){.pilcrow}
:::
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[BEYONDJAIN\]
:   [Ware, R.]{.refAuthor}, [Mukerjee, M. K.]{.refAuthor},
    [Seshan, S.]{.refAuthor}, and [J. Sherry]{.refAuthor}, [\"Beyond
    Jain\'s Fairness Index: Setting the Bar For The Deployment of
    Congestion Control Algorithms\"]{.refTitle}, [HotNets \'19:
    Proceedings of the 18th ACM Workshop on Hot Topics in Networks
    ]{.refContent}, [DOI 10.1145/3365609.3365855]{.seriesInfo}, November
    2019, \<<https://doi.org/10.1145/3365609.3365855>\>.
:   

\[CODING-FOR-QUIC\]
:   [Swett, I.]{.refAuthor}, [Montpetit, M.]{.refAuthor},
    [Roca, V.]{.refAuthor}, and [F. Michel]{.refAuthor}, [\"Coding for
    QUIC\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-swett-nwcrg-coding-for-quic-04]{.seriesInfo},
    9 March 2020,
    \<<https://datatracker.ietf.org/doc/html/draft-swett-nwcrg-coding-for-quic-04>\>.
:   

\[CTCP\]
:   [Kim, M.]{.refAuthor}, [Cloud, J.]{.refAuthor},
    [ParandehGheibi, A.]{.refAuthor}, [Urbina, L.]{.refAuthor},
    [Fouli, K.]{.refAuthor}, [Leith, D.]{.refAuthor}, and [M.
    Medard]{.refAuthor}, [\"Network Coded TCP (CTCP)\"]{.refTitle},
    [arXiv: 1212.2291v3 ]{.refContent}, [DOI
    10.48550/arXiv.1212.2291]{.seriesInfo}, April 2013,
    \<<https://doi.org/10.48550/arXiv.1212.2291>\>.
:   

\[FEC-CONGESTION-CONTROL\]
:   [Singh, V.]{.refAuthor}, [Nagy, M.]{.refAuthor},
    [Ott, J.]{.refAuthor}, and [L. Eggert]{.refAuthor}, [\"Congestion
    Control Using FEC for Conversational Media\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-singh-rmcat-adaptive-fec-03]{.seriesInfo}, 20 March 2016,
    \<<https://datatracker.ietf.org/doc/html/draft-singh-rmcat-adaptive-fec-03>\>.
:   

\[FLOW-RATE-FAIRNESS\]
:   [Briscoe, B.]{.refAuthor}, [\"Flow Rate Fairness: Dismantling a
    Religion\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-briscoe-tsvarea-fair-02]{.seriesInfo}, 11
    July 2007,
    \<<https://datatracker.ietf.org/doc/html/draft-briscoe-tsvarea-fair-02>\>.
:   

\[NCTCP\]
:   [Sundararajan, J.]{.refAuthor}, [Shah, D.]{.refAuthor},
    [Médard, M.]{.refAuthor}, [Jakubczak, S.]{.refAuthor},
    [Mitzenmacher, M.]{.refAuthor}, and [J. Barros]{.refAuthor},
    [\"Network Coding Meets TCP: Theory and
    Implementation\"]{.refTitle}, [Proceedings of the IEEE (Volume: 99,
    Issue: 3)]{.refContent}, [DOI
    10.1109/JPROC.2010.2093850]{.seriesInfo}, March 2011,
    \<<https://doi.org/10.1109/JPROC.2010.2093850>\>.
:   

\[QUIC-FEC\]
:   [Michel, F.]{.refAuthor}, [De Coninck, Q.]{.refAuthor}, and [O.
    Bonaventure]{.refAuthor}, [\"QUIC-FEC: Bringing the benefits of
    Forward Erasure Correction to QUIC\"]{.refTitle}, [DOI
    10.23919/IFIPNetworking.2019.8816838]{.seriesInfo}, May 2019,
    \<<https://doi.org/10.23919/IFIPNetworking.2019.8816838>\>.
:   

\[RFC3168\]
:   [Ramakrishnan, K.]{.refAuthor}, [Floyd, S.]{.refAuthor}, and [D.
    Black]{.refAuthor}, [\"The Addition of Explicit Congestion
    Notification (ECN) to IP\"]{.refTitle}, [RFC 3168]{.seriesInfo},
    [DOI 10.17487/RFC3168]{.seriesInfo}, September 2001,
    \<<https://www.rfc-editor.org/info/rfc3168>\>.
:   

\[RFC3758\]
:   [Stewart, R.]{.refAuthor}, [Ramalho, M.]{.refAuthor},
    [Xie, Q.]{.refAuthor}, [Tuexen, M.]{.refAuthor}, and [P.
    Conrad]{.refAuthor}, [\"Stream Control Transmission Protocol (SCTP)
    Partial Reliability Extension\"]{.refTitle}, [RFC
    3758]{.seriesInfo}, [DOI 10.17487/RFC3758]{.seriesInfo}, May 2004,
    \<<https://www.rfc-editor.org/info/rfc3758>\>.
:   

\[RFC4340\]
:   [Kohler, E.]{.refAuthor}, [Handley, M.]{.refAuthor}, and [S.
    Floyd]{.refAuthor}, [\"Datagram Congestion Control Protocol
    (DCCP)\"]{.refTitle}, [RFC 4340]{.seriesInfo}, [DOI
    10.17487/RFC4340]{.seriesInfo}, March 2006,
    \<<https://www.rfc-editor.org/info/rfc4340>\>.
:   

\[RFC5109\]
:   [Li, A., Ed.]{.refAuthor}, [\"RTP Payload Format for Generic Forward
    Error Correction\"]{.refTitle}, [RFC 5109]{.seriesInfo}, [DOI
    10.17487/RFC5109]{.seriesInfo}, December 2007,
    \<<https://www.rfc-editor.org/info/rfc5109>\>.
:   

\[RFC5681\]
:   [Allman, M.]{.refAuthor}, [Paxson, V.]{.refAuthor}, and [E.
    Blanton]{.refAuthor}, [\"TCP Congestion Control\"]{.refTitle}, [RFC
    5681]{.seriesInfo}, [DOI 10.17487/RFC5681]{.seriesInfo}, September
    2009, \<<https://www.rfc-editor.org/info/rfc5681>\>.
:   

\[RFC6297\]
:   [Welzl, M.]{.refAuthor} and [D. Ros]{.refAuthor}, [\"A Survey of
    Lower-than-Best-Effort Transport Protocols\"]{.refTitle}, [RFC
    6297]{.seriesInfo}, [DOI 10.17487/RFC6297]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6297>\>.
:   

\[RFC6356\]
:   [Raiciu, C.]{.refAuthor}, [Handley, M.]{.refAuthor}, and [D.
    Wischik]{.refAuthor}, [\"Coupled Congestion Control for Multipath
    Transport Protocols\"]{.refTitle}, [RFC 6356]{.seriesInfo}, [DOI
    10.17487/RFC6356]{.seriesInfo}, October 2011,
    \<<https://www.rfc-editor.org/info/rfc6356>\>.
:   

\[RFC8095\]
:   [Fairhurst, G., Ed.]{.refAuthor}, [Trammell, B., Ed.]{.refAuthor},
    and [M. Kuehlewind, Ed.]{.refAuthor}, [\"Services Provided by IETF
    Transport Protocols and Congestion Control Mechanisms\"]{.refTitle},
    [RFC 8095]{.seriesInfo}, [DOI 10.17487/RFC8095]{.seriesInfo}, March
    2017, \<<https://www.rfc-editor.org/info/rfc8095>\>.
:   

\[RFC8406\]
:   [Adamson, B.]{.refAuthor}, [Adjih, C.]{.refAuthor},
    [Bilbao, J.]{.refAuthor}, [Firoiu, V.]{.refAuthor},
    [Fitzek, F.]{.refAuthor}, [Ghanem, S.]{.refAuthor},
    [Lochin, E.]{.refAuthor}, [Masucci, A.]{.refAuthor}, [Montpetit,
    M-J.]{.refAuthor}, [Pedersen, M.]{.refAuthor},
    [Peralta, G.]{.refAuthor}, [Roca, V., Ed.]{.refAuthor},
    [Saxena, P.]{.refAuthor}, and [S. Sivakumar]{.refAuthor},
    [\"Taxonomy of Coding Techniques for Efficient Network
    Communications\"]{.refTitle}, [RFC 8406]{.seriesInfo}, [DOI
    10.17487/RFC8406]{.seriesInfo}, June 2018,
    \<<https://www.rfc-editor.org/info/rfc8406>\>.
:   

\[RFC8680\]
:   [Roca, V.]{.refAuthor} and [A. Begen]{.refAuthor}, [\"Forward Error
    Correction (FEC) Framework Extension to Sliding Window
    Codes\"]{.refTitle}, [RFC 8680]{.seriesInfo}, [DOI
    10.17487/RFC8680]{.seriesInfo}, January 2020,
    \<<https://www.rfc-editor.org/info/rfc8680>\>.
:   

\[RFC8681\]
:   [Roca, V.]{.refAuthor} and [B. Teibi]{.refAuthor}, [\"Sliding Window
    Random Linear Code (RLC) Forward Erasure Correction (FEC) Schemes
    for FECFRAME\"]{.refTitle}, [RFC 8681]{.seriesInfo}, [DOI
    10.17487/RFC8681]{.seriesInfo}, January 2020,
    \<<https://www.rfc-editor.org/info/rfc8681>\>.
:   

\[RFC8699\]
:   [Islam, S.]{.refAuthor}, [Welzl, M.]{.refAuthor}, and [S.
    Gjessing]{.refAuthor}, [\"Coupled Congestion Control for RTP
    Media\"]{.refTitle}, [RFC 8699]{.seriesInfo}, [DOI
    10.17487/RFC8699]{.seriesInfo}, January 2020,
    \<<https://www.rfc-editor.org/info/rfc8699>\>.
:   

\[RFC9221\]
:   [Pauly, T.]{.refAuthor}, [Kinnear, E.]{.refAuthor}, and [D.
    Schinazi]{.refAuthor}, [\"An Unreliable Datagram Extension to
    QUIC\"]{.refTitle}, [RFC 9221]{.seriesInfo}, [DOI
    10.17487/RFC9221]{.seriesInfo}, March 2022,
    \<<https://www.rfc-editor.org/info/rfc9221>\>.
:   

\[TENTET\]
:   [Lochin, E.]{.refAuthor}, [\"On the joint use of TCP and Network
    Coding\"]{.refTitle}, [NWCRG Session, IETF 100]{.refContent},
    November 2017,
    \<<https://datatracker.ietf.org/meeting/100/materials/slides-100-nwcrg-07-lochin-on-the-joint-use-of-tcp-and-network-coding-00>\>.
:   

\[TETRYS\]
:   [Detchart, J.]{.refAuthor}, [Lochin, E.]{.refAuthor},
    [Lacan, J.]{.refAuthor}, and [V. Roca]{.refAuthor}, [\"Tetrys, an
    On-the-Fly Network Coding protocol\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-detchart-nwcrg-tetrys-08]{.seriesInfo}, 17 October 2021,
    \<<https://datatracker.ietf.org/doc/html/draft-detchart-nwcrg-tetrys-08>\>.
:   
:::

::: {#sec_acknowledgements}
::: {#appendix-A .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

Many thanks to [Spencer Dawkins]{.contact-name}, [Dave
Oran]{.contact-name}, [Carsten Bormann]{.contact-name}, [Vincent
Roca]{.contact-name}, and [Marie-Jose Montpetit]{.contact-name} for
their useful comments that helped improve the
document.[¶](#appendix-A-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-B .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Nicolas Kuhn]{.fn .nameRole}
:::

::: {.left dir="auto"}
[CNES]{.org}
:::

::: email
Email: <nicolas.kuhn.ietf@gmail.com>
:::

::: {.left dir="auto"}
[Emmanuel Lochin]{.fn .nameRole}
:::

::: {.left dir="auto"}
[ENAC]{.org}
:::

::: email
Email: <emmanuel.lochin@enac.fr>
:::

::: {.left dir="auto"}
[François Michel]{.fn .nameRole}
:::

::: {.left dir="auto"}
[UCLouvain]{.org}
:::

::: email
Email: <francois.michel@uclouvain.be>
:::

::: {.left dir="auto"}
[Michael Welzl]{.fn .nameRole}
:::

::: {.left dir="auto"}
[University of Oslo]{.org}
:::

::: email
Email: <michawe@ifi.uio.no>
:::
:::
:::
