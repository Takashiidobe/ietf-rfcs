  RFC 8927   JSON Type Definition   November 2020
  ---------- ---------------------- ---------------
  Carion     Experimental           \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Independent Submission

RFC:
:   [8927](https://www.rfc-editor.org/rfc/rfc8927){.eref}

Category:
:   Experimental

Published:
:   November 2020

ISSN:
:   2070-1721

Author:

:   ::: author
    ::: author-name
    U. Carion
    :::

    ::: org
    Segment
    :::
    :::
:::

# RFC 8927 {#rfcnum}

# JSON Type Definition {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document proposes a format, called JSON Type Definition (JTD), for
describing the shape of JavaScript Object Notation (JSON) messages. Its
main goals are to enable code generation from schemas as well as
portable validation with standardized error indicators. To this end, JTD
is intentionally limited to be no more expressive than the type systems
of mainstream programming languages. This intentional limitation, as
well as the decision to make JTD schemas be JSON documents, makes
tooling atop of JTD easier to build.[¶](#section-abstract-1){.pilcrow}

This document does not have IETF consensus and is presented here to
facilitate experimentation with the concept of
JTD.[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for examination, experimental implementation, and
evaluation.[¶](#section-boilerplate.1-1){.pilcrow}

This document defines an Experimental Protocol for the Internet
community. This is a contribution to the RFC Series, independently of
any other RFC stream. The RFC Editor has chosen to publish this document
at its discretion and makes no statement about its value for
implementation or deployment. Documents approved for publication by the
RFC Editor are not candidates for any level of Internet Standard; see
Section 2 of RFC 7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8927>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.1.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.1.2.2}
        [1.2](#section-1.2){.xref}.  [Scope of
        Experiment](#name-scope-of-experiment){.xref}[¶](#section-toc.1-1.1.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Syntax](#name-syntax){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Root vs. Non-root
        Schemas](#name-root-vs-non-root-schemas){.xref}[¶](#section-toc.1-1.2.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [Forms](#name-forms){.xref}[¶](#section-toc.1-1.2.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.2.2.2.2.1}
            [2.2.1](#section-2.2.1){.xref}.  [Empty](#name-empty){.xref}[¶](#section-toc.1-1.2.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.2.2.2.2.2}
            [2.2.2](#section-2.2.2){.xref}.  [Ref](#name-ref){.xref}[¶](#section-toc.1-1.2.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.2.2.2.2.3}
            [2.2.3](#section-2.2.3){.xref}.  [Type](#name-type){.xref}[¶](#section-toc.1-1.2.2.2.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.2.2.2.2.4}
            [2.2.4](#section-2.2.4){.xref}.  [Enum](#name-enum){.xref}[¶](#section-toc.1-1.2.2.2.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.2.2.2.2.5}
            [2.2.5](#section-2.2.5){.xref}.  [Elements](#name-elements){.xref}[¶](#section-toc.1-1.2.2.2.2.5.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.2.2.2.2.6}
            [2.2.6](#section-2.2.6){.xref}.  [Properties](#name-properties){.xref}[¶](#section-toc.1-1.2.2.2.2.6.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.2.2.2.2.7}
            [2.2.7](#section-2.2.7){.xref}.  [Values](#name-values){.xref}[¶](#section-toc.1-1.2.2.2.2.7.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.2.2.2.2.8}
            [2.2.8](#section-2.2.8){.xref}.  [Discriminator](#name-discriminator){.xref}[¶](#section-toc.1-1.2.2.2.2.8.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.2.2.3}
        [2.3](#section-2.3){.xref}.  [Extending JTD\'s
        Syntax](#name-extending-jtds-syntax){.xref}[¶](#section-toc.1-1.2.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Semantics](#name-semantics){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Allowing Additional
        Properties](#name-allowing-additional-propert){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Errors](#name-errors){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Forms](#name-forms-2){.xref}[¶](#section-toc.1-1.3.2.3.1){.pilcrow}

        -   ::: {#section-toc.1-1.3.2.3.2.1}
            [3.3.1](#section-3.3.1){.xref}.  [Empty](#name-empty-2){.xref}[¶](#section-toc.1-1.3.2.3.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.2}
            [3.3.2](#section-3.3.2){.xref}.  [Ref](#name-ref-2){.xref}[¶](#section-toc.1-1.3.2.3.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.3}
            [3.3.3](#section-3.3.3){.xref}.  [Type](#name-type-2){.xref}[¶](#section-toc.1-1.3.2.3.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.4}
            [3.3.4](#section-3.3.4){.xref}.  [Enum](#name-enum-2){.xref}[¶](#section-toc.1-1.3.2.3.2.4.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.5}
            [3.3.5](#section-3.3.5){.xref}.  [Elements](#name-elements-2){.xref}[¶](#section-toc.1-1.3.2.3.2.5.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.6}
            [3.3.6](#section-3.3.6){.xref}.  [Properties](#name-properties-2){.xref}[¶](#section-toc.1-1.3.2.3.2.6.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.7}
            [3.3.7](#section-3.3.7){.xref}.  [Values](#name-values-2){.xref}[¶](#section-toc.1-1.3.2.3.2.7.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.3.2.3.2.8}
            [3.3.8](#section-3.3.8){.xref}.  [Discriminator](#name-discriminator-2){.xref}[¶](#section-toc.1-1.3.2.3.2.8.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [References](#name-references){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [Appendix A](#section-appendix.a){.xref}.  [Rationale for Omitted
    Features](#name-rationale-for-omitted-featu){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [A.1](#section-a.1){.xref}.  [Support for 64-Bit
        Numbers](#name-support-for-64-bit-numbers){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [A.2](#section-a.2){.xref}.  [Support for Non-root
        Definitions](#name-support-for-non-root-defini){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [Appendix B](#section-appendix.b){.xref}.  [Comparison with
    CDDL](#name-comparison-with-cddl){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [Appendix
    C](#section-appendix.c){.xref}.  [Example](#name-example){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [](#section-appendix.d){.xref}[Acknowledgments](#name-acknowledgments){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [](#section-appendix.e){.xref}[Author\'s
    Address](#name-authors-address){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

This document describes a schema language for JSON
\[[RFC8259](#RFC8259){.xref}\] called JSON Type Definition
(JTD).[¶](#section-1-1){.pilcrow}

There exist many options for describing JSON data. JTD\'s niche is to
focus on enabling code generation from schemas; to this end, JTD\'s
expressiveness is intentionally limited to be no more powerful than what
can be expressed in the type systems of mainstream programming
languages.[¶](#section-1-2){.pilcrow}

The goals of JTD are to:[¶](#section-1-3){.pilcrow}

-   [Provide an unambiguous description of the overall structure of a
    JSON document.[¶](#section-1-4.1){.pilcrow}]{#section-1-4.1}
-   [Be able to describe common JSON data types and structures (that is,
    the data types and structures necessary to support most JSON
    documents and that are widely understood in an interoperable way by
    JSON implementations).[¶](#section-1-4.2){.pilcrow}]{#section-1-4.2}
-   [Provide a single format that is readable and editable by both
    humans and machines and that can be embedded within other JSON
    documents. This makes JTD a convenient format for tooling to accept
    as input or produce as
    output.[¶](#section-1-4.3){.pilcrow}]{#section-1-4.3}
-   [Enable code generation from JTD schemas. JTD schemas are meant to
    be easy to convert into data structures idiomatic to mainstream
    programming languages.[¶](#section-1-4.4){.pilcrow}]{#section-1-4.4}
-   [Provide a standardized format for error indicators when data does
    not conform with a
    schema.[¶](#section-1-4.5){.pilcrow}]{#section-1-4.5}

JTD is intentionally designed as a rather minimal schema language. Thus,
although JTD can describe some categories of JSON, it is not able to
describe its own structure; this document uses Concise Data Definition
Language (CDDL) \[[RFC8610](#RFC8610){.xref}\] to describe JTD\'s
syntax. By keeping the expressiveness of the schema language minimal,
JTD makes code generation and standardized error indicators easier to
implement.[¶](#section-1-5){.pilcrow}

Examples in this document use constructs from the C++ programming
language. These examples are provided to aid the reader in understanding
the principles of JTD but are not limiting in any
way.[¶](#section-1-6){.pilcrow}

JTD\'s feature set is designed to represent common patterns in
JSON-using applications, while still having a clear correspondence to
programming languages in widespread use. Thus, JTD
supports:[¶](#section-1-7){.pilcrow}

-   [Signed and unsigned 8-, 16-, and 32-bit integers. A tool that
    converts JTD schemas into code can use \"int8_t\", \"uint8_t\",
    \"int16_t\", etc., or their equivalents in the target language, to
    represent these JTD
    types.[¶](#section-1-8.1){.pilcrow}]{#section-1-8.1}
-   [A distinction between \"float32\" and \"float64\". Code generators
    can use \"float\" and \"double\", or their equivalents, for these
    JTD types.[¶](#section-1-8.2){.pilcrow}]{#section-1-8.2}
-   [A \"properties\" form of JSON objects, corresponding to some sort
    of struct or record. The \"properties\" form of JSON objects is akin
    to a C++ \"struct\".[¶](#section-1-8.3){.pilcrow}]{#section-1-8.3}
-   [A \"values\" form of JSON objects, corresponding to some sort of
    dictionary or associative array. The \"values\" form of JSON objects
    is akin to a C++
    \"std::map\".[¶](#section-1-8.4){.pilcrow}]{#section-1-8.4}
-   [A \"discriminator\" form of JSON objects, corresponding to a
    discriminated (or \"tagged\") union. The \"discriminator\" form of
    JSON objects is akin to a C++
    \"std::variant\".[¶](#section-1-8.5){.pilcrow}]{#section-1-8.5}

The principle of common patterns in JSON is why JTD does not support
64-bit integers, as these are usually transmitted over JSON in
non-interoperable (i.e., ignoring the recommendations in [Section
2.2](https://www.rfc-editor.org/rfc/rfc7493#section-2.2){.relref} of
\[[RFC7493](#RFC7493){.xref}\]) or mutually inconsistent ways. [Appendix
A.1](#other-considerations-int64){.xref} further elaborates on why JTD
does not support 64-bit integers.[¶](#section-1-9){.pilcrow}

The principle of clear correspondence to common programming languages is
why JTD does not support, for example, a data type for integers up to
2\*\*53-1.[¶](#section-1-10){.pilcrow}

It is expected that for many use cases, a schema language of JTD\'s
expressiveness is sufficient. Where a more expressive language is
required, alternatives exist in CDDL and
others.[¶](#section-1-11){.pilcrow}

This document does not have IETF consensus and is presented here to
facilitate experimentation with the concept of JTD. The purpose of the
experiment is to gain experience with JTD and to possibly revise this
work accordingly. If JTD is determined to be a valuable and popular
approach, it may be taken to the IETF for further discussion and
revision.[¶](#section-1-12){.pilcrow}

This document has the following structure. [Section 2](#syntax){.xref}
defines the syntax of JTD. [Section 3](#semantics){.xref} describes the
semantics of JTD; this includes determining whether some data satisfies
a schema and what error indicators should be produced when the data is
unsatisfactory. [Appendix A](#other-considerations){.xref} discusses why
certain features are omitted from JTD. [Appendix
B](#comparison-with-cddl){.xref} presents various JTD schemas and their
CDDL equivalents.[¶](#section-1-13){.pilcrow}

::: {#terminology}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-1){.pilcrow}

The term \"JSON Pointer\", when it appears in this document, is to be
understood as it is defined in
\[[RFC6901](#RFC6901){.xref}\].[¶](#section-1.1-2){.pilcrow}

The terms \"object\", \"member\", \"array\", \"number\", \"name\", and
\"string\" in this document are to be interpreted as described in
\[[RFC8259](#RFC8259){.xref}\].[¶](#section-1.1-3){.pilcrow}

The term \"instance\", when it appears in this document, refers to a
JSON value being validated against a JTD schema. This value can be an
entire JSON document, or it can be a value embedded within a JSON
document.[¶](#section-1.1-4){.pilcrow}
:::
:::

::: {#scope-of-experiment}
::: {#section-1.2 .section}
### [1.2.](#section-1.2){.section-number .selfRef} [Scope of Experiment](#name-scope-of-experiment){.section-name .selfRef} {#name-scope-of-experiment}

JTD is an experiment. Participation in this experiment consists of using
JTD to validate or document interchanged JSON messages or building
tooling atop of JTD. Feedback on the results of this experiment may be
emailed to the author. Participants in this experiment are anticipated
to mostly be nodes that provide or consume JSON-based
APIs.[¶](#section-1.2-1){.pilcrow}

Nodes know if they are participating in the experiment if they are
validating JSON messages against a JTD schema or if they are relying on
another node to do so. Nodes are also participating in the experiment if
they are running code generated from a JTD
schema.[¶](#section-1.2-2){.pilcrow}

The risk of this experiment \"escaping\" takes the form of a
JTD-supporting node expecting another node, which lacks such support, to
validate messages against some JTD schema. In such a case, the outcome
will likely be that the nodes fail to interchange information
correctly.[¶](#section-1.2-3){.pilcrow}

This experiment will be deemed successful when JTD has been implemented
by multiple independent parties and these parties successfully use JTD
to facilitate information interchange within their internal systems or
between systems operated by independent
parties.[¶](#section-1.2-4){.pilcrow}

If this experiment is deemed successful, and JTD is determined to be a
valuable and popular approach, it may be taken to the IETF for further
discussion and revision. One possible outcome of this discussion and
revision could be that a working group produces a Standards Track
specification of JTD.[¶](#section-1.2-5){.pilcrow}

Some implementations of JTD, as well as code generators and other
tooling related to JTD, are available at
\<<https://github.com/jsontypedef>\>.[¶](#section-1.2-6){.pilcrow}
:::
:::
:::
:::

::: {#syntax}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Syntax](#name-syntax){.section-name .selfRef} {#name-syntax}

This section describes when a JSON document is a correct JTD schema.
Because Concise Data Definition Language (CDDL) is well suited to the
task of defining complex JSON formats, such as JTD schemas, this section
uses CDDL to describe the format of JTD
schemas.[¶](#section-2-1){.pilcrow}

JTD schemas may recursively contain other schemas. In this document, a
\"root schema\" is one that is not contained within another schema,
i.e., it is \"top level\".[¶](#section-2-2){.pilcrow}

A JTD schema is a JSON object taking on an appropriate form. JTD schemas
may contain \"additional data\", discussed in [Section
2.3](#extending-JTD-syntax){.xref}. Root JTD schemas may optionally
contain definitions (a mapping from names to
schemas).[¶](#section-2-3){.pilcrow}

A correct root JTD schema [MUST]{.bcp14} match the \"root-schema\" CDDL
rule described in this section. A correct non-root JTD schema
[MUST]{.bcp14} match the \"schema\" CDDL rule described in this
section.[¶](#section-2-4){.pilcrow}

[]{#name-cddl-definition-of-a-schema}

::: {#cddl-schema}
::: {#section-2-5.1}
``` {.sourcecode .lang-cddl}
; root-schema is identical to schema, but additionally allows for
; definitions.
;
; definitions are prohibited from appearing on non-root schemas.
root-schema = {
  ? definitions: { * tstr => { schema}},
  schema,
}
; schema is the main CDDL rule defining a JTD schema.
;
; All JTD schemas are JSON objects taking on one of eight forms
; listed here.
schema = (
  ref //
  type //
  enum //
  elements //
  properties //
  values //
  discriminator //
  empty //
)
; shared is a CDDL rule containing properties that all eight schema
; forms share.
shared = (
  ? metadata: { * tstr => any },
  ? nullable: bool,
)
; empty describes the "empty" schema form.
empty = shared
; ref describes the "ref" schema form.
;
; There are additional constraints on this form that cannot be
; expressed in CDDL. Section 2.2.2 describes these additional
; constraints in detail.
ref = ( ref: tstr, shared )
; type describes the "type" schema form.
type = (
  type: "boolean"
    / "float32"
    / "float64"
    / "int8"
    / "uint8"
    / "int16"
    / "uint16"
    / "int32"
    / "uint32"
    / "string"
    / "timestamp",
  shared,
)
; enum describes the "enum" schema form.
;
; There are additional constraints on this form that cannot be
; expressed in CDDL. Section 2.2.4 describes these additional
; constraints in detail.
enum = ( enum: [+ tstr], shared )
; elements describes the "elements" schema form.
elements = ( elements: { schema }, shared )
; properties describes the "properties" schema form.
;
; This CDDL rule is defined so that a schema of the "properties" form
; may omit a member named "properties" or a member named
; "optionalProperties", but not both.
;
; There are additional constraints on this form that cannot be
; expressed in CDDL. Section 2.2.6 describes these additional
; constraints in detail.
properties = (with-properties // with-optional-properties)
with-properties = (
  properties: { * tstr => { schema }},
  ? optionalProperties: { * tstr => { schema }},
  ? additionalProperties: bool,
  shared,
)
with-optional-properties = (
  ? properties: { * tstr => { schema }},
  optionalProperties: { * tstr => { schema }},
  ? additionalProperties: bool,
  shared,
)
; values describes the "values" schema form.
values = ( values: { schema }, shared )
; discriminator describes the "discriminator" schema form.
;
; There are additional constraints on this form that cannot be
; expressed in CDDL. Section 2.2.8 describes these additional
; constraints in detail.
discriminator = (
  discriminator: tstr,
  ; Note well: this rule is defined in terms of the "properties"
  ; CDDL rule, not the "schema" CDDL rule.
  mapping: { * tstr => { properties } }
  shared,
)
```
:::

[Figure 1](#figure-1){.selfRef}: [CDDL Definition of a
Schema](#name-cddl-definition-of-a-schema){.selfRef}
:::

The remainder of this section will describe constraints on JTD schemas
that cannot be expressed in CDDL. It will also provide examples of valid
and invalid JTD schemas.[¶](#section-2-6){.pilcrow}

::: {#root-vs-non-root-schemas}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Root vs. Non-root Schemas](#name-root-vs-non-root-schemas){.section-name .selfRef} {#name-root-vs-non-root-schemas}

The \"root-schema\" rule in [Figure 1](#cddl-schema){.xref} permits a
member named \"definitions\", but the \"schema\" rule does not permit
for such a member. This means that only root (i.e., \"top-level\") JTD
schemas can have a \"definitions\" object, and subschemas may
not.[¶](#section-2.1-1){.pilcrow}

Thus,[¶](#section-2.1-2){.pilcrow}

::: {#section-2.1-3}
``` {.sourcecode .lang-json}
   { "definitions": {} }
```

[¶](#section-2.1-3){.pilcrow}
:::

is a correct JTD schema, but[¶](#section-2.1-4){.pilcrow}

::: {#section-2.1-5}
``` {.sourcecode .lang-json}
   {
     "definitions": {
       "foo": {
         "definitions": {}
       }
     }
   }
```

[¶](#section-2.1-5){.pilcrow}
:::

is not, because subschemas (such as the object at \"/definitions/foo\")
must not have a member named
\"definitions\".[¶](#section-2.1-6){.pilcrow}
:::
:::

::: {#forms}
::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [Forms](#name-forms){.section-name .selfRef} {#name-forms}

JTD schemas (i.e., JSON objects satisfying the \"schema\" CDDL rule in
[Figure 1](#cddl-schema){.xref}) must take on one of eight forms. These
forms are defined so as to be mutually exclusive; a schema cannot
satisfy multiple forms at once.[¶](#section-2.2-1){.pilcrow}

::: {#syntax-form-empty}
::: {#section-2.2.1 .section}
#### [2.2.1.](#section-2.2.1){.section-number .selfRef} [Empty](#name-empty){.section-name .selfRef} {#name-empty}

The \"empty\" form is defined by the \"empty\" CDDL rule in [Figure
1](#cddl-schema){.xref}. The semantics of the \"empty\" form are
described in [Section
3.3.1](#semantics-form-empty){.xref}.[¶](#section-2.2.1-1){.pilcrow}

Despite the name \"empty\", schemas of the \"empty\" form are not
necessarily empty JSON objects. Like schemas of any of the eight forms,
schemas of the \"empty\" form may contain members named \"nullable\"
(whose value must be \"true\" or \"false\") or \"metadata\" (whose value
must be an object) or both.[¶](#section-2.2.1-2){.pilcrow}

Thus,[¶](#section-2.2.1-3){.pilcrow}

::: {#section-2.2.1-4}
``` {.sourcecode .lang-json}
   {}
```

[¶](#section-2.2.1-4){.pilcrow}
:::

and[¶](#section-2.2.1-5){.pilcrow}

::: {#section-2.2.1-6}
``` {.sourcecode .lang-json}
   { "nullable": true }
```

[¶](#section-2.2.1-6){.pilcrow}
:::

and[¶](#section-2.2.1-7){.pilcrow}

::: {#section-2.2.1-8}
``` {.sourcecode .lang-json}
   { "nullable": true, "metadata": { "foo": "bar" }}
```

[¶](#section-2.2.1-8){.pilcrow}
:::

are correct JTD schemas of the \"empty\" form,
but[¶](#section-2.2.1-9){.pilcrow}

::: {#section-2.2.1-10}
``` {.sourcecode .lang-json}
   { "nullable": "foo" }
```

[¶](#section-2.2.1-10){.pilcrow}
:::

is not, because the value of the member named \"nullable\" must be
\"true\" or \"false\".[¶](#section-2.2.1-11){.pilcrow}
:::
:::

::: {#syntax-form-ref}
::: {#section-2.2.2 .section}
#### [2.2.2.](#section-2.2.2){.section-number .selfRef} [Ref](#name-ref){.section-name .selfRef} {#name-ref}

The \"ref\" form is defined by the \"ref\" CDDL rule in [Figure
1](#cddl-schema){.xref}. The semantics of the \"ref\" form are described
in [Section
3.3.2](#semantics-form-ref){.xref}.[¶](#section-2.2.2-1){.pilcrow}

For a schema of the \"ref\" form to be correct, the value of the member
named \"ref\" must refer to one of the definitions found at the root
level of the schema it appears in. More formally, for a schema *S* of
the \"ref\" form:[¶](#section-2.2.2-2){.pilcrow}

-   [Let *B* be the root schema containing the schema or the schema
    itself if it is a root
    schema.[¶](#section-2.2.2-3.1){.pilcrow}]{#section-2.2.2-3.1}
-   [Let *R* be the value of the member of *S* with the name
    \"ref\".[¶](#section-2.2.2-3.2){.pilcrow}]{#section-2.2.2-3.2}

If the schema is correct, then *B* [MUST]{.bcp14} have a member *D* with
the name \"definitions\", and *D* [MUST]{.bcp14} contain a member whose
name equals *R*.[¶](#section-2.2.2-4){.pilcrow}

Thus,[¶](#section-2.2.2-5){.pilcrow}

::: {#section-2.2.2-6}
``` {.sourcecode .lang-json}
   {
     "definitions": {
       "coordinates": {
         "properties": {
           "lat": { "type": "float32" },
           "lng": { "type": "float32" }
         }
       }
     },
     "properties": {
       "user_location": { "ref": "coordinates" },
       "server_location": { "ref": "coordinates" }
     }
   }
```

[¶](#section-2.2.2-6){.pilcrow}
:::

is a correct JTD schema and demonstrates the point of the \"ref\" form:
to avoid redefining the same thing twice.
However,[¶](#section-2.2.2-7){.pilcrow}

::: {#section-2.2.2-8}
``` {.sourcecode .lang-json}
   { "ref": "foo" }
```

[¶](#section-2.2.2-8){.pilcrow}
:::

is not a correct JTD schema, as there are no top-level \"definitions\",
and so the \"ref\" form cannot be correct.
Similarly,[¶](#section-2.2.2-9){.pilcrow}

::: {#section-2.2.2-10}
``` {.sourcecode .lang-json}
   { "definitions": { "foo": {}}, "ref": "bar" }
```

[¶](#section-2.2.2-10){.pilcrow}
:::

is not a correct JTD schema, as there is no member named \"bar\" in the
top-level \"definitions\".[¶](#section-2.2.2-11){.pilcrow}
:::
:::

::: {#syntax-form-type}
::: {#section-2.2.3 .section}
#### [2.2.3.](#section-2.2.3){.section-number .selfRef} [Type](#name-type){.section-name .selfRef} {#name-type}

The \"type\" form is defined by the \"type\" CDDL rule in [Figure
1](#cddl-schema){.xref}. The semantics of the \"type\" form are
described in [Section
3.3.3](#semantics-form-type){.xref}.[¶](#section-2.2.3-1){.pilcrow}

As an example of a correct JTD schema of the \"type\"
form,[¶](#section-2.2.3-2){.pilcrow}

::: {#section-2.2.3-3}
``` {.sourcecode .lang-json}
   { "type": "uint8" }
```

[¶](#section-2.2.3-3){.pilcrow}
:::

is a correct JTD schema, whereas[¶](#section-2.2.3-4){.pilcrow}

::: {#section-2.2.3-5}
``` {.sourcecode .lang-json}
   { "type": true }
```

[¶](#section-2.2.3-5){.pilcrow}
:::

and[¶](#section-2.2.3-6){.pilcrow}

::: {#section-2.2.3-7}
``` {.sourcecode .lang-json}
   { "type": "foo" }
```

[¶](#section-2.2.3-7){.pilcrow}
:::

are not correct schemas, as neither \"true\" nor the JSON string \"foo\"
are in the list of permitted values of the \"type\" member described in
the \"type\" CDDL rule in [Figure
1](#cddl-schema){.xref}.[¶](#section-2.2.3-8){.pilcrow}
:::
:::

::: {#syntax-form-enum}
::: {#section-2.2.4 .section}
#### [2.2.4.](#section-2.2.4){.section-number .selfRef} [Enum](#name-enum){.section-name .selfRef} {#name-enum}

The \"enum\" form is defined by the \"enum\" CDDL rule in [Figure
1](#cddl-schema){.xref}. The semantics of the \"enum\" form are
described in [Section
3.3.4](#semantics-form-enum){.xref}.[¶](#section-2.2.4-1){.pilcrow}

For a schema of the \"enum\" form to be correct, the value of the member
named \"enum\" must be a nonempty array of strings, and that array must
not contain duplicate values. More formally, for a schema *S* of the
\"enum\" form:[¶](#section-2.2.4-2){.pilcrow}

-   [Let *E* be the value of the member of *S* with name
    \"enum\".[¶](#section-2.2.4-3.1){.pilcrow}]{#section-2.2.4-3.1}

If the schema is correct, then there [MUST NOT]{.bcp14} exist any pair
of elements of *E* that encode equal string values, where string
equality is defined as in [Section
8.3](https://www.rfc-editor.org/rfc/rfc8259#section-8.3){.relref} of
\[[RFC8259](#RFC8259){.xref}\].[¶](#section-2.2.4-4){.pilcrow}

Thus,[¶](#section-2.2.4-5){.pilcrow}

::: {#section-2.2.4-6}
``` {.sourcecode .lang-json}
   { "enum": [] }
```

[¶](#section-2.2.4-6){.pilcrow}
:::

is not a correct JTD schema, as the value of the member named \"enum\"
must be nonempty, and[¶](#section-2.2.4-7){.pilcrow}

::: {#section-2.2.4-8}
``` {.sourcecode .lang-json}
   { "enum": ["a\\b", "a\u005Cb"] }
```

[¶](#section-2.2.4-8){.pilcrow}
:::

is not a correct JTD schema, as[¶](#section-2.2.4-9){.pilcrow}

::: {#section-2.2.4-10}
``` {.sourcecode .lang-json}
   "a\\b"
```

[¶](#section-2.2.4-10){.pilcrow}
:::

and[¶](#section-2.2.4-11){.pilcrow}

::: {#section-2.2.4-12}
``` {.sourcecode .lang-json}
   "a\u005Cb"
```

[¶](#section-2.2.4-12){.pilcrow}
:::

encode strings that are equal by the definition of string equality given
in [Section
8.3](https://www.rfc-editor.org/rfc/rfc8259#section-8.3){.relref} of
\[[RFC8259](#RFC8259){.xref}\]. By
contrast,[¶](#section-2.2.4-13){.pilcrow}

::: {#section-2.2.4-14}
``` {.sourcecode .lang-json}
   { "enum": ["PENDING", "IN_PROGRESS", "DONE" ]}
```

[¶](#section-2.2.4-14){.pilcrow}
:::

is an example of a correct JTD schema of the \"enum\"
form.[¶](#section-2.2.4-15){.pilcrow}
:::
:::

::: {#syntax-form-elements}
::: {#section-2.2.5 .section}
#### [2.2.5.](#section-2.2.5){.section-number .selfRef} [Elements](#name-elements){.section-name .selfRef} {#name-elements}

The \"elements\" form is defined by the \"elements\" CDDL rule in
[Figure 1](#cddl-schema){.xref}. The semantics of the \"elements\" form
are described in [Section
3.3.5](#semantics-form-elements){.xref}.[¶](#section-2.2.5-1){.pilcrow}

As an example of a correct JTD schema of the \"elements\"
form,[¶](#section-2.2.5-2){.pilcrow}

::: {#section-2.2.5-3}
``` {.sourcecode .lang-json}
   { "elements": { "type": "uint8" }}
```

[¶](#section-2.2.5-3){.pilcrow}
:::

is a correct JTD schema, whereas[¶](#section-2.2.5-4){.pilcrow}

::: {#section-2.2.5-5}
``` {.sourcecode .lang-json}
   { "elements": true }
```

[¶](#section-2.2.5-5){.pilcrow}
:::

and[¶](#section-2.2.5-6){.pilcrow}

::: {#section-2.2.5-7}
``` {.sourcecode .lang-json}
   { "elements": { "type": "foo" } }
```

[¶](#section-2.2.5-7){.pilcrow}
:::

are not correct schemas, as neither[¶](#section-2.2.5-8){.pilcrow}

::: {#section-2.2.5-9}
``` {.sourcecode .lang-json}
   true
```

[¶](#section-2.2.5-9){.pilcrow}
:::

nor[¶](#section-2.2.5-10){.pilcrow}

::: {#section-2.2.5-11}
``` {.sourcecode .lang-json}
   { "type": "foo" }
```

[¶](#section-2.2.5-11){.pilcrow}
:::

are correct JTD schemas, and the value of the member named \"elements\"
must be a correct JTD schema.[¶](#section-2.2.5-12){.pilcrow}
:::
:::

::: {#syntax-form-properties}
::: {#section-2.2.6 .section}
#### [2.2.6.](#section-2.2.6){.section-number .selfRef} [Properties](#name-properties){.section-name .selfRef} {#name-properties}

The \"properties\" form is defined by the \"properties\" CDDL rule in
[Figure 1](#cddl-schema){.xref}. The semantics of the \"properties\"
form are described in [Section
3.3.6](#semantics-form-props){.xref}.[¶](#section-2.2.6-1){.pilcrow}

For a schema of the \"properties\" form to be correct, properties must
either be required (i.e., in \"properties\") or optional (i.e., in
\"optionalProperties\"), but not both.[¶](#section-2.2.6-2){.pilcrow}

More formally, if a schema has both a member named \"properties\" (with
value *P*) and another member named \"optionalProperties\" (with value
*O*), then *O* and *P* [MUST NOT]{.bcp14} have any member names in
common; that is, no member of *P* may have a name equal to the name of
any member of *O*, under the definition of string equality given in
[Section
8.3](https://www.rfc-editor.org/rfc/rfc8259#section-8.3){.relref} of
\[[RFC8259](#RFC8259){.xref}\].[¶](#section-2.2.6-3){.pilcrow}

Thus,[¶](#section-2.2.6-4){.pilcrow}

::: {#section-2.2.6-5}
``` {.sourcecode .lang-json}
   {
     "properties": { "confusing": {} },
     "optionalProperties": { "confusing": {} }
   }
```

[¶](#section-2.2.6-5){.pilcrow}
:::

is not a correct JTD schema, as \"confusing\" appears in both
\"properties\" and \"optionalProperties\". By
contrast,[¶](#section-2.2.6-6){.pilcrow}

::: {#section-2.2.6-7}
``` {.sourcecode .lang-json}
   {
     "properties": {
       "users": {
         "elements": {
           "properties": {
             "id": { "type": "string" },
             "name": { "type": "string" },
             "create_time": { "type": "timestamp" }
           },
           "optionalProperties": {
             "delete_time": { "type": "timestamp" }
           }
         }
       },
       "next_page_token": { "type": "string" }
     }
   }
```

[¶](#section-2.2.6-7){.pilcrow}
:::

is a correct JTD schema of the \"properties\" form, describing a
paginated list of users and demonstrating the recursive nature of the
syntax of JTD schemas.[¶](#section-2.2.6-8){.pilcrow}
:::
:::

::: {#syntax-form-values}
::: {#section-2.2.7 .section}
#### [2.2.7.](#section-2.2.7){.section-number .selfRef} [Values](#name-values){.section-name .selfRef} {#name-values}

The \"values\" form is defined by the \"values\" CDDL rule in [Figure
1](#cddl-schema){.xref}. The semantics of the \"values\" form are
described in [Section
3.3.7](#semantics-form-values){.xref}.[¶](#section-2.2.7-1){.pilcrow}

As an example of a correct JTD schema of the \"values\"
form,[¶](#section-2.2.7-2){.pilcrow}

::: {#section-2.2.7-3}
``` {.sourcecode .lang-json}
   { "values": { "type": "uint8" }}
```

[¶](#section-2.2.7-3){.pilcrow}
:::

is a correct JTD schema, whereas[¶](#section-2.2.7-4){.pilcrow}

::: {#section-2.2.7-5}
``` {.sourcecode .lang-json}
   { "values": true }
```

[¶](#section-2.2.7-5){.pilcrow}
:::

and[¶](#section-2.2.7-6){.pilcrow}

::: {#section-2.2.7-7}
``` {.sourcecode .lang-json}
   { "values": { "type": "foo" } }
```

[¶](#section-2.2.7-7){.pilcrow}
:::

are not correct schemas, as neither[¶](#section-2.2.7-8){.pilcrow}

::: {#section-2.2.7-9}
``` {.sourcecode .lang-json}
   true
```

[¶](#section-2.2.7-9){.pilcrow}
:::

nor[¶](#section-2.2.7-10){.pilcrow}

::: {#section-2.2.7-11}
``` {.sourcecode .lang-json}
   { "type": "foo" }
```

[¶](#section-2.2.7-11){.pilcrow}
:::

are correct JTD schemas, and the value of the member named \"values\"
must be a correct JTD schema.[¶](#section-2.2.7-12){.pilcrow}
:::
:::

::: {#syntax-form-discriminator}
::: {#section-2.2.8 .section}
#### [2.2.8.](#section-2.2.8){.section-number .selfRef} [Discriminator](#name-discriminator){.section-name .selfRef} {#name-discriminator}

The \"discriminator\" form is defined by the \"discriminator\" CDDL rule
in [Figure 1](#cddl-schema){.xref}. The semantics of the
\"discriminator\" form are described in [Section
3.3.8](#semantics-form-discriminator){.xref}. Understanding the
semantics of the \"discriminator\" form will likely aid the reader in
understanding why this section provides constraints on the
\"discriminator\" form beyond those in [Figure
1](#cddl-schema){.xref}.[¶](#section-2.2.8-1){.pilcrow}

To prevent ambiguous or unsatisfiable constraints on the
\"discriminator\" property of a tagged union, an additional constraint
on schemas of the \"discriminator\" form exists. For schemas of the
\"discriminator\" form:[¶](#section-2.2.8-2){.pilcrow}

-   [Let *D* be the member of the schema with the name
    \"discriminator\".[¶](#section-2.2.8-3.1){.pilcrow}]{#section-2.2.8-3.1}
-   [Let *M* be the member of the schema with the name
    \"mapping\".[¶](#section-2.2.8-3.2){.pilcrow}]{#section-2.2.8-3.2}

If the schema is correct, then all member values *S* of *M* will be
schemas of the \"properties\" form. For each
*S*:[¶](#section-2.2.8-4){.pilcrow}

-   [If *S* has a member *N* whose name equals \"nullable\", *N*\'s
    value [MUST NOT]{.bcp14} be the JSON primitive value
    \"true\".[¶](#section-2.2.8-5.1){.pilcrow}]{#section-2.2.8-5.1}
-   [For each member *P* of *S* whose name equals \"properties\" or
    \"optionalProperties\", *P*\'s value, which must be an object, [MUST
    NOT]{.bcp14} contain any members whose name equals *D*\'s
    value.[¶](#section-2.2.8-5.2){.pilcrow}]{#section-2.2.8-5.2}

Thus,[¶](#section-2.2.8-6){.pilcrow}

::: {#section-2.2.8-7}
``` {.sourcecode .lang-json}
   {
     "discriminator": "event_type",
     "mapping": {
       "can_the_object_be_null_or_not?": {
         "nullable": true,
         "properties": { "foo": { "type": "string" } }}
       }
     }
   }
```

[¶](#section-2.2.8-7){.pilcrow}
:::

is an incorrect schema, as a member of \"mapping\" has a member named
\"nullable\" whose value is \"true\". This would suggest that the
instance may be null. Yet, the top-level schema lacks such a
\"nullable\" set to \"true\", which would suggest that the instance in
fact cannot be null. If this were a correct JTD schema, it would be
unclear which piece of information takes
precedence.[¶](#section-2.2.8-8){.pilcrow}

JTD handles such possible ambiguity by disallowing, at the syntactic
level, the possibility of contradictory specifications of whether an
instance described by a schema of the \"discriminator\" form may be
null. The schemas in a discriminator \"mapping\" cannot have
\"nullable\" set to \"true\"; only the discriminator itself can use
\"nullable\" in this way.[¶](#section-2.2.8-9){.pilcrow}

It also follows that[¶](#section-2.2.8-10){.pilcrow}

::: {#section-2.2.8-11}
``` {.sourcecode .lang-json}
   {
     "discriminator": "event_type",
     "mapping": {
       "is_event_type_a_string_or_a_float32?": {
         "properties": { "event_type": { "type": "float32" }}
       }
     }
   }
```

[¶](#section-2.2.8-11){.pilcrow}
:::

and[¶](#section-2.2.8-12){.pilcrow}

::: {#section-2.2.8-13}
``` {.sourcecode .lang-json}
   {
     "discriminator": "event_type",
     "mapping": {
       "is_event_type_a_string_or_an_optional_float32?": {
         "optionalProperties": { "event_type": { "type": "float32" }}
       }
     }
   }
```

[¶](#section-2.2.8-13){.pilcrow}
:::

are incorrect schemas, as \"event_type\" is both the value of
\"discriminator\" and a member name in one of the \"mapping\" member
\"properties\" or \"optionalProperties\". This is ambiguous, because
ordinarily the \"discriminator\" keyword would indicate that
\"event_type\" is expected to be a string, but another part of the
schema specifies that \"event_type\" is expected to be a
number.[¶](#section-2.2.8-14){.pilcrow}

JTD handles such possible ambiguity by disallowing, at the syntactic
level, the possibility of contradictory specifications of discriminator
\"tags\". Discriminator \"tags\" cannot be redefined in other parts of
the schema.[¶](#section-2.2.8-15){.pilcrow}

By contrast,[¶](#section-2.2.8-16){.pilcrow}

::: {#section-2.2.8-17}
``` {.sourcecode .lang-json}
   {
     "discriminator": "event_type",
     "mapping": {
       "account_deleted": {
         "properties": {
           "account_id": { "type": "string" }
         }
       },
       "account_payment_plan_changed": {
         "properties": {
           "account_id": { "type": "string" },
           "payment_plan": { "enum": ["FREE", "PAID"] }
         },
         "optionalProperties": {
           "upgraded_by": { "type": "string" }
         }
       }
     }
   }
```

[¶](#section-2.2.8-17){.pilcrow}
:::

is a correct schema, describing a pattern of data common in JSON-based
messaging systems. [Section 3.3.8](#semantics-form-discriminator){.xref}
provides examples of what this schema accepts and
rejects.[¶](#section-2.2.8-18){.pilcrow}
:::
:::
:::
:::

::: {#extending-JTD-syntax}
::: {#section-2.3 .section}
### [2.3.](#section-2.3){.section-number .selfRef} [Extending JTD\'s Syntax](#name-extending-jtds-syntax){.section-name .selfRef} {#name-extending-jtds-syntax}

This document does not describe any extension mechanisms for JTD schema
validation, which is described in [Section 3](#semantics){.xref}.
However, schemas are defined to optionally contain a \"metadata\"
keyword, whose value is an arbitrary JSON object. Call the members of
this object \"metadata members\".[¶](#section-2.3-1){.pilcrow}

Users [MAY]{.bcp14} add metadata members to JTD schemas to convey
information that is not pertinent to validation. For example, such
metadata members could provide hints to code generators or trigger some
special behavior for a library that generates user interfaces from
schemas.[¶](#section-2.3-2){.pilcrow}

Users [SHOULD NOT]{.bcp14} expect metadata members to be understood by
other parties. As a result, if consistent validation with other parties
is a requirement, users [MUST NOT]{.bcp14} use metadata members to
affect how schema validation, as described in [Section
3](#semantics){.xref}, works.[¶](#section-2.3-3){.pilcrow}

Users [MAY]{.bcp14} expect metadata members to be understood by other
parties and [MAY]{.bcp14} use metadata members to affect how schema
validation works, if these other parties are somehow known to support
these metadata members. For example, two parties may agree, out of band,
that they will support an extended JTD with a custom metadata member
that affects validation.[¶](#section-2.3-4){.pilcrow}
:::
:::
:::
:::

::: {#semantics}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Semantics](#name-semantics){.section-name .selfRef} {#name-semantics}

This section describes when an instance is valid against a correct JTD
schema and the error indicators to produce when an instance is
invalid.[¶](#section-3-1){.pilcrow}

::: {#allow-additional-properties}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Allowing Additional Properties](#name-allowing-additional-propert){.section-name .selfRef} {#name-allowing-additional-propert}

Users will have different desired behavior with respect to
\"unspecified\" members in an instance. For example, consider the JTD
schema in [Figure
2](#JTD-properties-a){.xref}:[¶](#section-3.1-1){.pilcrow}

[]{#name-an-illustrative-jtd-schema}

::: {#JTD-properties-a}
::: {#section-3.1-2.1}
``` {.sourcecode .lang-json}
{ "properties": { "a": { "type": "string" }}}
```
:::

[Figure 2](#figure-2){.selfRef}: [An Illustrative JTD
Schema](#name-an-illustrative-jtd-schema){.selfRef}
:::

Some users may expect that[¶](#section-3.1-3){.pilcrow}

::: {#section-3.1-4}
``` {.sourcecode .lang-json}
   {"a": "foo", "b": "bar"}
```

[¶](#section-3.1-4){.pilcrow}
:::

satisfies the schema in [Figure 2](#JTD-properties-a){.xref}. Others may
disagree, as \"b\" is not one of the properties described in the schema.
In this document, allowing such \"unspecified\" members, like \"b\" in
this example, happens when evaluation is in \"allow additional
properties\" mode.[¶](#section-3.1-5){.pilcrow}

Evaluation of a schema does not allow additional properties by default,
but this can be overridden by having the schema include a member named
\"additionalProperties\", where that member has a value of
\"true\".[¶](#section-3.1-6){.pilcrow}

More formally, evaluation of a schema *S* is in \"allow additional
properties\" mode if there exists a member of *S* whose name equals
\"additionalProperties\" and whose value is a boolean \"true\".
Otherwise, evaluation of *S* is not in \"allow additional properties\"
mode.[¶](#section-3.1-7){.pilcrow}

See [Section 3.3.6](#semantics-form-props){.xref} for how allowing
unknown properties affects schema evaluation, but briefly, the
schema[¶](#section-3.1-8){.pilcrow}

::: {#section-3.1-9}
``` {.sourcecode .lang-json}
   { "properties": { "a": { "type": "string" }}}
```

[¶](#section-3.1-9){.pilcrow}
:::

rejects[¶](#section-3.1-10){.pilcrow}

::: {#section-3.1-11}
``` {.sourcecode .lang-json}
   { "a": "foo", "b": "bar" }
```

[¶](#section-3.1-11){.pilcrow}
:::

However, the schema[¶](#section-3.1-12){.pilcrow}

::: {#section-3.1-13}
``` {.sourcecode .lang-json}
   {
     "additionalProperties": true,
     "properties": { "a": { "type": "string" }}
   }
```

[¶](#section-3.1-13){.pilcrow}
:::

accepts[¶](#section-3.1-14){.pilcrow}

::: {#section-3.1-15}
``` {.sourcecode .lang-json}
   { "a": "foo", "b": "bar" }
```

[¶](#section-3.1-15){.pilcrow}
:::

Note that \"additionalProperties\" does not get \"inherited\" by
subschemas. For example, the JTD schema[¶](#section-3.1-16){.pilcrow}

::: {#section-3.1-17}
``` {.sourcecode .lang-json}
   {
     "additionalProperties": true,
     "properties": {
       "a": {
         "properties": {
           "b": { "type": "string" }
         }
       }
     }
   }
```

[¶](#section-3.1-17){.pilcrow}
:::

accepts[¶](#section-3.1-18){.pilcrow}

::: {#section-3.1-19}
``` {.sourcecode .lang-json}
   { "a": { "b": "c" }, "foo": "bar" }
```

[¶](#section-3.1-19){.pilcrow}
:::

but rejects[¶](#section-3.1-20){.pilcrow}

::: {#section-3.1-21}
``` {.sourcecode .lang-json}
   { "a": { "b": "c", "foo": "bar" }}
```

[¶](#section-3.1-21){.pilcrow}
:::

because the \"additionalProperties\" at the root level does not affect
the behavior of subschemas.[¶](#section-3.1-22){.pilcrow}

Note from [Figure 1](#cddl-schema){.xref} that only schemas of the
\"properties\" form may have a member named
\"additionalProperties\".[¶](#section-3.1-23){.pilcrow}
:::
:::

::: {#errors}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Errors](#name-errors){.section-name .selfRef} {#name-errors}

To facilitate consistent validation error handling, this document
specifies a standard error indicator format. Implementations
[SHOULD]{.bcp14} support producing error indicators in this standard
form.[¶](#section-3.2-1){.pilcrow}

The standard error indicator format is a JSON array. The order of the
elements of this array is not specified. The elements of this array are
JSON objects with:[¶](#section-3.2-2){.pilcrow}

-   [A member with the name \"instancePath\", whose value is a JSON
    string encoding a JSON Pointer. This JSON Pointer will point to the
    part of the instance that was
    rejected.[¶](#section-3.2-3.1){.pilcrow}]{#section-3.2-3.1}
-   [A member with the name \"schemaPath\", whose value is a JSON string
    encoding a JSON Pointer. This JSON Pointer will point to the part of
    the schema that rejected the
    instance.[¶](#section-3.2-3.2){.pilcrow}]{#section-3.2-3.2}

The values for \"instancePath\" and \"schemaPath\" depend on the form of
the schema and are described in detail in [Section
3.3](#semantics-forms){.xref}.[¶](#section-3.2-4){.pilcrow}
:::
:::

::: {#semantics-forms}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Forms](#name-forms-2){.section-name .selfRef} {#name-forms-2}

This section describes, for each of the eight JTD schema forms, the
rules dictating whether an instance is accepted, as well as the error
indicators to produce when an instance is
invalid.[¶](#section-3.3-1){.pilcrow}

The forms a correct schema may take on are formally described in
[Section 2](#syntax){.xref}.[¶](#section-3.3-2){.pilcrow}

::: {#semantics-form-empty}
::: {#section-3.3.1 .section}
#### [3.3.1.](#section-3.3.1){.section-number .selfRef} [Empty](#name-empty-2){.section-name .selfRef} {#name-empty-2}

The \"empty\" form is meant to describe instances whose values are
unknown, unpredictable, or otherwise unconstrained by the schema. The
syntax of the \"empty\" form is described in [Section
2.2.1](#syntax-form-empty){.xref}.[¶](#section-3.3.1-1){.pilcrow}

If a schema is of the \"empty\" form, then it accepts all instances. A
schema of the \"empty\" form will never produce any error
indicators.[¶](#section-3.3.1-2){.pilcrow}
:::
:::

::: {#semantics-form-ref}
::: {#section-3.3.2 .section}
#### [3.3.2.](#section-3.3.2){.section-number .selfRef} [Ref](#name-ref-2){.section-name .selfRef} {#name-ref-2}

The \"ref\" form is for when a schema is defined in terms of something
in the \"definitions\" of the root schema. The \"ref\" form enables
schemas to be less repetitive and also enables describing recursive
structures. The syntax of the \"ref\" form is described in [Section
2.2.2](#syntax-form-ref){.xref}.[¶](#section-3.3.2-1){.pilcrow}

If a schema is of the \"ref\" form, then:[¶](#section-3.3.2-2){.pilcrow}

-   ::: {#section-3.3.2-3.1}
    If the schema has a member named \"nullable\" whose value is the
    boolean \"true\", and the instance is the JSON primitive value
    \"null\", then the schema accepts the
    instance.[¶](#section-3.3.2-3.1.1){.pilcrow}

    Otherwise:[¶](#section-3.3.2-3.1.2){.pilcrow}

    -   [Let *R* be the value of the schema member with the name
        \"ref\".[¶](#section-3.3.2-3.1.3.1){.pilcrow}]{#section-3.3.2-3.1.3.1}
    -   [Let *B* be the root schema containing the schema or the schema
        itself if it is a root
        schema.[¶](#section-3.3.2-3.1.3.2){.pilcrow}]{#section-3.3.2-3.1.3.2}
    -   [Let *D* be the member of *B* with the name \"definitions\". Per
        [Section 2](#syntax){.xref}, we know *D*
        exists.[¶](#section-3.3.2-3.1.3.3){.pilcrow}]{#section-3.3.2-3.1.3.3}
    -   [Let *S* be the value of the member of *D* whose name equals
        *R*. Per [Section 2.2.2](#syntax-form-ref){.xref}, we know *S*
        exists and is a
        schema.[¶](#section-3.3.2-3.1.3.4){.pilcrow}]{#section-3.3.2-3.1.3.4}
    :::

The schema accepts the instance if and only if *S* accepts the instance.
Otherwise, the error indicators to return in this case are the union of
the error indicators from evaluating *S* against the
instance.[¶](#section-3.3.2-4){.pilcrow}

For example, the schema[¶](#section-3.3.2-5){.pilcrow}

::: {#section-3.3.2-6}
``` {.sourcecode .lang-json}
   {
     "definitions": { "a": { "type": "float32" }},
     "ref": "a"
   }
```

[¶](#section-3.3.2-6){.pilcrow}
:::

accepts[¶](#section-3.3.2-7){.pilcrow}

::: {#section-3.3.2-8}
``` {.sourcecode .lang-json}
   123
```

[¶](#section-3.3.2-8){.pilcrow}
:::

but rejects[¶](#section-3.3.2-9){.pilcrow}

::: {#section-3.3.2-10}
``` {.sourcecode .lang-json}
   null
```

[¶](#section-3.3.2-10){.pilcrow}
:::

with the error indicator[¶](#section-3.3.2-11){.pilcrow}

::: {#section-3.3.2-12}
``` {.sourcecode .lang-json}
   [{ "instancePath": "", "schemaPath": "/definitions/a/type" }]
```

[¶](#section-3.3.2-12){.pilcrow}
:::

The schema[¶](#section-3.3.2-13){.pilcrow}

::: {#section-3.3.2-14}
``` {.sourcecode .lang-json}
   {
     "definitions": { "a": { "type": "float32" }},
     "ref": "a",
     "nullable": true
   }
```

[¶](#section-3.3.2-14){.pilcrow}
:::

accepts[¶](#section-3.3.2-15){.pilcrow}

::: {#section-3.3.2-16}
``` {.sourcecode .lang-json}
   null
```

[¶](#section-3.3.2-16){.pilcrow}
:::

because the schema has a \"nullable\" member whose value is
\"true\".[¶](#section-3.3.2-17){.pilcrow}

Note that \"nullable\" being \"false\" has no effect in any of the forms
described in this document. For example, the
schema[¶](#section-3.3.2-18){.pilcrow}

::: {#section-3.3.2-19}
``` {.sourcecode .lang-json}
   {
     "definitions": { "a": { "nullable": false, "type": "float32" }},
     "ref": "a",
     "nullable": true
   }
```

[¶](#section-3.3.2-19){.pilcrow}
:::

accepts[¶](#section-3.3.2-20){.pilcrow}

::: {#section-3.3.2-21}
``` {.sourcecode .lang-json}
   null
```

[¶](#section-3.3.2-21){.pilcrow}
:::

In other words, it is not the case that putting a \"false\" value for
\"nullable\" will ever override a \"nullable\" member in schemas of the
\"ref\" form; it is correct, though ineffectual, to have a value of
\"false\" for the \"nullable\" member in a
schema.[¶](#section-3.3.2-22){.pilcrow}
:::
:::

::: {#semantics-form-type}
::: {#section-3.3.3 .section}
#### [3.3.3.](#section-3.3.3){.section-number .selfRef} [Type](#name-type-2){.section-name .selfRef} {#name-type-2}

The \"type\" form is meant to describe instances whose value is a
boolean, number, string, or timestamp \[[RFC3339](#RFC3339){.xref}\].
The syntax of the \"type\" form is described in [Section
2.2.3](#syntax-form-type){.xref}.[¶](#section-3.3.3-1){.pilcrow}

If a schema is of the \"type\" form,
then:[¶](#section-3.3.3-2){.pilcrow}

-   ::: {#section-3.3.3-3.1}
    If the schema has a member named \"nullable\" whose value is the
    boolean \"true\", and the instance is the JSON primitive value
    \"null\", then the schema accepts the
    instance.[¶](#section-3.3.3-3.1.1){.pilcrow}

    Otherwise:[¶](#section-3.3.3-3.1.2){.pilcrow}

    -   [Let *T* be the value of the member with the name \"type\". The
        following table describes whether the instance is accepted, as a
        function of *T*\'s
        value:[¶](#section-3.3.3-3.1.3.1){.pilcrow}]{#section-3.3.3-3.1.3.1}

    -   [[]{#name-accepted-values-for-type}]{#section-3.3.3-3.1.3.2}

        ::: {#type-values}
          If *\"T\"* equals \...   then the instance is accepted if it is \...
          ------------------------ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
          boolean                  equal to \"true\" or \"false\"
          float32                  a JSON number
          float64                  a JSON number
          int8                     See [Table 2](#int-ranges){.xref}
          uint8                    See [Table 2](#int-ranges){.xref}
          int16                    See [Table 2](#int-ranges){.xref}
          uint16                   See [Table 2](#int-ranges){.xref}
          int32                    See [Table 2](#int-ranges){.xref}
          uint32                   See [Table 2](#int-ranges){.xref}
          string                   a JSON string
          timestamp                a JSON string that follows the standard format described in \[[RFC3339](#RFC3339){.xref}\], as refined by [Section 3.3](https://www.rfc-editor.org/rfc/rfc4287#section-3.3){.relref} of \[[RFC4287](#RFC4287){.xref}\]

          : [Table 1](#table-1){.selfRef}: [Accepted Values for
          Type](#name-accepted-values-for-type){.selfRef}
        :::

        \"float32\" and \"float64\" are distinguished from each other in
        their intent. \"float32\" indicates data intended to be
        processed as an IEEE 754 single-precision float, whereas
        \"float64\" indicates data intended to be processed as an IEEE
        754 double-precision float. Tools that generate code from JTD
        schemas will likely produce different code for \"float32\" than
        for \"float64\".[¶](#section-3.3.3-3.1.3.2.2){.pilcrow}
    :::

If *T* starts with \"int\" or \"uint\", then the instance is accepted if
and only if it is a JSON number encoding a value with zero fractional
part. Depending on the value of *T*, this encoded number must
additionally fall within a particular
range:[¶](#section-3.3.3-4){.pilcrow}

[]{#name-ranges-for-integer-types}

::: {#int-ranges}
  *\"T\"*   Minimum Value (Inclusive)   Maximum Value (Inclusive)
  --------- --------------------------- ---------------------------
  int8      -128                        127
  uint8     0                           255
  int16     -32,768                     32,767
  uint16    0                           65,535
  int32     -2,147,483,648              2,147,483,647
  uint32    0                           4,294,967,295

  : [Table 2](#table-2){.selfRef}: [Ranges for Integer
  Types](#name-ranges-for-integer-types){.selfRef}
:::

Note that[¶](#section-3.3.3-6){.pilcrow}

::: {#section-3.3.3-7}
``` {.sourcecode .lang-json}
   10
```

[¶](#section-3.3.3-7){.pilcrow}
:::

and[¶](#section-3.3.3-8){.pilcrow}

::: {#section-3.3.3-9}
``` {.sourcecode .lang-json}
   10.0
```

[¶](#section-3.3.3-9){.pilcrow}
:::

and[¶](#section-3.3.3-10){.pilcrow}

::: {#section-3.3.3-11}
``` {.sourcecode .lang-json}
   1.0e1
```

[¶](#section-3.3.3-11){.pilcrow}
:::

encode values with zero fractional part,
whereas[¶](#section-3.3.3-12){.pilcrow}

::: {#section-3.3.3-13}
``` {.sourcecode .lang-json}
   10.5
```

[¶](#section-3.3.3-13){.pilcrow}
:::

encodes a number with a non-zero fractional part. Thus, the
schema[¶](#section-3.3.3-14){.pilcrow}

::: {#section-3.3.3-15}
``` {.sourcecode .lang-json}
   {"type": "int8"}
```

[¶](#section-3.3.3-15){.pilcrow}
:::

accepts[¶](#section-3.3.3-16){.pilcrow}

::: {#section-3.3.3-17}
``` {.sourcecode .lang-json}
   10
```

[¶](#section-3.3.3-17){.pilcrow}
:::

and[¶](#section-3.3.3-18){.pilcrow}

::: {#section-3.3.3-19}
``` {.sourcecode .lang-json}
   10.0
```

[¶](#section-3.3.3-19){.pilcrow}
:::

and[¶](#section-3.3.3-20){.pilcrow}

::: {#section-3.3.3-21}
``` {.sourcecode .lang-json}
   1.0e1
```

[¶](#section-3.3.3-21){.pilcrow}
:::

but rejects[¶](#section-3.3.3-22){.pilcrow}

::: {#section-3.3.3-23}
``` {.sourcecode .lang-json}
   10.5
```

[¶](#section-3.3.3-23){.pilcrow}
:::

as well as[¶](#section-3.3.3-24){.pilcrow}

::: {#section-3.3.3-25}
``` {.sourcecode .lang-json}
   false
```

[¶](#section-3.3.3-25){.pilcrow}
:::

because \"false\" is not a number at
all.[¶](#section-3.3.3-26){.pilcrow}

If the instance is not accepted, then the error indicator for this case
shall have an \"instancePath\" pointing to the instance and a
\"schemaPath\" pointing to the schema member with the name
\"type\".[¶](#section-3.3.3-27){.pilcrow}

For example, the schema[¶](#section-3.3.3-28){.pilcrow}

::: {#section-3.3.3-29}
``` {.sourcecode .lang-json}
   {"type": "boolean"}
```

[¶](#section-3.3.3-29){.pilcrow}
:::

accepts[¶](#section-3.3.3-30){.pilcrow}

::: {#section-3.3.3-31}
``` {.sourcecode .lang-json}
   false
```

[¶](#section-3.3.3-31){.pilcrow}
:::

but rejects[¶](#section-3.3.3-32){.pilcrow}

::: {#section-3.3.3-33}
``` {.sourcecode .lang-json}
   127
```

[¶](#section-3.3.3-33){.pilcrow}
:::

The schema[¶](#section-3.3.3-34){.pilcrow}

::: {#section-3.3.3-35}
``` {.sourcecode .lang-json}
   {"type": "float32"}
```

[¶](#section-3.3.3-35){.pilcrow}
:::

accepts[¶](#section-3.3.3-36){.pilcrow}

::: {#section-3.3.3-37}
``` {.sourcecode .lang-json}
   10.5
```

[¶](#section-3.3.3-37){.pilcrow}
:::

and[¶](#section-3.3.3-38){.pilcrow}

::: {#section-3.3.3-39}
``` {.sourcecode .lang-json}
   127
```

[¶](#section-3.3.3-39){.pilcrow}
:::

but rejects[¶](#section-3.3.3-40){.pilcrow}

::: {#section-3.3.3-41}
``` {.sourcecode .lang-json}
   false
```

[¶](#section-3.3.3-41){.pilcrow}
:::

The schema[¶](#section-3.3.3-42){.pilcrow}

::: {#section-3.3.3-43}
``` {.sourcecode .lang-json}
   {"type": "string"}
```

[¶](#section-3.3.3-43){.pilcrow}
:::

accepts[¶](#section-3.3.3-44){.pilcrow}

::: {#section-3.3.3-45}
``` {.sourcecode .lang-json}
   "1985-04-12T23:20:50.52Z"
```

[¶](#section-3.3.3-45){.pilcrow}
:::

and[¶](#section-3.3.3-46){.pilcrow}

::: {#section-3.3.3-47}
``` {.sourcecode .lang-json}
   "foo"
```

[¶](#section-3.3.3-47){.pilcrow}
:::

but rejects[¶](#section-3.3.3-48){.pilcrow}

::: {#section-3.3.3-49}
``` {.sourcecode .lang-json}
   false
```

[¶](#section-3.3.3-49){.pilcrow}
:::

The schema[¶](#section-3.3.3-50){.pilcrow}

::: {#section-3.3.3-51}
``` {.sourcecode .lang-json}
   {"type": "timestamp"}
```

[¶](#section-3.3.3-51){.pilcrow}
:::

accepts[¶](#section-3.3.3-52){.pilcrow}

::: {#section-3.3.3-53}
``` {.sourcecode .lang-json}
   "1985-04-12T23:20:50.52Z"
```

[¶](#section-3.3.3-53){.pilcrow}
:::

but rejects[¶](#section-3.3.3-54){.pilcrow}

::: {#section-3.3.3-55}
``` {.sourcecode .lang-json}
   "foo"
```

[¶](#section-3.3.3-55){.pilcrow}
:::

and[¶](#section-3.3.3-56){.pilcrow}

::: {#section-3.3.3-57}
``` {.sourcecode .lang-json}
   false
```

[¶](#section-3.3.3-57){.pilcrow}
:::

The schema[¶](#section-3.3.3-58){.pilcrow}

::: {#section-3.3.3-59}
``` {.sourcecode .lang-json}
   {"type": "boolean", "nullable": true}
```

[¶](#section-3.3.3-59){.pilcrow}
:::

accepts[¶](#section-3.3.3-60){.pilcrow}

::: {#section-3.3.3-61}
``` {.sourcecode .lang-json}
   null
```

[¶](#section-3.3.3-61){.pilcrow}
:::

and[¶](#section-3.3.3-62){.pilcrow}

::: {#section-3.3.3-63}
``` {.sourcecode .lang-json}
   false
```

[¶](#section-3.3.3-63){.pilcrow}
:::

but rejects[¶](#section-3.3.3-64){.pilcrow}

::: {#section-3.3.3-65}
``` {.sourcecode .lang-json}
   127
```

[¶](#section-3.3.3-65){.pilcrow}
:::

In all of the examples of rejected instances given in this section, the
error indicator to produce is:[¶](#section-3.3.3-66){.pilcrow}

::: {#section-3.3.3-67}
``` {.sourcecode .lang-json}
   [{ "instancePath": "", "schemaPath": "/type" }]
```

[¶](#section-3.3.3-67){.pilcrow}
:::
:::
:::

::: {#semantics-form-enum}
::: {#section-3.3.4 .section}
#### [3.3.4.](#section-3.3.4){.section-number .selfRef} [Enum](#name-enum-2){.section-name .selfRef} {#name-enum-2}

The \"enum\" form is meant to describe instances whose value must be one
of a given set of string values. The syntax of the \"enum\" form is
described in [Section
2.2.4](#syntax-form-enum){.xref}.[¶](#section-3.3.4-1){.pilcrow}

If a schema is of the \"enum\" form,
then:[¶](#section-3.3.4-2){.pilcrow}

-   ::: {#section-3.3.4-3.1}
    If the schema has a member named \"nullable\" whose value is the
    boolean \"true\", and the instance is the JSON primitive value
    \"null\", then the schema accepts the
    instance.[¶](#section-3.3.4-3.1.1){.pilcrow}

    Otherwise:[¶](#section-3.3.4-3.1.2){.pilcrow}

    -   [Let *E* be the value of the schema member with the name
        \"enum\". The instance is accepted if and only if it is equal to
        one of the elements of
        *E*.[¶](#section-3.3.4-3.1.3.1){.pilcrow}]{#section-3.3.4-3.1.3.1}
    :::

If the instance is not accepted, then the error indicator for this case
shall have an \"instancePath\" pointing to the instance and a
\"schemaPath\" pointing to the schema member with the name
\"enum\".[¶](#section-3.3.4-4){.pilcrow}

For example, the schema[¶](#section-3.3.4-5){.pilcrow}

::: {#section-3.3.4-6}
``` {.sourcecode .lang-json}
   { "enum": ["PENDING", "DONE", "CANCELED"] }
```

[¶](#section-3.3.4-6){.pilcrow}
:::

accepts[¶](#section-3.3.4-7){.pilcrow}

::: {#section-3.3.4-8}
``` {.sourcecode .lang-json}
   "PENDING"
```

[¶](#section-3.3.4-8){.pilcrow}
:::

and[¶](#section-3.3.4-9){.pilcrow}

::: {#section-3.3.4-10}
``` {.sourcecode .lang-json}
   "DONE"
```

[¶](#section-3.3.4-10){.pilcrow}
:::

and[¶](#section-3.3.4-11){.pilcrow}

::: {#section-3.3.4-12}
``` {.sourcecode .lang-json}
   "CANCELED"
```

[¶](#section-3.3.4-12){.pilcrow}
:::

but rejects all of[¶](#section-3.3.4-13){.pilcrow}

::: {#section-3.3.4-14}
``` {.sourcecode .lang-json}
   0
```

[¶](#section-3.3.4-14){.pilcrow}
:::

and[¶](#section-3.3.4-15){.pilcrow}

::: {#section-3.3.4-16}
``` {.sourcecode .lang-json}
   1
```

[¶](#section-3.3.4-16){.pilcrow}
:::

and[¶](#section-3.3.4-17){.pilcrow}

::: {#section-3.3.4-18}
``` {.sourcecode .lang-json}
   2
```

[¶](#section-3.3.4-18){.pilcrow}
:::

and[¶](#section-3.3.4-19){.pilcrow}

::: {#section-3.3.4-20}
``` {.sourcecode .lang-json}
   "UNKNOWN"
```

[¶](#section-3.3.4-20){.pilcrow}
:::

and[¶](#section-3.3.4-21){.pilcrow}

::: {#section-3.3.4-22}
``` {.sourcecode .lang-json}
   null
```

[¶](#section-3.3.4-22){.pilcrow}
:::

with the error indicator[¶](#section-3.3.4-23){.pilcrow}

::: {#section-3.3.4-24}
``` {.sourcecode .lang-json}
   [{ "instancePath": "", "schemaPath": "/enum" }]
```

[¶](#section-3.3.4-24){.pilcrow}
:::

The schema[¶](#section-3.3.4-25){.pilcrow}

::: {#section-3.3.4-26}
``` {.sourcecode .lang-json}
   { "enum": ["PENDING", "DONE", "CANCELED"], "nullable": true }
```

[¶](#section-3.3.4-26){.pilcrow}
:::

accepts[¶](#section-3.3.4-27){.pilcrow}

::: {#section-3.3.4-28}
``` {.sourcecode .lang-json}
   "PENDING"
```

[¶](#section-3.3.4-28){.pilcrow}
:::

and[¶](#section-3.3.4-29){.pilcrow}

::: {#section-3.3.4-30}
``` {.sourcecode .lang-json}
   null
```

[¶](#section-3.3.4-30){.pilcrow}
:::

but rejects[¶](#section-3.3.4-31){.pilcrow}

::: {#section-3.3.4-32}
``` {.sourcecode .lang-json}
   1
```

[¶](#section-3.3.4-32){.pilcrow}
:::

and[¶](#section-3.3.4-33){.pilcrow}

::: {#section-3.3.4-34}
``` {.sourcecode .lang-json}
   "UNKNOWN"
```

[¶](#section-3.3.4-34){.pilcrow}
:::

with the error indicator[¶](#section-3.3.4-35){.pilcrow}

::: {#section-3.3.4-36}
``` {.sourcecode .lang-json}
   [{ "instancePath": "", "schemaPath": "/enum" }]
```

[¶](#section-3.3.4-36){.pilcrow}
:::
:::
:::

::: {#semantics-form-elements}
::: {#section-3.3.5 .section}
#### [3.3.5.](#section-3.3.5){.section-number .selfRef} [Elements](#name-elements-2){.section-name .selfRef} {#name-elements-2}

The \"elements\" form is meant to describe instances that must be
arrays. A further subschema describes the elements of the array. The
syntax of the \"elements\" form is described in [Section
2.2.5](#syntax-form-elements){.xref}.[¶](#section-3.3.5-1){.pilcrow}

If a schema is of the \"elements\" form,
then:[¶](#section-3.3.5-2){.pilcrow}

-   ::: {#section-3.3.5-3.1}
    If the schema has a member named \"nullable\" whose value is the
    boolean \"true\", and the instance is the JSON primitive value
    \"null\", then the schema accepts the
    instance.[¶](#section-3.3.5-3.1.1){.pilcrow}

    Otherwise:[¶](#section-3.3.5-3.1.2){.pilcrow}

    -   ::: {#section-3.3.5-3.1.3.1}
        Let *S* be the value of the schema member with the name
        \"elements\". The instance is accepted if and only if all of the
        following are true:[¶](#section-3.3.5-3.1.3.1.1){.pilcrow}
        :::

    -   ::: {#section-3.3.5-3.1.3.2}
        -   [The instance is an array. Otherwise, the error indicator
            for this case shall have an \"instancePath\" pointing to the
            instance and a \"schemaPath\" pointing to the schema member
            with the name
            \"elements\".[¶](#section-3.3.5-3.1.3.2.1.1){.pilcrow}]{#section-3.3.5-3.1.3.2.1.1}
        -   [If the instance is an array, then every element of the
            instance must be accepted by *S*. Otherwise, the error
            indicators for this case are the union of all the errors
            arising from evaluating *S* against elements of the
            instance.[¶](#section-3.3.5-3.1.3.2.1.2){.pilcrow}]{#section-3.3.5-3.1.3.2.1.2}
        :::
    :::

For example, the schema[¶](#section-3.3.5-4){.pilcrow}

::: {#section-3.3.5-5}
``` {.sourcecode .lang-json}
   {
     "elements": {
       "type": "float32"
     }
   }
```

[¶](#section-3.3.5-5){.pilcrow}
:::

accepts[¶](#section-3.3.5-6){.pilcrow}

::: {#section-3.3.5-7}
``` {.sourcecode .lang-json}
   []
```

[¶](#section-3.3.5-7){.pilcrow}
:::

and[¶](#section-3.3.5-8){.pilcrow}

::: {#section-3.3.5-9}
``` {.sourcecode .lang-json}
   [1, 2, 3]
```

[¶](#section-3.3.5-9){.pilcrow}
:::

but rejects[¶](#section-3.3.5-10){.pilcrow}

::: {#section-3.3.5-11}
``` {.sourcecode .lang-json}
   null
```

[¶](#section-3.3.5-11){.pilcrow}
:::

with the error indicator[¶](#section-3.3.5-12){.pilcrow}

::: {#section-3.3.5-13}
``` {.sourcecode .lang-json}
   [{ "instancePath": "", "schemaPath": "/elements" }]
```

[¶](#section-3.3.5-13){.pilcrow}
:::

and rejects[¶](#section-3.3.5-14){.pilcrow}

::: {#section-3.3.5-15}
``` {.sourcecode .lang-json}
   [1, 2, "foo", 3, "bar"]
```

[¶](#section-3.3.5-15){.pilcrow}
:::

with the error indicators[¶](#section-3.3.5-16){.pilcrow}

::: {#section-3.3.5-17}
``` {.sourcecode .lang-json}
   [
     { "instancePath": "/2", "schemaPath": "/elements/type" },
     { "instancePath": "/4", "schemaPath": "/elements/type" }
   ]
```

[¶](#section-3.3.5-17){.pilcrow}
:::

The schema[¶](#section-3.3.5-18){.pilcrow}

::: {#section-3.3.5-19}
``` {.sourcecode .lang-json}
   {
     "elements": {
       "type": "float32"
     },
     "nullable": true
   }
```

[¶](#section-3.3.5-19){.pilcrow}
:::

accepts[¶](#section-3.3.5-20){.pilcrow}

::: {#section-3.3.5-21}
``` {.sourcecode .lang-json}
   null
```

[¶](#section-3.3.5-21){.pilcrow}
:::

and[¶](#section-3.3.5-22){.pilcrow}

::: {#section-3.3.5-23}
``` {.sourcecode .lang-json}
   []
```

[¶](#section-3.3.5-23){.pilcrow}
:::

and[¶](#section-3.3.5-24){.pilcrow}

::: {#section-3.3.5-25}
``` {.sourcecode .lang-json}
   [1, 2, 3]
```

[¶](#section-3.3.5-25){.pilcrow}
:::

but rejects[¶](#section-3.3.5-26){.pilcrow}

::: {#section-3.3.5-27}
``` {.sourcecode .lang-json}
   [1, 2, "foo", 3, "bar"]
```

[¶](#section-3.3.5-27){.pilcrow}
:::

with the error indicators[¶](#section-3.3.5-28){.pilcrow}

::: {#section-3.3.5-29}
``` {.sourcecode .lang-json}
   [
     { "instancePath": "/2", "schemaPath": "/elements/type" },
     { "instancePath": "/4", "schemaPath": "/elements/type" }
   ]
```

[¶](#section-3.3.5-29){.pilcrow}
:::
:::
:::

::: {#semantics-form-props}
::: {#section-3.3.6 .section}
#### [3.3.6.](#section-3.3.6){.section-number .selfRef} [Properties](#name-properties-2){.section-name .selfRef} {#name-properties-2}

The \"properties\" form is meant to describe JSON objects being used as
a \"struct\". The syntax of the \"properties\" form is described in
[Section
2.2.6](#syntax-form-properties){.xref}.[¶](#section-3.3.6-1){.pilcrow}

If a schema is of the \"properties\" form,
then:[¶](#section-3.3.6-2){.pilcrow}

-   ::: {#section-3.3.6-3.1}
    If the schema has a member named \"nullable\" whose value is the
    boolean \"true\", and the instance is the JSON primitive value
    \"null\", then the schema accepts the
    instance.[¶](#section-3.3.6-3.1.1){.pilcrow}

    Otherwise:[¶](#section-3.3.6-3.1.2){.pilcrow}

    -   ::: {#section-3.3.6-3.1.3.1}
        The instance must be an
        object.[¶](#section-3.3.6-3.1.3.1.1){.pilcrow}

        Otherwise, the schema rejects the instance. The error indicator
        for this case shall have an \"instancePath\" pointing to the
        instance, and a \"schemaPath\" pointing to the schema member
        with the name \"properties\" if such a schema member exists; if
        such a member doesn\'t exist, \"schemaPath\" shall point to the
        schema member with the name
        \"optionalProperties\".[¶](#section-3.3.6-3.1.3.1.2){.pilcrow}
        :::

    -   ::: {#section-3.3.6-3.1.3.2}
        If the instance is an object, and the schema has a member named
        \"properties\", then let *P* be the value of the schema member
        named \"properties\". Per [Section
        2.2.6](#syntax-form-properties){.xref}, we know *P* is an
        object. For every member name in *P*, a member of the same name
        in the instance must
        exist.[¶](#section-3.3.6-3.1.3.2.1){.pilcrow}

        Otherwise, the schema rejects the instance. The error indicator
        for this case shall have an \"instancePath\" pointing to the
        instance, and a \"schemaPath\" pointing to the member of *P*
        failing the requirement just
        described.[¶](#section-3.3.6-3.1.3.2.2){.pilcrow}
        :::

    -   ::: {#section-3.3.6-3.1.3.3}
        If the instance is an object, then let *P* be the value of the
        schema member named \"properties\" (if it exists) and *O* be the
        value of the schema member named \"optionalProperties\" (if it
        exists).[¶](#section-3.3.6-3.1.3.3.1){.pilcrow}

        For every member *I* of the instance, find a member with the
        same name as *I*\'s in *P* or *O*. Per [Section
        2.2.6](#syntax-form-properties){.xref}, we know it is not
        possible for both *P* and *O* to have such a member. If the
        \"discriminator tag exemption\" is in effect on *I* (see
        [Section 3.3.8](#semantics-form-discriminator){.xref}), then
        ignore *I*.[¶](#section-3.3.6-3.1.3.3.2){.pilcrow}

        Otherwise:[¶](#section-3.3.6-3.1.3.3.3){.pilcrow}

        -   ::: {#section-3.3.6-3.1.3.3.4.1}
            If no such member in *P* or *O* exists and validation is not
            in \"allow additional properties\" mode (see [Section
            3.1](#allow-additional-properties){.xref}), then the schema
            rejects the
            instance.[¶](#section-3.3.6-3.1.3.3.4.1.1){.pilcrow}

            The error indicator for this case has an \"instancePath\"
            pointing to *I* and a \"schemaPath\" pointing to the
            schema.[¶](#section-3.3.6-3.1.3.3.4.1.2){.pilcrow}
            :::

        -   ::: {#section-3.3.6-3.1.3.3.4.2}
            If such a member in *P* or *O* does exist, then call this
            member *S*. If *S* rejects *I*\'s value, then the schema
            rejects the
            instance.[¶](#section-3.3.6-3.1.3.3.4.2.1){.pilcrow}

            The error indicators for this case are the union of the
            error indicators from evaluating *S* against *I*\'s
            value.[¶](#section-3.3.6-3.1.3.3.4.2.2){.pilcrow}
            :::
        :::
    :::

```{=html}
<!-- -->
```
-   ::: {#section-3.3.6-4.1}
    If an instance is an object, it may have multiple errors arising
    from the second and third bullet in the list above. In this case,
    the error indicators are the union of the
    errors.[¶](#section-3.3.6-4.1.1){.pilcrow}

    For example, the schema[¶](#section-3.3.6-4.1.2){.pilcrow}

    ::: {#section-3.3.6-4.1.3}
    ``` {.sourcecode .lang-json}
       {
         "properties": {
           "a": { "type": "string" },
           "b": { "type": "string" }
         },
         "optionalProperties": {
           "c": { "type": "string" },
           "d": { "type": "string" }
         }
       }
    ```

    [¶](#section-3.3.6-4.1.3){.pilcrow}
    :::

    accepts[¶](#section-3.3.6-4.1.4){.pilcrow}

    ::: {#section-3.3.6-4.1.5}
    ``` {.sourcecode .lang-json}
       { "a": "foo", "b": "bar" }
    ```

    [¶](#section-3.3.6-4.1.5){.pilcrow}
    :::

    and[¶](#section-3.3.6-4.1.6){.pilcrow}

    ::: {#section-3.3.6-4.1.7}
    ``` {.sourcecode .lang-json}
       { "a": "foo", "b": "bar", "c": "baz" }
    ```

    [¶](#section-3.3.6-4.1.7){.pilcrow}
    :::

    and[¶](#section-3.3.6-4.1.8){.pilcrow}

    ::: {#section-3.3.6-4.1.9}
    ``` {.sourcecode .lang-json}
       { "a": "foo", "b": "bar", "c": "baz", "d": "quux" }
    ```

    [¶](#section-3.3.6-4.1.9){.pilcrow}
    :::

    and[¶](#section-3.3.6-4.1.10){.pilcrow}

    ::: {#section-3.3.6-4.1.11}
    ``` {.sourcecode .lang-json}
       { "a": "foo", "b": "bar", "d": "quux" }
    ```

    [¶](#section-3.3.6-4.1.11){.pilcrow}
    :::

    but rejects[¶](#section-3.3.6-4.1.12){.pilcrow}

    ::: {#section-3.3.6-4.1.13}
    ``` {.sourcecode .lang-json}
       null
    ```

    [¶](#section-3.3.6-4.1.13){.pilcrow}
    :::

    with the error indicator[¶](#section-3.3.6-4.1.14){.pilcrow}

    ::: {#section-3.3.6-4.1.15}
    ``` {.sourcecode .lang-json}
       [{ "instancePath": "", "schemaPath": "/properties" }]
    ```

    [¶](#section-3.3.6-4.1.15){.pilcrow}
    :::

    and rejects[¶](#section-3.3.6-4.1.16){.pilcrow}

    ::: {#section-3.3.6-4.1.17}
    ``` {.sourcecode .lang-json}
       { "b": 3, "c": 3, "e": 3 }
    ```

    [¶](#section-3.3.6-4.1.17){.pilcrow}
    :::

    with the error indicators[¶](#section-3.3.6-4.1.18){.pilcrow}

    ::: {#section-3.3.6-4.1.19}
    ``` {.sourcecode .lang-json}
       [
         { "instancePath": "",
           "schemaPath": "/properties/a" },
         { "instancePath": "/b",
           "schemaPath": "/properties/b/type" },
         { "instancePath": "/c",
           "schemaPath": "/optionalProperties/c/type" },
         { "instancePath": "/e",
           "schemaPath": "" }
       ]
    ```

    [¶](#section-3.3.6-4.1.19){.pilcrow}
    :::

    If instead the schema had \"additionalProperties: true\" but was
    otherwise the same:[¶](#section-3.3.6-4.1.20){.pilcrow}

    ::: {#section-3.3.6-4.1.21}
    ``` {.sourcecode .lang-json}
       {
         "properties": {
           "a": { "type": "string" },
           "b": { "type": "string" }
         },
         "optionalProperties": {
           "c": { "type": "string" },
           "d": { "type": "string" }
         },
         "additionalProperties": true
       }
    ```

    [¶](#section-3.3.6-4.1.21){.pilcrow}
    :::

    and the instance remained the
    same:[¶](#section-3.3.6-4.1.22){.pilcrow}

    ::: {#section-3.3.6-4.1.23}
    ``` {.sourcecode .lang-json}
       { "b": 3, "c": 3, "e": 3 }
    ```

    [¶](#section-3.3.6-4.1.23){.pilcrow}
    :::

    then the error indicators from evaluating the instance against the
    schema would be:[¶](#section-3.3.6-4.1.24){.pilcrow}

    ::: {#section-3.3.6-4.1.25}
    ``` {.sourcecode .lang-json}
       [
         { "instancePath": "",
           "schemaPath": "/properties/a" },
         { "instancePath": "/b",
           "schemaPath": "/properties/b/type" },
         { "instancePath": "/c",
           "schemaPath": "/optionalProperties/c/type" },
       ]
    ```

    [¶](#section-3.3.6-4.1.25){.pilcrow}
    :::

    These are the same errors as before, except the final error
    (associated with the additional member named \"e\" in the instance)
    is no longer present. This is because \"additionalProperties: true\"
    enables \"allow additional properties\" mode on the
    schema.[¶](#section-3.3.6-4.1.26){.pilcrow}

    Finally, the schema[¶](#section-3.3.6-4.1.27){.pilcrow}

    ::: {#section-3.3.6-4.1.28}
    ``` {.sourcecode .lang-json}
       {
         "nullable": true,
         "properties": {
           "a": { "type": "string" },
           "b": { "type": "string" }
         },
         "optionalProperties": {
           "c": { "type": "string" },
           "d": { "type": "string" }
         },
         "additionalProperties": true
       }
    ```

    [¶](#section-3.3.6-4.1.28){.pilcrow}
    :::

    accepts[¶](#section-3.3.6-4.1.29){.pilcrow}

    ::: {#section-3.3.6-4.1.30}
    ``` {.sourcecode .lang-json}
       null
    ```

    [¶](#section-3.3.6-4.1.30){.pilcrow}
    :::

    but rejects[¶](#section-3.3.6-4.1.31){.pilcrow}

    ::: {#section-3.3.6-4.1.32}
    ``` {.sourcecode .lang-json}
       { "b": 3, "c": 3, "e": 3 }
    ```

    [¶](#section-3.3.6-4.1.32){.pilcrow}
    :::

    with the error indicators[¶](#section-3.3.6-4.1.33){.pilcrow}

    ::: {#section-3.3.6-4.1.34}
    ``` {.sourcecode .lang-json}
       [
         { "instancePath": "",
           "schemaPath": "/properties/a" },
         { "instancePath": "/b",
           "schemaPath": "/properties/b/type" },
         { "instancePath": "/c",
           "schemaPath": "/optionalProperties/c/type" },
       ]
    ```

    [¶](#section-3.3.6-4.1.34){.pilcrow}
    :::
    :::
:::
:::

::: {#semantics-form-values}
::: {#section-3.3.7 .section}
#### [3.3.7.](#section-3.3.7){.section-number .selfRef} [Values](#name-values-2){.section-name .selfRef} {#name-values-2}

The \"values\" form is meant to describe instances that are JSON objects
being used as an associative array. The syntax of the \"values\" form is
described in [Section
2.2.7](#syntax-form-values){.xref}.[¶](#section-3.3.7-1){.pilcrow}

If a schema is of the \"values\" form,
then:[¶](#section-3.3.7-2){.pilcrow}

-   ::: {#section-3.3.7-3.1}
    If the schema has a member named \"nullable\" whose value is the
    boolean \"true\", and the instance is the JSON primitive value
    \"null\", then the schema accepts the
    instance.[¶](#section-3.3.7-3.1.1){.pilcrow}

    Otherwise:[¶](#section-3.3.7-3.1.2){.pilcrow}

    -   ::: {#section-3.3.7-3.1.3.1}
        Let *S* be the value of the schema member with the name
        \"values\". The instance is accepted if and only if all of the
        following are true:[¶](#section-3.3.7-3.1.3.1.1){.pilcrow}

        -   [The instance is an object. Otherwise, the error indicator
            for this case shall have an \"instancePath\" pointing to the
            instance and a \"schemaPath\" pointing to the schema member
            with the name
            \"values\".[¶](#section-3.3.7-3.1.3.1.2.1){.pilcrow}]{#section-3.3.7-3.1.3.1.2.1}
        -   [If the instance is an object, then every member value of
            the instance must be accepted by *S*. Otherwise, the error
            indicators for this case are the union of all the error
            indicators arising from evaluating *S* against member values
            of the
            instance.[¶](#section-3.3.7-3.1.3.1.2.2){.pilcrow}]{#section-3.3.7-3.1.3.1.2.2}
        :::
    :::

For example, the schema[¶](#section-3.3.7-4){.pilcrow}

::: {#section-3.3.7-5}
``` {.sourcecode .lang-json}
   {
     "values": {
       "type": "float32"
     }
   }
```

[¶](#section-3.3.7-5){.pilcrow}
:::

accepts[¶](#section-3.3.7-6){.pilcrow}

::: {#section-3.3.7-7}
``` {.sourcecode .lang-json}
   {}
```

[¶](#section-3.3.7-7){.pilcrow}
:::

and[¶](#section-3.3.7-8){.pilcrow}

::: {#section-3.3.7-9}
``` {.sourcecode .lang-json}
   {"a": 1, "b": 2}
```

[¶](#section-3.3.7-9){.pilcrow}
:::

but rejects[¶](#section-3.3.7-10){.pilcrow}

::: {#section-3.3.7-11}
``` {.sourcecode .lang-json}
   null
```

[¶](#section-3.3.7-11){.pilcrow}
:::

with the error indicator[¶](#section-3.3.7-12){.pilcrow}

::: {#section-3.3.7-13}
``` {.sourcecode .lang-json}
   [{ "instancePath": "", "schemaPath": "/values" }]
```

[¶](#section-3.3.7-13){.pilcrow}
:::

and rejects[¶](#section-3.3.7-14){.pilcrow}

::: {#section-3.3.7-15}
``` {.sourcecode .lang-json}
   { "a": 1, "b": 2, "c": "foo", "d": 3, "e": "bar" }
```

[¶](#section-3.3.7-15){.pilcrow}
:::

with the error indicators[¶](#section-3.3.7-16){.pilcrow}

::: {#section-3.3.7-17}
``` {.sourcecode .lang-json}
   [
     { "instancePath": "/c", "schemaPath": "/values/type" },
     { "instancePath": "/e", "schemaPath": "/values/type" }
   ]
```

[¶](#section-3.3.7-17){.pilcrow}
:::

The schema[¶](#section-3.3.7-18){.pilcrow}

::: {#section-3.3.7-19}
``` {.sourcecode .lang-json}
   {
     "nullable": true,
     "values": {
       "type": "float32"
     }
   }
```

[¶](#section-3.3.7-19){.pilcrow}
:::

accepts[¶](#section-3.3.7-20){.pilcrow}

::: {#section-3.3.7-21}
``` {.sourcecode .lang-json}
   null
```

[¶](#section-3.3.7-21){.pilcrow}
:::

but rejects[¶](#section-3.3.7-22){.pilcrow}

::: {#section-3.3.7-23}
``` {.sourcecode .lang-json}
   { "a": 1, "b": 2, "c": "foo", "d": 3, "e": "bar" }
```

[¶](#section-3.3.7-23){.pilcrow}
:::

with the error indicators[¶](#section-3.3.7-24){.pilcrow}

::: {#section-3.3.7-25}
``` {.sourcecode .lang-json}
   [
     { "instancePath": "/c", "schemaPath": "/values/type" },
     { "instancePath": "/e", "schemaPath": "/values/type" }
   ]
```

[¶](#section-3.3.7-25){.pilcrow}
:::
:::
:::

::: {#semantics-form-discriminator}
::: {#section-3.3.8 .section}
#### [3.3.8.](#section-3.3.8){.section-number .selfRef} [Discriminator](#name-discriminator-2){.section-name .selfRef} {#name-discriminator-2}

The \"discriminator\" form is meant to describe JSON objects being used
in a fashion similar to a discriminated union construct in C-like
languages. The syntax of the \"discriminator\" form is described in
[Section
2.2.8](#syntax-form-discriminator){.xref}.[¶](#section-3.3.8-1){.pilcrow}

When a schema is of the \"discriminator\" form, it validates
that:[¶](#section-3.3.8-2){.pilcrow}

-   [the instance is an
    object,[¶](#section-3.3.8-3.1){.pilcrow}]{#section-3.3.8-3.1}
-   [the instance has a particular \"tag\"
    property,[¶](#section-3.3.8-3.2){.pilcrow}]{#section-3.3.8-3.2}
-   [this \"tag\" property\'s value is a string within a set of valid
    values, and[¶](#section-3.3.8-3.3){.pilcrow}]{#section-3.3.8-3.3}
-   [the instance satisfies another schema, where this other schema is
    chosen based on the value of the \"tag\"
    property.[¶](#section-3.3.8-3.4){.pilcrow}]{#section-3.3.8-3.4}

The behavior of the \"discriminator\" form is more complex than the
other keywords. Readers familiar with CDDL may find the final example in
[Appendix B](#comparison-with-cddl){.xref} helpful in understanding its
behavior. What follows in this section is a description of the
\"discriminator\" form\'s behavior, as well as some
examples.[¶](#section-3.3.8-4){.pilcrow}

If a schema is of the \"discriminator\" form,
then:[¶](#section-3.3.8-5){.pilcrow}

-   [Let *D* be the schema member with the name
    \"discriminator\".[¶](#section-3.3.8-6.1){.pilcrow}]{#section-3.3.8-6.1}
-   [Let *M* be the schema member with the name
    \"mapping\".[¶](#section-3.3.8-6.2){.pilcrow}]{#section-3.3.8-6.2}
-   [Let *I* be the instance member whose name equals *D*\'s value. *I*
    may, for some rejected instances, not
    exist.[¶](#section-3.3.8-6.3){.pilcrow}]{#section-3.3.8-6.3}
-   [Let *S* be the member of *M* whose name equals *I*\'s value. *S*
    may, for some rejected instances, not
    exist.[¶](#section-3.3.8-6.4){.pilcrow}]{#section-3.3.8-6.4}

If the schema has a member named \"nullable\" whose value is the boolean
\"true\", and the instance is the JSON primitive value \"null\", then
the schema accepts the instance. Otherwise, the instance is accepted if
and only if all of the following are
true:[¶](#section-3.3.8-7){.pilcrow}

-   ::: {#section-3.3.8-8.1}
    The instance is an object.[¶](#section-3.3.8-8.1.1){.pilcrow}

    Otherwise, the error indicator for this case shall have an
    \"instancePath\" pointing to the instance and a \"schemaPath\"
    pointing to *D*.[¶](#section-3.3.8-8.1.2){.pilcrow}
    :::

-   ::: {#section-3.3.8-8.2}
    If the instance is a JSON object, then *I* must
    exist.[¶](#section-3.3.8-8.2.1){.pilcrow}

    Otherwise, the error indicator for this case shall have an
    \"instancePath\" pointing to the instance and a \"schemaPath\"
    pointing to *D*.[¶](#section-3.3.8-8.2.2){.pilcrow}
    :::

-   ::: {#section-3.3.8-8.3}
    If the instance is a JSON object and *I* exists, *I*\'s value must
    be a string.[¶](#section-3.3.8-8.3.1){.pilcrow}

    Otherwise, the error indicator for this case shall have an
    \"instancePath\" pointing to *I* and a \"schemaPath\" pointing to
    *D*.[¶](#section-3.3.8-8.3.2){.pilcrow}
    :::

-   ::: {#section-3.3.8-8.4}
    If the instance is a JSON object and *I* exists and has a string
    value, then *S* must exist.[¶](#section-3.3.8-8.4.1){.pilcrow}

    Otherwise, the error indicator for this case shall have an
    \"instancePath\" pointing to *I* and a \"schemaPath\" pointing to
    *M*.[¶](#section-3.3.8-8.4.2){.pilcrow}
    :::

-   ::: {#section-3.3.8-8.5}
    If the instance is a JSON object, *I* exists, and *S* exists, then
    the instance must satisfy *S*\'s value. Per [Section
    2](#syntax){.xref}, we know *S*\'s value is a schema of the
    \"properties\" form. Apply the \"discriminator tag exemption\"
    afforded in [Section 3.3.6](#semantics-form-props){.xref} to *I*
    when evaluating whether the instance satisfies *S*\'s
    value.[¶](#section-3.3.8-8.5.1){.pilcrow}

    Otherwise, the error indicators for this case shall be error
    indicators from evaluating *S*\'s value against the instance, with
    the \"discriminator tag exemption\" applied to
    *I*.[¶](#section-3.3.8-8.5.2){.pilcrow}
    :::

The list items above are defined in a mutually exclusive way. For any
given instance and schema, exactly one of the list items above will
apply.[¶](#section-3.3.8-9){.pilcrow}

For example, the schema[¶](#section-3.3.8-10){.pilcrow}

::: {#section-3.3.8-11}
``` {.sourcecode .lang-json}
   {
     "discriminator": "version",
     "mapping": {
       "v1": {
         "properties": {
           "a": { "type": "float32" }
         }
       },
       "v2": {
         "properties": {
           "a": { "type": "string" }
         }
       }
     }
   }
```

[¶](#section-3.3.8-11){.pilcrow}
:::

rejects[¶](#section-3.3.8-12){.pilcrow}

::: {#section-3.3.8-13}
``` {.sourcecode .lang-json}
   null
```

[¶](#section-3.3.8-13){.pilcrow}
:::

with the error indicator[¶](#section-3.3.8-14){.pilcrow}

::: {#section-3.3.8-15}
``` {.sourcecode .lang-json}
   [{ "instancePath": "", "schemaPath": "/discriminator" }]
```

[¶](#section-3.3.8-15){.pilcrow}
:::

(This is the case of the instance not being an
object.)[¶](#section-3.3.8-16){.pilcrow}

Also rejected is[¶](#section-3.3.8-17){.pilcrow}

::: {#section-3.3.8-18}
``` {.sourcecode .lang-json}
   {}
```

[¶](#section-3.3.8-18){.pilcrow}
:::

with the error indicator[¶](#section-3.3.8-19){.pilcrow}

::: {#section-3.3.8-20}
``` {.sourcecode .lang-json}
   [{ "instancePath": "", "schemaPath": "/discriminator" }]
```

[¶](#section-3.3.8-20){.pilcrow}
:::

(This is the case of *I* not existing.)[¶](#section-3.3.8-21){.pilcrow}

Also rejected is[¶](#section-3.3.8-22){.pilcrow}

::: {#section-3.3.8-23}
``` {.sourcecode .lang-json}
   { "version": 1 }
```

[¶](#section-3.3.8-23){.pilcrow}
:::

with the error indicator[¶](#section-3.3.8-24){.pilcrow}

::: {#section-3.3.8-25}
``` {.sourcecode .lang-json}
   [
     {
       "instancePath": "/version",
       "schemaPath": "/discriminator"
     }
   ]
```

[¶](#section-3.3.8-25){.pilcrow}
:::

(This is the case of *I* existing but not having a string
value.)[¶](#section-3.3.8-26){.pilcrow}

Also rejected is[¶](#section-3.3.8-27){.pilcrow}

::: {#section-3.3.8-28}
``` {.sourcecode .lang-json}
   { "version": "v3" }
```

[¶](#section-3.3.8-28){.pilcrow}
:::

with the error indicator[¶](#section-3.3.8-29){.pilcrow}

::: {#section-3.3.8-30}
``` {.sourcecode .lang-json}
   [
     {
       "instancePath": "/version",
       "schemaPath": "/mapping"
     }
   ]
```

[¶](#section-3.3.8-30){.pilcrow}
:::

(This is the case of *I* existing and having a string value but *S* not
existing.)[¶](#section-3.3.8-31){.pilcrow}

Also rejected is[¶](#section-3.3.8-32){.pilcrow}

::: {#section-3.3.8-33}
``` {.sourcecode .lang-json}
   { "version": "v2", "a": 3 }
```

[¶](#section-3.3.8-33){.pilcrow}
:::

with the error indicator[¶](#section-3.3.8-34){.pilcrow}

::: {#section-3.3.8-35}
``` {.sourcecode .lang-json}
   [
     {
       "instancePath": "/a",
       "schemaPath": "/mapping/v2/properties/a/type"
     }
   ]
```

[¶](#section-3.3.8-35){.pilcrow}
:::

(This is the case of *I* and *S* existing but the instance not
satisfying *S*\'s value.)[¶](#section-3.3.8-36){.pilcrow}

Finally, the schema accepts[¶](#section-3.3.8-37){.pilcrow}

::: {#section-3.3.8-38}
``` {.sourcecode .lang-json}
   { "version": "v2", "a": "foo" }
```

[¶](#section-3.3.8-38){.pilcrow}
:::

This instance is accepted even though \"version\" is not mentioned by
\"/mapping/v2/properties\"; the \"discriminator tag exemption\" ensures
that \"version\" is not treated as an additional property when
evaluating the instance against *S*\'s
value.[¶](#section-3.3.8-39){.pilcrow}

By contrast, consider the same schema but with \"nullable\" being
\"true\". The schema[¶](#section-3.3.8-40){.pilcrow}

::: {#section-3.3.8-41}
``` {.sourcecode .lang-json}
   {
     "nullable": true,
      "discriminator": "version",
      "mapping": {
        "v1": {
          "properties": {
            "a": { "type": "float32" }
          }
        },
        "v2": {
          "properties": {
            "a": { "type": "string" }
          }
        }
      }
   }
```

[¶](#section-3.3.8-41){.pilcrow}
:::

accepts[¶](#section-3.3.8-42){.pilcrow}

::: {#section-3.3.8-43}
``` {.sourcecode .lang-json}
   null
```

[¶](#section-3.3.8-43){.pilcrow}
:::

To further illustrate the \"discriminator\" form with examples, recall
the JTD schema in [Section 2.2.8](#syntax-form-discriminator){.xref},
reproduced here:[¶](#section-3.3.8-44){.pilcrow}

::: {#section-3.3.8-45}
``` {.sourcecode .lang-json}
   {
     "discriminator": "event_type",
     "mapping": {
       "account_deleted": {
         "properties": {
           "account_id": { "type": "string" }
         }
       },
       "account_payment_plan_changed": {
         "properties": {
           "account_id": { "type": "string" },
           "payment_plan": { "enum": ["FREE", "PAID"] }
         },
         "optionalProperties": {
           "upgraded_by": { "type": "string" }
         }
       }
     }
   }
```

[¶](#section-3.3.8-45){.pilcrow}
:::

This schema accepts[¶](#section-3.3.8-46){.pilcrow}

::: {#section-3.3.8-47}
``` {.sourcecode .lang-json}
   { "event_type": "account_deleted", "account_id": "abc-123" }
```

[¶](#section-3.3.8-47){.pilcrow}
:::

and[¶](#section-3.3.8-48){.pilcrow}

::: {#section-3.3.8-49}
``` {.sourcecode .lang-json}
   {
     "event_type": "account_payment_plan_changed",
     "account_id": "abc-123",
     "payment_plan": "PAID"
   }
```

[¶](#section-3.3.8-49){.pilcrow}
:::

and[¶](#section-3.3.8-50){.pilcrow}

::: {#section-3.3.8-51}
``` {.sourcecode .lang-json}
   {
     "event_type": "account_payment_plan_changed",
     "account_id": "abc-123",
     "payment_plan": "PAID",
     "upgraded_by": "users/mkhwarizmi"
   }
```

[¶](#section-3.3.8-51){.pilcrow}
:::

but rejects[¶](#section-3.3.8-52){.pilcrow}

::: {#section-3.3.8-53}
``` {.sourcecode .lang-json}
   {}
```

[¶](#section-3.3.8-53){.pilcrow}
:::

with the error indicator[¶](#section-3.3.8-54){.pilcrow}

::: {#section-3.3.8-55}
``` {.sourcecode .lang-json}
   [{ "instancePath": "", "schemaPath": "/discriminator" }]
```

[¶](#section-3.3.8-55){.pilcrow}
:::

and rejects[¶](#section-3.3.8-56){.pilcrow}

::: {#section-3.3.8-57}
``` {.sourcecode .lang-json}
   { "event_type": "some_other_event_type" }
```

[¶](#section-3.3.8-57){.pilcrow}
:::

with the error indicator[¶](#section-3.3.8-58){.pilcrow}

::: {#section-3.3.8-59}
``` {.sourcecode .lang-json}
   [
     {
       "instancePath": "/event_type",
       "schemaPath": "/mapping"
     }
   ]
```

[¶](#section-3.3.8-59){.pilcrow}
:::

and rejects[¶](#section-3.3.8-60){.pilcrow}

::: {#section-3.3.8-61}
``` {.sourcecode .lang-json}
   { "event_type": "account_deleted" }
```

[¶](#section-3.3.8-61){.pilcrow}
:::

with the error indicator[¶](#section-3.3.8-62){.pilcrow}

::: {#section-3.3.8-63}
``` {.sourcecode .lang-json}
   [{
     "instancePath": "",
     "schemaPath": "/mapping/account_deleted/properties/account_id"
   }]
```

[¶](#section-3.3.8-63){.pilcrow}
:::

and rejects[¶](#section-3.3.8-64){.pilcrow}

::: {#section-3.3.8-65}
``` {.sourcecode .lang-json}
   {
     "event_type": "account_payment_plan_changed",
     "account_id": "abc-123",
     "payment_plan": "PAID",
     "xxx": "asdf"
   }
```

[¶](#section-3.3.8-65){.pilcrow}
:::

with the error indicator[¶](#section-3.3.8-66){.pilcrow}

::: {#section-3.3.8-67}
``` {.sourcecode .lang-json}
   [{
     "instancePath": "/xxx",
     "schemaPath": "/mapping/account_payment_plan_changed"
   }]
```

[¶](#section-3.3.8-67){.pilcrow}
:::
:::
:::
:::
:::
:::
:::

::: {#iana-considerations}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-4-1){.pilcrow}
:::
:::

::: {#security-considerations}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

Implementations of JTD will necessarily be manipulating JSON data.
Therefore, the security considerations of \[[RFC8259](#RFC8259){.xref}\]
are all relevant here.[¶](#section-5-1){.pilcrow}

Implementations that evaluate user-inputted schemas [SHOULD]{.bcp14}
implement mechanisms to detect and abort circular references that might
cause a naive implementation to go into an infinite loop. Without such
mechanisms, implementations may be vulnerable to denial-of-service
attacks.[¶](#section-5-2){.pilcrow}
:::
:::

::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC3339\]
:   [Klyne, G.]{.refAuthor}[ and C. Newman]{.refAuthor}, [\"Date and
    Time on the Internet: Timestamps\"]{.refTitle}, [RFC
    3339]{.seriesInfo}, [DOI 10.17487/RFC3339]{.seriesInfo}, July 2002,
    \<<https://www.rfc-editor.org/info/rfc3339>\>.
:   

\[RFC4287\]
:   [Nottingham, M., Ed.]{.refAuthor}[ and R. Sayre, Ed.]{.refAuthor},
    [\"The Atom Syndication Format\"]{.refTitle}, [RFC
    4287]{.seriesInfo}, [DOI 10.17487/RFC4287]{.seriesInfo}, December
    2005, \<<https://www.rfc-editor.org/info/rfc4287>\>.
:   

\[RFC6901\]
:   [Bryan, P., Ed.]{.refAuthor}[, Zyp, K.]{.refAuthor}[, and M.
    Nottingham, Ed.]{.refAuthor}, [\"JavaScript Object Notation (JSON)
    Pointer\"]{.refTitle}, [RFC 6901]{.seriesInfo}, [DOI
    10.17487/RFC6901]{.seriesInfo}, April 2013,
    \<<https://www.rfc-editor.org/info/rfc6901>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8259\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The JavaScript Object Notation
    (JSON) Data Interchange Format\"]{.refTitle}, [STD 90]{.seriesInfo},
    [RFC 8259]{.seriesInfo}, [DOI 10.17487/RFC8259]{.seriesInfo},
    December 2017, \<<https://www.rfc-editor.org/info/rfc8259>\>.
:   

\[RFC8610\]
:   [Birkholz, H.]{.refAuthor}[, Vigano, C.]{.refAuthor}[, and C.
    Bormann]{.refAuthor}, [\"Concise Data Definition Language (CDDL): A
    Notational Convention to Express Concise Binary Object
    Representation (CBOR) and JSON Data Structures\"]{.refTitle}, [RFC
    8610]{.seriesInfo}, [DOI 10.17487/RFC8610]{.seriesInfo}, June 2019,
    \<<https://www.rfc-editor.org/info/rfc8610>\>.
:   
:::

::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[JSON-SCHEMA\]
:   [Wright, A.]{.refAuthor}[, Andrews, H.]{.refAuthor}[,
    Hutton, B.]{.refAuthor}[, and G. Dennis]{.refAuthor}, [\"JSON
    Schema: A Media Type for Describing JSON Documents\"]{.refTitle},
    [Work in Progress]{.refContent}, [Internet-Draft,
    draft-handrews-json-schema-02]{.seriesInfo}, 17 September 2019,
    \<<https://tools.ietf.org/html/draft-handrews-json-schema-02>\>.
:   

\[OPENAPI\]
:   [OpenAPI Initiative]{.refAuthor}, [\"OpenAPI
    Specification\"]{.refTitle}, February 2020,
    \<<https://spec.openapis.org/oas/v3.0.3>\>.
:   

\[RFC7071\]
:   [Borenstein, N.]{.refAuthor}[ and M. Kucherawy]{.refAuthor}, [\"A
    Media Type for Reputation Interchange\"]{.refTitle}, [RFC
    7071]{.seriesInfo}, [DOI 10.17487/RFC7071]{.seriesInfo}, November
    2013, \<<https://www.rfc-editor.org/info/rfc7071>\>.
:   

\[RFC7493\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The I-JSON Message
    Format\"]{.refTitle}, [RFC 7493]{.seriesInfo}, [DOI
    10.17487/RFC7493]{.seriesInfo}, March 2015,
    \<<https://www.rfc-editor.org/info/rfc7493>\>.
:   
:::
:::

::: {#other-considerations}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [Rationale for Omitted Features](#name-rationale-for-omitted-featu){.section-name .selfRef} {#name-rationale-for-omitted-featu}

This appendix is not normative.[¶](#section-appendix.a-1){.pilcrow}

This section describes possible features that are intentionally left out
of JSON Type Definition and justifies why these features are
omitted.[¶](#section-appendix.a-2){.pilcrow}

::: {#other-considerations-int64}
::: {#section-a.1 .section}
## [A.1.](#section-a.1){.section-number .selfRef} [Support for 64-Bit Numbers](#name-support-for-64-bit-numbers){.section-name .selfRef} {#name-support-for-64-bit-numbers}

This document does not allow \"int64\" or \"uint64\" as values for the
JTD \"type\" keyword (see Sections [2.2.3](#syntax-form-type){.xref} and
[3.3.3](#semantics-form-type){.xref}). Such hypothetical \"int64\" or
\"uint64\" types would behave like \"int32\" or \"uint32\"
(respectively) but with the range of values associated with 64-bit
instead of 32-bit integers. That is:[¶](#section-a.1-1){.pilcrow}

-   [\"int64\" would accept numbers between -(2\*\*63) and
    (2\*\*63)-1[¶](#section-a.1-2.1){.pilcrow}]{#section-a.1-2.1}
-   [\"uint64\" would accept numbers between 0 and
    (2\*\*64)-1[¶](#section-a.1-2.2){.pilcrow}]{#section-a.1-2.2}

Users of \"int64\" and \"uint64\" would likely expect that the full
range of signed or unsigned 64-bit integers could interoperably be
transmitted as JSON without loss of precision. But this assumption is
likely to be incorrect, for the reasons given in [Section
2.2](https://www.rfc-editor.org/rfc/rfc7493#section-2.2){.relref} of
\[[RFC7493](#RFC7493){.xref}\].[¶](#section-a.1-3){.pilcrow}

\"int64\" and \"uint64\" likely would have led users to falsely assume
that the full range of 64-bit integers can be interoperably processed as
JSON without loss of precision. To avoid leading users astray, JTD omits
\"int64\" and \"uint64\".[¶](#section-a.1-4){.pilcrow}
:::
:::

::: {#support-for-non-root-definitions}
::: {#section-a.2 .section}
## [A.2.](#section-a.2){.section-number .selfRef} [Support for Non-root Definitions](#name-support-for-non-root-defini){.section-name .selfRef} {#name-support-for-non-root-defini}

This document disallows the \"definitions\" keyword from appearing
outside of root schemas (see [Figure 1](#cddl-schema){.xref}).
Conceivably, this document could have instead allowed \"definitions\" to
appear on any schema, even non-root ones. Under this alternative design,
\"ref\"s would resolve to a definition in the \"nearest\" (i.e., most
nested) schema that both contained the \"ref\" and had a suitably named
\"definitions\" member.[¶](#section-a.2-1){.pilcrow}

For instance, under this alternative approach, one could define schemas
like the one in [Figure
3](#hypothetical-ref){.xref}.[¶](#section-a.2-2){.pilcrow}

[]{#name-a-hypothetical-schema-had-t}

::: {#hypothetical-ref}
::: {#section-a.2-3.1}
``` {.sourcecode .lang-json}
{
  "properties": {
    "foo": {
      "definitions": {
        "user": { "properties": { "user_id": {"type": "string" }}}
      },
      "ref": "user"
    },
    "bar": {
      "definitions": {
        "user": { "properties": { "user_id": {"type": "string" }}}
      },
      "ref": "user"
    },
    "baz": {
      "definitions": {
        "user": { "properties": { "userId": {"type": "string" }}}
      },
      "ref": "user"
    }
  }
}
```
:::

[Figure 3](#figure-3){.selfRef}: [A Hypothetical Schema Had This
Document Permitted Non-root Definitions. This Is Not a Correct JTD
Schema.](#name-a-hypothetical-schema-had-t){.selfRef}
:::

If schemas like that in [Figure 3](#hypothetical-ref){.xref} were
permitted, code generation from JTD schemas would be more difficult, and
the generated code would be less useful.[¶](#section-a.2-4){.pilcrow}

Code generation would be more difficult because it would force code
generators to implement a name-mangling scheme for types generated from
definitions. This additional difficulty is not immense, but it adds
complexity to an otherwise relatively trivial
task.[¶](#section-a.2-5){.pilcrow}

Generated code would be less useful because generated, mangled struct
names are less pithy than human-defined struct names. For instance, the
\"user\" definitions in [Figure 3](#hypothetical-ref){.xref} might have
been generated into types named \"PropertiesFooUser\",
\"PropertiesBarUser\", and \"PropertiesBazUser\"; obtuse names like
these are less useful to human-written code than names like
\"User\".[¶](#section-a.2-6){.pilcrow}

Furthermore, even though \"PropertiesFooUser\" and \"PropertiesBarUser\"
would be essentially identical, they would not be interchangeable in
many statically typed programming languages. A code generator could
attempt to circumvent this by deduplicating identical definitions, but
then the user might be confused as to why the subtly distinct
\"PropertiesBazUser\", defined from a schema allowing a property named
\"userId\" (not \"user_id\"), was not
deduplicated.[¶](#section-a.2-7){.pilcrow}

Because there seem to be implementation and usability challenges
associated with non-root definitions, and because it would be easier to
later amend JTD to permit for non-root definitions than to later amend
JTD to prohibit them, this document does not permit non-root definitions
in JTD schemas.[¶](#section-a.2-8){.pilcrow}
:::
:::
:::
:::

::: {#comparison-with-cddl}
::: {#section-appendix.b .section}
## [Appendix B.](#section-appendix.b){.section-number .selfRef} [Comparison with CDDL](#name-comparison-with-cddl){.section-name .selfRef} {#name-comparison-with-cddl}

This appendix is not normative.[¶](#section-appendix.b-1){.pilcrow}

To aid the reader familiar with CDDL, this section illustrates how JTD
works by presenting JTD schemas and CDDL schemas that accept and reject
the same instances.[¶](#section-appendix.b-2){.pilcrow}

The JTD schema[¶](#section-appendix.b-3){.pilcrow}

::: {#section-appendix.b-4}
``` {.sourcecode .lang-json}
   {}
```

[¶](#section-appendix.b-4){.pilcrow}
:::

accepts the same instances as the CDDL
rule[¶](#section-appendix.b-5){.pilcrow}

::: {#section-appendix.b-6}
``` {.sourcecode .lang-cddl}
   root = any
```

[¶](#section-appendix.b-6){.pilcrow}
:::

The JTD schema[¶](#section-appendix.b-7){.pilcrow}

::: {#section-appendix.b-8}
``` {.sourcecode .lang-json}
   {
     "definitions": {
       "a": { "elements": { "ref": "b" }},
       "b": { "type": "float32" }
     },
     "elements": {
       "ref": "a"
     }
   }
```

[¶](#section-appendix.b-8){.pilcrow}
:::

accepts the same instances as the CDDL
rule[¶](#section-appendix.b-9){.pilcrow}

::: {#section-appendix.b-10}
``` {.sourcecode .lang-cddl}
   root = [* a]
   a = [* b]
   b = number
```

[¶](#section-appendix.b-10){.pilcrow}
:::

The JTD schema[¶](#section-appendix.b-11){.pilcrow}

::: {#section-appendix.b-12}
``` {.sourcecode .lang-json}
   { "enum": ["PENDING", "DONE", "CANCELED"]}
```

[¶](#section-appendix.b-12){.pilcrow}
:::

accepts the same instances as the CDDL
rule[¶](#section-appendix.b-13){.pilcrow}

::: {#section-appendix.b-14}
``` {.sourcecode .lang-cddl}
   root = "PENDING" / "DONE" / "CANCELED"
```

[¶](#section-appendix.b-14){.pilcrow}
:::

The JTD schema[¶](#section-appendix.b-15){.pilcrow}

::: {#section-appendix.b-16}
``` {.sourcecode .lang-json}
   {"type": "boolean"}
```

[¶](#section-appendix.b-16){.pilcrow}
:::

accepts the same instances as the CDDL
rule[¶](#section-appendix.b-17){.pilcrow}

::: {#section-appendix.b-18}
``` {.sourcecode .lang-cddl}
   root = bool
```

[¶](#section-appendix.b-18){.pilcrow}
:::

The JTD schemas:[¶](#section-appendix.b-19){.pilcrow}

::: {#section-appendix.b-20}
``` {.sourcecode .lang-json}
   {"type": "float32"}
```

[¶](#section-appendix.b-20){.pilcrow}
:::

and[¶](#section-appendix.b-21){.pilcrow}

::: {#section-appendix.b-22}
``` {.sourcecode .lang-json}
   {"type": "float64"}
```

[¶](#section-appendix.b-22){.pilcrow}
:::

both accept the same instances as the CDDL
rule[¶](#section-appendix.b-23){.pilcrow}

::: {#section-appendix.b-24}
``` {.sourcecode .lang-cddl}
   root = number
```

[¶](#section-appendix.b-24){.pilcrow}
:::

The JTD schema[¶](#section-appendix.b-25){.pilcrow}

::: {#section-appendix.b-26}
``` {.sourcecode .lang-json}
   {"type": "string"}
```

[¶](#section-appendix.b-26){.pilcrow}
:::

accepts the same instances as the CDDL
rule[¶](#section-appendix.b-27){.pilcrow}

::: {#section-appendix.b-28}
``` {.sourcecode .lang-cddl}
   root = tstr
```

[¶](#section-appendix.b-28){.pilcrow}
:::

The JTD schema[¶](#section-appendix.b-29){.pilcrow}

::: {#section-appendix.b-30}
``` {.sourcecode .lang-json}
   {"type": "timestamp"}
```

[¶](#section-appendix.b-30){.pilcrow}
:::

accepts the same instances as the CDDL
rule[¶](#section-appendix.b-31){.pilcrow}

::: {#section-appendix.b-32}
``` {.sourcecode .lang-cddl}
   root = tdate
```

[¶](#section-appendix.b-32){.pilcrow}
:::

The JTD schema[¶](#section-appendix.b-33){.pilcrow}

::: {#section-appendix.b-34}
``` {.sourcecode .lang-json}
   { "elements": { "type": "float32" }}
```

[¶](#section-appendix.b-34){.pilcrow}
:::

accepts the same instances as the CDDL
rule[¶](#section-appendix.b-35){.pilcrow}

::: {#section-appendix.b-36}
``` {.sourcecode .lang-cddl}
   root = [* number]
```

[¶](#section-appendix.b-36){.pilcrow}
:::

The JTD schema[¶](#section-appendix.b-37){.pilcrow}

::: {#section-appendix.b-38}
``` {.sourcecode .lang-json}
   {
     "properties": {
       "a": { "type": "boolean" },
       "b": { "type": "float32" }
     },
     "optionalProperties": {
       "c": { "type": "string" },
       "d": { "type": "timestamp" }
     }
   }
```

[¶](#section-appendix.b-38){.pilcrow}
:::

accepts the same instances as the CDDL
rule[¶](#section-appendix.b-39){.pilcrow}

::: {#section-appendix.b-40}
``` {.sourcecode .lang-cddl}
   root = { a: bool, b: number, ? c: tstr, ? d: tdate }
```

[¶](#section-appendix.b-40){.pilcrow}
:::

The JTD schema[¶](#section-appendix.b-41){.pilcrow}

::: {#section-appendix.b-42}
``` {.sourcecode .lang-json}
   { "values": { "type": "float32" }}
```

[¶](#section-appendix.b-42){.pilcrow}
:::

accepts the same instances as the CDDL
rule[¶](#section-appendix.b-43){.pilcrow}

::: {#section-appendix.b-44}
``` {.sourcecode .lang-cddl}
   root = { * tstr => number }
```

[¶](#section-appendix.b-44){.pilcrow}
:::

Finally, the JTD schema[¶](#section-appendix.b-45){.pilcrow}

::: {#section-appendix.b-46}
``` {.sourcecode .lang-json}
   {
     "discriminator": "a",
     "mapping": {
       "foo": {
         "properties": {
           "b": { "type": "float32" }
         }
       },
       "bar": {
         "properties": {
           "b": { "type": "string" }
         }
       }
     }
   }
```

[¶](#section-appendix.b-46){.pilcrow}
:::

accepts the same instances as the CDDL
rule[¶](#section-appendix.b-47){.pilcrow}

::: {#section-appendix.b-48}
``` {.sourcecode .lang-cddl}
   root = { a: "foo", b: number } / { a: "bar", b: tstr }
```

[¶](#section-appendix.b-48){.pilcrow}
:::
:::
:::

::: {#examples}
::: {#section-appendix.c .section}
## [Appendix C.](#section-appendix.c){.section-number .selfRef} [Example](#name-example){.section-name .selfRef} {#name-example}

This appendix is not normative.[¶](#section-appendix.c-1){.pilcrow}

As a demonstration of JTD, in [Figure 4](#JTD-reputation-object){.xref}
is a JTD schema closely equivalent to the plain-English definition
\"reputation-object\" described in [Section
6.2.2](https://www.rfc-editor.org/rfc/rfc7071#section-6.2.2){.relref} of
\[[RFC7071](#RFC7071){.xref}\]:[¶](#section-appendix.c-2){.pilcrow}

[]{#name-a-jtd-schema-describing-rep}

::: {#JTD-reputation-object}
::: {#section-appendix.c-3.1}
``` {.sourcecode .lang-json}
{
  "properties": {
    "application": { "type": "string" },
    "reputons": {
      "elements": {
        "additionalProperties": true,
        "properties": {
          "rater": { "type": "string" },
          "assertion": { "type": "string" },
          "rated": { "type": "string" },
          "rating": { "type": "float32" },
        },
        "optionalProperties": {
          "confidence": { "type": "float32" },
          "normal-rating": { "type": "float32" },
          "sample-size": { "type": "float64" },
          "generated": { "type": "float64" },
          "expires": { "type": "float64" }
        }
      }
    }
  }
}
```
:::

[Figure 4](#figure-4){.selfRef}: [A JTD Schema Describing
\"reputation-object\" from [Section
6.2.2](https://www.rfc-editor.org/rfc/rfc7071#section-6.2.2){.relref} of
\[[RFC7071](#RFC7071){.xref}\]](#name-a-jtd-schema-describing-rep){.selfRef}
:::

This schema does not enforce the requirement that \"sample-size\",
\"generated\", and \"expires\" be unbounded positive integers. It does
not express the limitation that \"rating\", \"confidence\", and
\"normal-rating\" should not have more than three decimal places of
precision.[¶](#section-appendix.c-4){.pilcrow}

The example in [Figure 4](#JTD-reputation-object){.xref} can be compared
against the equivalent example in [Appendix
H](https://www.rfc-editor.org/rfc/rfc8610#appendix-H){.relref} of
\[[RFC8610](#RFC8610){.xref}\].[¶](#section-appendix.c-5){.pilcrow}
:::
:::

::: {#acknowledgments}
::: {#section-appendix.d .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

[Carsten Bormann]{.contact-name} provided lots of useful guidance and
feedback on JTD\'s design and the structure of this
document.[¶](#section-appendix.d-1){.pilcrow}

[Evgeny Poberezkin]{.contact-name} suggested the addition of
\"nullable\" and thoroughly vetted this document for mistakes and
opportunities for simplification.[¶](#section-appendix.d-2){.pilcrow}

[Tim Bray]{.contact-name} suggested the current \"ref\" model and the
addition of \"enum\". [Anders Rundgren]{.contact-name} suggested
extending \"type\" to have more support for numerical types. [James
Manger]{.contact-name} suggested additional clarifying examples of how
integer types work. [Adrian Farrel]{.contact-name} suggested many
improvements to help make this document
clearer.[¶](#section-appendix.d-3){.pilcrow}

Members of the IETF JSON mailing list \-- in particular, [Pete
Cordell]{.contact-name}, [Phillip Hallam-Baker]{.contact-name}, [Nico
Williams]{.contact-name}, [John Cowan]{.contact-name}, [Rob
Sayre]{.contact-name}, and [Erik Wilde]{.contact-name} \-- provided lots
of useful feedback.[¶](#section-appendix.d-4){.pilcrow}

OpenAPI\'s \"discriminator\" object \[[OPENAPI](#OPENAPI){.xref}\]
inspired the \"discriminator\" form.
\[[JSON-SCHEMA](#I-D.handrews-json-schema){.xref}\] influenced various
parts of JTD\'s early design.[¶](#section-appendix.d-5){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.e .section}
## [Author\'s Address](#name-authors-address){.section-name .selfRef} {#name-authors-address}

::: {.left dir="auto"}
[Ulysse Carion]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Segment.io, Inc]{.org}
:::

::: {.left dir="auto"}
[100 California Street]{.street-address}
:::

::: {.left dir="auto"}
[San Francisco]{.locality}, [CA]{.region} [94111]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <ulysse@segment.com>
:::
:::
:::
