  RFC 9111           HTTP Caching      June 2022
  ------------------ ----------------- -----------
  Fielding, et al.   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9111](https://www.rfc-editor.org/rfc/rfc9111){.eref}

STD:
:   98

Obsoletes:
:   [7234](https://www.rfc-editor.org/rfc/rfc7234){.eref}

Category:
:   Standards Track

Published:
:   June 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    R. Fielding, [Ed.]{.editor}
    :::

    ::: org
    Adobe
    :::
    :::

    ::: author
    ::: author-name
    M. Nottingham, [Ed.]{.editor}
    :::

    ::: org
    Fastly
    :::
    :::

    ::: author
    ::: author-name
    J. Reschke, [Ed.]{.editor}
    :::

    ::: org
    greenbytes
    :::
    :::
:::

# RFC 9111 {#rfcnum}

# HTTP Caching {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

The Hypertext Transfer Protocol (HTTP) is a stateless application-level
protocol for distributed, collaborative, hypertext information systems.
This document defines HTTP caches and the associated header fields that
control cache behavior or indicate cacheable response
messages.[¶](#section-abstract-1){.pilcrow}

This document obsoletes RFC 7234.[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9111>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}

This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November 10,
2008. The person(s) controlling the copyright in some of this material
may not have granted the IETF Trust the right to allow modifications of
such material outside the IETF Standards Process. Without obtaining an
adequate license from the person(s) controlling the copyright in such
materials, this document may not be modified outside the IETF Standards
Process, and derivative works of it may not be created outside the IETF
Standards Process, except to format it for publication as an RFC or to
translate it into languages other than
English.[¶](#section-boilerplate.2-3){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Requirements
        Notation](#name-requirements-notation){.xref}
        :::

    -   ::: {#section-toc.1-1.1.2.2}
        [1.2](#section-1.2){.xref}.  [Syntax
        Notation](#name-syntax-notation){.xref}

        -   ::: {#section-toc.1-1.1.2.2.2.1}
            [1.2.1](#section-1.2.1){.xref}.  [Imported
            Rules](#name-imported-rules){.xref}
            :::

        -   ::: {#section-toc.1-1.1.2.2.2.2}
            [1.2.2](#section-1.2.2){.xref}.  [Delta
            Seconds](#name-delta-seconds){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Overview of Cache
    Operation](#name-overview-of-cache-operation){.xref}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Storing Responses in
    Caches](#name-storing-responses-in-caches){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Storing Header and Trailer
        Fields](#name-storing-header-and-trailer-){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Updating Stored Header
        Fields](#name-updating-stored-header-fiel){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.xref}.  [Storing Incomplete
        Responses](#name-storing-incomplete-response){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.xref}.  [Combining Partial
        Content](#name-combining-partial-content){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.5}
        [3.5](#section-3.5){.xref}.  [Storing Responses to Authenticated
        Requests](#name-storing-responses-to-authen){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Constructing Responses from
    Caches](#name-constructing-responses-from){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Calculating Cache Keys with the
        Vary Header Field](#name-calculating-cache-keys-with){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Freshness](#name-freshness){.xref}

        -   ::: {#section-toc.1-1.4.2.2.2.1}
            [4.2.1](#section-4.2.1){.xref}.  [Calculating Freshness
            Lifetime](#name-calculating-freshness-lifet){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.2}
            [4.2.2](#section-4.2.2){.xref}.  [Calculating Heuristic
            Freshness](#name-calculating-heuristic-fresh){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.3}
            [4.2.3](#section-4.2.3){.xref}.  [Calculating
            Age](#name-calculating-age){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.4}
            [4.2.4](#section-4.2.4){.xref}.  [Serving Stale
            Responses](#name-serving-stale-responses){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Validation](#name-validation){.xref}

        -   ::: {#section-toc.1-1.4.2.3.2.1}
            [4.3.1](#section-4.3.1){.xref}.  [Sending a Validation
            Request](#name-sending-a-validation-reques){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.2}
            [4.3.2](#section-4.3.2){.xref}.  [Handling a Received
            Validation
            Request](#name-handling-a-received-validat){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.3}
            [4.3.3](#section-4.3.3){.xref}.  [Handling a Validation
            Response](#name-handling-a-validation-respo){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.4}
            [4.3.4](#section-4.3.4){.xref}.  [Freshening Stored
            Responses upon
            Validation](#name-freshening-stored-responses){.xref}
            :::

        -   ::: {#section-toc.1-1.4.2.3.2.5}
            [4.3.5](#section-4.3.5){.xref}.  [Freshening Responses with
            HEAD](#name-freshening-responses-with-h){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Invalidating Stored
        Responses](#name-invalidating-stored-respons){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Field
    Definitions](#name-field-definitions){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Age](#name-age){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Cache-Control](#name-cache-control){.xref}

        -   ::: {#section-toc.1-1.5.2.2.2.1}
            [5.2.1](#section-5.2.1){.xref}.  [Request
            Directives](#name-request-directives){.xref}

            -   ::: {#section-toc.1-1.5.2.2.2.1.2.1}
                [5.2.1.1](#section-5.2.1.1){.xref}.  [max-age](#name-max-age){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.2.2.1.2.2}
                [5.2.1.2](#section-5.2.1.2){.xref}.  [max-stale](#name-max-stale){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.2.2.1.2.3}
                [5.2.1.3](#section-5.2.1.3){.xref}.  [min-fresh](#name-min-fresh){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.2.2.1.2.4}
                [5.2.1.4](#section-5.2.1.4){.xref}.  [no-cache](#name-no-cache){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.2.2.1.2.5}
                [5.2.1.5](#section-5.2.1.5){.xref}.  [no-store](#name-no-store){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.2.2.1.2.6}
                [5.2.1.6](#section-5.2.1.6){.xref}.  [no-transform](#name-no-transform){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.2.2.1.2.7}
                [5.2.1.7](#section-5.2.1.7){.xref}.  [only-if-cached](#name-only-if-cached){.xref}
                :::
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.2}
            [5.2.2](#section-5.2.2){.xref}.  [Response
            Directives](#name-response-directives){.xref}

            -   ::: {#section-toc.1-1.5.2.2.2.2.2.1}
                [5.2.2.1](#section-5.2.2.1){.xref}.  [max-age](#name-max-age-2){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.2.2.2.2.2}
                [5.2.2.2](#section-5.2.2.2){.xref}.  [must-revalidate](#name-must-revalidate){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.2.2.2.2.3}
                [5.2.2.3](#section-5.2.2.3){.xref}.  [must-understand](#name-must-understand){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.2.2.2.2.4}
                [5.2.2.4](#section-5.2.2.4){.xref}.  [no-cache](#name-no-cache-2){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.2.2.2.2.5}
                [5.2.2.5](#section-5.2.2.5){.xref}.  [no-store](#name-no-store-2){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.2.2.2.2.6}
                [5.2.2.6](#section-5.2.2.6){.xref}.  [no-transform](#name-no-transform-2){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.2.2.2.2.7}
                [5.2.2.7](#section-5.2.2.7){.xref}.  [private](#name-private){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.2.2.2.2.8}
                [5.2.2.8](#section-5.2.2.8){.xref}.  [proxy-revalidate](#name-proxy-revalidate){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.2.2.2.2.9}
                [5.2.2.9](#section-5.2.2.9){.xref}.  [public](#name-public){.xref}
                :::

            -   ::: {#section-toc.1-1.5.2.2.2.2.2.10}
                [5.2.2.10](#section-5.2.2.10){.xref}. [s-maxage](#name-s-maxage){.xref}
                :::
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.3}
            [5.2.3](#section-5.2.3){.xref}.  [Extension
            Directives](#name-extension-directives){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.4}
            [5.2.4](#section-5.2.4){.xref}.  [Cache Directive
            Registry](#name-cache-directive-registry){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Expires](#name-expires){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [Pragma](#name-pragma){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [Warning](#name-warning){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Relationship to Applications and Other
    Caches](#name-relationship-to-application){.xref}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Cache
        Poisoning](#name-cache-poisoning){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Timing
        Attacks](#name-timing-attacks){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Caching of Sensitive
        Information](#name-caching-of-sensitive-inform){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Field Name
        Registration](#name-field-name-registration){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Cache Directive
        Registration](#name-cache-directive-registratio){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.3}
        [8.3](#section-8.3){.xref}.  [Warn Code
        Registry](#name-warn-code-registry){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [Appendix A](#appendix-A){.xref}.  [Collected
    ABNF](#name-collected-abnf){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [Appendix B](#appendix-B){.xref}.  [Changes from RFC
    7234](#name-changes-from-rfc-7234){.xref}
    :::

-   ::: {#section-toc.1-1.12}
    [](#appendix-C){.xref}[Acknowledgements](#name-acknowledgements){.xref}
    :::

-   ::: {#section-toc.1-1.13}
    [](#appendix-D){.xref}[Index](#name-index){.xref}
    :::

-   ::: {#section-toc.1-1.14}
    [](#appendix-E){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#caching}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The Hypertext Transfer Protocol (HTTP) is a stateless application-level
request/response protocol that uses extensible semantics and
self-descriptive messages for flexible interaction with network-based
hypertext information systems. It is typically used for distributed
information systems, where the use of response caches can improve
performance. This document defines aspects of HTTP related to caching
and reusing response messages.[¶](#section-1-1){.pilcrow}

[]{#iref-cache-1 .iref}

An HTTP \"cache\" is a local store of response messages and the
subsystem that controls storage, retrieval, and deletion of messages in
it. A cache stores cacheable responses to reduce the response time and
network bandwidth consumption on future equivalent requests. Any client
or server [MAY]{.bcp14} use a cache, though not when acting as a tunnel
([Section
3.7](https://www.rfc-editor.org/rfc/rfc9110#section-3.7){.relref} of
\[[HTTP](#HTTP){.xref}\]).[¶](#section-1-2){.pilcrow}

[]{#iref-shared-cache-2 .iref} []{#iref-private-cache-3 .iref}

::: {#shared.and.private.caches}
A \"shared cache\" is a cache that stores responses for reuse by more
than one user; shared caches are usually (but not always) deployed as a
part of an intermediary. A \"private cache\", in contrast, is dedicated
to a single user; often, they are deployed as a component of a user
agent.[¶](#section-1-3){.pilcrow}
:::

The goal of HTTP caching is significantly improving performance by
reusing a prior response message to satisfy a current request. A cache
considers a stored response \"fresh\", as defined in [Section
4.2](#expiration.model){.xref}, if it can be reused without
\"validation\" (checking with the origin server to see if the cached
response remains valid for this request). A fresh response can therefore
reduce both latency and network overhead each time the cache reuses it.
When a cached response is not fresh, it might still be reusable if
validation can freshen it ([Section 4.3](#validation.model){.xref}) or
if the origin is unavailable ([Section
4.2.4](#serving.stale.responses){.xref}).[¶](#section-1-4){.pilcrow}

This document obsoletes [RFC 7234](#RFC7234){.xref}, with the changes
being summarized in [Appendix
B](#changes.from.rfc.7234){.xref}.[¶](#section-1-5){.pilcrow}

::: {#requirements.notation}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Requirements Notation](#name-requirements-notation){.section-name .selfRef} {#name-requirements-notation}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-1.1-1){.pilcrow}

[Section 2](https://www.rfc-editor.org/rfc/rfc9110#section-2){.relref}
of \[[HTTP](#HTTP){.xref}\] defines conformance criteria and contains
considerations regarding error handling.[¶](#section-1.1-2){.pilcrow}
:::
:::

::: {#notation}
::: {#section-1.2 .section}
### [1.2.](#section-1.2){.section-number .selfRef} [Syntax Notation](#name-syntax-notation){.section-name .selfRef} {#name-syntax-notation}

[]{#iref-grammar-digit-4 .iref}

This specification uses the Augmented Backus-Naur Form (ABNF) notation
of \[[RFC5234](#RFC5234){.xref}\], extended with the notation for
case-sensitivity in strings defined in
\[[RFC7405](#RFC7405){.xref}\].[¶](#section-1.2-1){.pilcrow}

It also uses a list extension, defined in [Section
5.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-5.6.1){.relref} of
\[[HTTP](#HTTP){.xref}\], that allows for compact definition of
comma-separated lists using a \"#\" operator (similar to how the \"\*\"
operator indicates repetition). [Appendix A](#collected.abnf){.xref}
shows the collected grammar with all list operators expanded to standard
ABNF notation.[¶](#section-1.2-2){.pilcrow}

::: {#abnf.imported}
::: {#section-1.2.1 .section}
#### [1.2.1.](#section-1.2.1){.section-number .selfRef} [Imported Rules](#name-imported-rules){.section-name .selfRef} {#name-imported-rules}

::: {#core.rules}
The following core rule is included by reference, as defined in
\[[RFC5234](#RFC5234){.xref}\], [Appendix
B.1](https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1){.relref}:
DIGIT (decimal 0-9).[¶](#section-1.2.1-1){.pilcrow}
:::

::: {#imported.rules}
\[[HTTP](#HTTP){.xref}\] defines the following
rules:[¶](#section-1.2.1-2){.pilcrow}
:::

::: {#section-1.2.1-3}
``` {.lang-abnf9110 .sourcecode}
  HTTP-date     = <HTTP-date, see [HTTP], Section 5.6.7>
  OWS           = <OWS, see [HTTP], Section 5.6.3>
  field-name    = <field-name, see [HTTP], Section 5.1>
  quoted-string = <quoted-string, see [HTTP], Section 5.6.4>
  token         = <token, see [HTTP], Section 5.6.2>
```

[¶](#section-1.2.1-3){.pilcrow}
:::
:::
:::

::: {#delta-seconds}
::: {#section-1.2.2 .section}
#### [1.2.2.](#section-1.2.2){.section-number .selfRef} [Delta Seconds](#name-delta-seconds){.section-name .selfRef} {#name-delta-seconds}

The delta-seconds rule specifies a non-negative integer, representing
time in seconds.[¶](#section-1.2.2-1){.pilcrow}

[]{#iref-grammar-delta-seconds-5 .iref}

::: {#section-1.2.2-2}
``` {.lang-abnf9110 .sourcecode}
  delta-seconds  = 1*DIGIT
```

[¶](#section-1.2.2-2){.pilcrow}
:::

A recipient parsing a delta-seconds value and converting it to binary
form ought to use an arithmetic type of at least 31 bits of non-negative
integer range. If a cache receives a delta-seconds value greater than
the greatest integer it can represent, or if any of its subsequent
calculations overflows, the cache [MUST]{.bcp14} consider the value to
be 2147483648 (2^31^) or the greatest positive integer it can
conveniently represent.[¶](#section-1.2.2-3){.pilcrow}

**Note:** The value 2147483648 is here for historical reasons,
represents infinity (over 68 years), and does not need to be stored in
binary form; an implementation could produce it as a string if any
overflow occurs, even if the calculations are performed with an
arithmetic type incapable of directly representing that number. What
matters here is that an overflow be detected and not treated as a
negative value in later calculations.[¶](#section-1.2.2-4.1){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#caching.overview}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Overview of Cache Operation](#name-overview-of-cache-operation){.section-name .selfRef} {#name-overview-of-cache-operation}

[]{#iref-cache-key-6 .iref}

Proper cache operation preserves the semantics of HTTP transfers while
reducing the transmission of information already held in the cache. See
[Section 3](https://www.rfc-editor.org/rfc/rfc9110#section-3){.relref}
of \[[HTTP](#HTTP){.xref}\] for the general terminology and core
concepts of HTTP.[¶](#section-2-1){.pilcrow}

Although caching is an entirely [OPTIONAL]{.bcp14} feature of HTTP, it
can be assumed that reusing a cached response is desirable and that such
reuse is the default behavior when no requirement or local configuration
prevents it. Therefore, HTTP cache requirements are focused on
preventing a cache from either storing a non-reusable response or
reusing a stored response inappropriately, rather than mandating that
caches always store and reuse particular
responses.[¶](#section-2-2){.pilcrow}

[]{#iref-cache-key-7 .iref}

The \"cache key\" is the information a cache uses to choose a response
and is composed from, at a minimum, the request method and target URI
used to retrieve the stored response; the method determines under which
circumstances that response can be used to satisfy a subsequent request.
However, many HTTP caches in common use today only cache GET responses
and therefore only use the URI as the cache
key.[¶](#section-2-3){.pilcrow}

A cache might store multiple responses for a request target that is
subject to content negotiation. Caches differentiate these responses by
incorporating some of the original request\'s header fields into the
cache key as well, using information in the Vary response header field,
as per [Section
4.1](#caching.negotiated.responses){.xref}.[¶](#section-2-4){.pilcrow}

Caches might incorporate additional material into the cache key. For
example, user agent caches might include the referring site\'s identity,
thereby \"double keying\" the cache to avoid some privacy risks (see
[Section 7.2](#security.timing){.xref}).[¶](#section-2-5){.pilcrow}

Most commonly, caches store the successful result of a retrieval
request: i.e., a 200 (OK) response to a GET request, which contains a
representation of the target resource ([Section
9.3.1](https://www.rfc-editor.org/rfc/rfc9110#section-9.3.1){.relref} of
\[[HTTP](#HTTP){.xref}\]). However, it is also possible to store
redirects, negative results (e.g., 404 (Not Found)), incomplete results
(e.g., 206 (Partial Content)), and responses to methods other than GET
if the method\'s definition allows such caching and defines something
suitable for use as a cache key.[¶](#section-2-6){.pilcrow}

A cache is \"disconnected\" when it cannot contact the origin server or
otherwise find a forward path for a request. A disconnected cache can
serve stale responses in some circumstances ([Section
4.2.4](#serving.stale.responses){.xref}).[¶](#section-2-7){.pilcrow}
:::
:::

::: {#response.cacheability}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Storing Responses in Caches](#name-storing-responses-in-caches){.section-name .selfRef} {#name-storing-responses-in-caches}

A cache [MUST NOT]{.bcp14} store a response to a request
unless:[¶](#section-3-1){.pilcrow}

-   ::: {#section-3-2.1}
    the request method is understood by the
    cache;[¶](#section-3-2.1.1){.pilcrow}
    :::

-   ::: {#section-3-2.2}
    the response status code is final (see [Section
    15](https://www.rfc-editor.org/rfc/rfc9110#section-15){.relref} of
    \[[HTTP](#HTTP){.xref}\]);[¶](#section-3-2.2.1){.pilcrow}
    :::

-   ::: {#section-3-2.3}
    if the response status code is 206 or 304, or the must-understand
    cache directive (see [Section
    5.2.2.3](#cache-response-directive.must-understand){.xref}) is
    present: the cache understands the response status
    code;[¶](#section-3-2.3.1){.pilcrow}
    :::

-   ::: {#section-3-2.4}
    the no-store cache directive is not present in the response (see
    [Section
    5.2.2.5](#cache-response-directive.no-store){.xref});[¶](#section-3-2.4.1){.pilcrow}
    :::

-   ::: {#section-3-2.5}
    if the cache is shared: the private response directive is either not
    present or allows a shared cache to store a modified response; see
    [Section
    5.2.2.7](#cache-response-directive.private){.xref});[¶](#section-3-2.5.1){.pilcrow}
    :::

-   ::: {#section-3-2.6}
    if the cache is shared: the Authorization header field is not
    present in the request (see [Section
    11.6.2](https://www.rfc-editor.org/rfc/rfc9110#section-11.6.2){.relref}
    of \[[HTTP](#HTTP){.xref}\]) or a response directive is present that
    explicitly allows shared caching (see [Section
    3.5](#caching.authenticated.responses){.xref});
    and[¶](#section-3-2.6.1){.pilcrow}
    :::

-   ::: {#section-3-2.7}
    the response contains at least one of the
    following:[¶](#section-3-2.7.1){.pilcrow}

    -   [a public response directive (see [Section
        5.2.2.9](#cache-response-directive.public){.xref});[¶](#section-3-2.7.2.1){.pilcrow}]{#section-3-2.7.2.1}
    -   [a private response directive, if the cache is not shared (see
        [Section
        5.2.2.7](#cache-response-directive.private){.xref});[¶](#section-3-2.7.2.2){.pilcrow}]{#section-3-2.7.2.2}
    -   [an [Expires](#field.expires){.xref} header field (see [Section
        5.3](#field.expires){.xref});[¶](#section-3-2.7.2.3){.pilcrow}]{#section-3-2.7.2.3}
    -   [a max-age response directive (see [Section
        5.2.2.1](#cache-response-directive.max-age){.xref});[¶](#section-3-2.7.2.4){.pilcrow}]{#section-3-2.7.2.4}
    -   [if the cache is shared: an s-maxage response directive (see
        [Section
        5.2.2.10](#cache-response-directive.s-maxage){.xref});[¶](#section-3-2.7.2.5){.pilcrow}]{#section-3-2.7.2.5}
    -   [a cache extension that allows it to be cached (see [Section
        5.2.3](#cache.control.extensions){.xref});
        or[¶](#section-3-2.7.2.6){.pilcrow}]{#section-3-2.7.2.6}
    -   [a status code that is defined as heuristically cacheable (see
        [Section
        4.2.2](#heuristic.freshness){.xref}).[¶](#section-3-2.7.2.7){.pilcrow}]{#section-3-2.7.2.7}
    :::

Note that a cache extension can override any of the requirements listed;
see [Section
5.2.3](#cache.control.extensions){.xref}.[¶](#section-3-3){.pilcrow}

In this context, a cache has \"understood\" a request method or a
response status code if it recognizes it and implements all specified
caching-related behavior.[¶](#section-3-4){.pilcrow}

Note that, in normal operation, some caches will not store a response
that has neither a cache validator nor an explicit expiration time, as
such responses are not usually useful to store. However, caches are not
prohibited from storing such responses.[¶](#section-3-5){.pilcrow}

::: {#storing.fields}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Storing Header and Trailer Fields](#name-storing-header-and-trailer-){.section-name .selfRef} {#name-storing-header-and-trailer-}

Caches [MUST]{.bcp14} include all received response header fields \--
including unrecognized ones \-- when storing a response; this assures
that new HTTP header fields can be successfully deployed. However, the
following exceptions are made:[¶](#section-3.1-1){.pilcrow}

-   [The Connection header field and fields whose names are listed in it
    are required by [Section
    7.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1){.relref}
    of \[[HTTP](#HTTP){.xref}\] to be removed before forwarding the
    message. This [MAY]{.bcp14} be implemented by doing so before
    storage.[¶](#section-3.1-2.1){.pilcrow}]{#section-3.1-2.1}
-   [Likewise, some fields\' semantics require them to be removed before
    forwarding the message, and this [MAY]{.bcp14} be implemented by
    doing so before storage; see [Section
    7.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1){.relref}
    of \[[HTTP](#HTTP){.xref}\] for some
    examples.[¶](#section-3.1-2.2){.pilcrow}]{#section-3.1-2.2}
-   [The no-cache ([Section
    5.2.2.4](#cache-response-directive.no-cache){.xref}) and private
    ([Section 5.2.2.7](#cache-response-directive.private){.xref}) cache
    directives can have arguments that prevent storage of header fields
    by all caches and shared caches,
    respectively.[¶](#section-3.1-2.3){.pilcrow}]{#section-3.1-2.3}
-   [Header fields that are specific to the proxy that a cache uses when
    forwarding a request [MUST NOT]{.bcp14} be stored, unless the cache
    incorporates the identity of the proxy into the cache key.
    Effectively, this is limited to Proxy-Authenticate ([Section
    11.7.1](https://www.rfc-editor.org/rfc/rfc9110#section-11.7.1){.relref}
    of \[[HTTP](#HTTP){.xref}\]), Proxy-Authentication-Info ([Section
    11.7.3](https://www.rfc-editor.org/rfc/rfc9110#section-11.7.3){.relref}
    of \[[HTTP](#HTTP){.xref}\]), and Proxy-Authorization ([Section
    11.7.2](https://www.rfc-editor.org/rfc/rfc9110#section-11.7.2){.relref}
    of
    \[[HTTP](#HTTP){.xref}\]).[¶](#section-3.1-2.4){.pilcrow}]{#section-3.1-2.4}

Caches [MAY]{.bcp14} either store trailer fields separate from header
fields or discard them. Caches [MUST NOT]{.bcp14} combine trailer fields
with header fields.[¶](#section-3.1-3){.pilcrow}
:::
:::

::: {#update}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Updating Stored Header Fields](#name-updating-stored-header-fiel){.section-name .selfRef} {#name-updating-stored-header-fiel}

Caches are required to update a stored response\'s header fields from
another (typically newer) response in several situations; for example,
see Sections [3.4](#combining.responses){.xref},
[4.3.4](#freshening.responses){.xref}, and
[4.3.5](#head.effects){.xref}.[¶](#section-3.2-1){.pilcrow}

When doing so, the cache [MUST]{.bcp14} add each header field in the
provided response to the stored response, replacing field values that
are already present, with the following
exceptions:[¶](#section-3.2-2){.pilcrow}

-   [Header fields excepted from storage in [Section
    3.1](#storing.fields){.xref},[¶](#section-3.2-3.1){.pilcrow}]{#section-3.2-3.1}
-   [Header fields that the cache\'s stored response depends upon, as
    described below,[¶](#section-3.2-3.2){.pilcrow}]{#section-3.2-3.2}
-   [Header fields that are automatically processed and removed by the
    recipient, as described below,
    and[¶](#section-3.2-3.3){.pilcrow}]{#section-3.2-3.3}
-   [The Content-Length header
    field.[¶](#section-3.2-3.4){.pilcrow}]{#section-3.2-3.4}

In some cases, caches (especially in user agents) store the results of
processing the received response, rather than the response itself, and
updating header fields that affect that processing can result in
inconsistent behavior and security issues. Caches in this situation
[MAY]{.bcp14} omit these header fields from updating stored responses on
an exceptional basis but [SHOULD]{.bcp14} limit such omission to those
fields necessary to assure integrity of the stored
response.[¶](#section-3.2-4){.pilcrow}

For example, a browser might decode the content coding of a response
while it is being received, creating a disconnect between the data it
has stored and the response\'s original metadata. Updating that stored
metadata with a different Content-Encoding header field would be
problematic. Likewise, a browser might store a post-parse HTML tree
rather than the content received in the response; updating the
Content-Type header field would not be workable in this case because any
assumptions about the format made in parsing would now be
invalid.[¶](#section-3.2-5){.pilcrow}

Furthermore, some fields are automatically processed and removed by the
HTTP implementation, such as the Content-Range header field.
Implementations [MAY]{.bcp14} automatically omit such header fields from
updates, even when the processing does not actually
occur.[¶](#section-3.2-6){.pilcrow}

Note that the Content-\* prefix is not a signal that a header field is
omitted from update; it is a convention for MIME header fields, not
HTTP.[¶](#section-3.2-7){.pilcrow}
:::
:::

::: {#incomplete.responses}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [Storing Incomplete Responses](#name-storing-incomplete-response){.section-name .selfRef} {#name-storing-incomplete-response}

If the request method is GET, the response status code is 200 (OK), and
the entire response header section has been received, a cache
[MAY]{.bcp14} store a response that is not complete ([Section
6.1](https://www.rfc-editor.org/rfc/rfc9110#section-6.1){.relref} of
\[[HTTP](#HTTP){.xref}\]) provided that the stored response is recorded
as being incomplete. Likewise, a 206 (Partial Content) response
[MAY]{.bcp14} be stored as if it were an incomplete 200 (OK) response.
However, a cache [MUST NOT]{.bcp14} store incomplete or partial-content
responses if it does not support the Range and Content-Range header
fields or if it does not understand the range units used in those
fields.[¶](#section-3.3-1){.pilcrow}

A cache [MAY]{.bcp14} complete a stored incomplete response by making a
subsequent range request ([Section
14.2](https://www.rfc-editor.org/rfc/rfc9110#section-14.2){.relref} of
\[[HTTP](#HTTP){.xref}\]) and combining the successful response with the
stored response, as defined in [Section
3.4](#combining.responses){.xref}. A cache [MUST NOT]{.bcp14} use an
incomplete response to answer requests unless the response has been made
complete, or the request is partial and specifies a range wholly within
the incomplete response. A cache [MUST NOT]{.bcp14} send a partial
response to a client without explicitly marking it using the 206
(Partial Content) status code.[¶](#section-3.3-2){.pilcrow}
:::
:::

::: {#combining.responses}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [Combining Partial Content](#name-combining-partial-content){.section-name .selfRef} {#name-combining-partial-content}

A response might transfer only a partial representation if the
connection closed prematurely or if the request used one or more Range
specifiers ([Section
14.2](https://www.rfc-editor.org/rfc/rfc9110#section-14.2){.relref} of
\[[HTTP](#HTTP){.xref}\]). After several such transfers, a cache might
have received several ranges of the same representation. A cache
[MAY]{.bcp14} combine these ranges into a single stored response, and
reuse that response to satisfy later requests, if they all share the
same strong validator and the cache complies with the client
requirements in [Section
15.3.7.3](https://www.rfc-editor.org/rfc/rfc9110#section-15.3.7.3){.relref}
of \[[HTTP](#HTTP){.xref}\].[¶](#section-3.4-1){.pilcrow}

When combining the new response with one or more stored responses, a
cache [MUST]{.bcp14} update the stored response header fields using the
header fields provided in the new response, as per [Section
3.2](#update){.xref}.[¶](#section-3.4-2){.pilcrow}
:::
:::

::: {#caching.authenticated.responses}
::: {#section-3.5 .section}
### [3.5.](#section-3.5){.section-number .selfRef} [Storing Responses to Authenticated Requests](#name-storing-responses-to-authen){.section-name .selfRef} {#name-storing-responses-to-authen}

A shared cache [MUST NOT]{.bcp14} use a cached response to a request
with an Authorization header field ([Section
11.6.2](https://www.rfc-editor.org/rfc/rfc9110#section-11.6.2){.relref}
of \[[HTTP](#HTTP){.xref}\]) to satisfy any subsequent request unless
the response contains a [Cache-Control](#field.cache-control){.xref}
field with a response directive ([Section
5.2.2](#cache-response-directive){.xref}) that allows it to be stored by
a shared cache, and the cache conforms to the requirements of that
directive for that response.[¶](#section-3.5-1){.pilcrow}

In this specification, the following response directives have such an
effect: must-revalidate ([Section
5.2.2.2](#cache-response-directive.must-revalidate){.xref}), public
([Section 5.2.2.9](#cache-response-directive.public){.xref}), and
s-maxage ([Section
5.2.2.10](#cache-response-directive.s-maxage){.xref}).[¶](#section-3.5-2){.pilcrow}
:::
:::
:::
:::

::: {#constructing.responses.from.caches}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Constructing Responses from Caches](#name-constructing-responses-from){.section-name .selfRef} {#name-constructing-responses-from}

When presented with a request, a cache [MUST NOT]{.bcp14} reuse a stored
response unless:[¶](#section-4-1){.pilcrow}

-   ::: {#section-4-2.1}
    the presented target URI ([Section
    7.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.1){.relref} of
    \[[HTTP](#HTTP){.xref}\]) and that of the stored response match,
    and[¶](#section-4-2.1.1){.pilcrow}
    :::

-   ::: {#section-4-2.2}
    the request method associated with the stored response allows it to
    be used for the presented request,
    and[¶](#section-4-2.2.1){.pilcrow}
    :::

-   ::: {#section-4-2.3}
    request header fields nominated by the stored response (if any)
    match those presented (see [Section
    4.1](#caching.negotiated.responses){.xref}),
    and[¶](#section-4-2.3.1){.pilcrow}
    :::

-   ::: {#section-4-2.4}
    the stored response does not contain the no-cache directive
    ([Section 5.2.2.4](#cache-response-directive.no-cache){.xref}),
    unless it is successfully validated ([Section
    4.3](#validation.model){.xref}), and[¶](#section-4-2.4.1){.pilcrow}
    :::

-   ::: {#section-4-2.5}
    the stored response is one of the
    following:[¶](#section-4-2.5.1){.pilcrow}

    -   [fresh (see [Section 4.2](#expiration.model){.xref}),
        or[¶](#section-4-2.5.2.1){.pilcrow}]{#section-4-2.5.2.1}
    -   [allowed to be served stale (see [Section
        4.2.4](#serving.stale.responses){.xref}),
        or[¶](#section-4-2.5.2.2){.pilcrow}]{#section-4-2.5.2.2}
    -   [successfully validated (see [Section
        4.3](#validation.model){.xref}).[¶](#section-4-2.5.2.3){.pilcrow}]{#section-4-2.5.2.3}
    :::

Note that a cache extension can override any of the requirements listed;
see [Section
5.2.3](#cache.control.extensions){.xref}.[¶](#section-4-3){.pilcrow}

When a stored response is used to satisfy a request without validation,
a cache [MUST]{.bcp14} generate an [Age](#field.age){.xref} header field
([Section 5.1](#field.age){.xref}), replacing any present in the
response with a value equal to the stored response\'s current_age; see
[Section 4.2.3](#age.calculations){.xref}.[¶](#section-4-4){.pilcrow}

A cache [MUST]{.bcp14} write through requests with methods that are
unsafe ([Section
9.2.1](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.1){.relref} of
\[[HTTP](#HTTP){.xref}\]) to the origin server; i.e., a cache is not
allowed to generate a reply to such a request before having forwarded
the request and having received a corresponding
response.[¶](#section-4-5){.pilcrow}

Also, note that unsafe requests might invalidate already-stored
responses; see [Section
4.4](#invalidation){.xref}.[¶](#section-4-6){.pilcrow}

[]{#iref-collapsed-requests-8 .iref}

A cache can use a response that is stored or storable to satisfy
multiple requests, provided that it is allowed to reuse that response
for the requests in question. This enables a cache to \"collapse
requests\" \-- or combine multiple incoming requests into a single
forward request upon a cache miss \-- thereby reducing load on the
origin server and network. Note, however, that if the cache cannot use
the returned response for some or all of the collapsed requests, it will
need to forward the requests in order to satisfy them, potentially
introducing additional latency.[¶](#section-4-7){.pilcrow}

When more than one suitable response is stored, a cache [MUST]{.bcp14}
use the most recent one (as determined by the Date header field). It can
also forward the request with \"Cache-Control: max-age=0\" or
\"Cache-Control: no-cache\" to disambiguate which response to
use.[¶](#section-4-8){.pilcrow}

A cache without a clock ([Section
5.6.7](https://www.rfc-editor.org/rfc/rfc9110#section-5.6.7){.relref} of
\[[HTTP](#HTTP){.xref}\]) [MUST]{.bcp14} revalidate stored responses
upon every use.[¶](#section-4-9){.pilcrow}

::: {#caching.negotiated.responses}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Calculating Cache Keys with the Vary Header Field](#name-calculating-cache-keys-with){.section-name .selfRef} {#name-calculating-cache-keys-with}

When a cache receives a request that can be satisfied by a stored
response and that stored response contains a Vary header field ([Section
12.5.5](https://www.rfc-editor.org/rfc/rfc9110#section-12.5.5){.relref}
of \[[HTTP](#HTTP){.xref}\]), the cache [MUST NOT]{.bcp14} use that
stored response without revalidation unless all the presented request
header fields nominated by that Vary field value match those fields in
the original request (i.e., the request that caused the cached response
to be stored).[¶](#section-4.1-1){.pilcrow}

The header fields from two requests are defined to match if and only if
those in the first request can be transformed to those in the second
request by applying any of the following:[¶](#section-4.1-2){.pilcrow}

-   [adding or removing whitespace, where allowed in the header field\'s
    syntax[¶](#section-4.1-3.1){.pilcrow}]{#section-4.1-3.1}
-   [combining multiple header field lines with the same field name (see
    [Section
    5.2](https://www.rfc-editor.org/rfc/rfc9110#section-5.2){.relref} of
    \[[HTTP](#HTTP){.xref}\])[¶](#section-4.1-3.2){.pilcrow}]{#section-4.1-3.2}
-   [normalizing both header field values in a way that is known to have
    identical semantics, according to the header field\'s specification
    (e.g., reordering field values when order is not significant;
    case-normalization, where values are defined to be
    case-insensitive)[¶](#section-4.1-3.3){.pilcrow}]{#section-4.1-3.3}

If (after any normalization that might take place) a header field is
absent from a request, it can only match another request if it is also
absent there.[¶](#section-4.1-4){.pilcrow}

A stored response with a Vary header field value containing a member
\"\*\" always fails to match.[¶](#section-4.1-5){.pilcrow}

If multiple stored responses match, the cache will need to choose one to
use. When a nominated request header field has a known mechanism for
ranking preference (e.g., qvalues on Accept and similar request header
fields), that mechanism [MAY]{.bcp14} be used to choose a preferred
response. If such a mechanism is not available, or leads to equally
preferred responses, the most recent response (as determined by the Date
header field) is chosen, as per [Section
4](#constructing.responses.from.caches){.xref}.[¶](#section-4.1-6){.pilcrow}

Some resources mistakenly omit the Vary header field from their default
response (i.e., the one sent when the request does not express any
preferences), with the effect of choosing it for subsequent requests to
that resource even when more preferable responses are available. When a
cache has multiple stored responses for a target URI and one or more
omits the Vary header field, the cache [SHOULD]{.bcp14} choose the most
recent (see [Section 4.2.3](#age.calculations){.xref}) stored response
with a valid Vary field value.[¶](#section-4.1-7){.pilcrow}

If no stored response matches, the cache cannot satisfy the presented
request. Typically, the request is forwarded to the origin server,
potentially with preconditions added to describe what responses the
cache has already stored ([Section
4.3](#validation.model){.xref}).[¶](#section-4.1-8){.pilcrow}
:::
:::

::: {#expiration.model}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Freshness](#name-freshness){.section-name .selfRef} {#name-freshness}

[]{#iref-fresh-9 .iref} []{#iref-stale-10 .iref}

A \"fresh\" response is one whose age has not yet exceeded its freshness
lifetime. Conversely, a \"stale\" response is one where it
has.[¶](#section-4.2-1){.pilcrow}

[]{#iref-freshness-lifetime-11 .iref}
[]{#iref-explicit-expiration-time-12 .iref}
[]{#iref-heuristic-expiration-time-1 .iref}

A response\'s \"freshness lifetime\" is the length of time between its
generation by the origin server and its expiration time. An \"explicit
expiration time\" is the time at which the origin server intends that a
stored response can no longer be used by a cache without further
validation, whereas a \"heuristic expiration time\" is assigned by a
cache when no explicit expiration time is
available.[¶](#section-4.2-2){.pilcrow}

[]{#iref-age-14 .iref}

A response\'s \"age\" is the time that has passed since it was generated
by, or successfully validated with, the origin
server.[¶](#section-4.2-3){.pilcrow}

When a response is fresh, it can be used to satisfy subsequent requests
without contacting the origin server, thereby improving
efficiency.[¶](#section-4.2-4){.pilcrow}

The primary mechanism for determining freshness is for an origin server
to provide an explicit expiration time in the future, using either the
[Expires](#field.expires){.xref} header field ([Section
5.3](#field.expires){.xref}) or the max-age response directive ([Section
5.2.2.1](#cache-response-directive.max-age){.xref}). Generally, origin
servers will assign future explicit expiration times to responses in the
belief that the representation is not likely to change in a semantically
significant way before the expiration time is
reached.[¶](#section-4.2-5){.pilcrow}

If an origin server wishes to force a cache to validate every request,
it can assign an explicit expiration time in the past to indicate that
the response is already stale. Compliant caches will normally validate a
stale cached response before reusing it for subsequent requests (see
[Section
4.2.4](#serving.stale.responses){.xref}).[¶](#section-4.2-6){.pilcrow}

Since origin servers do not always provide explicit expiration times,
caches are also allowed to use a heuristic to determine an expiration
time under certain circumstances (see [Section
4.2.2](#heuristic.freshness){.xref}).[¶](#section-4.2-7){.pilcrow}

The calculation to determine if a response is fresh
is:[¶](#section-4.2-8){.pilcrow}

::: {#section-4.2-9}
``` {.lang-pseudocode .sourcecode}
   response_is_fresh = (freshness_lifetime > current_age)
```

[¶](#section-4.2-9){.pilcrow}
:::

freshness_lifetime is defined in [Section
4.2.1](#calculating.freshness.lifetime){.xref}; current_age is defined
in [Section
4.2.3](#age.calculations){.xref}.[¶](#section-4.2-10){.pilcrow}

Clients can send the max-age or min-fresh request directives ([Section
5.2.1](#cache-request-directive){.xref}) to suggest limits on the
freshness calculations for the corresponding response. However, caches
are not required to honor them.[¶](#section-4.2-11){.pilcrow}

When calculating freshness, to avoid common problems in date
parsing:[¶](#section-4.2-12){.pilcrow}

-   [Although all date formats are specified to be case-sensitive, a
    cache recipient [SHOULD]{.bcp14} match the field value
    case-insensitively.[¶](#section-4.2-13.1){.pilcrow}]{#section-4.2-13.1}
-   [If a cache recipient\'s internal implementation of time has less
    resolution than the value of an HTTP-date, the recipient
    [MUST]{.bcp14} internally represent a parsed
    [Expires](#field.expires){.xref} date as the nearest time equal to
    or earlier than the received
    value.[¶](#section-4.2-13.2){.pilcrow}]{#section-4.2-13.2}
-   [A cache recipient [MUST NOT]{.bcp14} allow local time zones to
    influence the calculation or comparison of an age or expiration
    time.[¶](#section-4.2-13.3){.pilcrow}]{#section-4.2-13.3}
-   [A cache recipient [SHOULD]{.bcp14} consider a date with a zone
    abbreviation other than \"GMT\" to be invalid for calculating
    expiration.[¶](#section-4.2-13.4){.pilcrow}]{#section-4.2-13.4}

Note that freshness applies only to cache operation; it cannot be used
to force a user agent to refresh its display or reload a resource. See
[Section 6](#history.lists){.xref} for an explanation of the difference
between caches and history mechanisms.[¶](#section-4.2-14){.pilcrow}

::: {#calculating.freshness.lifetime}
::: {#section-4.2.1 .section}
#### [4.2.1.](#section-4.2.1){.section-number .selfRef} [Calculating Freshness Lifetime](#name-calculating-freshness-lifet){.section-name .selfRef} {#name-calculating-freshness-lifet}

A cache can calculate the freshness lifetime (denoted as
freshness_lifetime) of a response by evaluating the following rules and
using the first match:[¶](#section-4.2.1-1){.pilcrow}

-   [If the cache is shared and the s-maxage response directive
    ([Section 5.2.2.10](#cache-response-directive.s-maxage){.xref}) is
    present, use its value,
    or[¶](#section-4.2.1-2.1){.pilcrow}]{#section-4.2.1-2.1}
-   [If the max-age response directive ([Section
    5.2.2.1](#cache-response-directive.max-age){.xref}) is present, use
    its value, or[¶](#section-4.2.1-2.2){.pilcrow}]{#section-4.2.1-2.2}
-   [If the [Expires](#field.expires){.xref} response header field
    ([Section 5.3](#field.expires){.xref}) is present, use its value
    minus the value of the Date response header field (using the time
    the message was received if it is not present, as per [Section
    6.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-6.6.1){.relref}
    of \[[HTTP](#HTTP){.xref}\]),
    or[¶](#section-4.2.1-2.3){.pilcrow}]{#section-4.2.1-2.3}
-   [Otherwise, no explicit expiration time is present in the response.
    A heuristic freshness lifetime might be applicable; see [Section
    4.2.2](#heuristic.freshness){.xref}.[¶](#section-4.2.1-2.4){.pilcrow}]{#section-4.2.1-2.4}

Note that this calculation is intended to reduce clock skew by using the
clock information provided by the origin server whenever
possible.[¶](#section-4.2.1-3){.pilcrow}

When there is more than one value present for a given directive (e.g.,
two [Expires](#field.expires){.xref} header field lines or multiple
Cache-Control: max-age directives), either the first occurrence should
be used or the response should be considered stale. If directives
conflict (e.g., both max-age and no-cache are present), the most
restrictive directive should be honored. Caches are encouraged to
consider responses that have invalid freshness information (e.g., a
max-age directive with non-integer content) to be
stale.[¶](#section-4.2.1-4){.pilcrow}
:::
:::

::: {#heuristic.freshness}
::: {#section-4.2.2 .section}
#### [4.2.2.](#section-4.2.2){.section-number .selfRef} [Calculating Heuristic Freshness](#name-calculating-heuristic-fresh){.section-name .selfRef} {#name-calculating-heuristic-fresh}

[]{#iref-heuristically-cacheable-15 .iref}

Since origin servers do not always provide explicit expiration times, a
cache [MAY]{.bcp14} assign a heuristic expiration time when an explicit
time is not specified, employing algorithms that use other field values
(such as the Last-Modified time) to estimate a plausible expiration
time. This specification does not provide specific algorithms, but it
does impose worst-case constraints on their
results.[¶](#section-4.2.2-1){.pilcrow}

A cache [MUST NOT]{.bcp14} use heuristics to determine freshness when an
explicit expiration time is present in the stored response. Because of
the requirements in [Section 3](#response.cacheability){.xref},
heuristics can only be used on responses without explicit freshness
whose status codes are defined as \"heuristically cacheable\" (e.g., see
[Section
15.1](https://www.rfc-editor.org/rfc/rfc9110#section-15.1){.relref} of
\[[HTTP](#HTTP){.xref}\]) and on responses without explicit freshness
that have been marked as explicitly cacheable (e.g., with a public
response directive).[¶](#section-4.2.2-2){.pilcrow}

Note that in previous specifications, heuristically cacheable response
status codes were called \"cacheable by
default\".[¶](#section-4.2.2-3){.pilcrow}

If the response has a Last-Modified header field ([Section
8.8.2](https://www.rfc-editor.org/rfc/rfc9110#section-8.8.2){.relref} of
\[[HTTP](#HTTP){.xref}\]), caches are encouraged to use a heuristic
expiration value that is no more than some fraction of the interval
since that time. A typical setting of this fraction might be
10%.[¶](#section-4.2.2-4){.pilcrow}

**Note:** A previous version of the HTTP specification ([Section
13.9](https://www.rfc-editor.org/rfc/rfc2616#section-13.9){.relref} of
\[[RFC2616](#RFC2616){.xref}\]) prohibited caches from calculating
heuristic freshness for URIs with query components (i.e., those
containing \"?\"). In practice, this has not been widely implemented.
Therefore, origin servers are encouraged to send explicit directives
(e.g., Cache-Control: no-cache) if they wish to prevent
caching.[¶](#section-4.2.2-5.1){.pilcrow}
:::
:::

::: {#age.calculations}
::: {#section-4.2.3 .section}
#### [4.2.3.](#section-4.2.3){.section-number .selfRef} [Calculating Age](#name-calculating-age){.section-name .selfRef} {#name-calculating-age}

The [Age](#field.age){.xref} header field is used to convey an estimated
age of the response message when obtained from a cache. The Age field
value is the cache\'s estimate of the number of seconds since the origin
server generated or validated the response. The Age value is therefore
the sum of the time that the response has been resident in each of the
caches along the path from the origin server, plus the time it has been
in transit along network paths.[¶](#section-4.2.3-1){.pilcrow}

Age calculation uses the following data:[¶](#section-4.2.3-2){.pilcrow}

[]{.break}

\"age_value\"
:   The term \"age_value\" denotes the value of the
    [Age](#field.age){.xref} header field ([Section
    5.1](#field.age){.xref}), in a form appropriate for arithmetic
    operation; or 0, if not available.[¶](#section-4.2.3-3.2){.pilcrow}
:   

\"date_value\"
:   The term \"date_value\" denotes the value of the Date header field,
    in a form appropriate for arithmetic operations. See [Section
    6.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-6.6.1){.relref}
    of \[[HTTP](#HTTP){.xref}\] for the definition of the Date header
    field and for requirements regarding responses without
    it.[¶](#section-4.2.3-3.4){.pilcrow}
:   

\"now\"
:   The term \"now\" means the current value of this implementation\'s
    clock ([Section
    5.6.7](https://www.rfc-editor.org/rfc/rfc9110#section-5.6.7){.relref}
    of \[[HTTP](#HTTP){.xref}\]).[¶](#section-4.2.3-3.6){.pilcrow}
:   

\"request_time\"
:   The value of the clock at the time of the request that resulted in
    the stored response.[¶](#section-4.2.3-3.8){.pilcrow}
:   

\"response_time\"
:   The value of the clock at the time the response was
    received.[¶](#section-4.2.3-3.10){.pilcrow}
:   

A response\'s age can be calculated in two entirely independent
ways:[¶](#section-4.2.3-4){.pilcrow}

1.  [the \"apparent_age\": response_time minus date_value, if the
    implementation\'s clock is reasonably well synchronized to the
    origin server\'s clock. If the result is negative, the result is
    replaced by
    zero.[¶](#section-4.2.3-5.1){.pilcrow}]{#section-4.2.3-5.1}
2.  [the \"corrected_age_value\", if all of the caches along the
    response path implement HTTP/1.1 or greater. A cache [MUST]{.bcp14}
    interpret this value relative to the time the request was initiated,
    not the time that the response was
    received.[¶](#section-4.2.3-5.2){.pilcrow}]{#section-4.2.3-5.2}

::: {#section-4.2.3-6}
``` {.lang-pseudocode .sourcecode}
  apparent_age = max(0, response_time - date_value);

  response_delay = response_time - request_time;
  corrected_age_value = age_value + response_delay;
```

[¶](#section-4.2.3-6){.pilcrow}
:::

The corrected_age_value [MAY]{.bcp14} be used as the
corrected_initial_age. In circumstances where very old cache
implementations that might not correctly insert [Age](#field.age){.xref}
are present, corrected_initial_age can be calculated more conservatively
as[¶](#section-4.2.3-7){.pilcrow}

::: {#section-4.2.3-8}
``` {.lang-pseudocode .sourcecode}
  corrected_initial_age = max(apparent_age, corrected_age_value);
```

[¶](#section-4.2.3-8){.pilcrow}
:::

The current_age of a stored response can then be calculated by adding
the time (in seconds) since the stored response was last validated by
the origin server to the
corrected_initial_age.[¶](#section-4.2.3-9){.pilcrow}

::: {#section-4.2.3-10}
``` {.lang-pseudocode .sourcecode}
  resident_time = now - response_time;
  current_age = corrected_initial_age + resident_time;
```

[¶](#section-4.2.3-10){.pilcrow}
:::
:::
:::

::: {#serving.stale.responses}
::: {#section-4.2.4 .section}
#### [4.2.4.](#section-4.2.4){.section-number .selfRef} [Serving Stale Responses](#name-serving-stale-responses){.section-name .selfRef} {#name-serving-stale-responses}

A \"stale\" response is one that either has explicit expiry information
or is allowed to have heuristic expiry calculated, but is not fresh
according to the calculations in [Section
4.2](#expiration.model){.xref}.[¶](#section-4.2.4-1){.pilcrow}

A cache [MUST NOT]{.bcp14} generate a stale response if it is prohibited
by an explicit in-protocol directive (e.g., by a no-cache response
directive, a must-revalidate response directive, or an applicable
s-maxage or proxy-revalidate response directive; see [Section
5.2.2](#cache-response-directive){.xref}).[¶](#section-4.2.4-2){.pilcrow}

A cache [MUST NOT]{.bcp14} generate a stale response unless it is
disconnected or doing so is explicitly permitted by the client or origin
server (e.g., by the max-stale request directive in [Section
5.2.1](#cache-request-directive){.xref}, extension directives such as
those defined in \[[RFC5861](#RFC5861){.xref}\], or configuration in
accordance with an out-of-band contract).[¶](#section-4.2.4-3){.pilcrow}
:::
:::
:::
:::

::: {#validation.model}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Validation](#name-validation){.section-name .selfRef} {#name-validation}

When a cache has one or more stored responses for a requested URI, but
cannot serve any of them (e.g., because they are not fresh, or one
cannot be chosen; see [Section
4.1](#caching.negotiated.responses){.xref}), it can use the conditional
request mechanism ([Section
13](https://www.rfc-editor.org/rfc/rfc9110#section-13){.relref} of
\[[HTTP](#HTTP){.xref}\]) in the forwarded request to give the next
inbound server an opportunity to choose a valid stored response to use,
updating the stored metadata in the process, or to replace the stored
response(s) with a new response. This process is known as \"validating\"
or \"revalidating\" the stored response.[¶](#section-4.3-1){.pilcrow}

::: {#validation.sent}
::: {#section-4.3.1 .section}
#### [4.3.1.](#section-4.3.1){.section-number .selfRef} [Sending a Validation Request](#name-sending-a-validation-reques){.section-name .selfRef} {#name-sending-a-validation-reques}

[]{#iref-validator-16 .iref}

When generating a conditional request for validation, a cache either
starts with a request it is attempting to satisfy or \-- if it is
initiating the request independently \-- synthesizes a request using a
stored response by copying the method, target URI, and request header
fields identified by the Vary header field ([Section
4.1](#caching.negotiated.responses){.xref}).[¶](#section-4.3.1-1){.pilcrow}

It then updates that request with one or more precondition header
fields. These contain validator metadata sourced from a stored
response(s) that has the same URI. Typically, this will include only the
stored response(s) that has the same cache key, although a cache is
allowed to validate a response that it cannot choose with the request
header fields it is sending (see [Section
4.1](#caching.negotiated.responses){.xref}).[¶](#section-4.3.1-2){.pilcrow}

The precondition header fields are then compared by recipients to
determine whether any stored response is equivalent to a current
representation of the resource.[¶](#section-4.3.1-3){.pilcrow}

One such validator is the timestamp given in a Last-Modified header
field ([Section
8.8.2](https://www.rfc-editor.org/rfc/rfc9110#section-8.8.2){.relref} of
\[[HTTP](#HTTP){.xref}\]), which can be used in an If-Modified-Since
header field for response validation, or in an If-Unmodified-Since or
If-Range header field for representation selection (i.e., the client is
referring specifically to a previously obtained representation with that
timestamp).[¶](#section-4.3.1-4){.pilcrow}

Another validator is the entity tag given in an ETag field ([Section
8.8.3](https://www.rfc-editor.org/rfc/rfc9110#section-8.8.3){.relref} of
\[[HTTP](#HTTP){.xref}\]). One or more entity tags, indicating one or
more stored responses, can be used in an If-None-Match header field for
response validation, or in an If-Match or If-Range header field for
representation selection (i.e., the client is referring specifically to
one or more previously obtained representations with the listed entity
tags).[¶](#section-4.3.1-5){.pilcrow}

When generating a conditional request for validation, a
cache:[¶](#section-4.3.1-6){.pilcrow}

-   [[MUST]{.bcp14} send the relevant entity tags (using If-Match,
    If-None-Match, or If-Range) if the entity tags were provided in the
    stored response(s) being
    validated.[¶](#section-4.3.1-7.1){.pilcrow}]{#section-4.3.1-7.1}
-   [[SHOULD]{.bcp14} send the Last-Modified value (using
    If-Modified-Since) if the request is not for a subrange, a single
    stored response is being validated, and that response contains a
    Last-Modified
    value.[¶](#section-4.3.1-7.2){.pilcrow}]{#section-4.3.1-7.2}
-   [[MAY]{.bcp14} send the Last-Modified value (using
    If-Unmodified-Since or If-Range) if the request is for a subrange, a
    single stored response is being validated, and that response
    contains only a Last-Modified value (not an entity
    tag).[¶](#section-4.3.1-7.3){.pilcrow}]{#section-4.3.1-7.3}

In most cases, both validators are generated in cache validation
requests, even when entity tags are clearly superior, to allow old
intermediaries that do not understand entity tag preconditions to
respond appropriately.[¶](#section-4.3.1-8){.pilcrow}
:::
:::

::: {#validation.received}
::: {#section-4.3.2 .section}
#### [4.3.2.](#section-4.3.2){.section-number .selfRef} [Handling a Received Validation Request](#name-handling-a-received-validat){.section-name .selfRef} {#name-handling-a-received-validat}

Each client in the request chain may have its own cache, so it is common
for a cache at an intermediary to receive conditional requests from
other (outbound) caches. Likewise, some user agents make use of
conditional requests to limit data transfers to recently modified
representations or to complete the transfer of a partially retrieved
representation.[¶](#section-4.3.2-1){.pilcrow}

If a cache receives a request that can be satisfied by reusing a stored
200 (OK) or 206 (Partial Content) response, as per [Section
4](#constructing.responses.from.caches){.xref}, the cache
[SHOULD]{.bcp14} evaluate any applicable conditional header field
preconditions received in that request with respect to the corresponding
validators contained within the stored
response.[¶](#section-4.3.2-2){.pilcrow}

A cache [MUST NOT]{.bcp14} evaluate conditional header fields that only
apply to an origin server, occur in a request with semantics that cannot
be satisfied with a cached response, or occur in a request with a target
resource for which it has no stored responses; such preconditions are
likely intended for some other (inbound)
server.[¶](#section-4.3.2-3){.pilcrow}

The proper evaluation of conditional requests by a cache depends on the
received precondition header fields and their precedence. In summary,
the If-Match and If-Unmodified-Since conditional header fields are not
applicable to a cache, and If-None-Match takes precedence over
If-Modified-Since. See [Section
13.2.2](https://www.rfc-editor.org/rfc/rfc9110#section-13.2.2){.relref}
of \[[HTTP](#HTTP){.xref}\] for a complete specification of precondition
precedence.[¶](#section-4.3.2-4){.pilcrow}

A request containing an If-None-Match header field ([Section
13.1.2](https://www.rfc-editor.org/rfc/rfc9110#section-13.1.2){.relref}
of \[[HTTP](#HTTP){.xref}\]) indicates that the client wants to validate
one or more of its own stored responses in comparison to the stored
response chosen by the cache (as per [Section
4](#constructing.responses.from.caches){.xref}).[¶](#section-4.3.2-5){.pilcrow}

If an If-None-Match header field is not present, a request containing an
If-Modified-Since header field ([Section
13.1.3](https://www.rfc-editor.org/rfc/rfc9110#section-13.1.3){.relref}
of \[[HTTP](#HTTP){.xref}\]) indicates that the client wants to validate
one or more of its own stored responses by modification
date.[¶](#section-4.3.2-6){.pilcrow}

If a request contains an If-Modified-Since header field and the
Last-Modified header field is not present in a stored response, a cache
[SHOULD]{.bcp14} use the stored response\'s Date field value (or, if no
Date field is present, the time that the stored response was received)
to evaluate the conditional.[¶](#section-4.3.2-7){.pilcrow}

A cache that implements partial responses to range requests, as defined
in [Section
14.2](https://www.rfc-editor.org/rfc/rfc9110#section-14.2){.relref} of
\[[HTTP](#HTTP){.xref}\], also needs to evaluate a received If-Range
header field ([Section
13.1.5](https://www.rfc-editor.org/rfc/rfc9110#section-13.1.5){.relref}
of \[[HTTP](#HTTP){.xref}\]) with respect to the cache\'s chosen
response.[¶](#section-4.3.2-8){.pilcrow}

When a cache decides to forward a request to revalidate its own stored
responses for a request that contains an If-None-Match list of entity
tags, the cache [MAY]{.bcp14} combine the received list with a list of
entity tags from its own stored set of responses (fresh or stale) and
send the union of the two lists as a replacement If-None-Match header
field value in the forwarded request. If a stored response contains only
partial content, the cache [MUST NOT]{.bcp14} include its entity tag in
the union unless the request is for a range that would be fully
satisfied by that partial stored response. If the response to the
forwarded request is 304 (Not Modified) and has an ETag field value with
an entity tag that is not in the client\'s list, the cache
[MUST]{.bcp14} generate a 200 (OK) response for the client by reusing
its corresponding stored response, as updated by the 304 response
metadata ([Section
4.3.4](#freshening.responses){.xref}).[¶](#section-4.3.2-9){.pilcrow}
:::
:::

::: {#validation.response}
::: {#section-4.3.3 .section}
#### [4.3.3.](#section-4.3.3){.section-number .selfRef} [Handling a Validation Response](#name-handling-a-validation-respo){.section-name .selfRef} {#name-handling-a-validation-respo}

Cache handling of a response to a conditional request depends upon its
status code:[¶](#section-4.3.3-1){.pilcrow}

-   [A 304 (Not Modified) response status code indicates that the stored
    response can be updated and reused; see [Section
    4.3.4](#freshening.responses){.xref}.[¶](#section-4.3.3-2.1){.pilcrow}]{#section-4.3.3-2.1}
-   [A full response (i.e., one containing content) indicates that none
    of the stored responses nominated in the conditional request are
    suitable. Instead, the cache [MUST]{.bcp14} use the full response to
    satisfy the request. The cache [MAY]{.bcp14} store such a full
    response, subject to its constraints (see [Section
    3](#response.cacheability){.xref}).[¶](#section-4.3.3-2.2){.pilcrow}]{#section-4.3.3-2.2}
-   [However, if a cache receives a 5xx (Server Error) response while
    attempting to validate a response, it can either forward this
    response to the requesting client or act as if the server failed to
    respond. In the latter case, the cache can send a previously stored
    response, subject to its constraints on doing so (see [Section
    4.2.4](#serving.stale.responses){.xref}), or retry the validation
    request.[¶](#section-4.3.3-2.3){.pilcrow}]{#section-4.3.3-2.3}
:::
:::

::: {#freshening.responses}
::: {#section-4.3.4 .section}
#### [4.3.4.](#section-4.3.4){.section-number .selfRef} [Freshening Stored Responses upon Validation](#name-freshening-stored-responses){.section-name .selfRef} {#name-freshening-stored-responses}

When a cache receives a 304 (Not Modified) response, it needs to
identify stored responses that are suitable for updating with the new
information provided, and then do so.[¶](#section-4.3.4-1){.pilcrow}

The initial set of stored responses to update are those that could have
been chosen for that request \-- i.e., those that meet the requirements
in [Section 4](#constructing.responses.from.caches){.xref}, except the
last requirement to be fresh, able to be served stale, or just
validated.[¶](#section-4.3.4-2){.pilcrow}

Then, that initial set of stored responses is further filtered by the
first match of:[¶](#section-4.3.4-3){.pilcrow}

-   [If the new response contains one or more \"strong validators\" (see
    [Section
    8.8.1](https://www.rfc-editor.org/rfc/rfc9110#section-8.8.1){.relref}
    of \[[HTTP](#HTTP){.xref}\]), then each of those strong validators
    identifies a selected representation for update. All the stored
    responses in the initial set with one of those same strong
    validators are identified for update. If none of the initial set
    contains at least one of the same strong validators, then the cache
    [MUST NOT]{.bcp14} use the new response to update any stored
    responses.[¶](#section-4.3.4-4.1){.pilcrow}]{#section-4.3.4-4.1}
-   [If the new response contains no strong validators but does contain
    one or more \"weak validators\", and those validators correspond to
    one of the initial set\'s stored responses, then the most recent of
    those matching stored responses is identified for
    update.[¶](#section-4.3.4-4.2){.pilcrow}]{#section-4.3.4-4.2}
-   [If the new response does not include any form of validator (such as
    where a client generates an If-Modified-Since request from a source
    other than the Last-Modified response header field), and there is
    only one stored response in the initial set, and that stored
    response also lacks a validator, then that stored response is
    identified for
    update.[¶](#section-4.3.4-4.3){.pilcrow}]{#section-4.3.4-4.3}

For each stored response identified, the cache [MUST]{.bcp14} update its
header fields with the header fields provided in the 304 (Not Modified)
response, as per [Section
3.2](#update){.xref}.[¶](#section-4.3.4-5){.pilcrow}
:::
:::

::: {#head.effects}
::: {#section-4.3.5 .section}
#### [4.3.5.](#section-4.3.5){.section-number .selfRef} [Freshening Responses with HEAD](#name-freshening-responses-with-h){.section-name .selfRef} {#name-freshening-responses-with-h}

A response to the HEAD method is identical to what an equivalent request
made with a GET would have been, without sending the content. This
property of HEAD responses can be used to invalidate or update a cached
GET response if the more efficient conditional GET request mechanism is
not available (due to no validators being present in the stored
response) or if transmission of the content is not desired even if it
has changed.[¶](#section-4.3.5-1){.pilcrow}

When a cache makes an inbound HEAD request for a target URI and receives
a 200 (OK) response, the cache [SHOULD]{.bcp14} update or invalidate
each of its stored GET responses that could have been chosen for that
request (see [Section
4.1](#caching.negotiated.responses){.xref}).[¶](#section-4.3.5-2){.pilcrow}

For each of the stored responses that could have been chosen, if the
stored response and HEAD response have matching values for any received
validator fields (ETag and Last-Modified) and, if the HEAD response has
a Content-Length header field, the value of Content-Length matches that
of the stored response, the cache [SHOULD]{.bcp14} update the stored
response as described below; otherwise, the cache [SHOULD]{.bcp14}
consider the stored response to be stale.[¶](#section-4.3.5-3){.pilcrow}

If a cache updates a stored response with the metadata provided in a
HEAD response, the cache [MUST]{.bcp14} use the header fields provided
in the HEAD response to update the stored response (see [Section
3.2](#update){.xref}).[¶](#section-4.3.5-4){.pilcrow}
:::
:::
:::
:::

::: {#invalidation}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Invalidating Stored Responses](#name-invalidating-stored-respons){.section-name .selfRef} {#name-invalidating-stored-respons}

Because unsafe request methods ([Section
9.2.1](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.1){.relref} of
\[[HTTP](#HTTP){.xref}\]) such as PUT, POST, or DELETE have the
potential for changing state on the origin server, intervening caches
are required to invalidate stored responses to keep their contents up to
date.[¶](#section-4.4-1){.pilcrow}

A cache [MUST]{.bcp14} invalidate the target URI ([Section
7.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.1){.relref} of
\[[HTTP](#HTTP){.xref}\]) when it receives a non-error status code in
response to an unsafe request method (including methods whose safety is
unknown).[¶](#section-4.4-2){.pilcrow}

A cache [MAY]{.bcp14} invalidate other URIs when it receives a non-error
status code in response to an unsafe request method (including methods
whose safety is unknown). In particular, the URI(s) in the Location and
Content-Location response header fields (if present) are candidates for
invalidation; other URIs might be discovered through mechanisms not
specified in this document. However, a cache [MUST NOT]{.bcp14} trigger
an invalidation under these conditions if the origin ([Section
4.3.1](https://www.rfc-editor.org/rfc/rfc9110#section-4.3.1){.relref} of
\[[HTTP](#HTTP){.xref}\]) of the URI to be invalidated differs from that
of the target URI ([Section
7.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.1){.relref} of
\[[HTTP](#HTTP){.xref}\]). This helps prevent denial-of-service
attacks.[¶](#section-4.4-3){.pilcrow}

\"Invalidate\" means that the cache will either remove all stored
responses whose target URI matches the given URI or mark them as
\"invalid\" and in need of a mandatory validation before they can be
sent in response to a subsequent request.[¶](#section-4.4-4){.pilcrow}

A \"non-error response\" is one with a 2xx (Successful) or 3xx
(Redirection) status code.[¶](#section-4.4-5){.pilcrow}

Note that this does not guarantee that all appropriate responses are
invalidated globally; a state-changing request would only invalidate
responses in the caches it travels through.[¶](#section-4.4-6){.pilcrow}
:::
:::
:::
:::

::: {#header.field.definitions}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Field Definitions](#name-field-definitions){.section-name .selfRef} {#name-field-definitions}

This section defines the syntax and semantics of HTTP fields related to
caching.[¶](#section-5-1){.pilcrow}

::: {#field.age}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Age](#name-age){.section-name .selfRef} {#name-age}

[]{#iref-fields-age-17 .iref} []{#iref-header-fields-age-18 .iref}
[]{#iref-fields-age-19 .iref} []{#iref-header-fields-age-20 .iref}
[]{#iref-age-header-field-21 .iref}

The \"Age\" response header field conveys the sender\'s estimate of the
time since the response was generated or successfully validated at the
origin server. Age values are calculated as specified in [Section
4.2.3](#age.calculations){.xref}.[¶](#section-5.1-1){.pilcrow}

[]{#iref-grammar-age-22 .iref}

::: {#section-5.1-2}
``` {.lang-abnf9110 .sourcecode}
  Age = delta-seconds
```

[¶](#section-5.1-2){.pilcrow}
:::

The Age field value is a non-negative integer, representing time in
seconds (see [Section
1.2.2](#delta-seconds){.xref}).[¶](#section-5.1-3){.pilcrow}

Although it is defined as a singleton header field, a cache encountering
a message with a list-based Age field value [SHOULD]{.bcp14} use the
first member of the field value, discarding subsequent
ones.[¶](#section-5.1-4){.pilcrow}

If the field value (after discarding additional members, as per above)
is invalid (e.g., it contains something other than a non-negative
integer), a cache [SHOULD]{.bcp14} ignore the
field.[¶](#section-5.1-5){.pilcrow}

The presence of an Age header field implies that the response was not
generated or validated by the origin server for this request. However,
lack of an Age header field does not imply the origin was
contacted.[¶](#section-5.1-6){.pilcrow}
:::
:::

::: {#field.cache-control}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Cache-Control](#name-cache-control){.section-name .selfRef} {#name-cache-control}

[]{#iref-fields-cache-control-23 .iref}
[]{#iref-header-fields-cache-control .iref}
[]{#iref-cache-control-header-field- .iref}

The \"Cache-Control\" header field is used to list directives for caches
along the request/response chain. Cache directives are unidirectional,
in that the presence of a directive in a request does not imply that the
same directive is present or copied in the
response.[¶](#section-5.2-1){.pilcrow}

See [Section 5.2.3](#cache.control.extensions){.xref} for information
about how Cache-Control directives defined elsewhere are
handled.[¶](#section-5.2-2){.pilcrow}

A proxy, whether or not it implements a cache, [MUST]{.bcp14} pass cache
directives through in forwarded messages, regardless of their
significance to that application, since the directives might apply to
all recipients along the request/response chain. It is not possible to
target a directive to a specific cache.[¶](#section-5.2-3){.pilcrow}

Cache directives are identified by a token, to be compared
case-insensitively, and have an optional argument that can use both
token and quoted-string syntax. For the directives defined below that
define arguments, recipients ought to accept both forms, even if a
specific form is required for generation.[¶](#section-5.2-4){.pilcrow}

[]{#iref-grammar-cache-control-26 .iref}
[]{#iref-grammar-cache-directive-27 .iref}

::: {#section-5.2-5}
``` {.lang-abnf9110 .sourcecode}
  Cache-Control   = #cache-directive

  cache-directive = token [ "=" ( token / quoted-string ) ]
```

[¶](#section-5.2-5){.pilcrow}
:::

For the cache directives defined below, no argument is defined (nor
allowed) unless stated otherwise.[¶](#section-5.2-6){.pilcrow}

::: {#cache-request-directive}
::: {#section-5.2.1 .section}
#### [5.2.1.](#section-5.2.1){.section-number .selfRef} [Request Directives](#name-request-directives){.section-name .selfRef} {#name-request-directives}

This section defines cache request directives. They are advisory; caches
[MAY]{.bcp14} implement them, but are not required
to.[¶](#section-5.2.1-1){.pilcrow}

::: {#cache-request-directive.max-age}
::: {#section-5.2.1.1 .section}
##### [5.2.1.1.](#section-5.2.1.1){.section-number .selfRef} [max-age](#name-max-age){.section-name .selfRef} {#name-max-age}

[]{#iref-max-age-cache-directive-28 .iref}

Argument syntax:[¶](#section-5.2.1.1-1){.pilcrow}

-   [[delta-seconds](#delta-seconds){.xref} (see [Section
    1.2.2](#delta-seconds){.xref})[¶](#section-5.2.1.1-2.1){.pilcrow}]{#section-5.2.1.1-2.1}

The max-age request directive indicates that the client prefers a
response whose age is less than or equal to the specified number of
seconds. Unless the max-stale request directive is also present, the
client does not wish to receive a stale
response.[¶](#section-5.2.1.1-3){.pilcrow}

This directive uses the token form of the argument syntax: e.g.,
\'max-age=5\' not \'max-age=\"5\"\'. A sender [MUST NOT]{.bcp14}
generate the quoted-string form.[¶](#section-5.2.1.1-4){.pilcrow}
:::
:::

::: {#cache-request-directive.max-stale}
::: {#section-5.2.1.2 .section}
##### [5.2.1.2.](#section-5.2.1.2){.section-number .selfRef} [max-stale](#name-max-stale){.section-name .selfRef} {#name-max-stale}

[]{#iref-max-stale-cache-directive-2 .iref}

Argument syntax:[¶](#section-5.2.1.2-1){.pilcrow}

-   [[delta-seconds](#delta-seconds){.xref} (see [Section
    1.2.2](#delta-seconds){.xref})[¶](#section-5.2.1.2-2.1){.pilcrow}]{#section-5.2.1.2-2.1}

The max-stale request directive indicates that the client will accept a
response that has exceeded its freshness lifetime. If a value is
present, then the client is willing to accept a response that has
exceeded its freshness lifetime by no more than the specified number of
seconds. If no value is assigned to max-stale, then the client will
accept a stale response of any age.[¶](#section-5.2.1.2-3){.pilcrow}

This directive uses the token form of the argument syntax: e.g.,
\'max-stale=10\' not \'max-stale=\"10\"\'. A sender [MUST NOT]{.bcp14}
generate the quoted-string form.[¶](#section-5.2.1.2-4){.pilcrow}
:::
:::

::: {#cache-request-directive.min-fresh}
::: {#section-5.2.1.3 .section}
##### [5.2.1.3.](#section-5.2.1.3){.section-number .selfRef} [min-fresh](#name-min-fresh){.section-name .selfRef} {#name-min-fresh}

[]{#iref-min-fresh-cache-directive-3 .iref}

Argument syntax:[¶](#section-5.2.1.3-1){.pilcrow}

-   [[delta-seconds](#delta-seconds){.xref} (see [Section
    1.2.2](#delta-seconds){.xref})[¶](#section-5.2.1.3-2.1){.pilcrow}]{#section-5.2.1.3-2.1}

The min-fresh request directive indicates that the client prefers a
response whose freshness lifetime is no less than its current age plus
the specified time in seconds. That is, the client wants a response that
will still be fresh for at least the specified number of
seconds.[¶](#section-5.2.1.3-3){.pilcrow}

This directive uses the token form of the argument syntax: e.g.,
\'min-fresh=20\' not \'min-fresh=\"20\"\'. A sender [MUST NOT]{.bcp14}
generate the quoted-string form.[¶](#section-5.2.1.3-4){.pilcrow}
:::
:::

::: {#cache-request-directive.no-cache}
::: {#section-5.2.1.4 .section}
##### [5.2.1.4.](#section-5.2.1.4){.section-number .selfRef} [no-cache](#name-no-cache){.section-name .selfRef} {#name-no-cache}

[]{#iref-no-cache-cache-directive-31 .iref}

The no-cache request directive indicates that the client prefers a
stored response not be used to satisfy the request without successful
validation on the origin server.[¶](#section-5.2.1.4-1){.pilcrow}
:::
:::

::: {#cache-request-directive.no-store}
::: {#section-5.2.1.5 .section}
##### [5.2.1.5.](#section-5.2.1.5){.section-number .selfRef} [no-store](#name-no-store){.section-name .selfRef} {#name-no-store}

[]{#iref-no-store-cache-directive-32 .iref}

The no-store request directive indicates that a cache [MUST NOT]{.bcp14}
store any part of either this request or any response to it. This
directive applies to both private and shared caches. \"MUST NOT store\"
in this context means that the cache [MUST NOT]{.bcp14} intentionally
store the information in non-volatile storage and [MUST]{.bcp14} make a
best-effort attempt to remove the information from volatile storage as
promptly as possible after forwarding
it.[¶](#section-5.2.1.5-1){.pilcrow}

This directive is not a reliable or sufficient mechanism for ensuring
privacy. In particular, malicious or compromised caches might not
recognize or obey this directive, and communications networks might be
vulnerable to eavesdropping.[¶](#section-5.2.1.5-2){.pilcrow}

Note that if a request containing this directive is satisfied from a
cache, the no-store request directive does not apply to the already
stored response.[¶](#section-5.2.1.5-3){.pilcrow}
:::
:::

::: {#cache-request-directive.no-transform}
::: {#section-5.2.1.6 .section}
##### [5.2.1.6.](#section-5.2.1.6){.section-number .selfRef} [no-transform](#name-no-transform){.section-name .selfRef} {#name-no-transform}

[]{#iref-no-transform-cache-directiv .iref}

The no-transform request directive indicates that the client is asking
for intermediaries to avoid transforming the content, as defined in
[Section
7.7](https://www.rfc-editor.org/rfc/rfc9110#section-7.7){.relref} of
\[[HTTP](#HTTP){.xref}\].[¶](#section-5.2.1.6-1){.pilcrow}
:::
:::

::: {#cache-request-directive.only-if-cached}
::: {#section-5.2.1.7 .section}
##### [5.2.1.7.](#section-5.2.1.7){.section-number .selfRef} [only-if-cached](#name-only-if-cached){.section-name .selfRef} {#name-only-if-cached}

[]{#iref-only-if-cached-cache-direct .iref}

The only-if-cached request directive indicates that the client only
wishes to obtain a stored response. Caches that honor this request
directive [SHOULD]{.bcp14}, upon receiving it, respond with either a
stored response consistent with the other constraints of the request or
a 504 (Gateway Timeout) status code.[¶](#section-5.2.1.7-1){.pilcrow}
:::
:::
:::
:::

::: {#cache-response-directive}
::: {#section-5.2.2 .section}
#### [5.2.2.](#section-5.2.2){.section-number .selfRef} [Response Directives](#name-response-directives){.section-name .selfRef} {#name-response-directives}

This section defines cache response directives. A cache [MUST]{.bcp14}
obey the Cache-Control directives defined in this
section.[¶](#section-5.2.2-1){.pilcrow}

::: {#cache-response-directive.max-age}
::: {#section-5.2.2.1 .section}
##### [5.2.2.1.](#section-5.2.2.1){.section-number .selfRef} [max-age](#name-max-age-2){.section-name .selfRef} {#name-max-age-2}

[]{#iref-max-age-cache-directive-35 .iref}

Argument syntax:[¶](#section-5.2.2.1-1){.pilcrow}

-   [[delta-seconds](#delta-seconds){.xref} (see [Section
    1.2.2](#delta-seconds){.xref})[¶](#section-5.2.2.1-2.1){.pilcrow}]{#section-5.2.2.1-2.1}

The max-age response directive indicates that the response is to be
considered stale after its age is greater than the specified number of
seconds.[¶](#section-5.2.2.1-3){.pilcrow}

This directive uses the token form of the argument syntax: e.g.,
\'max-age=5\' not \'max-age=\"5\"\'. A sender [MUST NOT]{.bcp14}
generate the quoted-string form.[¶](#section-5.2.2.1-4){.pilcrow}
:::
:::

::: {#cache-response-directive.must-revalidate}
::: {#section-5.2.2.2 .section}
##### [5.2.2.2.](#section-5.2.2.2){.section-number .selfRef} [must-revalidate](#name-must-revalidate){.section-name .selfRef} {#name-must-revalidate}

[]{#iref-must-revalidate-cache-direc .iref}

The must-revalidate response directive indicates that once the response
has become stale, a cache [MUST NOT]{.bcp14} reuse that response to
satisfy another request until it has been successfully validated by the
origin, as defined by [Section
4.3](#validation.model){.xref}.[¶](#section-5.2.2.2-1){.pilcrow}

The must-revalidate directive is necessary to support reliable operation
for certain protocol features. In all circumstances, a cache [MUST
NOT]{.bcp14} ignore the must-revalidate directive; in particular, if a
cache is disconnected, the cache [MUST]{.bcp14} generate an error
response rather than reuse the stale response. The generated status code
[SHOULD]{.bcp14} be 504 (Gateway Timeout) unless another error status
code is more applicable.[¶](#section-5.2.2.2-2){.pilcrow}

The must-revalidate directive ought to be used by servers if and only if
failure to validate a request could cause incorrect operation, such as a
silently unexecuted financial
transaction.[¶](#section-5.2.2.2-3){.pilcrow}

The must-revalidate directive also permits a shared cache to reuse a
response to a request containing an Authorization header field ([Section
11.6.2](https://www.rfc-editor.org/rfc/rfc9110#section-11.6.2){.relref}
of \[[HTTP](#HTTP){.xref}\]), subject to the above requirement on
revalidation ([Section
3.5](#caching.authenticated.responses){.xref}).[¶](#section-5.2.2.2-4){.pilcrow}
:::
:::

::: {#cache-response-directive.must-understand}
::: {#section-5.2.2.3 .section}
##### [5.2.2.3.](#section-5.2.2.3){.section-number .selfRef} [must-understand](#name-must-understand){.section-name .selfRef} {#name-must-understand}

[]{#iref-must-understand-cache-direc .iref}

The must-understand response directive limits caching of the response to
a cache that understands and conforms to the requirements for that
response\'s status code.[¶](#section-5.2.2.3-1){.pilcrow}

A response that contains the must-understand directive [SHOULD]{.bcp14}
also contain the no-store directive. When a cache that implements the
must-understand directive receives a response that includes it, the
cache [SHOULD]{.bcp14} ignore the no-store directive if it understands
and implements the status code\'s caching
requirements.[¶](#section-5.2.2.3-2){.pilcrow}
:::
:::

::: {#cache-response-directive.no-cache}
::: {#section-5.2.2.4 .section}
##### [5.2.2.4.](#section-5.2.2.4){.section-number .selfRef} [no-cache](#name-no-cache-2){.section-name .selfRef} {#name-no-cache-2}

[]{#iref-no-cache-cache-directive-38 .iref}

Argument syntax:[¶](#section-5.2.2.4-1){.pilcrow}

-   [\#[field-name](#imported.rules){.xref}[¶](#section-5.2.2.4-2.1){.pilcrow}]{#section-5.2.2.4-2.1}

The no-cache response directive, in its unqualified form (without an
argument), indicates that the response [MUST NOT]{.bcp14} be used to
satisfy any other request without forwarding it for validation and
receiving a successful response; see [Section
4.3](#validation.model){.xref}.[¶](#section-5.2.2.4-3){.pilcrow}

This allows an origin server to prevent a cache from using the response
to satisfy a request without contacting it, even by caches that have
been configured to send stale
responses.[¶](#section-5.2.2.4-4){.pilcrow}

The qualified form of the no-cache response directive, with an argument
that lists one or more field names, indicates that a cache [MAY]{.bcp14}
use the response to satisfy a subsequent request, subject to any other
restrictions on caching, if the listed header fields are excluded from
the subsequent response or the subsequent response has been successfully
revalidated with the origin server (updating or removing those fields).
This allows an origin server to prevent the reuse of certain header
fields in a response, while still allowing caching of the rest of the
response.[¶](#section-5.2.2.4-5){.pilcrow}

The field names given are not limited to the set of header fields
defined by this specification. Field names are
case-insensitive.[¶](#section-5.2.2.4-6){.pilcrow}

This directive uses the quoted-string form of the argument syntax. A
sender [SHOULD NOT]{.bcp14} generate the token form (even if quoting
appears not to be needed for single-entry
lists).[¶](#section-5.2.2.4-7){.pilcrow}

**Note:** The qualified form of the directive is often handled by caches
as if an unqualified no-cache directive was received; that is, the
special handling for the qualified form is not widely
implemented.[¶](#section-5.2.2.4-8.1){.pilcrow}
:::
:::

::: {#cache-response-directive.no-store}
::: {#section-5.2.2.5 .section}
##### [5.2.2.5.](#section-5.2.2.5){.section-number .selfRef} [no-store](#name-no-store-2){.section-name .selfRef} {#name-no-store-2}

[]{#iref-no-store-cache-directive-39 .iref}

The no-store response directive indicates that a cache [MUST
NOT]{.bcp14} store any part of either the immediate request or the
response and [MUST NOT]{.bcp14} use the response to satisfy any other
request.[¶](#section-5.2.2.5-1){.pilcrow}

This directive applies to both private and shared caches. \"MUST NOT
store\" in this context means that the cache [MUST NOT]{.bcp14}
intentionally store the information in non-volatile storage and
[MUST]{.bcp14} make a best-effort attempt to remove the information from
volatile storage as promptly as possible after forwarding
it.[¶](#section-5.2.2.5-2){.pilcrow}

This directive is not a reliable or sufficient mechanism for ensuring
privacy. In particular, malicious or compromised caches might not
recognize or obey this directive, and communications networks might be
vulnerable to eavesdropping.[¶](#section-5.2.2.5-3){.pilcrow}

Note that the must-understand cache directive overrides no-store in
certain circumstances; see [Section
5.2.2.3](#cache-response-directive.must-understand){.xref}.[¶](#section-5.2.2.5-4){.pilcrow}
:::
:::

::: {#cache-response-directive.no-transform}
::: {#section-5.2.2.6 .section}
##### [5.2.2.6.](#section-5.2.2.6){.section-number .selfRef} [no-transform](#name-no-transform-2){.section-name .selfRef} {#name-no-transform-2}

[]{#iref-no-transform-cache-directive .iref}

The no-transform response directive indicates that an intermediary
(regardless of whether it implements a cache) [MUST NOT]{.bcp14}
transform the content, as defined in [Section
7.7](https://www.rfc-editor.org/rfc/rfc9110#section-7.7){.relref} of
\[[HTTP](#HTTP){.xref}\].[¶](#section-5.2.2.6-1){.pilcrow}
:::
:::

::: {#cache-response-directive.private}
::: {#section-5.2.2.7 .section}
##### [5.2.2.7.](#section-5.2.2.7){.section-number .selfRef} [private](#name-private){.section-name .selfRef} {#name-private}

[]{#iref-private-cache-directive-41 .iref}

Argument syntax:[¶](#section-5.2.2.7-1){.pilcrow}

-   [\#[field-name](#imported.rules){.xref}[¶](#section-5.2.2.7-2.1){.pilcrow}]{#section-5.2.2.7-2.1}

The unqualified private response directive indicates that a shared cache
[MUST NOT]{.bcp14} store the response (i.e., the response is intended
for a single user). It also indicates that a private cache [MAY]{.bcp14}
store the response, subject to the constraints defined in [Section
3](#response.cacheability){.xref}, even if the response would not
otherwise be heuristically cacheable by a private
cache.[¶](#section-5.2.2.7-3){.pilcrow}

If a qualified private response directive is present, with an argument
that lists one or more field names, then only the listed header fields
are limited to a single user: a shared cache [MUST NOT]{.bcp14} store
the listed header fields if they are present in the original response
but [MAY]{.bcp14} store the remainder of the response message without
those header fields, subject the constraints defined in [Section
3](#response.cacheability){.xref}.[¶](#section-5.2.2.7-4){.pilcrow}

The field names given are not limited to the set of header fields
defined by this specification. Field names are
case-insensitive.[¶](#section-5.2.2.7-5){.pilcrow}

This directive uses the quoted-string form of the argument syntax. A
sender [SHOULD NOT]{.bcp14} generate the token form (even if quoting
appears not to be needed for single-entry
lists).[¶](#section-5.2.2.7-6){.pilcrow}

**Note:** This usage of the word \"private\" only controls where the
response can be stored; it cannot ensure the privacy of the message
content. Also, the qualified form of the directive is often handled by
caches as if an unqualified private directive was received; that is, the
special handling for the qualified form is not widely
implemented.[¶](#section-5.2.2.7-7.1){.pilcrow}
:::
:::

::: {#cache-response-directive.proxy-revalidate}
::: {#section-5.2.2.8 .section}
##### [5.2.2.8.](#section-5.2.2.8){.section-number .selfRef} [proxy-revalidate](#name-proxy-revalidate){.section-name .selfRef} {#name-proxy-revalidate}

[]{#iref-proxy-revalidate-cache-dire .iref}

The proxy-revalidate response directive indicates that once the response
has become stale, a shared cache [MUST NOT]{.bcp14} reuse that response
to satisfy another request until it has been successfully validated by
the origin, as defined by [Section 4.3](#validation.model){.xref}. This
is analogous to must-revalidate ([Section
5.2.2.2](#cache-response-directive.must-revalidate){.xref}), except that
proxy-revalidate does not apply to private
caches.[¶](#section-5.2.2.8-1){.pilcrow}

Note that proxy-revalidate on its own does not imply that a response is
cacheable. For example, it might be combined with the public directive
([Section 5.2.2.9](#cache-response-directive.public){.xref}), allowing
the response to be cached while requiring only a shared cache to
revalidate when stale.[¶](#section-5.2.2.8-2){.pilcrow}
:::
:::

::: {#cache-response-directive.public}
::: {#section-5.2.2.9 .section}
##### [5.2.2.9.](#section-5.2.2.9){.section-number .selfRef} [public](#name-public){.section-name .selfRef} {#name-public}

[]{#iref-public-cache-directive-43 .iref}

The public response directive indicates that a cache [MAY]{.bcp14} store
the response even if it would otherwise be prohibited, subject to the
constraints defined in [Section 3](#response.cacheability){.xref}. In
other words, public explicitly marks the response as cacheable. For
example, public permits a shared cache to reuse a response to a request
containing an Authorization header field ([Section
3.5](#caching.authenticated.responses){.xref}).[¶](#section-5.2.2.9-1){.pilcrow}

Note that it is unnecessary to add the public directive to a response
that is already cacheable according to [Section
3](#response.cacheability){.xref}.[¶](#section-5.2.2.9-2){.pilcrow}

If a response with the public directive has no explicit freshness
information, it is heuristically cacheable ([Section
4.2.2](#heuristic.freshness){.xref}).[¶](#section-5.2.2.9-3){.pilcrow}
:::
:::

::: {#cache-response-directive.s-maxage}
::: {#section-5.2.2.10 .section}
##### [5.2.2.10.](#section-5.2.2.10){.section-number .selfRef} [s-maxage](#name-s-maxage){.section-name .selfRef} {#name-s-maxage}

[]{#iref-s-maxage-cache-directive-44 .iref}

Argument syntax:[¶](#section-5.2.2.10-1){.pilcrow}

-   [[delta-seconds](#delta-seconds){.xref} (see [Section
    1.2.2](#delta-seconds){.xref})[¶](#section-5.2.2.10-2.1){.pilcrow}]{#section-5.2.2.10-2.1}

The s-maxage response directive indicates that, for a shared cache, the
maximum age specified by this directive overrides the maximum age
specified by either the max-age directive or the
[Expires](#field.expires){.xref} header
field.[¶](#section-5.2.2.10-3){.pilcrow}

The s-maxage directive incorporates the semantics of the
proxy‑revalidate response directive ([Section
5.2.2.8](#cache-response-directive.proxy-revalidate){.xref}) for a
shared cache. A shared cache [MUST NOT]{.bcp14} reuse a stale response
with s-maxage to satisfy another request until it has been successfully
validated by the origin, as defined by [Section
4.3](#validation.model){.xref}. This directive also permits a shared
cache to reuse a response to a request containing an Authorization
header field, subject to the above requirements on maximum age and
revalidation ([Section
3.5](#caching.authenticated.responses){.xref}).[¶](#section-5.2.2.10-4){.pilcrow}

This directive uses the token form of the argument syntax: e.g.,
\'s-maxage=10\' not \'s-maxage=\"10\"\'. A sender [MUST NOT]{.bcp14}
generate the quoted-string form.[¶](#section-5.2.2.10-5){.pilcrow}
:::
:::
:::
:::

::: {#cache.control.extensions}
::: {#section-5.2.3 .section}
#### [5.2.3.](#section-5.2.3){.section-number .selfRef} [Extension Directives](#name-extension-directives){.section-name .selfRef} {#name-extension-directives}

The Cache-Control header field can be extended through the use of one or
more extension cache directives. A cache [MUST]{.bcp14} ignore
unrecognized cache directives.[¶](#section-5.2.3-1){.pilcrow}

Informational extensions (those that do not require a change in cache
behavior) can be added without changing the semantics of other
directives.[¶](#section-5.2.3-2){.pilcrow}

Behavioral extensions are designed to work by acting as modifiers to the
existing base of cache directives. Both the new directive and the old
directive are supplied, such that applications that do not understand
the new directive will default to the behavior specified by the old
directive, and those that understand the new directive will recognize it
as modifying the requirements associated with the old directive. In this
way, extensions to the existing cache directives can be made without
breaking deployed caches.[¶](#section-5.2.3-3){.pilcrow}

For example, consider a hypothetical new response directive called
\"community\" that acts as a modifier to the private directive: in
addition to private caches, only a cache that is shared by members of
the named community is allowed to cache the response. An origin server
wishing to allow the UCI community to use an otherwise private response
in their shared cache(s) could do so by
including[¶](#section-5.2.3-4){.pilcrow}

::: {#section-5.2.3-5}
``` {.lang-http-message .sourcecode}
Cache-Control: private, community="UCI"
```

[¶](#section-5.2.3-5){.pilcrow}
:::

A cache that recognizes such a community cache directive could broaden
its behavior in accordance with that extension. A cache that does not
recognize the community cache directive would ignore it and adhere to
the private directive.[¶](#section-5.2.3-6){.pilcrow}

New extension directives ought to consider
defining:[¶](#section-5.2.3-7){.pilcrow}

-   [What it means for a directive to be specified multiple
    times,[¶](#section-5.2.3-8.1){.pilcrow}]{#section-5.2.3-8.1}
-   [When the directive does not take an argument, what it means when an
    argument is
    present,[¶](#section-5.2.3-8.2){.pilcrow}]{#section-5.2.3-8.2}
-   [When the directive requires an argument, what it means when it is
    missing, and[¶](#section-5.2.3-8.3){.pilcrow}]{#section-5.2.3-8.3}
-   [Whether the directive is specific to requests, specific to
    responses, or able to be used in
    either.[¶](#section-5.2.3-8.4){.pilcrow}]{#section-5.2.3-8.4}
:::
:::

::: {#cache.directive.registry}
::: {#section-5.2.4 .section}
#### [5.2.4.](#section-5.2.4){.section-number .selfRef} [Cache Directive Registry](#name-cache-directive-registry){.section-name .selfRef} {#name-cache-directive-registry}

The \"Hypertext Transfer Protocol (HTTP) Cache Directive Registry\"
defines the namespace for the cache directives. It has been created and
is now maintained at
\<<https://www.iana.org/assignments/http-cache-directives>\>.[¶](#section-5.2.4-1){.pilcrow}

A registration [MUST]{.bcp14} include the following
fields:[¶](#section-5.2.4-2){.pilcrow}

-   [Cache Directive
    Name[¶](#section-5.2.4-3.1){.pilcrow}]{#section-5.2.4-3.1}
-   [Pointer to specification
    text[¶](#section-5.2.4-3.2){.pilcrow}]{#section-5.2.4-3.2}

Values to be added to this namespace require IETF Review (see
\[[RFC8126](#RFC8126){.xref}\], [Section
4.8](https://www.rfc-editor.org/rfc/rfc8126#section-4.8){.relref}).[¶](#section-5.2.4-4){.pilcrow}
:::
:::
:::
:::

::: {#field.expires}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Expires](#name-expires){.section-name .selfRef} {#name-expires}

[]{#iref-fields-expires-45 .iref} []{#iref-header-fields-expires-46
.iref} []{#iref-fields-expires-47 .iref}
[]{#iref-header-fields-expires-48 .iref}
[]{#iref-expires-header-field-49 .iref}

The \"Expires\" response header field gives the date/time after which
the response is considered stale. See [Section
4.2](#expiration.model){.xref} for further discussion of the freshness
model.[¶](#section-5.3-1){.pilcrow}

The presence of an Expires header field does not imply that the original
resource will change or cease to exist at, before, or after that
time.[¶](#section-5.3-2){.pilcrow}

The Expires field value is an HTTP-date timestamp, as defined in
[Section
5.6.7](https://www.rfc-editor.org/rfc/rfc9110#section-5.6.7){.relref} of
\[[HTTP](#HTTP){.xref}\]. See also [Section
4.2](#expiration.model){.xref} for parsing requirements specific to
caches.[¶](#section-5.3-3){.pilcrow}

[]{#iref-grammar-expires-50 .iref}

::: {#section-5.3-4}
``` {.lang-abnf9110 .sourcecode}
  Expires = HTTP-date
```

[¶](#section-5.3-4){.pilcrow}
:::

For example[¶](#section-5.3-5){.pilcrow}

::: {#section-5.3-6}
``` {.lang-http-message .sourcecode}
Expires: Thu, 01 Dec 1994 16:00:00 GMT
```

[¶](#section-5.3-6){.pilcrow}
:::

A cache recipient [MUST]{.bcp14} interpret invalid date formats,
especially the value \"0\", as representing a time in the past (i.e.,
\"already expired\").[¶](#section-5.3-7){.pilcrow}

If a response includes a [Cache-Control](#field.cache-control){.xref}
header field with the max-age directive ([Section
5.2.2.1](#cache-response-directive.max-age){.xref}), a recipient
[MUST]{.bcp14} ignore the Expires header field. Likewise, if a response
includes the s-maxage directive ([Section
5.2.2.10](#cache-response-directive.s-maxage){.xref}), a shared cache
recipient [MUST]{.bcp14} ignore the Expires header field. In both these
cases, the value in Expires is only intended for recipients that have
not yet implemented the Cache-Control header
field.[¶](#section-5.3-8){.pilcrow}

An origin server without a clock ([Section
5.6.7](https://www.rfc-editor.org/rfc/rfc9110#section-5.6.7){.relref} of
\[[HTTP](#HTTP){.xref}\]) [MUST NOT]{.bcp14} generate an Expires header
field unless its value represents a fixed time in the past (always
expired) or its value has been associated with the resource by a system
with a clock.[¶](#section-5.3-9){.pilcrow}

Historically, HTTP required the Expires field value to be no more than a
year in the future. While longer freshness lifetimes are no longer
prohibited, extremely large values have been demonstrated to cause
problems (e.g., clock overflows due to use of 32-bit integers for time
values), and many caches will evict a response far sooner than
that.[¶](#section-5.3-10){.pilcrow}
:::
:::

::: {#field.pragma}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [Pragma](#name-pragma){.section-name .selfRef} {#name-pragma}

[]{#iref-fields-pragma-51 .iref} []{#iref-header-fields-pragma-52 .iref}
[]{#iref-fields-pragma-53 .iref} []{#iref-header-fields-pragma-54 .iref}
[]{#iref-pragma-header-field-55 .iref}

The \"Pragma\" request header field was defined for HTTP/1.0 caches, so
that clients could specify a \"no-cache\" request (as
[Cache-Control](#field.cache-control){.xref} was not defined until
HTTP/1.1).[¶](#section-5.4-1){.pilcrow}

However, support for Cache-Control is now widespread. As a result, this
specification deprecates Pragma.[¶](#section-5.4-2){.pilcrow}

**Note:** Because the meaning of \"Pragma: no-cache\" in responses was
never specified, it does not provide a reliable replacement for
\"Cache-Control: no-cache\" in them.[¶](#section-5.4-3.1){.pilcrow}
:::
:::

::: {#field.warning}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [Warning](#name-warning){.section-name .selfRef} {#name-warning}

[]{#iref-fields-warning-56 .iref} []{#iref-header-fields-warning-57
.iref} []{#iref-warning-header-field-58 .iref}

The \"Warning\" header field was used to carry additional information
about the status or transformation of a message that might not be
reflected in the status code. This specification obsoletes it, as it is
not widely generated or surfaced to users. The information it carried
can be gleaned from examining other header fields, such as
[Age](#field.age){.xref}.[¶](#section-5.5-1){.pilcrow}
:::
:::
:::
:::

::: {#history.lists}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Relationship to Applications and Other Caches](#name-relationship-to-application){.section-name .selfRef} {#name-relationship-to-application}

Applications using HTTP often specify additional forms of caching. For
example, Web browsers often have history mechanisms such as \"Back\"
buttons that can be used to redisplay a representation retrieved earlier
in a session.[¶](#section-6-1){.pilcrow}

Likewise, some Web browsers implement caching of images and other assets
within a page view; they may or may not honor HTTP caching
semantics.[¶](#section-6-2){.pilcrow}

The requirements in this specification do not necessarily apply to how
applications use data after it is retrieved from an HTTP cache. For
example, a history mechanism can display a previous representation even
if it has expired, and an application can use cached data in other ways
beyond its freshness lifetime.[¶](#section-6-3){.pilcrow}

This specification does not prohibit the application from taking HTTP
caching into account; for example, a history mechanism might tell the
user that a view is stale, or it might honor cache directives (e.g.,
Cache-Control: no-store).[¶](#section-6-4){.pilcrow}

However, when an application caches data and does not make this apparent
to or easily controllable by the user, it is strongly encouraged to
define its operation with respect to HTTP cache directives so as not to
surprise authors who expect caching semantics to be honored. For
example, while it might be reasonable to define an application cache
\"above\" HTTP that allows a response containing Cache-Control: no-store
to be reused for requests that are directly related to the request that
fetched it (such as those created during the same page load), it would
likely be surprising and confusing to users and authors if it were
allowed to be reused for requests unrelated in any way to the one from
which it was obtained.[¶](#section-6-5){.pilcrow}
:::
:::

::: {#security.considerations}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

This section is meant to inform developers, information providers, and
users of known security concerns specific to HTTP caching. More general
security considerations are addressed in \"HTTP/1.1\" ([Section
11](https://www.rfc-editor.org/rfc/rfc9112#section-11){.relref} of
\[[HTTP/1.1](#HTTP11){.xref}\]) and \"HTTP Semantics\" ([Section
17](https://www.rfc-editor.org/rfc/rfc9110#section-17){.relref} of
\[[HTTP](#HTTP){.xref}\]).[¶](#section-7-1){.pilcrow}

Caches expose an additional attack surface because the contents of the
cache represent an attractive target for malicious exploitation. Since
cache contents persist after an HTTP request is complete, an attack on
the cache can reveal information long after a user believes that the
information has been removed from the network. Therefore, cache contents
need to be protected as sensitive
information.[¶](#section-7-2){.pilcrow}

In particular, because private caches are restricted to a single user,
they can be used to reconstruct a user\'s activity. As a result, it is
important for user agents to allow end users to control them, for
example, by allowing stored responses to be removed for some or all
origin servers.[¶](#section-7-3){.pilcrow}

::: {#cache.poisoning}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Cache Poisoning](#name-cache-poisoning){.section-name .selfRef} {#name-cache-poisoning}

Storing malicious content in a cache can extend the reach of an attacker
to affect multiple users. Such \"cache poisoning\" attacks happen when
an attacker uses implementation flaws, elevated privileges, or other
techniques to insert a response into a cache. This is especially
effective when shared caches are used to distribute malicious content to
many clients.[¶](#section-7.1-1){.pilcrow}

One common attack vector for cache poisoning is to exploit differences
in message parsing on proxies and in user agents; see [Section
6.3](https://www.rfc-editor.org/rfc/rfc9112#section-6.3){.relref} of
\[[HTTP/1.1](#HTTP11){.xref}\] for the relevant requirements regarding
HTTP/1.1.[¶](#section-7.1-2){.pilcrow}
:::
:::

::: {#security.timing}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Timing Attacks](#name-timing-attacks){.section-name .selfRef} {#name-timing-attacks}

Because one of the primary uses of a cache is to optimize performance,
its use can \"leak\" information about which resources have been
previously requested.[¶](#section-7.2-1){.pilcrow}

For example, if a user visits a site and their browser caches some of
its responses and then navigates to a second site, that site can attempt
to load responses it knows exist on the first site. If they load
quickly, it can be assumed that the user has visited that site, or even
a specific page on it.[¶](#section-7.2-2){.pilcrow}

Such \"timing attacks\" can be mitigated by adding more information to
the cache key, such as the identity of the referring site (to prevent
the attack described above). This is sometimes called \"double
keying\".[¶](#section-7.2-3){.pilcrow}
:::
:::

::: {#caching.of.sensitive.information}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Caching of Sensitive Information](#name-caching-of-sensitive-inform){.section-name .selfRef} {#name-caching-of-sensitive-inform}

Implementation and deployment flaws (often led to by the
misunderstanding of cache operation) might lead to the caching of
sensitive information (e.g., authentication credentials) that is thought
to be private, exposing it to unauthorized
parties.[¶](#section-7.3-1){.pilcrow}

Note that the Set-Cookie response header field
\[[COOKIE](#COOKIE){.xref}\] does not inhibit caching; a cacheable
response with a Set-Cookie header field can be (and often is) used to
satisfy subsequent requests to caches. Servers that wish to control
caching of these responses are encouraged to emit appropriate
Cache-Control response header fields.[¶](#section-7.3-2){.pilcrow}
:::
:::
:::
:::

::: {#iana.considerations}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

The change controller for the following registrations is: \"IETF
(iesg\@ietf.org) - Internet Engineering Task
Force\".[¶](#section-8-1){.pilcrow}

::: {#field.name.registration}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Field Name Registration](#name-field-name-registration){.section-name .selfRef} {#name-field-name-registration}

IANA has updated the \"Hypertext Transfer Protocol (HTTP) Field Name
Registry\" at \<<https://www.iana.org/assignments/http-fields>\>, as
described in [Section
18.4](https://www.rfc-editor.org/rfc/rfc9110#section-18.4){.relref} of
\[[HTTP](#HTTP){.xref}\], with the field names listed in the table
below:[¶](#section-8.1-1){.pilcrow}

::: {#iana.header.registration.table}
  Field Name      Status       Section                              Comments
  --------------- ------------ ------------------------------------ ----------
  Age             permanent    [5.1](#field.age){.xref}             
  Cache-Control   permanent    [5.2](#field.cache-control){.xref}   
  Expires         permanent    [5.3](#field.expires){.xref}         
  Pragma          deprecated   [5.4](#field.pragma){.xref}          
  Warning         obsoleted    [5.5](#field.warning){.xref}         

  : [Table 1](#table-1){.selfRef}
:::
:::
:::

::: {#cache.directive.registration}
::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Cache Directive Registration](#name-cache-directive-registratio){.section-name .selfRef} {#name-cache-directive-registratio}

IANA has updated the \"Hypertext Transfer Protocol (HTTP) Cache
Directive Registry\" at
\<<https://www.iana.org/assignments/http-cache-directives>\> with the
registration procedure per [Section
5.2.4](#cache.directive.registry){.xref} and the cache directive names
summarized in the table below.[¶](#section-8.2-1){.pilcrow}

::: {#iana.cache.directive.registration.table}
  Cache Directive    Section
  ------------------ -------------------------------------------------------------------------------------------------------------------
  max-age            [5.2.1.1](#cache-request-directive.max-age){.xref}, [5.2.2.1](#cache-response-directive.max-age){.xref}
  max-stale          [5.2.1.2](#cache-request-directive.max-stale){.xref}
  min-fresh          [5.2.1.3](#cache-request-directive.min-fresh){.xref}
  must-revalidate    [5.2.2.2](#cache-response-directive.must-revalidate){.xref}
  must-understand    [5.2.2.3](#cache-response-directive.must-understand){.xref}
  no-cache           [5.2.1.4](#cache-request-directive.no-cache){.xref}, [5.2.2.4](#cache-response-directive.no-cache){.xref}
  no-store           [5.2.1.5](#cache-request-directive.no-store){.xref}, [5.2.2.5](#cache-response-directive.no-store){.xref}
  no-transform       [5.2.1.6](#cache-request-directive.no-transform){.xref}, [5.2.2.6](#cache-response-directive.no-transform){.xref}
  only-if-cached     [5.2.1.7](#cache-request-directive.only-if-cached){.xref}
  private            [5.2.2.7](#cache-response-directive.private){.xref}
  proxy-revalidate   [5.2.2.8](#cache-response-directive.proxy-revalidate){.xref}
  public             [5.2.2.9](#cache-response-directive.public){.xref}
  s-maxage           [5.2.2.10](#cache-response-directive.s-maxage){.xref}

  : [Table 2](#table-2){.selfRef}
:::
:::
:::

::: {#warn.code.registration}
::: {#section-8.3 .section}
### [8.3.](#section-8.3){.section-number .selfRef} [Warn Code Registry](#name-warn-code-registry){.section-name .selfRef} {#name-warn-code-registry}

IANA has added the following note to the \"Hypertext Transfer Protocol
(HTTP) Warn Codes\" registry at
\<<https://www.iana.org/assignments/http-warn-codes>\> stating that
\"Warning\" has been obsoleted:[¶](#section-8.3-1){.pilcrow}

> The Warning header field (and the warn codes that it uses) has been
> obsoleted for HTTP per \[RFC9111\].[¶](#section-8.3-2.1){.pilcrow}
:::
:::
:::
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[HTTP\]
:   [Fielding, R., Ed.]{.refAuthor}, [Nottingham, M., Ed.]{.refAuthor},
    and [J. Reschke, Ed.]{.refAuthor}, [\"HTTP Semantics\"]{.refTitle},
    [STD 97]{.seriesInfo}, [RFC 9110]{.seriesInfo}, [DOI
    10.17487/RFC9110]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9110>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC5234\]
:   [Crocker, D., Ed.]{.refAuthor} and [P. Overell]{.refAuthor},
    [\"Augmented BNF for Syntax Specifications: ABNF\"]{.refTitle}, [STD
    68]{.seriesInfo}, [RFC 5234]{.seriesInfo}, [DOI
    10.17487/RFC5234]{.seriesInfo}, January 2008,
    \<<https://www.rfc-editor.org/info/rfc5234>\>.
:   

\[RFC7405\]
:   [Kyzivat, P.]{.refAuthor}, [\"Case-Sensitive String Support in
    ABNF\"]{.refTitle}, [RFC 7405]{.seriesInfo}, [DOI
    10.17487/RFC7405]{.seriesInfo}, December 2014,
    \<<https://www.rfc-editor.org/info/rfc7405>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   
:::

::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[COOKIE\]
:   [Barth, A.]{.refAuthor}, [\"HTTP State Management
    Mechanism\"]{.refTitle}, [RFC 6265]{.seriesInfo}, [DOI
    10.17487/RFC6265]{.seriesInfo}, April 2011,
    \<<https://www.rfc-editor.org/info/rfc6265>\>.
:   

\[HTTP/1.1\]
:   [Fielding, R., Ed.]{.refAuthor}, [Nottingham, M., Ed.]{.refAuthor},
    and [J. Reschke, Ed.]{.refAuthor}, [\"HTTP/1.1\"]{.refTitle}, [STD
    99]{.seriesInfo}, [RFC 9112]{.seriesInfo}, [DOI
    10.17487/RFC9112]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9112>\>.
:   

\[RFC2616\]
:   [Fielding, R.]{.refAuthor}, [Gettys, J.]{.refAuthor},
    [Mogul, J.]{.refAuthor}, [Frystyk, H.]{.refAuthor},
    [Masinter, L.]{.refAuthor}, [Leach, P.]{.refAuthor}, and [T.
    Berners-Lee]{.refAuthor}, [\"Hypertext Transfer Protocol \--
    HTTP/1.1\"]{.refTitle}, [RFC 2616]{.seriesInfo}, [DOI
    10.17487/RFC2616]{.seriesInfo}, June 1999,
    \<<https://www.rfc-editor.org/info/rfc2616>\>.
:   

\[RFC5861\]
:   [Nottingham, M.]{.refAuthor}, [\"HTTP Cache-Control Extensions for
    Stale Content\"]{.refTitle}, [RFC 5861]{.seriesInfo}, [DOI
    10.17487/RFC5861]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5861>\>.
:   

\[RFC7234\]
:   [Fielding, R., Ed.]{.refAuthor}, [Nottingham, M., Ed.]{.refAuthor},
    and [J. Reschke, Ed.]{.refAuthor}, [\"Hypertext Transfer Protocol
    (HTTP/1.1): Caching\"]{.refTitle}, [RFC 7234]{.seriesInfo}, [DOI
    10.17487/RFC7234]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7234>\>.
:   

\[RFC8126\]
:   [Cotton, M.]{.refAuthor}, [Leiba, B.]{.refAuthor}, and [T.
    Narten]{.refAuthor}, [\"Guidelines for Writing an IANA
    Considerations Section in RFCs\"]{.refTitle}, [BCP 26]{.seriesInfo},
    [RFC 8126]{.seriesInfo}, [DOI 10.17487/RFC8126]{.seriesInfo}, June
    2017, \<<https://www.rfc-editor.org/info/rfc8126>\>.
:   
:::
:::

::: {#collected.abnf}
::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [Collected ABNF](#name-collected-abnf){.section-name .selfRef} {#name-collected-abnf}

In the collected ABNF below, list rules are expanded per [Section
5.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-5.6.1){.relref} of
\[[HTTP](#HTTP){.xref}\].[¶](#appendix-A-1){.pilcrow}

::: {#appendix-A-2}
``` {.lang-abnf .sourcecode}
Age = delta-seconds

Cache-Control = [ cache-directive *( OWS "," OWS cache-directive ) ]

Expires = HTTP-date

HTTP-date = <HTTP-date, see [HTTP], Section 5.6.7>

OWS = <OWS, see [HTTP], Section 5.6.3>

cache-directive = token [ "=" ( token / quoted-string ) ]

delta-seconds = 1*DIGIT

field-name = <field-name, see [HTTP], Section 5.1>

quoted-string = <quoted-string, see [HTTP], Section 5.6.4>

token = <token, see [HTTP], Section 5.6.2>
```

[¶](#appendix-A-2){.pilcrow}
:::
:::
:::

::: {#changes.from.rfc.7234}
::: {#appendix-B .section}
## [Appendix B.](#appendix-B){.section-number .selfRef} [Changes from RFC 7234](#name-changes-from-rfc-7234){.section-name .selfRef} {#name-changes-from-rfc-7234}

Handling of duplicate and conflicting cache directives has been
clarified. ([Section
4.2.1](#calculating.freshness.lifetime){.xref})[¶](#appendix-B-1){.pilcrow}

Cache invalidation of the URIs in the Location and Content-Location
header fields is no longer required but is still allowed. ([Section
4.4](#invalidation){.xref})[¶](#appendix-B-2){.pilcrow}

Cache invalidation of the URIs in the Location and Content-Location
header fields is disallowed when the origin is different; previously, it
was the host. ([Section
4.4](#invalidation){.xref})[¶](#appendix-B-3){.pilcrow}

Handling invalid and multiple Age header field values has been
clarified. ([Section
5.1](#field.age){.xref})[¶](#appendix-B-4){.pilcrow}

Some cache directives defined by this specification now have stronger
prohibitions against generating the quoted form of their values, since
this has been found to create interoperability problems. Consumers of
extension cache directives are no longer required to accept both token
and quoted-string forms, but they still need to parse them properly for
unknown extensions. ([Section
5.2](#field.cache-control){.xref})[¶](#appendix-B-5){.pilcrow}

The public and private cache directives were clarified, so that they do
not make responses reusable under any condition. ([Section
5.2.2](#cache-response-directive){.xref})[¶](#appendix-B-6){.pilcrow}

The must-understand cache directive was introduced; caches are no longer
required to understand the semantics of new response status codes unless
it is present. ([Section
5.2.2.3](#cache-response-directive.must-understand){.xref})[¶](#appendix-B-7){.pilcrow}

The Warning response header was obsoleted. Much of the information
supported by Warning could be gleaned by examining the response, and the
remaining information \-- although potentially useful \-- was entirely
advisory. In practice, Warning was not added by caches or
intermediaries. ([Section
5.5](#field.warning){.xref})[¶](#appendix-B-8){.pilcrow}
:::
:::

::: {#acks}
::: {#appendix-C .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

See Appendix \"Acknowledgements\" of \[[HTTP](#HTTP){.xref}\], which
applies to this document as well.[¶](#appendix-C-1){.pilcrow}
:::
:::

::: {#appendix-D .section}
## [Index](#name-index){.section-name .selfRef} {#name-index}

::: {#rfc.index.index}
[A](#rfc.index.u65){.xref} [C](#rfc.index.u67){.xref}
[E](#rfc.index.u69){.xref} [F](#rfc.index.u70){.xref}
[G](#rfc.index.u71){.xref} [H](#rfc.index.u72){.xref}
[M](#rfc.index.u77){.xref} [N](#rfc.index.u78){.xref}
[O](#rfc.index.u79){.xref} [P](#rfc.index.u80){.xref}
[S](#rfc.index.u83){.xref} [V](#rfc.index.u86){.xref}
[W](#rfc.index.u87){.xref}[¶](#appendix-D-1){.pilcrow}
:::

-   ::: {#appendix-D-2.1}
    ::: {#rfc.index.u65}
    [A](#rfc.index.u65){.xref}[¶](#appendix-D-2.1.1){.pilcrow}
    :::

    -   [[]{.break}]{#appendix-D-2.1.2.1}

        age

        :   [Section
            4.2](#expiration.model){.xref}[¶](#appendix-D-2.1.2.1.1.2.1){.pilcrow}

        :   

        Age header field

        :   ***[Section
            5.1](#field.age){.xref}***[¶](#appendix-D-2.1.2.1.1.4.1){.pilcrow}

        :   
    :::

-   ::: {#appendix-D-2.2}
    ::: {#rfc.index.u67}
    [C](#rfc.index.u67){.xref}[¶](#appendix-D-2.2.1){.pilcrow}
    :::

    -   [[]{.break}]{#appendix-D-2.2.2.1}

        cache

        :   [Section
            1](#caching){.xref}[¶](#appendix-D-2.2.2.1.1.2.1){.pilcrow}

        :   

        cache key

        :   [Section 2](#caching.overview){.xref}; [Section
            2](#caching.overview){.xref}[¶](#appendix-D-2.2.2.1.1.4.1){.pilcrow}

        :   

        Cache-Control header field

        :   ***[Section
            5.2](#field.cache-control){.xref}***[¶](#appendix-D-2.2.2.1.1.6.1){.pilcrow}

        :   

        collapsed requests

        :   [Section
            4](#constructing.responses.from.caches){.xref}[¶](#appendix-D-2.2.2.1.1.8.1){.pilcrow}

        :   
    :::

-   ::: {#appendix-D-2.3}
    ::: {#rfc.index.u69}
    [E](#rfc.index.u69){.xref}[¶](#appendix-D-2.3.1){.pilcrow}
    :::

    -   [[]{.break}]{#appendix-D-2.3.2.1}

        Expires header field

        :   ***[Section
            5.3](#field.expires){.xref}***[¶](#appendix-D-2.3.2.1.1.2.1){.pilcrow}

        :   

        explicit expiration time

        :   [Section
            4.2](#expiration.model){.xref}[¶](#appendix-D-2.3.2.1.1.4.1){.pilcrow}

        :   
    :::

-   ::: {#appendix-D-2.4}
    ::: {#rfc.index.u70}
    [F](#rfc.index.u70){.xref}[¶](#appendix-D-2.4.1){.pilcrow}
    :::

    -   [[]{.break}]{#appendix-D-2.4.2.1}

        Fields

        :   

        :   

        :   []{.break}

            Age

            :   ***[Section 5.1](#field.age){.xref}***; ***[Section
                5.1](#field.age){.xref}***[¶](#appendix-D-2.4.2.1.1.4.1.2.1){.pilcrow}

            :   

            Cache-Control

            :   ***[Section
                5.2](#field.cache-control){.xref}***[¶](#appendix-D-2.4.2.1.1.4.1.4.1){.pilcrow}

            :   

            Expires

            :   ***[Section 5.3](#field.expires){.xref}***; ***[Section
                5.3](#field.expires){.xref}***[¶](#appendix-D-2.4.2.1.1.4.1.6.1){.pilcrow}

            :   

            Pragma

            :   ***[Section 5.4](#field.pragma){.xref}***; ***[Section
                5.4](#field.pragma){.xref}***[¶](#appendix-D-2.4.2.1.1.4.1.8.1){.pilcrow}

            :   

            Warning

            :   ***[Section
                5.5](#field.warning){.xref}***[¶](#appendix-D-2.4.2.1.1.4.1.10.1){.pilcrow}

            :   
        :   

        fresh

        :   [Section
            4.2](#expiration.model){.xref}[¶](#appendix-D-2.4.2.1.1.6.1){.pilcrow}

        :   

        freshness lifetime

        :   [Section
            4.2](#expiration.model){.xref}[¶](#appendix-D-2.4.2.1.1.8.1){.pilcrow}

        :   
    :::

-   ::: {#appendix-D-2.5}
    ::: {#rfc.index.u71}
    [G](#rfc.index.u71){.xref}[¶](#appendix-D-2.5.1){.pilcrow}
    :::

    -   [[]{.break}]{#appendix-D-2.5.2.1}

        Grammar

        :   

        :   

        :   []{.break}

            Age

            :   ***[Section
                5.1](#field.age){.xref}***[¶](#appendix-D-2.5.2.1.1.4.1.2.1){.pilcrow}

            :   

            Cache-Control

            :   ***[Section
                5.2](#field.cache-control){.xref}***[¶](#appendix-D-2.5.2.1.1.4.1.4.1){.pilcrow}

            :   

            DIGIT

            :   ***[Section
                1.2](#notation){.xref}***[¶](#appendix-D-2.5.2.1.1.4.1.6.1){.pilcrow}

            :   

            Expires

            :   ***[Section
                5.3](#field.expires){.xref}***[¶](#appendix-D-2.5.2.1.1.4.1.8.1){.pilcrow}

            :   

            cache-directive

            :   ***[Section
                5.2](#field.cache-control){.xref}***[¶](#appendix-D-2.5.2.1.1.4.1.10.1){.pilcrow}

            :   

            delta-seconds

            :   ***[Section
                1.2.2](#delta-seconds){.xref}***[¶](#appendix-D-2.5.2.1.1.4.1.12.1){.pilcrow}

            :   
        :   
    :::

-   ::: {#appendix-D-2.6}
    ::: {#rfc.index.u72}
    [H](#rfc.index.u72){.xref}[¶](#appendix-D-2.6.1){.pilcrow}
    :::

    -   [[]{.break}]{#appendix-D-2.6.2.1}

        Header Fields

        :   

        :   

        :   []{.break}

            Age

            :   ***[Section 5.1](#field.age){.xref}***; ***[Section
                5.1](#field.age){.xref}***[¶](#appendix-D-2.6.2.1.1.4.1.2.1){.pilcrow}

            :   

            Cache-Control

            :   ***[Section
                5.2](#field.cache-control){.xref}***[¶](#appendix-D-2.6.2.1.1.4.1.4.1){.pilcrow}

            :   

            Expires

            :   ***[Section 5.3](#field.expires){.xref}***; ***[Section
                5.3](#field.expires){.xref}***[¶](#appendix-D-2.6.2.1.1.4.1.6.1){.pilcrow}

            :   

            Pragma

            :   ***[Section 5.4](#field.pragma){.xref}***; ***[Section
                5.4](#field.pragma){.xref}***[¶](#appendix-D-2.6.2.1.1.4.1.8.1){.pilcrow}

            :   

            Warning

            :   ***[Section
                5.5](#field.warning){.xref}***[¶](#appendix-D-2.6.2.1.1.4.1.10.1){.pilcrow}

            :   
        :   

        heuristic expiration time

        :   [Section
            4.2](#expiration.model){.xref}[¶](#appendix-D-2.6.2.1.1.6.1){.pilcrow}

        :   

        heuristically cacheable

        :   [Section
            4.2.2](#heuristic.freshness){.xref}[¶](#appendix-D-2.6.2.1.1.8.1){.pilcrow}

        :   
    :::

-   ::: {#appendix-D-2.7}
    ::: {#rfc.index.u77}
    [M](#rfc.index.u77){.xref}[¶](#appendix-D-2.7.1){.pilcrow}
    :::

    -   [[]{.break}]{#appendix-D-2.7.2.1}

        max-age (cache directive)

        :   ***[Section
            5.2.1.1](#cache-request-directive.max-age){.xref}***;
            ***[Section
            5.2.2.1](#cache-response-directive.max-age){.xref}***[¶](#appendix-D-2.7.2.1.1.2.1){.pilcrow}

        :   

        max-stale (cache directive)

        :   ***[Section
            5.2.1.2](#cache-request-directive.max-stale){.xref}***[¶](#appendix-D-2.7.2.1.1.4.1){.pilcrow}

        :   

        min-fresh (cache directive)

        :   ***[Section
            5.2.1.3](#cache-request-directive.min-fresh){.xref}***[¶](#appendix-D-2.7.2.1.1.6.1){.pilcrow}

        :   

        must-revalidate (cache directive)

        :   ***[Section
            5.2.2.2](#cache-response-directive.must-revalidate){.xref}***[¶](#appendix-D-2.7.2.1.1.8.1){.pilcrow}

        :   

        must-understand (cache directive)

        :   ***[Section
            5.2.2.3](#cache-response-directive.must-understand){.xref}***[¶](#appendix-D-2.7.2.1.1.10.1){.pilcrow}

        :   
    :::

-   ::: {#appendix-D-2.8}
    ::: {#rfc.index.u78}
    [N](#rfc.index.u78){.xref}[¶](#appendix-D-2.8.1){.pilcrow}
    :::

    -   [[]{.break}]{#appendix-D-2.8.2.1}

        no-cache (cache directive)

        :   ***[Section
            5.2.1.4](#cache-request-directive.no-cache){.xref}***;
            ***[Section
            5.2.2.4](#cache-response-directive.no-cache){.xref}***[¶](#appendix-D-2.8.2.1.1.2.1){.pilcrow}

        :   

        no-store (cache directive)

        :   ***[Section
            5.2.1.5](#cache-request-directive.no-store){.xref}***;
            ***[Section
            5.2.2.5](#cache-response-directive.no-store){.xref}***[¶](#appendix-D-2.8.2.1.1.4.1){.pilcrow}

        :   

        no-transform (cache directive)

        :   ***[Section
            5.2.1.6](#cache-request-directive.no-transform){.xref}***;
            ***[Section
            5.2.2.6](#cache-response-directive.no-transform){.xref}***[¶](#appendix-D-2.8.2.1.1.6.1){.pilcrow}

        :   
    :::

-   ::: {#appendix-D-2.9}
    ::: {#rfc.index.u79}
    [O](#rfc.index.u79){.xref}[¶](#appendix-D-2.9.1){.pilcrow}
    :::

    -   [[]{.break}]{#appendix-D-2.9.2.1}

        only-if-cached (cache directive)

        :   ***[Section
            5.2.1.7](#cache-request-directive.only-if-cached){.xref}***[¶](#appendix-D-2.9.2.1.1.2.1){.pilcrow}

        :   
    :::

-   ::: {#appendix-D-2.10}
    ::: {#rfc.index.u80}
    [P](#rfc.index.u80){.xref}[¶](#appendix-D-2.10.1){.pilcrow}
    :::

    -   [[]{.break}]{#appendix-D-2.10.2.1}

        Pragma header field

        :   ***[Section
            5.4](#field.pragma){.xref}***[¶](#appendix-D-2.10.2.1.1.2.1){.pilcrow}

        :   

        private (cache directive)

        :   ***[Section
            5.2.2.7](#cache-response-directive.private){.xref}***[¶](#appendix-D-2.10.2.1.1.4.1){.pilcrow}

        :   

        private cache

        :   [Section
            1](#caching){.xref}[¶](#appendix-D-2.10.2.1.1.6.1){.pilcrow}

        :   

        proxy-revalidate (cache directive)

        :   ***[Section
            5.2.2.8](#cache-response-directive.proxy-revalidate){.xref}***[¶](#appendix-D-2.10.2.1.1.8.1){.pilcrow}

        :   

        public (cache directive)

        :   ***[Section
            5.2.2.9](#cache-response-directive.public){.xref}***[¶](#appendix-D-2.10.2.1.1.10.1){.pilcrow}

        :   
    :::

-   ::: {#appendix-D-2.11}
    ::: {#rfc.index.u83}
    [S](#rfc.index.u83){.xref}[¶](#appendix-D-2.11.1){.pilcrow}
    :::

    -   [[]{.break}]{#appendix-D-2.11.2.1}

        s-maxage (cache directive)

        :   ***[Section
            5.2.2.10](#cache-response-directive.s-maxage){.xref}***[¶](#appendix-D-2.11.2.1.1.2.1){.pilcrow}

        :   

        shared cache

        :   [Section
            1](#caching){.xref}[¶](#appendix-D-2.11.2.1.1.4.1){.pilcrow}

        :   

        stale

        :   [Section
            4.2](#expiration.model){.xref}[¶](#appendix-D-2.11.2.1.1.6.1){.pilcrow}

        :   
    :::

-   ::: {#appendix-D-2.12}
    ::: {#rfc.index.u86}
    [V](#rfc.index.u86){.xref}[¶](#appendix-D-2.12.1){.pilcrow}
    :::

    -   [[]{.break}]{#appendix-D-2.12.2.1}

        validator

        :   [Section
            4.3.1](#validation.sent){.xref}[¶](#appendix-D-2.12.2.1.1.2.1){.pilcrow}

        :   
    :::

-   ::: {#appendix-D-2.13}
    ::: {#rfc.index.u87}
    [W](#rfc.index.u87){.xref}[¶](#appendix-D-2.13.1){.pilcrow}
    :::

    -   [[]{.break}]{#appendix-D-2.13.2.1}

        Warning header field

        :   ***[Section
            5.5](#field.warning){.xref}***[¶](#appendix-D-2.13.2.1.1.2.1){.pilcrow}

        :   
    :::
:::

::: {#authors-addresses}
::: {#appendix-E .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Roy T. Fielding ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Adobe]{.org}
:::

::: {.left dir="auto"}
[345 Park Ave\
San Jose, CA 95110]{.street-address}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <fielding@gbiv.com>
:::

::: url
URI: <https://roy.gbiv.com/>
:::

::: {.left dir="auto"}
[Mark Nottingham ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Fastly]{.org}
:::

::: {.left dir="auto"}
[Prahran]{.street-address}
:::

::: {.left dir="auto"}
[Australia]{.country-name}
:::

::: email
Email: <mnot@mnot.net>
:::

::: url
URI: <https://www.mnot.net/>
:::

::: {.left dir="auto"}
[Julian Reschke ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[greenbytes GmbH]{.org}
:::

::: {.left dir="auto"}
[Hafenweg 16\
48155 Münster]{.street-address}
:::

::: {.left dir="auto"}
[Germany]{.country-name}
:::

::: email
Email: <julian.reschke@greenbytes.de>
:::

::: url
URI: <https://greenbytes.de/tech/webdav/>
:::
:::
:::
