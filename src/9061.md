  RFC 9061              IPsec Flow Protection Based on SDN   July 2021
  --------------------- ------------------------------------ -----------
  Marin-Lopez, et al.   Standards Track                      \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9061](https://www.rfc-editor.org/rfc/rfc9061){.eref}

Category:
:   Standards Track

Published:
:   July 2021

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    R. Marin-Lopez
    :::

    ::: org
    University of Murcia
    :::
    :::

    ::: author
    ::: author-name
    G. Lopez-Millan
    :::

    ::: org
    University of Murcia
    :::
    :::

    ::: author
    ::: author-name
    F. Pereniguez-Garcia
    :::

    ::: org
    University Defense Center
    :::
    :::
:::

# RFC 9061 {#rfcnum}

# A YANG Data Model for IPsec Flow Protection Based on Software‑Defined Networking (SDN) {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document describes how to provide IPsec-based flow protection
(integrity and confidentiality) by means of an Interface to Network
Security Function (I2NSF) Controller. It considers two main well-known
scenarios in IPsec: gateway-to-gateway and host-to-host. The service
described in this document allows the configuration and monitoring of
IPsec Security Associations (IPsec SAs) from an I2NSF Controller to one
or several flow-based Network Security Functions (NSFs) that rely on
IPsec to protect data traffic.[¶](#section-abstract-1){.pilcrow}

This document focuses on the I2NSF NSF-Facing Interface by providing
YANG data models for configuring the IPsec databases, namely Security
Policy Database (SPD), Security Association Database (SAD), Peer
Authorization Database (PAD), and Internet Key Exchange Version 2
(IKEv2). This allows IPsec SA establishment with minimal intervention by
the network administrator. This document defines three YANG modules, but
it does not define any new protocol.[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9061>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Requirements
        Language](#name-requirements-language){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [SDN-Based IPsec Management
    Description](#name-sdn-based-ipsec-management-){.xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [IKE Case: IKEv2/IPsec in the
        NSF](#name-ike-case-ikev2-ipsec-in-the){.xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [IKE-less Case: IPsec (No IKEv2) in
        the NSF](#name-ike-less-case-ipsec-no-ikev){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [IKE Case vs. IKE-less
    Case](#name-ike-case-vs-ike-less-case){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Rekeying
        Process](#name-rekeying-process){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [NSF State
        Loss](#name-nsf-state-loss){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [NAT
        Traversal](#name-nat-traversal){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [NSF Registration and
        Discovery](#name-nsf-registration-and-discov){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [YANG Configuration Data
    Models](#name-yang-configuration-data-mod){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [The \'ietf-i2nsf-ikec\'
        Module](#name-the-ietf-i2nsf-ikec-module){.xref}

        -   ::: {#section-toc.1-1.5.2.1.2.1}
            [5.1.1](#section-5.1.1){.xref}.  [Data Model
            Overview](#name-data-model-overview){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.2}
            [5.1.2](#section-5.1.2){.xref}.  [YANG
            Module](#name-yang-module){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [The \'ietf-i2nsf-ike\'
        Module](#name-the-ietf-i2nsf-ike-module){.xref}

        -   ::: {#section-toc.1-1.5.2.2.2.1}
            [5.2.1](#section-5.2.1){.xref}.  [Data Model
            Overview](#name-data-model-overview-2){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.2}
            [5.2.2](#section-5.2.2){.xref}.  [Example
            Usage](#name-example-usage){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.3}
            [5.2.3](#section-5.2.3){.xref}.  [YANG
            Module](#name-yang-module-2){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [The \'ietf-i2nsf-ikeless\'
        Module](#name-the-ietf-i2nsf-ikeless-modu){.xref}

        -   ::: {#section-toc.1-1.5.2.3.2.1}
            [5.3.1](#section-5.3.1){.xref}.  [Data Model
            Overview](#name-data-model-overview-3){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.2}
            [5.3.2](#section-5.3.2){.xref}.  [Example
            Usage](#name-example-usage-2){.xref}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.3}
            [5.3.3](#section-5.3.3){.xref}.  [YANG
            Module](#name-yang-module-3){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [IKE Case](#name-ike-case){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [IKE-less
        Case](#name-ike-less-case){.xref}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [YANG
        Modules](#name-yang-modules){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [Appendix A](#appendix-A){.xref}.  [XML Configuration Example for
    IKE Case
    (Gateway-to-Gateway)](#name-xml-configuration-example-f){.xref}
    :::

-   ::: {#section-toc.1-1.10}
    [Appendix B](#appendix-B){.xref}.  [XML Configuration Example for
    IKE-less Case
    (Host-to-Host)](#name-xml-configuration-example-fo){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [Appendix C](#appendix-C){.xref}.  [XML Notification
    Examples](#name-xml-notification-examples){.xref}
    :::

-   ::: {#section-toc.1-1.12}
    [Appendix D](#appendix-D){.xref}.  [Operational Use Case
    Examples](#name-operational-use-case-exampl){.xref}

    -   ::: {#section-toc.1-1.12.2.1}
        [D.1](#appendix-D.1){.xref}.  [Example of IPsec SA
        Establishment](#name-example-of-ipsec-sa-establi){.xref}

        -   ::: {#section-toc.1-1.12.2.1.2.1}
            [D.1.1](#appendix-D.1.1){.xref}.  [IKE
            Case](#name-ike-case-2){.xref}
            :::

        -   ::: {#section-toc.1-1.12.2.1.2.2}
            [D.1.2](#appendix-D.1.2){.xref}.  [IKE-less
            Case](#name-ike-less-case-2){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [D.2](#appendix-D.2){.xref}.  [Example of the Rekeying Process
        in IKE-less Case](#name-example-of-the-rekeying-pro){.xref}
        :::

    -   ::: {#section-toc.1-1.12.2.3}
        [D.3](#appendix-D.3){.xref}.  [Example of Managing NSF State
        Loss in the IKE-less
        Case](#name-example-of-managing-nsf-sta){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [](#appendix-E){.xref}[Acknowledgements](#name-acknowledgements){.xref}
    :::

-   ::: {#section-toc.1-1.14}
    [](#appendix-F){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#intro}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Software-Defined Networking (SDN) is an architecture that enables
administrators to directly program, orchestrate, control, and manage
network resources through software. The SDN paradigm relocates the
control of network resources to a centralized entity, namely the SDN
Controller. SDN Controllers configure and manage distributed network
resources and provide an abstracted view of the network resources to SDN
applications. SDN applications can customize and automate the operations
(including management) of the abstracted network resources in a
programmable manner via this interface \[[RFC7149](#RFC7149){.xref}\]
\[[ITU-T.Y.3300](#ITU-T.Y.3300){.xref}\]
\[[ONF-SDN-Architecture](#ONF-SDN-Architecture){.xref}\]
\[[ONF-OpenFlow](#ONF-OpenFlow){.xref}\].[¶](#section-1-1){.pilcrow}

Recently, several network scenarios now demand a centralized way of
managing different security aspects, for example, Software-Defined WANs
(SD-WANs). SD-WANs are SDN extensions providing software abstractions to
create secure network overlays over traditional WAN and branch networks.
SD-WANs utilize IPsec \[[RFC4301](#RFC4301){.xref}\] as an underlying
security protocol. The goal of SD-WANs is to provide flexible and
automated deployment from a centralized point to enable on-demand
network security services, such as IPsec Security Association (IPsec SA)
management. Additionally, Section
[4.3.3](https://www.rfc-editor.org/rfc/rfc8192#section-4.3.3){.relref}
([\"Client-Specific Security Policy in Cloud
VPNs\"](https://www.rfc-editor.org/rfc/rfc8192#section-4.3.3){.relref})
of \[[RFC8192](#RFC8192){.xref}\] describes another example use case for
a cloud data center scenario. The use case in
\[[RFC8192](#RFC8192){.xref}\] states that \"dynamic key management is
critical for securing the VPN and the distribution of policies\". These
VPNs can be established using IPsec. The management of IPsec SAs in data
centers using a centralized entity is a scenario where the current
specification may be applicable.[¶](#section-1-2){.pilcrow}

Therefore, with the growth of SDN-based scenarios where network
resources are deployed in an autonomous manner, a mechanism to manage
IPsec SAs from a centralized entity becomes more relevant in the
industry.[¶](#section-1-3){.pilcrow}

In response to this need, the Interface to Network Security Functions
(I2NSF) charter states that the goal of this working group is \"to
define a set of software interfaces and data models for controlling and
monitoring aspects of physical and virtual NSFs\". As defined in
\[[RFC8192](#RFC8192){.xref}\], a Network Security Function (NSF) is \"a
function that is used to ensure integrity, confidentiality, or
availability of network communication; to detect unwanted network
activity; or to block, or at least mitigate, the effects of unwanted
activity\". This document pays special attention to flow-based NSFs that
ensure integrity and confidentiality by means of
IPsec.[¶](#section-1-4){.pilcrow}

In fact, [Section
3.1.9](https://www.rfc-editor.org/rfc/rfc8192#section-3.1.9){.relref} of
\[[RFC8192](#RFC8192){.xref}\] states that \"there is a need for a
controller to create, manage, and distribute various keys to distributed
NSFs\"; however, \"there is a lack of a standard interface to provision
and manage security associations\". Inspired by the SDN paradigm, the
I2NSF framework \[[RFC8329](#RFC8329){.xref}\] defines a centralized
entity, the I2NSF Controller, which manages one or multiple NSFs through
an I2NSF NSF-Facing Interface. In this document, an architecture is
defined for allowing the I2NSF Controller to carry out the key
management procedures. More specifically, three YANG data models are
defined for the I2NSF NSF-Facing Interface, which allows the I2NSF
Controller to configure and monitor IPsec-enabled, flow-based
NSFs.[¶](#section-1-5){.pilcrow}

The IPsec architecture \[[RFC4301](#RFC4301){.xref}\] defines a clear
separation between the processing to provide security services to IP
packets and the key management procedures to establish the IPsec SAs,
which allows centralizing the key management procedures in the I2NSF
Controller. This document considers two typical scenarios to
autonomously manage IPsec SAs: gateway-to-gateway and host-to-host
\[[RFC6071](#RFC6071){.xref}\]. In these cases, hosts, gateways, or both
may act as NSFs. Due to its complexity, consideration for the
host-to-gateway scenario is out of scope. The source of this complexity
comes from the fact that, in this scenario, the host may not be under
the control of the I2NSF Controller and, therefore, it is not
configurable. Nevertheless, the I2NSF interfaces defined in this
document can be considered as a starting point to analyze and provide a
solution for the host-to-gateway scenario.[¶](#section-1-6){.pilcrow}

For the definition of the YANG data models for the I2NSF NSF-Facing
Interface, this document considers two general cases,
namely:[¶](#section-1-7){.pilcrow}

1.  [IKE case. The NSF implements the Internet Key Exchange Version 2
    (IKEv2) protocol and the IPsec databases: the Security Policy
    Database (SPD), the Security Association Database (SAD), and the
    Peer Authorization Database (PAD). The I2NSF Controller is in charge
    of provisioning the NSF with the required information in the SPD and
    PAD (e.g., IKE credentials) and the IKE protocol itself (e.g.,
    parameters for the IKE_SA_INIT
    negotiation).[¶](#section-1-8.1){.pilcrow}]{#section-1-8.1}
2.  [IKE-less case. The NSF only implements the IPsec databases (no IKE
    implementation). The I2NSF Controller will provide the required
    parameters to create valid entries in the SPD and the SAD of the
    NSF. Therefore, the NSF will only have support for IPsec whereas key
    management functionality is moved to the I2NSF
    Controller.[¶](#section-1-8.2){.pilcrow}]{#section-1-8.2}

In both cases, a YANG data model for the I2NSF NSF-Facing Interface is
required to carry out this provisioning in a secure manner between the
I2NSF Controller and the NSF. Using YANG data modeling language version
1.1 \[[RFC7950](#RFC7950){.xref}\] and based on YANG data models defined
in \[[netconf-vpn](#netconf-vpn){.xref}\] and
\[[TRAN-IPSECME-YANG](#I-D.tran-ipsecme-yang){.xref}\] and the data
structures defined in \[[RFC4301](#RFC4301){.xref}\] and
\[[RFC7296](#RFC7296){.xref}\], this document defines the required
interfaces with a YANG data model for configuration and state data for
IKE, PAD, SPD, and SAD (see Sections [5.1](#ike-common-model){.xref},
[5.2](#ike-case-model){.xref}, and [5.3](#ike-less-model){.xref}). The
proposed YANG data model conforms to the Network Management Datastore
Architecture (NMDA) defined in \[[RFC8342](#RFC8342){.xref}\]. Examples
of the usage of these data models can be found in Appendices
[A](#appendix-d){.xref}, [B](#appendix-e){.xref}, and
[C](#appendix-f){.xref}.[¶](#section-1-9){.pilcrow}

In summary, the objectives of this document
are:[¶](#section-1-10){.pilcrow}

-   [To describe the architecture for I2NSF-based IPsec management,
    which allows for the establishment and management of IPsec Security
    Associations from the I2NSF Controller in order to protect specific
    data flows between two flow-based NSFs implementing
    IPsec.[¶](#section-1-11.1){.pilcrow}]{#section-1-11.1}
-   [To map this architecture to the I2NSF
    framework.[¶](#section-1-11.2){.pilcrow}]{#section-1-11.2}
-   [To define the interfaces required to manage and monitor the IPsec
    SAs in the NSF from an I2NSF Controller. YANG data models are
    defined for configuration and state data for IPsec and IKEv2
    management through the I2NSF NSF-Facing Interface. The YANG data
    models can be used via existing protocols, such as the Network
    Configuration Protocol (NETCONF) \[[RFC6241](#RFC6241){.xref}\] or
    RESTCONF \[[RFC8040](#RFC8040){.xref}\]. Thus, this document defines
    three YANG modules (see [Section 5](#models){.xref}) but does not
    define any new
    protocol.[¶](#section-1-11.3){.pilcrow}]{#section-1-11.3}
:::
:::

::: {#notation}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

This document uses the terminology described in
\[[ITU-T.Y.3300](#ITU-T.Y.3300){.xref}\],
\[[RFC8192](#RFC8192){.xref}\], \[[RFC4301](#RFC4301){.xref}\],
\[[RFC6437](#RFC6437){.xref}\], \[[RFC7296](#RFC7296){.xref}\],
\[[RFC6241](#RFC6241){.xref}\], and
\[[RFC8329](#RFC8329){.xref}\].[¶](#section-2-1){.pilcrow}

The following term is defined in
\[[ITU-T.Y.3300](#ITU-T.Y.3300){.xref}\]:[¶](#section-2-2){.pilcrow}

-   [Software-Defined Networking
    (SDN)[¶](#section-2-3.1){.pilcrow}]{#section-2-3.1}

The following terms are defined in
\[[RFC8192](#RFC8192){.xref}\]:[¶](#section-2-4){.pilcrow}

-   [Network Security Function
    (NSF)[¶](#section-2-5.1){.pilcrow}]{#section-2-5.1}
-   [flow-based NSF[¶](#section-2-5.2){.pilcrow}]{#section-2-5.2}

The following terms are defined in
\[[RFC4301](#RFC4301){.xref}\]:[¶](#section-2-6){.pilcrow}

-   [Peer Authorization Database
    (PAD)[¶](#section-2-7.1){.pilcrow}]{#section-2-7.1}
-   [Security Association Database
    (SAD)[¶](#section-2-7.2){.pilcrow}]{#section-2-7.2}
-   [Security Policy Database
    (SPD)[¶](#section-2-7.3){.pilcrow}]{#section-2-7.3}

The following two terms are related or have identical definition/usage
in \[[RFC6437](#RFC6437){.xref}\]:[¶](#section-2-8){.pilcrow}

-   [flow[¶](#section-2-9.1){.pilcrow}]{#section-2-9.1}
-   [traffic flow[¶](#section-2-9.2){.pilcrow}]{#section-2-9.2}

The following term is defined in
\[[RFC7296](#RFC7296){.xref}\]:[¶](#section-2-10){.pilcrow}

-   [Internet Key Exchange Version 2
    (IKEv2)[¶](#section-2-11.1){.pilcrow}]{#section-2-11.1}

The following terms are defined in
\[[RFC6241](#RFC6241){.xref}\]:[¶](#section-2-12){.pilcrow}

-   [configuration data[¶](#section-2-13.1){.pilcrow}]{#section-2-13.1}
-   [configuration
    datastore[¶](#section-2-13.2){.pilcrow}]{#section-2-13.2}
-   [state data[¶](#section-2-13.3){.pilcrow}]{#section-2-13.3}
-   [startup configuration
    datastore[¶](#section-2-13.4){.pilcrow}]{#section-2-13.4}
-   [running configuration
    datastore[¶](#section-2-13.5){.pilcrow}]{#section-2-13.5}

::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Requirements Language](#name-requirements-language){.section-name .selfRef} {#name-requirements-language}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2.1-1){.pilcrow}
:::
:::
:::

::: {#cases}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [SDN-Based IPsec Management Description](#name-sdn-based-ipsec-management-){.section-name .selfRef} {#name-sdn-based-ipsec-management-}

As mentioned in [Section 1](#intro){.xref}, two cases are considered,
depending on whether the NSF implements IKEv2 or not: the IKE case and
the IKE-less case.[¶](#section-3-1){.pilcrow}

::: {#case1}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [IKE Case: IKEv2/IPsec in the NSF](#name-ike-case-ikev2-ipsec-in-the){.section-name .selfRef} {#name-ike-case-ikev2-ipsec-in-the}

In this case, the NSF implements IPsec with IKEv2 support. The I2NSF
Controller is in charge of managing and applying IPsec connection
information (determining which nodes need to start an IKEv2/IPsec
session, identifying the type of traffic to be protected, and deriving
and delivering IKEv2 credentials, such as a pre-shared key (PSK),
certificates, etc.) and applying other IKEv2 configuration parameters
(e.g., cryptographic algorithms for establishing an IKEv2 SA) to the NSF
necessary for the IKEv2 negotiation.[¶](#section-3.1-1){.pilcrow}

With these entries, the IKEv2 implementation can operate to establish
the IPsec SAs. The I2NSF User establishes the IPsec requirements and
information about the endpoints (through the I2NSF Consumer-Facing
Interface \[[RFC8329](#RFC8329){.xref}\]), and the I2NSF Controller
translates these requirements into IKEv2, SPD, and PAD entries that will
be installed into the NSF (through the I2NSF NSF-Facing Interface). With
that information, the NSF can just run IKEv2 to establish the required
IPsec SA (when the traffic flow needs protection). [Figure
1](#fig_nsf-architecture1){.xref} shows the different layers and
corresponding functionality.[¶](#section-3.1-2){.pilcrow}

[]{#name-ike-case-ike-ipsec-in-the-n}

::: {#fig_nsf-architecture1}
::: {#section-3.1-3.1 .artwork .art-text .alignCenter}
                +-------------------------------------------+
                |          IPsec Management System          | I2NSF User
                +-------------------------------------------+
                                        |
                                        |  I2NSF Consumer-Facing
                                        |  Interface
                +-------------------------------------------+
                | IKEv2 Configuration, PAD and SPD Entries  | I2NSF
                |               Distribution                | Controller
                +-------------------------------------------+
                                        |
                                        |  I2NSF NSF-Facing
                                        |  Interface
                +-------------------------------------------+
                |   IKEv2  |      IPsec(PAD, SPD)           | Network
                |-------------------------------------------| Security
                |    IPsec Data Protection and Forwarding   | Function
                +-------------------------------------------+
:::

[Figure 1](#figure-1){.selfRef}: [IKE Case: IKE/IPsec in the
NSF](#name-ike-case-ike-ipsec-in-the-n){.selfRef}
:::

I2NSF-based IPsec flow protection services provide dynamic and flexible
management of IPsec SAs in flow-based NSFs. In order to support this
capability in the IKE case, a YANG data model for IKEv2, SPD, and PAD
configuration data and for IKEv2 state data needs to be defined for the
I2NSF NSF-Facing Interface (see [Section
5](#models){.xref}).[¶](#section-3.1-4){.pilcrow}
:::
:::

::: {#case2}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [IKE-less Case: IPsec (No IKEv2) in the NSF](#name-ike-less-case-ipsec-no-ikev){.section-name .selfRef} {#name-ike-less-case-ipsec-no-ikev}

In this case, the NSF does not deploy IKEv2 and, therefore, the I2NSF
Controller has to perform the IKEv2 security functions and management of
IPsec SAs by populating and managing the SPD and the
SAD.[¶](#section-3.2-1){.pilcrow}

As shown in [Figure 2](#fig_nsf-architecture2){.xref}, when an I2NSF
User enforces flow-based protection policies through the Consumer-Facing
Interface, the I2NSF Controller translates these requirements into SPD
and SAD entries, which are installed in the NSF. PAD entries are not
required, since there is no IKEv2 in the
NSF.[¶](#section-3.2-2){.pilcrow}

[]{#name-ike-less-case-ipsec-no-ikev2}

::: {#fig_nsf-architecture2}
::: {#section-3.2-3.1 .artwork .art-text .alignCenter}
             +-----------------------------------------+
             |         IPsec Management System         | I2NSF User
             +-----------------------------------------+
                                 |
                                 |  I2NSF Consumer-Facing Interface
                                 |
             +-----------------------------------------+
             |           SPD and SAD Entries           | I2NSF
             |              Distribution               | Controller
             +-----------------------------------------+
                                 |
                                 |  I2NSF NSF-Facing Interface
                                 |
             +-----------------------------------------+
             |             IPsec (SPD, SAD)            | Network
             |-----------------------------------------| Security
             |   IPsec Data Protection and Forwarding  | Function
             +-----------------------------------------+
:::

[Figure 2](#figure-2){.selfRef}: [IKE-less Case: IPsec (No IKEv2) in the
NSF](#name-ike-less-case-ipsec-no-ikev2){.selfRef}
:::

In order to support the IKE-less case, a YANG data model for SPD and SAD
configuration data and SAD state data [MUST]{.bcp14} be defined for the
NSF-Facing Interface (see [Section
5](#models){.xref}).[¶](#section-3.2-4){.pilcrow}

Specifically, the IKE-less case assumes that the I2NSF Controller has to
perform some security functions that IKEv2 typically does, namely
(non-exhaustive list):[¶](#section-3.2-5){.pilcrow}

-   [Initialization Vector (IV)
    generation[¶](#section-3.2-6.1){.pilcrow}]{#section-3.2-6.1}
-   [prevention of counter resets for the same
    key[¶](#section-3.2-6.2){.pilcrow}]{#section-3.2-6.2}
-   [generation of pseudorandom cryptographic keys for the IPsec
    SAs[¶](#section-3.2-6.3){.pilcrow}]{#section-3.2-6.3}
-   [generation of the IPsec SAs when required based on notifications
    (i.e., sadb-acquire) from the
    NSF[¶](#section-3.2-6.4){.pilcrow}]{#section-3.2-6.4}
-   [rekey of the IPsec SAs based on notifications from the NSF (i.e.,
    expire)[¶](#section-3.2-6.5){.pilcrow}]{#section-3.2-6.5}
-   [NAT traversal discovery and
    management[¶](#section-3.2-6.6){.pilcrow}]{#section-3.2-6.6}

Additionally to these functions, another set of tasks must be performed
by the I2NSF Controller (non-exhaustive
list):[¶](#section-3.2-7){.pilcrow}

-   [IPsec SA\'s Security Parameter Index (SPI) random
    generation[¶](#section-3.2-8.1){.pilcrow}]{#section-3.2-8.1}
-   [cryptographic algorithm
    selection[¶](#section-3.2-8.2){.pilcrow}]{#section-3.2-8.2}
-   [usage of extended sequence
    numbers[¶](#section-3.2-8.3){.pilcrow}]{#section-3.2-8.3}
-   [establishment of proper Traffic
    Selectors[¶](#section-3.2-8.4){.pilcrow}]{#section-3.2-8.4}
:::
:::
:::
:::

::: {#comparison}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [IKE Case vs. IKE-less Case](#name-ike-case-vs-ike-less-case){.section-name .selfRef} {#name-ike-case-vs-ike-less-case}

In principle, the IKE case is easier to deploy than the IKE-less case
because current flow-based NSFs (either hosts or gateways) have access
to IKEv2 implementations. While gateways typically deploy an IKEv2/IPsec
implementation, hosts can easily install it. As a downside, the NSF
needs more resources to use IKEv2, such as memory for the IKEv2
implementation and computation, since each IPsec Security Association
rekeying [MAY]{.bcp14} involve a Diffie-Hellman (DH)
exchange.[¶](#section-4-1){.pilcrow}

Alternatively, the IKE-less case benefits the deployment in
resource-constrained NSFs. Moreover, IKEv2 does not need to be performed
in gateway-to-gateway and host-to-host scenarios under the same I2NSF
Controller (see [Appendix D.1](#appendix-g1){.xref}). On the contrary,
the complexity of creating and managing IPsec SAs is shifted to the
I2NSF Controller since IKEv2 is not in the NSF. As a consequence, this
may result in a more complex implementation in the controller side in
comparison with the IKE case. For example, the I2NSF Controller has to
deal with the latency existing in the path between the I2NSF Controller
and the NSF (in order to solve tasks, such as rekey) or creation and
installation of new IPsec SAs. However, this is not specific to this
contribution but a general aspect in any SDN-based network. In summary,
this complexity may create some scalability and performance issues when
the number of NSFs is high.[¶](#section-4-2){.pilcrow}

Nevertheless, literature around SDN-based network management using a
centralized controller (like the I2NSF Controller) is aware of
scalability and performance issues, and solutions have been already
provided and discussed (e.g., hierarchical controllers, having multiple
replicated controllers, dedicated high-speed management networks, etc.).
In the context of I2NSF-based IPsec management, one way to reduce the
latency and alleviate some performance issues can be to install the
IPsec policies and IPsec SAs at the same time (proactive mode, as
described in [Appendix D.1](#appendix-g1){.xref}) instead of waiting for
notifications (e.g., a sadb-acquire notification received from an NSF
requiring a new IPsec SA) to proceed with the IPsec SA installation
(reactive mode). Another way to reduce the overhead and the potential
scalability and performance issues in the I2NSF Controller is to apply
the IKE case described in this document since the IPsec SAs are managed
between NSFs without the involvement of the I2NSF Controller at all,
except by the initial configuration (i.e., IKEv2, PAD, and SPD entries)
provided by the I2NSF Controller. Other solutions, such as
Controller-IKE
\[[IPSECME-CONTROLLER-IKE](#I-D.carrel-ipsecme-controller-ike){.xref}\],
have proposed that NSFs provide their DH public keys to the I2NSF
Controller so that the I2NSF Controller distributes all public keys to
all peers. All peers can calculate a unique pairwise secret for each
other peer, and there is no inter-NSF messages. A rekey mechanism is
further described in
\[[IPSECME-CONTROLLER-IKE](#I-D.carrel-ipsecme-controller-ike){.xref}\].[¶](#section-4-3){.pilcrow}

In terms of security, the IKE case provides better security properties
than the IKE-less case, as discussed in [Section 7](#security){.xref}.
The main reason is that the NSFs generate the session keys and not the
I2NSF Controller.[¶](#section-4-4){.pilcrow}

::: {#rekeying}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Rekeying Process](#name-rekeying-process){.section-name .selfRef} {#name-rekeying-process}

Performing a rekey for IPsec SAs is an important operation during the
IPsec SAs management. With the YANG data models defined in this document
the I2NSF Controller can configure parameters of the rekey process (IKE
case) or conduct the rekey process (IKE-less case). Indeed, depending on
the case, the rekey process is different.[¶](#section-4.1-1){.pilcrow}

For the IKE case, the rekeying process is carried out by IKEv2,
following the information defined in the SPD and SAD (i.e., based on the
IPsec SA lifetime established by the I2NSF Controller using the YANG
data model defined in this document). Therefore, IPsec connections will
live unless something different is required by the I2NSF User or the
I2NSF Controller detects something wrong.[¶](#section-4.1-2){.pilcrow}

For the IKE-less case, the I2NSF Controller [MUST]{.bcp14} take care of
the rekeying process. When the IPsec SA is going to expire (e.g., IPsec
SA soft lifetime), it [MUST]{.bcp14} create a new IPsec SA and it
[MAY]{.bcp14} remove the old one (e.g., when the lifetime of the old
IPsec SA has not been defined). This rekeying process starts when the
I2NSF Controller receives a sadb-expire notification or, on the I2NSF
Controller\'s initiative, based on lifetime state data obtained from the
NSF. How the I2NSF Controller implements an algorithm for the rekey
process is out of the scope of this document. Nevertheless, an example
of how this rekey could be performed is described in [Appendix
D.2](#appendix-g2){.xref}.[¶](#section-4.1-3){.pilcrow}
:::
:::

::: {#restart}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [NSF State Loss](#name-nsf-state-loss){.section-name .selfRef} {#name-nsf-state-loss}

If one of the NSF restarts, it will lose the IPsec state (affected NSF).
By default, the I2NSF Controller can assume that all the state has been
lost and, therefore, it will have to send IKEv2, SPD, and PAD
information to the NSF in the IKE case and SPD and SAD information in
the IKE-less case.[¶](#section-4.2-1){.pilcrow}

In both cases, the I2NSF Controller is aware of the affected NSF (e.g.,
the NETCONF/TCP connection is broken with the affected NSF, the I2NSF
Controller is receiving a sadb-bad-spi notification from a particular
NSF, etc.). Moreover, the I2NSF Controller keeps a list of NSFs that
have IPsec SAs with the affected NSF. Therefore, it knows the affected
IPsec SAs.[¶](#section-4.2-2){.pilcrow}

In the IKE case, the I2NSF Controller may need to configure the affected
NSF with the new IKEv2, SPD, and PAD information. Alternatively, IKEv2
configuration [MAY]{.bcp14} be made permanent between NSF reboots
without compromising security by means of the startup configuration
datastore in the NSF. This way, each time an NSF reboots, it will use
that configuration for each rebooting. It would imply avoiding contact
with the I2NSF Controller. Finally, the I2NSF Controller may also need
to send new parameters (e.g., a new fresh PSK for authentication) to the
NSFs that had IKEv2 SAs and IPsec SAs with the affected
NSF.[¶](#section-4.2-3){.pilcrow}

In the IKE-less case, the I2NSF Controller [SHOULD]{.bcp14} delete the
old IPsec SAs in the non-failed nodes established with the affected NSF.
Once the affected node restarts, the I2NSF Controller [MUST]{.bcp14}
take the necessary actions to reestablish IPsec-protected communication
between the failed node and those others having IPsec SAs with the
affected NSF. How the I2NSF Controller implements an algorithm for
managing a potential NSF state loss is out of the scope of this
document. Nevertheless, an example of how this could be performed is
described in [Appendix
D.3](#appendix-g3){.xref}.[¶](#section-4.2-4){.pilcrow}
:::
:::

::: {#nat-traversal}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [NAT Traversal](#name-nat-traversal){.section-name .selfRef} {#name-nat-traversal}

In the IKE case, IKEv2 already provides a mechanism to detect whether
some of the peers or both are located behind a NAT. In this case, UDP or
TCP encapsulation for Encapsulating Security Payload (ESP) packets
\[[RFC3948](#RFC3948){.xref}\] \[[RFC8229](#RFC8229){.xref}\] is
required. Note that IPsec transport mode [MUST NOT]{.bcp14} be used in
this specification when NAT is required.[¶](#section-4.3-1){.pilcrow}

In the IKE-less case, the NSF does not have the assistance of the IKEv2
implementation to detect if it is located behind a NAT. If the NSF does
not have any other mechanism to detect this situation, the I2NSF
Controller [SHOULD]{.bcp14} implement a mechanism to detect that case.
The SDN paradigm generally assumes the I2NSF Controller has a view of
the network under its control. This view is built either by requesting
information from the NSFs under its control or information pushed from
the NSFs to the I2NSF Controller. Based on this information, the I2NSF
Controller [MAY]{.bcp14} guess if there is a NAT configured between two
hosts and apply the required policies to both NSFs besides activating
the usage of UDP or TCP encapsulation of ESP packets
\[[RFC3948](#RFC3948){.xref}\] \[[RFC8229](#RFC8229){.xref}\]. The
interface for discovering if the NSF is behind a NAT is out of scope of
this document.[¶](#section-4.3-2){.pilcrow}

If the I2NSF Controller does not have any mechanism to know whether a
host is behind a NAT or not, then the IKE case [MUST]{.bcp14} be used
and not the IKE-less case.[¶](#section-4.3-3){.pilcrow}
:::
:::

::: {#nsf-discovery}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [NSF Registration and Discovery](#name-nsf-registration-and-discov){.section-name .selfRef} {#name-nsf-registration-and-discov}

NSF registration refers to the process of providing the I2NSF Controller
information about a valid NSF, such as certificate, IP address, etc.
This information is incorporated in a list of NSFs under its
control.[¶](#section-4.4-1){.pilcrow}

The assumption in this document is that, for both cases, before an NSF
can operate in this system, it [MUST]{.bcp14} be registered in the I2NSF
Controller. In this way, when the NSF starts and establishes a
connection to the I2NSF Controller, it knows that the NSF is valid for
joining the system.[¶](#section-4.4-2){.pilcrow}

Either during this registration process or when the NSF connects with
the I2NSF Controller, the I2NSF Controller [MUST]{.bcp14} discover
certain capabilities of this NSF, such as what are the cryptographic
suites supported, the authentication method, the support of the IKE case
and/or the IKE-less case, etc.[¶](#section-4.4-3){.pilcrow}

The registration and discovery processes are out of the scope of this
document.[¶](#section-4.4-4){.pilcrow}
:::
:::
:::
:::

::: {#models}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [YANG Configuration Data Models](#name-yang-configuration-data-mod){.section-name .selfRef} {#name-yang-configuration-data-mod}

In order to support the IKE and IKE-less cases, models are provided for
the different parameters and values that must be configured to manage
IPsec SAs. Specifically, the IKE case requires modeling IKEv2
configuration parameters, SPD and PAD, while the IKE-less case requires
configuration YANG data models for the SPD and SAD. Three modules have
been defined: ietf-i2nsf-ikec ([Section 5.1](#ike-common-model){.xref},
common to both cases), ietf-i2nsf-ike ([Section
5.2](#ike-case-model){.xref}, IKE case), and ietf-i2nsf-ikeless
([Section 5.3](#ike-less-model){.xref}, IKE-less case). Since the module
ietf-i2nsf-ikec has only typedef and groupings common to the other
modules, a simplified view of the ietf-i2nsf-ike and ietf-i2nsf-ikeless
modules is shown.[¶](#section-5-1){.pilcrow}

::: {#ike-common-model}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [The \'ietf-i2nsf-ikec\' Module](#name-the-ietf-i2nsf-ikec-module){.section-name .selfRef} {#name-the-ietf-i2nsf-ikec-module}

::: {#common-overview}
::: {#section-5.1.1 .section}
#### [5.1.1.](#section-5.1.1){.section-number .selfRef} [Data Model Overview](#name-data-model-overview){.section-name .selfRef} {#name-data-model-overview}

The module ietf-i2nsf-ikec only has definitions of data types (typedef)
and groupings that are common to the other
modules.[¶](#section-5.1.1-1){.pilcrow}
:::
:::

::: {#common-module}
::: {#section-5.1.2 .section}
#### [5.1.2.](#section-5.1.2){.section-number .selfRef} [YANG Module](#name-yang-module){.section-name .selfRef} {#name-yang-module}

This module has normative references to \[[RFC3947](#RFC3947){.xref}\],
\[[RFC4301](#RFC4301){.xref}\], \[[RFC4303](#RFC4303){.xref}\],
\[[RFC8174](#RFC8174){.xref}\], \[[RFC8221](#RFC8221){.xref}\],
\[[RFC3948](#RFC3948){.xref}\], \[[RFC8229](#RFC8229){.xref}\],
\[[RFC6991](#RFC6991){.xref}\],
\[[IANA-Protocols-Number](#IANA-Protocols-Number){.xref}\],
\[[IKEv2-Parameters](#IKEv2-Parameters){.xref}\],
\[[IKEv2-Transform-Type-1](#IKEv2-Transform-Type-1){.xref}\], and
\[[IKEv2-Transform-Type-3](#IKEv2-Transform-Type-3){.xref}\].[¶](#section-5.1.2-1){.pilcrow}

::: {#section-5.1.2-2}
``` {.sourcecode .lang-yang}
<CODE BEGINS> file "ietf-i2nsf-ikec@2021-07-14.yang"


module ietf-i2nsf-ikec {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikec";
  prefix nsfikec;

  import ietf-inet-types {
    prefix inet;
    reference
      "RFC 6991: Common YANG Data Types.";
  }

  organization
    "IETF I2NSF Working Group";
  contact
    "WG Web:  <https://datatracker.ietf.org/wg/i2nsf/>
     WG List: <mailto:i2nsf@ietf.org>

     Author: Rafael Marin-Lopez
               <mailto:rafa@um.es>

     Author: Gabriel Lopez-Millan
               <mailto:gabilm@um.es>

     Author: Fernando Pereniguez-Garcia
               <mailto:fernando.pereniguez@cud.upct.es>
    ";
  description
    "Common data model for the IKE and IKE-less cases
     defined by the SDN-based IPsec flow protection service.

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL',
     'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED',
     'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this
     document are to be interpreted as described in BCP 14
     (RFC 2119) (RFC 8174) when, and only when, they appear
     in all capitals, as shown here.

     Copyright (c) 2021 IETF Trust and the persons
     identified as authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 9061; see
     the RFC itself for full legal notices.";

  revision 2021-07-14 {
    description
      "Initial version.";
    reference
      "RFC 9061: A YANG Data Model for IPsec Flow Protection
                 Based on Software-Defined Networking (SDN).";
  }

  typedef encr-alg-t {
    type uint16;
    description
      "The encryption algorithm is specified with a 16-bit
       number extracted from the IANA registry.  The acceptable
       values MUST follow the requirement levels for
       encryption algorithms for ESP and IKEv2.";
    reference
      "IANA: Internet Key Exchange Version 2 (IKEv2) Parameters,
             IKEv2 Transform Attribute Types, Transform Type 1 -
             Encryption Algorithm Transform IDs
       RFC 8221: Cryptographic Algorithm Implementation
                 Requirements and Usage Guidance for Encapsulating
                 Security Payload (ESP) and Authentication Header
                 (AH)
       RFC 8247: Algorithm Implementation Requirements and Usage
                 Guidance for the Internet Key Exchange Protocol
                 Version 2 (IKEv2).";
  }

  typedef intr-alg-t {
    type uint16;
    description
      "The integrity algorithm is specified with a 16-bit
       number extracted from the IANA registry.
       The acceptable values MUST follow the requirement
       levels for integrity algorithms for ESP and IKEv2.";
    reference
      "IANA: Internet Key Exchange Version 2 (IKEv2) Parameters,
             IKEv2 Transform Attribute Types, Transform Type 3 -
             Integrity Algorithm Transform IDs
       RFC 8221: Cryptographic Algorithm Implementation
                 Requirements and Usage Guidance for Encapsulating
                 Security Payload (ESP) and Authentication Header
                 (AH)
       RFC 8247: Algorithm Implementation Requirements and Usage
                 Guidance for the Internet Key Exchange Protocol
                 Version 2 (IKEv2).";
  }

  typedef ipsec-mode {
    type enumeration {
      enum transport {
        description
          "IPsec transport mode.  No Network Address
           Translation (NAT) support.";
      }
      enum tunnel {
        description
          "IPsec tunnel mode.";
      }
    }
    description
      "Type definition of IPsec mode: transport or
       tunnel.";
    reference
      "RFC 4301: Security Architecture for the Internet Protocol,
                 Section 3.2.";
  }

  typedef esp-encap {
    type enumeration {
      enum espintcp {
        description
          "ESP in TCP encapsulation.";
        reference
          "RFC 8229: TCP Encapsulation of IKE and
                     IPsec Packets.";
      }
      enum espinudp {
        description
          "ESP in UDP encapsulation.";
        reference
          "RFC 3948: UDP Encapsulation of IPsec ESP
                     Packets.";
      }
      enum none {
        description
          "No ESP encapsulation.";
      }
    }
    description
      "Types of ESP encapsulation when Network Address
       Translation (NAT) may be present between two NSFs.";
    reference
      "RFC 8229: TCP Encapsulation of IKE and IPsec Packets
       RFC 3948: UDP Encapsulation of IPsec ESP Packets.";
  }

  typedef ipsec-protocol-params {
    type enumeration {
      enum esp {
        description
          "IPsec ESP protocol.";
      }
    }
    description
      "Only the Encapsulation Security Protocol (ESP) is
       supported, but it could be extended in the future.";
    reference
      "RFC 4303: IP Encapsulating Security Payload (ESP).";
  }

  typedef lifetime-action {
    type enumeration {
      enum terminate-clear {
        description
          "Terminates the IPsec SA and allows the
           packets through.";
      }
      enum terminate-hold {
        description
          "Terminates the IPsec SA and drops the
           packets.";
      }
      enum replace {
        description
          "Replaces the IPsec SA with a new one:
           rekey.";
      }
    }
    description
      "When the lifetime of an IPsec SA expires, an action
       needs to be performed for the IPsec SA that
       reached the lifetime.  There are three possible
       options: terminate-clear, terminate-hold, and
       replace.";
    reference
      "RFC 4301: Security Architecture for the Internet Protocol,
                 Section 4.5.";
  }

  typedef ipsec-traffic-direction {
    type enumeration {
      enum inbound {
        description
          "Inbound traffic.";
      }
      enum outbound {
        description
          "Outbound traffic.";
      }
    }
    description
      "IPsec traffic direction is defined in
       two directions: inbound and outbound.
       From an NSF perspective, inbound and
       outbound are defined as mentioned
       in Section 3.1 in RFC 4301.";
    reference
      "RFC 4301: Security Architecture for the Internet Protocol,
                 Section 3.1.";
  }

  typedef ipsec-spd-action {
    type enumeration {
      enum protect {
        description
          "PROTECT the traffic with IPsec.";
      }
      enum bypass {
        description
          "BYPASS the traffic.  The packet is forwarded
           without IPsec protection.";
      }
      enum discard {
        description
          "DISCARD the traffic.  The IP packet is
           discarded.";
      }
    }
    description
      "The action when traffic matches an IPsec security
       policy.  According to RFC 4301, there are three
       possible values: BYPASS, PROTECT, and DISCARD.";
    reference
      "RFC 4301: Security Architecture for the Internet Protocol,
                 Section 4.4.1.";
  }

  typedef ipsec-inner-protocol {
    type union {
      type uint8;
      type enumeration {
        enum any {
          value 256;
          description
            "Any IP protocol number value.";
        }
      }
    }
    default "any";
    description
      "IPsec protection can be applied to specific IP
       traffic and Layer 4 traffic (TCP, UDP, SCTP, etc.)
       or ANY protocol in the IP packet payload.
       The IP protocol number is specified with a uint8
       or ANY defining an enumerate with value 256 to
       indicate the protocol number.  Note that in case
       of IPv6, the protocol in the IP packet payload
       is indicated in the Next Header field of the IPv6
       packet.";
    reference
      "RFC 4301: Security Architecture for the Internet Protocol,
                 Section 4.4.1.1
       IANA: Protocol Numbers.";
  }

  grouping encap {
    description
      "This group of nodes allows defining of the type of
       encapsulation in case NAT traversal is
       required and includes port information.";
    leaf espencap {
      type esp-encap;
      default "none";
      description
        "ESP in TCP, ESP in UDP, or ESP in TLS.";
    }
    leaf sport {
      type inet:port-number;
      default "4500";
      description
        "Encapsulation source port.";
    }
    leaf dport {
      type inet:port-number;
      default "4500";
      description
        "Encapsulation destination port.";
    }
    leaf-list oaddr {
      type inet:ip-address;
      description
        "If required, this is the original address that
         was used before NAT was applied over the packet.";
    }
    reference
      "RFC 3947: Negotiation of NAT-Traversal in the IKE
       RFC 8229: TCP Encapsulation of IKE and IPsec Packets.";
  }

  grouping lifetime {
    description
      "Different lifetime values limited to an IPsec SA.";
    leaf time {
      type uint32;
      units "seconds";
      default "0";
      description
        "Time in seconds since the IPsec SA was added.
         For example, if this value is 180 seconds, it
         means the IPsec SA expires in 180 seconds since
         it was added.  The value 0 implies infinite.";
    }
    leaf bytes {
      type uint64;
      default "0";
      description
        "If the IPsec SA processes the number of bytes
         expressed in this leaf, the IPsec SA expires and
         SHOULD be rekeyed.  The value 0 implies
         infinite.";
    }
    leaf packets {
      type uint32;
      default "0";
      description
        "If the IPsec SA processes the number of packets
         expressed in this leaf, the IPsec SA expires and
         SHOULD be rekeyed.  The value 0 implies
         infinite.";
    }
    leaf idle {
      type uint32;
      units "seconds";
      default "0";
      description
        "When an NSF stores an IPsec SA, it
         consumes system resources.  For an idle IPsec SA, this
         is a waste of resources.  If the IPsec SA is idle
         during this number of seconds, the IPsec SA
         SHOULD be removed.  The value 0 implies
         infinite.";
    }
    reference
      "RFC 4301: Security Architecture for the Internet Protocol,
                 Section 4.4.2.1.";
  }

  grouping port-range {
    description
      "This grouping defines a port range, such as that
       expressed in RFC 4301, for example, 1500 (Start
       Port Number)-1600 (End Port Number).
       A port range is used in the Traffic Selector.";
    leaf start {
      type inet:port-number;
      description
        "Start port number.";
    }
    leaf end {
      type inet:port-number;
      must '. >= ../start' {
        error-message
          "The end port number MUST be equal or greater
           than the start port number.";
      }
      description
        "End port number.  To express a single port, set
         the same value as start and end.";
    }
    reference
      "RFC 4301: Security Architecture for the Internet Protocol,
                 Section 4.4.1.2.";
  }

  grouping tunnel-grouping {
    description
      "The parameters required to define the IP tunnel
       endpoints when IPsec SA requires tunnel mode.  The
       tunnel is defined by two endpoints: the local IP
       address and the remote IP address.";
    leaf local {
      type inet:ip-address;
      mandatory true;
      description
        "Local IP address' tunnel endpoint.";
    }
    leaf remote {
      type inet:ip-address;
      mandatory true;
      description
        "Remote IP address' tunnel endpoint.";
    }
    leaf df-bit {
      type enumeration {
        enum clear {
          description
            "Disable the Don't Fragment (DF) bit
             in the outer header.  This is the
             default value.";
        }
        enum set {
          description
            "Enable the DF bit in the outer header.";
        }
        enum copy {
          description
            "Copy the DF bit to the outer header.";
        }
      }
      default "clear";
      description
        "Allow configuring the DF bit when encapsulating
         tunnel mode IPsec traffic.  RFC 4301 describes
         three options to handle the DF bit during
         tunnel encapsulation: clear, set, and copy from
         the inner IP header.  This MUST be ignored or
         has no meaning when the local/remote
         IP addresses are IPv6 addresses.";
      reference
        "RFC 4301: Security Architecture for the Internet Protocol,
                   Section 8.1.";
    }
    leaf bypass-dscp {
      type boolean;
      default "true";
      description
        "If true, to copy the Differentiated Services Code
         Point (DSCP) value from inner header to outer header.
         If false, to map DSCP values
         from an inner header to values in an outer header
         following ../dscp-mapping.";
      reference
        "RFC 4301: Security Architecture for the Internet Protocol,
                   Section 4.4.1.2.";
    }
    list dscp-mapping {
      must '../bypass-dscp = "false"';
      key "id";
      ordered-by user;
      leaf id {
        type uint8;
        description
          "The index of list with the
           different mappings.";
      }
      leaf inner-dscp {
        type inet:dscp;
        description
          "The DSCP value of the inner IP packet.  If this
           leaf is not defined, it means ANY inner DSCP value.";
      }
      leaf outer-dscp {
        type inet:dscp;
        default "0";
        description
          "The DSCP value of the outer IP packet.";
      }
      description
        "A list that represents an array with the mapping from the
         inner DSCP value to outer DSCP value when bypass-dscp is
         false.  To express a default mapping in the list where any
         other inner dscp value is not matching a node in the list,
         a new node has to be included at the end of the list where
         the leaf inner-dscp is not defined (ANY) and the leaf
         outer-dscp includes the value of the mapping.  If there is
         no value set in the leaf outer-dscp, the default value for
         this leaf is 0.";
      reference
        "RFC 4301: Security Architecture for the Internet Protocol,
                   Section 4.4.1.2 and Appendix C.";
    }
  }

  grouping selector-grouping {
    description
      "This grouping contains the definition of a Traffic
       Selector, which is used in the IPsec policies and
       IPsec SAs.";
    leaf local-prefix {
      type inet:ip-prefix;
      mandatory true;
      description
        "Local IP address prefix.";
    }
    leaf remote-prefix {
      type inet:ip-prefix;
      mandatory true;
      description
        "Remote IP address prefix.";
    }
    leaf inner-protocol {
      type ipsec-inner-protocol;
      default "any";
      description
        "Inner protocol that is going to be
         protected with IPsec.";
    }
    list local-ports {
      key "start end";
      uses port-range;
      description
        "List of local ports. When the inner
         protocol is ICMP, this 16-bit value
         represents code and type.
         If this list is not defined,
         it is assumed that start and
         end are 0 by default (any port).";
    }
    list remote-ports {
      key "start end";
      uses port-range;
      description
        "List of remote ports. When the upper layer
         protocol is ICMP, this 16-bit value represents
         code and type.  If this list is not defined,
         it is assumed that start and end are 0 by
         default (any port).";
    }
    reference
      "RFC 4301: Security Architecture for the Internet Protocol,
                 Section 4.4.1.2.";
  }

  grouping ipsec-policy-grouping {
    description
      "Holds configuration information for an IPsec SPD
       entry.";
    leaf anti-replay-window-size {
      type uint32;
      default "64";
      description
        "To set the anti-replay window size.
         The default value is set
         to 64, following the recommendation in RFC 4303.";
      reference
        "RFC 4303: IP Encapsulating Security Payload (ESP),
                   Section 3.4.3.";
    }
    container traffic-selector {
      description
        "Packets are selected for
         processing actions based on Traffic Selector
         values, which refer to IP and inner protocol
         header information.";
      uses selector-grouping;
      reference
        "RFC 4301: Security Architecture for the Internet Protocol,
                   Section 4.4.4.1.";
    }
    container processing-info {
      description
        "SPD processing.  If the required processing
         action is protect, it contains the required
         information to process the packet.";
      leaf action {
        type ipsec-spd-action;
        default "discard";
        description
          "If bypass or discard, container
           ipsec-sa-cfg is empty.";
      }
      container ipsec-sa-cfg {
        when "../action = 'protect'";
        description
          "IPsec SA configuration included in the SPD
           entry.";
        leaf pfp-flag {
          type boolean;
          default "false";
          description
            "Each selector has a Populate From
             Packet (PFP) flag.  If asserted for a
             given selector X, the flag indicates
             that the IPsec SA to be created should
             take its value (local IP address,
             remote IP address, Next Layer
             Protocol, etc.) for X from the value
             in the packet.  Otherwise, the IPsec SA
             should take its value(s) for X from
             the value(s) in the SPD entry.";
        }
        leaf ext-seq-num {
          type boolean;
          default "false";
          description
            "True if this IPsec SA is using extended
             sequence numbers.  If true, the 64-bit
             extended sequence number counter is used;
             if false, the normal 32-bit sequence
             number counter is used.";
        }
        leaf seq-overflow {
          type boolean;
          default "false";
          description
            "The flag indicating whether
             overflow of the sequence number
             counter should prevent transmission
             of additional packets on the IPsec
             SA (false) and, therefore, needs to
             be rekeyed or whether rollover is
             permitted (true).  If Authenticated
             Encryption with Associated Data
             (AEAD) is used (leaf
             esp-algorithms/encryption/algorithm-type),
             this flag MUST be false.  Setting this
             flag to true is strongly discouraged.";
        }
        leaf stateful-frag-check {
          type boolean;
          default "false";
          description
            "Indicates whether (true) or not (false)
             stateful fragment checking applies to
             the IPsec SA to be created.";
        }
        leaf mode {
          type ipsec-mode;
          default "transport";
          description
            "IPsec SA has to be processed in
             transport or tunnel mode.";
        }
        leaf protocol-parameters {
          type ipsec-protocol-params;
          default "esp";
          description
            "Security protocol of the IPsec SA.
             Only ESP is supported, but it could be
             extended in the future.";
        }
        container esp-algorithms {
          when "../protocol-parameters = 'esp'";
          description
            "Configuration of Encapsulating
             Security Payload (ESP) parameters and
             algorithms.";
          leaf-list integrity {
            type intr-alg-t;
            default "0";
            ordered-by user;
            description
              "Configuration of ESP authentication
               based on the specified integrity
               algorithm.  With AEAD encryption
               algorithms, the integrity node is
               not used.";
            reference
              "RFC 4303: IP Encapsulating Security Payload (ESP),
                         Section 3.2.";
          }
          list encryption {
            key "id";
            ordered-by user;
            leaf id {
              type uint16;
              description
                "An identifier that unequivocally identifies each
                 entry of the list, i.e., an encryption algorithm
                 and its key length (if required).";
            }
            leaf algorithm-type {
              type encr-alg-t;
              default "20";
              description
                "Default value 20 (ENCR_AES_GCM_16).";
            }
            leaf key-length {
              type uint16;
              default "128";
              description
                "By default, key length is 128
                 bits.";
            }
            description
              "Encryption or AEAD algorithm for the
               IPsec SAs.  This list is ordered
               following from the higher priority to
               lower priority.  First node of the
               list will be the algorithm with
               higher priority.  In case the list
               is empty, then no encryption algorithm
               is applied (NULL).";
            reference
              "RFC 4303: IP Encapsulating Security Payload (ESP),
                         Section 3.2.";
          }
          leaf tfc-pad {
            type boolean;
            default "false";
            description
              "If Traffic Flow Confidentiality
               (TFC) padding for ESP encryption
               can be used (true) or not (false).";
            reference
              "RFC 4303: IP Encapsulating Security Payload (ESP),
                         Section 2.7.";
          }
          reference
            "RFC 4303: IP Encapsulating Security Payload (ESP).";
        }
        container tunnel {
          when "../mode = 'tunnel'";
          uses tunnel-grouping;
          description
            "IPsec tunnel endpoints definition.";
        }
      }
      reference
        "RFC 4301: Security Architecture for the Internet Protocol,
                   Section 4.4.1.2.";
    }
  }
}

<CODE ENDS>
```

[¶](#section-5.1.2-2){.pilcrow}
:::
:::
:::
:::
:::

::: {#ike-case-model}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [The \'ietf-i2nsf-ike\' Module](#name-the-ietf-i2nsf-ike-module){.section-name .selfRef} {#name-the-ietf-i2nsf-ike-module}

In this section, the YANG module for the IKE case is
described.[¶](#section-5.2-1){.pilcrow}

::: {#ike-overview}
::: {#section-5.2.1 .section}
#### [5.2.1.](#section-5.2.1){.section-number .selfRef} [Data Model Overview](#name-data-model-overview-2){.section-name .selfRef} {#name-data-model-overview-2}

The model related to IKEv2 has been extracted from reading the IKEv2
standard in \[[RFC7296](#RFC7296){.xref}\] and observing some open
source implementations, such as strongSwan
\[[strongswan](#strongswan){.xref}\] or Libreswan
\[[libreswan](#libreswan){.xref}\].[¶](#section-5.2.1-1){.pilcrow}

The definition of the PAD model has been extracted from the
specification in [Section
4.4.3](https://www.rfc-editor.org/rfc/rfc4301#section-4.4.3){.relref} of
\[[RFC4301](#RFC4301){.xref}\]. (Note that many implementations
integrate PAD configuration as part of the IKEv2
configuration.)[¶](#section-5.2.1-2){.pilcrow}

The definition of the SPD model has been mainly extracted from the
specification in Section
[4.4.1](https://www.rfc-editor.org/rfc/rfc4301#section-4.4.1){.relref}
and Appendix
[D](https://www.rfc-editor.org/rfc/rfc4301#appendix-D){.relref} of
\[[RFC4301](#RFC4301){.xref}\].[¶](#section-5.2.1-3){.pilcrow}

The YANG data model for the IKE case is defined by the module
\"ietf-i2nsf-ike\". Its structure is depicted in the following diagram,
using the notation syntax for YANG tree diagrams
\[[RFC8340](#RFC8340){.xref}\].[¶](#section-5.2.1-4){.pilcrow}

::: {#section-5.2.1-5}
``` {.sourcecode .lang-yangtree}
module: ietf-i2nsf-ike
  +--rw ipsec-ike
    +--rw pad
    |  +--rw pad-entry* [name]
    |     +--rw name                           string
    |     +--rw (identity)
    |     |  +--:(ipv4-address)
    |     |  |  +--rw ipv4-address?            inet:ipv4-address
    |     |  +--:(ipv6-address)
    |     |  |  +--rw ipv6-address?            inet:ipv6-address
    |     |  +--:(fqdn-string)
    |     |  |  +--rw fqdn-string?             inet:domain-name
    |     |  +--:(rfc822-address-string)
    |     |  |  +--rw rfc822-address-string?   string
    |     |  +--:(dnx509)
    |     |  |  +--rw dnx509?                  binary
    |     |  +--:(gnx509)
    |     |  |  +--rw gnx509?                  binary
    |     |  +--:(id-key)
    |     |  |  +--rw id-key?                  binary
    |     |  +--:(id-null)
    |     |     +--rw id-null?                 empty
    |     +--rw auth-protocol?                 auth-protocol-type
    |     +--rw peer-authentication
    |        +--rw auth-method?         auth-method-type
    |        +--rw eap-method
    |        |  +--rw eap-type    uint64
    |        +--rw pre-shared
    |        |  +--rw secret?   yang:hex-string
    |        +--rw digital-signature
    |           +--rw ds-algorithm?           uint8
    |           +--rw (public-key)?
    |           |  +--:(raw-public-key)
    |           |  |  +--rw raw-public-key?   binary
    |           |  +--:(cert-data)
    |           |     +--rw cert-data?        binary
    |           +--rw private-key?            binary
    |           +--rw ca-data*                binary
    |           +--rw crl-data?               binary
    |           +--rw crl-uri?                inet:uri
    |           +--rw oscp-uri?               inet:uri
    +--rw conn-entry* [name]
    |  +--rw name                             string
    |  +--rw autostartup?                     autostartup-type
    |  +--rw initial-contact?                 boolean
    |  +--rw version?                         auth-protocol-type
    |  +--rw fragmentation
    |  |  +--rw enabled?   boolean
    |  |  +--rw mtu?      uint16
    |  +--rw ike-sa-lifetime-soft
    |  |  +--rw rekey-time?    uint32
    |  |  +--rw reauth-time?   uint32
    |  +--rw ike-sa-lifetime-hard
    |  |  +--rw over-time?   uint32
    |  +--rw ike-sa-intr-alg*  nsfikec:intr-alg-t
    |  +--rw ike-sa-encr-alg* [id]
    |  |  +--rw id                uint16
    |  |  +--rw algorithm-type?   nsfikec:encr-alg-t
    |  |  +--rw key-length?       uint16
    |  +--rw dh-group?                            fs-group
    |  +--rw half-open-ike-sa-timer?              uint32
    |  +--rw half-open-ike-sa-cookie-threshold?   uint32
    |  +--rw local
    |  |  +--rw local-pad-entry-name    string
    |  +--rw remote
    |  |  +--rw remote-pad-entry-name    string
    |  +--rw encapsulation-type
    |  |  +--rw espencap?   esp-encap
    |  |  +--rw sport?      inet:port-number
    |  |  +--rw dport?      inet:port-number
    |  |  +--rw oaddr*      inet:ip-address
    |  +--rw spd
    |  |  +--rw spd-entry* [name]
    |  |    +--rw name                   string
    |  |    +--rw ipsec-policy-config
    |  |      +--rw anti-replay-window-size?   uint32
    |  |      +--rw traffic-selector
    |  |      |  +--rw local-prefix      inet:ip-prefix
    |  |      |  +--rw remote-prefix     inet:ip-prefix
    |  |      |  +--rw inner-protocol?   ipsec-inner-protocol
    |  |      |  +--rw local-ports* [start end]
    |  |      |  |  +--rw start    inet:port-number
    |  |      |  |  +--rw end      inet:port-number
    |  |      |  +--rw remote-ports* [start end]
    |  |      |     +--rw start    inet:port-number
    |  |      |     +--rw end      inet:port-number
    |  |      +--rw processing-info
    |  |        +--rw action?         ipsec-spd-action
    |  |        +--rw ipsec-sa-cfg
    |  |         +--rw pfp-flag?              boolean
    |  |         +--rw ext-seq-num?           boolean
    |  |         +--rw seq-overflow?          boolean
    |  |         +--rw stateful-frag-check?   boolean
    |  |         +--rw mode?                  ipsec-mode
    |  |         +--rw protocol-parameters? ipsec-protocol-params
    |  |              +--rw esp-algorithms
    |  |              |  +--rw integrity*    intr-alg-t
    |  |              |  +--rw encryption* [id]
    |  |              |  |  +--rw id                uint16
    |  |              |  |  +--rw algorithm-type?   encr-alg-t
    |  |              |  |  +--rw key-length?       uint16
    |  |              |  +--rw tfc-pad?      boolean
    |  |              +--rw tunnel
    |  |                 +--rw local           inet:ip-address
    |  |                 +--rw remote          inet:ip-address
    |  |                 +--rw df-bit?         enumeration
    |  |                 +--rw bypass-dscp?    boolean
    |  |                 +--rw dscp-mapping* [id]
    |  |                    +--rw id            uint8
    |  |                    +--rw inner-dscp?   inet:dscp
    |  |                    +--rw outer-dscp?   inet:dscp
    |  +--rw child-sa-info
    |  |  +--rw fs-groups*                fs-group
    |  |  +--rw child-sa-lifetime-soft
    |  |  |  +--rw time?      uint32
    |  |  |  +--rw bytes?     yang:counter64
    |  |  |  +--rw packets?   uint32
    |  |  |  +--rw idle?      uint32
    |  |  |  +--rw action?    nsfikec:lifetime-action
    |  |  +--rw child-sa-lifetime-hard
    |  |     +--rw time?      uint32
    |  |     +--rw bytes?     yang:counter64
    |  |     +--rw packets?   uint32
    |  |     +--rw idle?      uint32
    |  +--ro state
    |     +--ro initiator?             boolean
    |     +--ro initiator-ikesa-spi?   ike-spi
    |     +--ro responder-ikesa-spi?   ike-spi
    |     +--ro nat-local?             boolean
    |     +--ro nat-remote?            boolean
    |     +--ro encapsulation-type
    |     |  +--ro espencap?   esp-encap
    |     |  +--ro sport?      inet:port-number
    |     |  +--ro dport?      inet:port-number
    |     |  +--ro oaddr*      inet:ip-address
    |     +--ro established?           uint64
    |     +--ro current-rekey-time?    uint64
    |     +--ro current-reauth-time?   uint64
    +--ro number-ike-sas
        +--ro total?               yang:gauge64
        +--ro half-open?           yang:gauge64
        +--ro half-open-cookies?   yang:gauge64
```

[¶](#section-5.2.1-5){.pilcrow}
:::

The YANG data model consists of a unique \"ipsec-ike\" container defined
as follows. Firstly, it contains a \"pad\" container that serves to
configure the Peer Authentication Database with authentication
information about local and remote peers (NSFs). More precisely, it
consists of a list of entries, each one indicating the identity,
authentication method, and credentials that a particular peer (local or
remote) will use. Therefore, each entry contains identity,
authentication information, and credentials of either the local NSF or
the remote NSF. As a consequence, the I2NF Controller can store
identity, authentication information, and credentials for the local NSF
and the remote NSF.[¶](#section-5.2.1-6){.pilcrow}

Next, a list \"conn-entry\" is defined with information about the
different IKE connections a peer can maintain with others. Each
connection entry is composed of a wide number of parameters to configure
different aspects of a particular IKE connection between two peers:
local and remote peer authentication information, IKE SA configuration
(soft and hard lifetimes, cryptographic algorithms, etc.), a list of
IPsec policies describing the type of network traffic to be secured
(local/remote subnet and ports, etc.) and how it must be protected (ESP,
tunnel/transport, cryptographic algorithms, etc.), Child SA
configuration (soft and hard lifetimes), and state information of the
IKE connection (SPIs, usage of NAT, current expiration times,
etc.).[¶](#section-5.2.1-7){.pilcrow}

Lastly, the \"ipsec-ike\" container declares a \"number-ike-sas\"
container to specify state information reported by the IKE software
related to the amount of IKE connections
established.[¶](#section-5.2.1-8){.pilcrow}
:::
:::

::: {#ike-example}
::: {#section-5.2.2 .section}
#### [5.2.2.](#section-5.2.2){.section-number .selfRef} [Example Usage](#name-example-usage){.section-name .selfRef} {#name-example-usage}

[Appendix A](#appendix-d){.xref} shows an example of IKE case
configuration for an NSF, in tunnel mode (gateway-to-gateway), with NSF
authentication based on X.509
certificates.[¶](#section-5.2.2-1){.pilcrow}
:::
:::

::: {#ike-module}
::: {#section-5.2.3 .section}
#### [5.2.3.](#section-5.2.3){.section-number .selfRef} [YANG Module](#name-yang-module-2){.section-name .selfRef} {#name-yang-module-2}

This YANG module has normative references to
\[[RFC5280](#RFC5280){.xref}\], \[[RFC4301](#RFC4301){.xref}\],
\[[RFC5915](#RFC5915){.xref}\], \[[RFC6991](#RFC6991){.xref}\],
\[[RFC7296](#RFC7296){.xref}\], \[[RFC7383](#RFC7383){.xref}\],
\[[RFC7427](#RFC7427){.xref}\], \[[RFC7619](#RFC7619){.xref}\],
\[[RFC8017](#RFC8017){.xref}\], \[[ITU-T.X.690](#ITU-T.X.690){.xref}\],
\[[RFC5322](#RFC5322){.xref}\], \[[RFC8229](#RFC8229){.xref}\],
\[[RFC8174](#RFC8174){.xref}\], \[[RFC6960](#RFC6960){.xref}\],
\[[IKEv2-Auth-Method](#IKEv2-Auth-Method){.xref}\],
\[[IKEv2-Transform-Type-4](#IKEv2-Transform-Type-4){.xref}\],
\[[IKEv2-Parameters](#IKEv2-Parameters){.xref}\], and
\[[IANA-Method-Type](#IANA-Method-Type){.xref}\].[¶](#section-5.2.3-1){.pilcrow}

::: {#section-5.2.3-2}
``` {.sourcecode .lang-yang}
<CODE BEGINS> file "ietf-i2nsf-ike@2021-07-14.yang"


module ietf-i2nsf-ike {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-i2nsf-ike";
  prefix nsfike;

  import ietf-inet-types {
    prefix inet;
    reference
      "RFC 6991: Common YANG Data Types.";
  }
  import ietf-yang-types {
    prefix yang;
    reference
      "RFC 6991: Common YANG Data Types.";
  }
  import ietf-i2nsf-ikec {
    prefix nsfikec;
    reference
      "RFC 9061: A YANG Data Model for IPsec Flow Protection
                 Based on Software-Defined Networking (SDN).";
  }
  import ietf-netconf-acm {
    prefix nacm;
    reference
      "RFC 8341: Network Configuration Access Control
                 Model.";
  }

  organization
    "IETF I2NSF Working Group";
  contact
    "WG Web:  <https://datatracker.ietf.org/wg/i2nsf/>
     WG List: <mailto:i2nsf@ietf.org>

     Author: Rafael Marin-Lopez
               <mailto:rafa@um.es>

     Author: Gabriel Lopez-Millan
               <mailto:gabilm@um.es>

     Author: Fernando Pereniguez-Garcia
               <mailto:fernando.pereniguez@cud.upct.es>
    ";
  description
    "This module contains the IPsec IKE case model for the SDN-based
     IPsec flow protection service.

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL',
     'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED',
     'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this
     document are to be interpreted as described in BCP 14
     (RFC 2119) (RFC 8174) when, and only when, they appear
     in all capitals, as shown here.

     Copyright (c) 2021 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 9061; see
     the RFC itself for full legal notices.";

  revision 2021-07-14 {
    description
      "Initial version.";
    reference
      "RFC 9061: A YANG Data Model for IPsec Flow Protection
                 Based on Software-Defined Networking (SDN).";
  }

  typedef ike-spi {
    type uint64 {
      range "0..max";
    }
    description
      "Security Parameter Index (SPI)'s IKE SA.";
    reference
      "RFC 7296: Internet Key Exchange Protocol Version 2
                 (IKEv2), Section 2.6.";
  }

  typedef autostartup-type {
    type enumeration {
      enum add {
        description
          "IKE/IPsec configuration is only loaded into
           IKE implementation, but IKE/IPsec SA is not
           started.";
      }
      enum on-demand {
        description
          "IKE/IPsec configuration is loaded
           into IKE implementation.  The IPsec policies
           are transferred to the NSF, but the
           IPsec SAs are not established immediately.
           The IKE implementation will negotiate the
           IPsec SAs when they are required
           (i.e., through an ACQUIRE notification).";
      }
      enum start {
        description
          "IKE/IPsec configuration is loaded
           and transferred to the NSF's kernel, and the
           IKEv2-based IPsec SAs are established
           immediately without waiting for any packet.";
      }
    }
    description
      "Different policies to set IPsec SA configuration
       into NSF's kernel when IKEv2 implementation has
       started.";
  }

  typedef fs-group {
    type uint16;
    description
      "DH groups for IKE and IPsec SA rekey.";
    reference
      "IANA: Internet Key Exchange Version 2 (IKEv2) Parameters,
             IKEv2 Transform Attribute Types, Transform Type 4 -
             Diffie-Hellman Group Transform IDs
       RFC 7296: Internet Key Exchange Protocol Version 2
                 (IKEv2), Section 3.3.2.";
  }

  typedef auth-protocol-type {
    type enumeration {
      enum ikev2 {
        value 2;
        description
          "IKEv2 authentication protocol.  It is the
           only one defined right now.  An enum is
           used for further extensibility.";
      }
    }
    description
      "IKE authentication protocol version specified in the
       Peer Authorization Database (PAD).  It is defined as
       enumerated to allow new IKE versions in the
       future.";
    reference
      "RFC 7296: Internet Key Exchange Protocol Version 2
                 (IKEv2).";
  }

  typedef auth-method-type {
    type enumeration {
      enum pre-shared {
        description
          "Select pre-shared key as the
           authentication method.";
        reference
          "RFC 7296: Internet Key Exchange Protocol Version 2
                     (IKEv2).";
      }
      enum eap {
        description
          "Select the Extensible Authentication Protocol (EAP) as
           the authentication method.";
        reference
          "RFC 7296: Internet Key Exchange Protocol Version 2
                     (IKEv2).";
      }
      enum digital-signature {
        description
          "Select digital signature as the authentication method.";
        reference
          "RFC 7296: Internet Key Exchange Protocol Version 2
                     (IKEv2)
           RFC 7427: Signature Authentication in the Internet Key
                     Exchange Version 2 (IKEv2).";
      }
      enum null {
        description
          "Null authentication.";
        reference
          "RFC 7619: The NULL Authentication Method in the Internet
                     Key Exchange Protocol Version 2 (IKEv2).";
      }
    }
    description
      "Peer authentication method specified in the Peer
       Authorization Database (PAD).";
  }

  container ipsec-ike {
    description
      "IKE configuration for an NSF.  It includes PAD
       parameters, IKE connection information, and state
       data.";
    container pad {
      description
        "Configuration of the Peer Authorization Database
         (PAD).  Each entry of PAD contains authentication
         information of either the local peer or the remote peer.
         Therefore, the I2NSF Controller stores authentication
         information (and credentials) not only for the remote NSF
         but also for the local NSF.  The local NSF MAY use the
         same identity for different types of authentication
         and credentials.  Pointing to the entry for a local NSF
         (e.g., A) and the entry for remote NSF (e.g., B)
         is possible to specify all the required information to
         carry out the authentication between A and B (see
         ../conn-entry/local and ../conn-entry/remote).";
      list pad-entry {
        key "name";
        ordered-by user;
        description
          "Peer Authorization Database (PAD) entry.  It
           is a list of PAD entries ordered by the
           I2NSF Controller, and each entry is
           unequivocally identified by a name.";
        leaf name {
          type string;
          description
            "PAD-unique name to identify this
             entry.";
        }
        choice identity {
          mandatory true;
          description
            "A particular IKE peer will be
             identified by one of these identities.
             This peer can be a remote peer or local
             peer (this NSF).";
          reference
            "RFC 4301: Security Architecture for the Internet
                       Protocol, Section 4.4.3.1.";
          case ipv4-address {
            leaf ipv4-address {
              type inet:ipv4-address;
              description
                "Specifies the identity as
                 a single 4-octet IPv4 address.";
            }
          }
          case ipv6-address {
            leaf ipv6-address {
              type inet:ipv6-address;
              description
                "Specifies the identity as a
                 single 16-octet IPv6
                 address.  An example is
                 2001:db8::8:800:200c:417a.";
            }
          }
          case fqdn-string {
            leaf fqdn-string {
              type inet:domain-name;
              description
                "Specifies the identity as a
                 Fully Qualified Domain Name
                 (FQDN) string.  An example is
                 example.com.  The string MUST
                 NOT contain any terminators
                 (e.g., NULL, Carriage Return
                 (CR), etc.).";
            }
          }
          case rfc822-address-string {
            leaf rfc822-address-string {
              type string;
              description
                "Specifies the identity as a
                 fully qualified  email address
                 string (RFC 5322).  An example is
                 jsmith@example.com.  The string
                 MUST NOT contain any
                 terminators (e.g., NULL, CR,
                 etc.).";
              reference
                "RFC 5322: Internet Message Format.";
            }
          }
          case dnx509 {
            leaf dnx509 {
              type binary;
              description
                "The binary
                 Distinguished Encoding Rules (DER)
                 encoding of an ASN.1 X.500
                 Distinguished Name, as specified in IKEv2.";
              reference
                "RFC 5280: Internet X.509 Public Key Infrastructure
                           Certificate and Certificate Revocation
                           List (CRL) Profile
                 RFC 7296: Internet Key Exchange Protocol Version 2
                           (IKEv2), Section 3.5.";
            }
          }
          case gnx509 {
            leaf gnx509 {
              type binary;
              description
                "ASN.1 X.509 GeneralName structure,
                 as specified in RFC 5280, encoded
                 using ASN.1 Distinguished Encoding Rules
                 (DER), as specified in ITU-T X.690.";
              reference
                "RFC 5280: Internet X.509 Public Key Infrastructure
                           Certificate and Certificate Revocation
                           List (CRL) Profile.";
            }
          }
          case id-key {
            leaf id-key {
              type binary;
              description
                "Opaque octet stream that may be
                 used to pass vendor-specific
                 information for proprietary
                 types of identification.";
              reference
                "RFC 7296: Internet Key Exchange Protocol Version 2
                           (IKEv2), Section 3.5.";
            }
          }
          case id-null {
            leaf id-null {
              type empty;
              description
                "The ID_NULL identification is used
                 when the IKE identification payload
                 is not used.";
              reference
                "RFC 7619: The NULL Authentication Method in the
                           Internet Key Exchange Protocol Version 2
                           (IKEv2).";
            }
          }
        }
        leaf auth-protocol {
          type auth-protocol-type;
          default "ikev2";
          description
            "Only IKEv2 is supported right now, but
             other authentication protocols may be
             supported in the future.";
        }
        container peer-authentication {
          description
            "This container allows the security
             controller to configure the
             authentication method (pre-shared key,
             eap, digital-signature, null) that
             will be used with a particular peer and
             the credentials to use, which will
             depend on the selected authentication
             method.";
          leaf auth-method {
            type auth-method-type;
            default "pre-shared";
            description
              "Type of authentication method
               (pre-shared key, eap, digital signature,
               null).";
            reference
              "RFC 7296: Internet Key Exchange Protocol Version 2
                         (IKEv2), Section 2.15.";
          }
          container eap-method {
            when "../auth-method = 'eap'";
            leaf eap-type {
              type uint32 {
                range "1 .. 4294967295";
              }
              mandatory true;
              description
                "EAP method type specified with
                 a value extracted from the
                 IANA registry.  This
                 information provides the
                 particular EAP method to be
                 used.  Depending on the EAP
                 method, pre-shared keys or
                 certificates may be used.";
            }
            description
              "EAP method description used when
               authentication method is 'eap'.";
            reference
              "IANA: Extensible Authentication Protocol (EAP)
                     Registry, Method Types
               RFC 7296: Internet Key Exchange Protocol Version 2
                         (IKEv2), Section 2.16.";
          }
          container pre-shared {
            when "../auth-method[.='pre-shared' or
                  .='eap']";
            leaf secret {
              nacm:default-deny-all;
              type yang:hex-string;
              description
                "Pre-shared secret value.  The
                 NSF has to prevent read access
                 to this value for security
                 reasons.  This value MUST be
                 set if the EAP method uses a
                 pre-shared key or pre-shared
                 authentication has been chosen.";
            }
            description
              "Shared secret value for PSK or
               EAP method authentication based on
               PSK.";
          }
          container digital-signature {
            when "../auth-method[.='digital-signature'
                  or .='eap']";
            leaf ds-algorithm {
              type uint8;
              default "14";
              description
                "The digital signature
                 algorithm is specified with a
                 value extracted from the IANA
                 registry.  Default is the generic
                 digital signature method.  Depending
                 on the algorithm, the following leafs
                 MUST contain information.  For
                 example, if digital signature or the
                 EAP method involves a certificate,
                 then leaves 'cert-data' and 'private-key'
                 will contain this information.";
              reference
                "IANA: Internet Key Exchange Version 2 (IKEv2)
                       Parameters, IKEv2 Authentication Method.";
            }
            choice public-key {
              leaf raw-public-key {
                type binary;
                description
                  "A binary that contains the
                   value of the public key.  The
                   interpretation of the content
                   is defined by the digital
                   signature algorithm.  For
                   example, an RSA key is
                   represented as RSAPublicKey, as
                   defined in RFC 8017, and an
                   Elliptic Curve Cryptography
                   (ECC) key is represented
                   using the 'publicKey'
                   described in RFC 5915.";
                reference
                  "RFC 5915: Elliptic Curve Private Key
                             Structure
                   RFC 8017: PKCS #1: RSA Cryptography
                             Specifications Version 2.2.";
              }
              leaf cert-data {
                type binary;
                description
                  "X.509 certificate data in DER
                   format.  If raw-public-key is
                   defined, this leaf is empty.";
                reference
                  "RFC 5280: Internet X.509 Public Key
                             Infrastructure Certificate
                             and Certificate Revocation
                             List (CRL) Profile.";
              }
              description
                "If the I2NSF Controller
                 knows that the NSF
                 already owns a private key
                 associated to this public key
                 (e.g., the NSF generated the pair
                 public key/private key out of
                 band), it will only configure
                 one of the leaves of this
                 choice but not the leaf
                 private-key.  The NSF, based on
                 the public key value, can know
                 the private key to be used.";
            }
            leaf private-key {
              nacm:default-deny-all;
              type binary;
              description
                "A binary that contains the
                 value of the private key.  The
                 interpretation of the content
                 is defined by the digital
                 signature algorithm.  For
                 example, an RSA key is
                 represented as RSAPrivateKey, as
                 defined in RFC 8017, and an
                 Elliptic Curve Cryptography
                 (ECC) key is represented as
                 ECPrivateKey, as defined in RFC
                 5915.  This value is set
                 if public key is defined and the
                 I2NSF Controller is in charge
                 of configuring the
                 private key.  Otherwise, it is
                 not set and the value is
                 kept in secret.";
              reference
                "RFC 5915: Elliptic Curve Private Key
                           Structure
                 RFC 8017: PKCS #1: RSA Cryptography
                           Specifications Version 2.2.";
            }
            leaf-list ca-data {
              type binary;
              description
                "List of trusted Certification
                 Authorities (CAs) certificates
                 encoded using ASN.1
                 Distinguished Encoding Rules
                 (DER).  If it is not defined,
                 the default value is empty.";
            }
            leaf crl-data {
              type binary;
              description
                "A CertificateList structure, as
                 specified in RFC 5280,
                 encoded using ASN.1
                 Distinguished Encoding Rules
                 (DER), as specified in ITU-T
                 X.690.  If it is not defined,
                 the default value is empty.";
              reference
                "RFC 5280: Internet X.509 Public Key Infrastructure
                           Certificate and Certificate Revocation
                           List (CRL) Profile.";
            }
            leaf crl-uri {
              type inet:uri;
              description
                "X.509 Certificate Revocation List
                 (CRL) certificate URI.
                 If it is not defined,
                 the default value is empty.";
              reference
                "RFC 5280: Internet X.509 Public Key Infrastructure
                           Certificate and Certificate Revocation
                           List (CRL) Profile.";
            }
            leaf oscp-uri {
              type inet:uri;
              description
                "Online Certificate Status Protocol
                 (OCSP) URI.  If it is not defined,
                 the default value is empty.";
              reference
                "RFC 6960: X.509 Internet Public Key Infrastructure
                           Online Certificate Status Protocol - OCSP
                 RFC 5280: Internet X.509 Public Key Infrastructure
                           Certificate and Certificate Revocation
                           List (CRL) Profile.";
            }
            description
              "digital-signature container.";
          } /*container digital-signature*/
        } /*container peer-authentication*/
      }
    }
    list conn-entry {
      key "name";
      description
        "IKE peer connection information.  This list
         contains the IKE connection for this peer
         with other peers.  This will create, in
         real time, IKE Security Associations
         established with these nodes.";
      leaf name {
        type string;
        description
          "Identifier for this connection
           entry.";
      }
      leaf autostartup {
        type autostartup-type;
        default "add";
        description
          "By default, only add configuration
           without starting the security
           association.";
      }
      leaf initial-contact {
        type boolean;
        default "false";
        description
          "The goal of this value is to deactivate the
           usage of INITIAL_CONTACT notification
           (true).  If this flag remains set to false, it
           means the usage of the INITIAL_CONTACT
           notification will depend on the IKEv2
           implementation.";
      }
      leaf version {
        type auth-protocol-type;
        default "ikev2";
        description
          "IKE version.  Only version 2 is supported.";
      }
      container fragmentation {
        leaf enabled {
          type boolean;
          default "false";
          description
            "Whether or not to enable IKEv2
             fragmentation (true or false).";
          reference
            "RFC 7383: Internet Key Exchange Protocol Version 2
                       (IKEv2) Message Fragmentation.";
        }
        leaf mtu {
          when "../enabled='true'";
          type uint16 {
            range "68..65535";
          }
          description
            "MTU that IKEv2 can use
             for IKEv2 fragmentation.";
          reference
            "RFC 7383: Internet Key Exchange Protocol Version 2
                       (IKEv2) Message Fragmentation.";
        }
        description
          "IKEv2 fragmentation, as per RFC 7383.  If the
           IKEv2 fragmentation is enabled, it is possible
           to specify the MTU.";
      }
      container ike-sa-lifetime-soft {
        description
          "IKE SA lifetime soft.  Two lifetime values
           can be configured: either rekey time of the
           IKE SA or reauth time of the IKE SA.  When
           the rekey lifetime expires, a rekey of the
           IKE SA starts.  When reauth lifetime
           expires, an IKE SA reauthentication starts.";
        leaf rekey-time {
          type uint32;
          units "seconds";
          default "0";
          description
            "Time in seconds between each IKE SA
             rekey.  The value 0 means infinite.";
        }
        leaf reauth-time {
          type uint32;
          units "seconds";
          default "0";
          description
            "Time in seconds between each IKE SA
             reauthentication.  The value 0 means
             infinite.";
        }
        reference
          "RFC 7296: Internet Key Exchange Protocol Version 2
                     (IKEv2), Section 2.8.";
      }
      container ike-sa-lifetime-hard {
        description
          "Hard IKE SA lifetime.  When this
           time is reached, the IKE SA is removed.";
        leaf over-time {
          type uint32;
          units "seconds";
          default "0";
          description
            "Time in seconds before the IKE SA is
             removed.  The value 0 means infinite.";
        }
        reference
          "RFC 7296: Internet Key Exchange Protocol Version 2
                     (IKEv2).";
      }
      leaf-list ike-sa-intr-alg {
        type nsfikec:intr-alg-t;
        default "12";
        ordered-by user;
        description
          "Integrity algorithm for establishing
           the IKE SA.  This list is ordered following
           from the higher priority to lower priority.
           The first node of the list will be the
           algorithm with higher priority.
           Default value 12 (AUTH_HMAC_SHA2_256_128).";
      }
      list ike-sa-encr-alg {
        key "id";
        min-elements 1;
        ordered-by user;
        leaf id {
          type uint16;
          description
            "An identifier that unequivocally
             identifies each entry of the list,
             i.e., an encryption algorithm and
             its key length (if required).";
        }
        leaf algorithm-type {
          type nsfikec:encr-alg-t;
          default "12";
          description
            "Default value 12 (ENCR_AES_CBC).";
        }
        leaf key-length {
          type uint16;
          default "128";
          description
            "By default, key length is 128 bits.";
        }
        description
          "Encryption or AEAD algorithm for the IKE
           SAs.  This list is ordered following
           from the higher priority to lower priority.
           The first node of the list will be the
           algorithm with higher priority.";
      }
      leaf dh-group {
        type fs-group;
        default "14";
        description
          "Group number for Diffie-Hellman
           Exponentiation used during IKE_SA_INIT
           for the IKE SA key exchange.";
      }
      leaf half-open-ike-sa-timer {
        type uint32;
        units "seconds";
        default "0";
        description
          "Set the half-open IKE SA timeout
           duration.  The value 0 implies infinite.";
        reference
          "RFC 7296: Internet Key Exchange Protocol Version 2
                     (IKEv2), Section 2.";
      }
      leaf half-open-ike-sa-cookie-threshold {
        type uint32;
        default "0";
        description
          "Number of half-open IKE SAs that activate
           the cookie mechanism.  The value 0 implies
           infinite.";
        reference
          "RFC 7296: Internet Key Exchange Protocol Version 2
                     (IKEv2), Section 2.6.";
      }
      container local {
        leaf local-pad-entry-name {
          type string;
          mandatory true;
          description
            "Local peer authentication information.
             This node points to a specific entry in
             the PAD where the authorization
             information about this particular local
             peer is stored.  It MUST match a
             pad-entry-name.";
        }
        description
          "Local peer authentication information.";
      }
      container remote {
        leaf remote-pad-entry-name {
          type string;
          mandatory true;
          description
            "Remote peer authentication information.
             This node points to a specific entry in
             the PAD where the authorization
             information about this particular
             remote peer is stored.  It MUST match a
             pad-entry-name.";
        }
        description
          "Remote peer authentication information.";
      }
      container encapsulation-type {
        uses nsfikec:encap;
        description
          "This container carries configuration
           information about the source and destination
           ports of encapsulation that IKE should use
           and the type of encapsulation that
           should be used when NAT traversal is required.
           However, this is just a best effort since
           the IKE implementation may need to use a
           different encapsulation, as described in
           RFC 8229.";
        reference
          "RFC 8229: TCP Encapsulation of IKE and IPsec
                     Packets.";
      }
      container spd {
        description
          "Configuration of the Security Policy
           Database (SPD).  This main information is
           placed in the grouping
           ipsec-policy-grouping.";
        list spd-entry {
          key "name";
          ordered-by user;
          leaf name {
            type string;
            description
              "SPD-entry-unique name to identify
               the IPsec policy.";
          }
          container ipsec-policy-config {
            description
              "This container carries the
               configuration of an IPsec policy.";
            uses nsfikec:ipsec-policy-grouping;
          }
          description
            "List of entries that will constitute
             the representation of the SPD.  In this
             case, since the NSF implements IKE, it
             is only required to send an IPsec policy
             from this NSF where 'local' is this NSF
             and 'remote' the other NSF.  The IKE
             implementation will install IPsec
             policies in the NSF's kernel in both
             directions (inbound and outbound) and
             their corresponding IPsec SAs based on
             the information in this SPD entry.";
        }
        reference
          "RFC 7296: Internet Key Exchange Protocol Version 2
                     (IKEv2), Section 2.9.";
      }
      container child-sa-info {
        leaf-list fs-groups {
          type fs-group;
          default "0";
          ordered-by user;
          description
            "If non-zero, forward secrecy is
             required when a new IPsec SA is being
             created, the (non-zero) value indicates
             the group number to use for the key
             exchange process used to achieve forward
             secrecy.
             This list is ordered following from the
             higher priority to lower priority.  The
             first node of the list will be the
             algorithm with higher priority.";
        }
        container child-sa-lifetime-soft {
          description
            "Soft IPsec SA lifetime.
             After the lifetime, the action is
             defined in this container
             in the leaf action.";
          uses nsfikec:lifetime;
          leaf action {
            type nsfikec:lifetime-action;
            default "replace";
            description
              "When the lifetime of an IPsec SA
               expires, an action needs to be
               performed over the IPsec SA that
               reached the lifetime.  There are
               three possible options:
               terminate-clear, terminate-hold, and
               replace.";
            reference
              "RFC 4301: Security Architecture for the Internet
                         Protocol, Section 4.5
               RFC 7296: Internet Key Exchange Protocol Version 2
                         (IKEv2), Section 2.8.";
          }
        }
        container child-sa-lifetime-hard {
          description
            "IPsec SA lifetime hard.  The action will
             be to terminate the IPsec SA.";
          uses nsfikec:lifetime;
          reference
            "RFC 7296: Internet Key Exchange Protocol Version 2
                       (IKEv2), Section 2.8.";
        }
        description
          "Specific information for IPsec SAs.
           It includes the Perfect Forward Secrecy (PFS)
           group and IPsec SAs rekey lifetimes.";
      }
      container state {
        config false;
        leaf initiator {
          type boolean;
          description
            "It is acting as an initiator for this
             connection.";
        }
        leaf initiator-ikesa-spi {
          type ike-spi;
          description
            "Initiator's IKE SA SPI.";
        }
        leaf responder-ikesa-spi {
          type ike-spi;
          description
            "Responder's IKE SA SPI.";
        }
        leaf nat-local {
          type boolean;
          description
            "True if local endpoint is behind a
             NAT.";
        }
        leaf nat-remote {
          type boolean;
          description
            "True if remote endpoint is behind
             a NAT.";
        }
        container encapsulation-type {
          uses nsfikec:encap;
          description
            "This container provides information
             about the source and destination
             ports of encapsulation that IKE is
             using and the type of encapsulation
             when NAT traversal is required.";
          reference
            "RFC 8229: TCP Encapsulation of IKE and IPsec Packets.";
        }
        leaf established {
          type uint64;
          units "seconds";
          description
            "Seconds since this IKE SA has been
             established.";
        }
        leaf current-rekey-time {
          type uint64;
          units "seconds";
          description
            "Seconds before IKE SA is rekeyed.";
        }
        leaf current-reauth-time {
          type uint64;
          units "seconds";
          description
            "Seconds before IKE SA is
             reauthenticated.";
        }
        description
          "IKE state data for a particular
           connection.";
      } /* ike-sa-state */
    } /* ike-conn-entries */
    container number-ike-sas {
      config false;
      leaf total {
        type yang:gauge64;
        description
          "Total number of active IKE SAs.";
      }
      leaf half-open {
        type yang:gauge64;
        description
          "Number of half-open active IKE SAs.";
      }
      leaf half-open-cookies {
        type yang:gauge64;
        description
          "Number of half-open active IKE SAs with
           cookie activated.";
      }
      description
        "General information about the IKE SAs.  In
         particular, it provides the current number of
         IKE SAs.";
    }
  } /* container ipsec-ike */
}

<CODE ENDS>
```

[¶](#section-5.2.3-2){.pilcrow}
:::
:::
:::
:::
:::

::: {#ike-less-model}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [The \'ietf-i2nsf-ikeless\' Module](#name-the-ietf-i2nsf-ikeless-modu){.section-name .selfRef} {#name-the-ietf-i2nsf-ikeless-modu}

In this section, the YANG module for the IKE-less case is
described.[¶](#section-5.3-1){.pilcrow}

::: {#ikeless-overview}
::: {#section-5.3.1 .section}
#### [5.3.1.](#section-5.3.1){.section-number .selfRef} [Data Model Overview](#name-data-model-overview-3){.section-name .selfRef} {#name-data-model-overview-3}

For this case, the definition of the SPD model has been mainly extracted
from the specification in Section
[4.4.1](https://www.rfc-editor.org/rfc/rfc4301#section-4.4.1){.relref}
and Appendix
[D](https://www.rfc-editor.org/rfc/rfc4301#appendix-D){.relref} in
\[[RFC4301](#RFC4301){.xref}\], though with some changes,
namely:[¶](#section-5.3.1-1){.pilcrow}

-   [For simplicity, each IPsec policy (spd-entry) contains one Traffic
    Selector, instead of a list of them. The reason is that actual
    kernel implementations only admit a single Traffic Selector per
    IPsec policy.[¶](#section-5.3.1-2.1){.pilcrow}]{#section-5.3.1-2.1}
-   [Each IPsec policy contains an identifier (reqid) to relate the
    policy with the IPsec SA. This is common in Linux-based
    systems.[¶](#section-5.3.1-2.2){.pilcrow}]{#section-5.3.1-2.2}
-   [Each IPsec policy has only one name and not a list of
    names.[¶](#section-5.3.1-2.3){.pilcrow}]{#section-5.3.1-2.3}
-   [Combined algorithms have been removed because encryption algorithms
    [MAY]{.bcp14} include Authenticated Encryption with Associated Data
    (AEAD).[¶](#section-5.3.1-2.4){.pilcrow}]{#section-5.3.1-2.4}
-   [Tunnel information has been extended with information about DSCP
    mapping. The reason is that certain kernel implementations accept
    configuration of these
    values.[¶](#section-5.3.1-2.5){.pilcrow}]{#section-5.3.1-2.5}

The definition of the SAD model has been mainly extracted from the
specification in [Section
4.4.2](https://www.rfc-editor.org/rfc/rfc4301#section-4.4.2){.relref} of
\[[RFC4301](#RFC4301){.xref}\], though with some changes,
namely:[¶](#section-5.3.1-3){.pilcrow}

-   [For simplicity, each IPsec SA (sad-entry) contains one Traffic
    Selector, instead of a list of them. The reason is that actual
    kernel implementations only admit a single Traffic Selector per
    IPsec SA.[¶](#section-5.3.1-4.1){.pilcrow}]{#section-5.3.1-4.1}
-   [Each IPsec SA contains an identifier (reqid) to relate the IPsec SA
    with the IPsec policy. The reason is that real kernel
    implementations allow this value to be
    included.[¶](#section-5.3.1-4.2){.pilcrow}]{#section-5.3.1-4.2}
-   [Each IPsec SA is also named in the same way as IPsec
    policies.[¶](#section-5.3.1-4.3){.pilcrow}]{#section-5.3.1-4.3}
-   [The model allows specifying the algorithm for encryption. This can
    be Authenticated Encryption with Associated Data (AEAD) or non-AEAD.
    If an AEAD algorithm is specified, the integrity algorithm is not
    required. If a non-AEAD algorithm is specified, the integrity
    algorithm is required
    \[[RFC8221](#RFC8221){.xref}\].[¶](#section-5.3.1-4.4){.pilcrow}]{#section-5.3.1-4.4}
-   [Tunnel information has been extended with information about
    Differentiated Services Code Point (DSCP) mapping. It is assumed
    that NSFs involved in this document provide ECN full functionality
    to prevent discarding of ECN congestion indications
    \[[RFC6040](#RFC6040){.xref}\].[¶](#section-5.3.1-4.5){.pilcrow}]{#section-5.3.1-4.5}
-   [The lifetime of the IPsec SAs also includes idle time and the
    number of IP packets as a threshold to trigger the lifetime. The
    reason is that actual kernel implementations allow for setting these
    types of
    lifetimes.[¶](#section-5.3.1-4.6){.pilcrow}]{#section-5.3.1-4.6}
-   [Information to configure the type of encapsulation
    (encapsulation-type) for IPsec ESP packets in UDP
    \[[RFC3948](#RFC3948){.xref}\] or TCP \[[RFC8229](#RFC8229){.xref}\]
    has been
    included.[¶](#section-5.3.1-4.7){.pilcrow}]{#section-5.3.1-4.7}

The notifications model has been defined using, as reference, the
PF_KEYv2 specification in
\[[RFC2367](#RFC2367){.xref}\].[¶](#section-5.3.1-5){.pilcrow}

The YANG data model for the IKE-less case is defined by the module
\"ietf-i2nsf-ikeless\". Its structure is depicted in the following
diagram, using the notation syntax for YANG tree diagrams
\[[RFC8340](#RFC8340){.xref}\].[¶](#section-5.3.1-6){.pilcrow}

::: {#section-5.3.1-7}
``` {.sourcecode .lang-yangtree}
module: ietf-i2nsf-ikeless
  +--rw ipsec-ikeless
    +--rw spd
    |  +--rw spd-entry* [name]
    |     +--rw name  string
    |     +--rw direction nsfikec:ipsec-traffic-direction
    |     +--rw reqid? uint64
    |     +--rw ipsec-policy-config
    |        +--rw anti-replay-window-size?   uint32
    |        +--rw traffic-selector
    |        |  +--rw local-prefix      inet:ip-prefix
    |        |  +--rw remote-prefix     inet:ip-prefix
    |        |  +--rw inner-protocol?   ipsec-inner-protocol
    |        |  +--rw local-ports* [start end]
    |        |  |  +--rw start    inet:port-number
    |        |  |  +--rw end      inet:port-number
    |        |  +--rw remote-ports* [start end]
    |        |     +--rw start    inet:port-number
    |        |     +--rw end      inet:port-number
    |        +--rw processing-info
    |           +--rw action?         ipsec-spd-action
    |           +--rw ipsec-sa-cfg
    |             +--rw pfp-flag?              boolean
    |             +--rw ext-seq-num?           boolean
    |             +--rw seq-overflow?          boolean
    |             +--rw stateful-frag-check?   boolean
    |             +--rw mode?                  ipsec-mode
    |             +--rw protocol-parameters? ipsec-protocol-params
    |              +--rw esp-algorithms
    |              |  +--rw integrity*    intr-alg-t
    |              |  +--rw encryption* [id]
    |              |  |  +--rw id                uint16
    |              |  |  +--rw algorithm-type?   encr-alg-t
    |              |  |  +--rw key-length?       uint16
    |              |  +--rw tfc-pad?      boolean
    |              +--rw tunnel
    |                 +--rw local           inet:ip-address
    |                 +--rw remote          inet:ip-address
    |                 +--rw df-bit?         enumeration
    |                 +--rw bypass-dscp?    boolean
    |                 +--rw dscp-mapping* [id]
    |                    +--rw id            uint8
    |                    +--rw inner-dscp?   inet:dscp
    |                    +--rw outer-dscp?   inet:dscp
    +--rw sad
      +--rw sad-entry* [name]
       +--rw name               string
       +--rw reqid?             uint64
       +--rw ipsec-sa-config
       |  +--rw spi                        uint32
       |  +--rw ext-seq-num?               boolean
       |  +--rw seq-overflow?              boolean
       |  +--rw anti-replay-window-size?   uint32
       |  +--rw traffic-selector
       |  |  +--rw local-prefix      inet:ip-prefix
       |  |  +--rw remote-prefix     inet:ip-prefix
       |  |  +--rw inner-protocol?   ipsec-inner-protocol
       |  |  +--rw local-ports* [start end]
       |  |  |  +--rw start    inet:port-number
       |  |  |  +--rw end      inet:port-number
       |  |  +--rw remote-ports* [start end]
       |  |     +--rw start    inet:port-number
       |  |     +--rw end      inet:port-number
       |  +--rw protocol-parameters? nsfikec:ipsec-protocol-params
       |  +--rw mode?                      nsfikec:ipsec-mode
       |  +--rw esp-sa
       |  |  +--rw encryption
       |  |  |  +--rw encryption-algorithm?   nsfikec:encr-alg-t
       |  |  |  +--rw key?                    yang:hex-string
       |  |  |  +--rw iv?                     yang:hex-string
       |  |  +--rw integrity
       |  |     +--rw integrity-algorithm?   nsfikec:intr-alg-t
       |  |     +--rw key?                   yang:hex-string
       |  +--rw sa-lifetime-hard
       |  |  +--rw time?      uint32
       |  |  +--rw bytes?     yang:counter64
       |  |  +--rw packets?   uint32
       |  |  +--rw idle?      uint32
       |  +--rw sa-lifetime-soft
       |  |  +--rw time?      uint32
       |  |  +--rw bytes?     yang:counter64
       |  |  +--rw packets?   uint32
       |  |  +--rw idle?      uint32
       |  |  +--rw action?    nsfikec:lifetime-action
       |  +--rw tunnel
       |  |  +--rw local           inet:ip-address
       |  |  +--rw remote          inet:ip-address
       |  |  +--rw df-bit?         enumeration
       |  |  +--rw bypass-dscp?    boolean
       |  |  +--rw dscp-mapping* [id]
       |  |  |  +--rw id            uint8
       |  |  |  +--rw inner-dscp?   inet:dscp
       |  |  |  +--rw outer-dscp?   inet:dscp
       |  |  +--rw dscp-values*    inet:dscp
       |  +--rw encapsulation-type
       |     +--rw espencap?   esp-encap
       |     +--rw sport?      inet:port-number
       |     +--rw dport?      inet:port-number
       |     +--rw oaddr*      inet:ip-address
       +--ro ipsec-sa-state
          +--ro sa-lifetime-current
          |  +--ro time?      uint32
          |  +--ro bytes?     yang:counter64
          |  +--ro packets?   uint32
          |  +--ro idle?      uint32
          +--ro replay-stats
             +--ro replay-window
             |  +--ro w?   uint32
             |  +--ro t?   uint64
             |  +--ro b?   uint64
             +--ro packet-dropped?       yang:counter64
             +--ro failed?               yang:counter64
             +--ro seq-number-counter?   uint64

   notifications:
     +---n sadb-acquire {ikeless-notification}?
     |  +--ro ipsec-policy-name    string
     |  +--ro traffic-selector
     |     +--ro local-prefix      inet:ip-prefix
     |     +--ro remote-prefix     inet:ip-prefix
     |     +--ro inner-protocol?   ipsec-inner-protocol
     |     +--ro local-ports* [start end]
     |     |  +--ro start    inet:port-number
     |     |  +--ro end      inet:port-number
     |     +--ro remote-ports* [start end]
     |        +--ro start    inet:port-number
     |        +--ro end      inet:port-number
     +---n sadb-expire {ikeless-notification}?
     |  +--ro ipsec-sa-name           string
     |  +--ro soft-lifetime-expire?   boolean
     |  +--ro lifetime-current
     |     +--ro time?      uint32
     |     +--ro bytes?     yang:counter64
     |     +--ro packets?   uint32
     |     +--ro idle?      uint32
     +---n sadb-seq-overflow {ikeless-notification}?
     |  +--ro ipsec-sa-name    string
     +---n sadb-bad-spi {ikeless-notification}?
        +--ro spi    uint32
```

[¶](#section-5.3.1-7){.pilcrow}
:::

The YANG data model consists of a unique \"ipsec-ikeless\" container,
which, in turn, is composed of two additional containers: \"spd\" and
\"sad\". The \"spd\" container consists of a list of entries that form
the Security Policy Database. Compared to the IKE case YANG data model,
this part specifies a few additional parameters necessary due to the
absence of an IKE software in the NSF: traffic direction to apply the
IPsec policy and a \"reqid\" value to link an IPsec policy with its
associated IPsec SAs since it is otherwise a little hard to find by
searching. The \"sad\" container is a list of entries that form the
Security Association Database. In general, each entry allows specifying
both configuration information (SPI, Traffic Selectors, tunnel/transport
mode, cryptographic algorithms and keying material, soft/hard lifetimes,
etc.) as well as stating information (time to expire, replay statistics,
etc.) of a concrete IPsec SA.[¶](#section-5.3.1-8){.pilcrow}

In addition, the module defines a set of notifications to allow the NSF
to inform the I2NSF Controller about relevant events, such as IPsec SA
expiration, sequence number overflow, or bad SPI in a received
packet.[¶](#section-5.3.1-9){.pilcrow}
:::
:::

::: {#ikeless-examples}
::: {#section-5.3.2 .section}
#### [5.3.2.](#section-5.3.2){.section-number .selfRef} [Example Usage](#name-example-usage-2){.section-name .selfRef} {#name-example-usage-2}

[Appendix B](#appendix-e){.xref} shows an example of an IKE-less case
configuration for an NSF in transport mode (host-to-host). Additionally,
[Appendix C](#appendix-f){.xref} shows examples of IPsec SA expire,
acquire, sequence number overflow, and bad SPI
notifications.[¶](#section-5.3.2-1){.pilcrow}
:::
:::

::: {#ikeless-module}
::: {#section-5.3.3 .section}
#### [5.3.3.](#section-5.3.3){.section-number .selfRef} [YANG Module](#name-yang-module-3){.section-name .selfRef} {#name-yang-module-3}

This YANG module has normative references to
\[[RFC4301](#RFC4301){.xref}\], \[[RFC4303](#RFC4303){.xref}\],
\[[RFC6991](#RFC6991){.xref}\], \[[RFC8174](#RFC8174){.xref}\] and
\[[RFC8341](#RFC8341){.xref}\].[¶](#section-5.3.3-1){.pilcrow}

::: {#section-5.3.3-2}
``` {.sourcecode .lang-yang}
<CODE BEGINS> file "ietf-i2nsf-ikeless@2021-07-14.yang"


module ietf-i2nsf-ikeless {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless";
  prefix nsfikels;

  import ietf-inet-types {
    prefix inet;
    reference
      "RFC 6991: Common YANG Data Types.";
  }
  import ietf-yang-types {
    prefix yang;
    reference
      "RFC 6991: Common YANG Data Types.";
  }
  import ietf-i2nsf-ikec {
    prefix nsfikec;
    reference
      "RFC 9061: A YANG Data Model for IPsec Flow Protection
                 Based on Software-Defined Networking (SDN).";
  }
  import ietf-netconf-acm {
    prefix nacm;
    reference
      "RFC 8341: Network Configuration Access Control
                 Model.";
  }

  organization
    "IETF I2NSF Working Group";
  contact
    "WG Web:  <https://datatracker.ietf.org/wg/i2nsf/>
     WG List: <mailto:i2nsf@ietf.org>

     Author: Rafael Marin-Lopez
              <mailto:rafa@um.es>

     Author: Gabriel Lopez-Millan
              <mailto:gabilm@um.es>

     Author: Fernando Pereniguez-Garcia
              <mailto:fernando.pereniguez@cud.upct.es>
    ";
  description
    "Data model for IKE-less case in the SDN-based IPsec flow
     protection service.

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL',
     'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED',
     'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this
     document are to be interpreted as described in BCP 14
     (RFC 2119) (RFC 8174) when, and only when, they appear
     in all capitals, as shown here.

     Copyright (c) 2021 IETF Trust and the persons
     identified as authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 9061; see
     the RFC itself for full legal notices.";

  revision 2021-07-14 {
    description
      "Initial version.";
    reference
      "RFC 9061: A YANG Data Model for IPsec Flow Protection
                 Based on Software-Defined Networking (SDN).";
  }

  feature ikeless-notification {
    description
      "This feature indicates that the server supports
       generating notifications in the ikeless module.

       To ensure broader applicability of this module,
       the notifications are marked as a feature.
       For the implementation of the IKE-less case,
       the NSF is expected to implement this
       feature.";
  }

  container ipsec-ikeless {
    description
      "Container for configuration of the IKE-less
       case. The container contains two additional
       containers: 'spd' and 'sad'.  The first allows the
       I2NSF Controller to configure IPsec policies in
       the Security Policy Database (SPD), and the second
       allows the I2NSF Controller to configure IPsec
       Security Associations (IPsec SAs) in the Security
       Association Database (SAD).";
    reference
      "RFC 4301: Security Architecture for the Internet Protocol.";
    container spd {
      description
        "Configuration of the Security Policy Database
         (SPD).";
      reference
        "RFC 4301: Security Architecture for the Internet Protocol,
                   Section 4.4.1.2.";
      list spd-entry {
        key "name";
        ordered-by user;
        leaf name {
          type string;
          description
            "SPD-entry-unique name to identify this
             entry.";
        }
        leaf direction {
          type nsfikec:ipsec-traffic-direction;
          mandatory true;
          description
            "Inbound traffic or outbound
             traffic.  In the IKE-less case, the
             I2NSF Controller needs to
             specify the policy direction to be
             applied in the NSF.  In the IKE case,
             this direction does not need to be
             specified, since IKE
             will determine the direction that the
             IPsec policy will require.";
        }
        leaf reqid {
          type uint64;
          default "0";
          description
            "This value allows linking this
             IPsec policy with IPsec SAs with the
             same reqid.  It is only required in
             the IKE-less model since, in the IKE
             case, this link is handled internally
             by IKE.";
        }
        container ipsec-policy-config {
          description
            "This container carries the
             configuration of an IPsec policy.";
          uses nsfikec:ipsec-policy-grouping;
        }
        description
          "The SPD is represented as a list of SPD
           entries, where each SPD entry represents an
           IPsec policy.";
      } /*list spd-entry*/
    } /*container spd*/
    container sad {
      description
        "Configuration of the IPsec Security Association
         Database (SAD).";
      reference
        "RFC 4301: Security Architecture for the Internet Protocol,
                   Section 4.4.2.1.";
      list sad-entry {
        key "name";
        ordered-by user;
        leaf name {
          type string;
          description
            "SAD-entry-unique name to identify this
             entry.";
        }
        leaf reqid {
          type uint64;
          default "0";
          description
            "This value allows linking this
             IPsec SA with an IPsec policy with
             the same reqid.";
        }
        container ipsec-sa-config {
          description
            "This container allows configuring
             details of an IPsec SA.";
          leaf spi {
            type uint32 {
              range "0..max";
            }
            mandatory true;
            description
              "IPsec SA of Security Parameter Index (SPI).";
          }
          leaf ext-seq-num {
            type boolean;
            default "true";
            description
              "True if this IPsec SA is using extended
               sequence numbers.  If true, the 64-bit
               extended sequence number counter is used;
               if false, the normal 32-bit sequence
               number counter is used.";
          }
          leaf seq-overflow {
            type boolean;
            default "false";
            description
              "The flag indicating whether
               overflow of the sequence number
               counter should prevent transmission
               of additional packets on the IPsec
               SA (false) and, therefore, needs to
               be rekeyed or whether rollover is
               permitted (true).  If Authenticated
               Encryption with Associated Data
               (AEAD) is used (leaf
               esp-algorithms/encryption/algorithm-type),
               this flag MUST BE false. Setting this
               flag to true is strongly discouraged.";
          }
          leaf anti-replay-window-size {
            type uint32;
            default "64";
            description
              "To set the anti-replay window size.
               The default value is set to 64,
               following the recommendation in RFC 4303.";
            reference
              "RFC 4303: IP Encapsulating Security Payload (ESP),
                         Section 3.4.3.";
          }
          container traffic-selector {
            uses nsfikec:selector-grouping;
            description
              "The IPsec SA Traffic Selector.";
          }
          leaf protocol-parameters {
            type nsfikec:ipsec-protocol-params;
            default "esp";
            description
              "Security protocol of IPsec SA, only
               ESP so far.";
          }
          leaf mode {
            type nsfikec:ipsec-mode;
            default "transport";
            description
              "Tunnel or transport mode.";
          }
          container esp-sa {
            when "../protocol-parameters = 'esp'";
            description
              "In case the IPsec SA is an
               Encapsulation Security Payload
               (ESP), it is required to specify
               encryption and integrity
               algorithms and key materials.";
            container encryption {
              description
                "Configuration of encryption or
                 AEAD algorithm for IPsec
                 Encapsulation Security Payload
                 (ESP).";
              leaf encryption-algorithm {
                type nsfikec:encr-alg-t;
                default "12";
                description
                  "Configuration of ESP
                   encryption.  With AEAD
                   algorithms, the integrity-algorithm
                   leaf is not used.";
              }
              leaf key {
                nacm:default-deny-all;
                type yang:hex-string;
                description
                  "ESP encryption key value.
                   If this leaf is not defined,
                   the key is not defined
                   (e.g., encryption is NULL).
                   The key length is
                   determined by the
                   length of the key set in
                   this leaf.  By default, it is
                   128 bits.";
              }
              leaf iv {
                nacm:default-deny-all;
                type yang:hex-string;
                description
                  "ESP encryption IV value.  If
                   this leaf is not defined, the
                   IV is not defined (e.g.,
                   encryption is NULL).";
              }
            }
            container integrity {
              description
                "Configuration of integrity for
                 IPsec Encapsulation Security
                 Payload (ESP).  This container
                 allows configuration of integrity
                 algorithms when no AEAD
                 algorithms are used and
                 integrity is required.";
              leaf integrity-algorithm {
                type nsfikec:intr-alg-t;
                default "12";
                description
                  "Message Authentication Code
                   (MAC) algorithm to provide
                   integrity in ESP (default
                   AUTH_HMAC_SHA2_256_128).
                   With AEAD algorithms,
                   the integrity leaf is not
                   used.";
              }
              leaf key {
                nacm:default-deny-all;
                type yang:hex-string;
                description
                  "ESP integrity key value.
                   If this leaf is not defined,
                   the key is not defined (e.g.,
                   AEAD algorithm is chosen and
                   integrity algorithm is not
                   required).  The key length is
                   determined by the length of
                   the key configured.";
              }
            }
          } /*container esp-sa*/
          container sa-lifetime-hard {
            description
              "IPsec SA hard lifetime.  The action
               associated is terminate and hold.";
            uses nsfikec:lifetime;
          }
          container sa-lifetime-soft {
            description
              "IPsec SA soft lifetime.";
            uses nsfikec:lifetime;
            leaf action {
              type nsfikec:lifetime-action;
              description
                "Action lifetime: terminate-clear,
                 terminate-hold, or replace.";
            }
          }
          container tunnel {
            when "../mode = 'tunnel'";
            uses nsfikec:tunnel-grouping;
            leaf-list dscp-values {
              type inet:dscp;
              description
                "DSCP values allowed for ingress packets carried
                 over this IPsec SA.  If no values are specified, no
                 DSCP-specific filtering is applied.  When
                 ../bypass-dscp is false and a dscp-mapping is
                 defined, each value here would be the same as the
                 'inner' DSCP value for the DSCP mapping (list
                 dscp-mapping).";
              reference
                "RFC 4301: Security Architecture for the Internet
                           Protocol, Section 4.4.2.1.";
            }
            description
              "Endpoints of the IPsec tunnel.";
          }
          container encapsulation-type {
            uses nsfikec:encap;
            description
              "This container carries
               configuration information about
               the source and destination ports
               that will be used for ESP
               encapsulation of ESP packets and
               the type of encapsulation when NAT
               traversal is in place.";
          }
        } /*ipsec-sa-config*/
        container ipsec-sa-state {
          config false;
          description
            "Container describing IPsec SA state
             data.";
          container sa-lifetime-current {
            uses nsfikec:lifetime;
            description
              "SAD lifetime current.";
          }
          container replay-stats {
            description
              "State data about the anti-replay
               window.";
            container replay-window {
              leaf w {
                type uint32;
                description
                  "Size of the replay window.";
              }
              leaf t {
                type uint64;
                description
                  "Highest sequence number
                   authenticated so far,
                   upper bound of window.";
              }
              leaf b {
                type uint64;
                description
                  "Lower bound of window.";
              }
              description
                "This container contains three
                 parameters that define the state
                 of the replay window: window size (w),
                 highest sequence number authenticated (t),
                 and lower bound of the window (b), according
                 to Appendix A2.1 in RFC 4303 (w = t - b + 1).";
              reference
                "RFC 4303: IP Encapsulating Security Payload (ESP),
                           Appendix A.";
            }
            leaf packet-dropped {
              type yang:counter64;
              description
                "Packets dropped
                 because they are
                 replay packets.";
            }
            leaf failed {
              type yang:counter64;
              description
                "Number of packets detected out
                 of the replay window.";
            }
            leaf seq-number-counter {
              type uint64;
              description
                "A 64-bit counter when this
                 IPsec SA is using Extended
                 Sequence Number or 32-bit
                 counter when it is not.
                 Current value of sequence
                 number.";
            }
          } /* container replay-stats*/
        } /*ipsec-sa-state*/
        description
          "List of SAD entries that form the SAD.";
      } /*list sad-entry*/
    } /*container sad*/
  } /*container ipsec-ikeless*/

  /* Notifications */

  notification sadb-acquire {
    if-feature "ikeless-notification";
    description
      "The NSF detects and notifies that
       an IPsec SA is required for an
       outbound IP packet that has matched an SPD entry.
       The traffic-selector container in this
       notification contains information about
       the IP packet that triggered this
       notification.";
    leaf ipsec-policy-name {
      type string;
      mandatory true;
      description
        "It contains the SPD entry name (unique) of
         the IPsec policy that hits the IP-packet-required
         IPsec SA.  It is assumed the
         I2NSF Controller will have a copy of the
         information of this policy so it can
         extract all the information with this
         unique identifier.  The type of IPsec SA is
         defined in the policy so the security
         controller can also know the type of IPsec
         SA that MUST be generated.";
    }
    container traffic-selector {
      description
        "The IP packet that triggered the acquire
         and requires an IPsec SA.  Specifically, it
         will contain the IP source/mask and IP
         destination/mask, protocol (udp, tcp,
         etc.), and source and destination
         ports.";
      uses nsfikec:selector-grouping;
    }
  }

  notification sadb-expire {
    if-feature "ikeless-notification";
    description
      "An IPsec SA expiration (soft or hard).";
    leaf ipsec-sa-name {
      type string;
      mandatory true;
      description
        "It contains the SAD entry name (unique) of
         the IPsec SA that is about to expire.  It is assumed
         the I2NSF Controller will have a copy of the
         IPsec SA information (except the cryptographic
         material and state data) indexed by this name
         (unique identifier) so it can know all the
         information (crypto algorithms, etc.) about
         the IPsec SA that has expired in order to
         perform a rekey (soft lifetime) or delete it
         (hard lifetime) with this unique identifier.";
    }
    leaf soft-lifetime-expire {
      type boolean;
      default "true";
      description
        "If this value is true, the lifetime expired is
         soft.  If it is false, the lifetime is hard.";
    }
    container lifetime-current {
      description
        "IPsec SA current lifetime.  If
         soft-lifetime-expired is true,
         this container is set with the
         lifetime information about current
         soft lifetime.
         It can help the NSF Controller
         to know which of the (soft) lifetime
         limits raised the event: time, bytes,
         packets, or idle.";
      uses nsfikec:lifetime;
    }
  }

  notification sadb-seq-overflow {
    if-feature "ikeless-notification";
    description
      "Sequence overflow notification.";
    leaf ipsec-sa-name {
      type string;
      mandatory true;
      description
        "It contains the SAD entry name (unique) of
         the IPsec SA that is about to have a sequence
         number overflow, and rollover is not permitted.
         When the NSF issues this event before reaching
         a sequence number, overflow is implementation
         specific and out of scope of this specification.
         It is assumed the I2NSF Controller will have a
         copy of the IPsec SA information (except the
         cryptographic material and state data) indexed
         by this name (unique identifier) so it can
         know all the information (crypto algorithms,
         etc.) about the IPsec SA in
         order to perform a rekey of the IPsec SA.";
    }
  }

  notification sadb-bad-spi {
    if-feature "ikeless-notification";
    description
      "Notify when the NSF receives a packet with an
       incorrect SPI (i.e., not present in the SAD).";
    leaf spi {
      type uint32 {
        range "0..max";
      }
      mandatory true;
      description
        "SPI number contained in the erroneous IPsec
         packet.";
    }
  }
}

<CODE ENDS>
```

[¶](#section-5.3.3-2){.pilcrow}
:::
:::
:::
:::
:::
:::
:::

::: {#iana}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

IANA has registered the following namespaces in the \"ns\" subregistry
within the \"IETF XML Registry\"
\[[RFC3688](#RFC3688){.xref}\]:[¶](#section-6-1){.pilcrow}

[]{.break}

URI:
:   urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikec[¶](#section-6-2.2){.pilcrow}
:   

Registrant Contact:
:   The IESG.[¶](#section-6-2.4){.pilcrow}
:   

XML:
:   N/A, the requested URI is an XML
    namespace.[¶](#section-6-2.6){.pilcrow}
:   

[]{.break}

URI:
:   urn:ietf:params:xml:ns:yang:ietf-i2nsf-ike[¶](#section-6-3.2){.pilcrow}
:   

Registrant Contact:
:   The IESG.[¶](#section-6-3.4){.pilcrow}
:   

XML:
:   N/A, the requested URI is an XML
    namespace.[¶](#section-6-3.6){.pilcrow}
:   

[]{.break}

URI:
:   urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless[¶](#section-6-4.2){.pilcrow}
:   

Registrant Contact:
:   The IESG.[¶](#section-6-4.4){.pilcrow}
:   

XML:
:   N/A, the requested URI is an XML
    namespace.[¶](#section-6-4.6){.pilcrow}
:   

IANA has registered the following YANG modules in the \"YANG Module
Names\" registry
\[[RFC6020](#RFC6020){.xref}\]:[¶](#section-6-5){.pilcrow}

[]{.break}

Name:
:   ietf-i2nsf-ikec[¶](#section-6-6.2){.pilcrow}
:   

Maintained by IANA:
:   N[¶](#section-6-6.4){.pilcrow}
:   

Namespace:
:   urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikec[¶](#section-6-6.6){.pilcrow}
:   

Prefix:
:   nsfikec[¶](#section-6-6.8){.pilcrow}
:   

Reference:
:   RFC 9061[¶](#section-6-6.10){.pilcrow}
:   

[]{.break}

Name:
:   ietf-i2nsf-ike[¶](#section-6-7.2){.pilcrow}
:   

Maintained by IANA:
:   N[¶](#section-6-7.4){.pilcrow}
:   

Namespace:
:   urn:ietf:params:xml:ns:yang:ietf-i2nsf-ike[¶](#section-6-7.6){.pilcrow}
:   

Prefix:
:   nsfike[¶](#section-6-7.8){.pilcrow}
:   

Reference:
:   RFC 9061[¶](#section-6-7.10){.pilcrow}
:   

[]{.break}

Name:
:   ietf-i2nsf-ikeless[¶](#section-6-8.2){.pilcrow}
:   

Maintained by IANA:
:   N[¶](#section-6-8.4){.pilcrow}
:   

Namespace:
:   urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless[¶](#section-6-8.6){.pilcrow}
:   

Prefix:
:   nsfikels[¶](#section-6-8.8){.pilcrow}
:   

Reference:
:   RFC 9061[¶](#section-6-8.10){.pilcrow}
:   
:::
:::

::: {#security}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

First of all, this document shares all the security issues of SDN that
are specified in the Security Considerations sections of
\[[ITU-T.Y.3300](#ITU-T.Y.3300){.xref}\] and
\[[RFC7426](#RFC7426){.xref}\].[¶](#section-7-1){.pilcrow}

On the one hand, it is important to note that there [MUST]{.bcp14} exist
a security association between the I2NSF Controller and the NSFs to
protect the critical information (cryptographic keys, configuration
parameter, etc.) exchanged between these entities. The nature of and
means to create that security association is out of the scope of this
document (i.e., it is part of device provisioning or
onboarding).[¶](#section-7-2){.pilcrow}

On the other hand, if encryption is mandatory for all traffic of an NSF,
its default policy [MUST]{.bcp14} be to drop (DISCARD) packets to
prevent cleartext packet leaks. This default policy [MUST]{.bcp14} be
preconfigured in the startup configuration datastore in the NSF before
the NSF contacts the I2NSF Controller. Moreover, the startup
configuration datastore [MUST]{.bcp14} be also preconfigured with the
required ALLOW policies that allow the NSF to communicate with the I2NSF
Controller once the NSF is deployed. This preconfiguration step is not
carried out by the I2NSF Controller but by some other entity before the
NSF deployment. In this manner, when the NSF starts/reboots, it will
always first apply the configuration in the startup configuration before
contacting the I2NSF Controller.[¶](#section-7-3){.pilcrow}

Finally, this section is divided in two parts in order to analyze
different security considerations for both cases: NSF with IKEv2 (IKE
case) and NSF without IKEv2 (IKE-less case). In general, the I2NSF
Controller, as typically in the SDN paradigm, is a target for different
type of attacks; see \[[SDNSecServ](#SDNSecServ){.xref}\] and
\[[SDNSecurity](#SDNSecurity){.xref}\]. Thus, the I2NSF Controller is a
key entity in the infrastructure and [MUST]{.bcp14} be protected
accordingly. In particular, the I2NSF Controller will handle
cryptographic material; thus, the attacker may try to access this
information. The impact is different depending on the IKE case or the
IKE-less case.[¶](#section-7-4){.pilcrow}

::: {#sec-case1}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [IKE Case](#name-ike-case){.section-name .selfRef} {#name-ike-case}

In the IKE case, the I2NSF Controller sends IKEv2 credentials (PSK,
public/private keys, certificates, etc.) to the NSFs using the security
association between the I2NSF Controller and NSFs. The I2NSF Controller
[MUST NOT]{.bcp14} store the IKEv2 credentials after distributing them.
Moreover, the NSFs [MUST NOT]{.bcp14} allow the reading of these values
once they have been applied by the I2NSF Controller (i.e., write-only
operations). One option is to always return the same value (i.e., all
0s) if a read operation is carried out.[¶](#section-7.1-1){.pilcrow}

If the attacker has access to the I2NSF Controller during the period of
time that key material is generated, it might have access to the key
material. Since these values are used during NSF authentication in
IKEv2, it may impersonate the affected NSFs. Several recommendations are
important.[¶](#section-7.1-2){.pilcrow}

-   [IKEv2 configurations [SHOULD]{.bcp14} adhere to the recommendations
    in
    \[[RFC8247](#RFC8247){.xref}\].[¶](#section-7.1-3.1){.pilcrow}]{#section-7.1-3.1}
-   [If PSK authentication is used in IKEv2, the I2NSF Controller
    [MUST]{.bcp14} remove the PSK immediately after generating and
    distributing it.[¶](#section-7.1-3.2){.pilcrow}]{#section-7.1-3.2}
-   [When public/private keys are used, the I2NSF Controller
    [MAY]{.bcp14} generate both public key and private key. In such a
    case, the I2NSF Controller [MUST]{.bcp14} remove the associated
    private key immediately after distributing them to the NSFs.
    Alternatively, the NSF [MAY]{.bcp14} generate the private key and
    export only the public key to the I2NSF Controller. How the NSF
    generates these cryptographic materials (public key/ private keys)
    and exports the public key is out of scope of this
    document.[¶](#section-7.1-3.3){.pilcrow}]{#section-7.1-3.3}
-   [If certificates are used, the NSF [MAY]{.bcp14} generate the
    private key and export the public key for certification to the I2NSF
    Controller. How the NSF generates these cryptographic material
    (public key/ private keys) and exports the public key is out of
    scope of this
    document.[¶](#section-7.1-3.4){.pilcrow}]{#section-7.1-3.4}
:::
:::

::: {#sec-case2}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [IKE-less Case](#name-ike-less-case){.section-name .selfRef} {#name-ike-less-case}

In the IKE-less case, the I2NSF Controller sends the IPsec SA
information to the NSF\'s SAD that includes the private session keys
required for integrity and encryption. The I2NSF Controller [MUST
NOT]{.bcp14} store the keys after distributing them. Moreover, the NSFs
receiving private key material [MUST NOT]{.bcp14} allow the reading of
these values by any other entity (including the I2NSF Controller itself)
once they have been applied (i.e., write-only operations) into the NSFs.
Nevertheless, if the attacker has access to the I2NSF Controller during
the period of time that key material is generated, it may obtain these
values. In other words, the attacker might be able to observe the IPsec
traffic and decrypt, or even modify and re-encrypt, the traffic between
peers.[¶](#section-7.2-1){.pilcrow}

Finally, the security association between the I2NSF Controller and the
NSFs [MUST]{.bcp14} provide, at least, the same degree of protection as
the one achieved by the IPsec SAs configured in the NSFs. In particular,
the security association between the I2NSF Controller and the NSFs
[MUST]{.bcp14} provide forward secrecy if this property is to be
achieved in the IPsec SAs that the I2NSF Controller configures in the
NSFs. Similarly, the encryption algorithms used in the security
association between the I2NSF Controller and the NSF [MUST]{.bcp14}
have, at least, the same strength (minimum strength of a 128-bit key) as
the algorithms used to establish the IPsec
SAs.[¶](#section-7.2-2){.pilcrow}
:::
:::

::: {#sec-yang}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [YANG Modules](#name-yang-modules){.section-name .selfRef} {#name-yang-modules}

The YANG modules specified in this document define a schema for data
that is designed to be accessed via network management protocols such as
NETCONF \[[RFC6241](#RFC6241){.xref}\] or RESTCONF
\[[RFC8040](#RFC8040){.xref}\]. The lowest NETCONF layer is the secure
transport layer, and the mandatory-to-implement secure transport is
Secure Shell (SSH) \[[RFC6242](#RFC6242){.xref}\]. The lowest RESTCONF
layer is HTTPS, and the mandatory-to-implement secure transport is TLS
\[[RFC8446](#RFC8446){.xref}\].[¶](#section-7.3-1){.pilcrow}

The Network Configuration Access Control Model (NACM)
\[[RFC8341](#RFC8341){.xref}\] provides the means to restrict access for
particular NETCONF or RESTCONF users to a preconfigured subset of all
available NETCONF or RESTCONF protocol operations and
content.[¶](#section-7.3-2){.pilcrow}

There are a number of data nodes defined in these YANG modules that are
writable/creatable/deletable (i.e., config true, which is the default).
These data nodes may be considered sensitive or vulnerable in some
network environments. Write operations (e.g., edit-config) to these data
nodes without proper protection can have a negative effect on network
operations. These are the subtrees and data nodes and their
sensitivity/vulnerability:[¶](#section-7.3-3){.pilcrow}

[]{.break}

For the IKE case (ietf-i2nsf-ike):
:   []{.break}

    /ipsec-ike:
    :   The entire container in this module is sensitive to write
        operations. An attacker may add/modify the credentials to be
        used for the authentication (e.g., to impersonate an NSF), for
        the trust root (e.g., changing the trusted CA certificates), for
        the cryptographic algorithms (allowing a downgrading attack),
        for the IPsec policies (e.g., by allowing leaking of data
        traffic by changing to an allow policy), and in general,
        changing the IKE SA conditions and credentials between any
        NSF.[¶](#section-7.3-4.2.1.2){.pilcrow}
    :   
:   

For the IKE-less case (ietf-i2nsf-ikeless):
:   []{.break}

    /ipsec-ikeless:
    :   The entire container in this module is sensitive to write
        operations. An attacker may add/modify/delete any IPsec policies
        (e.g., by allowing leaking of data traffic by changing to an
        allow policy) in the /ipsec-ikeless/spd container,
        add/modify/delete any IPsec SAs between two NSF by means of
        /ipsec-ikeless/sad container, and, in general, change any IPsec
        SAs and IPsec policies between any
        NSF.[¶](#section-7.3-4.4.1.2){.pilcrow}
    :   
:   

Some of the readable data nodes in these YANG modules may be considered
sensitive or vulnerable in some network environments. It is thus
important to control read access (e.g., via get, get-config, or
notification) to these data nodes. These are the subtrees and data nodes
and their sensitivity/vulnerability:[¶](#section-7.3-5){.pilcrow}

[]{.break}

For the IKE case (ietf-i2nsf-ike):
:   []{.break}

    /ipsec-ike/pad:
    :   This container includes sensitive information to read
        operations. This information [MUST NOT]{.bcp14} be returned to a
        client. For example, cryptographic material configured in the
        NSFs (peer-authentication/pre-shared/secret and
        peer-authentication/digital-signature/private-key) are already
        protected by the NACM extension \"default-deny-all\" in this
        document.[¶](#section-7.3-6.2.1.2){.pilcrow}
    :   
:   

For the IKE-less case (ietf-i2nsf-ikeless):
:   []{.break}

    /ipsec-ikeless/sad/sad-entry/ipsec-sa-config/esp-sa:
    :   This container includes symmetric keys for the IPsec SAs. For
        example, encryption/key contains an ESP encryption key value and
        encryption/iv contains an Initialization Vector value.
        Similarly, integrity/key has an ESP integrity key value. Those
        values [MUST NOT]{.bcp14} be read by anyone and are protected by
        the NACM extension \"default-deny-all\" in this
        document.[¶](#section-7.3-6.4.1.2){.pilcrow}
    :   
:   
:::
:::
:::
:::

::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[IANA-Method-Type\]
:   [IANA]{.refAuthor}, [\"Method Type\"]{.refTitle},
    \<<https://www.iana.org/assignments/eap-numbers/>\>.
:   

\[IANA-Protocols-Number\]
:   [IANA]{.refAuthor}, [\"Protocol Numbers\"]{.refTitle},
    \<<https://www.iana.org/assignments/protocol-numbers/>\>.
:   

\[IKEv2-Auth-Method\]
:   [IANA]{.refAuthor}, [\"IKEv2 Authentication Method\"]{.refTitle},
    \<<https://www.iana.org/assignments/ikev2-parameters/>\>.
:   

\[IKEv2-Parameters\]
:   [IANA]{.refAuthor}, [\"Internet Key Exchange Version 2 (IKEv2)
    Parameters\"]{.refTitle},
    \<<https://www.iana.org/assignments/ikev2-parameters/>\>.
:   

\[IKEv2-Transform-Type-1\]
:   [IANA]{.refAuthor}, [\"Transform Type 1 - Encryption Algorithm
    Transform IDs\"]{.refTitle},
    \<<https://www.iana.org/assignments/ikev2-parameters/>\>.
:   

\[IKEv2-Transform-Type-3\]
:   [IANA]{.refAuthor}, [\"Transform Type 3 - Integrity Algorithm
    Transform IDs\"]{.refTitle},
    \<<https://www.iana.org/assignments/ikev2-parameters/>\>.
:   

\[IKEv2-Transform-Type-4\]
:   [IANA]{.refAuthor}, [\"Transform Type 4 - Diffie-Hellman Group
    Transform IDs\"]{.refTitle},
    \<<https://www.iana.org/assignments/ikev2-parameters/>\>.
:   

\[ITU-T.X.690\]
:   [International Telecommunication Union]{.refAuthor}, [\"Information
    Technology - ASN.1 encoding rules: Specification of Basic Encoding
    Rules (BER), Canonical Encoding Rules (CER) and Distinguished
    Encoding Rules (DER)\"]{.refTitle}, [ITU-T Recommendation
    X.690]{.refContent}, [ISO/IEC 8825-1]{.refContent}, February 2021.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC3947\]
:   [Kivinen, T.]{.refAuthor}, [Swander, B.]{.refAuthor},
    [Huttunen, A.]{.refAuthor}, and [V. Volpe]{.refAuthor},
    [\"Negotiation of NAT-Traversal in the IKE\"]{.refTitle}, [RFC
    3947]{.seriesInfo}, [DOI 10.17487/RFC3947]{.seriesInfo}, January
    2005, \<<https://www.rfc-editor.org/info/rfc3947>\>.
:   

\[RFC3948\]
:   [Huttunen, A.]{.refAuthor}, [Swander, B.]{.refAuthor},
    [Volpe, V.]{.refAuthor}, [DiBurro, L.]{.refAuthor}, and [M.
    Stenberg]{.refAuthor}, [\"UDP Encapsulation of IPsec ESP
    Packets\"]{.refTitle}, [RFC 3948]{.seriesInfo}, [DOI
    10.17487/RFC3948]{.seriesInfo}, January 2005,
    \<<https://www.rfc-editor.org/info/rfc3948>\>.
:   

\[RFC4301\]
:   [Kent, S.]{.refAuthor} and [K. Seo]{.refAuthor}, [\"Security
    Architecture for the Internet Protocol\"]{.refTitle}, [RFC
    4301]{.seriesInfo}, [DOI 10.17487/RFC4301]{.seriesInfo}, December
    2005, \<<https://www.rfc-editor.org/info/rfc4301>\>.
:   

\[RFC4303\]
:   [Kent, S.]{.refAuthor}, [\"IP Encapsulating Security Payload
    (ESP)\"]{.refTitle}, [RFC 4303]{.seriesInfo}, [DOI
    10.17487/RFC4303]{.seriesInfo}, December 2005,
    \<<https://www.rfc-editor.org/info/rfc4303>\>.
:   

\[RFC5280\]
:   [Cooper, D.]{.refAuthor}, [Santesson, S.]{.refAuthor},
    [Farrell, S.]{.refAuthor}, [Boeyen, S.]{.refAuthor},
    [Housley, R.]{.refAuthor}, and [W. Polk]{.refAuthor}, [\"Internet
    X.509 Public Key Infrastructure Certificate and Certificate
    Revocation List (CRL) Profile\"]{.refTitle}, [RFC
    5280]{.seriesInfo}, [DOI 10.17487/RFC5280]{.seriesInfo}, May 2008,
    \<<https://www.rfc-editor.org/info/rfc5280>\>.
:   

\[RFC5322\]
:   [Resnick, P., Ed.]{.refAuthor}, [\"Internet Message
    Format\"]{.refTitle}, [RFC 5322]{.seriesInfo}, [DOI
    10.17487/RFC5322]{.seriesInfo}, October 2008,
    \<<https://www.rfc-editor.org/info/rfc5322>\>.
:   

\[RFC5915\]
:   [Turner, S.]{.refAuthor} and [D. Brown]{.refAuthor}, [\"Elliptic
    Curve Private Key Structure\"]{.refTitle}, [RFC 5915]{.seriesInfo},
    [DOI 10.17487/RFC5915]{.seriesInfo}, June 2010,
    \<<https://www.rfc-editor.org/info/rfc5915>\>.
:   

\[RFC6020\]
:   [Bjorklund, M., Ed.]{.refAuthor}, [\"YANG - A Data Modeling Language
    for the Network Configuration Protocol (NETCONF)\"]{.refTitle}, [RFC
    6020]{.seriesInfo}, [DOI 10.17487/RFC6020]{.seriesInfo}, October
    2010, \<<https://www.rfc-editor.org/info/rfc6020>\>.
:   

\[RFC6241\]
:   [Enns, R., Ed.]{.refAuthor}, [Bjorklund, M., Ed.]{.refAuthor},
    [Schoenwaelder, J., Ed.]{.refAuthor}, and [A. Bierman,
    Ed.]{.refAuthor}, [\"Network Configuration Protocol
    (NETCONF)\"]{.refTitle}, [RFC 6241]{.seriesInfo}, [DOI
    10.17487/RFC6241]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6241>\>.
:   

\[RFC6242\]
:   [Wasserman, M.]{.refAuthor}, [\"Using the NETCONF Protocol over
    Secure Shell (SSH)\"]{.refTitle}, [RFC 6242]{.seriesInfo}, [DOI
    10.17487/RFC6242]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6242>\>.
:   

\[RFC6960\]
:   [Santesson, S.]{.refAuthor}, [Myers, M.]{.refAuthor},
    [Ankney, R.]{.refAuthor}, [Malpani, A.]{.refAuthor},
    [Galperin, S.]{.refAuthor}, and [C. Adams]{.refAuthor}, [\"X.509
    Internet Public Key Infrastructure Online Certificate Status
    Protocol - OCSP\"]{.refTitle}, [RFC 6960]{.seriesInfo}, [DOI
    10.17487/RFC6960]{.seriesInfo}, June 2013,
    \<<https://www.rfc-editor.org/info/rfc6960>\>.
:   

\[RFC6991\]
:   [Schoenwaelder, J., Ed.]{.refAuthor}, [\"Common YANG Data
    Types\"]{.refTitle}, [RFC 6991]{.seriesInfo}, [DOI
    10.17487/RFC6991]{.seriesInfo}, July 2013,
    \<<https://www.rfc-editor.org/info/rfc6991>\>.
:   

\[RFC7296\]
:   [Kaufman, C.]{.refAuthor}, [Hoffman, P.]{.refAuthor},
    [Nir, Y.]{.refAuthor}, [Eronen, P.]{.refAuthor}, and [T.
    Kivinen]{.refAuthor}, [\"Internet Key Exchange Protocol Version 2
    (IKEv2)\"]{.refTitle}, [STD 79]{.seriesInfo}, [RFC
    7296]{.seriesInfo}, [DOI 10.17487/RFC7296]{.seriesInfo}, October
    2014, \<<https://www.rfc-editor.org/info/rfc7296>\>.
:   

\[RFC7383\]
:   [Smyslov, V.]{.refAuthor}, [\"Internet Key Exchange Protocol Version
    2 (IKEv2) Message Fragmentation\"]{.refTitle}, [RFC
    7383]{.seriesInfo}, [DOI 10.17487/RFC7383]{.seriesInfo}, November
    2014, \<<https://www.rfc-editor.org/info/rfc7383>\>.
:   

\[RFC7427\]
:   [Kivinen, T.]{.refAuthor} and [J. Snyder]{.refAuthor}, [\"Signature
    Authentication in the Internet Key Exchange Version 2
    (IKEv2)\"]{.refTitle}, [RFC 7427]{.seriesInfo}, [DOI
    10.17487/RFC7427]{.seriesInfo}, January 2015,
    \<<https://www.rfc-editor.org/info/rfc7427>\>.
:   

\[RFC7619\]
:   [Smyslov, V.]{.refAuthor} and [P. Wouters]{.refAuthor}, [\"The NULL
    Authentication Method in the Internet Key Exchange Protocol Version
    2 (IKEv2)\"]{.refTitle}, [RFC 7619]{.seriesInfo}, [DOI
    10.17487/RFC7619]{.seriesInfo}, August 2015,
    \<<https://www.rfc-editor.org/info/rfc7619>\>.
:   

\[RFC7950\]
:   [Bjorklund, M., Ed.]{.refAuthor}, [\"The YANG 1.1 Data Modeling
    Language\"]{.refTitle}, [RFC 7950]{.seriesInfo}, [DOI
    10.17487/RFC7950]{.seriesInfo}, August 2016,
    \<<https://www.rfc-editor.org/info/rfc7950>\>.
:   

\[RFC8017\]
:   [Moriarty, K., Ed.]{.refAuthor}, [Kaliski, B.]{.refAuthor},
    [Jonsson, J.]{.refAuthor}, and [A. Rusch]{.refAuthor}, [\"PKCS #1:
    RSA Cryptography Specifications Version 2.2\"]{.refTitle}, [RFC
    8017]{.seriesInfo}, [DOI 10.17487/RFC8017]{.seriesInfo}, November
    2016, \<<https://www.rfc-editor.org/info/rfc8017>\>.
:   

\[RFC8040\]
:   [Bierman, A.]{.refAuthor}, [Bjorklund, M.]{.refAuthor}, and [K.
    Watsen]{.refAuthor}, [\"RESTCONF Protocol\"]{.refTitle}, [RFC
    8040]{.seriesInfo}, [DOI 10.17487/RFC8040]{.seriesInfo}, January
    2017, \<<https://www.rfc-editor.org/info/rfc8040>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8221\]
:   [Wouters, P.]{.refAuthor}, [Migault, D.]{.refAuthor},
    [Mattsson, J.]{.refAuthor}, [Nir, Y.]{.refAuthor}, and [T.
    Kivinen]{.refAuthor}, [\"Cryptographic Algorithm Implementation
    Requirements and Usage Guidance for Encapsulating Security Payload
    (ESP) and Authentication Header (AH)\"]{.refTitle}, [RFC
    8221]{.seriesInfo}, [DOI 10.17487/RFC8221]{.seriesInfo}, October
    2017, \<<https://www.rfc-editor.org/info/rfc8221>\>.
:   

\[RFC8229\]
:   [Pauly, T.]{.refAuthor}, [Touati, S.]{.refAuthor}, and [R.
    Mantha]{.refAuthor}, [\"TCP Encapsulation of IKE and IPsec
    Packets\"]{.refTitle}, [RFC 8229]{.seriesInfo}, [DOI
    10.17487/RFC8229]{.seriesInfo}, August 2017,
    \<<https://www.rfc-editor.org/info/rfc8229>\>.
:   

\[RFC8247\]
:   [Nir, Y.]{.refAuthor}, [Kivinen, T.]{.refAuthor},
    [Wouters, P.]{.refAuthor}, and [D. Migault]{.refAuthor},
    [\"Algorithm Implementation Requirements and Usage Guidance for the
    Internet Key Exchange Protocol Version 2 (IKEv2)\"]{.refTitle}, [RFC
    8247]{.seriesInfo}, [DOI 10.17487/RFC8247]{.seriesInfo}, September
    2017, \<<https://www.rfc-editor.org/info/rfc8247>\>.
:   

\[RFC8340\]
:   [Bjorklund, M.]{.refAuthor} and [L. Berger, Ed.]{.refAuthor},
    [\"YANG Tree Diagrams\"]{.refTitle}, [BCP 215]{.seriesInfo}, [RFC
    8340]{.seriesInfo}, [DOI 10.17487/RFC8340]{.seriesInfo}, March 2018,
    \<<https://www.rfc-editor.org/info/rfc8340>\>.
:   

\[RFC8341\]
:   [Bierman, A.]{.refAuthor} and [M. Bjorklund]{.refAuthor}, [\"Network
    Configuration Access Control Model\"]{.refTitle}, [STD
    91]{.seriesInfo}, [RFC 8341]{.seriesInfo}, [DOI
    10.17487/RFC8341]{.seriesInfo}, March 2018,
    \<<https://www.rfc-editor.org/info/rfc8341>\>.
:   

\[RFC8342\]
:   [Bjorklund, M.]{.refAuthor}, [Schoenwaelder, J.]{.refAuthor},
    [Shafer, P.]{.refAuthor}, [Watsen, K.]{.refAuthor}, and [R.
    Wilton]{.refAuthor}, [\"Network Management Datastore Architecture
    (NMDA)\"]{.refTitle}, [RFC 8342]{.seriesInfo}, [DOI
    10.17487/RFC8342]{.seriesInfo}, March 2018,
    \<<https://www.rfc-editor.org/info/rfc8342>\>.
:   

\[RFC8446\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   
:::

::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[IPSECME-CONTROLLER-IKE\]
:   [Carrel, D.]{.refAuthor} and [B. Weis]{.refAuthor}, [\"IPsec Key
    Exchange using a Controller\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-carrel-ipsecme-controller-ike-01]{.seriesInfo}, 10 March 2019,
    \<<https://datatracker.ietf.org/doc/html/draft-carrel-ipsecme-controller-ike-01>\>.
:   

\[ITU-T.Y.3300\]
:   [International Telecommunications Union]{.refAuthor}, [\"Y.3300:
    Framework of software-defined networking\"]{.refTitle}, June 2014,
    \<<https://www.itu.int/rec/T-REC-Y.3300/en>\>.
:   

\[libreswan\]
:   [The Libreswan Project]{.refAuthor}, [\"Libreswan VPN
    software\"]{.refTitle}, \<<https://libreswan.org/>\>.
:   

\[netconf-vpn\]
:   [Stefan Wallin]{.refAuthor}, [\"Tutorial: NETCONF and
    YANG\"]{.refTitle}, January 2014,
    \<<https://ripe68.ripe.net/presentations/181-NETCONF-YANG-tutorial-43.pdf>\>.
:   

\[ONF-OpenFlow\]
:   [Open Networking Foundation]{.refAuthor}, [\"OpenFlow Switch
    Specification\"]{.refTitle}, [Version 1.4.0 (Wire Protocol
    0x05)]{.seriesInfo}, October 2013,
    \<<https://www.opennetworking.org/wp-content/uploads/2014/10/openflow-spec-v1.4.0.pdf>\>.
:   

\[ONF-SDN-Architecture\]
:   [Open Networking Foundation]{.refAuthor}, [\"SDN
    architecture\"]{.refTitle}, [Issue 1]{.seriesInfo}, June 2014,
    \<<https://www.opennetworking.org/wp-content/uploads/2013/02/TR_SDN_ARCH_1.0_06062014.pdf>\>.
:   

\[RFC2367\]
:   [McDonald, D.]{.refAuthor}, [Metz, C.]{.refAuthor}, and [B.
    Phan]{.refAuthor}, [\"PF_KEY Key Management API, Version
    2\"]{.refTitle}, [RFC 2367]{.seriesInfo}, [DOI
    10.17487/RFC2367]{.seriesInfo}, July 1998,
    \<<https://www.rfc-editor.org/info/rfc2367>\>.
:   

\[RFC3688\]
:   [Mealling, M.]{.refAuthor}, [\"The IETF XML Registry\"]{.refTitle},
    [BCP 81]{.seriesInfo}, [RFC 3688]{.seriesInfo}, [DOI
    10.17487/RFC3688]{.seriesInfo}, January 2004,
    \<<https://www.rfc-editor.org/info/rfc3688>\>.
:   

\[RFC6040\]
:   [Briscoe, B.]{.refAuthor}, [\"Tunnelling of Explicit Congestion
    Notification\"]{.refTitle}, [RFC 6040]{.seriesInfo}, [DOI
    10.17487/RFC6040]{.seriesInfo}, November 2010,
    \<<https://www.rfc-editor.org/info/rfc6040>\>.
:   

\[RFC6071\]
:   [Frankel, S.]{.refAuthor} and [S. Krishnan]{.refAuthor}, [\"IP
    Security (IPsec) and Internet Key Exchange (IKE) Document
    Roadmap\"]{.refTitle}, [RFC 6071]{.seriesInfo}, [DOI
    10.17487/RFC6071]{.seriesInfo}, February 2011,
    \<<https://www.rfc-editor.org/info/rfc6071>\>.
:   

\[RFC6437\]
:   [Amante, S.]{.refAuthor}, [Carpenter, B.]{.refAuthor},
    [Jiang, S.]{.refAuthor}, and [J. Rajahalme]{.refAuthor}, [\"IPv6
    Flow Label Specification\"]{.refTitle}, [RFC 6437]{.seriesInfo},
    [DOI 10.17487/RFC6437]{.seriesInfo}, November 2011,
    \<<https://www.rfc-editor.org/info/rfc6437>\>.
:   

\[RFC7149\]
:   [Boucadair, M.]{.refAuthor} and [C. Jacquenet]{.refAuthor},
    [\"Software-Defined Networking: A Perspective from within a Service
    Provider Environment\"]{.refTitle}, [RFC 7149]{.seriesInfo}, [DOI
    10.17487/RFC7149]{.seriesInfo}, March 2014,
    \<<https://www.rfc-editor.org/info/rfc7149>\>.
:   

\[RFC7426\]
:   [Haleplidis, E., Ed.]{.refAuthor}, [Pentikousis, K.,
    Ed.]{.refAuthor}, [Denazis, S.]{.refAuthor}, [Hadi
    Salim, J.]{.refAuthor}, [Meyer, D.]{.refAuthor}, and [O.
    Koufopavlou]{.refAuthor}, [\"Software-Defined Networking (SDN):
    Layers and Architecture Terminology\"]{.refTitle}, [RFC
    7426]{.seriesInfo}, [DOI 10.17487/RFC7426]{.seriesInfo}, January
    2015, \<<https://www.rfc-editor.org/info/rfc7426>\>.
:   

\[RFC8192\]
:   [Hares, S.]{.refAuthor}, [Lopez, D.]{.refAuthor},
    [Zarny, M.]{.refAuthor}, [Jacquenet, C.]{.refAuthor},
    [Kumar, R.]{.refAuthor}, and [J. Jeong]{.refAuthor}, [\"Interface to
    Network Security Functions (I2NSF): Problem Statement and Use
    Cases\"]{.refTitle}, [RFC 8192]{.seriesInfo}, [DOI
    10.17487/RFC8192]{.seriesInfo}, July 2017,
    \<<https://www.rfc-editor.org/info/rfc8192>\>.
:   

\[RFC8329\]
:   [Lopez, D.]{.refAuthor}, [Lopez, E.]{.refAuthor},
    [Dunbar, L.]{.refAuthor}, [Strassner, J.]{.refAuthor}, and [R.
    Kumar]{.refAuthor}, [\"Framework for Interface to Network Security
    Functions\"]{.refTitle}, [RFC 8329]{.seriesInfo}, [DOI
    10.17487/RFC8329]{.seriesInfo}, February 2018,
    \<<https://www.rfc-editor.org/info/rfc8329>\>.
:   

\[SDNSecServ\]
:   [Scott-Hayward, S.]{.refAuthor}, [O\'Callaghan, G.]{.refAuthor}, and
    [P. Sezer]{.refAuthor}, [\"Sdn Security: A Survey\"]{.refTitle},
    [2013 IEEE SDN for Future Networks and Services (SDN4FNS), pp.
    1-7]{.refContent}, [DOI 10.1109/SDN4FNS.2013.6702553]{.seriesInfo},
    November 2013, \<<https://doi.org/10.1109/SDN4FNS.2013.6702553>\>.
:   

\[SDNSecurity\]
:   [Kreutz, D.]{.refAuthor}, [Ramos, F.]{.refAuthor}, and [P.
    Verissimo]{.refAuthor}, [\"Towards secure and dependable
    software-defined networks\"]{.refTitle}, [Proceedings of the second
    ACM SIGCOMM workshop on Hot Topics in software defined networking,
    pp. 55-60]{.refContent}, [DOI 10.1145/2491185.2491199]{.seriesInfo},
    August 2013, \<<https://doi.org/10.1145/2491185.2491199>\>.
:   

\[strongswan\]
:   [CESNET]{.refAuthor}, [\"strongSwan: the OpenSource IPsec-based VPN
    Solution\"]{.refTitle}, \<<https://www.strongswan.org/>\>.
:   

\[TRAN-IPSECME-YANG\]
:   [Tran, K.]{.refAuthor}, [Wang, H.]{.refAuthor}, [Nagaraj, V.
    K.]{.refAuthor}, and [X. Chen]{.refAuthor}, [\"Yang Data Model for
    Internet Protocol Security (IPsec)\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-tran-ipsecme-yang-01]{.seriesInfo}, 18 March 2016,
    \<<https://datatracker.ietf.org/doc/html/draft-tran-ipsecme-yang-01>\>.
:   
:::
:::

::: {#appendix-d}
::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [XML Configuration Example for IKE Case (Gateway-to-Gateway)](#name-xml-configuration-example-f){.section-name .selfRef} {#name-xml-configuration-example-f}

This example shows an XML configuration file sent by the I2NSF
Controller to establish an IPsec SA between two NSFs (see [Figure
3](#fig_example-ike){.xref}) in tunnel mode (gateway-to-gateway) with
ESP, with authentication based on X.509 certificates (simplified for
brevity with \"base64encodedvalue==\") and applying the IKE
case.[¶](#appendix-A-1){.pilcrow}

[]{#name-ike-case-tunnel-mode-x509-c}

::: {#fig_example-ike}
::: {#appendix-A-2.1 .artwork .art-text .alignCenter}
                              +------------------+
                              | I2NSF Controller |
                              +------------------+
                       I2NSF NSF-Facing |
                              Interface |
                      /-----------------+---------------\
                     /                                   \
                    /                                     \
       +----+  +--------+                            +--------+  +----+
       | h1 |--| nsf_h1 |== IPsec_ESP_Tunnel_mode == | nsf_h2 |--| h2 |
       +----+  +--------+                            +--------+  +----+
              :1        :100                       :200       :1

    (2001:db8:1:/64)          (2001:db8:123:/64)       (2001:db8:2:/64)
:::

[Figure 3](#figure-3){.selfRef}: [IKE Case, Tunnel Mode, X.509
Certificate Authentication](#name-ike-case-tunnel-mode-x509-c){.selfRef}
:::

::: {#appendix-A-3}
``` {.sourcecode .lang-xml}
<ipsec-ike xmlns="urn:ietf:params:xml:ns:yang:ietf-i2nsf-ike"
xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
  <pad>
    <pad-entry>
      <name>nsf_h1_pad</name>
      <ipv6-address>2001:db8:123::100</ipv6-address>
      <peer-authentication>
         <auth-method>digital-signature</auth-method>
         <digital-signature>
            <cert-data>base64encodedvalue==</cert-data>
            <private-key>base64encodedvalue==</private-key>
            <ca-data>base64encodedvalue==</ca-data>
         </digital-signature>
      </peer-authentication>
    </pad-entry>
    <pad-entry>
      <name>nsf_h2_pad</name>
      <ipv6-address>2001:db8:123::200</ipv6-address>
      <auth-protocol>ikev2</auth-protocol>
      <peer-authentication>
        <auth-method>digital-signature</auth-method>
        <digital-signature>
          <!-- RSA Digital Signature -->
          <ds-algorithm>1</ds-algorithm>
          <cert-data>base64encodedvalue==</cert-data>
          <ca-data>base64encodedvalue==</ca-data>
        </digital-signature>
      </peer-authentication>
    </pad-entry>
  </pad>
  <conn-entry>
     <name>nsf_h1-nsf_h2</name>
     <autostartup>start</autostartup>
     <version>ikev2</version>
     <initial-contact>false</initial-contact>
     <fragmentation><enabled>false</enabled></fragmentation>
     <ike-sa-lifetime-soft>
        <rekey-time>60</rekey-time>
        <reauth-time>120</reauth-time>
     </ike-sa-lifetime-soft>
     <ike-sa-lifetime-hard>
        <over-time>3600</over-time>
     </ike-sa-lifetime-hard>
     <!--AUTH_HMAC_SHA2_512_256-->
     <ike-sa-intr-alg>14</ike-sa-intr-alg>
     <!--ENCR_AES_CBC - 128 bits-->
     <ike-sa-encr-alg>
        <id>1</id>
     </ike-sa-encr-alg>
     <!--8192-bit MODP Group-->
     <dh-group>18</dh-group>
     <half-open-ike-sa-timer>30</half-open-ike-sa-timer>
     <half-open-ike-sa-cookie-threshold>
        15
     </half-open-ike-sa-cookie-threshold>
     <local>
         <local-pad-entry-name>nsf_h1_pad</local-pad-entry-name>
     </local>
     <remote>
         <remote-pad-entry-name>nsf_h2_pad</remote-pad-entry-name>
     </remote>
     <spd>
       <spd-entry>
          <name>nsf_h1-nsf_h2</name>
          <ipsec-policy-config>
            <anti-replay-window-size>64</anti-replay-window-size>
            <traffic-selector>
               <local-prefix>2001:db8:1::0/64</local-prefix>
               <remote-prefix>2001:db8:2::0/64</remote-prefix>
               <inner-protocol>any</inner-protocol>
            </traffic-selector>
            <processing-info>
               <action>protect</action>
               <ipsec-sa-cfg>
                  <pfp-flag>false</pfp-flag>
                  <ext-seq-num>true</ext-seq-num>
                  <seq-overflow>false</seq-overflow>
                  <stateful-frag-check>false</stateful-frag-check>
                  <mode>tunnel</mode>
                  <protocol-parameters>esp</protocol-parameters>
                  <esp-algorithms>
                     <!-- AUTH_HMAC_SHA1_96 -->
                     <integrity>2</integrity>
                      <encryption>
                          <!-- ENCR_AES_CBC -->
                          <id>1</id>
                          <algorithm-type>12</algorithm-type>
                          <key-length>128</key-length>
                      </encryption>
                      <encryption>
                          <!-- ENCR_3DES-->
                          <id>2</id>
                          <algorithm-type>3</algorithm-type>
                      </encryption>
                     <tfc-pad>false</tfc-pad>
                  </esp-algorithms>
                  <tunnel>
                     <local>2001:db8:123::100</local>
                     <remote>2001:db8:123::200</remote>
                     <df-bit>clear</df-bit>
                     <bypass-dscp>true</bypass-dscp>
                 </tunnel>
               </ipsec-sa-cfg>
            </processing-info>
          </ipsec-policy-config>
       </spd-entry>
     </spd>
     <child-sa-info>
        <!--8192-bit MODP Group -->
        <fs-groups>18</fs-groups>
        <child-sa-lifetime-soft>
           <bytes>1000000</bytes>
           <packets>1000</packets>
           <time>30</time>
           <idle>60</idle>
           <action>replace</action>
        </child-sa-lifetime-soft>
        <child-sa-lifetime-hard>
           <bytes>2000000</bytes>
           <packets>2000</packets>
           <time>60</time>
           <idle>120</idle>
        </child-sa-lifetime-hard>
     </child-sa-info>
   </conn-entry>
</ipsec-ike>
```

[¶](#appendix-A-3){.pilcrow}
:::
:::
:::

::: {#appendix-e}
::: {#appendix-B .section}
## [Appendix B.](#appendix-B){.section-number .selfRef} [XML Configuration Example for IKE-less Case (Host-to-Host)](#name-xml-configuration-example-fo){.section-name .selfRef} {#name-xml-configuration-example-fo}

This example shows an XML configuration file sent by the I2NSF
Controller to establish an IPsec SA between two NSFs (see [Figure
4](#fig_example-ikeless){.xref}) in transport mode (host-to-host) with
ESP in the IKE-less case.[¶](#appendix-B-1){.pilcrow}

[]{#name-ike-less-case-transport-mod}

::: {#fig_example-ikeless}
::: {#appendix-B-2.1 .artwork .art-text .alignCenter}
                       +------------------+
                       | I2NSF Controller |
                       +------------------+
               I2NSF NSF-Facing |
                      Interface |
           /--------------------+-------------------\
          /                                          \
         /                                            \
    +--------+                                    +--------+
    | nsf_h1 |===== IPsec_ESP_Transport_mode =====| nsf_h2 |
    +--------+                                    +--------+
            :100        (2001:db8:123:/64)       :200
:::

[Figure 4](#figure-4){.selfRef}: [IKE-less Case, Transport
Mode](#name-ike-less-case-transport-mod){.selfRef}
:::

::: {#appendix-B-3}
``` {.sourcecode .lang-xml}
<ipsec-ikeless
  xmlns="urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless"
  xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
  <spd>
    <spd-entry>
        <name>
           in/trans/2001:db8:123::200/2001:db8:123::100
        </name>
        <direction>inbound</direction>
        <reqid>1</reqid>
        <ipsec-policy-config>
           <traffic-selector>
             <local-prefix>2001:db8:123::200/128</local-prefix>
             <remote-prefix>2001:db8:123::100/128</remote-prefix>
             <inner-protocol>any</inner-protocol>
           </traffic-selector>
           <processing-info>
              <action>protect</action>
              <ipsec-sa-cfg>
                <ext-seq-num>true</ext-seq-num>
                <seq-overflow>false</seq-overflow>
                <mode>transport</mode>
                <protocol-parameters>esp</protocol-parameters>
                <esp-algorithms>
                   <!--AUTH_HMAC_SHA1_96-->
                   <integrity>2</integrity>
                   <!--ENCR_AES_CBC -->
                   <encryption>
                     <id>1</id>
                     <algorithm-type>12</algorithm-type>
                      <key-length>128</key-length>
                   </encryption>
                   <encryption>
                     <id>2</id>
                     <algorithm-type>3</algorithm-type>
                   </encryption>
                </esp-algorithms>
              </ipsec-sa-cfg>
            </processing-info>
          </ipsec-policy-config>
        </spd-entry>
        <spd-entry>
          <name>out/trans/2001:db8:123::100/2001:db8:123::200</name>
          <direction>outbound</direction>
          <reqid>1</reqid>
          <ipsec-policy-config>
            <traffic-selector>
              <local-prefix>2001:db8:123::100/128</local-prefix>
              <remote-prefix>2001:db8:123::200/128</remote-prefix>
              <inner-protocol>any</inner-protocol>
            </traffic-selector>
            <processing-info>
              <action>protect</action>
              <ipsec-sa-cfg>
                <ext-seq-num>true</ext-seq-num>
                <seq-overflow>false</seq-overflow>
                <mode>transport</mode>
                <protocol-parameters>esp</protocol-parameters>
                <esp-algorithms>
                  <!-- AUTH_HMAC_SHA1_96 -->
                  <integrity>2</integrity>
                  <!-- ENCR_AES_CBC -->
                  <encryption>
                     <id>1</id>
                     <algorithm-type>12</algorithm-type>
                     <key-length>128</key-length>
                  </encryption>
                  <encryption>
                     <id>2</id>
                     <algorithm-type>3</algorithm-type>
                  </encryption>
                </esp-algorithms>
               </ipsec-sa-cfg>
             </processing-info>
           </ipsec-policy-config>
        </spd-entry>
     </spd>
     <sad>
       <sad-entry>
         <name>out/trans/2001:db8:123::100/2001:db8:123::200</name>
         <reqid>1</reqid>
         <ipsec-sa-config>
            <spi>34501</spi>
            <ext-seq-num>true</ext-seq-num>
            <seq-overflow>false</seq-overflow>
            <anti-replay-window-size>64</anti-replay-window-size>
            <traffic-selector>
              <local-prefix>2001:db8:123::100/128</local-prefix>
              <remote-prefix>2001:db8:123::200/128</remote-prefix>
                 <inner-protocol>any</inner-protocol>
             </traffic-selector>
             <protocol-parameters>esp</protocol-parameters>
             <mode>transport</mode>
             <esp-sa>
               <encryption>
                  <!-- //ENCR_AES_CBC -->
                  <encryption-algorithm>12</encryption-algorithm>
                  <key>01:23:45:67:89:AB:CE:DF</key>
                  <iv>01:23:45:67:89:AB:CE:DF</iv>
               </encryption>
               <integrity>
                  <!-- //AUTH_HMAC_SHA1_96 -->
                  <integrity-algorithm>2</integrity-algorithm>
                  <key>01:23:45:67:89:AB:CE:DF</key>
               </integrity>
             </esp-sa>
         </ipsec-sa-config>
       </sad-entry>
       <sad-entry>
          <name>in/trans/2001:db8:123::200/2001:db8:123::100</name>
          <reqid>1</reqid>
          <ipsec-sa-config>
              <spi>34502</spi>
              <ext-seq-num>true</ext-seq-num>
              <seq-overflow>false</seq-overflow>
              <anti-replay-window-size>64</anti-replay-window-size>
              <traffic-selector>
                 <local-prefix>2001:db8:123::200/128</local-prefix>
                 <remote-prefix>2001:db8:123::100/128</remote-prefix>
                 <inner-protocol>any</inner-protocol>
              </traffic-selector>
              <protocol-parameters>esp</protocol-parameters>
              <mode>transport</mode>
              <esp-sa>
                 <encryption>
                    <!-- //ENCR_AES_CBC -->
                    <encryption-algorithm>12</encryption-algorithm>
                    <key>01:23:45:67:89:AB:CE:DF</key>
                    <iv>01:23:45:67:89:AB:CE:DF</iv>
                 </encryption>
                 <integrity>
                    <!-- //AUTH_HMAC_SHA1_96 -->
                    <integrity-algorithm>2</integrity-algorithm>
                    <key>01:23:45:67:89:AB:CE:DF</key>
                 </integrity>
               </esp-sa>
               <sa-lifetime-hard>
                  <bytes>2000000</bytes>
                  <packets>2000</packets>
                  <time>60</time>
                  <idle>120</idle>
               </sa-lifetime-hard>
               <sa-lifetime-soft>
                  <bytes>1000000</bytes>
                  <packets>1000</packets>
                  <time>30</time>
                  <idle>60</idle>
                  <action>replace</action>
               </sa-lifetime-soft>
         </ipsec-sa-config>
       </sad-entry>
    </sad>
</ipsec-ikeless>
```

[¶](#appendix-B-3){.pilcrow}
:::
:::
:::

::: {#appendix-f}
::: {#appendix-C .section}
## [Appendix C.](#appendix-C){.section-number .selfRef} [XML Notification Examples](#name-xml-notification-examples){.section-name .selfRef} {#name-xml-notification-examples}

In the following, several XML files are shown to illustrate different
types of notifications defined in the IKE-less YANG data model, which
are sent by the NSF to the I2NSF Controller. The notifications happen in
the IKE-less case.[¶](#appendix-C-1){.pilcrow}

[]{#name-example-of-the-sadb-expire-}

::: {#sadb-expire-not}
::: {#appendix-C-2.1}
``` {.sourcecode .lang-xml}
<sadb-expire xmlns="urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless">
<ipsec-sa-name>in/trans/2001:db8:123::200/2001:db8:123::100
</ipsec-sa-name>
    <soft-lifetime-expire>true</soft-lifetime-expire>
       <lifetime-current>
          <bytes>1000000</bytes>
          <packets>1000</packets>
          <time>30</time>
          <idle>60</idle>
       </lifetime-current>
</sadb-expire>
```
:::

[Figure 5](#figure-5){.selfRef}: [Example of the sadb-expire
Notification](#name-example-of-the-sadb-expire-){.selfRef}
:::

[]{#name-example-of-the-sadb-acquire}

::: {#sadb-acquire-not}
::: {#appendix-C-3.1}
``` {.sourcecode .lang-xml}
<sadb-acquire xmlns="urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless">
    <ipsec-policy-name>in/trans/2001:db8:123::200/2001:db8:123::100
    </ipsec-policy-name>
    <traffic-selector>
        <local-prefix>2001:db8:123::200/128</local-prefix>
        <remote-prefix>2001:db8:123::100/128</remote-prefix>
        <inner-protocol>any</inner-protocol>
         <local-ports>
              <start>0</start>
              <end>0</end>
         </local-ports>
         <remote-ports>
              <start>0</start>
              <end>0</end>
         </remote-ports>
    </traffic-selector>
</sadb-acquire>
```
:::

[Figure 6](#figure-6){.selfRef}: [Example of the sadb-acquire
Notification](#name-example-of-the-sadb-acquire){.selfRef}
:::

[]{#name-example-of-the-sadb-seq-ove}

::: {#sadb-seq-overflow-not}
::: {#appendix-C-4.1}
``` {.sourcecode .lang-xml}
<sadb-seq-overflow
    xmlns="urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless">
      <ipsec-sa-name>in/trans/2001:db8:123::200/2001:db8:123::100
      </ipsec-sa-name>
</sadb-seq-overflow>
```
:::

[Figure 7](#figure-7){.selfRef}: [Example of the sadb-seq-overflow
Notification](#name-example-of-the-sadb-seq-ove){.selfRef}
:::

[]{#name-example-of-the-sadb-bad-spi}

::: {#sadb-bad-spi-not}
::: {#appendix-C-5.1}
``` {.sourcecode .lang-xml}
<sadb-bad-spi
         xmlns="urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless">
        <spi>666</spi>
</sadb-bad-spi>
```
:::

[Figure 8](#figure-8){.selfRef}: [Example of the sadb-bad-spi
Notification](#name-example-of-the-sadb-bad-spi){.selfRef}
:::
:::
:::

::: {#appendix-g}
::: {#appendix-D .section}
## [Appendix D.](#appendix-D){.section-number .selfRef} [Operational Use Case Examples](#name-operational-use-case-exampl){.section-name .selfRef} {#name-operational-use-case-exampl}

::: {#appendix-g1}
::: {#appendix-D.1 .section}
### [D.1.](#appendix-D.1){.section-number .selfRef} [Example of IPsec SA Establishment](#name-example-of-ipsec-sa-establi){.section-name .selfRef} {#name-example-of-ipsec-sa-establi}

This appendix exemplifies the applicability of the IKE case and IKE-less
case to traditional IPsec configurations, that is, host-to-host and
gateway-to-gateway. The following examples assume the existence of two
NSFs needing to establish an end-to-end IPsec SA to protect their
communications. Both NSFs could be two hosts that exchange traffic
(host-to-host) or gateways (gateway-to-gateway), for example, within an
enterprise that needs to protect the traffic between the networks of two
branch offices.[¶](#appendix-D.1-1){.pilcrow}

Applicability of these configurations appear in current and new
networking scenarios. For example, SD-WAN technologies are providing
dynamic and on-demand VPN connections between branch offices or between
branches and Software as a Service (SaaS) cloud services. Besides,
Infrastructure as a Service (IaaS) services providing virtualization
environments are deployments that often rely on IPsec to provide secure
channels between virtual instances (host-to-host) and providing VPN
solutions for virtualized networks
(gateway-to-gateway).[¶](#appendix-D.1-2){.pilcrow}

As can be observed in the following, the I2NSF-based IPsec management
system (for IKE and IKE-less cases) exhibits various
advantages:[¶](#appendix-D.1-3){.pilcrow}

1.  [It allows creating IPsec SAs among two NSFs, based only on the
    application of general flow-based protection policies at the I2NSF
    User. Thus, administrators can manage all security associations in a
    centralized point with an abstracted view of the
    network.[¶](#appendix-D.1-4.1){.pilcrow}]{#appendix-D.1-4.1}
2.  [Any NSF deployed in the system does not need manual configuration,
    therefore, allowing its deployment in an automated
    manner.[¶](#appendix-D.1-4.2){.pilcrow}]{#appendix-D.1-4.2}

::: {#sec-example-ikecase}
::: {#appendix-D.1.1 .section}
#### [D.1.1.](#appendix-D.1.1){.section-number .selfRef} [IKE Case](#name-ike-case-2){.section-name .selfRef} {#name-ike-case-2}

[]{#name-host-to-host-gateway-to-gat}

::: {#fig_g2gsinglecontroller1}
::: {#appendix-D.1.1-1.1 .artwork .art-text .alignCenter}
              +----------------------------------------+
              |  I2NSF User  (IPsec Management System) |
              +----------------------------------------+
                        |
               (1)    Flow-based    I2NSF Consumer-Facing
                   Protection Policy       Interface
                        |
              +---------|------------------------------+
              |         |                              |
              |         |   I2NSF Controller           |
              |         V                              |
              |   +--------------+ (2)+--------------+ |
              |   |Translate into|--->|   NETCONF/   | |
              |   |IPsec Policies|    |   RESTCONF   | |
              |   +--------------+    +--------------+ |
              |                          |     |       |
              |                          |     |       |
              +--------------------------|-----|-------+
                                         |     |
             I2NSF NSF-Facing Interface  |     |
                                         | (3) |
               |-------------------------+     +---|
               V                                   V
       +----------------------+         +----------------------+
       |       NSF A          |         |        NSF B         |
       | IKEv2/IPsec(SPD/PAD) |         | IKEv2/IPsec(SPD/PAD) |
       +----------------------+         +----------------------+
:::

[Figure 9](#figure-9){.selfRef}: [Host-to-Host/Gateway-to-Gateway for
the IKE Case](#name-host-to-host-gateway-to-gat){.selfRef}
:::

[Figure 9](#fig_g2gsinglecontroller1){.xref} describes the application
of the IKE case when a data packet needs to be protected in the path
between NSF A and NSF B:[¶](#appendix-D.1.1-2){.pilcrow}

1.  [The I2NSF User defines a general flow-based protection policy
    (e.g., protect data traffic between NSF A and B). The I2NSF
    Controller looks for the NSFs involved (NSF A and NSF
    B).[¶](#appendix-D.1.1-3.1){.pilcrow}]{#appendix-D.1.1-3.1}
2.  [The I2NSF Controller generates IKEv2 credentials for them and
    translates the policies into SPD and PAD
    entries.[¶](#appendix-D.1.1-3.2){.pilcrow}]{#appendix-D.1.1-3.2}
3.  [The I2NSF Controller inserts an IKEv2 configuration that includes
    the SPD and PAD entries in both NSF A and NSF B. If some of
    operations with NSF A and NSF B fail, the I2NSF Controller will stop
    the process and perform a rollback operation by deleting any IKEv2,
    SPD, and PAD configuration that had been successfully installed in
    NSF A or B.[¶](#appendix-D.1.1-3.3){.pilcrow}]{#appendix-D.1.1-3.3}

If the previous steps are successful, the flow is protected by means of
the IPsec SA established with IKEv2 between NSF A and NSF
B.[¶](#appendix-D.1.1-4){.pilcrow}
:::
:::

::: {#sec-example-ikeless-case}
::: {#appendix-D.1.2 .section}
#### [D.1.2.](#appendix-D.1.2){.section-number .selfRef} [IKE-less Case](#name-ike-less-case-2){.section-name .selfRef} {#name-ike-less-case-2}

[]{#name-host-to-host-gateway-to-gate}

::: {#fig_g2gsinglecontroller2}
::: {#appendix-D.1.2-1.1 .artwork .art-text .alignCenter}
            +----------------------------------------+
            | I2NSF User  (IPsec Management System)  |
            +----------------------------------------+
                      |
           (1)   Flow-based       I2NSF Consumer-Facing
              Protection Policy      Interface
                      |
            +---------|------------------------------+
            |         |                              |
            |         |   I2NSF Controller           |
            |         V                              |
            |  +--------------+ (2) +--------------+ |
            |  |Translate into|---->|   NETCONF/   | |
            |  |IPsec Policies|     |   RESTCONF   | |
            |  +--------------+     +--------------+ |
            |                         |     |        |
            +-------------------------|-----|--------+
                                      |     |
           I2NSF NSF-Facing Interface |     |
                                      | (3) |
               |----------------------+     +--|
               V                               V
      +----------------+             +----------------+
      |     NSF A      |             |     NSF B      |
      | IPsec(SPD/SAD) |             | IPsec(SPD/SAD) |
      +----------------+             +----------------+
:::

[Figure 10](#figure-10){.selfRef}: [Host-to-Host/Gateway-to-Gateway for
the IKE-less Case](#name-host-to-host-gateway-to-gate){.selfRef}
:::

[Figure 10](#fig_g2gsinglecontroller2){.xref} describes the application
of the IKE-less case when a data packet needs to be protected in the
path between NSF A and NSF B:[¶](#appendix-D.1.2-2){.pilcrow}

1.  [The I2NSF User establishes a general flow-based protection policy,
    and the I2NSF Controller looks for the involved
    NSFs.[¶](#appendix-D.1.2-3.1){.pilcrow}]{#appendix-D.1.2-3.1}

2.  [The I2NSF Controller translates the flow-based security policies
    into IPsec SPD and SAD
    entries.[¶](#appendix-D.1.2-3.2){.pilcrow}]{#appendix-D.1.2-3.2}

3.  ::: {#appendix-D.1.2-3.3}
    The I2NSF Controller inserts these entries in both NSF A and NSF B
    IPsec databases (i.e., SPD and SAD). The following text describes
    how this would happen:[¶](#appendix-D.1.2-3.3.1){.pilcrow}

    -   [The I2NSF Controller chooses two random values as SPIs, for
        example, SPIa1 for the inbound IPsec SA in NSF A and SPIb1 for
        the inbound IPsec SA in NSF B. The value of the SPIa1 [MUST
        NOT]{.bcp14} be the same as any inbound SPI in A. In the same
        way, the value of the SPIb1 [MUST NOT]{.bcp14} be the same as
        any inbound SPI in B. Moreover, the SPIa1 [MUST]{.bcp14} be used
        in B for the outbound IPsec SA to A, while SPIb1 [MUST]{.bcp14}
        be used in A for the outbound IPsec SA to B. It also generates
        fresh cryptographic material for the new inbound/outbound IPsec
        SAs and their
        parameters.[¶](#appendix-D.1.2-3.3.2.1){.pilcrow}]{#appendix-D.1.2-3.3.2.1}
    -   [After that, the I2NSF Controller simultaneously sends the new
        inbound IPsec SA with SPIa1 and new outbound IPsec SA with SPIb1
        to NSF A and the new inbound IPsec SA with SPIb1 and new
        outbound IPsec SA with SPIa1 to B, together with the
        corresponding IPsec
        policies.[¶](#appendix-D.1.2-3.3.2.2){.pilcrow}]{#appendix-D.1.2-3.3.2.2}
    -   [Once the I2NSF Controller receives confirmation from NSF A and
        NSF B, it knows that the IPsec SAs are correctly installed and
        ready.[¶](#appendix-D.1.2-3.3.2.3){.pilcrow}]{#appendix-D.1.2-3.3.2.3}

    Another alternative to this operation is the I2NSF Controller first
    sends the IPsec policies and new inbound IPsec SAs to A and B. Once
    it obtains a successful confirmation of these operations from NSF A
    and NSF B, it proceeds with installing the new outbound IPsec SAs.
    Even though this procedure may increase the latency to complete the
    process, no traffic is sent over the network until the IPsec SAs are
    completely operative. In any case, other alternatives [MAY]{.bcp14}
    be possible to implement step 3.[¶](#appendix-D.1.2-3.3.3){.pilcrow}
    :::

4.  [If some of the operations described above fail (e.g., NSF A reports
    an error when the I2NSF Controller is trying to install the SPD
    entry, the new inbound or outbound IPsec SAs), the I2NSF Controller
    [MUST]{.bcp14} perform rollback operations by deleting any new
    inbound or outbound IPsec SA and SPD entry that had been
    successfully installed in any of the NSFs (e.g., NSF B) and stop the
    process. Note that the I2NSF Controller [MAY]{.bcp14} retry several
    times before giving
    up.[¶](#appendix-D.1.2-3.4){.pilcrow}]{#appendix-D.1.2-3.4}

5.  [Otherwise, if the steps 1 to 3 are successful, the flow between NSF
    A and NSF B is protected by means of the IPsec SAs established by
    the I2NSF Controller. It is worth mentioning that the I2NSF
    Controller associates a lifetime to the new IPsec SAs. When this
    lifetime expires, the NSF will send a sadb-expire notification to
    the I2NSF Controller in order to start the rekeying
    process.[¶](#appendix-D.1.2-3.5){.pilcrow}]{#appendix-D.1.2-3.5}

Instead of installing IPsec policies (in the SPD) and IPsec SAs (in the
SAD) in step 3 (proactive mode), it is also possible that the I2NSF
Controller only installs the SPD entries in step 3 (reactive mode). In
such a case, when a data packet requires to be protected with IPsec, the
NSF that first saw the data packet will send a sadb-acquire notification
that informs the I2NSF Controller that needs SAD entries with the IPsec
SAs to process the data packet. Again, if some of the operations
installing the new inbound/outbound IPsec SAs fail, the I2NSF Controller
stops the process and performs a rollback operation by deleting any new
inbound/outbound SAs that had been successfully
installed.[¶](#appendix-D.1.2-4){.pilcrow}
:::
:::
:::
:::

::: {#appendix-g2}
::: {#appendix-D.2 .section}
### [D.2.](#appendix-D.2){.section-number .selfRef} [Example of the Rekeying Process in IKE-less Case](#name-example-of-the-rekeying-pro){.section-name .selfRef} {#name-example-of-the-rekeying-pro}

To explain an example of the rekeying process between two IPsec NSFs, A
and B, assume that SPIa1 identifies the inbound IPsec SA in A and SPIb1
identifies the inbound IPsec SA in B. The rekeying process will take the
following steps:[¶](#appendix-D.2-1){.pilcrow}

1.  [The I2NSF Controller chooses two random values as SPI for the new
    inbound IPsec SAs, for example, SPIa2 for the inbound IPsec SA in A
    and SPIb2 for the inbound IPsec SA in B. The value of the SPIa1
    [MUST NOT]{.bcp14} be the same as any inbound SPI in A. In the same
    way, the value of the SPIb1 [MUST NOT]{.bcp14} be the same as any
    inbound SPI in B. Then, the I2NSF Controller creates an inbound
    IPsec SA with SPIa2 in A and another inbound IPsec SA in B with
    SPIb2. It can send this information simultaneously to A and
    B.[¶](#appendix-D.2-2.1){.pilcrow}]{#appendix-D.2-2.1}
2.  [Once the I2NSF Controller receives confirmation from A and B, the
    controller knows that the inbound IPsec SAs are correctly installed.
    Then, it proceeds to send, in parallel to A and B, the outbound
    IPsec SAs: the outbound IPsec SA to A with SPIb2 and the outbound
    IPsec SA to B with SPIa2. At this point, the new IPsec SAs are
    ready.[¶](#appendix-D.2-2.2){.pilcrow}]{#appendix-D.2-2.2}
3.  [Once the I2NSF Controller receives confirmation from A and B that
    the outbound IPsec SAs have been installed, the I2NSF Controller, in
    parallel, deletes the old IPsec SAs from A (inbound SPIa1 and
    outbound SPIb1) and B (outbound SPIa1 and inbound
    SPIb1).[¶](#appendix-D.2-2.3){.pilcrow}]{#appendix-D.2-2.3}

If some of the operations in step 1 fail (e.g., NSF A reports an error
when the I2NSF Controller is trying to install a new inbound IPsec SA),
the I2NSF Controller [MUST]{.bcp14} perform rollback operations by
removing any new inbound SA that had been successfully installed during
step 1.[¶](#appendix-D.2-3){.pilcrow}

If step 1 is successful but some of the operations in step 2 fail (e.g.,
NSF A reports an error when the I2NSF Controller is trying to install
the new outbound IPsec SA), the I2NSF Controller [MUST]{.bcp14} perform
a rollback operation by deleting any new outbound SA that had been
successfully installed during step 2 and by deleting the inbound SAs
created in step 1, in that order.[¶](#appendix-D.2-4){.pilcrow}

If the steps 1 and 2 are successful but the step 3 fails, the I2NSF
Controller will avoid any rollback of the operations carried out in
steps 1 and 2, since new and valid IPsec SAs were created and are
functional. The I2NSF Controller [MAY]{.bcp14} reattempt to remove the
old inbound and outbound IPsec SAs in NSF A and NSF B several times
until it receives a success or it gives up. In the last case, the old
IPsec SAs will be removed when their corresponding hard lifetime is
reached.[¶](#appendix-D.2-5){.pilcrow}
:::
:::

::: {#appendix-g3}
::: {#appendix-D.3 .section}
### [D.3.](#appendix-D.3){.section-number .selfRef} [Example of Managing NSF State Loss in the IKE-less Case](#name-example-of-managing-nsf-sta){.section-name .selfRef} {#name-example-of-managing-nsf-sta}

In the IKE-less case, if the I2NSF Controller detects that an NSF has
lost the IPsec state, it could follow the next
steps:[¶](#appendix-D.3-1){.pilcrow}

1.  [The I2NSF Controller [SHOULD]{.bcp14} delete the old IPsec SAs on
    the non-failed nodes, established with the failed node. This
    prevents the non-failed nodes from leaking
    plaintext.[¶](#appendix-D.3-2.1){.pilcrow}]{#appendix-D.3-2.1}
2.  [If the affected node restarts, the I2NSF Controller configures the
    new inbound IPsec SAs between the affected node and all the nodes it
    was talking to.[¶](#appendix-D.3-2.2){.pilcrow}]{#appendix-D.3-2.2}
3.  [After these inbound IPsec SAs have been established, the I2NSF
    Controller configures the outbound IPsec SAs in
    parallel.[¶](#appendix-D.3-2.3){.pilcrow}]{#appendix-D.3-2.3}

Steps 2 and 3 can be performed at the same time at the cost of a
potential packet loss. If this is not critical, then it is an
optimization since the number of exchanges between the I2NSF Controller
and NSFs is lower.[¶](#appendix-D.3-3){.pilcrow}
:::
:::
:::
:::

::: {#ack}
::: {#appendix-E .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

Authors want to thank [Paul Wouters]{.contact-name}, [Valery
Smyslov]{.contact-name}, [Sowmini Varadhan]{.contact-name}, [David
Carrel]{.contact-name}, [Yoav Nir]{.contact-name}, [Tero
Kivinen]{.contact-name}, [Martin Bjorklund]{.contact-name}, [Graham
Bartlett]{.contact-name}, [Sandeep Kampati]{.contact-name}, [Linda
Dunbar]{.contact-name}, [Mohit Sethi]{.contact-name}, [Martin
Bjorklund]{.contact-name}, [Tom Petch]{.contact-name}, [Christian
Hopps]{.contact-name}, [Rob Wilton]{.contact-name}, [Carlos J.
Bernardos]{.contact-name}, [Alejandro Perez-Mendez]{.contact-name},
[Alejandro Abad-Carrascosa]{.contact-name}, [Ignacio
Martinez]{.contact-name}, [Ruben Ricart]{.contact-name}, and all IESG
members that have reviewed this document for their valuable
comments.[¶](#appendix-E-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-F .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Rafa Marin-Lopez]{.fn .nameRole}
:::

::: {.left dir="auto"}
[University of Murcia]{.org}
:::

::: {.left dir="auto"}
[Faculty of Computer Science]{.extended-address}
:::

::: {.left dir="auto"}
[Campus de Espinardo S/N]{.street-address}
:::

::: {.left dir="auto"}
[30100]{.postal-code} [Murcia]{.region}
:::

::: {.left dir="auto"}
[Spain]{.country-name}
:::

::: tel
Phone: [+34 868 88 85 01](tel:+34%20868%2088%2085%2001){.tel}
:::

::: email
Email: <rafa@um.es>
:::

::: {.left dir="auto"}
[Gabriel Lopez-Millan]{.fn .nameRole}
:::

::: {.left dir="auto"}
[University of Murcia]{.org}
:::

::: {.left dir="auto"}
[Faculty of Computer Science]{.extended-address}
:::

::: {.left dir="auto"}
[Campus de Espinardo S/N]{.street-address}
:::

::: {.left dir="auto"}
[30100]{.postal-code} [Murcia]{.region}
:::

::: {.left dir="auto"}
[Spain]{.country-name}
:::

::: tel
Phone: [+34 868 88 85 04](tel:+34%20868%2088%2085%2004){.tel}
:::

::: email
Email: <gabilm@um.es>
:::

::: {.left dir="auto"}
[Fernando Pereniguez-Garcia]{.fn .nameRole}
:::

::: {.left dir="auto"}
[University Defense Center]{.org}
:::

::: {.left dir="auto"}
[Spanish Air Force Academy]{.extended-address}
:::

::: {.left dir="auto"}
[MDE-UPCT]{.street-address}
:::

::: {.left dir="auto"}
[30720]{.postal-code} [San Javier]{.locality} [Murcia]{.region}
:::

::: {.left dir="auto"}
[Spain]{.country-name}
:::

::: tel
Phone: [+34 968 18 99 46](tel:+34%20968%2018%2099%2046){.tel}
:::

::: email
Email: <fernando.pereniguez@cud.upct.es>
:::
:::
:::
