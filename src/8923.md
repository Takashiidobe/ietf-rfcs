  RFC 8923           Minimal Transport Services   October 2020
  ------------------ ---------------------------- --------------
  Welzl & Gjessing   Informational                \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8923](https://www.rfc-editor.org/rfc/rfc8923){.eref}

Category:
:   Informational

Published:
:   October 2020

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    M. Welzl
    :::

    ::: org
    University of Oslo
    :::
    :::

    ::: author
    ::: author-name
    S. Gjessing
    :::

    ::: org
    University of Oslo
    :::
    :::
:::

# RFC 8923 {#rfcnum}

# A Minimal Set of Transport Services for End Systems {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document recommends a minimal set of Transport Services offered by
end systems and gives guidance on choosing among the available
mechanisms and protocols. It is based on the set of transport features
in RFC 8303.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This document is not an Internet Standards Track specification; it is
published for informational
purposes.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Not all documents approved
by the IESG are candidates for any level of Internet Standard; see
Section 2 of RFC 7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8923>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Deriving the Minimal
    Set](#name-deriving-the-minimal-set){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [The Reduced Set of Transport
    Features](#name-the-reduced-set-of-transpor){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [CONNECTION-Related Transport
        Features](#name-connection-related-transpor){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [DATA-Transfer-Related Transport
        Features](#name-data-transfer-related-trans){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.4.2.2.2.1}
            [4.2.1](#section-4.2.1){.xref}.  [Sending
            Data](#name-sending-data){.xref}[¶](#section-toc.1-1.4.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.2}
            [4.2.2](#section-4.2.2){.xref}.  [Receiving
            Data](#name-receiving-data){.xref}[¶](#section-toc.1-1.4.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.3}
            [4.2.3](#section-4.2.3){.xref}.  [Errors](#name-errors){.xref}[¶](#section-toc.1-1.4.2.2.2.3.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Discussion](#name-discussion){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Sending Messages, Receiving
        Bytes](#name-sending-messages-receiving-){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Stream Schedulers without
        Streams](#name-stream-schedulers-without-s){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [Early Data
        Transmission](#name-early-data-transmission){.xref}[¶](#section-toc.1-1.5.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.4}
        [5.4](#section-5.4){.xref}.  [Sender Running
        Dry](#name-sender-running-dry){.xref}[¶](#section-toc.1-1.5.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.5}
        [5.5](#section-5.5){.xref}.  [Capacity
        Profile](#name-capacity-profile){.xref}[¶](#section-toc.1-1.5.2.5.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.6}
        [5.6](#section-5.6){.xref}.  [Security](#name-security){.xref}[¶](#section-toc.1-1.5.2.6.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.7}
        [5.7](#section-5.7){.xref}.  [Packet
        Size](#name-packet-size){.xref}[¶](#section-toc.1-1.5.2.7.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [The Minimal Set of Transport
    Features](#name-the-minimal-set-of-transpor){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [ESTABLISHMENT, AVAILABILITY, and
        TERMINATION](#name-establishment-availability-){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [MAINTENANCE](#name-maintenance){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.6.2.2.2.1}
            [6.2.1](#section-6.2.1){.xref}.  [Connection
            Groups](#name-connection-groups){.xref}[¶](#section-toc.1-1.6.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.6.2.2.2.2}
            [6.2.2](#section-6.2.2){.xref}.  [Individual
            Connections](#name-individual-connections){.xref}[¶](#section-toc.1-1.6.2.2.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [DATA
        Transfer](#name-data-transfer){.xref}[¶](#section-toc.1-1.6.2.3.1){.pilcrow}

        -   ::: {#section-toc.1-1.6.2.3.2.1}
            [6.3.1](#section-6.3.1){.xref}.  [Sending
            Data](#name-sending-data-2){.xref}[¶](#section-toc.1-1.6.2.3.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.6.2.3.2.2}
            [6.3.2](#section-6.3.2){.xref}.  [Receiving
            Data](#name-receiving-data-2){.xref}[¶](#section-toc.1-1.6.2.3.2.2.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [References](#name-references){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.9.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.9.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [Appendix A](#section-appendix.a){.xref}.  [The Superset of
    Transport
    Features](#name-the-superset-of-transport-f){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}

    -   ::: {#section-toc.1-1.10.2.1}
        [A.1](#section-a.1){.xref}.  [CONNECTION-Related Transport
        Features](#name-connection-related-transport){.xref}[¶](#section-toc.1-1.10.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.10.2.2}
        [A.2](#section-a.2){.xref}.  [DATA-Transfer-Related Transport
        Features](#name-data-transfer-related-transp){.xref}[¶](#section-toc.1-1.10.2.2.1){.pilcrow}

        -   ::: {#section-toc.1-1.10.2.2.2.1}
            [A.2.1](#section-a.2.1){.xref}.  [Sending
            Data](#name-sending-data-3){.xref}[¶](#section-toc.1-1.10.2.2.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.10.2.2.2.2}
            [A.2.2](#section-a.2.2){.xref}.  [Receiving
            Data](#name-receiving-data-3){.xref}[¶](#section-toc.1-1.10.2.2.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.10.2.2.2.3}
            [A.2.3](#section-a.2.3){.xref}.  [Errors](#name-errors-2){.xref}[¶](#section-toc.1-1.10.2.2.2.3.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.11}
    [](#section-appendix.b){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.12}
    [](#section-appendix.c){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}
    :::
:::
:::

::: {#sec-intro}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Currently, the set of Transport Services that most applications use is
based on TCP and UDP (and protocols that are layered on top of them);
this limits the ability for the network stack to make use of features of
other transport protocols. For example, if a protocol supports
out-of-order message delivery but applications always assume that the
network provides an ordered byte stream, then the network stack can not
immediately deliver a message that arrives out of order; doing so would
break a fundamental assumption of the application. The net result is
unnecessary head-of-line blocking delay.[¶](#section-1-1){.pilcrow}

By exposing the Transport Services of multiple transport protocols, a
transport system can make it possible for applications to use these
services without being statically bound to a specific transport
protocol. The first step towards the design of such a system was taken
by \[[RFC8095](#RFC8095){.xref}\], which surveys a large number of
transports, and \[[RFC8303](#RFC8303){.xref}\] as well as
\[[RFC8304](#RFC8304){.xref}\], which identify the specific transport
features that are exposed to applications by the protocols TCP,
Multipath TCP (MPTCP), UDP(-Lite), and Stream Control Transmission
Protocol (SCTP), as well as the Low Extra Delay Background Transport
(LEDBAT) congestion control mechanism. LEDBAT was included as the only
congestion control mechanism in this list because the \"low extra delay
background transport\" service that it offers is significantly different
from the typical service provided by other congestion control
mechanisms. This memo is based on these documents and follows the same
terminology (also listed below). Because the considered transport
protocols conjointly cover a wide range of transport features, there is
reason to hope that the resulting set (and the reasoning that led to it)
will also apply to many aspects of other transport protocols that may be
in use today or may be designed in the
future.[¶](#section-1-2){.pilcrow}

By decoupling applications from transport protocols, a transport system
provides a different abstraction level than the Berkeley sockets
interface \[[POSIX](#POSIX){.xref}\]. As with high- vs. low-level
programming languages, a higher abstraction level allows more freedom
for automation below the interface, yet it takes some control away from
the application programmer. This is the design trade-off that a
transport system developer is facing, and this document provides
guidance on the design of this abstraction level. Some transport
features are currently rarely offered by APIs, yet they must be offered
or they can never be used. Other transport features are offered by the
APIs of the protocols covered here, but not exposing them in an API
would allow for more freedom to automate protocol usage in a transport
system. The minimal set presented here is an effort to find a middle
ground that can be recommended for transport systems to implement, on
the basis of the transport features discussed in
\[[RFC8303](#RFC8303){.xref}\].[¶](#section-1-3){.pilcrow}

Applications use a wide variety of APIs today. While this document was
created to ensure the API developed in the Transport Services (TAPS)
Working Group \[[TAPS-INTERFACE](#I-D.ietf-taps-interface){.xref}\]
includes the most important transport features, the minimal set
presented here must be reflected in \*all\* network APIs in order for
the underlying functionality to become usable everywhere. For example,
it does not help an application that talks to a library that offers its
own communication interface if the underlying Berkeley Sockets API is
extended to offer \"unordered message delivery\", but the library only
exposes an ordered byte stream. Both the Berkeley Sockets API and the
library would have to expose the \"unordered message delivery\"
transport feature (alternatively, there may be ways for certain types of
libraries to use this transport feature without exposing it, based on
knowledge about the applications, but this is not the general case).
Similarly, transport protocols such as the Stream Control Transmission
Protocol (SCTP) offer multi-streaming, which cannot be utilized, e.g.,
to prioritize messages between streams, unless applications communicate
the priorities and the group of connections upon which these priorities
should be applied. In most situations, in the interest of being as
flexible and efficient as possible, the best choice will be for a
library to expose at least all of the transport features that are
recommended as a \"minimal set\" here.[¶](#section-1-4){.pilcrow}

This \"minimal set\" can be implemented \"one-sided\" over TCP. This
means that a sender-side transport system can talk to a standard TCP
receiver, and a receiver-side transport system can talk to a standard
TCP sender. If certain limitations are put in place, the \"minimal set\"
can also be implemented \"one-sided\" over UDP. While the possibility of
such \"one-sided\" implementation may help deployment, it comes at the
cost of limiting the set to services that can also be provided by TCP
(or, with further limitations, UDP). Thus, the minimal set of transport
features here is applicable for many, but not all, applications; some
application protocols have requirements that are not met by this
\"minimal set\".[¶](#section-1-5){.pilcrow}

Note that, throughout this document, protocols are meant to be used
natively. For example, when transport features of TCP, or
\"implementation over\" TCP is discussed, this refers to native usage of
TCP rather than TCP being encapsulated in some other transport protocol
such as UDP.[¶](#section-1-6){.pilcrow}
:::
:::

::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

[]{.break}

Transport Feature:
:   A specific end-to-end feature that the transport layer provides to
    an application. Examples include confidentiality, reliable delivery,
    ordered delivery, message-versus-stream orientation,
    etc.[¶](#section-2-1.2){.pilcrow}
:   

Transport Service:
:   A set of Transport Features, without an association to any given
    framing protocol, that provides a complete service to an
    application.[¶](#section-2-1.4){.pilcrow}
:   

Transport Protocol:
:   An implementation that provides one or more different Transport
    Services using a specific framing and header format on the
    wire.[¶](#section-2-1.6){.pilcrow}
:   

Application:
:   An entity that uses a transport-layer interface for end-to-end
    delivery of data across the network (this may also be an upper-layer
    protocol or tunnel encapsulation).[¶](#section-2-1.8){.pilcrow}
:   

Application-specific knowledge:
:   Knowledge that only applications have.[¶](#section-2-1.10){.pilcrow}
:   

End system:
:   An entity that communicates with one or more other end systems using
    a transport protocol. An end system provides a transport-layer
    interface to applications.[¶](#section-2-1.12){.pilcrow}
:   

Connection:
:   Shared state of two or more end systems that persists across
    messages that are transmitted between these end
    systems.[¶](#section-2-1.14){.pilcrow}
:   

Connection Group:
:   A set of connections that share the same configuration (configuring
    one of them causes all other connections in the same group to be
    configured in the same way). We call connections that belong to a
    connection group \"grouped\", while \"ungrouped\" connections are
    not a part of a connection group.[¶](#section-2-1.16){.pilcrow}
:   

Socket:
:   The combination of a destination IP address and a destination port
    number.[¶](#section-2-1.18){.pilcrow}
:   

Moreover, throughout the document, the protocol name \"UDP(-Lite)\" is
used when discussing transport features that are equivalent for UDP and
UDP-Lite; similarly, the protocol name \"TCP\" refers to both TCP and
MPTCP.[¶](#section-2-2){.pilcrow}
:::

::: {#deriving}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Deriving the Minimal Set](#name-deriving-the-minimal-set){.section-name .selfRef} {#name-deriving-the-minimal-set}

We assume that applications have no specific requirements that need
knowledge about the network, e.g., regarding the choice of network
interface or the end-to-end path. Even with these assumptions, there are
certain requirements that are strictly kept by transport protocols
today, and these must also be kept by a transport system. Some of these
requirements relate to transport features that we call
\"Functional\".[¶](#section-3-1){.pilcrow}

Functional transport features provide functionality that cannot be used
without the application knowing about them, or else they violate
assumptions that might cause the application to fail. For example,
ordered message delivery is a functional transport feature: it cannot be
configured without the application knowing about it because the
application\'s assumption could be that messages always arrive in order.
Failure includes any change of the application behavior that is not
performance oriented, e.g., security.[¶](#section-3-2){.pilcrow}

\"Change DSCP\" and \"Disable Nagle algorithm\" are examples of
transport features that we call \"Optimizing\"; if a transport system
autonomously decides to enable or disable them, an application will not
fail, but a transport system may be able to communicate more efficiently
if the application is in control of this optimizing transport feature.
These transport features require application-specific knowledge (e.g.,
about delay/bandwidth requirements or the length of future data blocks
that are to be transmitted).[¶](#section-3-3){.pilcrow}

The transport features of IETF transport protocols that do not require
application-specific knowledge and could therefore be utilized by a
transport system on its own without involving the application are called
\"Automatable\".[¶](#section-3-4){.pilcrow}

We approach the construction of a minimal set of transport features in
the following way:[¶](#section-3-5){.pilcrow}

1.  [Categorization ([Appendix A](#super){.xref}): The superset of
    transport features from \[[RFC8303](#RFC8303){.xref}\] is presented,
    and transport features are categorized as Functional, Optimizing, or
    Automatable for later
    reduction.[¶](#section-3-6.1){.pilcrow}]{#section-3-6.1}
2.  [Reduction ([Section 4](#Reduction){.xref}): A shorter list of
    transport features is derived from the categorization in the first
    step. This removes all transport features that do not require
    application-specific knowledge or would result in semantically
    incorrect behavior if they were implemented over TCP or
    UDP.[¶](#section-3-6.2){.pilcrow}]{#section-3-6.2}
3.  [Discussion ([Section 5](#Discussion){.xref}): The resulting list
    shows a number of peculiarities that are discussed, to provide a
    basis for constructing the minimal
    set.[¶](#section-3-6.3){.pilcrow}]{#section-3-6.3}
4.  [Construction ([Section 6](#minset){.xref}): Based on the reduced
    set and the discussion of the transport features therein, a minimal
    set is constructed.[¶](#section-3-6.4){.pilcrow}]{#section-3-6.4}

Following \[[RFC8303](#RFC8303){.xref}\] and retaining its terminology,
we divide the transport features into two main groups as
follows:[¶](#section-3-7){.pilcrow}

1.  ::: {#section-3-8.1}
    CONNECTION-related transport features[¶](#section-3-8.1.1){.pilcrow}

    -   [ESTABLISHMENT[¶](#section-3-8.1.2.1){.pilcrow}]{#section-3-8.1.2.1}
    -   [AVAILABILITY[¶](#section-3-8.1.2.2){.pilcrow}]{#section-3-8.1.2.2}
    -   [MAINTENANCE[¶](#section-3-8.1.2.3){.pilcrow}]{#section-3-8.1.2.3}
    -   [TERMINATION[¶](#section-3-8.1.2.4){.pilcrow}]{#section-3-8.1.2.4}
    :::

2.  ::: {#section-3-8.2}
    DATA-Transfer-related transport
    features[¶](#section-3-8.2.1){.pilcrow}

    -   [Sending
        Data[¶](#section-3-8.2.2.1){.pilcrow}]{#section-3-8.2.2.1}
    -   [Receiving
        Data[¶](#section-3-8.2.2.2){.pilcrow}]{#section-3-8.2.2.2}
    -   [Errors[¶](#section-3-8.2.2.3){.pilcrow}]{#section-3-8.2.2.3}
    :::
:::
:::

::: {#Reduction}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [The Reduced Set of Transport Features](#name-the-reduced-set-of-transpor){.section-name .selfRef} {#name-the-reduced-set-of-transpor}

By hiding automatable transport features from the application, a
transport system can gain opportunities to automate the usage of
network-related functionality. This can facilitate using the transport
system for the application programmer and it allows for optimizations
that may not be possible for an application. For instance, system-wide
configurations regarding the usage of multiple interfaces can better be
exploited if the choice of the interface is not entirely up to the
application. Therefore, since they are not strictly necessary to expose
in a transport system, we do not include automatable transport features
in the reduced set of transport features. This leaves us with only the
transport features that are either optimizing or
functional.[¶](#section-4-1){.pilcrow}

A transport system should be able to communicate via TCP or UDP if
alternative transport protocols are found not to work. For many
transport features, this is possible, often by simply not doing anything
when a specific request is made. For some transport features, however,
it was identified that direct usage of neither TCP nor UDP is possible;
in these cases, even not doing anything would incur semantically
incorrect behavior. Whenever an application would make use of one of
these transport features, this would eliminate the possibility to use
TCP or UDP. Thus, we only keep the functional and optimizing transport
features for which an implementation over either TCP or UDP is possible
in our reduced set.[¶](#section-4-2){.pilcrow}

The following list contains the transport features from [Appendix
A](#super){.xref}, reduced using these rules. The \"minimal set\"
derived in this document is meant to be implementable \"one-sided\" over
TCP and, with limitations, UDP. In the list, we therefore precede a
transport feature with \"T:\" if an implementation over TCP is possible,
\"U:\" if an implementation over UDP is possible, and \"T,U:\" if an
implementation over either TCP or UDP is
possible.[¶](#section-4-3){.pilcrow}

::: {#conn-reduced}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [CONNECTION-Related Transport Features](#name-connection-related-transpor){.section-name .selfRef} {#name-connection-related-transpor}

ESTABLISHMENT:[¶](#section-4.1-1){.pilcrow}

-   [T,U: Connect[¶](#section-4.1-2.1){.pilcrow}]{#section-4.1-2.1}
-   [T,U: Specify number of attempts and/or timeout for the first
    establishment
    message[¶](#section-4.1-2.2){.pilcrow}]{#section-4.1-2.2}
-   [T,U: Disable
    MPTCP[¶](#section-4.1-2.3){.pilcrow}]{#section-4.1-2.3}
-   [T: Configure
    authentication[¶](#section-4.1-2.4){.pilcrow}]{#section-4.1-2.4}
-   [T: Hand over a message to reliably transfer (possibly multiple
    times) before connection
    establishment[¶](#section-4.1-2.5){.pilcrow}]{#section-4.1-2.5}
-   [T: Hand over a message to reliably transfer during connection
    establishment[¶](#section-4.1-2.6){.pilcrow}]{#section-4.1-2.6}

AVAILABILITY:[¶](#section-4.1-3){.pilcrow}

-   [T,U: Listen[¶](#section-4.1-4.1){.pilcrow}]{#section-4.1-4.1}
-   [T,U: Disable
    MPTCP[¶](#section-4.1-4.2){.pilcrow}]{#section-4.1-4.2}
-   [T: Configure
    authentication[¶](#section-4.1-4.3){.pilcrow}]{#section-4.1-4.3}

MAINTENANCE:[¶](#section-4.1-5){.pilcrow}

-   [T: Change timeout for aborting connection (using retransmit limit
    or time value)[¶](#section-4.1-6.1){.pilcrow}]{#section-4.1-6.1}
-   [T: Suggest timeout to the
    peer[¶](#section-4.1-6.2){.pilcrow}]{#section-4.1-6.2}
-   [T,U: Disable Nagle
    algorithm[¶](#section-4.1-6.3){.pilcrow}]{#section-4.1-6.3}
-   [T,U: Notification of Excessive Retransmissions (early warning below
    abortion
    threshold)[¶](#section-4.1-6.4){.pilcrow}]{#section-4.1-6.4}
-   [T,U: Specify DSCP
    field[¶](#section-4.1-6.5){.pilcrow}]{#section-4.1-6.5}
-   [T,U: Notification of ICMP error message
    arrival[¶](#section-4.1-6.6){.pilcrow}]{#section-4.1-6.6}
-   [T: Change authentication
    parameters[¶](#section-4.1-6.7){.pilcrow}]{#section-4.1-6.7}
-   [T: Obtain authentication
    information[¶](#section-4.1-6.8){.pilcrow}]{#section-4.1-6.8}
-   [T,U: Set Cookie life
    value[¶](#section-4.1-6.9){.pilcrow}]{#section-4.1-6.9}
-   [T,U: Choose a scheduler to operate between streams of an
    association[¶](#section-4.1-6.10){.pilcrow}]{#section-4.1-6.10}
-   [T,U: Configure priority or weight for a
    scheduler[¶](#section-4.1-6.11){.pilcrow}]{#section-4.1-6.11}
-   [T,U: Disable checksum when
    sending[¶](#section-4.1-6.12){.pilcrow}]{#section-4.1-6.12}
-   [T,U: Disable checksum requirement when
    receiving[¶](#section-4.1-6.13){.pilcrow}]{#section-4.1-6.13}
-   [T,U: Specify checksum coverage used by the
    sender[¶](#section-4.1-6.14){.pilcrow}]{#section-4.1-6.14}
-   [T,U: Specify minimum checksum coverage required by
    receiver[¶](#section-4.1-6.15){.pilcrow}]{#section-4.1-6.15}
-   [T,U: Specify DF
    field[¶](#section-4.1-6.16){.pilcrow}]{#section-4.1-6.16}
-   [T,U: Get max. transport-message size that may be sent using a
    non-fragmented IP packet from the configured
    interface[¶](#section-4.1-6.17){.pilcrow}]{#section-4.1-6.17}
-   [T,U: Get max. transport-message size that may be received from the
    configured
    interface[¶](#section-4.1-6.18){.pilcrow}]{#section-4.1-6.18}
-   [T,U: Obtain ECN
    field[¶](#section-4.1-6.19){.pilcrow}]{#section-4.1-6.19}
-   [T,U: Enable and configure a \"Low Extra Delay Background
    Transfer\"[¶](#section-4.1-6.20){.pilcrow}]{#section-4.1-6.20}

TERMINATION:[¶](#section-4.1-7){.pilcrow}

-   [T: Close after reliably delivering all remaining data, causing an
    event informing the application on the other
    side[¶](#section-4.1-8.1){.pilcrow}]{#section-4.1-8.1}
-   [T: Abort without delivering remaining data, causing an event
    informing the application on the other
    side[¶](#section-4.1-8.2){.pilcrow}]{#section-4.1-8.2}
-   [T,U: Abort without delivering remaining data, not causing an event
    informing the application on the other
    side[¶](#section-4.1-8.3){.pilcrow}]{#section-4.1-8.3}
-   [T,U: Timeout event when data could not be delivered for too
    long[¶](#section-4.1-8.4){.pilcrow}]{#section-4.1-8.4}
:::
:::

::: {#data-reduced}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [DATA-Transfer-Related Transport Features](#name-data-transfer-related-trans){.section-name .selfRef} {#name-data-transfer-related-trans}

::: {#data-sending-reduced}
::: {#section-4.2.1 .section}
#### [4.2.1.](#section-4.2.1){.section-number .selfRef} [Sending Data](#name-sending-data){.section-name .selfRef} {#name-sending-data}

-   [T: Reliably transfer data, with congestion
    control[¶](#section-4.2.1-1.1){.pilcrow}]{#section-4.2.1-1.1}
-   [T: Reliably transfer a message, with congestion
    control[¶](#section-4.2.1-1.2){.pilcrow}]{#section-4.2.1-1.2}
-   [T,U: Unreliably transfer a
    message[¶](#section-4.2.1-1.3){.pilcrow}]{#section-4.2.1-1.3}
-   [T: Configurable Message
    Reliability[¶](#section-4.2.1-1.4){.pilcrow}]{#section-4.2.1-1.4}
-   [T: Ordered message delivery (potentially slower than
    unordered)[¶](#section-4.2.1-1.5){.pilcrow}]{#section-4.2.1-1.5}
-   [T,U: Unordered message delivery (potentially faster than
    ordered)[¶](#section-4.2.1-1.6){.pilcrow}]{#section-4.2.1-1.6}
-   [T,U: Request not to bundle
    messages[¶](#section-4.2.1-1.7){.pilcrow}]{#section-4.2.1-1.7}
-   [T: Specifying a key id to be used to authenticate a
    message[¶](#section-4.2.1-1.8){.pilcrow}]{#section-4.2.1-1.8}
-   [T,U: Request not to delay the acknowledgement (SACK) of a
    message[¶](#section-4.2.1-1.9){.pilcrow}]{#section-4.2.1-1.9}
:::
:::

::: {#data-receiving-reduced}
::: {#section-4.2.2 .section}
#### [4.2.2.](#section-4.2.2){.section-number .selfRef} [Receiving Data](#name-receiving-data){.section-name .selfRef} {#name-receiving-data}

-   [T,U: Receive data (with no message
    delimiting)[¶](#section-4.2.2-1.1){.pilcrow}]{#section-4.2.2-1.1}
-   [U: Receive a
    message[¶](#section-4.2.2-1.2){.pilcrow}]{#section-4.2.2-1.2}
-   [T,U: Information about partial message
    arrival[¶](#section-4.2.2-1.3){.pilcrow}]{#section-4.2.2-1.3}
:::
:::

::: {#data-errors-reduced}
::: {#section-4.2.3 .section}
#### [4.2.3.](#section-4.2.3){.section-number .selfRef} [Errors](#name-errors){.section-name .selfRef} {#name-errors}

This section describes sending failures that are associated with a
specific call to in the \"Sending Data\" category ([Appendix
A.2.1](#data-sending-pass3){.xref}).[¶](#section-4.2.3-1){.pilcrow}

-   [T,U: Notification of send
    failures[¶](#section-4.2.3-2.1){.pilcrow}]{#section-4.2.3-2.1}
-   [T,U: Notification that the stack has no more user data to
    send[¶](#section-4.2.3-2.2){.pilcrow}]{#section-4.2.3-2.2}
-   [T,U: Notification to a receiver that a partial message delivery has
    been aborted[¶](#section-4.2.3-2.3){.pilcrow}]{#section-4.2.3-2.3}
:::
:::
:::
:::
:::
:::

::: {#Discussion}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Discussion](#name-discussion){.section-name .selfRef} {#name-discussion}

The reduced set in the previous section exhibits a number of
peculiarities, which we will discuss in the following. This section
focuses on TCP because, with the exception of one particular transport
feature (\"Receive a message\"; we will discuss this in [Section
5.1](#sendmsg){.xref}), the list shows that UDP is strictly a subset of
TCP. We can first try to understand how to build a transport system that
can run over TCP, and then narrow down the result further to allow that
the system can always run over either TCP or UDP (which effectively
means removing everything related to reliability, ordering,
authentication, and closing/aborting with a notification to the
peer).[¶](#section-5-1){.pilcrow}

Note that, because the functional transport features of UDP are, with
the exception of \"Receive a message\", a subset of TCP, TCP can be used
as a replacement for UDP whenever an application does not need message
delimiting (e.g., because the application-layer protocol already does
it). This has been recognized by many applications that already do this
in practice, by trying to communicate with UDP at first and falling back
to TCP in case of a connection failure.[¶](#section-5-2){.pilcrow}

::: {#sendmsg}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Sending Messages, Receiving Bytes](#name-sending-messages-receiving-){.section-name .selfRef} {#name-sending-messages-receiving-}

For implementing a transport system over TCP, there are several
transport features related to sending, but only a single transport
feature related to receiving: \"Receive data (with no message
delimiting)\" (and, strangely, \"information about partial message
arrival\"). Notably, the transport feature \"Receive a message\" is also
the only non-automatable transport feature of UDP(-Lite) for which no
implementation over TCP is possible.[¶](#section-5.1-1){.pilcrow}

To support these TCP receiver semantics, we define an
\"Application-Framed Byte Stream\" (AFra Byte Stream). AFra Byte Streams
allow senders to operate on messages while minimizing changes to the TCP
socket API. In particular, nothing changes on the receiver side; data
can be accepted via a normal TCP socket.[¶](#section-5.1-2){.pilcrow}

In an AFra Byte Stream, the sending application can optionally inform
the transport about message boundaries and required properties per
message (configurable order and reliability, or embedding a request not
to delay the acknowledgement of a message). Whenever the sending
application specifies per-message properties that relax the notion of
reliable in-order delivery of bytes, it must assume that the receiving
application is 1) able to determine message boundaries, provided that
messages are always kept intact, and 2) able to accept these relaxed
per-message properties. Any signaling of such information to the peer is
up to an application-layer protocol and considered out of scope of this
document.[¶](#section-5.1-3){.pilcrow}

For example, if an application requests to transfer fixed-size messages
of 100 bytes with partial reliability, this needs the receiving
application to be prepared to accept data in chunks of 100 bytes. Then,
if some of these 100-byte messages are missing (e.g., if SCTP with
Configurable Reliability is used), this is the expected application
behavior. With TCP, no messages would be missing, but this is also
correct for the application, and the possible retransmission delay is
acceptable within the best-effort service model (see [Section
3.5](https://www.rfc-editor.org/rfc/rfc7305#section-3.5){.relref} of
\[[RFC7305](#RFC7305){.xref}\]). Still, the receiving application would
separate the byte stream into 100-byte
chunks.[¶](#section-5.1-4){.pilcrow}

Note that this usage of messages does not require all messages to be
equal in size. Many application protocols use some form of
Type-Length-Value (TLV) encoding, e.g., by defining a header including
length fields; another alternative is the use of byte stuffing methods
such as Consistent Overhead Byte Stuffing (COBS)
\[[COBS](#COBS){.xref}\]. If an application needs message numbers, e.g.,
to restore the correct sequence of messages, these must also be encoded
by the application itself, as SCTP\'s transport features that are
related to the sequence number are not provided by the \"minimum set\"
(in the interest of enabling usage of TCP).[¶](#section-5.1-5){.pilcrow}
:::
:::

::: {#nostream}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Stream Schedulers without Streams](#name-stream-schedulers-without-s){.section-name .selfRef} {#name-stream-schedulers-without-s}

We have already stated that multi-streaming does not require
application-specific knowledge. Potential benefits or disadvantages of,
e.g., using two streams of an SCTP association versus using two separate
SCTP associations or TCP connections are related to knowledge about the
network and the particular transport protocol in use, not the
application. However, the transport features \"Choose a scheduler to
operate between streams of an association\" and \"Configure priority or
weight for a scheduler\" operate on streams. Here, streams identify
communication channels between which a scheduler operates, and they can
be assigned a priority. Moreover, the transport features in the
MAINTENANCE category all operate on associations in case of SCTP, i.e.,
they apply to all streams in that
association.[¶](#section-5.2-1){.pilcrow}

With only these semantics necessary to represent, the interface to a
transport system becomes easier if we assume that connections may be not
only a transport protocol\'s connection or association, but could also
be a stream of an existing SCTP association, for example. We only need
to allow for a way to define a possible grouping of connections. Then,
all MAINTENANCE transport features can be said to operate on connection
groups, not connections, and a scheduler operates on the connections
within a group.[¶](#section-5.2-2){.pilcrow}

To be compatible with multiple transport protocols and uniformly allow
access to both transport connections and streams of a multi-streaming
protocol, the semantics of opening and closing need to be the most
restrictive subset of all of the underlying options. For example, TCP\'s
support of half-closed connections can be seen as a feature on top of
the more restrictive \"ABORT\"; this feature cannot be supported because
not all protocols used by a transport system (including streams of an
association) support half-closed
connections.[¶](#section-5.2-3){.pilcrow}
:::
:::

::: {#earlydata}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Early Data Transmission](#name-early-data-transmission){.section-name .selfRef} {#name-early-data-transmission}

There are two transport features related to transferring a message
early: \"Hand over a message to reliably transfer (possibly multiple
times) before connection establishment\", which relates to TCP Fast Open
\[[RFC7413](#RFC7413){.xref}\], and \"Hand over a message to reliably
transfer during connection establishment\", which relates to SCTP\'s
ability to transfer data together with the COOKIE-Echo chunk. Also
without TCP Fast Open, TCP can transfer data during the handshake,
together with the SYN packet; however, the receiver of this data may not
hand it over to the application until the handshake has completed. Also,
different from TCP Fast Open, this data is not delimited as a message by
TCP (thus, not visible as a \"message\"). This functionality is commonly
available in TCP and supported in several implementations, even though
the TCP specification does not explain how to provide it to
applications.[¶](#section-5.3-1){.pilcrow}

A transport system could differentiate between the cases of transmitting
data \"before\" (possibly multiple times) or \"during\" the handshake.
Alternatively, it could also assume that data that are handed over early
will be transmitted as early as possible, and \"before\" the handshake
would only be used for messages that are explicitly marked as
\"idempotent\" (i.e., it would be acceptable to transfer them multiple
times).[¶](#section-5.3-2){.pilcrow}

The amount of data that can successfully be transmitted before or during
the handshake depends on various factors: the transport protocol, the
use of header options, the choice of IPv4 and IPv6, and the Path MTU. A
transport system should therefore allow a sending application to query
the maximum amount of data it can possibly transmit before (or, if
exposed, during) connection establishment.[¶](#section-5.3-3){.pilcrow}
:::
:::

::: {#rundry}
::: {#section-5.4 .section}
### [5.4.](#section-5.4){.section-number .selfRef} [Sender Running Dry](#name-sender-running-dry){.section-name .selfRef} {#name-sender-running-dry}

The transport feature \"Notification that the stack has no more user
data to send\" relates to SCTP\'s \"SENDER DRY\" notification. Such
notifications can, in principle, be used to avoid having an
unnecessarily large send buffer, yet ensure that the transport sender
always has data available when it has an opportunity to transmit it.
This has been found to be very beneficial for some applications
\[[WWDC2015](#WWDC2015){.xref}\]. However, \"SENDER DRY\" truly means
that the entire send buffer (including both unsent and unacknowledged
data) has emptied, i.e., when it notifies the sender, it is already too
late; the transport protocol already missed an opportunity to send data.
Some modern TCP implementations now include the unspecified
\"TCP_NOTSENT_LOWAT\" socket option that was proposed in
\[[WWDC2015](#WWDC2015){.xref}\], which limits the amount of unsent data
that TCP can keep in the socket buffer; this allows specifying at which
buffer filling level the socket becomes writable, rather than waiting
for the buffer to run empty.[¶](#section-5.4-1){.pilcrow}

SCTP allows configuring the sender-side buffer too; the automatable
Transport Feature \"Configure send buffer size\" provides this
functionality, but only for the complete buffer, which includes both
unsent and unacknowledged data. SCTP does not allow to control these two
sizes separately. It therefore makes sense for a transport system to
allow for uniform access to \"TCP_NOTSENT_LOWAT\" as well as the
\"SENDER DRY\" notification.[¶](#section-5.4-2){.pilcrow}
:::
:::

::: {#profile}
::: {#section-5.5 .section}
### [5.5.](#section-5.5){.section-number .selfRef} [Capacity Profile](#name-capacity-profile){.section-name .selfRef} {#name-capacity-profile}

The transport features:[¶](#section-5.5-1){.pilcrow}

-   [Disable Nagle
    algorithm[¶](#section-5.5-2.1){.pilcrow}]{#section-5.5-2.1}
-   [Enable and configure a \"Low Extra Delay Background
    Transfer\"[¶](#section-5.5-2.2){.pilcrow}]{#section-5.5-2.2}
-   [Specify DSCP
    field[¶](#section-5.5-2.3){.pilcrow}]{#section-5.5-2.3}

All relate to a QoS-like application need such as \"low latency\" or
\"scavenger\". In the interest of flexibility of a transport system,
they could therefore be offered in a uniform, more abstract way, where a
transport system could, e.g., decide by itself how to use combinations
of LEDBAT-like congestion control and certain DSCP values, and an
application would only specify a general \"capacity profile\" (a
description of how it wants to use the available capacity). A need for
\"lowest possible latency at the expense of overhead\" could then
translate into automatically disabling the Nagle
algorithm.[¶](#section-5.5-3){.pilcrow}

In some cases, the Nagle algorithm is best controlled directly by the
application because it is not only related to a general profile but also
to knowledge about the size of future messages. For fine-grain control
over Nagle-like functionality, the \"Request not to bundle messages\" is
available.[¶](#section-5.5-4){.pilcrow}
:::
:::

::: {#security}
::: {#section-5.6 .section}
### [5.6.](#section-5.6){.section-number .selfRef} [Security](#name-security){.section-name .selfRef} {#name-security}

Both TCP and SCTP offer authentication. TCP authenticates complete
segments. SCTP allows configuring which of SCTP\'s chunk types must
always be authenticated; if this is exposed as such, it creates an
undesirable dependency on the transport protocol. For compatibility with
TCP, a transport system should only allow to configure complete
transport layer packets, including headers, IP pseudo-header (if any)
and payload.[¶](#section-5.6-1){.pilcrow}

Security is discussed in a separate document
\[[RFC8922](#RFC8922){.xref}\]. The minimal set presented in the present
document excludes all security-related transport features from [Appendix
A](#super){.xref}: \"Configure authentication\", \"Change authentication
parameters\", \"Obtain authentication information\", and \"Set Cookie
life value\", as well as \"Specifying a key id to be used to
authenticate a message\". It also excludes security transport features
not listed in [Appendix A](#super){.xref}, including content privacy to
in-path devices.[¶](#section-5.6-2){.pilcrow}
:::
:::

::: {#packetsize}
::: {#section-5.7 .section}
### [5.7.](#section-5.7){.section-number .selfRef} [Packet Size](#name-packet-size){.section-name .selfRef} {#name-packet-size}

UDP(-Lite) has a transport feature called \"Specify DF field\". This
yields an error message in the case of sending a message that exceeds
the Path MTU, which is necessary for a UDP-based application to be able
to implement Path MTU Discovery (a function that UDP-based applications
must do by themselves). The \"Get max. transport-message size that may
be sent using a non-fragmented IP packet from the configured interface\"
transport feature yields an upper limit for the Path MTU (minus headers)
and can therefore help to implement Path MTU Discovery more
efficiently.[¶](#section-5.7-1){.pilcrow}
:::
:::
:::
:::

::: {#minset}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [The Minimal Set of Transport Features](#name-the-minimal-set-of-transpor){.section-name .selfRef} {#name-the-minimal-set-of-transpor}

Based on the categorization, reduction, and discussion in [Section
3](#deriving){.xref}, this section describes a minimal set of transport
features that end systems should offer. Any configuration based on the
described minimum set of transport feature can always be realized over
TCP but also gives the transport system flexibility to choose another
transport if implemented. In the text of this section, \"not UDP\" is
used to indicate elements of the system that cannot be implemented over
UDP. Conversely, all elements of the system that are not marked with
\"not UDP\" can also be implemented over UDP.[¶](#section-6-1){.pilcrow}

The arguments laid out in [Section 5](#Discussion){.xref}
(\"discussion\") were used to make the final representation of the
minimal set as short, simple, and general as possible. There may be
situations where these arguments do not apply, e.g., implementers may
have specific reasons to expose multi-streaming as a visible
functionality to applications, or the restrictive open/close semantics
may be problematic under some circumstances. In such cases, the
representation in [Section 4](#Reduction){.xref} (\"reduction\") should
be considered.[¶](#section-6-2){.pilcrow}

As in [Section 3](#deriving){.xref}, [Section 4](#Reduction){.xref}, and
\[[RFC8303](#RFC8303){.xref}\], we categorize the minimal set of
transport features as 1) CONNECTION related (ESTABLISHMENT,
AVAILABILITY, MAINTENANCE, TERMINATION) and 2) DATA Transfer related
(Sending Data, Receiving Data, Errors). Here, the focus is on
connections that the transport system offers as an abstraction to the
application, as opposed to connections of transport protocols that the
transport system uses.[¶](#section-6-3){.pilcrow}

::: {#minset-init}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [ESTABLISHMENT, AVAILABILITY, and TERMINATION](#name-establishment-availability-){.section-name .selfRef} {#name-establishment-availability-}

A connection must first be \"created\" to allow for some initial
configuration to be carried out before the transport system can actively
or passively establish communication with a remote end system. As a
configuration of the newly created connection, an application can choose
to disallow usage of MPTCP. Furthermore, all configuration parameters in
[Section 6.2](#minset-groupconfig){.xref} can be used initially,
although some of them may only take effect when a connection has been
established with a chosen transport protocol. Configuring a connection
early helps a transport system make the right decisions. For example,
grouping information can influence whether or not the transport system
implements a connection as a stream of a multi-streaming protocol\'s
existing association.[¶](#section-6.1-1){.pilcrow}

For ungrouped connections, early configuration is necessary because it
allows the transport system to know which protocols it should try to
use. In particular, a transport system that only makes a one-time choice
for a particular protocol must know early about strict requirements that
must be kept, or it can end up in a deadlock situation (e.g., having
chosen UDP and later be asked to support reliable transfer). As an
example description of how to correctly handle these cases, we provide
the following decision tree (this is derived from [Section
4.1](#conn-reduced){.xref} excluding authentication, as explained in
[Section 8](#Security){.xref}):[¶](#section-6.1-2){.pilcrow}

::: {#section-6.1-3 .artwork .art-text .alignLeft}
          +----------------------------------------------------------+
          | Will it ever be necessary to offer any of the following? |
          | * Reliably transfer data                                 |
          | * Notify the peer of closing/aborting                    |
          | * Preserve data ordering                                 |
          +----------------------------------------------------------+
                    |                                    |
                    |Yes                                 |No
                    | (SCTP or TCP)                      | (All protocols
                    |  can be used.)                     |  can be used.)
                    V                                    V
    +--------------------------------------+ +-----------------------------+
    | Is any of the following useful to    | | Is any of the following     |
    | the application?                     | | useful to the application?  |
    | * Choosing a scheduler to operate    | | * Specify checksum coverage |
    |   between connections in a group,    | |   used by the sender        |
    |   with the possibility to configure  | | * Specify minimum checksum  |
    |   a priority or weight per connection| |   coverage required by the  |
    | * Configurable message reliability   | |   receiver                  |
    | * Unordered message delivery         | +-----------------------------+
    | * Request not to delay the           |         |             |
    |   acknowledgement (SACK) of a message|         |Yes          |No
    +--------------------------------------+         |             |
              |                |                     |             |
              |Yes             |No                   |             |
              V                |                     V             V
            SCTP is            |                UDP-Lite is    UDP is
            preferred.         |                preferred.     preferred.
                               V
    +------------------------------------------------------+
    | Is any of the following useful to the application?   |
    | * Hand over a message to reliably transfer (possibly |
    |   multiple times) before connection establishment    |
    | * Suggest timeout to the peer                        |
    | * Notification of Excessive Retransmissions (early   |
    |   warning below abortion threshold)                  |
    | * Notification of ICMP error message arrival         |
    +------------------------------------------------------+
              |                            |
              |Yes                         |No
              V                            V
        TCP is preferred.             SCTP and TCP
                                      are equally preferable.

[¶](#section-6.1-3){.pilcrow}
:::

Note that this decision tree is not optimal for all cases. For example,
if an application wants to use \"Specify checksum coverage used by the
sender\", which is only offered by UDP-Lite, and \"Configure priority or
weight for a scheduler\", which is only offered by SCTP, the above
decision tree will always choose UDP-Lite, making it impossible to use
SCTP\'s schedulers with priorities between grouped connections. Also,
several other factors may influence the decisions for or against a
protocol, e.g., penetration rates, the ability to work through NATs,
etc. We caution implementers to be aware of the full set of trade-offs,
for which we recommend consulting the list in [Section
4.1](#conn-reduced){.xref} when deciding how to initialize a
connection.[¶](#section-6.1-4){.pilcrow}

To summarize, the following parameters serve as input for the transport
system to help it choose and configure a suitable
protocol:[¶](#section-6.1-5){.pilcrow}

[]{.break}

Reliability:
:   a boolean that should be set to true when any of the following will
    be useful to the application: reliably transfer data; notify the
    peer of closing/aborting; or preserve data
    ordering.[¶](#section-6.1-6.2){.pilcrow}
:   

Checksum coverage:
:   a boolean to specify whether it will be useful to the application to
    specify checksum coverage when sending or
    receiving.[¶](#section-6.1-6.4){.pilcrow}
:   

Configure message priority:
:   a boolean that should be set to true when any of the following
    per-message configuration or prioritization mechanisms will be
    useful to the application: choosing a scheduler to operate between
    grouped connections, with the possibility to configure a priority or
    weight per connection; configurable message reliability; unordered
    message delivery; or requesting not to delay the acknowledgement
    (SACK) of a message.[¶](#section-6.1-6.6){.pilcrow}
:   

Early message timeout notifications:
:   a boolean that should be set to true when any of the following will
    be useful to the application: hand over a message to reliably
    transfer (possibly multiple times) before connection establishment;
    suggest timeout to the peer; notification of excessive
    retransmissions (early warning below abortion threshold); or
    notification of ICMP error message
    arrival.[¶](#section-6.1-6.8){.pilcrow}
:   

Once a connection is created, it can be queried for the maximum amount
of data that an application can possibly expect to have reliably
transmitted before or during transport connection establishment (with
zero being a possible answer) (see [Section
6.2.1](#minset-maintenance-grouped){.xref}). An application can also
give the connection a message for reliable transmission before or during
connection establishment (not UDP); the transport system will then try
to transmit it as early as possible. An application can facilitate
sending a message particularly early by marking it as \"idempotent\"
(see [Section 6.3.1](#minset-datatrans-sending){.xref}); in this case,
the receiving application must be prepared to potentially receive
multiple copies of the message (because idempotent messages are reliably
transferred, asking for idempotence is not necessary for systems that
support UDP).[¶](#section-6.1-7){.pilcrow}

After creation, a transport system can actively establish communication
with a peer, or it can passively listen for incoming connection
requests. Note that active establishment may or may not trigger a
notification on the listening side. It is possible that the first
notification on the listening side is the arrival of the first data that
the active side sends (a receiver-side transport system could handle
this by continuing to block a \"Listen\" call, immediately followed, for
example, by issuing \"Receive\"; callback-based implementations could
simply skip the equivalent of \"Listen\"). This also means that the
active opening side is assumed to be the first side sending
data.[¶](#section-6.1-8){.pilcrow}

A transport system can actively close a connection, i.e., terminate it
after reliably delivering all remaining data to the peer (if reliable
data delivery was requested earlier (not UDP)), in which case the peer
is notified that the connection is closed. Alternatively, a connection
can be aborted without delivering outstanding data to the peer. In case
reliable or partially reliable data delivery was requested earlier (not
UDP), the peer is notified that the connection is aborted. A timeout can
be configured to abort a connection when data could not be delivered for
too long (not UDP); however, timeout-based abortion does not notify the
peer application that the connection has been aborted. Because
half-closed connections are not supported, when a host implementing a
transport system receives a notification that the peer is closing or
aborting the connection (not UDP), its peer may not be able to read
outstanding data. This means that unacknowledged data residing in a
transport system\'s send buffer may have to be dropped from that buffer
upon arrival of a \"close\" or \"abort\" notification from the
peer.[¶](#section-6.1-9){.pilcrow}
:::
:::

::: {#minset-groupconfig}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [MAINTENANCE](#name-maintenance){.section-name .selfRef} {#name-maintenance}

A transport system must offer means to group connections, but it cannot
guarantee truly grouping them using the transport protocols that it uses
(e.g., it cannot be guaranteed that connections become multiplexed as
streams on a single SCTP association when SCTP may not be available).
The transport system must therefore ensure that group- versus
non-group-configurations are handled correctly in some way (e.g., by
applying the configuration to all grouped connections even when they are
not multiplexed, or informing the application about grouping success or
failure).[¶](#section-6.2-1){.pilcrow}

As a general rule, any configuration described below should be carried
out as early as possible to aid the transport system\'s decision
making.[¶](#section-6.2-2){.pilcrow}

::: {#minset-maintenance-grouped}
::: {#section-6.2.1 .section}
#### [6.2.1.](#section-6.2.1){.section-number .selfRef} [Connection Groups](#name-connection-groups){.section-name .selfRef} {#name-connection-groups}

The following transport features and notifications (some directly from
[Section 4](#Reduction){.xref}; some new or changed, based on the
discussion in [Section 5](#Discussion){.xref}) automatically apply to
all grouped connections:[¶](#section-6.2.1-1){.pilcrow}

Configure a timeout (not UDP)\
This can be done with the following
parameters:[¶](#section-6.2.1-2){.pilcrow}

-   [A timeout value for aborting connections, in
    seconds.[¶](#section-6.2.1-3.1){.pilcrow}]{#section-6.2.1-3.1}
-   [A timeout value to be suggested to the peer (if possible), in
    seconds.[¶](#section-6.2.1-3.2){.pilcrow}]{#section-6.2.1-3.2}
-   [The number of retransmissions after which the application should be
    notified of \"Excessive
    Retransmissions\".[¶](#section-6.2.1-3.3){.pilcrow}]{#section-6.2.1-3.3}

Configure urgency\
This can be done with the following
parameters:[¶](#section-6.2.1-4){.pilcrow}

-   [A number to identify the type of scheduler that should be used to
    operate between connections in the group (no guarantees given).
    Schedulers are defined in
    \[[RFC8260](#RFC8260){.xref}\].[¶](#section-6.2.1-5.1){.pilcrow}]{#section-6.2.1-5.1}
-   [A \"capacity profile\" number to identify how an application wants
    to use its available capacity. Choices can be \"lowest possible
    latency at the expense of overhead\" (which would disable any
    Nagle-like algorithm), \"scavenger\", or values that help determine
    the DSCP value for a
    connection.[¶](#section-6.2.1-5.2){.pilcrow}]{#section-6.2.1-5.2}
-   [A buffer limit (in bytes); when the sender has less than the
    provided limit of bytes in the buffer, the application may be
    notified. Notifications are not guaranteed, and it is optional for a
    transport system to support buffer limit values greater than 0. Note
    that this limit and its notification should operate across the
    buffers of the whole transport system, i.e., also any potential
    buffers that the transport system itself may use on top of the
    transport\'s send
    buffer.[¶](#section-6.2.1-5.3){.pilcrow}]{#section-6.2.1-5.3}

Following [Section 5.7](#packetsize){.xref}, these properties can be
queried:[¶](#section-6.2.1-6){.pilcrow}

-   [The maximum message size that may be sent without fragmentation via
    the configured interface. This is optional for a transport system to
    offer and may return an error (\"not available\"). It can aid
    applications implementing Path MTU
    Discovery.[¶](#section-6.2.1-7.1){.pilcrow}]{#section-6.2.1-7.1}
-   [The maximum transport message size that can be sent, in bytes.
    Irrespective of fragmentation, there is a size limit for the
    messages that can be handed over to SCTP or UDP(-Lite); because the
    service provided by a transport system is independent of the
    transport protocol, it must allow an application to query this
    value: the maximum size of a message in an Application-Framed Byte
    Stream (see [Section 5.1](#sendmsg){.xref}). This may also return an
    error when data is not delimited (\"not
    available\").[¶](#section-6.2.1-7.2){.pilcrow}]{#section-6.2.1-7.2}
-   [The maximum transport message size that can be received from the
    configured interface, in bytes (or \"not
    available\").[¶](#section-6.2.1-7.3){.pilcrow}]{#section-6.2.1-7.3}
-   [The maximum amount of data that can possibly be sent before or
    during connection establishment, in
    bytes.[¶](#section-6.2.1-7.4){.pilcrow}]{#section-6.2.1-7.4}

In addition to the already mentioned closing/aborting notifications and
possible send errors, the following notifications can
occur:[¶](#section-6.2.1-8){.pilcrow}

[]{.break}

Excessive Retransmissions:
:   The configured (or a default) number of retransmissions has been
    reached, yielding this early warning below an abortion
    threshold.[¶](#section-6.2.1-9.2){.pilcrow}
:   

ICMP Arrival (parameter: ICMP message):
:   An ICMP packet carrying the conveyed ICMP message has
    arrived.[¶](#section-6.2.1-9.4){.pilcrow}
:   

ECN Arrival (parameter: ECN value):
:   A packet carrying the conveyed Explicit Congestion Notification
    (ECN) value has arrived. This can be useful for applications
    implementing congestion control.[¶](#section-6.2.1-9.6){.pilcrow}
:   

Timeout (parameter: s seconds):
:   Data could not be delivered for s
    seconds.[¶](#section-6.2.1-9.8){.pilcrow}
:   

Drain:
:   The send buffer has either drained below the configured buffer limit
    or it has become completely empty. This is a generic notification
    that tries to enable uniform access to \"TCP_NOTSENT_LOWAT\" as well
    as the \"SENDER DRY\" notification (as discussed in [Section
    5.4](#rundry){.xref}; SCTP\'s \"SENDER DRY\" is a special case where
    the threshold (for unsent data) is 0 and there is also no more
    unacknowledged data in the send
    buffer).[¶](#section-6.2.1-9.10){.pilcrow}
:   
:::
:::

::: {#minset-maintenance-individual}
::: {#section-6.2.2 .section}
#### [6.2.2.](#section-6.2.2){.section-number .selfRef} [Individual Connections](#name-individual-connections){.section-name .selfRef} {#name-individual-connections}

Configure priority or weight for a scheduler, as described in
\[[RFC8260](#RFC8260){.xref}\].[¶](#section-6.2.2-1){.pilcrow}

Configure checksum usage: This can be done with the following
parameters, but there is no guarantee that any checksum limitations will
indeed be enforced (the default behavior is \"full coverage, checksum
enabled\"):[¶](#section-6.2.2-2){.pilcrow}

-   [a boolean to enable/disable usage of a checksum when
    sending[¶](#section-6.2.2-3.1){.pilcrow}]{#section-6.2.2-3.1}
-   [the desired coverage (in bytes) of the checksum used when
    sending[¶](#section-6.2.2-3.2){.pilcrow}]{#section-6.2.2-3.2}
-   [a boolean to enable/disable requiring a checksum when
    receiving[¶](#section-6.2.2-3.3){.pilcrow}]{#section-6.2.2-3.3}
-   [the required minimum coverage (in bytes) of the checksum when
    receiving[¶](#section-6.2.2-3.4){.pilcrow}]{#section-6.2.2-3.4}
:::
:::
:::
:::

::: {#minset-datatrans}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [DATA Transfer](#name-data-transfer){.section-name .selfRef} {#name-data-transfer}

::: {#minset-datatrans-sending}
::: {#section-6.3.1 .section}
#### [6.3.1.](#section-6.3.1){.section-number .selfRef} [Sending Data](#name-sending-data-2){.section-name .selfRef} {#name-sending-data-2}

When sending a message, no guarantees are given about the preservation
of message boundaries to the peer; if message boundaries are needed, the
receiving application at the peer must know about them beforehand (or
the transport system cannot use TCP). Note that an application should
already be able to hand over data before the transport system
establishes a connection with a chosen transport protocol. Regarding the
message that is being handed over, the following parameters can be
used:[¶](#section-6.3.1-1){.pilcrow}

[]{.break}

Reliability:
:   This parameter is used to convey a choice of: fully reliable with
    congestion control (not UDP), unreliable without congestion control,
    unreliable with congestion control (not UDP), and partially reliable
    with congestion control (see \[[RFC3758](#RFC3758){.xref}\] and
    \[[RFC7496](#RFC7496){.xref}\] for details on how to specify partial
    reliability) (not UDP). The latter two choices are optional for a
    transport system to offer and may result in full reliability. Note
    that applications sending unreliable data without congestion control
    should themselves perform congestion control in accordance with
    \[[RFC8085](#RFC8085){.xref}\].[¶](#section-6.3.1-2.2){.pilcrow}
:   

Ordered (not UDP):
:   This boolean lets an application choose between ordered message
    delivery (true) and possibly unordered, potentially faster message
    delivery (false).[¶](#section-6.3.1-2.4){.pilcrow}
:   

Bundle:
:   This boolean expresses a preference for allowing to bundle messages
    (true) or not (false). No guarantees are
    given.[¶](#section-6.3.1-2.6){.pilcrow}
:   

DelAck:
:   This boolean, if false, lets an application request that the peer
    not delay the acknowledgement for this
    message.[¶](#section-6.3.1-2.8){.pilcrow}
:   

Fragment:
:   This boolean expresses a preference for allowing to fragment
    messages (true) or not (false), at the IP level. No guarantees are
    given.[¶](#section-6.3.1-2.10){.pilcrow}
:   

Idempotent (not UDP):
:   This boolean expresses whether a message is idempotent (true) or not
    (false). Idempotent messages may arrive multiple times at the
    receiver (but they will arrive at least once). When data is
    idempotent, it can be used by the receiver immediately on a
    connection establishment attempt. Thus, if data is handed over
    before the transport system establishes a connection with a chosen
    transport protocol, stating that a message is idempotent facilitates
    transmitting it to the peer application particularly
    early.[¶](#section-6.3.1-2.12){.pilcrow}
:   

An application can be notified of a failure to send a specific message.
There is no guarantee of such notifications, i.e., send failures can
also silently occur.[¶](#section-6.3.1-3){.pilcrow}
:::
:::

::: {#minset-datatrans-receiving}
::: {#section-6.3.2 .section}
#### [6.3.2.](#section-6.3.2){.section-number .selfRef} [Receiving Data](#name-receiving-data-2){.section-name .selfRef} {#name-receiving-data-2}

A receiving application obtains an \"Application-Framed Byte Stream\"
(AFra Byte Stream); this concept is further described in [Section
5.1](#sendmsg){.xref}. In line with TCP\'s receiver semantics, an AFra
Byte Stream is just a stream of bytes to the receiver. If message
boundaries were specified by the sender, a receiver-side transport
system implementing only the minimum set of Transport Services defined
here will still not inform the receiving application about them (this
limitation is only needed for transport systems that are implemented to
directly use TCP).[¶](#section-6.3.2-1){.pilcrow}

Different from TCP\'s semantics, if the sending application has allowed
that messages are not fully reliably transferred, or delivered out of
order, then such reordering or unreliability may be reflected per
message in the arriving data. Messages will always stay intact, i.e., if
an incomplete message is contained at the end of the arriving data
block, this message is guaranteed to continue in the next arriving data
block.[¶](#section-6.3.2-2){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#IANA}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-7-1){.pilcrow}
:::
:::

::: {#Security}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

Authentication, confidentiality protection, and integrity protection are
identified as transport features by \[[RFC8095](#RFC8095){.xref}\].
Often, these features are provided by a protocol or layer on top of the
transport protocol; none of the full-featured standards-track transport
protocols in \[[RFC8303](#RFC8303){.xref}\], which this document is
based upon, provide all of these transport features on its own.
Therefore, they are not considered in this document, with the exception
of native authentication capabilities of TCP and SCTP for which the
security considerations in \[[RFC5925](#RFC5925){.xref}\] and
\[[RFC4895](#RFC4895){.xref}\] apply. The minimum requirements for a
secure transport system are discussed in a separate document
\[[RFC8922](#RFC8922){.xref}\].[¶](#section-8-1){.pilcrow}
:::
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC8095\]
:   [Fairhurst, G., Ed.]{.refAuthor}[, Trammell, B., Ed.]{.refAuthor}[,
    and M. Kuehlewind, Ed.]{.refAuthor}, [\"Services Provided by IETF
    Transport Protocols and Congestion Control Mechanisms\"]{.refTitle},
    [RFC 8095]{.seriesInfo}, [DOI 10.17487/RFC8095]{.seriesInfo}, March
    2017, \<<https://www.rfc-editor.org/info/rfc8095>\>.
:   

\[RFC8303\]
:   [Welzl, M.]{.refAuthor}[, Tuexen, M.]{.refAuthor}[, and N.
    Khademi]{.refAuthor}, [\"On the Usage of Transport Features Provided
    by IETF Transport Protocols\"]{.refTitle}, [RFC 8303]{.seriesInfo},
    [DOI 10.17487/RFC8303]{.seriesInfo}, February 2018,
    \<<https://www.rfc-editor.org/info/rfc8303>\>.
:   

\[RFC8922\]
:   [Enghardt, T.]{.refAuthor}[, Pauly, T.]{.refAuthor}[,
    Perkins, C.]{.refAuthor}[, Rose, K.]{.refAuthor}[, and C.
    Wood]{.refAuthor}, [\"A Survey of the Interaction between Security
    Protocols and Transport Services\"]{.refTitle}, [RFC
    8922]{.seriesInfo}, [DOI 10.17487/RFC8922]{.seriesInfo}, October
    2020, \<<https://www.rfc-editor.org/info/rfc8922>\>.
:   
:::

::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[COBS\]
:   [Cheshire, S.]{.refAuthor}[ and M. Baker]{.refAuthor}, [\"Consistent
    overhead byte stuffing\"]{.refTitle}, [IEEE/ACM Transactions on
    Networking, Volume 7, Issue 2 ]{.refContent}, [DOI
    10.1109/90.769765]{.seriesInfo}, April 1999,
    \<<https://doi.org/10.1109/90.769765>\>.
:   

\[POSIX\]
:   [The Open Group]{.refAuthor}, [\"IEEE Standard for Information
    Technology\--Portable Operating System Interface (POSIX(R)) Base
    Specifications, Issue 7\"]{.refTitle}, [(Revision of IEEE Std
    1003.1-2008)]{.refContent}, [IEEE Std 1003.1-2017]{.seriesInfo},
    January 2018,
    \<<https://www.opengroup.org/onlinepubs/9699919799/functions/contents.html>\>.
:   

\[RFC3758\]
:   [Stewart, R.]{.refAuthor}[, Ramalho, M.]{.refAuthor}[,
    Xie, Q.]{.refAuthor}[, Tuexen, M.]{.refAuthor}[, and P.
    Conrad]{.refAuthor}, [\"Stream Control Transmission Protocol (SCTP)
    Partial Reliability Extension\"]{.refTitle}, [RFC
    3758]{.seriesInfo}, [DOI 10.17487/RFC3758]{.seriesInfo}, May 2004,
    \<<https://www.rfc-editor.org/info/rfc3758>\>.
:   

\[RFC4895\]
:   [Tuexen, M.]{.refAuthor}[, Stewart, R.]{.refAuthor}[,
    Lei, P.]{.refAuthor}[, and E. Rescorla]{.refAuthor},
    [\"Authenticated Chunks for the Stream Control Transmission Protocol
    (SCTP)\"]{.refTitle}, [RFC 4895]{.seriesInfo}, [DOI
    10.17487/RFC4895]{.seriesInfo}, August 2007,
    \<<https://www.rfc-editor.org/info/rfc4895>\>.
:   

\[RFC4987\]
:   [Eddy, W.]{.refAuthor}, [\"TCP SYN Flooding Attacks and Common
    Mitigations\"]{.refTitle}, [RFC 4987]{.seriesInfo}, [DOI
    10.17487/RFC4987]{.seriesInfo}, August 2007,
    \<<https://www.rfc-editor.org/info/rfc4987>\>.
:   

\[RFC5925\]
:   [Touch, J.]{.refAuthor}[, Mankin, A.]{.refAuthor}[, and R.
    Bonica]{.refAuthor}, [\"The TCP Authentication Option\"]{.refTitle},
    [RFC 5925]{.seriesInfo}, [DOI 10.17487/RFC5925]{.seriesInfo}, June
    2010, \<<https://www.rfc-editor.org/info/rfc5925>\>.
:   

\[RFC6897\]
:   [Scharf, M.]{.refAuthor}[ and A. Ford]{.refAuthor}, [\"Multipath TCP
    (MPTCP) Application Interface Considerations\"]{.refTitle}, [RFC
    6897]{.seriesInfo}, [DOI 10.17487/RFC6897]{.seriesInfo}, March 2013,
    \<<https://www.rfc-editor.org/info/rfc6897>\>.
:   

\[RFC7305\]
:   [Lear, E., Ed.]{.refAuthor}, [\"Report from the IAB Workshop on
    Internet Technology Adoption and Transition (ITAT)\"]{.refTitle},
    [RFC 7305]{.seriesInfo}, [DOI 10.17487/RFC7305]{.seriesInfo}, July
    2014, \<<https://www.rfc-editor.org/info/rfc7305>\>.
:   

\[RFC7413\]
:   [Cheng, Y.]{.refAuthor}[, Chu, J.]{.refAuthor}[,
    Radhakrishnan, S.]{.refAuthor}[, and A. Jain]{.refAuthor}, [\"TCP
    Fast Open\"]{.refTitle}, [RFC 7413]{.seriesInfo}, [DOI
    10.17487/RFC7413]{.seriesInfo}, December 2014,
    \<<https://www.rfc-editor.org/info/rfc7413>\>.
:   

\[RFC7496\]
:   [Tuexen, M.]{.refAuthor}[, Seggelmann, R.]{.refAuthor}[,
    Stewart, R.]{.refAuthor}[, and S. Loreto]{.refAuthor}, [\"Additional
    Policies for the Partially Reliable Stream Control Transmission
    Protocol Extension\"]{.refTitle}, [RFC 7496]{.seriesInfo}, [DOI
    10.17487/RFC7496]{.seriesInfo}, April 2015,
    \<<https://www.rfc-editor.org/info/rfc7496>\>.
:   

\[RFC8085\]
:   [Eggert, L.]{.refAuthor}[, Fairhurst, G.]{.refAuthor}[, and G.
    Shepherd]{.refAuthor}, [\"UDP Usage Guidelines\"]{.refTitle}, [BCP
    145]{.seriesInfo}, [RFC 8085]{.seriesInfo}, [DOI
    10.17487/RFC8085]{.seriesInfo}, March 2017,
    \<<https://www.rfc-editor.org/info/rfc8085>\>.
:   

\[RFC8260\]
:   [Stewart, R.]{.refAuthor}[, Tuexen, M.]{.refAuthor}[,
    Loreto, S.]{.refAuthor}[, and R. Seggelmann]{.refAuthor}, [\"Stream
    Schedulers and User Message Interleaving for the Stream Control
    Transmission Protocol\"]{.refTitle}, [RFC 8260]{.seriesInfo}, [DOI
    10.17487/RFC8260]{.seriesInfo}, November 2017,
    \<<https://www.rfc-editor.org/info/rfc8260>\>.
:   

\[RFC8304\]
:   [Fairhurst, G.]{.refAuthor}[ and T. Jones]{.refAuthor}, [\"Transport
    Features of the User Datagram Protocol (UDP) and Lightweight UDP
    (UDP-Lite)\"]{.refTitle}, [RFC 8304]{.seriesInfo}, [DOI
    10.17487/RFC8304]{.seriesInfo}, February 2018,
    \<<https://www.rfc-editor.org/info/rfc8304>\>.
:   

\[RFC8622\]
:   [Bless, R.]{.refAuthor}, [\"A Lower-Effort Per-Hop Behavior (LE PHB)
    for Differentiated Services\"]{.refTitle}, [RFC 8622]{.seriesInfo},
    [DOI 10.17487/RFC8622]{.seriesInfo}, June 2019,
    \<<https://www.rfc-editor.org/info/rfc8622>\>.
:   

\[SCTP-STREAM-1\]
:   [Weinrank, F.]{.refAuthor}[ and M. Tuexen]{.refAuthor},
    [\"Transparent Flow Mapping for NEAT\"]{.refTitle}, [IFIP Networking
    2017]{.refContent}, [Workshop on Future of Internet Transport
    (FIT 2017)]{.refContent}, June 2017.
:   

\[SCTP-STREAM-2\]
:   [Welzl, M.]{.refAuthor}[, Niederbacher, F.]{.refAuthor}[, and S.
    Gjessing]{.refAuthor}, [\"Beneficial Transparent Deployment of SCTP:
    The Missing Pieces\"]{.refTitle}, [IEEE GlobeCom 2011]{.refContent},
    [DOI 10.1109/GLOCOM.2011.6133554]{.seriesInfo}, December 2011,
    \<<https://doi.org/10.1109/GLOCOM.2011.6133554>\>.
:   

\[TAPS-INTERFACE\]
:   [Trammell, B.]{.refAuthor}[, Welzl, M.]{.refAuthor}[,
    Enghardt, T.]{.refAuthor}[, Fairhurst, G.]{.refAuthor}[,
    Kuehlewind, M.]{.refAuthor}[, Perkins, C.]{.refAuthor}[, Tiesel, P.
    S.]{.refAuthor}[, Wood, C. A.]{.refAuthor}[, and T.
    Pauly]{.refAuthor}, [\"An Abstract Application Layer Interface to
    Transport Services\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-taps-interface-09]{.seriesInfo}, 27 July
    2020,
    \<<https://tools.ietf.org/html/draft-ietf-taps-interface-09>\>.
:   

\[WWDC2015\]
:   [Lakhera, P.]{.refAuthor}[ and S. Cheshire]{.refAuthor}, [\"Your App
    and Next Generation Networks\"]{.refTitle}, [Apple Worldwide
    Developers Conference 2015]{.refContent}, [San Francisco,
    USA]{.refContent}, June 2015,
    \<<https://developer.apple.com/videos/wwdc/2015/?id=719>\>.
:   
:::
:::

::: {#super}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [The Superset of Transport Features](#name-the-superset-of-transport-f){.section-name .selfRef} {#name-the-superset-of-transport-f}

In this description, transport features are presented following the
nomenclature \"CATEGORY.\[SUBCATEGORY\].FEATURENAME.PROTOCOL\",
equivalent to \"pass 2\" in \[[RFC8303](#RFC8303){.xref}\]. We also
sketch how functional or optimizing transport features can be
implemented by a transport system. The \"minimal set\" derived in this
document is meant to be implementable \"one-sided\" over TCP and, with
limitations, UDP. Hence, for all transport features that are categorized
as \"functional\" or \"optimizing\", and for which no matching TCP
and/or UDP primitive exists in \"pass 2\" of
\[[RFC8303](#RFC8303){.xref}\], a brief discussion on how to implement
them over TCP and/or UDP is
included.[¶](#section-appendix.a-1){.pilcrow}

We designate some transport features as \"automatable\" on the basis of
a broader decision that affects multiple transport
features:[¶](#section-appendix.a-2){.pilcrow}

-   [Most transport features that are related to multi-streaming were
    designated as \"automatable\". This was done because the decision on
    whether or not to use multi-streaming does not depend on
    application-specific knowledge. This means that a connection that is
    exhibited to an application could be implemented by using a single
    stream of an SCTP association instead of mapping it to a complete
    SCTP association or TCP connection. This could be achieved by using
    more than one stream when an SCTP association is first established
    (CONNECT.SCTP parameter \"outbound stream count\"), maintaining an
    internal stream number, and using this stream number when sending
    data (SEND.SCTP parameter \"stream number\"). Closing or aborting a
    connection could then simply free the stream number for future use.
    This is discussed further in [Section
    5.2](#nostream){.xref}.[¶](#section-appendix.a-3.1){.pilcrow}]{#section-appendix.a-3.1}
-   [With the exception of \"Disable MPTCP\", all transport features
    that are related to using multiple paths or the choice of the
    network interface were designated as \"automatable\". For example,
    \"Listen\" could always listen on all available interfaces and
    \"Connect\" could use the default interface for the destination IP
    address.[¶](#section-appendix.a-3.2){.pilcrow}]{#section-appendix.a-3.2}

Finally, in three cases, transport features are aggregated and/or
slightly changed from \[[RFC8303](#RFC8303){.xref}\] in the description
below. These transport features are marked as \"CHANGED FROM RFC 8303\".
These do not add any new functionality but just represent a simple
refactoring step that helps to streamline the derivation process (e.g.,
by removing a choice of a parameter for the sake of applications that
may not care about this choice). The corresponding transport features
are automatable, and they are listed immediately below the \"CHANGED
FROM RFC 8303\" transport feature.[¶](#section-appendix.a-4){.pilcrow}

::: {#conn-super}
::: {#section-a.1 .section}
## [A.1.](#section-a.1){.section-number .selfRef} [CONNECTION-Related Transport Features](#name-connection-related-transport){.section-name .selfRef} {#name-connection-related-transport}

ESTABLISHMENT:[¶](#section-a.1-1){.pilcrow}

-   ::: {#section-a.1-2.1}
    Connect[¶](#section-a.1-2.1.1){.pilcrow}

    Protocols: TCP, SCTP, UDP(-Lite)[¶](#section-a.1-2.1.2){.pilcrow}

    Functional because the notion of a connection is often reflected in
    applications as an expectation to be able to communicate after a
    \"Connect\" succeeded, with a communication sequence relating to
    this transport feature that is defined by the application
    protocol.[¶](#section-a.1-2.1.3){.pilcrow}

    Implementation: via CONNECT.TCP, CONNECT.SCTP or
    CONNECT.UDP(-Lite).[¶](#section-a.1-2.1.4){.pilcrow}
    :::

-   ::: {#section-a.1-2.2}
    Specify which IP Options must always be
    used[¶](#section-a.1-2.2.1){.pilcrow}

    Protocols: TCP, UDP(-Lite)[¶](#section-a.1-2.2.2){.pilcrow}

    Automatable because IP Options relate to knowledge about the
    network, not the application.[¶](#section-a.1-2.2.3){.pilcrow}
    :::

-   ::: {#section-a.1-2.3}
    Request multiple streams[¶](#section-a.1-2.3.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-2.3.2){.pilcrow}

    Automatable because using multi-streaming does not require
    application-specific knowledge (example implementations of using
    multi-streaming without involving the application are described in
    \[[SCTP-STREAM-1](#SCTP-STREAM-1){.xref}\] and
    \[[SCTP-STREAM-2](#SCTP-STREAM-2){.xref}\]).[¶](#section-a.1-2.3.3){.pilcrow}

    Implementation: see [Section
    5.2](#nostream){.xref}.[¶](#section-a.1-2.3.4){.pilcrow}
    :::

-   ::: {#section-a.1-2.4}
    Limit the number of inbound streams[¶](#section-a.1-2.4.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-2.4.2){.pilcrow}

    Automatable because using multi-streaming does not require
    application-specific knowledge.[¶](#section-a.1-2.4.3){.pilcrow}

    Implementation: see [Section
    5.2](#nostream){.xref}.[¶](#section-a.1-2.4.4){.pilcrow}
    :::

-   ::: {#section-a.1-2.5}
    Specify number of attempts and/or timeout for the first
    establishment message[¶](#section-a.1-2.5.1){.pilcrow}

    Protocols: TCP, SCTP[¶](#section-a.1-2.5.2){.pilcrow}

    Functional because this is closely related to potentially assumed
    reliable data delivery for data that is sent before or during
    connection establishment.[¶](#section-a.1-2.5.3){.pilcrow}

    Implementation: using a parameter of CONNECT.TCP and
    CONNECT.SCTP.[¶](#section-a.1-2.5.4){.pilcrow}

    Implementation over UDP: do nothing (this is irrelevant in the case
    of UDP because there, reliable data delivery is not
    assumed).[¶](#section-a.1-2.5.5){.pilcrow}
    :::

-   ::: {#section-a.1-2.6}
    Obtain multiple sockets[¶](#section-a.1-2.6.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-2.6.2){.pilcrow}

    Automatable because the non-parallel usage of multiple paths to
    communicate between the same end hosts relates to knowledge about
    the network, not the application.[¶](#section-a.1-2.6.3){.pilcrow}
    :::

-   ::: {#section-a.1-2.7}
    Disable MPTCP[¶](#section-a.1-2.7.1){.pilcrow}

    Protocols: MPTCP[¶](#section-a.1-2.7.2){.pilcrow}

    Optimizing because the parallel usage of multiple paths to
    communicate between the same end hosts can improve performance.
    Whether or not to use this feature depends on knowledge about the
    network as well as application-specific knowledge (see [Section
    3.1](https://www.rfc-editor.org/rfc/rfc6897#section-3.1){.relref} of
    \[[RFC6897](#RFC6897){.xref}\]).[¶](#section-a.1-2.7.3){.pilcrow}

    Implementation: via a boolean parameter in
    CONNECT.MPTCP.[¶](#section-a.1-2.7.4){.pilcrow}

    Implementation over TCP: do
    nothing.[¶](#section-a.1-2.7.5){.pilcrow}

    Implementation over UDP: do
    nothing.[¶](#section-a.1-2.7.6){.pilcrow}
    :::

-   ::: {#section-a.1-2.8}
    Configure authentication[¶](#section-a.1-2.8.1){.pilcrow}

    Protocols: TCP, SCTP[¶](#section-a.1-2.8.2){.pilcrow}

    Functional because this has a direct influence on
    security.[¶](#section-a.1-2.8.3){.pilcrow}

    Implementation: via parameters in CONNECT.TCP and CONNECT.SCTP. With
    TCP, this allows configuring Master Key Tuples (MKTs) to
    authenticate complete segments (including the TCP IPv4 pseudoheader,
    TCP header, and TCP data). With SCTP, this allows specifying which
    chunk types must always be authenticated. Authenticating only
    certain chunk types creates a reduced level of security that is not
    supported by TCP; to be compatible, this should therefore only allow
    to authenticate all chunk types. Key material must be provided in a
    way that is compatible with both \[[RFC4895](#RFC4895){.xref}\] and
    \[[RFC5925](#RFC5925){.xref}\].[¶](#section-a.1-2.8.4){.pilcrow}

    Implementation over UDP: not possible (UDP does not offer this
    functionality).[¶](#section-a.1-2.8.5){.pilcrow}
    :::

-   ::: {#section-a.1-2.9}
    Indicate (and/or obtain upon completion) an Adaptation Layer via an
    adaptation code point[¶](#section-a.1-2.9.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-2.9.2){.pilcrow}

    Functional because it allows sending extra data for the sake of
    identifying an adaptation layer, which by itself is application
    specific.[¶](#section-a.1-2.9.3){.pilcrow}

    Implementation: via a parameter in
    CONNECT.SCTP.[¶](#section-a.1-2.9.4){.pilcrow}

    Implementation over TCP: not possible. (TCP does not offer this
    functionality.)[¶](#section-a.1-2.9.5){.pilcrow}

    Implementation over UDP: not possible. (UDP does not offer this
    functionality.)[¶](#section-a.1-2.9.6){.pilcrow}
    :::

-   ::: {#section-a.1-2.10}
    Request to negotiate interleaving of user
    messages[¶](#section-a.1-2.10.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-2.10.2){.pilcrow}

    Automatable because it requires using multiple streams, but
    requesting multiple streams in the CONNECTION.ESTABLISHMENT category
    is automatable.[¶](#section-a.1-2.10.3){.pilcrow}

    Implementation: controlled via a parameter in CONNECT.SCTP. One
    possible implementation is to always try to enable
    interleaving.[¶](#section-a.1-2.10.4){.pilcrow}
    :::

-   ::: {#section-a.1-2.11}
    Hand over a message to reliably transfer (possibly multiple times)
    before connection establishment[¶](#section-a.1-2.11.1){.pilcrow}

    Protocols: TCP[¶](#section-a.1-2.11.2){.pilcrow}

    Functional because this is closely tied to properties of the data
    that an application sends or expects to
    receive.[¶](#section-a.1-2.11.3){.pilcrow}

    Implementation: via a parameter in
    CONNECT.TCP.[¶](#section-a.1-2.11.4){.pilcrow}

    Implementation over UDP: not possible. (UDP does not provide
    reliability.)[¶](#section-a.1-2.11.5){.pilcrow}
    :::

-   ::: {#section-a.1-2.12}
    Hand over a message to reliably transfer during connection
    establishment[¶](#section-a.1-2.12.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-2.12.2){.pilcrow}

    Functional because this can only work if the message is limited in
    size, making it closely tied to properties of the data that an
    application sends or expects to
    receive.[¶](#section-a.1-2.12.3){.pilcrow}

    Implementation: via a parameter in
    CONNECT.SCTP.[¶](#section-a.1-2.12.4){.pilcrow}

    Implementation over TCP: transmit the message with the SYN packet,
    sacrificing the ability to identify message
    boundaries.[¶](#section-a.1-2.12.5){.pilcrow}

    Implementation over UDP: not possible. (UDP is
    unreliable.)[¶](#section-a.1-2.12.6){.pilcrow}
    :::

-   ::: {#section-a.1-2.13}
    Enable UDP encapsulation with a specified remote UDP port
    number[¶](#section-a.1-2.13.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-2.13.2){.pilcrow}

    Automatable because UDP encapsulation relates to knowledge about the
    network, not the application.[¶](#section-a.1-2.13.3){.pilcrow}
    :::

AVAILABILITY:[¶](#section-a.1-3){.pilcrow}

-   ::: {#section-a.1-4.1}
    Listen[¶](#section-a.1-4.1.1){.pilcrow}

    Protocols: TCP, SCTP, UDP(-Lite)[¶](#section-a.1-4.1.2){.pilcrow}

    Functional because the notion of accepting connection requests is
    often reflected in applications as an expectation to be able to
    communicate after a \"Listen\" succeeded, with a communication
    sequence relating to this transport feature that is defined by the
    application protocol.[¶](#section-a.1-4.1.3){.pilcrow}

    CHANGED FROM RFC 8303. This differs from the 3 automatable transport
    features below in that it leaves the choice of interfaces for
    listening open.[¶](#section-a.1-4.1.4){.pilcrow}

    Implementation: by listening on all interfaces via LISTEN.TCP (not
    providing a local IP address) or LISTEN.SCTP (providing SCTP port
    number / address pairs for all local IP addresses).
    LISTEN.UDP(-Lite) supports both
    methods.[¶](#section-a.1-4.1.5){.pilcrow}
    :::

-   ::: {#section-a.1-4.2}
    Listen, 1 specified local interface[¶](#section-a.1-4.2.1){.pilcrow}

    Protocols: TCP, SCTP, UDP(-Lite)[¶](#section-a.1-4.2.2){.pilcrow}

    Automatable because decisions about local interfaces relate to
    knowledge about the network and the Operating System, not the
    application.[¶](#section-a.1-4.2.3){.pilcrow}
    :::

-   ::: {#section-a.1-4.3}
    Listen, N specified local
    interfaces[¶](#section-a.1-4.3.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-4.3.2){.pilcrow}

    Automatable because decisions about local interfaces relate to
    knowledge about the network and the Operating System, not the
    application.[¶](#section-a.1-4.3.3){.pilcrow}
    :::

-   ::: {#section-a.1-4.4}
    Listen, all local interfaces[¶](#section-a.1-4.4.1){.pilcrow}

    Protocols: TCP, SCTP, UDP(-Lite)[¶](#section-a.1-4.4.2){.pilcrow}

    Automatable because decisions about local interfaces relate to
    knowledge about the network and the Operating System, not the
    application.[¶](#section-a.1-4.4.3){.pilcrow}
    :::

-   ::: {#section-a.1-4.5}
    Specify which IP Options must always be
    used[¶](#section-a.1-4.5.1){.pilcrow}

    Protocols: TCP, UDP(-Lite)[¶](#section-a.1-4.5.2){.pilcrow}

    Automatable because IP Options relate to knowledge about the
    network, not the application.[¶](#section-a.1-4.5.3){.pilcrow}
    :::

-   ::: {#section-a.1-4.6}
    Disable MPTCP[¶](#section-a.1-4.6.1){.pilcrow}

    Protocols: MPTCP[¶](#section-a.1-4.6.2){.pilcrow}

    Optimizing because the parallel usage of multiple paths to
    communicate between the same end hosts can improve performance.
    Whether or not to use this feature depends on knowledge about the
    network as well as application-specific knowledge (see [Section
    3.1](https://www.rfc-editor.org/rfc/rfc6897#section-3.1){.relref} of
    \[[RFC6897](#RFC6897){.xref}\]).[¶](#section-a.1-4.6.3){.pilcrow}

    Implementation: via a boolean parameter in
    LISTEN.MPTCP.[¶](#section-a.1-4.6.4){.pilcrow}

    Implementation over TCP: do
    nothing.[¶](#section-a.1-4.6.5){.pilcrow}

    Implementation over UDP: do
    nothing.[¶](#section-a.1-4.6.6){.pilcrow}
    :::

-   ::: {#section-a.1-4.7}
    Configure authentication[¶](#section-a.1-4.7.1){.pilcrow}

    Protocols: TCP, SCTP[¶](#section-a.1-4.7.2){.pilcrow}

    Functional because this has a direct influence on
    security.[¶](#section-a.1-4.7.3){.pilcrow}

    Implementation: via parameters in LISTEN.TCP and
    LISTEN.SCTP.[¶](#section-a.1-4.7.4){.pilcrow}

    Implementation over TCP: with TCP, this allows configuring Master
    Key Tuples (MKTs) to authenticate complete segments (including the
    TCP IPv4 pseudoheader, TCP header, and TCP data). With SCTP, this
    allows specifying which chunk types must always be authenticated.
    Authenticating only certain chunk types creates a reduced level of
    security that is not supported by TCP; to be compatible, this should
    therefore only allow to authenticate all chunk types. Key material
    must be provided in a way that is compatible with both
    \[[RFC4895](#RFC4895){.xref}\] and
    \[[RFC5925](#RFC5925){.xref}\].[¶](#section-a.1-4.7.5){.pilcrow}

    Implementation over UDP: not possible. (UDP does not offer
    authentication.)[¶](#section-a.1-4.7.6){.pilcrow}
    :::

-   ::: {#section-a.1-4.8}
    Obtain requested number of streams[¶](#section-a.1-4.8.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-4.8.2){.pilcrow}

    Automatable because using multi-streaming does not require
    application-specific knowledge.[¶](#section-a.1-4.8.3){.pilcrow}

    Implementation: see [Section
    5.2](#nostream){.xref}.[¶](#section-a.1-4.8.4){.pilcrow}
    :::

-   ::: {#section-a.1-4.9}
    Limit the number of inbound streams[¶](#section-a.1-4.9.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-4.9.2){.pilcrow}

    Automatable because using multi-streaming does not require
    application-specific knowledge.[¶](#section-a.1-4.9.3){.pilcrow}

    Implementation: see [Section
    5.2](#nostream){.xref}.[¶](#section-a.1-4.9.4){.pilcrow}
    :::

-   ::: {#section-a.1-4.10}
    Indicate (and/or obtain upon completion) an Adaptation Layer via an
    adaptation code point[¶](#section-a.1-4.10.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-4.10.2){.pilcrow}

    Functional because it allows sending extra data for the sake of
    identifying an adaptation layer, which by itself is application
    specific.[¶](#section-a.1-4.10.3){.pilcrow}

    Implementation: via a parameter in
    LISTEN.SCTP.[¶](#section-a.1-4.10.4){.pilcrow}

    Implementation over TCP: not possible. (TCP does not offer this
    functionality.)[¶](#section-a.1-4.10.5){.pilcrow}

    Implementation over UDP: not possible. (UDP does not offer this
    functionality.)[¶](#section-a.1-4.10.6){.pilcrow}
    :::

-   ::: {#section-a.1-4.11}
    Request to negotiate interleaving of user
    messages[¶](#section-a.1-4.11.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-4.11.2){.pilcrow}

    Automatable because it requires using multiple streams, but
    requesting multiple streams in the CONNECTION.ESTABLISHMENT category
    is automatable.[¶](#section-a.1-4.11.3){.pilcrow}

    Implementation: via a parameter in
    LISTEN.SCTP.[¶](#section-a.1-4.11.4){.pilcrow}
    :::

MAINTENANCE:[¶](#section-a.1-5){.pilcrow}

-   ::: {#section-a.1-6.1}
    Change timeout for aborting connection (using retransmit limit or
    time value)[¶](#section-a.1-6.1.1){.pilcrow}

    Protocols: TCP, SCTP[¶](#section-a.1-6.1.2){.pilcrow}

    Functional because this is closely related to potentially assumed
    reliable data delivery.[¶](#section-a.1-6.1.3){.pilcrow}

    Implementation: via CHANGE_TIMEOUT.TCP or
    CHANGE_TIMEOUT.SCTP.[¶](#section-a.1-6.1.4){.pilcrow}

    Implementation over UDP: not possible. (UDP is unreliable and there
    is no connection timeout.)[¶](#section-a.1-6.1.5){.pilcrow}
    :::

-   ::: {#section-a.1-6.2}
    Suggest timeout to the peer[¶](#section-a.1-6.2.1){.pilcrow}

    Protocols: TCP[¶](#section-a.1-6.2.2){.pilcrow}

    Functional because this is closely related to potentially assumed
    reliable data delivery.[¶](#section-a.1-6.2.3){.pilcrow}

    Implementation: via
    CHANGE_TIMEOUT.TCP.[¶](#section-a.1-6.2.4){.pilcrow}

    Implementation over UDP: not possible. (UDP is unreliable and there
    is no connection timeout.)[¶](#section-a.1-6.2.5){.pilcrow}
    :::

-   ::: {#section-a.1-6.3}
    Disable Nagle algorithm[¶](#section-a.1-6.3.1){.pilcrow}

    Protocols: TCP, SCTP[¶](#section-a.1-6.3.2){.pilcrow}

    Optimizing because this decision depends on knowledge about the size
    of future data blocks and the delay between
    them.[¶](#section-a.1-6.3.3){.pilcrow}

    Implementation: via DISABLE_NAGLE.TCP and
    DISABLE_NAGLE.SCTP.[¶](#section-a.1-6.3.4){.pilcrow}

    Implementation over UDP: do nothing (UDP does not implement the
    Nagle algorithm).[¶](#section-a.1-6.3.5){.pilcrow}
    :::

-   ::: {#section-a.1-6.4}
    Request an immediate heartbeat, returning
    success/failure[¶](#section-a.1-6.4.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.4.2){.pilcrow}

    Automatable because this informs about network-specific
    knowledge.[¶](#section-a.1-6.4.3){.pilcrow}
    :::

-   ::: {#section-a.1-6.5}
    Notification of Excessive Retransmissions (early warning below
    abortion threshold)[¶](#section-a.1-6.5.1){.pilcrow}

    Protocols: TCP[¶](#section-a.1-6.5.2){.pilcrow}

    Optimizing because it is an early warning to the application,
    informing it of an impending functional
    event.[¶](#section-a.1-6.5.3){.pilcrow}

    Implementation: via ERROR.TCP.[¶](#section-a.1-6.5.4){.pilcrow}

    Implementation over UDP: do nothing (there is no abortion
    threshold).[¶](#section-a.1-6.5.5){.pilcrow}
    :::

-   ::: {#section-a.1-6.6}
    Add path[¶](#section-a.1-6.6.1){.pilcrow}

    Protocols: MPTCP, SCTP[¶](#section-a.1-6.6.2){.pilcrow}

    MPTCP Parameters: source-IP; source-Port; destination-IP;
    destination-Port[¶](#section-a.1-6.6.3){.pilcrow}

    SCTP Parameters: local IP address[¶](#section-a.1-6.6.4){.pilcrow}

    Automatable because the choice of paths to communicate between the
    same end hosts relates to knowledge about the network, not the
    application.[¶](#section-a.1-6.6.5){.pilcrow}
    :::

-   ::: {#section-a.1-6.7}
    Remove path[¶](#section-a.1-6.7.1){.pilcrow}

    Protocols: MPTCP, SCTP[¶](#section-a.1-6.7.2){.pilcrow}

    MPTCP Parameters: source-IP; source-Port; destination-IP;
    destination-Port[¶](#section-a.1-6.7.3){.pilcrow}

    SCTP Parameters: local IP address[¶](#section-a.1-6.7.4){.pilcrow}

    Automatable because the choice of paths to communicate between the
    same end host relates to knowledge about the network, not the
    application.[¶](#section-a.1-6.7.5){.pilcrow}
    :::

-   ::: {#section-a.1-6.8}
    Set primary path[¶](#section-a.1-6.8.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.8.2){.pilcrow}

    Automatable because the choice of paths to communicate between the
    same end hosts relates to knowledge about the network, not the
    application.[¶](#section-a.1-6.8.3){.pilcrow}
    :::

-   ::: {#section-a.1-6.9}
    Suggest primary path to the peer[¶](#section-a.1-6.9.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.9.2){.pilcrow}

    Automatable because the choice of paths to communicate between the
    same end hosts relates to knowledge about the network, not the
    application.[¶](#section-a.1-6.9.3){.pilcrow}
    :::

-   ::: {#section-a.1-6.10}
    Configure Path Switchover[¶](#section-a.1-6.10.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.10.2){.pilcrow}

    Automatable because the choice of paths to communicate between the
    same end hosts relates to knowledge about the network, not the
    application.[¶](#section-a.1-6.10.3){.pilcrow}
    :::

-   ::: {#section-a.1-6.11}
    Obtain status (query or
    notification)[¶](#section-a.1-6.11.1){.pilcrow}

    Protocols: SCTP, MPTCP[¶](#section-a.1-6.11.2){.pilcrow}

    SCTP parameters: association connection state; destination transport
    address list; destination transport address reachability states;
    current local and peer receiver window size; current local
    congestion window sizes; number of unacknowledged DATA chunks;
    number of DATA chunks pending receipt; primary path; most recent
    SRTT on primary path; RTO on primary path; SRTT and RTO on other
    destination addresses; MTU per path; interleaving supported
    yes/no[¶](#section-a.1-6.11.3){.pilcrow}

    MPTCP parameters: subflow-list (identified by source-IP;
    source-Port; destination-IP;
    destination-Port)[¶](#section-a.1-6.11.4){.pilcrow}

    Automatable because these parameters relate to knowledge about the
    network, not the application.[¶](#section-a.1-6.11.5){.pilcrow}
    :::

-   ::: {#section-a.1-6.12}
    Specify DSCP field[¶](#section-a.1-6.12.1){.pilcrow}

    Protocols: TCP, SCTP, UDP(-Lite)[¶](#section-a.1-6.12.2){.pilcrow}

    Optimizing because choosing a suitable DSCP value requires
    application-specific knowledge.[¶](#section-a.1-6.12.3){.pilcrow}

    Implementation: via SET_DSCP.TCP / SET_DSCP.SCTP /
    SET_DSCP.UDP(-Lite).[¶](#section-a.1-6.12.4){.pilcrow}
    :::

-   ::: {#section-a.1-6.13}
    Notification of ICMP error message
    arrival[¶](#section-a.1-6.13.1){.pilcrow}

    Protocols: TCP, UDP(-Lite)[¶](#section-a.1-6.13.2){.pilcrow}

    Optimizing because these messages can inform about success or
    failure of functional transport features (e.g., host unreachable
    relates to \"Connect\").[¶](#section-a.1-6.13.3){.pilcrow}

    Implementation: via ERROR.TCP or
    ERROR.UDP(-Lite.)[¶](#section-a.1-6.13.4){.pilcrow}
    :::

-   ::: {#section-a.1-6.14}
    Obtain information about interleaving
    support[¶](#section-a.1-6.14.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.14.2){.pilcrow}

    Automatable because it requires using multiple streams, but
    requesting multiple streams in the CONNECTION.ESTABLISHMENT category
    is automatable.[¶](#section-a.1-6.14.3){.pilcrow}

    Implementation: via STATUS.SCTP.[¶](#section-a.1-6.14.4){.pilcrow}
    :::

-   ::: {#section-a.1-6.15}
    Change authentication parameters[¶](#section-a.1-6.15.1){.pilcrow}

    Protocols: TCP, SCTP[¶](#section-a.1-6.15.2){.pilcrow}

    Functional because this has a direct influence on
    security.[¶](#section-a.1-6.15.3){.pilcrow}

    Implementation: via SET_AUTH.TCP and
    SET_AUTH.SCTP.[¶](#section-a.1-6.15.4){.pilcrow}

    Implementation over TCP: with SCTP, this allows adjusting key_id,
    key, and hmac_id. With TCP, this allows changing the preferred
    outgoing MKT (current_key) and the preferred incoming MKT
    (rnext_key), respectively, for a segment that is sent on the
    connection. Key material must be provided in a way that is
    compatible with both \[[RFC4895](#RFC4895){.xref}\] and
    \[[RFC5925](#RFC5925){.xref}\].[¶](#section-a.1-6.15.5){.pilcrow}

    Implementation over UDP: not possible. (UDP does not offer
    authentication.)[¶](#section-a.1-6.15.6){.pilcrow}
    :::

-   ::: {#section-a.1-6.16}
    Obtain authentication information[¶](#section-a.1-6.16.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.16.2){.pilcrow}

    Functional because authentication decisions may have been made by
    the peer, and this has an influence on the necessary
    application-level measures to provide a certain level of
    security.[¶](#section-a.1-6.16.3){.pilcrow}

    Implementation: via GET_AUTH.SCTP.[¶](#section-a.1-6.16.4){.pilcrow}

    Implementation over TCP: with SCTP, this allows obtaining key_id and
    a chunk list. With TCP, this allows obtaining current_key and
    rnext_key from a previously received segment. Key material must be
    provided in a way that is compatible with both
    \[[RFC4895](#RFC4895){.xref}\] and
    \[[RFC5925](#RFC5925){.xref}\].[¶](#section-a.1-6.16.5){.pilcrow}

    Implementation over UDP: not possible. (UDP does not offer
    authentication.)[¶](#section-a.1-6.16.6){.pilcrow}
    :::

-   ::: {#section-a.1-6.17}
    Reset Stream[¶](#section-a.1-6.17.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.17.2){.pilcrow}

    Automatable because using multi-streaming does not require
    application-specific knowledge.[¶](#section-a.1-6.17.3){.pilcrow}

    Implementation: see [Section
    5.2](#nostream){.xref}.[¶](#section-a.1-6.17.4){.pilcrow}
    :::

-   ::: {#section-a.1-6.18}
    Notification of Stream Reset[¶](#section-a.1-6.18.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.18.2){.pilcrow}

    Automatable because using multi-streaming does not require
    application-specific knowledge.[¶](#section-a.1-6.18.3){.pilcrow}

    Implementation: see [Section
    5.2](#nostream){.xref}.[¶](#section-a.1-6.18.4){.pilcrow}
    :::

-   ::: {#section-a.1-6.19}
    Reset Association[¶](#section-a.1-6.19.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.19.2){.pilcrow}

    Automatable because deciding to reset an association does not
    require application-specific
    knowledge.[¶](#section-a.1-6.19.3){.pilcrow}

    Implementation: via
    RESET_ASSOC.SCTP.[¶](#section-a.1-6.19.4){.pilcrow}
    :::

-   ::: {#section-a.1-6.20}
    Notification of Association Reset[¶](#section-a.1-6.20.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.20.2){.pilcrow}

    Automatable because this notification does not relate to
    application-specific knowledge.[¶](#section-a.1-6.20.3){.pilcrow}
    :::

-   ::: {#section-a.1-6.21}
    Add Streams[¶](#section-a.1-6.21.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.21.2){.pilcrow}

    Automatable because using multi-streaming does not require
    application-specific knowledge.[¶](#section-a.1-6.21.3){.pilcrow}

    Implementation: see [Section
    5.2](#nostream){.xref}.[¶](#section-a.1-6.21.4){.pilcrow}
    :::

-   ::: {#section-a.1-6.22}
    Notification of Added Stream[¶](#section-a.1-6.22.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.22.2){.pilcrow}

    Automatable because using multi-streaming does not require
    application-specific knowledge.[¶](#section-a.1-6.22.3){.pilcrow}

    Implementation: see [Section
    5.2](#nostream){.xref}.[¶](#section-a.1-6.22.4){.pilcrow}
    :::

-   ::: {#section-a.1-6.23}
    Choose a scheduler to operate between streams of an
    association[¶](#section-a.1-6.23.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.23.2){.pilcrow}

    Optimizing because the scheduling decision requires
    application-specific knowledge. However, if a transport system would
    not use this, or wrongly configure it on its own, this would only
    affect the performance of data transfers; the outcome would still be
    correct within the \"best effort\" service
    model.[¶](#section-a.1-6.23.3){.pilcrow}

    Implementation: using
    SET_STREAM_SCHEDULER.SCTP.[¶](#section-a.1-6.23.4){.pilcrow}

    Implementation over TCP: do nothing (streams are not available in
    TCP, but no guarantee is given that this transport feature has any
    effect).[¶](#section-a.1-6.23.5){.pilcrow}

    Implementation over UDP: do nothing (streams are not available in
    UDP, but no guarantee is given that this transport feature has any
    effect).[¶](#section-a.1-6.23.6){.pilcrow}
    :::

-   ::: {#section-a.1-6.24}
    Configure priority or weight for a
    scheduler[¶](#section-a.1-6.24.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.24.2){.pilcrow}

    Optimizing because the priority or weight requires
    application-specific knowledge. However, if a transport system would
    not use this, or wrongly configure it on its own, this would only
    affect the performance of data transfers; the outcome would still be
    correct within the \"best effort\" service
    model.[¶](#section-a.1-6.24.3){.pilcrow}

    Implementation: using
    CONFIGURE_STREAM_SCHEDULER.SCTP.[¶](#section-a.1-6.24.4){.pilcrow}

    Implementation over TCP: do nothing (streams are not available in
    TCP, but no guarantee is given that this transport feature has any
    effect).[¶](#section-a.1-6.24.5){.pilcrow}

    Implementation over UDP: do nothing (streams are not available in
    UDP, but no guarantee is given that this transport feature has any
    effect).[¶](#section-a.1-6.24.6){.pilcrow}
    :::

-   ::: {#section-a.1-6.25}
    Configure send buffer size[¶](#section-a.1-6.25.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.25.2){.pilcrow}

    Automatable because this decision relates to knowledge about the
    network and the Operating System, not the application (see also the
    discussion in [Section
    5.4](#rundry){.xref}).[¶](#section-a.1-6.25.3){.pilcrow}
    :::

-   ::: {#section-a.1-6.26}
    Configure receive buffer (and rwnd)
    size[¶](#section-a.1-6.26.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.26.2){.pilcrow}

    Automatable because this decision relates to knowledge about the
    network and the Operating System, not the
    application.[¶](#section-a.1-6.26.3){.pilcrow}
    :::

-   ::: {#section-a.1-6.27}
    Configure message fragmentation[¶](#section-a.1-6.27.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.27.2){.pilcrow}

    Automatable because this relates to knowledge about the network and
    the Operating System, not the application. Note that this SCTP
    feature does not control IP-level fragmentation, but decides on
    fragmentation of messages by SCTP, in the end
    system.[¶](#section-a.1-6.27.3){.pilcrow}

    Implementation: done by always enabling it with
    CONFIG_FRAGMENTATION.SCTP and auto-setting the fragmentation size
    based on network or Operating System
    conditions.[¶](#section-a.1-6.27.4){.pilcrow}
    :::

-   ::: {#section-a.1-6.28}
    Configure PMTUD[¶](#section-a.1-6.28.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.28.2){.pilcrow}

    Automatable because Path MTU Discovery relates to knowledge about
    the network, not the application.[¶](#section-a.1-6.28.3){.pilcrow}
    :::

-   ::: {#section-a.1-6.29}
    Configure delayed SACK timer[¶](#section-a.1-6.29.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.29.2){.pilcrow}

    Automatable because the receiver-side decision to delay sending
    SACKs relates to knowledge about the network, not the application
    (it can be relevant for a sending application to request not to
    delay the SACK of a message, but this is a different transport
    feature).[¶](#section-a.1-6.29.3){.pilcrow}
    :::

-   ::: {#section-a.1-6.30}
    Set Cookie life value[¶](#section-a.1-6.30.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.30.2){.pilcrow}

    Functional because it relates to security (possibly weakened by
    keeping a cookie very long) versus the time between connection
    establishment attempts. Knowledge about both issues can be
    application specific.[¶](#section-a.1-6.30.3){.pilcrow}

    Implementation over TCP: the closest specified TCP functionality is
    the cookie in TCP Fast Open; for this,
    \[[RFC7413](#RFC7413){.xref}\] states that the server \"can expire
    the cookie at any time to enhance security\", and [Section
    4.1.2](https://www.rfc-editor.org/rfc/rfc7413#section-4.1.2){.relref}
    of \[[RFC7413](#RFC7413){.xref}\] describes an example
    implementation where updating the key on the server side causes the
    cookie to expire. Alternatively, for implementations that do not
    support TCP Fast Open, this transport feature could also affect the
    validity of SYN cookies (see [Section
    3.6](https://www.rfc-editor.org/rfc/rfc4987#section-3.6){.relref} of
    \[[RFC4987](#RFC4987){.xref}\]).[¶](#section-a.1-6.30.4){.pilcrow}

    Implementation over UDP: not possible. (UDP does not offer this
    functionality.)[¶](#section-a.1-6.30.5){.pilcrow}
    :::

-   ::: {#section-a.1-6.31}
    Set maximum burst[¶](#section-a.1-6.31.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.31.2){.pilcrow}

    Automatable because it relates to knowledge about the network, not
    the application.[¶](#section-a.1-6.31.3){.pilcrow}
    :::

-   ::: {#section-a.1-6.32}
    Configure size where messages are broken up for partial
    delivery[¶](#section-a.1-6.32.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.1-6.32.2){.pilcrow}

    Functional because this is closely tied to properties of the data
    that an application sends or expects to
    receive.[¶](#section-a.1-6.32.3){.pilcrow}

    Implementation over TCP: not possible. (TCP does not offer
    identification of message
    boundaries.)[¶](#section-a.1-6.32.4){.pilcrow}

    Implementation over UDP: not possible. (UDP does not fragment
    messages.)[¶](#section-a.1-6.32.5){.pilcrow}
    :::

-   ::: {#section-a.1-6.33}
    Disable checksum when sending[¶](#section-a.1-6.33.1){.pilcrow}

    Protocols: UDP[¶](#section-a.1-6.33.2){.pilcrow}

    Functional because application-specific knowledge is necessary to
    decide whether it can be acceptable to lose data integrity with
    respect to random corruption.[¶](#section-a.1-6.33.3){.pilcrow}

    Implementation: via
    SET_CHECKSUM_ENABLED.UDP.[¶](#section-a.1-6.33.4){.pilcrow}

    Implementation over TCP: do nothing (TCP does not offer to disable
    the checksum, but transmitting data with an intact checksum will not
    yield a semantically wrong
    result).[¶](#section-a.1-6.33.5){.pilcrow}
    :::

-   ::: {#section-a.1-6.34}
    Disable checksum requirement when
    receiving[¶](#section-a.1-6.34.1){.pilcrow}

    Protocols: UDP[¶](#section-a.1-6.34.2){.pilcrow}

    Functional because application-specific knowledge is necessary to
    decide whether it can be acceptable to lose data integrity with
    respect to random corruption.[¶](#section-a.1-6.34.3){.pilcrow}

    Implementation: via
    SET_CHECKSUM_REQUIRED.UDP.[¶](#section-a.1-6.34.4){.pilcrow}

    Implementation over TCP: do nothing (TCP does not offer to disable
    the checksum, but transmitting data with an intact checksum will not
    yield a semantically wrong
    result).[¶](#section-a.1-6.34.5){.pilcrow}
    :::

-   ::: {#section-a.1-6.35}
    Specify checksum coverage used by the
    sender[¶](#section-a.1-6.35.1){.pilcrow}

    Protocols: UDP-Lite[¶](#section-a.1-6.35.2){.pilcrow}

    Functional because application-specific knowledge is necessary to
    decide for which parts of the data it can be acceptable to lose data
    integrity with respect to random
    corruption.[¶](#section-a.1-6.35.3){.pilcrow}

    Implementation: via
    SET_CHECKSUM_COVERAGE.UDP-Lite.[¶](#section-a.1-6.35.4){.pilcrow}

    Implementation over TCP: do nothing (TCP does not offer to limit the
    checksum length, but transmitting data with an intact checksum will
    not yield a semantically wrong
    result).[¶](#section-a.1-6.35.5){.pilcrow}

    Implementation over UDP: if checksum coverage is set to cover
    payload data, do nothing. Else, either do nothing (transmitting data
    with an intact checksum will not yield a semantically wrong result),
    or use the transport feature \"Disable checksum when
    sending\".[¶](#section-a.1-6.35.6){.pilcrow}
    :::

-   ::: {#section-a.1-6.36}
    Specify minimum checksum coverage required by
    receiver[¶](#section-a.1-6.36.1){.pilcrow}

    Protocols: UDP-Lite[¶](#section-a.1-6.36.2){.pilcrow}

    Functional because application-specific knowledge is necessary to
    decide for which parts of the data it can be acceptable to lose data
    integrity with respect to random
    corruption.[¶](#section-a.1-6.36.3){.pilcrow}

    Implementation: via
    SET_MIN_CHECKSUM_COVERAGE.UDP-Lite.[¶](#section-a.1-6.36.4){.pilcrow}

    Implementation over TCP: do nothing (TCP does not offer to limit the
    checksum length, but transmitting data with an intact checksum will
    not yield a semantically wrong
    result).[¶](#section-a.1-6.36.5){.pilcrow}

    Implementation over UDP: if checksum coverage is set to cover
    payload data, do nothing. Else, either do nothing (transmitting data
    with an intact checksum will not yield a semantically wrong result),
    or use the transport feature \"Disable checksum requirement when
    receiving\".[¶](#section-a.1-6.36.6){.pilcrow}
    :::

-   ::: {#section-a.1-6.37}
    Specify DF field[¶](#section-a.1-6.37.1){.pilcrow}

    Protocols: UDP(-Lite)[¶](#section-a.1-6.37.2){.pilcrow}

    Optimizing because the DF field can be used to carry out Path MTU
    Discovery, which can lead an application to choose message sizes
    that can be transmitted more
    efficiently.[¶](#section-a.1-6.37.3){.pilcrow}

    Implementation: via MAINTENANCE.SET_DF.UDP(-Lite) and
    SEND_FAILURE.UDP(-Lite).[¶](#section-a.1-6.37.4){.pilcrow}

    Implementation over TCP: do nothing (with TCP, the sending
    application is not in control of transport message sizes, making
    this functionality irrelevant).[¶](#section-a.1-6.37.5){.pilcrow}
    :::

-   ::: {#section-a.1-6.38}
    Get max. transport-message size that may be sent using a
    non-fragmented IP packet from the configured
    interface[¶](#section-a.1-6.38.1){.pilcrow}

    Protocols: UDP(-Lite)[¶](#section-a.1-6.38.2){.pilcrow}

    Optimizing because this can lead an application to choose message
    sizes that can be transmitted more
    efficiently.[¶](#section-a.1-6.38.3){.pilcrow}

    Implementation over TCP: do nothing (this information is not
    available with TCP).[¶](#section-a.1-6.38.4){.pilcrow}
    :::

-   ::: {#section-a.1-6.39}
    Get max. transport-message size that may be received from the
    configured interface[¶](#section-a.1-6.39.1){.pilcrow}

    Protocols: UDP(-Lite)[¶](#section-a.1-6.39.2){.pilcrow}

    Optimizing because this can, for example, influence an
    application\'s memory management.[¶](#section-a.1-6.39.3){.pilcrow}

    Implementation over TCP: do nothing (this information is not
    available with TCP).[¶](#section-a.1-6.39.4){.pilcrow}
    :::

-   ::: {#section-a.1-6.40}
    Specify TTL/Hop count field[¶](#section-a.1-6.40.1){.pilcrow}

    Protocols: UDP(-Lite)[¶](#section-a.1-6.40.2){.pilcrow}

    Automatable because a transport system can use a large enough system
    default to avoid communication failures. Allowing an application to
    configure it differently can produce notifications of ICMP error
    message arrivals that yield information that only relates to
    knowledge about the network, not the
    application.[¶](#section-a.1-6.40.3){.pilcrow}
    :::

-   ::: {#section-a.1-6.41}
    Obtain TTL/Hop count field[¶](#section-a.1-6.41.1){.pilcrow}

    Protocols: UDP(-Lite)[¶](#section-a.1-6.41.2){.pilcrow}

    Automatable because the TTL/Hop count field relates to knowledge
    about the network, not the
    application.[¶](#section-a.1-6.41.3){.pilcrow}
    :::

-   ::: {#section-a.1-6.42}
    Specify ECN field[¶](#section-a.1-6.42.1){.pilcrow}

    Protocols: UDP(-Lite)[¶](#section-a.1-6.42.2){.pilcrow}

    Automatable because the ECN field relates to knowledge about the
    network, not the application.[¶](#section-a.1-6.42.3){.pilcrow}
    :::

-   ::: {#section-a.1-6.43}
    Obtain ECN field[¶](#section-a.1-6.43.1){.pilcrow}

    Protocols: UDP(-Lite)[¶](#section-a.1-6.43.2){.pilcrow}

    Optimizing because this information can be used by an application to
    better carry out congestion control (this is relevant when choosing
    a data transmission Transport Service that does not already do
    congestion control).[¶](#section-a.1-6.43.3){.pilcrow}

    Implementation over TCP: do nothing (this information is not
    available with TCP).[¶](#section-a.1-6.43.4){.pilcrow}
    :::

-   ::: {#section-a.1-6.44}
    Specify IP Options[¶](#section-a.1-6.44.1){.pilcrow}

    Protocols: UDP(-Lite)[¶](#section-a.1-6.44.2){.pilcrow}

    Automatable because IP Options relate to knowledge about the
    network, not the application.[¶](#section-a.1-6.44.3){.pilcrow}
    :::

-   ::: {#section-a.1-6.45}
    Obtain IP Options[¶](#section-a.1-6.45.1){.pilcrow}

    Protocols: UDP(-Lite)[¶](#section-a.1-6.45.2){.pilcrow}

    Automatable because IP Options relate to knowledge about the
    network, not the application.[¶](#section-a.1-6.45.3){.pilcrow}
    :::

-   ::: {#section-a.1-6.46}
    Enable and configure a \"Low Extra Delay Background
    Transfer\"[¶](#section-a.1-6.46.1){.pilcrow}

    Protocols: a protocol implementing the LEDBAT congestion control
    mechanism[¶](#section-a.1-6.46.2){.pilcrow}

    Optimizing because whether this feature is appropriate or not
    depends on application-specific knowledge. However, wrongly using
    this will only affect the speed of data transfers (albeit including
    other transfers that may compete with the transport system\'s
    transfer in the network), so it is still correct within the \"best
    effort\" service model.[¶](#section-a.1-6.46.3){.pilcrow}

    Implementation: via CONFIGURE.LEDBAT and/or SET_DSCP.TCP /
    SET_DSCP.SCTP / SET_DSCP.UDP(-Lite)
    \[[RFC8622](#RFC8622){.xref}\].[¶](#section-a.1-6.46.4){.pilcrow}

    Implementation over TCP: do nothing (TCP does not support LEDBAT
    congestion control, but not implementing this functionality will not
    yield a semantically wrong
    behavior).[¶](#section-a.1-6.46.5){.pilcrow}

    Implementation over UDP: do nothing (UDP does not offer congestion
    control).[¶](#section-a.1-6.46.6){.pilcrow}
    :::

TERMINATION:[¶](#section-a.1-7){.pilcrow}

-   ::: {#section-a.1-8.1}
    Close after reliably delivering all remaining data, causing an event
    informing the application on the other
    side[¶](#section-a.1-8.1.1){.pilcrow}

    Protocols: TCP, SCTP[¶](#section-a.1-8.1.2){.pilcrow}

    Functional because the notion of a connection is often reflected in
    applications as an expectation to have all outstanding data
    delivered and no longer be able to communicate after a \"Close\"
    succeeded, with a communication sequence relating to this transport
    feature that is defined by the application
    protocol.[¶](#section-a.1-8.1.3){.pilcrow}

    Implementation: via CLOSE.TCP and
    CLOSE.SCTP.[¶](#section-a.1-8.1.4){.pilcrow}

    Implementation over UDP: not possible. (UDP is unreliable and hence
    does not know when all remaining data is delivered; it does also not
    offer to cause an event related to closing at the
    peer.)[¶](#section-a.1-8.1.5){.pilcrow}
    :::

-   ::: {#section-a.1-8.2}
    Abort without delivering remaining data, causing an event informing
    the application on the other side[¶](#section-a.1-8.2.1){.pilcrow}

    Protocols: TCP, SCTP[¶](#section-a.1-8.2.2){.pilcrow}

    Functional because the notion of a connection is often reflected in
    applications as an expectation to potentially not have all
    outstanding data delivered and no longer be able to communicate
    after an \"Abort\" succeeded. On both sides of a connection, an
    application protocol may define a communication sequence relating to
    this transport feature.[¶](#section-a.1-8.2.3){.pilcrow}

    Implementation: via ABORT.TCP and
    ABORT.SCTP.[¶](#section-a.1-8.2.4){.pilcrow}

    Implementation over UDP: not possible. (UDP does not offer to cause
    an event related to aborting at the
    peer.)[¶](#section-a.1-8.2.5){.pilcrow}
    :::

-   ::: {#section-a.1-8.3}
    Abort without delivering remaining data, not causing an event
    informing the application on the other
    side[¶](#section-a.1-8.3.1){.pilcrow}

    Protocols: UDP(-Lite)[¶](#section-a.1-8.3.2){.pilcrow}

    Functional because the notion of a connection is often reflected in
    applications as an expectation to potentially not have all
    outstanding data delivered and no longer be able to communicate
    after an \"Abort\" succeeded. On both sides of a connection, an
    application protocol may define a communication sequence relating to
    this transport feature.[¶](#section-a.1-8.3.3){.pilcrow}

    Implementation: via
    ABORT.UDP(-Lite).[¶](#section-a.1-8.3.4){.pilcrow}

    Implementation over TCP: stop using the connection, wait for a
    timeout.[¶](#section-a.1-8.3.5){.pilcrow}
    :::

-   ::: {#section-a.1-8.4}
    Timeout event when data could not be delivered for too
    long[¶](#section-a.1-8.4.1){.pilcrow}

    Protocols: TCP, SCTP[¶](#section-a.1-8.4.2){.pilcrow}

    Functional because this notifies that potentially assumed reliable
    data delivery is no longer
    provided.[¶](#section-a.1-8.4.3){.pilcrow}

    Implementation: via TIMEOUT.TCP and
    TIMEOUT.SCTP.[¶](#section-a.1-8.4.4){.pilcrow}

    Implementation over UDP: do nothing (this event will not occur with
    UDP).[¶](#section-a.1-8.4.5){.pilcrow}
    :::
:::
:::

::: {#data-pass3}
::: {#section-a.2 .section}
## [A.2.](#section-a.2){.section-number .selfRef} [DATA-Transfer-Related Transport Features](#name-data-transfer-related-transp){.section-name .selfRef} {#name-data-transfer-related-transp}

::: {#data-sending-pass3}
::: {#section-a.2.1 .section}
### [A.2.1.](#section-a.2.1){.section-number .selfRef} [Sending Data](#name-sending-data-3){.section-name .selfRef} {#name-sending-data-3}

-   ::: {#section-a.2.1-1.1}
    Reliably transfer data, with congestion
    control[¶](#section-a.2.1-1.1.1){.pilcrow}

    Protocols: TCP, SCTP[¶](#section-a.2.1-1.1.2){.pilcrow}

    Functional because this is closely tied to properties of the data
    that an application sends or expects to
    receive.[¶](#section-a.2.1-1.1.3){.pilcrow}

    Implementation: via SEND.TCP and
    SEND.SCTP.[¶](#section-a.2.1-1.1.4){.pilcrow}

    Implementation over UDP: not possible. (UDP is
    unreliable.)[¶](#section-a.2.1-1.1.5){.pilcrow}
    :::

-   ::: {#section-a.2.1-1.2}
    Reliably transfer a message, with congestion
    control[¶](#section-a.2.1-1.2.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.2.1-1.2.2){.pilcrow}

    Functional because this is closely tied to properties of the data
    that an application sends or expects to
    receive.[¶](#section-a.2.1-1.2.3){.pilcrow}

    Implementation: via SEND.SCTP.[¶](#section-a.2.1-1.2.4){.pilcrow}

    Implementation over TCP: via SEND.TCP. With SEND.TCP, message
    boundaries will not be identifiable by the receiver, because TCP
    provides a byte-stream service.[¶](#section-a.2.1-1.2.5){.pilcrow}

    Implementation over UDP: not possible. (UDP is
    unreliable.)[¶](#section-a.2.1-1.2.6){.pilcrow}
    :::

-   ::: {#section-a.2.1-1.3}
    Unreliably transfer a message[¶](#section-a.2.1-1.3.1){.pilcrow}

    Protocols: SCTP, UDP(-Lite)[¶](#section-a.2.1-1.3.2){.pilcrow}

    Optimizing because only applications know about the time criticality
    of their communication, and reliably transferring a message is never
    incorrect for the receiver of a potentially unreliable data
    transfer, it is just slower.[¶](#section-a.2.1-1.3.3){.pilcrow}

    CHANGED FROM RFC 8303. This differs from the 2 automatable transport
    features below in that it leaves the choice of congestion control
    open.[¶](#section-a.2.1-1.3.4){.pilcrow}

    Implementation: via SEND.SCTP or
    SEND.UDP(-Lite).[¶](#section-a.2.1-1.3.5){.pilcrow}

    Implementation over TCP: use SEND.TCP. With SEND.TCP, messages will
    be sent reliably, and message boundaries will not be identifiable by
    the receiver.[¶](#section-a.2.1-1.3.6){.pilcrow}
    :::

-   ::: {#section-a.2.1-1.4}
    Unreliably transfer a message, with congestion
    control[¶](#section-a.2.1-1.4.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.2.1-1.4.2){.pilcrow}

    Automatable because congestion control relates to knowledge about
    the network, not the application.[¶](#section-a.2.1-1.4.3){.pilcrow}
    :::

-   ::: {#section-a.2.1-1.5}
    Unreliably transfer a message, without congestion
    control[¶](#section-a.2.1-1.5.1){.pilcrow}

    Protocols: UDP(-Lite)[¶](#section-a.2.1-1.5.2){.pilcrow}

    Automatable because congestion control relates to knowledge about
    the network, not the application.[¶](#section-a.2.1-1.5.3){.pilcrow}
    :::

-   ::: {#section-a.2.1-1.6}
    Configurable Message Reliability[¶](#section-a.2.1-1.6.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.2.1-1.6.2){.pilcrow}

    Optimizing because only applications know about the time criticality
    of their communication, and reliably transferring a message is never
    incorrect for the receiver of a potentially unreliable data
    transfer, it is just slower.[¶](#section-a.2.1-1.6.3){.pilcrow}

    Implementation: via SEND.SCTP.[¶](#section-a.2.1-1.6.4){.pilcrow}

    Implementation over TCP: done by using SEND.TCP and ignoring this
    configuration. Based on the assumption of the best-effort service
    model, unnecessarily delivering data does not violate application
    expectations. Moreover, it is not possible to associate the
    requested reliability to a \"message\" in TCP
    anyway.[¶](#section-a.2.1-1.6.5){.pilcrow}

    Implementation over UDP: not possible. (UDP is
    unreliable.)[¶](#section-a.2.1-1.6.6){.pilcrow}
    :::

-   ::: {#section-a.2.1-1.7}
    Choice of stream[¶](#section-a.2.1-1.7.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.2.1-1.7.2){.pilcrow}

    Automatable because it requires using multiple streams, but
    requesting multiple streams in the CONNECTION.ESTABLISHMENT category
    is automatable.[¶](#section-a.2.1-1.7.3){.pilcrow}

    Implementation: see [Section
    5.2](#nostream){.xref}.[¶](#section-a.2.1-1.7.4){.pilcrow}
    :::

-   ::: {#section-a.2.1-1.8}
    Choice of path (destination
    address)[¶](#section-a.2.1-1.8.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.2.1-1.8.2){.pilcrow}

    Automatable because it requires using multiple sockets, but
    obtaining multiple sockets in the CONNECTION.ESTABLISHMENT category
    is automatable.[¶](#section-a.2.1-1.8.3){.pilcrow}
    :::

-   ::: {#section-a.2.1-1.9}
    Ordered message delivery (potentially slower than
    unordered)[¶](#section-a.2.1-1.9.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.2.1-1.9.2){.pilcrow}

    Functional because this is closely tied to properties of the data
    that an application sends or expects to
    receive.[¶](#section-a.2.1-1.9.3){.pilcrow}

    Implementation: via SEND.SCTP.[¶](#section-a.2.1-1.9.4){.pilcrow}

    Implementation over TCP: done by using SEND.TCP. With SEND.TCP,
    messages will not be identifiable by the
    receiver.[¶](#section-a.2.1-1.9.5){.pilcrow}

    Implementation over UDP: not possible. (UDP does not offer any
    guarantees regarding ordering.)[¶](#section-a.2.1-1.9.6){.pilcrow}
    :::

-   ::: {#section-a.2.1-1.10}
    Unordered message delivery (potentially faster than
    ordered)[¶](#section-a.2.1-1.10.1){.pilcrow}

    Protocols: SCTP, UDP(-Lite)[¶](#section-a.2.1-1.10.2){.pilcrow}

    Functional because this is closely tied to properties of the data
    that an application sends or expects to
    receive.[¶](#section-a.2.1-1.10.3){.pilcrow}

    Implementation: via SEND.SCTP.[¶](#section-a.2.1-1.10.4){.pilcrow}

    Implementation over TCP: done by using SEND.TCP and always sending
    data ordered. Based on the assumption of the best-effort service
    model, ordered delivery may just be slower and does not violate
    application expectations. Moreover, it is not possible to associate
    the requested delivery order to a \"message\" in TCP
    anyway.[¶](#section-a.2.1-1.10.5){.pilcrow}
    :::

-   ::: {#section-a.2.1-1.11}
    Request not to bundle messages[¶](#section-a.2.1-1.11.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.2.1-1.11.2){.pilcrow}

    Optimizing because this decision depends on knowledge about the size
    of future data blocks and the delay between
    them.[¶](#section-a.2.1-1.11.3){.pilcrow}

    Implementation: via SEND.SCTP.[¶](#section-a.2.1-1.11.4){.pilcrow}

    Implementation over TCP: done by using SEND.TCP and
    DISABLE_NAGLE.TCP to disable the Nagle algorithm when the request is
    made and enable it again when the request is no longer made. Note
    that this is not fully equivalent because it relates to the time of
    issuing the request rather than a specific
    message.[¶](#section-a.2.1-1.11.5){.pilcrow}

    Implementation over UDP: do nothing (UDP never bundles
    messages).[¶](#section-a.2.1-1.11.6){.pilcrow}
    :::

-   ::: {#section-a.2.1-1.12}
    Specifying a \"payload protocol-id\" (handed over as such by the
    receiver)[¶](#section-a.2.1-1.12.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.2.1-1.12.2){.pilcrow}

    Functional because it allows sending extra application data with
    every message, for the sake of identification of data, which by
    itself is application specific.[¶](#section-a.2.1-1.12.3){.pilcrow}

    Implementation: SEND.SCTP.[¶](#section-a.2.1-1.12.4){.pilcrow}

    Implementation over TCP: not possible. (This functionality is not
    available in TCP.)[¶](#section-a.2.1-1.12.5){.pilcrow}

    Implementation over UDP: not possible. (This functionality is not
    available in UDP.)[¶](#section-a.2.1-1.12.6){.pilcrow}
    :::

-   ::: {#section-a.2.1-1.13}
    Specifying a key id to be used to authenticate a
    message[¶](#section-a.2.1-1.13.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.2.1-1.13.2){.pilcrow}

    Functional because this has a direct influence on
    security.[¶](#section-a.2.1-1.13.3){.pilcrow}

    Implementation: via a parameter in
    SEND.SCTP.[¶](#section-a.2.1-1.13.4){.pilcrow}

    Implementation over TCP: this could be emulated by using
    SET_AUTH.TCP before and after the message is sent. Note that this is
    not fully equivalent because it relates to the time of issuing the
    request rather than a specific
    message.[¶](#section-a.2.1-1.13.5){.pilcrow}

    Implementation over UDP: not possible. (UDP does not offer
    authentication.)[¶](#section-a.2.1-1.13.6){.pilcrow}
    :::

-   ::: {#section-a.2.1-1.14}
    Request not to delay the acknowledgement (SACK) of a
    message[¶](#section-a.2.1-1.14.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.2.1-1.14.2){.pilcrow}

    Optimizing because only an application knows for which message it
    wants to quickly be informed about success/failure of its
    delivery.[¶](#section-a.2.1-1.14.3){.pilcrow}

    Implementation over TCP: do nothing (TCP does not offer this
    functionality, but ignoring this request from the application will
    not yield a semantically wrong
    behavior).[¶](#section-a.2.1-1.14.4){.pilcrow}

    Implementation over UDP: do nothing (UDP does not offer this
    functionality, but ignoring this request from the application will
    not yield a semantically wrong
    behavior).[¶](#section-a.2.1-1.14.5){.pilcrow}
    :::
:::
:::

::: {#data-receiving-pass3}
::: {#section-a.2.2 .section}
### [A.2.2.](#section-a.2.2){.section-number .selfRef} [Receiving Data](#name-receiving-data-3){.section-name .selfRef} {#name-receiving-data-3}

-   ::: {#section-a.2.2-1.1}
    Receive data (with no message
    delimiting)[¶](#section-a.2.2-1.1.1){.pilcrow}

    Protocols: TCP[¶](#section-a.2.2-1.1.2){.pilcrow}

    Functional because a transport system must be able to send and
    receive data.[¶](#section-a.2.2-1.1.3){.pilcrow}

    Implementation: via RECEIVE.TCP.[¶](#section-a.2.2-1.1.4){.pilcrow}

    Implementation over UDP: do nothing (UDP only works on messages;
    these can be handed over, the application can still ignore the
    message boundaries).[¶](#section-a.2.2-1.1.5){.pilcrow}
    :::

-   ::: {#section-a.2.2-1.2}
    Receive a message[¶](#section-a.2.2-1.2.1){.pilcrow}

    Protocols: SCTP, UDP(-Lite)[¶](#section-a.2.2-1.2.2){.pilcrow}

    Functional because this is closely tied to properties of the data
    that an application sends or expects to
    receive.[¶](#section-a.2.2-1.2.3){.pilcrow}

    Implementation: via RECEIVE.SCTP and
    RECEIVE.UDP(-Lite).[¶](#section-a.2.2-1.2.4){.pilcrow}

    Implementation over TCP: not possible. (TCP does not support
    identification of message
    boundaries.)[¶](#section-a.2.2-1.2.5){.pilcrow}
    :::

-   ::: {#section-a.2.2-1.3}
    Choice of stream to receive from[¶](#section-a.2.2-1.3.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.2.2-1.3.2){.pilcrow}

    Automatable because it requires using multiple streams, but
    requesting multiple streams in the CONNECTION.ESTABLISHMENT category
    is automatable.[¶](#section-a.2.2-1.3.3){.pilcrow}

    Implementation: see [Section
    5.2](#nostream){.xref}.[¶](#section-a.2.2-1.3.4){.pilcrow}
    :::

-   ::: {#section-a.2.2-1.4}
    Information about partial message
    arrival[¶](#section-a.2.2-1.4.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.2.2-1.4.2){.pilcrow}

    Functional because this is closely tied to properties of the data
    that an application sends or expects to
    receive.[¶](#section-a.2.2-1.4.3){.pilcrow}

    Implementation: via RECEIVE.SCTP.[¶](#section-a.2.2-1.4.4){.pilcrow}

    Implementation over TCP: do nothing (this information is not
    available with TCP).[¶](#section-a.2.2-1.4.5){.pilcrow}

    Implementation over UDP: do nothing (this information is not
    available with UDP).[¶](#section-a.2.2-1.4.6){.pilcrow}
    :::
:::
:::

::: {#data-errors-pass3}
::: {#section-a.2.3 .section}
### [A.2.3.](#section-a.2.3){.section-number .selfRef} [Errors](#name-errors-2){.section-name .selfRef} {#name-errors-2}

This section describes sending failures that are associated with a
specific call to in the \"Sending Data\" category ([Appendix
A.2.1](#data-sending-pass3){.xref}).[¶](#section-a.2.3-1){.pilcrow}

-   ::: {#section-a.2.3-2.1}
    Notification of send failures[¶](#section-a.2.3-2.1.1){.pilcrow}

    Protocols: SCTP, UDP(-Lite)[¶](#section-a.2.3-2.1.2){.pilcrow}

    Functional because this notifies that potentially assumed reliable
    data delivery is no longer
    provided.[¶](#section-a.2.3-2.1.3){.pilcrow}

    CHANGED FROM RFC 8303. This differs from the 2 automatable transport
    features below in that it does not distinguish between unsent and
    unacknowledged messages.[¶](#section-a.2.3-2.1.4){.pilcrow}

    Implementation: via SENDFAILURE-EVENT.SCTP and
    SEND_FAILURE.UDP(-Lite).[¶](#section-a.2.3-2.1.5){.pilcrow}

    Implementation over TCP: do nothing (this notification is not
    available and will therefore not occur with
    TCP).[¶](#section-a.2.3-2.1.6){.pilcrow}
    :::

-   ::: {#section-a.2.3-2.2}
    Notification of an unsent (part of a)
    message[¶](#section-a.2.3-2.2.1){.pilcrow}

    Protocols: SCTP, UDP(-Lite)[¶](#section-a.2.3-2.2.2){.pilcrow}

    Automatable because the distinction between unsent and
    unacknowledged does not relate to application-specific
    knowledge.[¶](#section-a.2.3-2.2.3){.pilcrow}
    :::

-   ::: {#section-a.2.3-2.3}
    Notification of an unacknowledged (part of a)
    message[¶](#section-a.2.3-2.3.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.2.3-2.3.2){.pilcrow}

    Automatable because the distinction between unsent and
    unacknowledged does not relate to application-specific
    knowledge.[¶](#section-a.2.3-2.3.3){.pilcrow}
    :::

-   ::: {#section-a.2.3-2.4}
    Notification that the stack has no more user data to
    send[¶](#section-a.2.3-2.4.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.2.3-2.4.2){.pilcrow}

    Optimizing because reacting to this notification requires the
    application to be involved, and ensuring that the stack does not run
    dry of data (for too long) can improve
    performance.[¶](#section-a.2.3-2.4.3){.pilcrow}

    Implementation over TCP: do nothing (see the discussion in [Section
    5.4](#rundry){.xref}).[¶](#section-a.2.3-2.4.4){.pilcrow}

    Implementation over UDP: do nothing (this notification is not
    available and will therefore not occur with
    UDP).[¶](#section-a.2.3-2.4.5){.pilcrow}
    :::

-   ::: {#section-a.2.3-2.5}
    Notification to a receiver that a partial message delivery has been
    aborted[¶](#section-a.2.3-2.5.1){.pilcrow}

    Protocols: SCTP[¶](#section-a.2.3-2.5.2){.pilcrow}

    Functional because this is closely tied to properties of the data
    that an application sends or expects to
    receive.[¶](#section-a.2.3-2.5.3){.pilcrow}

    Implementation over TCP: do nothing (this notification is not
    available and will therefore not occur with
    TCP).[¶](#section-a.2.3-2.5.4){.pilcrow}

    Implementation over UDP: do nothing (this notification is not
    available and will therefore not occur with
    UDP).[¶](#section-a.2.3-2.5.5){.pilcrow}
    :::
:::
:::
:::
:::
:::
:::

::: {#Acknowledgements}
::: {#section-appendix.b .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

The authors would like to thank all the participants of the TAPS Working
Group and the NEAT and MAMI research projects for valuable input to this
document. We especially thank [Michael Tüxen]{.contact-name} for help
with connection establishment/teardown, [Gorry Fairhurst]{.contact-name}
for his suggestions regarding fragmentation and packet sizes, and
[Spencer Dawkins]{.contact-name} for his extremely detailed and
constructive review. This work has received funding from the European
Union\'s Horizon 2020 research and innovation program under grant
agreement No. 644334 (NEAT).[¶](#section-appendix.b-1){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#section-appendix.c .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Michael Welzl]{.fn .nameRole}
:::

::: {.left dir="auto"}
[University of Oslo]{.org}
:::

::: {.left dir="auto"}
[PO Box 1080 Blindern]{.street-address}
:::

::: {.left dir="auto"}
[N-0316]{.postal-code} [Oslo]{.locality}
:::

::: {.left dir="auto"}
[Norway]{.country-name}
:::

::: tel
Phone: [+47 22 85 24 20](tel:+47%2022%2085%2024%2020){.tel}
:::

::: email
Email: <michawe@ifi.uio.no>
:::

::: {.left dir="auto"}
[Stein Gjessing]{.fn .nameRole}
:::

::: {.left dir="auto"}
[University of Oslo]{.org}
:::

::: {.left dir="auto"}
[PO Box 1080 Blindern]{.street-address}
:::

::: {.left dir="auto"}
[N-0316]{.postal-code} [Oslo]{.locality}
:::

::: {.left dir="auto"}
[Norway]{.country-name}
:::

::: tel
Phone: [+47 22 85 24 44](tel:+47%2022%2085%2024%2044){.tel}
:::

::: email
Email: <steing@ifi.uio.no>
:::
:::
:::
