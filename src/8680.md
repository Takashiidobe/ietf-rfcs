  RFC 8680       FEC Framework Extension   January 2020
  -------------- ------------------------- --------------
  Roca & Begen   Standards Track           \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8680](https://www.rfc-editor.org/rfc/rfc8680){.eref}

Updates:
:   [6363](https://www.rfc-editor.org/rfc/rfc6363){.eref}

Category:
:   Standards Track

Published:
:   January 2020

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    V. Roca
    :::

    ::: org
    INRIA
    :::
    :::

    ::: author
    ::: author-name
    A. Begen
    :::

    ::: org
    Networked Media
    :::
    :::
:::

# RFC 8680 {#rfcnum}

# Forward Error Correction (FEC) Framework Extension to Sliding Window Codes {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

RFC 6363 describes a framework for using Forward Error Correction (FEC)
codes to provide protection against packet loss. The framework supports
applying FEC to arbitrary packet flows over unreliable transport and is
primarily intended for real-time, or streaming, media. However, FECFRAME
as per RFC 6363 is restricted to block FEC codes. This document updates
RFC 6363 to support FEC codes based on a sliding encoding window, in
addition to block FEC codes, in a backward-compatible way. During
multicast/broadcast real-time content delivery, the use of sliding
window codes significantly improves robustness in harsh environments,
with less repair traffic and lower FEC-related added
latency.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8680>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2020 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [Definitions and
        Abbreviations](#name-definitions-and-abbreviatio){.xref}[¶](#section-toc.1-1.2.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [Requirements
        Language](#name-requirements-language){.xref}[¶](#section-toc.1-1.2.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Summary of Architecture
    Overview](#name-summary-of-architecture-ove){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Procedural
    Overview](#name-procedural-overview){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [General](#name-general){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Sender Operation with Sliding
        Window FEC
        Codes](#name-sender-operation-with-slidi){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [Receiver Operation with Sliding
        Window FEC
        Codes](#name-receiver-operation-with-sli){.xref}[¶](#section-toc.1-1.4.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [Protocol
    Specification](#name-protocol-specification){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [General](#name-general-2){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [FEC Framework Configuration
        Information](#name-fec-framework-configuration){.xref}[¶](#section-toc.1-1.5.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.xref}.  [FEC Scheme
        Requirements](#name-fec-scheme-requirements){.xref}[¶](#section-toc.1-1.5.2.3.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Feedback](#name-feedback){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Transport
    Protocols](#name-transport-protocols){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Congestion
    Control](#name-congestion-control){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [Operations and Management
    Considerations](#name-operations-and-management-c){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.12}
    [12](#section-12){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}

    -   ::: {#section-toc.1-1.12.2.1}
        [12.1](#section-12.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.12.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.12.2.2}
        [12.2](#section-12.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.12.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.13}
    [Appendix A](#section-appendix.a){.xref}.  [About Sliding Encoding
    Window Management
    (Informational)](#name-about-sliding-encoding-wind){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.14}
    [](#section-appendix.b){.xref}[Acknowledgments](#name-acknowledgments){.xref}[¶](#section-toc.1-1.14.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.15}
    [](#section-appendix.c){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}[¶](#section-toc.1-1.15.1){.pilcrow}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Many applications need to transport a continuous stream of packetized
data from a source (sender) to one or more destinations (receivers) over
networks that do not provide guaranteed packet delivery. In particular,
packets may be lost, which is strictly the focus of this document: we
assume that transmitted packets are either lost (e.g., because of a
congested router, a poor signal-to-noise ratio in a wireless network, or
because the number of bit errors exceeds the correction capabilities of
the physical-layer error-correcting code) or were received by the
transport protocol without any corruption (i.e., the bit errors, if any,
have been fixed by the physical-layer error-correcting code and
therefore are hidden to the upper layers).[¶](#section-1-1){.pilcrow}

For these use cases, Forward Error Correction (FEC) applied within the
transport or application layer is an efficient technique to improve
packet transmission robustness in the presence of packet losses (or
\"erasures\") without going through packet retransmissions that create a
delay often incompatible with real-time constraints. The FEC Building
Block defined in \[[RFC5052](#RFC5052){.xref}\] provides a framework for
the definition of Content Delivery Protocols (CDPs) that make use of
separately defined FEC schemes. Any CDP defined according to the
requirements of the FEC Building Block can then easily be used with any
FEC scheme that is also defined according to the requirements of the FEC
Building Block.[¶](#section-1-2){.pilcrow}

Then, FECFRAME \[[RFC6363](#RFC6363){.xref}\] provides a framework to
define Content Delivery Protocols (CDPs) that provide FEC protection for
arbitrary packet flows over an unreliable datagram service transport,
such as UDP. It is primarily intended for real-time or streaming media
applications that are using broadcast, multicast, or on-demand delivery.
A subset of FECFRAME is currently part of the 3GPP Evolved Multimedia
Broadcast/Multicast Service (eMBMS) standard
\[[MBMSTS](#MBMSTS){.xref}\].[¶](#section-1-3){.pilcrow}

However, \[[RFC6363](#RFC6363){.xref}\] only considers block FEC schemes
defined in accordance with the FEC Building Block
\[[RFC5052](#RFC5052){.xref}\] (e.g., \[[RFC6681](#RFC6681){.xref}\],
\[[RFC6816](#RFC6816){.xref}\], or \[[RFC6865](#RFC6865){.xref}\]).
These codes require the input flow(s) to be segmented into a sequence of
blocks. Then, FEC encoding (at a sender or an encoding middlebox) and
decoding (at a receiver or a decoding middlebox) are both performed on a
per-block basis. For instance, if the current block encompasses the
100\'s to 119\'s source symbols (i.e., a block of size 20 symbols) of an
input flow, encoding (and decoding) will be performed on this block
independently of other blocks. This approach has major impacts on FEC
encoding and decoding delays. The data packets of continuous media
flow(s) may be passed to the transport layer immediately, without delay.
But the block creation time, which depends on the number of source
symbols in this block, impacts both the FEC encoding delay (since
encoding requires that all source symbols be known) and, mechanically,
the packet loss recovery delay at a receiver (since no repair symbol for
the current block can be generated and therefore received before that
time). Therefore, a good value for the block size is necessarily a
balance between the maximum FEC decoding latency at the receivers (which
must be in line with the most stringent real-time requirement of the
protected flow(s), hence an incentive to reduce the block size) and the
desired robustness against long loss bursts (which increases with the
block size, hence an incentive to increase this
size).[¶](#section-1-4){.pilcrow}

This document updates \[[RFC6363](#RFC6363){.xref}\] in order to also
support FEC codes based on a sliding encoding window (a.k.a.,
convolutional codes) \[[RFC8406](#RFC8406){.xref}\]. This encoding
window, either fixed or variable size, slides over the set of source
symbols. FEC encoding is launched whenever needed from the set of source
symbols present in the sliding encoding window at that time. This
approach significantly reduces FEC-related latency, since repair symbols
can be generated and passed to the transport layer on the fly at any
time and can be regularly received by receivers to quickly recover
packet losses. Using sliding window FEC codes is therefore highly
beneficial to real-time flows, one of the primary targets of FECFRAME.
\[[RFC8681](#RFC8681){.xref}\] provides an example of such a FEC scheme
for FECFRAME, which is built upon the simple sliding window Random
Linear Code (RLC).[¶](#section-1-5){.pilcrow}

This document is fully backward compatible with
\[[RFC6363](#RFC6363){.xref}\]. Indeed:[¶](#section-1-6){.pilcrow}

-   [This FECFRAME update does not prevent or compromise in any way the
    support of block FEC codes. Both types of codes can nicely coexist,
    just like different block FEC schemes can
    coexist.[¶](#section-1-7.1){.pilcrow}]{#section-1-7.1}
-   [Each sliding window FEC scheme is associated with a specific FEC
    Encoding ID subject to IANA registration, just like block FEC
    schemes.[¶](#section-1-7.2){.pilcrow}]{#section-1-7.2}
-   [Any receiver \-- for instance, a legacy receiver that only supports
    block FEC schemes \-- can easily identify the FEC scheme used in a
    FECFRAME session. Indeed, the FEC Encoding ID that identifies the
    FEC scheme is carried in FEC Framework Configuration Information
    (see [Section
    5.5](https://www.rfc-editor.org/rfc/rfc6363#section-5.5){.relref} of
    \[[RFC6363](#RFC6363){.xref}\]). For instance, when the Session
    Description Protocol (SDP) is used to carry the FEC Framework
    Configuration Information, the FEC Encoding ID can be communicated
    in the \"encoding-id=\" parameter of a \"fec-repair-flow\" attribute
    \[[RFC6364](#RFC6364){.xref}\]. This mechanism is the basic approach
    for a FECFRAME receiver to determine whether or not it supports the
    FEC scheme used in a given FECFRAME
    session.[¶](#section-1-7.3){.pilcrow}]{#section-1-7.3}

This document leverages on \[[RFC6363](#RFC6363){.xref}\] and reuses its
structure. It proposes new sections specific to sliding window FEC codes
whenever required. The only exception is [Section
3](#ArchitectureOverview){.xref}, which provides a quick summary of
FECFRAME in order to facilitate the understanding of this document to
readers not familiar with the concepts and
terminology.[¶](#section-1-8){.pilcrow}
:::
:::

::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

::: {#definitionsAndAbbreviations}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Definitions and Abbreviations](#name-definitions-and-abbreviatio){.section-name .selfRef} {#name-definitions-and-abbreviatio}

The following list of definitions and abbreviations is copied from
\[[RFC6363](#RFC6363){.xref}\], adding only the Block FEC Code, Sliding
Window FEC Code, and Encoding/Decoding Window definitions (tagged with
\"ADDED\"):[¶](#section-2.1-1){.pilcrow}

Application Data Unit (ADU):
:   The unit of source data provided as a payload to the transport
    layer. For instance, it can be a payload containing the result of
    the RTP packetization of a compressed video
    frame.[¶](#section-2.1-2.2){.pilcrow}

ADU Flow:
:   A sequence of ADUs associated with a transport-layer flow identifier
    (such as the standard 5-tuple {source IP address, source port,
    destination IP address, destination port, transport
    protocol}).[¶](#section-2.1-2.4){.pilcrow}

AL-FEC:
:   Application-Layer Forward Error
    Correction.[¶](#section-2.1-2.6){.pilcrow}

Application Protocol:
:   Control protocol used to establish and control the source flow being
    protected, e.g., the Real-Time Streaming Protocol
    (RTSP).[¶](#section-2.1-2.8){.pilcrow}

Content Delivery Protocol (CDP):
:   A complete application protocol specification that, through the use
    of the framework defined in this document, is able to make use of
    FEC schemes to provide FEC
    capabilities.[¶](#section-2.1-2.10){.pilcrow}

FEC Code:
:   An algorithm for encoding data such that the encoded data flow is
    resilient to data loss. Note that, in general, FEC codes may also be
    used to make a data flow resilient to corruption, but that is not
    considered in this document.[¶](#section-2.1-2.12){.pilcrow}

Block FEC Code: (ADDED)
:   A FEC code that operates on blocks, i.e., for which the input flow
    [MUST]{.bcp14} be segmented into a sequence of blocks, with FEC
    encoding and decoding being performed independently on a per-block
    basis.[¶](#section-2.1-2.14){.pilcrow}

Sliding Window FEC Code: (ADDED)
:   A FEC code that can generate repair symbols on the fly, at any time,
    from the set of source symbols present in the sliding encoding
    window at that time. These codes are also known as convolutional
    codes.[¶](#section-2.1-2.16){.pilcrow}

FEC Framework:
:   A protocol framework for the definition of Content Delivery
    Protocols using FEC, such as the framework defined in this
    document.[¶](#section-2.1-2.18){.pilcrow}

FEC Framework Configuration Information:
:   Information that controls the operation of the FEC
    Framework.[¶](#section-2.1-2.20){.pilcrow}

FEC Payload ID:
:   Information that identifies the contents and provides positional
    information of a packet with respect to the FEC
    scheme.[¶](#section-2.1-2.22){.pilcrow}

FEC Repair Packet:
:   At a sender (respectively, at a receiver), a payload submitted to
    (respectively, received from) the transport protocol containing one
    or more repair symbols along with a Repair FEC Payload ID and
    possibly an RTP header.[¶](#section-2.1-2.24){.pilcrow}

FEC Scheme:
:   A specification that defines the additional protocol aspects
    required to use a particular FEC code with the FEC
    Framework.[¶](#section-2.1-2.26){.pilcrow}

FEC Source Packet:
:   At a sender (respectively, at a receiver), a payload submitted to
    (respectively, received from) the transport protocol containing an
    ADU along with an optional Explicit Source FEC Payload
    ID.[¶](#section-2.1-2.28){.pilcrow}

Repair Flow:
:   The packet flow carrying FEC data.[¶](#section-2.1-2.30){.pilcrow}

Repair FEC Payload ID:
:   A FEC Payload ID specifically for use with repair
    packets.[¶](#section-2.1-2.32){.pilcrow}

Source Flow:
:   The packet flow to which FEC protection is to be applied. A source
    flow consists of ADUs.[¶](#section-2.1-2.34){.pilcrow}

Source FEC Payload ID:
:   A FEC Payload ID specifically for use with source
    packets.[¶](#section-2.1-2.36){.pilcrow}

Source Protocol:
:   A protocol used for the source flow being protected, e.g.,
    RTP.[¶](#section-2.1-2.38){.pilcrow}

Transport Protocol:
:   The protocol used for the transport of the source and repair flows.
    This protocol needs to provide an unreliable datagram service, as
    UDP does (\[[RFC6363](#RFC6363){.xref}\], [Section
    7](https://www.rfc-editor.org/rfc/rfc6363#section-7){.relref}).[¶](#section-2.1-2.40){.pilcrow}

Encoding Window: (ADDED)
:   Set of source symbols available at the sender/coding node that are
    used (with a Sliding Window FEC code) to generate a repair
    symbol.[¶](#section-2.1-2.42){.pilcrow}

Decoding Window: (ADDED)
:   Set of received or decoded source and repair symbols available at a
    receiver that are used (with a Sliding Window FEC code) to decode
    lost source symbols.[¶](#section-2.1-2.44){.pilcrow}

Code Rate:
:   The ratio between the number of source symbols and the number of
    encoding symbols. By definition, the code rate is such that 0 \<
    code rate \<= 1. A code rate close to 1 indicates that a small
    number of repair symbols have been produced during the encoding
    process.[¶](#section-2.1-2.46){.pilcrow}

Encoding Symbol:
:   Unit of data generated by the encoding process. With systematic
    codes, source symbols are part of the encoding
    symbols.[¶](#section-2.1-2.48){.pilcrow}

Packet Erasure Channel:
:   A communication path where packets are either lost (e.g., in our
    case, by a congested router, or because the number of transmission
    errors exceeds the correction capabilities of the physical-layer
    code) or received. When a packet is received, it is assumed that
    this packet is not corrupted (i.e., in our case, the bit errors, if
    any, are fixed by the physical-layer code and are therefore hidden
    to the upper layers).[¶](#section-2.1-2.50){.pilcrow}

Repair Symbol:
:   Encoding symbol that is not a source
    symbol.[¶](#section-2.1-2.52){.pilcrow}

Source Block:
:   Group of ADUs that are to be FEC protected as a single block. This
    notion is restricted to Block FEC
    codes.[¶](#section-2.1-2.54){.pilcrow}

Source Symbol:
:   Unit of data used during the encoding
    process.[¶](#section-2.1-2.56){.pilcrow}

Systematic Code:
:   FEC code in which the source symbols are part of the encoding
    symbols.[¶](#section-2.1-2.58){.pilcrow}
:::
:::

::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [Requirements Language](#name-requirements-language){.section-name .selfRef} {#name-requirements-language}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2.2-1){.pilcrow}
:::
:::

::: {#ArchitectureOverview}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Summary of Architecture Overview](#name-summary-of-architecture-ove){.section-name .selfRef} {#name-summary-of-architecture-ove}

The architecture of [Section
3](https://www.rfc-editor.org/rfc/rfc6363#section-3){.relref} of
\[[RFC6363](#RFC6363){.xref}\] equally applies to this FECFRAME
extension and is not repeated here. However, this section includes a
quick summary to facilitate the understanding of this document to
readers not familiar with the concepts and
terminology.[¶](#section-3-1){.pilcrow}

[]{#name-fecframe-architecture-at-a-}

::: {#fig_archi}
::: {#section-3-2.1 .artwork .art-text .alignLeft}
    +----------------------+
    |     Application      |
    +----------------------+
               |
               | (1) Application Data Units (ADUs)
               |
               v
    +----------------------+                           +----------------+
    |    FEC Framework     |                           |                |
    |                      |-------------------------->|   FEC Scheme   |
    |(2) Construct source  |(3) Source Block           |                |
    |    blocks            |                           |(4) FEC Encoding|
    |(6) Construct FEC     |<--------------------------|                |
    |    Source and Repair |                           |                |
    |    Packets           |(5) Explicit Source FEC    |                |
    +----------------------+    Payload IDs            +----------------+
               |                Repair FEC Payload IDs
               |                Repair symbols
               |
               |(7) FEC Source and Repair Packets
               v
    +----------------------+
    |  Transport Protocol  |
    +----------------------+
:::

[Figure 1](#figure-1){.selfRef}: [FECFRAME Architecture at a
Sender](#name-fecframe-architecture-at-a-){.selfRef}
:::

The FECFRAME architecture is illustrated in [Figure
1](#fig_archi){.xref} for a block FEC scheme from the sender\'s point of
view. It shows an application generating an ADU flow (other flows from
other applications may coexist). These ADUs of variable size must be
somehow mapped to source symbols of a fixed size (this fixed size is a
requirement of all FEC schemes, which comes from the way mathematical
operations are applied to the symbols\' content). This is the goal of an
ADU-to-symbols mapping process that is FEC scheme specific (see below).
Once the source block is built, taking into account both the FEC scheme
constraints (e.g., in terms of maximum source block size) and the
application\'s flow constraints (e.g., in terms of real-time
constraints), the associated source symbols are handed to the FEC scheme
in order to produce an appropriate number of repair symbols. FEC Source
Packets (containing ADUs) and FEC Repair Packets (containing one or more
repair symbols each) are then generated and sent using an appropriate
transport protocol (more precisely, [Section
7](https://www.rfc-editor.org/rfc/rfc6363#section-7){.relref} of
\[[RFC6363](#RFC6363){.xref}\] requires a transport protocol providing
an unreliable datagram service, such as UDP). In practice, FEC Source
Packets may be passed to the transport layer as soon as available
without having to wait for FEC encoding to take place. In that case, a
copy of the associated source symbols needs to be kept within FECFRAME
for future FEC encoding purposes.[¶](#section-3-3){.pilcrow}

At a receiver (not shown), FECFRAME processing operates in a similar
way, taking as input the incoming FEC Source and Repair Packets
received. In case of FEC Source Packet losses, the FEC decoding of the
associated block may recover all (in case of successful decoding) or a
subset that is potentially empty (if decoding fails) of the missing
source symbols. After source-symbol-to-ADU mapping, when lost ADUs are
recovered, they are then assigned to their respective flow (see below).
ADUs are returned to the application(s), either in their initial
transmission order (in which case all ADUs received after a lost ADU
will be delayed until FEC decoding has taken place) or not (in which
case each ADU is returned as soon as it is received or recovered),
depending on the application requirements.[¶](#section-3-4){.pilcrow}

FECFRAME features two subtle mechanisms whose details are FEC scheme
dependent:[¶](#section-3-5){.pilcrow}

-   [ADUs-to-source-symbols mapping: in order to manage variable size
    ADUs, FECFRAME and FEC schemes can use small, fixed-size symbols and
    create a mapping between ADUs and symbols. The mapping details are
    FEC scheme dependent and must be defined in the associated document.
    For instance, with certain FEC schemes, to each ADU, this mechanism
    prepends a length field (plus a flow identifier; see below) and pads
    the result to a multiple of the symbol size. A small ADU may be
    mapped to a single source symbol, while a large one may be mapped to
    multiple symbols.[¶](#section-3-6.1){.pilcrow}]{#section-3-6.1}
-   [Assignment of decoded ADUs to flows in multi-flow configurations:
    when multiple flows are multiplexed over the same FECFRAME instance,
    a problem is to assign a decoded ADU to the right flow (UDP port
    numbers and IP addresses traditionally used to map incoming ADUs to
    flows are not recovered during FEC decoding). The mapping details
    are FEC scheme dependent and must be defined in the associated
    document. For instance, with certain FEC schemes, to make it
    possible, at the FECFRAME sending instance, each ADU is prepended
    with a flow identifier (1 byte) during the ADU-to-source-symbols
    mapping (see above). The flow identifiers are also shared between
    all FECFRAME instances as part of the FEC Framework Configuration
    Information. The ADU Information (ADUI), which includes the flow
    identifier, length, application payload, and padding, is then FEC
    protected. Therefore, a decoded ADUI contains enough information to
    assign the ADU to the right flow. Note that a FEC scheme may also be
    restricted to the particular case of a single flow over a FECFRAME
    instance; that would make the above mechanism
    pointless.[¶](#section-3-6.2){.pilcrow}]{#section-3-6.2}

A few aspects are not covered by FECFRAME,
namely:[¶](#section-3-7){.pilcrow}

-   [[Section
    8](https://www.rfc-editor.org/rfc/rfc6363#section-8){.relref} of
    \[[RFC6363](#RFC6363){.xref}\] does not detail any congestion
    control mechanisms and only provides high-level normative
    requirements.[¶](#section-3-8.1){.pilcrow}]{#section-3-8.1}
-   [The possibility of having feedback from receiver(s) is considered
    out of scope, although such a mechanism may exist within the
    application (e.g., through RTP Control Protocol (RTCP)
    messages).[¶](#section-3-8.2){.pilcrow}]{#section-3-8.2}
-   [Flow adaptation at a FECFRAME sender (e.g., how to set the FEC code
    rate based on transmission conditions) is not detailed, but it needs
    to comply with the congestion control normative requirements (see
    above).[¶](#section-3-8.3){.pilcrow}]{#section-3-8.3}
:::
:::

::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Procedural Overview](#name-procedural-overview){.section-name .selfRef} {#name-procedural-overview}

::: {#generalProceduralOverview}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [General](#name-general){.section-name .selfRef} {#name-general}

The general considerations of [Section
4.1](https://www.rfc-editor.org/rfc/rfc6363#section-4.1){.relref} of
\[[RFC6363](#RFC6363){.xref}\] that are specific to block FEC codes are
not repeated here.[¶](#section-4.1-1){.pilcrow}

With a Sliding Window FEC code, the FEC Source Packet [MUST]{.bcp14}
contain information to identify the position occupied by the ADU within
the source flow in terms specific to the FEC scheme. This information is
known as the Source FEC Payload ID, and the FEC scheme is responsible
for defining and interpreting it.[¶](#section-4.1-2){.pilcrow}

With a Sliding Window FEC code, the FEC Repair Packets [MUST]{.bcp14}
contain information that identifies the relationship between the
contained repair payloads and the original source symbols used during
encoding. This information is known as the Repair FEC Payload ID, and
the FEC scheme is responsible for defining and interpreting
it.[¶](#section-4.1-3){.pilcrow}

The sender operation (\[[RFC6363](#RFC6363){.xref}\], [Section
4.2](https://www.rfc-editor.org/rfc/rfc6363#section-4.2){.relref}) and
receiver operation (\[[RFC6363](#RFC6363){.xref}\], [Section
4.3](https://www.rfc-editor.org/rfc/rfc6363#section-4.3){.relref}) are
both specific to block FEC codes and are therefore omitted below. The
following two sections detail similar operations for Sliding Window FEC
codes.[¶](#section-4.1-4){.pilcrow}
:::
:::

::: {#senderoperation-convolutional}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Sender Operation with Sliding Window FEC Codes](#name-sender-operation-with-slidi){.section-name .selfRef} {#name-sender-operation-with-slidi}

With a Sliding Window FEC scheme, the following operations, illustrated
in [Figure 2](#senderfigure-convolutional){.xref} for the generic case
(non-RTP repair flows) and in [Figure
3](#senderfigurertp-convolutional){.xref} for the case of RTP repair
flows, describe a possible way to generate compliant source and repair
flows:[¶](#section-4.2-1){.pilcrow}

1.  [A new ADU is provided by the
    application.[¶](#section-4.2-2.1){.pilcrow}]{#section-4.2-2.1}
2.  [The FEC Framework communicates this ADU to the FEC
    scheme.[¶](#section-4.2-2.2){.pilcrow}]{#section-4.2-2.2}
3.  [The sliding encoding window is updated by the FEC scheme. The
    ADU-to-source-symbol mapping as well as the encoding window
    management details are both the responsibility of the FEC scheme and
    [MUST]{.bcp14} be detailed there. [Appendix
    A](#codingwindow-possibleManagement){.xref} provides non-normative
    hints about what FEC scheme designers need to
    consider.[¶](#section-4.2-2.3){.pilcrow}]{#section-4.2-2.3}
4.  [The Source FEC Payload ID information of the source packet is
    determined by the FEC scheme. If required by the FEC scheme, the
    Source FEC Payload ID is encoded into the Explicit Source FEC
    Payload ID field and returned to the FEC
    Framework.[¶](#section-4.2-2.4){.pilcrow}]{#section-4.2-2.4}
5.  [The FEC Framework constructs the FEC Source Packet according to
    Figure 6 in \[[RFC6363](#RFC6363){.xref}\], using the Explicit
    Source FEC Payload ID provided by the FEC scheme if
    applicable.[¶](#section-4.2-2.5){.pilcrow}]{#section-4.2-2.5}
6.  [The FEC Source Packet is sent using normal transport-layer
    procedures. This packet is sent using the same ADU flow
    identification information as would have been used for the original
    source packet if the FEC Framework were not present (e.g., the
    source and destination addresses and UDP port numbers on the IP
    datagram carrying the source packet will be the same whether or not
    the FEC Framework is
    applied).[¶](#section-4.2-2.6){.pilcrow}]{#section-4.2-2.6}
7.  [When the FEC Framework needs to send one or several FEC Repair
    Packets (e.g., according to the target code rate), it asks the FEC
    scheme to create one or several repair packet payloads from the
    current sliding encoding window along with their Repair FEC Payload
    ID.[¶](#section-4.2-2.7){.pilcrow}]{#section-4.2-2.7}
8.  [The Repair FEC Payload IDs and repair packet payloads are provided
    back by the FEC scheme to the FEC
    Framework.[¶](#section-4.2-2.8){.pilcrow}]{#section-4.2-2.8}
9.  [The FEC Framework constructs FEC Repair Packets according to Figure
    7 in \[[RFC6363](#RFC6363){.xref}\], using the FEC Payload IDs and
    repair packet payloads provided by the FEC
    scheme.[¶](#section-4.2-2.9){.pilcrow}]{#section-4.2-2.9}
10. [The FEC Repair Packets are sent using normal transport-layer
    procedures. The port(s) and multicast group(s) to be used for FEC
    Repair Packets are defined in the FEC Framework Configuration
    Information.[¶](#section-4.2-2.10){.pilcrow}]{#section-4.2-2.10}

[]{#name-sender-operation-with-slidin}

::: {#senderfigure-convolutional}
::: {#section-4.2-3.1 .artwork .art-text .alignLeft}
    +----------------------+
    |     Application      |
    +----------------------+
               |
               | (1) New Application Data Unit (ADU)
               v 
    +---------------------+                           +----------------+
    |    FEC Framework    |                           |   FEC Scheme   |
    |                     |-------------------------->|                |
    |                     | (2) New ADU               |(3) Update of   |
    |                     |                           |    encoding    |
    |                     |<--------------------------|    window      |
    |(5) Construct FEC    | (4) Explicit Source       |                |
    |    Source Packet    |     FEC Payload ID(s)     |(7) FEC         |
    |                     |<--------------------------|    encoding    |
    |(9) Construct FEC    | (8) Repair FEC Payload ID |                |
    |    Repair Packet(s) |     + Repair symbol(s)    +----------------+
    +---------------------+ 
               | 
               | (6)  FEC Source Packet 
               | (10) FEC Repair Packets
               v 
    +----------------------+ 
    |  Transport Protocol  |
    +----------------------+ 
:::

[Figure 2](#figure-2){.selfRef}: [Sender Operation with Sliding Window
FEC Codes](#name-sender-operation-with-slidin){.selfRef}
:::

[]{#name-sender-operation-with-sliding}

::: {#senderfigurertp-convolutional}
::: {#section-4.2-4.1 .artwork .art-text .alignLeft}
    +----------------------+
    |     Application      |
    +----------------------+
               |
               | (1) New Application Data Unit (ADU)
               v 
    +---------------------+                           +----------------+
    |    FEC Framework    |                           |   FEC Scheme   |
    |                     |-------------------------->|                |
    |                     | (2) New ADU               |(3) Update of   |
    |                     |                           |    encoding    |
    |                     |<--------------------------|    window      |
    |(5) Construct FEC    | (4) Explicit Source       |                |
    |    Source Packet    |     FEC Payload ID(s)     |(7) FEC         |
    |                     |<--------------------------|    encoding    |
    |(9) Construct FEC    | (8) Repair FEC Payload ID |                |
    |    Repair Packet(s) |     + Repair symbol(s)    +----------------+
    +---------------------+
        |             |
        |(6) Source   |(10) Repair payloads
        |    packets  |
        |      + -- -- -- -- -+
        |      |     RTP      |
        |      +-- -- -- -- --+
        v             v                 
    +----------------------+ 
    |  Transport Protocol  |
    +----------------------+ 
:::

[Figure 3](#figure-3){.selfRef}: [Sender Operation with Sliding Window
FEC Codes and RTP Repair
Flows](#name-sender-operation-with-sliding){.selfRef}
:::
:::
:::

::: {#receiveroperation-convolutional}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Receiver Operation with Sliding Window FEC Codes](#name-receiver-operation-with-sli){.section-name .selfRef} {#name-receiver-operation-with-sli}

With a Sliding Window FEC scheme, the following operations are
illustrated in [Figure 4](#receiverfigure){.xref} for the generic case
(non-RTP repair flows) and in [Figure 5](#receiverfigurertp){.xref} for
the case of RTP repair flows. The only differences with respect to block
FEC codes lie in steps (4) and (5). Therefore, this section does not
repeat the other steps of [Section
4.3](https://www.rfc-editor.org/rfc/rfc6363#section-4.3){.relref} of
\[[RFC6363](#RFC6363){.xref}\] (\"Receiver Operation\"). The new steps
(4) and (5) are:[¶](#section-4.3-1){.pilcrow}

4.  [The FEC scheme uses the received FEC Payload IDs (and derived FEC
    Source Payload IDs when the Explicit Source FEC Payload ID field is
    not used) to insert source and repair packets into the decoding
    window in the right way. If at least one source packet is missing
    and at least one repair packet has been received, then FEC decoding
    is attempted to recover the missing source payloads. The FEC scheme
    determines whether source packets have been lost and whether enough
    repair packets have been received to decode any or all of the
    missing source
    payloads.[¶](#section-4.3-2.1){.pilcrow}]{#section-4.3-2.1}
5.  [The FEC scheme returns the received and decoded ADUs to the FEC
    Framework, along with indications of any ADUs that were missing and
    could not be
    decoded.[¶](#section-4.3-2.2){.pilcrow}]{#section-4.3-2.2}

[]{#name-receiver-operation-with-slid}

::: {#receiverfigure}
::: {#section-4.3-3.1 .artwork .art-text .alignLeft}
    +----------------------+
    |     Application      |
    +----------------------+
               ^
               |(6) ADUs
               |
    +----------------------+                           +----------------+
    |    FEC Framework     |                           |   FEC Scheme   |
    |                      |<--------------------------|                |
    |(2)Extract FEC Payload|(5) ADUs                   |(4) FEC Decoding|
    |   IDs and pass IDs & |-------------------------->|                |
    |   payloads to FEC    |(3) Explicit Source FEC    +----------------+
    |   scheme             |            Payload IDs
    +----------------------+    Repair FEC Payload IDs
               ^                Source payloads       
               |                Repair payloads
               |(1) FEC Source
               |    and Repair Packets
    +----------------------+ 
    |  Transport Protocol  |
    +----------------------+
:::

[Figure 4](#figure-4){.selfRef}: [Receiver Operation with Sliding Window
FEC Codes](#name-receiver-operation-with-slid){.selfRef}
:::

[]{#name-receiver-operation-with-slidi}

::: {#receiverfigurertp}
::: {#section-4.3-4.1 .artwork .art-text .alignLeft}
    +----------------------+
    |     Application      |
    +----------------------+
               ^
               |(6) ADUs
               |
    +----------------------+                           +----------------+
    |    FEC Framework     |                           |   FEC Scheme   |
    |                      |<--------------------------|                |
    |(2)Extract FEC Payload|(5) ADUs                   |(4) FEC Decoding|
    |   IDs and pass IDs & |-------------------------->|                |
    |   payloads to FEC    |(3) Explicit Source FEC    +----------------+
    |   scheme             |            Payload IDs
    +----------------------+    Repair FEC Payload IDs
        ^             ^         Source payloads
        |             |         Repair payloads
        |Source pkts  |Repair payloads
        |             |
    +-- |- -- -- -- -- -- -+
    |RTP| | RTP Processing | 
    |   | +-- -- -- --|-- -+
    | +-- -- -- -- -- |--+ |
    | | RTP Demux        | |
    +-- -- -- -- -- -- -- -+ 
               ^
               |(1) FEC Source and Repair Packets
               |         
    +----------------------+ 
    |  Transport Protocol  |
    +----------------------+
:::

[Figure 5](#figure-5){.selfRef}: [Receiver Operation with Sliding Window
FEC Codes and RTP Repair
Flows](#name-receiver-operation-with-slidi){.selfRef}
:::
:::
:::
:::

::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [Protocol Specification](#name-protocol-specification){.section-name .selfRef} {#name-protocol-specification}

::: {#generalProtocolSpecification}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [General](#name-general-2){.section-name .selfRef} {#name-general-2}

This section discusses the protocol elements for the FEC Framework
specific to Sliding Window FEC schemes. The global formats of source
data packets (i.e., \[[RFC6363](#RFC6363){.xref}\], Figure 6) and repair
data packets (i.e., \[[RFC6363](#RFC6363){.xref}\], Figures 7 and 8)
remain the same with Sliding Window FEC codes. They are not repeated
here.[¶](#section-5.1-1){.pilcrow}
:::
:::

::: {#config}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [FEC Framework Configuration Information](#name-fec-framework-configuration){.section-name .selfRef} {#name-fec-framework-configuration}

The FEC Framework Configuration Information considerations of [Section
5.5](https://www.rfc-editor.org/rfc/rfc6363#section-5.5){.relref} of
\[[RFC6363](#RFC6363){.xref}\] equally apply to this FECFRAME extension
and are not repeated here.[¶](#section-5.2-1){.pilcrow}
:::
:::

::: {#fecscheme}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [FEC Scheme Requirements](#name-fec-scheme-requirements){.section-name .selfRef} {#name-fec-scheme-requirements}

The FEC scheme requirements of [Section
5.6](https://www.rfc-editor.org/rfc/rfc6363#section-5.6){.relref} of
\[[RFC6363](#RFC6363){.xref}\] mostly apply to this FECFRAME extension
and are not repeated here. An exception, though, is the \"full
specification of the FEC code\", item (4), which is specific to block
FEC codes. In case of a Sliding Window FEC scheme, then the following
item (4-bis) applies:[¶](#section-5.3-1){.pilcrow}

4-bis.

:   A full specification of the Sliding Window FEC
    code.[¶](#section-5.3-2.2.1){.pilcrow}

    This specification [MUST]{.bcp14} precisely define the valid
    FEC-Scheme-Specific Information values, the valid FEC Payload ID
    values, and the valid packet payload sizes (where \"packet payload\"
    refers to the space within a packet dedicated to carrying encoding
    symbols).[¶](#section-5.3-2.2.2){.pilcrow}

    Furthermore, given valid values of the FEC-Scheme-Specific
    Information, a valid Repair FEC Payload ID value, a valid packet
    payload size, and a valid encoding window (i.e., a set of source
    symbols), the specification [MUST]{.bcp14} uniquely define the
    values of the encoding symbol (or symbols) to be included in the
    repair packet payload with the given Repair FEC Payload ID
    value.[¶](#section-5.3-2.2.3){.pilcrow}

Additionally, the FEC scheme associated with a Sliding Window FEC
code:[¶](#section-5.3-3){.pilcrow}

-   [[MUST]{.bcp14} define the relationships between ADUs and the
    associated source symbols
    (mapping).[¶](#section-5.3-4.1){.pilcrow}]{#section-5.3-4.1}
-   [[MUST]{.bcp14} define the management of the encoding window that
    slides over the set of ADUs. [Appendix
    A](#codingwindow-possibleManagement){.xref} provides non-normative
    hints about what FEC scheme designers need to
    consider.[¶](#section-5.3-4.2){.pilcrow}]{#section-5.3-4.2}
-   [[MUST]{.bcp14} define the management of the decoding window. This
    usually consists of managing a system of linear equations (for a
    linear FEC code).[¶](#section-5.3-4.3){.pilcrow}]{#section-5.3-4.3}
:::
:::
:::

::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Feedback](#name-feedback){.section-name .selfRef} {#name-feedback}

The discussion in [Section
6](https://www.rfc-editor.org/rfc/rfc6363#section-6){.relref} of
\[[RFC6363](#RFC6363){.xref}\] equally applies to this FECFRAME
extension and is not repeated here.[¶](#section-6-1){.pilcrow}
:::

::: {#TransportProtocols}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Transport Protocols](#name-transport-protocols){.section-name .selfRef} {#name-transport-protocols}

The discussion in [Section
7](https://www.rfc-editor.org/rfc/rfc6363#section-7){.relref} of
\[[RFC6363](#RFC6363){.xref}\] equally applies to this FECFRAME
extension and is not repeated here.[¶](#section-7-1){.pilcrow}
:::
:::

::: {#sec_congestion}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Congestion Control](#name-congestion-control){.section-name .selfRef} {#name-congestion-control}

The discussion in [Section
8](https://www.rfc-editor.org/rfc/rfc6363#section-8){.relref} of
\[[RFC6363](#RFC6363){.xref}\] equally applies to this FECFRAME
extension and is not repeated here.[¶](#section-8-1){.pilcrow}
:::
:::

::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

This FECFRAME extension does not add any new security considerations.
All the considerations of [Section
9](https://www.rfc-editor.org/rfc/rfc6363#section-9){.relref} of
\[[RFC6363](#RFC6363){.xref}\] apply to this document as well. However,
for the sake of completeness, the following goal can be added to the
list provided in [Section
9.1](https://www.rfc-editor.org/rfc/rfc6363#section-9.1){.relref} of
\[[RFC6363](#RFC6363){.xref}\] (\"Problem
Statement\"):[¶](#section-9-1){.pilcrow}

-   [Attacks can try to corrupt source flows in order to modify the
    receiver application\'s behavior (as opposed to just denying
    service).[¶](#section-9-2.1){.pilcrow}]{#section-9-2.1}
:::

::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [Operations and Management Considerations](#name-operations-and-management-c){.section-name .selfRef} {#name-operations-and-management-c}

This FECFRAME extension does not add any new Operations and Management
Considerations. All the considerations of [Section
10](https://www.rfc-editor.org/rfc/rfc6363#section-10){.relref} of
\[[RFC6363](#RFC6363){.xref}\] apply to this document as
well.[¶](#section-10-1){.pilcrow}
:::

::: {#iana}
::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-11-1){.pilcrow}

A FEC scheme for use with this FEC Framework is identified via its FEC
Encoding ID. It is subject to IANA registration in the \"FEC Framework
(FECFRAME) FEC Encoding IDs\" registry. All the rules of [Section
11](https://www.rfc-editor.org/rfc/rfc6363#section-11){.relref} of
\[[RFC6363](#RFC6363){.xref}\] apply and are not repeated
here.[¶](#section-11-2){.pilcrow}
:::
:::

::: {#section-12 .section}
## [12.](#section-12){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-12.1 .section}
### [12.1.](#section-12.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.

\[RFC6363\]
:   [Watson, M.]{.refAuthor}[, Begen, A.]{.refAuthor}[, and V.
    Roca]{.refAuthor}, [\"Forward Error Correction (FEC)
    Framework\"]{.refTitle}, [RFC 6363]{.seriesInfo}, [DOI
    10.17487/RFC6363]{.seriesInfo}, October 2011,
    \<<https://www.rfc-editor.org/info/rfc6363>\>.

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:::

::: {#section-12.2 .section}
### [12.2.](#section-12.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[MBMSTS\]
:   [3GPP]{.refAuthor}, [\"Multimedia Broadcast/Multicast Service
    (MBMS); Protocols and codecs\"]{.refTitle}, [3GPP TS
    26.346]{.seriesInfo}, March 2009,
    \<<http://ftp.3gpp.org/specs/html-info/26346.htm>\>.

\[RFC5052\]
:   [Watson, M.]{.refAuthor}[, Luby, M.]{.refAuthor}[, and L.
    Vicisano]{.refAuthor}, [\"Forward Error Correction (FEC) Building
    Block\"]{.refTitle}, [RFC 5052]{.seriesInfo}, [DOI
    10.17487/RFC5052]{.seriesInfo}, August 2007,
    \<<https://www.rfc-editor.org/info/rfc5052>\>.

\[RFC6364\]
:   [Begen, A.]{.refAuthor}, [\"Session Description Protocol Elements
    for the Forward Error Correction (FEC) Framework\"]{.refTitle}, [RFC
    6364]{.seriesInfo}, [DOI 10.17487/RFC6364]{.seriesInfo}, October
    2011, \<<https://www.rfc-editor.org/info/rfc6364>\>.

\[RFC6681\]
:   [Watson, M.]{.refAuthor}[, Stockhammer, T.]{.refAuthor}[, and M.
    Luby]{.refAuthor}, [\"Raptor Forward Error Correction (FEC) Schemes
    for FECFRAME\"]{.refTitle}, [RFC 6681]{.seriesInfo}, [DOI
    10.17487/RFC6681]{.seriesInfo}, August 2012,
    \<<https://www.rfc-editor.org/info/rfc6681>\>.

\[RFC6816\]
:   [Roca, V.]{.refAuthor}[, Cunche, M.]{.refAuthor}[, and J.
    Lacan]{.refAuthor}, [\"Simple Low-Density Parity Check (LDPC)
    Staircase Forward Error Correction (FEC) Scheme for
    FECFRAME\"]{.refTitle}, [RFC 6816]{.seriesInfo}, [DOI
    10.17487/RFC6816]{.seriesInfo}, December 2012,
    \<<https://www.rfc-editor.org/info/rfc6816>\>.

\[RFC6865\]
:   [Roca, V.]{.refAuthor}[, Cunche, M.]{.refAuthor}[,
    Lacan, J.]{.refAuthor}[, Bouabdallah, A.]{.refAuthor}[, and K.
    Matsuzono]{.refAuthor}, [\"Simple Reed-Solomon Forward Error
    Correction (FEC) Scheme for FECFRAME\"]{.refTitle}, [RFC
    6865]{.seriesInfo}, [DOI 10.17487/RFC6865]{.seriesInfo}, February
    2013, \<<https://www.rfc-editor.org/info/rfc6865>\>.

\[RFC8406\]
:   [Adamson, B.]{.refAuthor}[, Adjih, C.]{.refAuthor}[,
    Bilbao, J.]{.refAuthor}[, Firoiu, V.]{.refAuthor}[,
    Fitzek, F.]{.refAuthor}[, Ghanem, S.]{.refAuthor}[,
    Lochin, E.]{.refAuthor}[, Masucci, A.]{.refAuthor}[, Montpetit,
    M-J.]{.refAuthor}[, Pedersen, M.]{.refAuthor}[,
    Peralta, G.]{.refAuthor}[, Roca, V., Ed.]{.refAuthor}[,
    Saxena, P.]{.refAuthor}[, and S. Sivakumar]{.refAuthor}, [\"Taxonomy
    of Coding Techniques for Efficient Network
    Communications\"]{.refTitle}, [RFC 8406]{.seriesInfo}, [DOI
    10.17487/RFC8406]{.seriesInfo}, June 2018,
    \<<https://www.rfc-editor.org/info/rfc8406>\>.

\[RFC8681\]
:   [Roca, V.]{.refAuthor}[ and B. Teibi]{.refAuthor}, [\"Sliding Window
    Random Linear Code (RLC) Forward Erasure Correction (FEC) Schemes
    for FECFRAME\"]{.refTitle}, [RFC 8681]{.seriesInfo}, [DOI
    10.17487/RFC8681]{.seriesInfo}, January 2020,
    \<<https://www.rfc-editor.org/info/rfc8681>\>.
:::
:::

::: {#codingwindow-possibleManagement}
::: {#section-appendix.a .section}
## [Appendix A.](#section-appendix.a){.section-number .selfRef} [About Sliding Encoding Window Management (Informational)](#name-about-sliding-encoding-wind){.section-name .selfRef} {#name-about-sliding-encoding-wind}

The FEC Framework does not specify the management of the sliding
encoding window, which is the responsibility of the FEC scheme. This
annex only provides a few informational
hints.[¶](#section-appendix.a-1){.pilcrow}

Source symbols are added to the sliding encoding window each time a new
ADU is available at the sender after the ADU-to-source-symbol mapping
specific to the FEC scheme has been
done.[¶](#section-appendix.a-2){.pilcrow}

Source symbols are removed from the sliding encoding window. For
instance:[¶](#section-appendix.a-3){.pilcrow}

-   [After a certain delay, when an \"old\" ADU of a real-time flow
    times out. The source symbol retention delay in the sliding encoding
    window should therefore be initialized according to the real-time
    features of incoming flow(s) when
    applicable.[¶](#section-appendix.a-4.1){.pilcrow}]{#section-appendix.a-4.1}
-   [Once the sliding encoding window has reached its maximum size
    (there is usually an upper limit to the sliding encoding window
    size). In that case, the oldest symbol is removed each time a new
    source symbol is
    added.[¶](#section-appendix.a-4.2){.pilcrow}]{#section-appendix.a-4.2}

Several considerations can impact the management of this sliding
encoding window:[¶](#section-appendix.a-5){.pilcrow}

-   [At the source flows level: real-time constraints can limit the
    total time during which source symbols can remain in the encoding
    window.[¶](#section-appendix.a-6.1){.pilcrow}]{#section-appendix.a-6.1}
-   [At the FEC code level: theoretical or practical limitations (e.g.,
    because of computational complexity) can limit the number of source
    symbols in the encoding
    window.[¶](#section-appendix.a-6.2){.pilcrow}]{#section-appendix.a-6.2}
-   [At the FEC scheme level: signaling and window management are
    intrinsically related. For instance, an encoding window composed of
    a nonsequential set of source symbols requires appropriate signaling
    to inform a receiver of the composition of the encoding window, and
    the associated transmission overhead can limit the maximum encoding
    window size. On the contrary, an encoding window always composed of
    a sequential set of source symbols simplifies signaling: providing
    the identity of the first source symbol plus its number is
    sufficient, which creates a fixed and relatively small transmission
    overhead.[¶](#section-appendix.a-6.3){.pilcrow}]{#section-appendix.a-6.3}
:::
:::

::: {#section-appendix.b .section}
## [Acknowledgments](#name-acknowledgments){.section-name .selfRef} {#name-acknowledgments}

The authors would like to thank Christer Holmberg, David Black, Gorry
Fairhurst, Emmanuel Lochin, Spencer Dawkins, Ben Campbell, Benjamin
Kaduk, Eric Rescorla, Adam Roach, and Greg Skinner for their valuable
feedback on this document. This document being an extension of
\[[RFC6363](#RFC6363){.xref}\], the authors would also like to thank
Mark Watson as the main author of that
RFC.[¶](#section-appendix.b-1){.pilcrow}
:::

::: {#authors-addresses}
::: {#section-appendix.c .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Vincent Roca]{.fn .nameRole}
:::

::: {.left dir="auto"}
[INRIA]{.org}
:::

::: {.left dir="auto"}
[Univ. Grenoble Alpes]{.extended-address}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <vincent.roca@inria.fr>
:::

::: {.left dir="auto"}
[Ali Begen]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Networked Media]{.org}
:::

::: {.left dir="auto"}
[Konya]{.locality}/
:::

::: {.left dir="auto"}
[Turkey]{.country-name}
:::

::: email
Email: <ali.begen@networked.media>
:::
:::
:::
