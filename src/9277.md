  RFC 9277               cbor-file-magic   August 2022
  ---------------------- ----------------- -------------
  Richardson & Bormann   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9277](https://www.rfc-editor.org/rfc/rfc9277){.eref}

Category:
:   Standards Track

Published:
:   August 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    M. Richardson
    :::

    ::: org
    Sandelman Software Works
    :::
    :::

    ::: author
    ::: author-name
    C. Bormann
    :::

    ::: org
    Universität Bremen TZI
    :::
    :::
:::

# RFC 9277 {#rfcnum}

# On Stable Storage for Items in Concise Binary Object Representation (CBOR) {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document defines a stored (\"file\") format for Concise Binary
Object Representation (CBOR) data items that is friendly to common
systems that recognize file types, such as the Unix file(1)
command.[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9277>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}

    -   ::: {#section-toc.1-1.1.2.1}
        [1.1](#section-1.1){.xref}.  [Terminology](#name-terminology){.xref}
        :::

    -   ::: {#section-toc.1-1.1.2.2}
        [1.2](#section-1.2){.xref}.  [Requirements for a Magic
        Number](#name-requirements-for-a-magic-nu){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Protocol](#name-protocol){.xref}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.xref}.  [The CBOR-Protocol-Specific
        Tag](#name-the-cbor-protocol-specific-){.xref}
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.xref}.  [Enveloping Method: CBOR Tag
        Wrapped](#name-enveloping-method-cbor-tag-){.xref}

        -   ::: {#section-toc.1-1.2.2.2.2.1}
            [2.2.1](#section-2.2.1){.xref}.  [Example](#name-example){.xref}
            :::
        :::

    -   ::: {#section-toc.1-1.2.2.3}
        [2.3](#section-2.3){.xref}.  [Enveloping Method: Labeled CBOR
        Sequence](#name-enveloping-method-labeled-c){.xref}

        -   ::: {#section-toc.1-1.2.2.3.2.1}
            [2.3.1](#section-2.3.1){.xref}.  [Example](#name-example-2){.xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [IANA
    Considerations](#name-iana-considerations){.xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Labeled CBOR Sequence
        Tag](#name-labeled-cbor-sequence-tag){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [CBOR-Labeled Non-CBOR Data
        Tag](#name-cbor-labeled-non-cbor-data-){.xref}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [CBOR Tags for CoAP Content-Format
        Numbers](#name-cbor-tags-for-coap-content-){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [References](#name-references){.xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Normative
        References](#name-normative-references){.xref}
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.xref}.  [Informative
        References](#name-informative-references){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [Appendix A](#appendix-A){.xref}.  [Advice to Protocol
    Designer](#name-advice-to-protocol-designer){.xref}

    -   ::: {#section-toc.1-1.6.2.1}
        [A.1](#appendix-A.1){.xref}.  [Is the on-wire format
        new?](#name-is-the-on-wire-format-new){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [A.2](#appendix-A.2){.xref}.  [Can many items be trivially
        concatenated?](#name-can-many-items-be-trivially){.xref}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [A.3](#appendix-A.3){.xref}.  [Are there tags at the
        start?](#name-are-there-tags-at-the-start){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [Appendix B](#appendix-B){.xref}.  [CBOR Tags for CoAP Content
    Formats](#name-cbor-tags-for-coap-content-f){.xref}

    -   ::: {#section-toc.1-1.7.2.1}
        [B.1](#appendix-B.1){.xref}.  [Content-Format Tag
        Examples](#name-content-format-tag-examples){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [Appendix C](#appendix-C){.xref}.  [Example from
    Openswan](#name-example-from-openswan){.xref}
    :::

-   ::: {#section-toc.1-1.9}
    [Appendix D](#appendix-D){.xref}.  [Using CBOR Labels for Non-CBOR
    Data](#name-using-cbor-labels-for-non-c){.xref}

    -   ::: {#section-toc.1-1.9.2.1}
        [D.1](#appendix-D.1){.xref}.  [Content-Format Tag
        Examples](#name-content-format-tag-examples-2){.xref}
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [](#appendix-E){.xref}[Acknowledgements](#name-acknowledgements){.xref}
    :::

-   ::: {#section-toc.1-1.11}
    [](#appendix-F){.xref}[Contributors](#name-contributors){.xref}
    :::

-   ::: {#section-toc.1-1.12}
    [](#appendix-G){.xref}[Authors\'
    Addresses](#name-authors-addresses){.xref}
    :::
:::
:::

::: {#introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

Since very early in computing, operating systems have sought ways to
mark which files could be processed by which programs. In Unix,
everything is a stream of bytes; identifying the contents of a stream of
bytes became a heuristic activity.[¶](#section-1-1){.pilcrow}

For instance, the Unix file(1) command, which has existed since 1973
\[[FILE](#FILE){.xref}\], has been able to identify many file formats
based upon the contents of the file for
decades.[¶](#section-1-2){.pilcrow}

Many systems (Linux, macOS, Windows) will select the correct application
based upon the file contents if the system cannot determine it by other
means. For instance, in classical Mac OS, a resource fork was maintained
separately from the file data that included file type information; this
way, the OS ideally never needed to know anything about the file data
contents to determine the media type.[¶](#section-1-3){.pilcrow}

Many other systems do this by using file extensions. Many common Web
servers derive the media-type information from file
extensions.[¶](#section-1-4){.pilcrow}

Having a media type associated with the file contents can avoid some of
the brittleness of this approach. When files become disconnected from
their type information, such as when attempting to do forensics on a
damaged system, being able to identify the type of information stored in
a file can become very important.[¶](#section-1-5){.pilcrow}

A common way to identify the type of a file from its contents is to
place a \"magic number\" at the start of the file contents
\[[MAGIC](#MAGIC){.xref}\]. In the media type registration template
\[[RFC6838](#RFC6838){.xref}\], a magic number is asked for, if
available, as is a file extension.[¶](#section-1-6){.pilcrow}

A challenge for the file(1) command is often that it can be confused by
recognizing the overall encoding but not the content being encoded. For
instance, an Android Package Kit APK (as used to transfer and store an
application) may be identified as a ZIP file. Additionally, both
OpenOffice and MSOffice files are ZIP files of XML files; the
identification may stop at identifying them as ZIP
files.[¶](#section-1-7){.pilcrow}

As CBOR becomes a more and more common encoding for a wide variety of
artifacts, identifying them as just \"CBOR\" is probably not sufficient.
This document provides a way to encode a magic number into the beginning
of a CBOR format file. As a CBOR format may use a single CBOR data item
or a CBOR sequence of data items \[[RFC8742](#RFC8742){.xref}\], two
possible methods of enveloping data are presented; a CBOR Protocol
designer will specify one. (A CBOR Protocol is a specification that uses
CBOR as its encoding.)[¶](#section-1-8){.pilcrow}

This document also gives advice to designers of CBOR Protocols on
choosing one of these mechanisms for identifying their contents. This
advice is informative.[¶](#section-1-9){.pilcrow}

A third method is also proposed by which a CBOR format tag is prepended
to identify non-CBOR files. Further information on this method appears
in [Appendix D](#headers){.xref} because it is not about identifying
media types containing CBOR-encoded data items. This includes a simple
way to derive a magic number for content-formats as defined in
\[[RFC7252](#RFC7252){.xref}\], even if the file is not in CBOR
form.[¶](#section-1-10){.pilcrow}

Examples of CBOR Protocols currently under development include Concise
Software Identification Tags \[[CoSWID](#I-D.ietf-sacm-coswid){.xref}\]
and Entity Attestation Tokens \[[EAT](#I-D.ietf-rats-eat){.xref}\]. CBOR
Object Signing and Encryption (COSE) itself
\[[RFC8152](#RFC8152){.xref}\] is considered infrastructure. The
encoding of public keys in CBOR as *C509* as described in
\[[C509-CERT](#I-D.ietf-cose-cbor-encoded-cert){.xref}\] would benefit
from being an identified CBOR Protocol.[¶](#section-1-11){.pilcrow}

A major inspiration for this document is observing the disarray in
certain ASN.1-based systems where most files are Privacy-Enhanced Mail
(PEM) encoded; these files are all identified by the extension \"pem\",
which confounds public keys, private keys, certificate requests, and
S/MIME content.[¶](#section-1-12){.pilcrow}

While the envelopes defined in this specification add information to how
data conforming to CBOR Protocols are stored in files, there is no
requirement that either type of envelope be transferred on the wire.
However, there are some protocols that may benefit from having such a
magic number on the wire if they are presently using a different
(legacy) encoding scheme. The presence of the identifiable magic
sequence can be used to signal that a CBOR Protocol is being used as
opposed to a legacy scheme.[¶](#section-1-13){.pilcrow}

::: {#terminology}
::: {#section-1.1 .section}
### [1.1.](#section-1.1){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

Byte is a synonym for octet. The term \"byte string\" refers to the data
item defined in
\[[STD94](#RFC8949){.xref}\].[¶](#section-1.1-1){.pilcrow}

The term \"file\" is understood to stand in a general way for a stored
representation that is somewhat detached from the original context of
usage of that representation; its usage in this document encompasses
similar units of storage that may have different identification schemes
such as partitions or media blocks.[¶](#section-1.1-2){.pilcrow}

The term \"diagnostic notation\" refers to the human-readable notation
for CBOR data items defined in [Section
8](https://www.rfc-editor.org/rfc/rfc8949#section-8){.relref} of
\[[STD94](#RFC8949){.xref}\] and [Appendix
G](https://www.rfc-editor.org/rfc/rfc8610#appendix-G){.relref} of
\[[RFC8610](#RFC8610){.xref}\].[¶](#section-1.1-3){.pilcrow}

The term \"CDDL\" (Concise Data Definition Language) refers to the
language defined in
\[[RFC8610](#RFC8610){.xref}\].[¶](#section-1.1-4){.pilcrow}

The function TN(ct) is defined in [Appendix
B](#ct-tags){.xref}.[¶](#section-1.1-5){.pilcrow}
:::
:::

::: {#requirements-for-a-magic-number}
::: {#section-1.2 .section}
### [1.2.](#section-1.2){.section-number .selfRef} [Requirements for a Magic Number](#name-requirements-for-a-magic-nu){.section-name .selfRef} {#name-requirements-for-a-magic-nu}

Ideally, a magic number is a fingerprint that is unique to a specific
CBOR Protocol, is present in the first few (small multiple of 4) bytes
of the file and does not change when the contents change, and does not
depend upon the length of the file.[¶](#section-1.2-1){.pilcrow}

Less ideal solutions have a pattern that needs to be matched, but in
which some bytes need to be ignored. While the Unix file(1) command can
be told to ignore certain bytes, this can lead to
ambiguities.[¶](#section-1.2-2){.pilcrow}
:::
:::
:::
:::

::: {#protocol}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Protocol](#name-protocol){.section-name .selfRef} {#name-protocol}

This section presents two enveloping methods. Both use CBOR tags in a
way that results in a deterministic first 8 to 12 bytes. The Protocol
designer determines which one to use; see [Appendix A](#advice){.xref}
for some guidance.[¶](#section-2-1){.pilcrow}

::: {#spectag}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [The CBOR-Protocol-Specific Tag](#name-the-cbor-protocol-specific-){.section-name .selfRef} {#name-the-cbor-protocol-specific-}

In both enveloping methods, CBOR Protocol designers need to obtain a
CBOR tag for each kind of object that they might store in files. As
there are more than 4 billion available 4-byte tags, there should be
little issue in allocating a few to each available CBOR
Protocol.[¶](#section-2.1-1){.pilcrow}

The IANA policy for 4-byte CBOR tags is First Come First Served
\[[RFC8126](#RFC8126){.xref}\] so only a simple interaction (e.g., via
Web or email) with IANA is required. The interaction includes filling in
the small template provided in [Section
9.2](https://www.rfc-editor.org/rfc/rfc8949#section-9.2){.relref} of
\[[STD94](#RFC8949){.xref}\]. In the template, a reference to this
specification (RFC 9277) alongside the Description of semantics is
suggested.[¶](#section-2.1-2){.pilcrow}

Allocation of the CBOR tag needs to be initiated by the designer of the
CBOR Protocol, who can provide a proposed tag number. In order to be in
the 4-byte range, and so that there are no leading zero bytes in the
4-byte encoding of the tag number, the value needs to be in the range
0x01000000 (decimal 16777216) to 0xFFFFFFFF (decimal 4294967295)
inclusive. It is further suggested to avoid values that have an embedded
zero byte in the 4 bytes of their binary representation (such as
0x12003456), as these may confuse implementations that treat the magic
number as a C string.[¶](#section-2.1-3){.pilcrow}

The use of a sequence of four ASCII \[[RFC20](#RFC0020){.xref}\] codes
which are mnemonic to the protocol is encouraged, but not required
(there may be reasons to encode other information into the tag; see
[Appendix B](#ct-tags){.xref} for an example). For instance, [Appendix
C](#openswan){.xref} uses \"OPSN\", which translates to the tag number
1330664270 registered for it.[¶](#section-2.1-4){.pilcrow}

In \[[IANA.CORE-PARAMETERS](#IANA.CORE-PARAMETERS){.xref}\], the
Constrained Application Protocol (CoAP) defines the \"CoAP
Content-Formats\" registry to assign Content-Format Numbers ([Section
12.3](https://www.rfc-editor.org/rfc/rfc7252#section-12.3){.relref} of
\[[RFC7252](#RFC7252){.xref}\]) to Content Types in a specific Content
Coding. For CBOR data items that form a representation that is already
described by such a Content-Format Number, a tag number has proactively
been allocated in [Section 4.3](#iana-ct-tags){.xref} (see [Appendix
B](#ct-tags){.xref} for details and
examples).[¶](#section-2.1-5){.pilcrow}
:::
:::

::: {#wrapped}
::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [Enveloping Method: CBOR Tag Wrapped](#name-enveloping-method-cbor-tag-){.section-name .selfRef} {#name-enveloping-method-cbor-tag-}

The CBOR Tag Wrapped method is appropriate for use with CBOR Protocols
that encode a single CBOR data item. This data item is enveloped into
two nested tags:[¶](#section-2.2-1){.pilcrow}

The outer tag is a self-described CBOR tag, 55799, as described in
[Section
3.4.6](https://www.rfc-editor.org/rfc/rfc8949#section-3.4.6){.relref} of
\[[STD94](#RFC8949){.xref}\].[¶](#section-2.2-2){.pilcrow}

The tag content of the outer tag is a second CBOR tag whose tag number
has been allocated to describe the specific Protocol involved, as
discussed in [Section 2.1](#spectag){.xref}. The tag content of this
inner tag is the single CBOR data item.[¶](#section-2.2-3){.pilcrow}

This method wraps the CBOR data item as CBOR tags usually do.
Applications that need to send the stored CBOR data item across a
constrained network may wish to remove the two tags if the type is
understood from the protocol context, e.g., from a CoAP Content-Format
Option ([Section
5.10.3](https://www.rfc-editor.org/rfc/rfc7252#section-5.10.3){.relref}
of \[[RFC7252](#RFC7252){.xref}\]). Therefore, a CBOR Protocol
specification may pick the specific cases where the CBOR Tag Wrapped
enveloping method is to be used. For instance, it might specify its use
for storing the representation in a local file or for Web access, but
not within protocol messages that already provide the necessary
context.[¶](#section-2.2-4){.pilcrow}

::: {#tag-wrap-example}
::: {#section-2.2.1 .section}
#### [2.2.1.](#section-2.2.1){.section-number .selfRef} [Example](#name-example){.section-name .selfRef} {#name-example}

To construct an example without registering a new tag, we use the
Content-Format ID assigned for `application/senml+cbor` (112)
\[[RFC8428](#RFC8428){.xref}\] of the \"CoAP Content-Formats\" registry
\[[IANA.CORE-PARAMETERS](#IANA.CORE-PARAMETERS){.xref}\]).[¶](#section-2.2.1-1){.pilcrow}

Using the technique described in [Appendix B](#ct-tags){.xref}, this
translates into the tag TN(112) =
1668546929.[¶](#section-2.2.1-2){.pilcrow}

With this tag, the SenML-CBOR pack `[{0: "current", 6: 3, 2: 1.5}]`
would be enveloped as follows (in diagnostic
notation):[¶](#section-2.2.1-3){.pilcrow}

::: {#section-2.2.1-4}
``` {.lang-cbor-diag .sourcecode}
55799(1668546929([{0: "current", 6: 3, 2: 1.5}]))
```

[¶](#section-2.2.1-4){.pilcrow}
:::

Or in hex:[¶](#section-2.2.1-5){.pilcrow}

::: {#section-2.2.1-6}
``` {.lang-cbor-pretty .sourcecode}
d9 d9f7                       # tag(55799)
   da 63740171                # tag(1668546929)
      81                      # array(1)
         a3                   # map(3)
            00                # unsigned(0)
            67                # text(7)
               63757272656e74 # "current"
            06                # unsigned(6)
            03                # unsigned(3)
            02                # unsigned(2)
            f9 3e00           # primitive(15872)
```

[¶](#section-2.2.1-6){.pilcrow}
:::

At the representation level, the unique fingerprint for
`application/senml+cbor` is composed of the 8 bytes d9d9f7da63740171
hex, after which the unadorned CBOR data (81\... for the SenML data) is
appended.[¶](#section-2.2.1-7){.pilcrow}
:::
:::
:::
:::

::: {#sequences}
::: {#section-2.3 .section}
### [2.3.](#section-2.3){.section-number .selfRef} [Enveloping Method: Labeled CBOR Sequence](#name-enveloping-method-labeled-c){.section-name .selfRef} {#name-enveloping-method-labeled-c}

The Labeled CBOR Sequence method is appropriate for use with CBOR
Sequences as described in
\[[RFC8742](#RFC8742){.xref}\].[¶](#section-2.3-1){.pilcrow}

This method prepends a newly constructed, separate data item to the CBOR
Sequence, the *label*.[¶](#section-2.3-2){.pilcrow}

The label is a nesting of two tags, similar to but distinct from the
CBOR Tag Wrapped methods, with an inner tag content of a constant byte
string. The total length of the label is 12
bytes.[¶](#section-2.3-3){.pilcrow}

1.  [The outer tag is the self-described CBOR Sequence tag,
    55800.[¶](#section-2.3-4.1){.pilcrow}]{#section-2.3-4.1}
2.  [The inner tag is a CBOR tag from the First Come First Served space
    that uniquely identifies the CBOR Protocol. As with the CBOR Tag
    Wrapped method, the use of a 4-byte tag that encodes without zero
    bytes is
    encouraged.[¶](#section-2.3-4.2){.pilcrow}]{#section-2.3-4.2}
3.  [The tag content is a 3-byte CBOR byte string containing 0x42_4f_52
    (\'BOR\' in diagnostic
    notation).[¶](#section-2.3-4.3){.pilcrow}]{#section-2.3-4.3}

The outer tag in the label identifies the file as being a CBOR Sequence
and does so with all the desirable properties explained in [Section
3.4.6](https://www.rfc-editor.org/rfc/rfc8949#section-3.4.6){.relref} of
\[[STD94](#RFC8949){.xref}\]. Specifically, it does not appear to
conflict with any known file types, and it is not valid Unicode in any
Unicode encoding.[¶](#section-2.3-5){.pilcrow}

The inner tag in the label identifies which CBOR Protocol is used, as
described above.[¶](#section-2.3-6){.pilcrow}

The inner tag content is a constant byte string that is represented as
0x43_42_4f_52, the ASCII characters \"CBOR\", which is the CBOR-encoded
data item for the 3-byte string 0x42_4f_52 (\'BOR\' in diagnostic
notation).[¶](#section-2.3-7){.pilcrow}

The actual CBOR Protocol data then follows as the next data item(s) in
the CBOR Sequence, without a need for any further specific tag. The use
of a CBOR Sequence allows the application to trivially remove the first
item with the two tags.[¶](#section-2.3-8){.pilcrow}

Should this file be reviewed by a human (directly in an editor or in a
hexdump display), it will include the ASCII characters \"CBOR\"
prominently. This value is also included simply because the inner nested
tag needs to tag something.[¶](#section-2.3-9){.pilcrow}

::: {#tag-seq-example}
::: {#section-2.3.1 .section}
#### [2.3.1.](#section-2.3.1){.section-number .selfRef} [Example](#name-example-2){.section-name .selfRef} {#name-example-2}

To construct an example without registering a new tag, we use ID 272 as
assigned for `application/missing-blocks+cbor-seq` of the \"CoAP
Content-Formats\" registry
\[[RFC9177](#RFC9177){.xref}\].[¶](#section-2.3.1-1){.pilcrow}

Using the technique described in [Appendix B](#ct-tags){.xref}, this
translates into the tag TN(272) =
1668547090.[¶](#section-2.3.1-2){.pilcrow}

This is a somewhat contrived example, as this is not a media type that
is likely to be committed to storage. Nonetheless, with this tag,
missing blocks list `0, 8, 15` would be enveloped as (in diagnostic
notation):[¶](#section-2.3.1-3){.pilcrow}

::: {#section-2.3.1-4}
``` {.lang-cbor-diag .sourcecode}
55800(1668547090('BOR')),
0,
8,
15
```

[¶](#section-2.3.1-4){.pilcrow}
:::

Or in hex:[¶](#section-2.3.1-5){.pilcrow}

::: {#section-2.3.1-6}
``` {.lang-cbor-pretty .sourcecode}
# CBOR sequence with 4 elements
d9 d9f8         # tag(55800)
   da 63740212  # tag(1668547090)
      43        # bytes(3)
         424f52 # "BOR"
00 # unsigned(0)
08 # unsigned(8)
0f # unsigned(15)
```

[¶](#section-2.3.1-6){.pilcrow}
:::

At the representation level, the unique fingerprint for
`application/missing-blocks+cbor-seq` is composed of the 8 bytes
d9d9f8da63740212 hex, after which the unadorned CBOR sequence (00\...
for the missing block list given) is
appended.[¶](#section-2.3.1-7){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#security-considerations}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

This document provides a way to identify CBOR Protocol objects. Clearly
identifying CBOR contents in files may have a variety of
impacts.[¶](#section-3-1){.pilcrow}

The most obvious is that it may allow malware to identify interesting
stored objects, and then exfiltrate or corrupt
them.[¶](#section-3-2){.pilcrow}

Protective applications (that check data) cannot rely on the
applications they try to protect (that use the data) to make exactly the
same decisions in recognizing file formats. (This is an instance of a
check versus use issue.) For example, end-point assessment technologies
should not solely rely on the labeling approaches described in this
document to decide whether to inspect a given file. Similarly, depending
on operating system configurations and related properties of the
execution environment, the labeling might influence the default
application used to process a file in a way that may not be predicted by
a protective application.[¶](#section-3-3){.pilcrow}
:::
:::

::: {#iana-considerations}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

These IANA considerations are entirely about CBOR tags in the \"Concise
Binary Object Representation (CBOR) Tags\" registry
\[[IANA.CBOR-TAGS](#IANA.CBOR-TAGS){.xref}\].[¶](#section-4-1){.pilcrow}

[Section 4.1](#cbor-sequence-tag){.xref} documents the allocation for a
CBOR tag to be used in a CBOR sequence to identify the sequence (an
example for using this tag is found in [Appendix C](#openswan){.xref}).
[Section 4.2](#cbor-labeled-non-cbor-data-tag){.xref} documents the
allocation for a CBOR tag to be used in the CBOR-Labeled Non-CBOR Data
Enveloping Method ([Appendix D](#headers){.xref}, which also shows
examples). [Section 4.3](#iana-ct-tags){.xref} allocates a CBOR tag for
each actual or potential CoAP Content-Format number (examples are in
[Appendix B](#ct-tags){.xref}).[¶](#section-4-2){.pilcrow}

::: {#cbor-sequence-tag}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Labeled CBOR Sequence Tag](#name-labeled-cbor-sequence-tag){.section-name .selfRef} {#name-labeled-cbor-sequence-tag}

IANA has allocated tag 55800 for the Labeled CBOR Sequence Enveloping
Method from the \"CBOR Tags\" registry. IANA has updated this tag
registration to point to this document.[¶](#section-4.1-1){.pilcrow}

This tag is from the First Come First Served
area.[¶](#section-4.1-2){.pilcrow}

The value has been picked to have properties similar to the 55799 tag
([Section
3.4.6](https://www.rfc-editor.org/rfc/rfc8949#section-3.4.6){.relref} of
\[[STD94](#RFC8949){.xref}\]).[¶](#section-4.1-3){.pilcrow}

The hexadecimal representation of the encoded tag head is
0xd9_d9_f8.[¶](#section-4.1-4){.pilcrow}

This is not valid UTF-8: the first 0xd9 introduces a 3-byte sequence in
UTF-8, but the 0xd9 as the second value is not a valid second byte for
UTF-8.[¶](#section-4.1-5){.pilcrow}

This is not valid UTF-16: the byte sequence 0xd9d9 (in either endian
order) puts this value into the UTF-16 high-half zone, which would
signal that this is a 32-bit Unicode value. However, the following
16-bit big-endian value 0xf8_xx is not a valid second sequence according
to \[[RFC2781](#RFC2781){.xref}\]. On a little-endian system, it would
be necessary to examine the fourth byte to determine if it is valid.
That next byte is determined by the subsequent encoding, and [Section
3.4.6](https://www.rfc-editor.org/rfc/rfc8949#section-3.4.6){.relref} of
\[[STD94](#RFC8949){.xref}\] has already determined that no valid CBOR
encodings result in valid UTF-16.[¶](#section-4.1-6){.pilcrow}

[]{.break}

Data Item:

:   tagged byte string[¶](#section-4.1-7.2.1){.pilcrow}

:   

Semantics:

:   indicates that the file contains CBOR
    Sequences[¶](#section-4.1-7.4.1){.pilcrow}

:   
:::
:::

::: {#cbor-labeled-non-cbor-data-tag}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [CBOR-Labeled Non-CBOR Data Tag](#name-cbor-labeled-non-cbor-data-){.section-name .selfRef} {#name-cbor-labeled-non-cbor-data-}

IANA has allocated tag 55801 for the CBOR-Labeled Non-CBOR Data
Enveloping Method ([Appendix D](#headers){.xref}) from the \"CBOR Tags\"
registry. IANA updated this tag registration to point to this
document.[¶](#section-4.2-1){.pilcrow}

This tag is from the First Come First Served
area.[¶](#section-4.2-2){.pilcrow}

The value has been picked to have properties similar to the 55799 tag
([Section
3.4.6](https://www.rfc-editor.org/rfc/rfc8949#section-3.4.6){.relref} of
\[[STD94](#RFC8949){.xref}\]).[¶](#section-4.2-3){.pilcrow}

The hexadecimal representation of the encoded tag head is
0xd9_d9_f9.[¶](#section-4.2-4){.pilcrow}

This is not valid UTF-8: the first 0xd9 introduces a 3-byte sequence in
UTF-8, but the 0xd9 as the second value is not a valid second byte for
UTF-8.[¶](#section-4.2-5){.pilcrow}

This is not valid UTF-16: the byte sequence 0xd9d9 (in either endian
order) puts this value into the UTF-16 high-half zone, which would
signal that this is a 32-bit Unicode value. However, the following
16-bit big-endian value 0xf9_xx is not a valid second sequence according
to \[[RFC2781](#RFC2781){.xref}\]. On a little-endian system, it would
be necessary to examine the fourth byte to determine if it is valid.
That next byte is determined by the subsequent encoding, and [Section
3.4.6](https://www.rfc-editor.org/rfc/rfc8949#section-3.4.6){.relref} of
\[[STD94](#RFC8949){.xref}\] has already determined that no valid CBOR
encodings result in valid UTF-16.[¶](#section-4.2-6){.pilcrow}

[]{.break}

Data Item:

:   tagged byte string[¶](#section-4.2-7.2.1){.pilcrow}

:   

Semantics:

:   indicates that the file starts with a CBOR-Labeled Non-CBOR Data
    label.[¶](#section-4.2-7.4.1){.pilcrow}

:   
:::
:::

::: {#iana-ct-tags}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [CBOR Tags for CoAP Content-Format Numbers](#name-cbor-tags-for-coap-content-){.section-name .selfRef} {#name-cbor-tags-for-coap-content-}

IANA allocated the tag numbers 1668546817 (0x63740101) to 1668612095
(0x6374ffff) as follows:[¶](#section-4.3-1){.pilcrow}

[]{.break}

Data Item:

:   byte string or any CBOR data item (see [Appendix
    B](#ct-tags){.xref})[¶](#section-4.3-2.2.1){.pilcrow}

:   

Semantics:

:   the representation of content-format ct \< 65025 is indicated by tag
    number\
    TN(ct) = 0x63740101 + (ct / 255) \* 256 + ct %
    255[¶](#section-4.3-2.4.1){.pilcrow}

:   

Reference:

:   RFC 9277[¶](#section-4.3-2.6.1){.pilcrow}

:   

The \"CoAP Content-Formats\" registry
\[[IANA.CORE-PARAMETERS](#IANA.CORE-PARAMETERS){.xref}\] is defined in
[Section
12.3](https://www.rfc-editor.org/rfc/rfc7252#section-12.3){.relref} of
\[[RFC7252](#RFC7252){.xref}\].[¶](#section-4.3-3){.pilcrow}
:::
:::
:::
:::

::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[C\]
:   [International Organization for Standardization]{.refAuthor},
    [\"Information technology \-- Programming languages \--
    C\"]{.refTitle}, [ISO/IEC 9899:2018, Fourth Edition]{.seriesInfo},
    June 2018, \<<https://www.iso.org/standard/74528.html>\>.
:   

\[RFC8742\]
:   [Bormann, C.]{.refAuthor}, [\"Concise Binary Object Representation
    (CBOR) Sequences\"]{.refTitle}, [RFC 8742]{.seriesInfo}, [DOI
    10.17487/RFC8742]{.seriesInfo}, February 2020,
    \<<https://www.rfc-editor.org/info/rfc8742>\>.
:   

\[STD94\]
:   [Bormann, C.]{.refAuthor} and [P. Hoffman]{.refAuthor}, [\"Concise
    Binary Object Representation (CBOR)\"]{.refTitle}, [STD
    94]{.seriesInfo}, [RFC 8949]{.seriesInfo}, [DOI
    10.17487/RFC8949]{.seriesInfo}, December 2020,
    \<<https://www.rfc-editor.org/info/std94>\>.
:   
:::

::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[C509-CERT\]
:   [Mattsson, J. P.]{.refAuthor}, [Selander, G.]{.refAuthor},
    [Raza, S.]{.refAuthor}, [Höglund, J.]{.refAuthor}, and [M.
    Furuhed]{.refAuthor}, [\"CBOR Encoded X.509 Certificates (C509
    Certificates)\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-cose-cbor-encoded-cert-04]{.seriesInfo},
    10 July 2022,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-cose-cbor-encoded-cert-04>\>.
:   

\[CoSWID\]
:   [Birkholz, H.]{.refAuthor}, [Fitzgerald-McKay, J.]{.refAuthor},
    [Schmidt, C.]{.refAuthor}, and [D. Waltermire]{.refAuthor},
    [\"Concise Software Identification Tags\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-sacm-coswid-22]{.seriesInfo}, 20 July 2022,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-sacm-coswid-22>\>.
:   

\[EAT\]
:   [Lundblade, L.]{.refAuthor}, [Mandyam, G.]{.refAuthor}, and [J.
    O\'Donoghue]{.refAuthor}, [\"The Entity Attestation Token
    (EAT)\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-rats-eat-14]{.seriesInfo}, 10 July 2022,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-rats-eat-14>\>.
:   

\[FILE\]
:   [Wikipedia]{.refAuthor}, [\"file (command)\"]{.refTitle}, 2 July
    2022,
    \<<https://en.wikipedia.org/w/index.php?title=File_(command)&oldid=1096086462>\>.
:   

\[IANA.CBOR-TAGS\]
:   [IANA]{.refAuthor}, [\"Concise Binary Object Representation (CBOR)
    Tags\"]{.refTitle},
    \<<https://www.iana.org/assignments/cbor-tags>\>.
:   

\[IANA.CORE-PARAMETERS\]
:   [IANA]{.refAuthor}, [\"Constrained RESTful Environments (CoRE)
    Parameters\"]{.refTitle},
    \<<https://www.iana.org/assignments/core-parameters>\>.
:   

\[MAGIC\]
:   [Bell Labs]{.refAuthor}, [\"archive (library) file
    format\"]{.refTitle}, [Unix Programmer\'s Manual, First Edition:
    File Formats]{.refContent}, 3 November 1971,
    \<<https://www.bell-labs.com/usr/dmr/www/man51.pdf#page=4>\>.
:   

\[RFC20\]
:   [Cerf, V.]{.refAuthor}, [\"ASCII format for network
    interchange\"]{.refTitle}, [STD 80]{.seriesInfo}, [RFC
    20]{.seriesInfo}, [DOI 10.17487/RFC0020]{.seriesInfo}, October 1969,
    \<<https://www.rfc-editor.org/info/rfc20>\>.
:   

\[RFC2781\]
:   [Hoffman, P.]{.refAuthor} and [F. Yergeau]{.refAuthor}, [\"UTF-16,
    an encoding of ISO 10646\"]{.refTitle}, [RFC 2781]{.seriesInfo},
    [DOI 10.17487/RFC2781]{.seriesInfo}, February 2000,
    \<<https://www.rfc-editor.org/info/rfc2781>\>.
:   

\[RFC6838\]
:   [Freed, N.]{.refAuthor}, [Klensin, J.]{.refAuthor}, and [T.
    Hansen]{.refAuthor}, [\"Media Type Specifications and Registration
    Procedures\"]{.refTitle}, [BCP 13]{.seriesInfo}, [RFC
    6838]{.seriesInfo}, [DOI 10.17487/RFC6838]{.seriesInfo}, January
    2013, \<<https://www.rfc-editor.org/info/rfc6838>\>.
:   

\[RFC7252\]
:   [Shelby, Z.]{.refAuthor}, [Hartke, K.]{.refAuthor}, and [C.
    Bormann]{.refAuthor}, [\"The Constrained Application Protocol
    (CoAP)\"]{.refTitle}, [RFC 7252]{.seriesInfo}, [DOI
    10.17487/RFC7252]{.seriesInfo}, June 2014,
    \<<https://www.rfc-editor.org/info/rfc7252>\>.
:   

\[RFC8017\]
:   [Moriarty, K., Ed.]{.refAuthor}, [Kaliski, B.]{.refAuthor},
    [Jonsson, J.]{.refAuthor}, and [A. Rusch]{.refAuthor}, [\"PKCS #1:
    RSA Cryptography Specifications Version 2.2\"]{.refTitle}, [RFC
    8017]{.seriesInfo}, [DOI 10.17487/RFC8017]{.seriesInfo}, November
    2016, \<<https://www.rfc-editor.org/info/rfc8017>\>.
:   

\[RFC8126\]
:   [Cotton, M.]{.refAuthor}, [Leiba, B.]{.refAuthor}, and [T.
    Narten]{.refAuthor}, [\"Guidelines for Writing an IANA
    Considerations Section in RFCs\"]{.refTitle}, [BCP 26]{.seriesInfo},
    [RFC 8126]{.seriesInfo}, [DOI 10.17487/RFC8126]{.seriesInfo}, June
    2017, \<<https://www.rfc-editor.org/info/rfc8126>\>.
:   

\[RFC8152\]
:   [Schaad, J.]{.refAuthor}, [\"CBOR Object Signing and Encryption
    (COSE)\"]{.refTitle}, [RFC 8152]{.seriesInfo}, [DOI
    10.17487/RFC8152]{.seriesInfo}, July 2017,
    \<<https://www.rfc-editor.org/info/rfc8152>\>.
:   

\[RFC8428\]
:   [Jennings, C.]{.refAuthor}, [Shelby, Z.]{.refAuthor},
    [Arkko, J.]{.refAuthor}, [Keranen, A.]{.refAuthor}, and [C.
    Bormann]{.refAuthor}, [\"Sensor Measurement Lists
    (SenML)\"]{.refTitle}, [RFC 8428]{.seriesInfo}, [DOI
    10.17487/RFC8428]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8428>\>.
:   

\[RFC8610\]
:   [Birkholz, H.]{.refAuthor}, [Vigano, C.]{.refAuthor}, and [C.
    Bormann]{.refAuthor}, [\"Concise Data Definition Language (CDDL): A
    Notational Convention to Express Concise Binary Object
    Representation (CBOR) and JSON Data Structures\"]{.refTitle}, [RFC
    8610]{.seriesInfo}, [DOI 10.17487/RFC8610]{.seriesInfo}, June 2019,
    \<<https://www.rfc-editor.org/info/rfc8610>\>.
:   

\[RFC9110\]
:   [Fielding, R., Ed.]{.refAuthor}, [Nottingham, M., Ed.]{.refAuthor},
    and [J. Reschke, Ed.]{.refAuthor}, [\"HTTP Semantics\"]{.refTitle},
    [STD 97]{.seriesInfo}, [RFC 9110]{.seriesInfo}, [DOI
    10.17487/RFC9110]{.seriesInfo}, June 2022,
    \<<https://www.rfc-editor.org/info/rfc9110>\>.
:   

\[RFC9177\]
:   [Boucadair, M.]{.refAuthor} and [J. Shallow]{.refAuthor},
    [\"Constrained Application Protocol (CoAP) Block-Wise Transfer
    Options Supporting Robust Transmission\"]{.refTitle}, [RFC
    9177]{.seriesInfo}, [DOI 10.17487/RFC9177]{.seriesInfo}, March 2022,
    \<<https://www.rfc-editor.org/info/rfc9177>\>.
:   

\[X.690\]
:   [ITU-T]{.refAuthor}, [\"Information technology - ASN.1 encoding
    rules: Specification of Basic Encoding Rules (BER), Canonical
    Encoding Rules (CER) and Distinguished Encoding Rules
    (DER)\"]{.refTitle}, [ITU-T Recommendation X.690]{.seriesInfo},
    [ISO/IEC 8825-1]{.seriesInfo}, February 2021,
    \<<https://www.itu.int/rec/T-REC-X.690>\>.
:   
:::
:::

::: {#advice}
::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [Advice to Protocol Designer](#name-advice-to-protocol-designer){.section-name .selfRef} {#name-advice-to-protocol-designer}

This document introduces a choice between wrapping a single CBOR data
item into a pair of identifying CBOR tags or prepending an identifying
encoded CBOR data item (which, in turn, contains a pair of identifying
CBOR tags) to a CBOR Sequence (which might be a single data
item).[¶](#appendix-A-1){.pilcrow}

Which should a protocol designer use?[¶](#appendix-A-2){.pilcrow}

In this discussion, one assumes that there is an object stored in a
file, perhaps specified by a system operator in a configuration
file.[¶](#appendix-A-3){.pilcrow}

For example: a private key used in COSE operations, a public
key/certificate in C509
\[[C509-CERT](#I-D.ietf-cose-cbor-encoded-cert){.xref}\] or CBOR format,
a recorded sensor reading stored for later transmission, or a COVID-19
vaccination certificate that needs to be displayed in QR code
form.[¶](#appendix-A-4){.pilcrow}

Both the Labeled CBOR Sequence and the wrapped tag can be trivially
removed by an application before sending the CBOR content out on the
wire.[¶](#appendix-A-5){.pilcrow}

The Labeled CBOR Sequence can be slightly easier to remove as, in most
cases, CBOR parsers will return it as a unit and then return the actual
CBOR item, which could be anything at all and could include CBOR tags
that *do* need to be sent on the wire.[¶](#appendix-A-6){.pilcrow}

On the other hand, having the Labeled CBOR Sequence in the file requires
that all programs that expect to examine that file be able to skip what
appears to be a CBOR item with two tags nested around a 3-byte byte
string. The 3-byte entry is not of the format the program would normally
have processed, so it may be a surprise. On the other hand, CBOR parsers
are generally tolerant of tags that appear: many of them will process
extra tags, making unknown tags available as meta information. A program
that is not expecting those tags may just ignore
them.[¶](#appendix-A-7){.pilcrow}

As an example of where there was a problem with previous security
systems, \"PEM\" format certificate files grew to be able to contain
multiple certificates by simple concatenation. The PKCS1 format
\[[RFC8017](#RFC8017){.xref}\] could also contain a private key object
followed by one or more certificate objects, but only when in PEM
format. Annoyingly, when in binary DER format
(\[[X.690](#X.690){.xref}\], which like CBOR is self-delimiting),
concatenation of certificates was not compatible with most programs as
they did not expect to read more than one item in the
file.[¶](#appendix-A-8){.pilcrow}

The use of CBOR Tag Wrapped format is easier to retrofit to an existing
format with existing and unchangeable stored format for a single CBOR
data item. This new sequence of tags is expected to be trivially ignored
by many existing programs when reading CBOR from files or similar units
of storage, even if the program only supports decoding a single data
item (and not a CBOR sequence). But, a naive program might also then
transmit the additional tags across the network. Removing the CBOR Tag
Wrapped format requires knowledge of the two tags involved. Other tags
present might be needed.[¶](#appendix-A-9){.pilcrow}

For a representation matching a specific media-type that is carried in a
CBOR byte string, the byte string head will already have to be removed
for use as such a representation, so it should be easy to remove the
enclosing tag heads as well. This is of particular interest with the
predefined tags provided in [Appendix B](#ct-tags){.xref} for media
types with CoAP Content-Format numbers.[¶](#appendix-A-10){.pilcrow}

Some considerations in the form of survey questions
follow.[¶](#appendix-A-11){.pilcrow}

::: {#is-the-on-wire-format-new}
::: {#appendix-A.1 .section}
### [A.1.](#appendix-A.1){.section-number .selfRef} [Is the on-wire format new?](#name-is-the-on-wire-format-new){.section-name .selfRef} {#name-is-the-on-wire-format-new}

If the on-wire format is new, then it could be specified with the CBOR
Tag Wrapped format if the extra 8 bytes are not a problem. The stored
format is then identical to the on-wire
format.[¶](#appendix-A.1-1){.pilcrow}

If the 8 bytes are a problem on the wire (and they often are if CBOR is
being considered), then the Labeled CBOR Sequence format should be
adopted for the stored format.[¶](#appendix-A.1-2){.pilcrow}
:::
:::

::: {#can-many-items-be-trivially-concatenated}
::: {#appendix-A.2 .section}
### [A.2.](#appendix-A.2){.section-number .selfRef} [Can many items be trivially concatenated?](#name-can-many-items-be-trivially){.section-name .selfRef} {#name-can-many-items-be-trivially}

If the programs that read the contents of the file already expect to
process all of the CBOR data items in the file (not just the first),
then the Labeled CBOR Sequence format may be easily
retrofitted.[¶](#appendix-A.2-1){.pilcrow}

The programs involved may throw errors or warnings on the Labeled CBOR
Sequence if they have not yet been updated, but this may not be a
problem.[¶](#appendix-A.2-2){.pilcrow}

There are situations where multiple objects may be concatenated into a
single file. If each object is preceded by a Labeled CBOR Sequence
label, then there may be multiple such labels in the
file.[¶](#appendix-A.2-3){.pilcrow}

A protocol based on CBOR Sequences may specify that Labeled CBOR
Sequence labels can occur within a CBOR Sequence, possibly even to
switch to data items following in the sequence that are of a different
type.[¶](#appendix-A.2-4){.pilcrow}

If the CBOR-Sequence-based protocol does not define the semantics for or
at least tolerate embedded labels, care must be taken when concatenating
Labeled CBOR Sequences to remove the label from all but the first
part.[¶](#appendix-A.2-5){.pilcrow}

As an example from legacy PEM-encoded PKIX certificates, many programs
accept a series of PKIX certificates in a single file in order to set up
a certificate chain. The file would contain not just the End-Entity (EE)
certificate, but also any subordinate certification authorities (CAs)
needed to validate the EE. This mechanism actually only works for
PEM-encoded certificates, and not DER-encoded certificates. One of the
reasons for this specification is to make sure that CBOR-encoded
certificates do not suffer from this
problem.[¶](#appendix-A.2-6.1){.pilcrow}

As an example of mixing of types, some TLS server programs also can
accept both their PEM-encoded private key and their PEM-encoded
certificate in the same file.[¶](#appendix-A.2-6.2){.pilcrow}

If only one item is ever expected in the file, the use of the Labeled
CBOR Sequence may present an implementation hurdle to programs that
previously just read a single data item and used
it.[¶](#appendix-A.2-7){.pilcrow}
:::
:::

::: {#are-there-tags-at-the-start}
::: {#appendix-A.3 .section}
### [A.3.](#appendix-A.3){.section-number .selfRef} [Are there tags at the start?](#name-are-there-tags-at-the-start){.section-name .selfRef} {#name-are-there-tags-at-the-start}

If the Protocol expects to use other tags at its top level, then the use
of the CBOR Tag Wrapped format may be easy to explain at the same place
in the protocol description.[¶](#appendix-A.3-1){.pilcrow}
:::
:::
:::
:::

::: {#ct-tags}
::: {#appendix-B .section}
## [Appendix B.](#appendix-B){.section-number .selfRef} [CBOR Tags for CoAP Content Formats](#name-cbor-tags-for-coap-content-f){.section-name .selfRef} {#name-cbor-tags-for-coap-content-f}

[Section
5.10.3](https://www.rfc-editor.org/rfc/rfc7252#section-5.10.3){.relref}
of \[[RFC7252](#RFC7252){.xref}\] defines the concept of a
Content-Format, which is a short, 16-bit unsigned integer that
identifies a specific content type (media type plus (optionally)
parameters), optionally together with a content coding (see [Section
8.4.1](https://www.rfc-editor.org/rfc/rfc9110#section-8.4.1){.relref} of
\[[RFC9110](#RFC9110){.xref}\]).[¶](#appendix-B-1){.pilcrow}

Outside of a transfer protocol that indicates the Content-Format for a
representation, it may be necessary to identify the Content-Format of
the representation when it is stored in a file, in firmware, or when
debugging.[¶](#appendix-B-2){.pilcrow}

This specification allocates CBOR tag numbers 1668546817 (0x63740101) to
1668612095 (0x6374FFFF) for the tagging of representations of specific
content formats.[¶](#appendix-B-3){.pilcrow}

Using tags from this range, a byte string that is to be interpreted as a
representation of Content-Format number `ct`, with ct \< 65025
(255\*255), can be identified by enclosing it in a tag with tag number
`TN(ct)` where:[¶](#appendix-B-4){.pilcrow}

-   ::: {#appendix-B-5.1}
    TN(ct) = 0x63740101 + (ct / 255) \* 256 + ct %
    255.[¶](#appendix-B-5.1.1){.pilcrow}
    :::

(where `+`, `*`, `/` and `%` stand for integer addition, multiplication,
division, and remainder as in the programming language C
\[[C](#C){.xref}\].)[¶](#appendix-B-6){.pilcrow}

This formula avoids the use of zero bytes in the representation of the
tag number.[¶](#appendix-B-7.1){.pilcrow}

Note that no tag numbers are assigned for Content-Format numbers in the
following range:[¶](#appendix-B-7.2){.pilcrow}

::: {#appendix-B-7.3 .alignLeft .art-text .artwork}
    65025 ≤ ct ≤ 65535

[¶](#appendix-B-7.3){.pilcrow}
:::

(This range is in the range reserved for Experimental Use
\[[RFC8126](#RFC8126){.xref}\] by [Section
12.3](https://www.rfc-editor.org/rfc/rfc7252#section-12.3){.relref} of
\[[RFC7252](#RFC7252){.xref}\]. The overlap of 25 code points between
this experimental range with the range this appendix defines tag numbers
for can be used for experiments that want to employ a tag
number.)[¶](#appendix-B-7.4){.pilcrow}

Exceptionally, when used immediately as tag content of one of the tags
55799, 55800, or 55801, the tag content is as
follows:[¶](#appendix-B-8){.pilcrow}

[]{.break}

Tag 55799 ([Section 2.2](#wrapped){.xref}):

:   One of:[¶](#appendix-B-9.2.1){.pilcrow}

    1.  [The CBOR data item within the representation (without
        byte-string wrapping). This only works for Content-Formats that
        are represented by a single CBOR data item in identity
        content-coding.[¶](#appendix-B-9.2.2.1){.pilcrow}]{#appendix-B-9.2.2.1}
    2.  [The data items in the CBOR sequence within the representation,
        without byte string wrapping, but wrapped in a CBOR array. This
        works for Content-Formats that are represented by a CBOR
        sequence in identity
        content-coding.[¶](#appendix-B-9.2.2.2){.pilcrow}]{#appendix-B-9.2.2.2}

:   

Tags 55800 ([Section 2.3](#sequences){.xref}) or 55801 ([Appendix D](#headers){.xref}):

:   the byte string \'BOR\', signifying that the representation of the
    given content-format follows in the file, in the way defined for
    these tags.[¶](#appendix-B-9.4.1){.pilcrow}

:   

::: {#ct-examples}
::: {#appendix-B.1 .section}
### [B.1.](#appendix-B.1){.section-number .selfRef} [Content-Format Tag Examples](#name-content-format-tag-examples){.section-name .selfRef} {#name-content-format-tag-examples}

The \"CoAP Content-Formats\" registry
\[[IANA.CORE-PARAMETERS](#IANA.CORE-PARAMETERS){.xref}\] defines content
formats that can be used as examples:[¶](#appendix-B.1-1){.pilcrow}

-   ::: {#appendix-B.1-2.1}
    As discussed in [Section 2.2.1](#tag-wrap-example){.xref},
    Content-Format ID 112 represents the application/senml+cbor media
    type (no parameters). The corresponding tag number is TN(112) =
    1668546929.[¶](#appendix-B.1-2.1.1){.pilcrow}

    The following CDDL snippet can be used to identify
    application/senml+cbor
    representations:[¶](#appendix-B.1-2.1.2){.pilcrow}

    ::: {#appendix-B.1-2.1.3}
    ``` {.lang-cddl .sourcecode}
    senml-cbor = #6.1668546929(bstr)
    ```

    [¶](#appendix-B.1-2.1.3){.pilcrow}
    :::

    Note that a byte string is used as the type of the tag content
    because a media type representation in general can be any byte
    string.[¶](#appendix-B.1-2.1.4){.pilcrow}
    :::

-   ::: {#appendix-B.1-2.2}
    Content-Format ID 272 represents the
    application/missing-blocks+cbor-seq media type, which is a CBOR
    sequence
    \[[RFC9177](#RFC9177){.xref}\].[¶](#appendix-B.1-2.2.1){.pilcrow}

    The corresponding tag number is TN(272) =
    1668547090.[¶](#appendix-B.1-2.2.2){.pilcrow}

    The following CDDL snippet can be used to identify
    application/missing-blocks+cbor-seq representations as embedded in a
    CBOR byte string:[¶](#appendix-B.1-2.2.3){.pilcrow}

    ::: {#appendix-B.1-2.2.4}
    ``` {.lang-cddl .sourcecode}
    missing-blocks = #6.1668547090(bstr)
    ```

    [¶](#appendix-B.1-2.2.4){.pilcrow}
    :::
    :::
:::
:::
:::
:::

::: {#openswan}
::: {#appendix-C .section}
## [Appendix C.](#appendix-C){.section-number .selfRef} [Example from Openswan](#name-example-from-openswan){.section-name .selfRef} {#name-example-from-openswan}

The Openswan IPsec project has a daemon (\"pluto\") and two control
programs (\"addconn\" and \"whack\"). They communicate via a Unix-domain
socket, over which a C-structure containing pointers to strings is
serialized using a bespoke mechanism. This is normally not a problem as
the structure is compiled by the same compiler; but when there are
upgrades, it is possible for the daemon and the control programs to get
out of sync by the bespoke serialization. As a result, there are extra
compensations to deal with shutting the daemon down. During testing, it
is sometimes the case that upgrades are backed
out.[¶](#appendix-C-1){.pilcrow}

In addition, when doing unit testing, the easiest way to load policy is
to use the normal policy-reading process, but that is not normally
loaded in the daemon. Instead, the IPC that is normally sent across the
wire is compiled, serialized, and placed in a file. The above magic
number is included in the file and on the IPC in order to distinguish
the \"shutdown\" command CBOR operation.[¶](#appendix-C-2){.pilcrow}

In order to reduce the problems due to serialization, the serialization
is being changed to CBOR. Additionally, this change allows the IPC to be
described by CDDL and any implementation language to be used that can
encode CBOR.[¶](#appendix-C-3){.pilcrow}

IANA has allocated the tag 1330664270 or 0x4f_50_53_4e for this purpose.
As a result, each file and each IPC is prefixed with a CBOR Sequence
tag.[¶](#appendix-C-4){.pilcrow}

In diagnostic notation:[¶](#appendix-C-5){.pilcrow}

::: {#appendix-C-6}
``` {.lang-cbor-diag .sourcecode}
55800(1330664270(h'424F52'))
```

[¶](#appendix-C-6){.pilcrow}
:::

Or in hex:[¶](#appendix-C-7){.pilcrow}

::: {#appendix-C-8}
``` {.lang-cbor-pretty .sourcecode}
d9 d9f8         # tag(55800)
   da 4f50534e  # tag(1330664270)
      43        # bytes(3)
         424f52 # "BOR"
```

[¶](#appendix-C-8){.pilcrow}
:::
:::
:::

::: {#headers}
::: {#appendix-D .section}
## [Appendix D.](#appendix-D){.section-number .selfRef} [Using CBOR Labels for Non-CBOR Data](#name-using-cbor-labels-for-non-c){.section-name .selfRef} {#name-using-cbor-labels-for-non-c}

The CBOR-Labeled Non-CBOR data method is appropriate for adding a magic
number to a Non-CBOR data format, particularly one that can be described
by a Content-Format tag ([Appendix
B](#ct-tags){.xref}).[¶](#appendix-D-1){.pilcrow}

This method prepends a CBOR data item to the Non-CBOR data; this data
item is called the \"header\" and, similar to the Labeled CBOR-Sequence
label, consists of two nested tags around a constant byte string for a
total of 12 bytes.[¶](#appendix-D-2){.pilcrow}

1.  [The outer tag is the CBOR-Labeled Non-CBOR Data tag,
    55801.[¶](#appendix-D-3.1){.pilcrow}]{#appendix-D-3.1}
2.  [The inner tag is a CBOR tag from the First Come First Served space
    that uniquely identifies the CBOR Protocol. As with CBOR Tag
    Wrapped, the use of a 4-byte tag is encouraged that encodes without
    zero bytes.[¶](#appendix-D-3.2){.pilcrow}]{#appendix-D-3.2}
3.  [The tag content is a 3-byte CBOR byte string containing 0x42_4F_52
    (\'BOR\' in diagnostic
    notation).[¶](#appendix-D-3.3){.pilcrow}]{#appendix-D-3.3}

The outer tag in the label identifies the file as being prefixed by a
Non-CBOR data label and does so with all the desirable properties
explained in [Section
3.4.6](https://www.rfc-editor.org/rfc/rfc8949#section-3.4.6){.relref} of
\[[STD94](#RFC8949){.xref}\]. Specifically, it does not appear to
conflict with any known file types, and it is not valid Unicode in any
Unicode encoding.[¶](#appendix-D-4){.pilcrow}

The inner tag in the label identifies which Non-CBOR Protocol is
used.[¶](#appendix-D-5){.pilcrow}

The inner tag content is a constant byte string that is represented as
0x43_42_4f_52, the ASCII characters \"CBOR\", which is the CBOR-encoded
data item for the 3-byte string 0x42_4f_52 (\'BOR\' in diagnostic
notation).[¶](#appendix-D-6){.pilcrow}

The actual Non-CBOR Protocol data then follow directly appended to the
CBOR representation of the header. This allows the application to
trivially remove the header item with the two nested tags and the byte
string.[¶](#appendix-D-7){.pilcrow}

As with the Labeled CBOR Sequence {#sequences}, this choice of the tag
content places the ASCII characters \"CBOR\" prominently into the
header.[¶](#appendix-D-8){.pilcrow}

::: {#header-ct-examples}
::: {#appendix-D.1 .section}
### [D.1.](#appendix-D.1){.section-number .selfRef} [Content-Format Tag Examples](#name-content-format-tag-examples-2){.section-name .selfRef} {#name-content-format-tag-examples-2}

The \"CoAP Content-Formats\" registry
\[[IANA.CORE-PARAMETERS](#IANA.CORE-PARAMETERS){.xref}\] defines content
formats that can be used as examples:[¶](#appendix-D.1-1){.pilcrow}

-   ::: {#appendix-D.1-2.1}
    Content-Format ID 432 represents the application/td+json media type
    (no parameters).[¶](#appendix-D.1-2.1.1){.pilcrow}

    The corresponding tag number is TN(432) =
    1668547250.[¶](#appendix-D.1-2.1.2){.pilcrow}

    The following CDDL snippet can be used to identify a CBOR-Labeled
    Non-CBOR data for application/td+json
    representations:[¶](#appendix-D.1-2.1.3){.pilcrow}

    ::: {#appendix-D.1-2.1.4}
    ``` {.lang-cddl .sourcecode}
    td-json-header = #6.55801(#6.1668547250('BOR'))
    ```

    [¶](#appendix-D.1-2.1.4){.pilcrow}
    :::
    :::

-   ::: {#appendix-D.1-2.2}
    Content-Format 11050 represents the application/json media type in
    deflate content-coding.[¶](#appendix-D.1-2.2.1){.pilcrow}

    The corresponding tag number is TN(11050) =
    1668557910.[¶](#appendix-D.1-2.2.2){.pilcrow}

    The following CDDL snippet can be used to identify a CBOR-Labeled
    Non-CBOR data for application/json representations compressed in
    deflate content-coding:[¶](#appendix-D.1-2.2.3){.pilcrow}

    ::: {#appendix-D.1-2.2.4}
    ``` {.lang-cddl .sourcecode}
    json-deflate-header = #6.55801(#6.1668557910('BOR'))
    ```

    [¶](#appendix-D.1-2.2.4){.pilcrow}
    :::
    :::
:::
:::
:::
:::

::: {#acknowledgements}
::: {#appendix-E .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

The CBOR WG brainstormed this protocol on January 20, 2021 via a number
of productive email exchanges on the mailing
list.[¶](#appendix-E-1){.pilcrow}
:::
:::

::: {#contributors}
::: {#appendix-F .section}
## [Contributors](#name-contributors){.section-name .selfRef} {#name-contributors}

::: {.left dir="auto"}
[Josef \'Jeff\' Sipek]{.fn .nameRole}
:::

::: email
Email: <jeffpc@josefsipek.net>
:::
:::
:::

::: {#authors-addresses}
::: {#appendix-G .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Michael Richardson]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Sandelman Software Works]{.org}
:::

::: email
Email: <mcr+ietf@sandelman.ca>
:::

::: {.left dir="auto"}
[Carsten Bormann]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Universität Bremen TZI]{.org}
:::

::: {.left dir="auto"}
[Postfach 330440]{.street-address}
:::

::: {.left dir="auto"}
[D-28359 Bremen]{.locality}
:::

::: {.left dir="auto"}
[Germany]{.country-name}
:::

::: tel
Phone: [+49-421-218-63921](tel:+49-421-218-63921){.tel}
:::

::: email
Email: <cabo@tzi.org>
:::
:::
:::
