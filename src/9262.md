  RFC 9262         BIER-TE ARCH      October 2022
  ---------------- ----------------- --------------
  Eckert, et al.   Standards Track   \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [9262](https://www.rfc-editor.org/rfc/rfc9262){.eref}

Category:
:   Standards Track

Published:
:   October 2022

ISSN:
:   2070-1721

Authors:

:   ::: author
    ::: author-name
    T. Eckert, [Ed.]{.editor}
    :::

    ::: org
    Futurewei
    :::
    :::

    ::: author
    ::: author-name
    M. Menth
    :::

    ::: org
    University of Tuebingen
    :::
    :::

    ::: author
    ::: author-name
    G. Cauchie
    :::

    ::: org
    KOEVOO
    :::
    :::
:::

# RFC 9262 {#rfcnum}

# Tree Engineering for Bit Index Explicit Replication (BIER-TE) {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This memo describes per-packet stateless strict and loose path steered
replication and forwarding for \"Bit Index Explicit Replication\" (BIER)
packets (RFC 8279); it is called \"Tree Engineering for Bit Index
Explicit Replication\" (BIER-TE) and is intended to be used as the path
steering mechanism for Traffic Engineering with
BIER.[¶](#section-abstract-1){.pilcrow}

BIER-TE introduces a new semantic for \"bit positions\" (BPs). These BPs
indicate adjacencies of the network topology, as opposed to (non-TE)
BIER in which BPs indicate \"Bit-Forwarding Egress Routers\" (BFERs). A
BIER-TE \"packets BitString\" therefore indicates the edges of the
(loop-free) tree across which the packets are forwarded by BIER-TE.
BIER-TE can leverage BIER forwarding engines with little changes.
Co-existence of BIER and BIER-TE forwarding in the same domain is
possible \-- for example, by using separate BIER \"subdomains\" (SDs).
Except for the optional routed adjacencies, BIER-TE does not require a
BIER routing underlay and can therefore operate without depending on a
routing protocol such as the \"Interior Gateway Protocol\"
(IGP).[¶](#section-abstract-2){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc9262>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2022 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Revised BSD License text as described in Section 4.e of the Trust Legal
Provisions and are provided without warranty as described in the Revised
BSD License.[¶](#section-boilerplate.2-2){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.auto .internal
    .xref}.  [Overview](#name-overview){.internal .xref}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.auto .internal
    .xref}.  [Introduction](#name-introduction){.internal .xref}

    -   ::: {#section-toc.1-1.2.2.1}
        [2.1](#section-2.1){.auto .internal .xref}.  [Requirements
        Language](#name-requirements-language){.internal .xref}
        :::

    -   ::: {#section-toc.1-1.2.2.2}
        [2.2](#section-2.2){.auto .internal .xref}.  [Basic
        Examples](#name-basic-examples){.internal .xref}
        :::

    -   ::: {#section-toc.1-1.2.2.3}
        [2.3](#section-2.3){.auto .internal .xref}.  [BIER-TE Topology
        and Adjacencies](#name-bier-te-topology-and-adjace){.internal
        .xref}
        :::

    -   ::: {#section-toc.1-1.2.2.4}
        [2.4](#section-2.4){.auto .internal .xref}.  [Relationship to
        BIER](#name-relationship-to-bier){.internal .xref}
        :::

    -   ::: {#section-toc.1-1.2.2.5}
        [2.5](#section-2.5){.auto .internal .xref}.  [Accelerated
        Hardware Forwarding
        Comparison](#name-accelerated-hardware-forwar){.internal .xref}
        :::
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.auto .internal
    .xref}.  [Components](#name-components){.internal .xref}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.auto .internal .xref}.  [The Multicast Flow
        Overlay](#name-the-multicast-flow-overlay){.internal .xref}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.auto .internal .xref}.  [The BIER-TE
        Control Plane](#name-the-bier-te-control-plane){.internal .xref}

        -   ::: {#section-toc.1-1.3.2.2.2.1}
            [3.2.1](#section-3.2.1){.auto .internal .xref}.  [The
            BIER-TE Controller](#name-the-bier-te-controller){.internal
            .xref}

            -   ::: {#section-toc.1-1.3.2.2.2.1.2.1}
                [3.2.1.1](#section-3.2.1.1){.auto .internal
                .xref}.  [BIER-TE Topology Discovery and
                Creation](#name-bier-te-topology-discovery-){.internal
                .xref}
                :::

            -   ::: {#section-toc.1-1.3.2.2.2.1.2.2}
                [3.2.1.2](#section-3.2.1.2){.auto .internal
                .xref}.  [Engineered Trees via
                BitStrings](#name-engineered-trees-via-bitstr){.internal
                .xref}
                :::

            -   ::: {#section-toc.1-1.3.2.2.2.1.2.3}
                [3.2.1.3](#section-3.2.1.3){.auto .internal
                .xref}.  [Changes in the Network
                Topology](#name-changes-in-the-network-topo){.internal
                .xref}
                :::

            -   ::: {#section-toc.1-1.3.2.2.2.1.2.4}
                [3.2.1.4](#section-3.2.1.4){.auto .internal
                .xref}.  [Link/Node Failures and
                Recovery](#name-link-node-failures-and-reco){.internal
                .xref}
                :::
            :::
        :::

    -   ::: {#section-toc.1-1.3.2.3}
        [3.3](#section-3.3){.auto .internal .xref}.  [The BIER-TE
        Forwarding Plane](#name-the-bier-te-forwarding-plan){.internal
        .xref}
        :::

    -   ::: {#section-toc.1-1.3.2.4}
        [3.4](#section-3.4){.auto .internal .xref}.  [The Routing
        Underlay](#name-the-routing-underlay){.internal .xref}
        :::

    -   ::: {#section-toc.1-1.3.2.5}
        [3.5](#section-3.5){.auto .internal .xref}.  [Traffic
        Engineering
        Considerations](#name-traffic-engineering-conside){.internal
        .xref}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.auto .internal .xref}.  [BIER-TE
    Forwarding](#name-bier-te-forwarding){.internal .xref}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.auto .internal .xref}.  [The BIER-TE Bit
        Index Forwarding Table
        (BIFT)](#name-the-bier-te-bit-index-forwa){.internal .xref}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.auto .internal .xref}.  [Adjacency
        Types](#name-adjacency-types){.internal .xref}

        -   ::: {#section-toc.1-1.4.2.2.2.1}
            [4.2.1](#section-4.2.1){.auto .internal .xref}.  [Forward
            Connected](#name-forward-connected){.internal .xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.2}
            [4.2.2](#section-4.2.2){.auto .internal .xref}.  [Forward
            Routed](#name-forward-routed){.internal .xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.3}
            [4.2.3](#section-4.2.3){.auto .internal
            .xref}.  [ECMP](#name-ecmp){.internal .xref}
            :::

        -   ::: {#section-toc.1-1.4.2.2.2.4}
            [4.2.4](#section-4.2.4){.auto .internal .xref}.  [Local
            Decap(sulation)](#name-local-decapsulation){.internal .xref}
            :::
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.auto .internal .xref}.  [Encapsulation /
        Co-existence with
        BIER](#name-encapsulation-co-existence-){.internal .xref}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.auto .internal .xref}.  [BIER-TE Forwarding
        Pseudocode](#name-bier-te-forwarding-pseudoco){.internal .xref}
        :::

    -   ::: {#section-toc.1-1.4.2.5}
        [4.5](#section-4.5){.auto .internal .xref}.  [BFR Requirements
        for BIER-TE
        Forwarding](#name-bfr-requirements-for-bier-t){.internal .xref}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.auto .internal .xref}.  [BIER-TE Controller
    Operational
    Considerations](#name-bier-te-controller-operatio){.internal .xref}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.auto .internal .xref}.  [Bit Position
        Assignments](#name-bit-position-assignments){.internal .xref}

        -   ::: {#section-toc.1-1.5.2.1.2.1}
            [5.1.1](#section-5.1.1){.auto .internal .xref}.  [P2P
            Links](#name-p2p-links){.internal .xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.2}
            [5.1.2](#section-5.1.2){.auto .internal
            .xref}.  [BFERs](#name-bfers){.internal .xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.3}
            [5.1.3](#section-5.1.3){.auto .internal .xref}.  [Leaf
            BFERs](#name-leaf-bfers){.internal .xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.4}
            [5.1.4](#section-5.1.4){.auto .internal
            .xref}.  [LANs](#name-lans){.internal .xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.5}
            [5.1.5](#section-5.1.5){.auto .internal .xref}.  [Hub and
            Spoke](#name-hub-and-spoke){.internal .xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.6}
            [5.1.6](#section-5.1.6){.auto .internal
            .xref}.  [Rings](#name-rings){.internal .xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.7}
            [5.1.7](#section-5.1.7){.auto .internal .xref}.  [Equal-Cost
            Multipath (ECMP)](#name-equal-cost-multipath-ecmp){.internal
            .xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.8}
            [5.1.8](#section-5.1.8){.auto .internal .xref}.  [Forward
            Routed
            Adjacencies](#name-forward-routed-adjacencies){.internal
            .xref}

            -   ::: {#section-toc.1-1.5.2.1.2.8.2.1}
                [5.1.8.1](#section-5.1.8.1){.auto .internal
                .xref}.  [Reducing Bit
                Positions](#name-reducing-bit-positions){.internal
                .xref}
                :::

            -   ::: {#section-toc.1-1.5.2.1.2.8.2.2}
                [5.1.8.2](#section-5.1.8.2){.auto .internal
                .xref}.  [Supporting Nodes without
                BIER-TE](#name-supporting-nodes-without-bi){.internal
                .xref}
                :::
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.9}
            [5.1.9](#section-5.1.9){.auto .internal .xref}.  [Reuse of
            Bit Positions (without
            DNC)](#name-reuse-of-bit-positions-with){.internal .xref}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.10}
            [5.1.10](#section-5.1.10){.auto .internal .xref}. [Summary
            of BP
            Optimizations](#name-summary-of-bp-optimizations){.internal
            .xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.2}
        [5.2](#section-5.2){.auto .internal .xref}.  [Avoiding
        Duplicates and
        Loops](#name-avoiding-duplicates-and-loo){.internal .xref}

        -   ::: {#section-toc.1-1.5.2.2.2.1}
            [5.2.1](#section-5.2.1){.auto .internal
            .xref}.  [Loops](#name-loops){.internal .xref}
            :::

        -   ::: {#section-toc.1-1.5.2.2.2.2}
            [5.2.2](#section-5.2.2){.auto .internal
            .xref}.  [Duplicates](#name-duplicates){.internal .xref}
            :::
        :::

    -   ::: {#section-toc.1-1.5.2.3}
        [5.3](#section-5.3){.auto .internal .xref}.  [Managing SIs,
        Subdomains, and
        BFR-ids](#name-managing-sis-subdomains-and){.internal .xref}

        -   ::: {#section-toc.1-1.5.2.3.2.1}
            [5.3.1](#section-5.3.1){.auto .internal .xref}.  [Why SIs
            and Subdomains?](#name-why-sis-and-subdomains){.internal
            .xref}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.2}
            [5.3.2](#section-5.3.2){.auto .internal .xref}.  [Assigning
            Bits for the BIER-TE
            Topology](#name-assigning-bits-for-the-bier){.internal
            .xref}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.3}
            [5.3.3](#section-5.3.3){.auto .internal .xref}.  [Assigning
            BFR-ids with
            BIER-TE](#name-assigning-bfr-ids-with-bier){.internal .xref}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.4}
            [5.3.4](#section-5.3.4){.auto .internal .xref}.  [Mapping
            from BFRs to BitStrings with
            BIER-TE](#name-mapping-from-bfrs-to-bitstr){.internal .xref}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.5}
            [5.3.5](#section-5.3.5){.auto .internal .xref}.  [Assigning
            BFR-ids for
            BIER-TE](#name-assigning-bfr-ids-for-bier-){.internal .xref}
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.6}
            [5.3.6](#section-5.3.6){.auto .internal .xref}.  [Example
            Bit Allocations](#name-example-bit-allocations){.internal
            .xref}

            -   ::: {#section-toc.1-1.5.2.3.2.6.2.1}
                [5.3.6.1](#section-5.3.6.1){.auto .internal
                .xref}.  [With BIER](#name-with-bier){.internal .xref}
                :::

            -   ::: {#section-toc.1-1.5.2.3.2.6.2.2}
                [5.3.6.2](#section-5.3.6.2){.auto .internal
                .xref}.  [With BIER-TE](#name-with-bier-te){.internal
                .xref}
                :::
            :::

        -   ::: {#section-toc.1-1.5.2.3.2.7}
            [5.3.7](#section-5.3.7){.auto .internal
            .xref}.  [Summary](#name-summary){.internal .xref}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.auto .internal .xref}.  [Security
    Considerations](#name-security-considerations){.internal .xref}
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.auto .internal .xref}.  [IANA
    Considerations](#name-iana-considerations){.internal .xref}
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.auto .internal
    .xref}.  [References](#name-references){.internal .xref}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.auto .internal .xref}.  [Normative
        References](#name-normative-references){.internal .xref}
        :::

    -   ::: {#section-toc.1-1.8.2.2}
        [8.2](#section-8.2){.auto .internal .xref}.  [Informative
        References](#name-informative-references){.internal .xref}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [Appendix A](#appendix-A){.auto .internal .xref}.  [BIER-TE and
    Segment Routing (SR)](#name-bier-te-and-segment-routing){.internal
    .xref}
    :::

-   ::: {#section-toc.1-1.10}
    [](#appendix-B){.auto .internal
    .xref}[Acknowledgements](#name-acknowledgements){.internal .xref}
    :::

-   ::: {#section-toc.1-1.11}
    [](#appendix-C){.auto .internal .xref}[Authors\'
    Addresses](#name-authors-addresses){.internal .xref}
    :::
:::
:::

::: {#overview}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Overview](#name-overview){.section-name .selfRef} {#name-overview}

\"Tree Engineering for Bit Index Explicit Replication\" (BIER-TE) is
based on the (non-TE) BIER architecture, terminology, and packet formats
as described in \[[RFC8279](#RFC8279){.cite .xref}\] and
\[[RFC8296](#RFC8296){.cite .xref}\]. This document describes BIER-TE,
with the expectation that the reader is familiar with these two
documents.[¶](#section-1-1){.pilcrow}

BIER-TE introduces a new semantic for \"bit positions\" (BPs). These BPs
indicate adjacencies of the network topology, as opposed to (non-TE)
BIER in which BPs indicate \"Bit-Forwarding Egress Routers\" (BFERs). A
BIER-TE \"packets BitString\" therefore indicates the edges of the
(loop-free) tree across which the packets are forwarded by BIER-TE. With
BIER-TE, the \"Bit Index Forwarding Table\" (BIFT) of each
\"Bit-Forwarding Router\" (BFR) is only populated with BPs that are
adjacent to the BFR in the BIER-TE topology. Other BPs are empty in the
BIFT. The BFR replicates and forwards BIER packets to adjacent BPs that
are set in the packets. BPs are normally also cleared upon forwarding to
avoid duplicates and loops.[¶](#section-1-2){.pilcrow}

BIER-TE can leverage BIER forwarding engines with little or no changes.
It can also co-exist with BIER forwarding in the same domain \-- for
example, by using separate BIER subdomains. Except for the optional
routed adjacencies, BIER-TE does not require a BIER routing underlay and
can therefore operate without depending on a routing protocol such as
the \"Interior Gateway Protocol\" (IGP).[¶](#section-1-3){.pilcrow}

This document is structured as follows:[¶](#section-1-4){.pilcrow}

-   [[Section 2](#introduction){.auto .internal .xref} introduces
    BIER-TE with two forwarding examples, followed by an introduction to
    the new concepts of the BIER-TE (overlay) topology, and finally a
    summary of the relationship between BIER and BIER-TE and a
    discussion of accelerated hardware
    forwarding.[¶](#section-1-5.1){.pilcrow}]{#section-1-5.1}
-   [[Section 3](#components){.auto .internal .xref} describes the
    components of the BIER-TE architecture: the multicast flow overlay,
    the BIER-TE layer with the BIER-TE control plane (including the
    BIER-TE controller), the BIER-TE forwarding plane, and the routing
    underlay.[¶](#section-1-5.2){.pilcrow}]{#section-1-5.2}
-   [[Section 4](#forwarding){.auto .internal .xref} specifies the
    behavior of the BIER-TE forwarding plane with the different types of
    adjacencies and possible variations of BIER-TE forwarding
    pseudocode, and finally the mandatory and optional
    requirements.[¶](#section-1-5.3){.pilcrow}]{#section-1-5.3}
-   [[Section 5](#controller-ops){.auto .internal .xref} describes
    operational considerations for the BIER-TE controller, primarily how
    the BIER-TE controller can optimize the use of BPs by using specific
    types of BIER-TE adjacencies for different types of topological
    situations. It also describes how to assign bits to avoid loops and
    duplicates (which, in BIER-TE, does not come \"for free\"). Finally,
    it discusses how \"Set Identifiers\" (SIs), \"subdomains\" (SDs),
    and BFR-ids can be managed by a BIER-TE controller; examples and a
    summary are provided.[¶](#section-1-5.4){.pilcrow}]{#section-1-5.4}
-   [[Appendix A](#SR){.auto .internal .xref} concludes this document;
    details regarding the relationship between BIER-TE and \"Segment
    Routing\" (SR) are
    discussed.[¶](#section-1-5.5){.pilcrow}]{#section-1-5.5}

Note that related work \[[CONSTRAINED-CAST](#I-D.ietf-roll-ccast){.cite
.xref}\] uses Bloom filters \[[Bloom70](#Bloom70){.cite .xref}\] to
represent leaves or edges of the intended delivery tree. Bloom filters
in general can support larger trees/topologies with fewer addressing
bits than explicit BitStrings, but they introduce the heuristic risk of
false positives and cannot clear bits in the BitStrings during
forwarding to avoid loops. For these reasons, BIER-TE, like BIER, uses
explicit BitStrings. Explicit BitStrings as used by BIER-TE can also be
seen as a special type of Bloom filter, and this is how other related
work \[[ICC](#ICC){.cite .xref}\] describes
it.[¶](#section-1-6){.pilcrow}
:::
:::

::: {#introduction}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

::: {#boilerplate}
::: {#section-2.1 .section}
### [2.1.](#section-2.1){.section-number .selfRef} [Requirements Language](#name-requirements-language){.section-name .selfRef} {#name-requirements-language}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.cite .xref}\]
\[[RFC8174](#RFC8174){.cite .xref}\] when, and only when, they appear in
all capitals, as shown here.[¶](#section-2.1-1){.pilcrow}
:::
:::

::: {#examples}
::: {#section-2.2 .section}
### [2.2.](#section-2.2){.section-number .selfRef} [Basic Examples](#name-basic-examples){.section-name .selfRef} {#name-basic-examples}

BIER-TE forwarding is best introduced with simple examples. These
examples use formal terms defined later in this document ([Figure
4](#adjacencies){.auto .internal .xref} in [Section 4.1](#btft){.auto
.internal .xref}), including forward_connected(), forward_routed(), and
local_decap().[¶](#section-2.2-1){.pilcrow}

Consider the simple network in the BIER-TE overview example shown in
[Figure 1](#basic-example){.auto .internal .xref}, with six BFRs.
 p1\...p15 are the bit positions used. All BFRs can act as a
\"Bit-Forwarding Ingress Router\" (BFIR); BFR1, BFR3, BFR4, and BFR6 can
also be BFERs. \"Forward_connected()\" is the name used for adjacencies
that represent subnet adjacencies of the network. \"Local_decap()\" is
the name used for the adjacency that decapsulates BIER-TE packets and
passes their payload to higher-layer
processing.[¶](#section-2.2-2){.pilcrow}

[]{#name-bier-te-basic-example}

::: {#basic-example}
::: {#section-2.2-3.1 .alignLeft .art-text .artwork}
    BIER-TE Topology:

       Diagram:

                        p5    p6
                      --- BFR3 ---
                   p3/    p13     \p7          p15
       BFR1 ---- BFR2              BFR5 ----- BFR6
          p1   p2  p4\    p14     /p10 p11   p12
                      --- BFR4 ---
                        p8    p9

       (simplified) BIER-TE Bit Index Forwarding Tables (BIFTs):

       BFR1:   p1  -> local_decap()
               p2  -> forward_connected() to BFR2

       BFR2:   p1  -> forward_connected() to BFR1
               p5  -> forward_connected() to BFR3
               p8  -> forward_connected() to BFR4

       BFR3:   p3  -> forward_connected() to BFR2
               p7  -> forward_connected() to BFR5
               p13 -> local_decap()

       BFR4:   p4  -> forward_connected() to BFR2
               p10 -> forward_connected() to BFR5
               p14 -> local_decap()

       BFR5:   p6  -> forward_connected() to BFR3
               p9  -> forward_connected() to BFR4
               p12 -> forward_connected() to BFR6

       BFR6:   p11 -> forward_connected() to BFR5
               p15 -> local_decap()
:::

[Figure 1](#figure-1){.selfRef}: [BIER-TE Basic
Example](#name-bier-te-basic-example){.selfRef}
:::

Assume that a packet from BFR1 should be sent via BFR4 to BFR6. This
requires a BitString (p2,p8,p10,p12,p15). When this packet is examined
by BIER-TE on BFR1, the only bit position from the BitString that is
also set in the BIFT is p2. This will cause BFR1 to send the only copy
of the packet to BFR2. Similarly, BFR2 will forward to BFR4 because of
p8, BFR4 to BFR5 because of p10, and BFR5 to BFR6 because of p12.  p15
finally makes BFR6 receive and decapsulate the
packet.[¶](#section-2.2-4){.pilcrow}

To send a copy to BFR6 via BFR4 and also a copy to BFR3, the BitString
needs to be (p2,p5,p8,p10,p12,p13,p15). When this packet is examined by
BFR2, p5 causes one copy to be sent to BFR3 and p8 one copy to BFR4.
When BFR3 receives the packet, p13 will cause it to receive and
decapsulate the packet.[¶](#section-2.2-5){.pilcrow}

If instead the BitString was (p2,p6,p8,p10,p12,p13,p15), the packet
would be copied by BFR5 towards BFR3 because of p6 instead of being
copied by BFR2 to BFR3 because of p5 in the prior case. This
demonstrates the ability of the BIER-TE topology, as shown in [Figure
1](#basic-example){.auto .internal .xref}, to make the traffic pass
across any possible path and be replicated where
desired.[¶](#section-2.2-6){.pilcrow}

BIER-TE has various options for minimizing BP assignments, many of which
are based on out-of-band knowledge about the required multicast traffic
paths and bandwidth consumption in the network, e.g., from predeployment
planning.[¶](#section-2.2-7){.pilcrow}

[Figure 2](#basic-overlay){.auto .internal .xref} shows a modified
example, in which Rtr2 and Rtr5 are assumed not to support BIER-TE, so
traffic has to be unicast encapsulated across them. To explicitly
distinguish routed/tunneled forwarding of BIER-TE packets from Layer 2
forwarding (forward_connected()), these adjacencies are called
\"forward_routed()\" adjacencies. Otherwise, there is no difference in
their processing over the aforementioned forward_connected()
adjacencies.[¶](#section-2.2-8){.pilcrow}

In addition, bits are saved in the following example by assuming that
BFR1 only needs to be a BFIR \-- not a BFER or a transit
BFR.[¶](#section-2.2-9){.pilcrow}

[]{#name-bier-te-basic-overlay-examp}

::: {#basic-overlay}
::: {#section-2.2-10.1 .alignLeft .art-text .artwork}
    BIER-TE Topology:

       Diagram:

                       p1  p3  p7
                    ....> BFR3 <....       p5
            ........                ........>
       BFR1       (Rtr2)          (Rtr5)      BFR6
            ........                ........> p9
                    ....> BFR4 <....       p6
                       p2  p4  p8

       (simplified) BIER-TE Bit Index Forwarding Tables (BIFTs):

       BFR1:   p1  -> forward_routed() to BFR3
               p2  -> forward_routed() to BFR4

       BFR3:   p3  -> local_decap()
               p5  -> forward_routed() to BFR6

       BFR4:   p4  -> local_decap()
               p6  -> forward_routed() to BFR6

       BFR6:   p7  -> forward_routed() to BFR3
               p8  -> forward_routed() to BFR4
               p9  -> local_decap()
:::

[Figure 2](#figure-2){.selfRef}: [BIER-TE Basic Overlay
Example](#name-bier-te-basic-overlay-examp){.selfRef}
:::

To send a BIER-TE packet from BFR1 via BFR3 to be received by BFR6, the
BitString is (p1,p5,p9). A packet from BFR1 via BFR4 to be received by
BFR6 uses the BitString (p2,p6,p9). A packet from BFR1 to be received by
BFR3,BFR4 and from BFR3 to be received by BFR6 uses (p1,p2,p3,p4,p5,p9).
A packet from BFR1 to be received by BFR3,BFR4 and from BFR4 to be
received by BFR6 uses (p1,p2,p3,p4,p6,p9). A packet from BFR1 to be
received by BFR4, then from BFR4 to be received by BFR6, and finally
from BFR6 to be received by BFR3, uses (p2,p3,p4,p6,p7,p9). A packet
from BFR1 to be received by BFR3, then from BFR3 to be received by BFR6,
and finally from BFR6 to be received by BFR4, uses
(p1,p3,p4,p5,p8,p9).[¶](#section-2.2-11){.pilcrow}
:::
:::

::: {#topology}
::: {#section-2.3 .section}
### [2.3.](#section-2.3){.section-number .selfRef} [BIER-TE Topology and Adjacencies](#name-bier-te-topology-and-adjace){.section-name .selfRef} {#name-bier-te-topology-and-adjace}

The key new component in BIER-TE compared to (non-TE) BIER is the
BIER-TE topology as introduced through the two examples in [Section
2.2](#examples){.auto .internal .xref}. It is used to control where
replication can or should happen and how to minimize the required number
of BPs for adjacencies.[¶](#section-2.3-1){.pilcrow}

The BIER-TE topology consists of the BIFTs of all the BFRs and can also
be expressed as a directed graph where the edges are the adjacencies
between the BFRs labeled with the BP used for the adjacency. Adjacencies
are naturally unidirectional. A BP can be reused across multiple
adjacencies as long as this does not lead to undesired duplicates or
loops, as explained in [Section 5.2](#avoiding){.auto .internal
.xref}.[¶](#section-2.3-2){.pilcrow}

If the BIER-TE topology represents (a subset of) the underlying (Layer
2) topology of the network as shown in the first example, this may be
called an \"underlay\" BIER-TE topology. A topology consisting only of
\"forward_routed()\" adjacencies as shown in the second example may be
called an \"overlay\" BIER-TE topology. A BIER-TE topology with both
forward_connected() and forward_routed() adjacencies may be called a
\"hybrid\" BIER-TE topology.[¶](#section-2.3-3){.pilcrow}
:::
:::

::: {#comparison}
::: {#section-2.4 .section}
### [2.4.](#section-2.4){.section-number .selfRef} [Relationship to BIER](#name-relationship-to-bier){.section-name .selfRef} {#name-relationship-to-bier}

BIER-TE is designed so that its forwarding plane is a simple extension
to the (non-TE) BIER forwarding plane, hence allowing it to be added to
BIER deployments where it can be
beneficial.[¶](#section-2.4-1){.pilcrow}

BIER-TE is also intended as an option to expand the BIER architecture
into deployments where (non-TE) BIER may not be the best fit, such as
statically provisioned networks that need path steering but do not want
distributed routing protocols.[¶](#section-2.4-2){.pilcrow}

1.  ::: {#section-2.4-3.1}
    BIER-TE inherits the following aspects from BIER
    unchanged:[¶](#section-2.4-3.1.1){.pilcrow}

    []{.break}

    1.a
    :   The fundamental purpose of per-packet signaled replication and
        delivery via a BitString.[¶](#section-2.4-3.1.2.1){.pilcrow}
    :   

    1.b
    :   The overall architecture, which consists of three layers: the
        flow overlay, the BIER(-TE) layer, and the routing
        underlay.[¶](#section-2.4-3.1.2.2){.pilcrow}
    :   

    1.c
    :   The supported encapsulations \[[RFC8296](#RFC8296){.cite
        .xref}\].[¶](#section-2.4-3.1.2.3){.pilcrow}
    :   

    1.d
    :   The semantics of all BIER header elements
        \[[RFC8296](#RFC8296){.cite .xref}\] used by the BIER-TE
        forwarding plane, other than the semantic of the BP in the
        BitString.[¶](#section-2.4-3.1.2.4){.pilcrow}
    :   

    1.e
    :   The BIER forwarding plane, except for how bits have to be
        cleared during replication.[¶](#section-2.4-3.1.2.5){.pilcrow}
    :   
    :::

2.  ::: {#section-2.4-3.2}
    BIER-TE has the following key changes with respect to
    BIER:[¶](#section-2.4-3.2.1){.pilcrow}

    []{.break}

    2.a
    :   In BIER, bits in the BitString of a BIER packet header indicate
        a BFER, and bits in the BIFT indicate the BIER control plane\'s
        calculated next hop towards that BFER. In BIER-TE, a bit in the
        BitString of a BIER packet header indicates an adjacency in the
        BIER-TE topology, and only the BFR that is the upstream of that
        adjacency has its BP populated with the adjacency in its
        BIFT.[¶](#section-2.4-3.2.2.1){.pilcrow}
    :   

    2.b
    :   In BIER, the implied reference options for the core part of the
        BIER layer control plane are the BIER extensions for distributed
        routing protocols. These include IS-IS and OSPF extensions for
        BIER, as specified in \[[RFC8401](#RFC8401){.cite .xref}\] and
        \[[RFC8444](#RFC8444){.cite .xref}\],
        respectively.[¶](#section-2.4-3.2.2.2){.pilcrow}
    :   

    2.c
    :   The reference option for the core part of the BIER-TE control
        plane is the BIER-TE controller. Nevertheless, both the BIER and
        BIER-TE BIFTs\' forwarding plane state could equally be
        populated by any mechanism.[¶](#section-2.4-3.2.2.3){.pilcrow}
    :   

    2.d
    :   Assuming the reference options for the control plane, BIER-TE
        replaces in-network autonomous path calculations with explicit
        paths calculated by the BIER-TE
        controller.[¶](#section-2.4-3.2.2.4){.pilcrow}
    :   
    :::

3.  ::: {#section-2.4-3.3}
    The following elements/functions described in the BIER architecture
    are not required by the BIER-TE
    architecture:[¶](#section-2.4-3.3.1){.pilcrow}

    []{.break}

    3.a
    :   \"Bit Index Routing Tables\" (BIRTs) are not required on BFRs
        for BIER-TE when using a BIER-TE controller, because the
        controller can directly populate the BIFTs. In BIER, BIRTs are
        populated by the distributed routing protocol support for BIER,
        allowing BFRs to populate their BIFTs locally from their BIRTs.
        Other BIER-TE control plane or management plane options may
        introduce requirements for BIRTs for BIER-TE
        BFRs.[¶](#section-2.4-3.3.2.1){.pilcrow}
    :   

    3.b
    :   The BIER-TE layer forwarding plane does not require BFRs to have
        a unique BP; see [Section 5.1.3](#leaf-bfer){.auto .internal
        .xref}. Therefore, BFRs may not have a unique BFR-id; see
        [Section 5.3.3](#bfr-id){.auto .internal
        .xref}.[¶](#section-2.4-3.3.2.2){.pilcrow}
    :   

    3.c
    :   Identification of BFRs by the BIER-TE control plane is outside
        the scope of this specification. Whereas the BIER control plane
        uses BFR-ids in its BFR-to-BFR signaling, a BIER-TE controller
        may choose any form of identification deemed
        appropriate.[¶](#section-2.4-3.3.2.3){.pilcrow}
    :   

    3.d
    :   BIER-TE forwarding does not require the BFIR-id field of the
        BIER packet header.[¶](#section-2.4-3.3.2.4){.pilcrow}
    :   
    :::

4.  ::: {#section-2.4-3.4}
    Co-existence of BIER and BIER-TE in the same network requires the
    following:[¶](#section-2.4-3.4.1){.pilcrow}

    []{.break}

    4.a
    :   The BIER/BIER-TE packet header needs to allow the addressing of
        both BIER and BIER-TE BIFTs. Depending on the encapsulation
        option, the same SD may or may not be reusable across BIER and
        BIER-TE. See [Section 4.3](#encapsulation){.auto .internal
        .xref}. In either case, a packet is always forwarded only end to
        end via BIER or via BIER-TE (\"ships in the night\"
        forwarding).[¶](#section-2.4-3.4.2.1){.pilcrow}
    :   

    4.b
    :   BIER-TE deployments will have to assign BFR-ids to BFRs and
        insert them into the BFIR-id field of BIER packet headers, as
        does BIER, whenever the deployment uses (unchanged) components
        developed for BIER that use BFR-ids, such as multicast flow
        overlays or BIER layer control plane elements. See also [Section
        5.3.3](#bfr-id){.auto .internal
        .xref}.[¶](#section-2.4-3.4.2.2){.pilcrow}
    :   
    :::
:::
:::

::: {#fwd-comparison}
::: {#section-2.5 .section}
### [2.5.](#section-2.5){.section-number .selfRef} [Accelerated Hardware Forwarding Comparison](#name-accelerated-hardware-forwar){.section-name .selfRef} {#name-accelerated-hardware-forwar}

BIER-TE forwarding rules, especially BitString parsing, are designed to
be as close as possible to those of BIER, with the expectation that this
eases the programming of BIER-TE forwarding code and/or BIER-TE
forwarding hardware on platforms supporting BIER. The pseudocode in
[Section 4.4](#pseudocode){.auto .internal .xref} shows how existing
(non-TE) BIER/BIFT forwarding can be modified to support the required
BIER-TE forwarding functionality ([Section 4.5](#requirements){.auto
.internal .xref}), by using the BIER BIFT\'s \"Forwarding Bit Mask\"
(F-BM): only the clearing of bits to avoid sending duplicate packets to
a BFR\'s neighbor is skipped in BIER-TE forwarding, because it is not
necessary and could not be done when using a BIER
F-BM.[¶](#section-2.5-1){.pilcrow}

Whether to use BIER or BIER-TE forwarding is simply a choice of the mode
of the BIFT indicated by the packet (BIER or BIER-TE BIFT). This is
determined by the BFR configuration for the encapsulation; see [Section
4.3](#encapsulation){.auto .internal
.xref}.[¶](#section-2.5-2){.pilcrow}
:::
:::
:::
:::

::: {#components}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Components](#name-components){.section-name .selfRef} {#name-components}

BIER-TE can be thought of as being composed of the same three layers as
BIER: the \"multicast flow overlay\", the \"BIER layer\", and the
\"routing underlay\". [Figure 3](#architecture){.auto .internal .xref}
also shows how the BIER layer is composed of the \"BIER-TE forwarding
plane\" and the \"BIER-TE control plane\" as represented by the
\"BIER-TE controller\".[¶](#section-3-1){.pilcrow}

[]{#name-bier-te-architecture}

::: {#architecture}
::: {#section-3-2.1 .alignLeft .art-text .artwork}
                    <------BGP/PIM----->
       |<-IGMP/PIM->  multicast flow   <-PIM/IGMP->|
                         overlay

           BIER-TE  [BIER-TE Controller] <=> [BIER-TE Topology]
           control     ^      ^     ^
           plane      /       |      \   BIER-TE control protocol
                     |        |       |  (e.g., YANG/NETCONF/RESTCONF
                     |        |       |       PCEP/...)
                     v        v       v
     Src -> Rtr1 -> BFIR-----BFR-----BFER -> Rtr2 -> Rcvr

                    |<----------------->|
                  BIER-TE forwarding plane

                    |<- BIER-TE domain->|

                  |<--------------------->|
                      Routing underlay
:::

[Figure 3](#figure-3){.selfRef}: [BIER-TE
Architecture](#name-bier-te-architecture){.selfRef}
:::

::: {#flow-overlay}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [The Multicast Flow Overlay](#name-the-multicast-flow-overlay){.section-name .selfRef} {#name-the-multicast-flow-overlay}

The multicast flow overlay has the same role as that described for BIER
in \[[RFC8279](#RFC8279){.cite .xref}\], [Section
4.3](https://www.rfc-editor.org/rfc/rfc8279#section-4.3){.relref}. See
also [Section 3.2.1.2](#engineered-bitstrings){.auto .internal
.xref}.[¶](#section-3.1-1){.pilcrow}

When a BIER-TE controller is used, it might also be preferable that
multicast flow overlay signaling be performed through a central point of
control. For BGP-based overlay flow services such as \"[Multicast VPN
Using Bit Index Explicit Replication (BIER)](#RFC8556){.internal
.xref}\" \[[RFC8556](#RFC8556){.cite .xref}\], this can be achieved by
making the BIER-TE controller operate as a BGP Route Reflector
\[[RFC4456](#RFC4456){.cite .xref}\] and combining it with signaling
through BGP or a different protocol for the BIER-TE controller\'s
calculated BitStrings. See
Sections [3.2.1.2](#engineered-bitstrings){.auto .internal .xref} and
[5.3.4](#bitstring-mappings){.auto .internal
.xref}.[¶](#section-3.1-2){.pilcrow}
:::
:::

::: {#control-plane}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [The BIER-TE Control Plane](#name-the-bier-te-control-plane){.section-name .selfRef} {#name-the-bier-te-control-plane}

In the (non-TE) BIER architecture \[[RFC8279](#RFC8279){.cite .xref}\],
the BIER layer is summarized in [Section
4.2](https://www.rfc-editor.org/rfc/rfc8279#section-4.2){.relref} of
\[[RFC8279](#RFC8279){.cite .xref}\]. This summary includes both the
functions of the BIER-layer control plane and forwarding plane, without
using those terms. Example standardized options for the BIER control
plane include IS-IS and OSPF extensions for BIER, as specified in
\[[RFC8401](#RFC8401){.cite .xref}\] and \[[RFC8444](#RFC8444){.cite
.xref}\], respectively.[¶](#section-3.2-1){.pilcrow}

For BIER-TE, the control plane includes, at a minimum, the following
functionality.[¶](#section-3.2-2){.pilcrow}

1.  ::: {#section-3.2-3.1}
    BIER-TE topology control: During initial provisioning of the network
    and/or during modifications of its topology and/or services, the
    protocols and/or procedures to establish BIER-TE
    BIFTs:[¶](#section-3.2-3.1.1){.pilcrow}

    []{.break}

    1.a

    :   ::: {#topology-control-1}
        Determine the desired BIER-TE topology for BIER-TE subdomains:
        the adjacencies that are assigned to BPs. Topology discovery is
        discussed in [Section 3.2.1.1](#topology-discovery){.auto
        .internal .xref}, and the various aspects of the BIER-TE
        controller\'s determinations regarding the topology are
        discussed throughout [Section 5](#controller-ops){.auto
        .internal .xref}.[¶](#topology-control-1){.pilcrow}
        :::

    :   

    1.b
    :   Determine the per-BFR BIFT from the BIER-TE topology. This is
        achieved by simply extracting the adjacencies of the BFR from
        the BIER-TE topology and populating the BFR\'s BIFT with
        them.[¶](#section-3.2-3.1.2.2){.pilcrow}
    :   

    1.c
    :   Optionally assign BFR-ids to BFIRs for later insertion into BIER
        headers on BFIRs as BFIR-ids. Alternatively, BFIR-ids in BIER
        packet headers may be managed solely by the flow overlay layer
        and/or be unused. This is discussed in [Section
        5.3.3](#bfr-id){.auto .internal
        .xref}.[¶](#section-3.2-3.1.2.3){.pilcrow}
    :   

    1.d
    :   Install/update the BIFTs into the BFRs and, optionally, BFR-ids
        into BFIRs. This is discussed in [Section
        3.2.1.1](#topology-discovery){.auto .internal
        .xref}.[¶](#section-3.2-3.1.2.4){.pilcrow}
    :   
    :::

2.  ::: {#section-3.2-3.2}
    ::: {#tree-control}
    BIER-TE tree control: During network operations, protocols and/or
    procedures to support creation/change/removal of overlay flows on
    BFIRs:[¶](#section-3.2-3.2.1){.pilcrow}
    :::

    []{.break}

    2.a
    :   Process the BIER-TE requirements for the multicast overlay flow:
        BFIRs and BFERs of the flow as well as policies for the path
        selection of the flow. This is discussed in [Section
        3.5](#te-considerations){.auto .internal
        .xref}.[¶](#section-3.2-3.2.2.1){.pilcrow}
    :   

    2.b
    :   Determine the BitStrings and, optionally, entropy. BitStrings
        are discussed in
        Sections [3.2.1.2](#engineered-bitstrings){.auto .internal
        .xref}, [3.5](#te-considerations){.auto .internal .xref}, and
        [5.3.4](#bitstring-mappings){.auto .internal .xref}. Entropy is
        discussed in [Section 4.2.3](#forward-ecmp){.auto .internal
        .xref}.[¶](#section-3.2-3.2.2.2){.pilcrow}
    :   

    2.c
    :   Install state on the BFIR to impose the desired BIER packet
        header(s) for packets of the overlay flow. Different aspects of
        this point, as well as the next point, are discussed throughout
        [Section 3.2.1](#bier-te-controller){.auto .internal .xref} and
        in [Section 4.3](#encapsulation){.auto .internal .xref}. The
        main component responsible for these two points is the multicast
        flow overlay ([Section 3.1](#flow-overlay){.auto .internal
        .xref}), which is architecturally inherited from
        BIER.[¶](#section-3.2-3.2.2.3){.pilcrow}
    :   

    2.d
    :   Install the necessary state on the BFERs to decapsulate the BIER
        packet header and properly dispatch its
        payload.[¶](#section-3.2-3.2.2.4){.pilcrow}
    :   
    :::

::: {#bier-te-controller}
::: {#section-3.2.1 .section}
#### [3.2.1.](#section-3.2.1){.section-number .selfRef} [The BIER-TE Controller](#name-the-bier-te-controller){.section-name .selfRef} {#name-the-bier-te-controller}

This architecture describes the BIER-TE control plane, as shown in
[Figure 3](#architecture){.auto .internal .xref}, as consisting
of:[¶](#section-3.2.1-1){.pilcrow}

-   [A BIER-TE
    controller.[¶](#section-3.2.1-2.1){.pilcrow}]{#section-3.2.1-2.1}
-   [BFR data models and protocols to communicate between the controller
    and BFRs in support of [BIER-TE topology
    control](#topology-control-1){.internal .xref} (see the list under
    \"BIER-TE topology control\"), such as YANG/NETCONF/RESTCONF
    \[[RFC7950](#RFC7950){.cite .xref}\] \[[RFC6241](#RFC6241){.cite
    .xref}\] \[[RFC8040](#RFC8040){.cite
    .xref}\].[¶](#section-3.2.1-2.2){.pilcrow}]{#section-3.2.1-2.2}
-   [BFR data models and protocols to communicate between the controller
    and BFIRs in support of [BIER-TE tree
    control](#tree-control){.internal .xref} (see [Section
    3.2](#control-plane){.auto .internal .xref}, point 2.), such as
    BIER-TE extensions for \[[RFC5440](#RFC5440){.cite
    .xref}\].[¶](#section-3.2.1-2.3){.pilcrow}]{#section-3.2.1-2.3}

The single, centralized BIER-TE controller is used in this document as
the reference option for the BIER-TE control plane, but other options
are equally feasible. The BIER-TE control plane could equally be
implemented without automated configuration/protocols, by an operator
via a CLI on the BFRs. In that case, operator-configured local policy on
the BFIR would have to determine how to set the appropriate BIER header
fields. The BIER-TE control plane could also be decentralized and/or
distributed, but this document does not consider any additional
protocols and/or procedures that would then be necessary to coordinate
its (distributed/decentralized) entities to achieve the above-described
functionality.[¶](#section-3.2.1-3){.pilcrow}

::: {#topology-discovery}
::: {#section-3.2.1.1 .section}
##### [3.2.1.1.](#section-3.2.1.1){.section-number .selfRef} [BIER-TE Topology Discovery and Creation](#name-bier-te-topology-discovery-){.section-name .selfRef} {#name-bier-te-topology-discovery-}

[The first item listed for BIER-TE topology
control](#topology-control-1){.internal .xref} ([Section
3.2](#control-plane){.auto .internal .xref}, point 1.a.) includes
network topology discovery and BIER-TE topology creation. The latter
describes the process by which a controller determines which routers are
to be configured as BFRs and the adjacencies between
them.[¶](#section-3.2.1.1-1){.pilcrow}

In statically managed networks, e.g., industrial environments, both
discovery and creation can be a manual/offline
process.[¶](#section-3.2.1.1-2){.pilcrow}

In other networks, topology discovery may rely on such protocols as
those that include extending an IGP based on a link-state protocol into
the BIER-TE controller itself, e.g., BGP-LS \[[RFC7752](#RFC7752){.cite
.xref}\] or YANG topology \[[RFC8345](#RFC8345){.cite .xref}\], as well
as methods specific to BIER-TE \-- for example, via
\[[BIER-TE-YANG](#BIER-TE-YANG){.cite .xref}\]. These options are
non-exhaustive.[¶](#section-3.2.1.1-3){.pilcrow}

Dynamic creation of the BIER-TE topology can be as easy as mapping the
network topology 1:1 to the BIER-TE topology by assigning a BP for every
network subnet adjacency. In larger networks, it likely involves more
complex policy and optimization decisions, including how to minimize the
number of BPs required and how to assign BPs across different BitStrings
to minimize the number of duplicate packets across links when delivering
an overlay flow to BFERs using different SIs:BitStrings. These topics
are discussed in [Section 5](#controller-ops){.auto .internal
.xref}.[¶](#section-3.2.1.1-4){.pilcrow}

When the BIER-TE topology has been determined, the BIER-TE controller
pushes the BPs/adjacencies to the BIFT of the BFRs. On each BFR, only
those SIs:BPs that are adjacencies to other BFRs in the BIER-TE topology
are populated.[¶](#section-3.2.1.1-5){.pilcrow}

Communications between the BIER-TE controller and BFRs for both BIER-TE
topology control and BIER-TE tree control are ideally via standardized
protocols and data models such as NETCONF/RESTCONF/YANG/PCEP. A
vendor-specific CLI on the BFRs is also an option (as in many other
\"Software-Defined Network\" (SDN) solutions lacking definitions of
standardized data models).[¶](#section-3.2.1.1-6){.pilcrow}
:::
:::

::: {#engineered-bitstrings}
::: {#section-3.2.1.2 .section}
##### [3.2.1.2.](#section-3.2.1.2){.section-number .selfRef} [Engineered Trees via BitStrings](#name-engineered-trees-via-bitstr){.section-name .selfRef} {#name-engineered-trees-via-bitstr}

In BIER, the same set of BFERs in a single subdomain is always encoded
as the same BitString. In BIER-TE, the BitString used to reach the same
set of BFERs in the same subdomain can be different for different
overlay flows because the BitString encodes the paths towards the BFERs,
so the BitStrings from different BFIRs to the same set of BFERs will
often be different. Likewise, the BitString from the same BFIR to the
same set of BFERs can be different for different overlay flows if
different policies should be applied to those overlay flows, such as
shortest path trees, Steiner trees (minimum cost trees), diverse path
trees for redundancy, and so on.[¶](#section-3.2.1.2-1){.pilcrow}

See also \[[BIER-MCAST-OVERLAY](#BIER-MCAST-OVERLAY){.cite .xref}\] for
an application leveraging BIER-TE engineered
trees.[¶](#section-3.2.1.2-2){.pilcrow}
:::
:::

::: {#changes-in-topo}
::: {#section-3.2.1.3 .section}
##### [3.2.1.3.](#section-3.2.1.3){.section-number .selfRef} [Changes in the Network Topology](#name-changes-in-the-network-topo){.section-name .selfRef} {#name-changes-in-the-network-topo}

If the network topology changes (not failure based) so that adjacencies
that are assigned to bit positions are no longer needed, the BIER-TE
controller can reuse those bit positions for new adjacencies. First,
these bit positions need to be removed from any BFIR flow state and BFR
BIFT state. Then, they can be repopulated, first into the BIFT and then
into the BFIR.[¶](#section-3.2.1.3-1){.pilcrow}
:::
:::

::: {#failures}
::: {#section-3.2.1.4 .section}
##### [3.2.1.4.](#section-3.2.1.4){.section-number .selfRef} [Link/Node Failures and Recovery](#name-link-node-failures-and-reco){.section-name .selfRef} {#name-link-node-failures-and-reco}

When links or nodes fail or recover in the topology, BIER-TE could
quickly respond with \"Fast Reroute\" (FRR) procedures such as those
described in \[[BIER-TE-PROTECTION](#BIER-TE-PROTECTION){.cite .xref}\],
the details of which are out of scope for this document. It can also
more slowly react by recalculating the BitStrings of affected multicast
flows. This reaction is slower than the FRR procedure because the
BIER-TE controller needs to receive link/node up/down indications,
recalculate the desired BitStrings, and push them down into the BFIRs.
With FRR, this is all performed locally on a BFR receiving the adjacency
up/down notification.[¶](#section-3.2.1.4-1){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#forwarding-plane}
::: {#section-3.3 .section}
### [3.3.](#section-3.3){.section-number .selfRef} [The BIER-TE Forwarding Plane](#name-the-bier-te-forwarding-plan){.section-name .selfRef} {#name-the-bier-te-forwarding-plan}

The BIER-TE forwarding plane consists of the following
components:[¶](#section-3.3-1){.pilcrow}

1.  [On a BFIR, imposition of the BIER header for packets from overlay
    flows. This is driven by state established by the BIER-TE control
    plane, the multicast flow overlay as explained in [Section
    3.1](#flow-overlay){.auto .internal .xref}, or a combination of
    both.[¶](#section-3.3-2.1){.pilcrow}]{#section-3.3-2.1}
2.  [On BFRs (including BFIRs and BFERs), forwarding/replication of BIER
    packets according to their SD, SI, \"BitStringLength\" (BSL),
    BitString, and, optionally, entropy fields as explained in [Section
    4](#forwarding){.auto .internal .xref}. Processing of other BIER
    header fields, such as the \"Differentiated Services Code Point\"
    (DSCP) field, is outside the scope of this
    document.[¶](#section-3.3-2.2){.pilcrow}]{#section-3.3-2.2}
3.  [On BFERs, removal of the BIER header and dispatching of the payload
    according to state created by the BIER-TE control plane and/or
    overlay layer.[¶](#section-3.3-2.3){.pilcrow}]{#section-3.3-2.3}

When the BIER-TE forwarding plane receives a packet, it simply looks up
the bit positions that are set in the BitString of the packet in the
BIFT that was populated by the BIER-TE controller. For every BP that is
set in the BitString and has one or more adjacencies in the BIFT, a copy
is made according to the types of adjacencies for that BP in the BIFT.
Before sending any copies, the BFR clears all BPs in the BitString of
the packet for which the BFR has one or more adjacencies in the BIFT.
Clearing these bits prevents packets from looping when a BitString
erroneously includes a forwarding loop. When a forward_connected()
adjacency has the \"DoNotClear\" (DNC) flag set, this BP is reset for
the packet copied to that adjacency. See [Section
4.2.1](#forward-connected){.auto .internal
.xref}.[¶](#section-3.3-3){.pilcrow}
:::
:::

::: {#routing-underlay}
::: {#section-3.4 .section}
### [3.4.](#section-3.4){.section-number .selfRef} [The Routing Underlay](#name-the-routing-underlay){.section-name .selfRef} {#name-the-routing-underlay}

For forward_connected() adjacencies, BIER-TE sends BIER packets to
directly connected BIER-TE neighbors as L2 (unicast) BIER packets
without requiring a routing underlay. For forward_routed() adjacencies,
BIER-TE forwarding encapsulates a copy of the BIER packet so that it can
be delivered by the forwarding plane of the routing underlay to the
routable destination address indicated in the adjacency. See [Section
4.2.2](#forward-routed){.auto .internal .xref} for details on
forward_routed() adjacencies.[¶](#section-3.4-1){.pilcrow}

BIER relies on the routing underlay to calculate paths towards BFERs and
derive next-hop BFR adjacencies for those paths. These two steps
commonly rely on BIER-specific extensions to the routing protocols of
the routing underlay but may also be established by a controller. In
BIER-TE, the next hops for a packet are determined by the BitString
through the BIER-TE controller-established adjacencies on the BFR for
the BPs of the BitString. There is thus no need for BFR-specific routing
underlay extensions to forward BIER packets with BIER-TE
semantics.[¶](#section-3.4-2){.pilcrow}

Encapsulation parameters can be provisioned by the BIER-TE controller
into the forward_connected() or forward_routed() adjacencies directly
without relying on a routing underlay.[¶](#section-3.4-3){.pilcrow}

If the BFR intends to support FRR for BIER-TE, then the BIER-TE
forwarding plane needs to receive fast adjacency up/down notifications:
link up/down or neighbor up/down, e.g., from \"Bidirectional Forwarding
Detection\" (BFD). Providing these notifications is considered to be
part of the routing underlay in this
document.[¶](#section-3.4-4){.pilcrow}
:::
:::

::: {#te-considerations}
::: {#section-3.5 .section}
### [3.5.](#section-3.5){.section-number .selfRef} [Traffic Engineering Considerations](#name-traffic-engineering-conside){.section-name .selfRef} {#name-traffic-engineering-conside}

Traffic Engineering \[[TE-OVERVIEW](#TE-OVERVIEW){.cite .xref}\]
provides performance optimization of operational IP networks while
utilizing network resources economically and reliably. The key elements
needed to effect Traffic Engineering are policy, path steering, and
resource management. These elements require support at the
control/controller level and within the forwarding
plane.[¶](#section-3.5-1){.pilcrow}

Policy decisions are made within the BIER-TE control plane, i.e., within
BIER-TE controllers. Controllers use policy when composing BitStrings
and BFR BIFT state. The mapping of user/IP traffic to specific
BitStrings / BIER-TE flows is made based on policy. The specific details
of BIER-TE policies and how a controller uses them are out of scope for
this document.[¶](#section-3.5-2){.pilcrow}

Path steering is supported via the definition of a BitString. BitStrings
used in BIER-TE are composed based on policy and resource management
considerations. For example, when composing BIER-TE BitStrings, a
controller must take into account the resources available at each BFR
and for each BP when it is providing congestion-loss-free services such
as Rate-Controlled Service Disciplines \[[RCSD94](#RCSD94){.cite
.xref}\]. Resource availability could be provided, for example, via
routing protocol information but may also be obtained via a BIER-TE
control protocol such as NETCONF or any other protocol commonly used by
a controller to understand the resources of the network on which it
operates. The resource usage of the BIER-TE traffic admitted by the
BIER-TE controller can be solely tracked on the BIER-TE controller based
on local accounting as long as no forward_routed() adjacencies are used
(see [Section 4.2.2](#forward-routed){.auto .internal .xref} for the
definition of forward_routed() adjacencies). When forward_routed()
adjacencies are used, the paths selected by the underlying routing
protocol need to be tracked as well.[¶](#section-3.5-3){.pilcrow}

Resource management has implications for the forwarding plane beyond the
BIER-TE-defined steering of packets; this includes allocation of buffers
to guarantee the worst-case requirements for admitted RCSD traffic and
potentially policing and/or rate-shaping mechanisms, typically done via
various forms of queuing. This level of resource control, while
optional, is important in networks that wish to support congestion
management policies to control or regulate the offered traffic to
deliver different levels of service and alleviate congestion problems,
or those networks that wish to control latencies experienced by specific
traffic flows.[¶](#section-3.5-4){.pilcrow}
:::
:::
:::
:::

::: {#forwarding}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [BIER-TE Forwarding](#name-bier-te-forwarding){.section-name .selfRef} {#name-bier-te-forwarding}

::: {#btft}
::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [The BIER-TE Bit Index Forwarding Table (BIFT)](#name-the-bier-te-bit-index-forwa){.section-name .selfRef} {#name-the-bier-te-bit-index-forwa}

The BIER-TE BIFT is equivalent to the (non-TE) BIER BIFT. It exists on
every BFR running BIER-TE. For every BIER \"subdomain\" (SD) in use for
BIER-TE, the BIFT is constructed per the example shown in [Figure
4](#adjacencies){.auto .internal .xref}. The BIFT in the figure assumes
a BSL of 8 \"bit positions\" (BPs) in the packets BitString. As in
\[[RFC8279](#RFC8279){.cite .xref}\], this BSL is purely used as an
example and is not a BSL supported by BIER/BIER-TE (minimum BSL is
64).[¶](#section-4.1-1){.pilcrow}

A BIER-TE BIFT is compared to a BIER BIFT as shown in
\[[RFC8279](#RFC8279){.cite .xref}\] as
follows.[¶](#section-4.1-2){.pilcrow}

In both BIER and BIER-TE, BIFT rows/entries are indexed in their
respective BIER pseudocode (\[[RFC8279](#RFC8279){.cite .xref}\],
[Section
6.5](https://www.rfc-editor.org/rfc/rfc8279#section-6.5){.relref}) and
BIER-TE pseudocode ([Section 4.4](#pseudocode){.auto .internal .xref})
by the BIFT-index derived from the packet\'s SI, BSL, and the one bit
position of the packets BitString (BP) addressing the BIFT row:
BIFT-index = SI \* BSL + BP - 1. BPs within a BitString are numbered
from 1 to BSL \-- hence, the - 1 offset when converting to a BIFT-index.
This document also uses the notion \"SI:BP\" to indicate BIFT rows.
\[[RFC8279](#RFC8279){.cite .xref}\] uses the equivalent notion
\"SI:BitString\", where the BitString is filled with only the BPs for
the BIFT row.[¶](#section-4.1-3){.pilcrow}

In BIER, each BIFT-index addresses one BFER by its BFR-id = BIFT-index +
1 and is populated on each BFR with the next-hop \"BFR Neighbor\"
(BFR-NBR) towards that BFER.[¶](#section-4.1-4){.pilcrow}

In BIER-TE, each BIFT-index and, therefore, SI:BP indicates one or, in
the case of reuse of SI:BP, more than one adjacency between BFRs in the
topology. The SI:BP is populated with the adjacency on the upstream BFR
of the adjacency. The BIFT entries are empty on all other
BFRs.[¶](#section-4.1-5){.pilcrow}

In BIER, each BIFT row also requires a \"Forwarding Bit Mask\" (F-BM)
entry for BIER forwarding rules. In BIER-TE forwarding, an F-BM is not
required but can be used when implementing BIER-TE on forwarding
hardware, derived from BIER forwarding, that must use an F-BM. This is
discussed in the first variation of BIER-TE forwarding pseudocode shown
in [Section 4.4](#pseudocode){.auto .internal
.xref}.[¶](#section-4.1-6){.pilcrow}

[]{#name-bier-te-bit-index-forwardin}

::: {#adjacencies}
::: {#section-4.1-7.1 .alignLeft .art-text .artwork}
     -------------------------------------------------------------------
     | BIFT-index |      | Adjacencies:                                |
     | (SI:BP)    |(F-BM)| <empty> or one or more per entry            |
     ===================================================================
     |               BIFT indices for Packets with SI=0                |
     -------------------------------------------------------------------
     | 0 (0:1)    | ...  | forward_connected(interface,neighbor{,DNC}) |
     -------------------------------------------------------------------
     | 1 (0:2)    | ...  | forward_connected(interface,neighbor{,DNC}) |
     |            | ...  | forward_connected(interface,neighbor{,DNC}) |
     -------------------------------------------------------------------
     |  ...       | ...  | ...                                         |
     -------------------------------------------------------------------
     | 4 (0:5)    | ...  | local_decap({VRF})                          |
     -------------------------------------------------------------------
     | 5 (0:6)    | ...  | forward_routed({VRF,}l3-neighbor)           |
     -------------------------------------------------------------------
     | 6 (0:7)    | ...  | <empty>                                     |
     -------------------------------------------------------------------
     | 7 (0:8)    | ...  | ECMP((adjacency1,...adjacencyN){,seed})     |
     -------------------------------------------------------------------
     |           BIFT indices for BitString/Packet with SI=1           |
     -------------------------------------------------------------------
     | 9 (1:1)    |      | ...                                         |
     |  ...       | ...  | ...                                         |
     -------------------------------------------------------------------
:::

[Figure 4](#figure-4){.selfRef}: [BIER-TE Bit Index Forwarding Table
(BIFT) with Different
Adjacencies](#name-bier-te-bit-index-forwardin){.selfRef}
:::

The BIFT is configured for the BIER-TE data plane of a BFR by the
BIER-TE controller through an appropriate protocol and data model. The
BIFT is then used to forward packets, according to the procedures for
the BIER-TE forwarding plane as specified in [Section
3.3](#forwarding-plane){.auto .internal
.xref}.[¶](#section-4.1-8){.pilcrow}

Note that a BIFT-index (SI:BP) may be populated in the BIFT of more than
one BFR to save BPs. See [Section 5.1.6](#rings){.auto .internal .xref}
for an example of how a BIER-TE controller could assign BPs to (logical)
adjacencies shared across multiple BFRs, [Section
5.1.3](#leaf-bfer){.auto .internal .xref} for an example of assigning
the same BP to different adjacencies, and [Section 5.1.9](#reuse){.auto
.internal .xref} for general guidelines regarding the reuse of BPs
across different adjacencies.[¶](#section-4.1-9){.pilcrow}

{VRF} indicates the Virtual Routing and Forwarding context into which
the BIER payload is to be delivered. This is optional and depends on the
multicast flow overlay.[¶](#section-4.1-10){.pilcrow}
:::
:::

::: {#atypes}
::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Adjacency Types](#name-adjacency-types){.section-name .selfRef} {#name-adjacency-types}

::: {#forward-connected}
::: {#section-4.2.1 .section}
#### [4.2.1.](#section-4.2.1){.section-number .selfRef} [Forward Connected](#name-forward-connected){.section-name .selfRef} {#name-forward-connected}

A \"forward_connected()\" adjacency is an adjacency towards a directly
connected BFR-NBR using an interface address of that BFR on the
connecting interface. A forward_connected() adjacency does not route
packets; only L2 forwards them to the
neighbor.[¶](#section-4.2.1-1){.pilcrow}

Packets sent to an adjacency with \"DoNotClear\" (DNC) set in the BIFT
[MUST NOT]{.bcp14} have the bit position for that adjacency cleared when
the BFR creates a copy for it. The bit position will still be cleared
for copies of a packet made towards other adjacencies. This can be used,
for example, in ring topologies as explained in [Section
5.1.6](#rings){.auto .internal .xref}.[¶](#section-4.2.1-2){.pilcrow}

For protection against loops caused by misconfiguration (see [Section
5.2.1](#loops){.auto .internal .xref}), DNC is only permissible for
forward_connected() adjacencies. No need or benefit of DNC for other
types of adjacencies was identified, and associated risks were not
analyzed.[¶](#section-4.2.1-3){.pilcrow}
:::
:::

::: {#forward-routed}
::: {#section-4.2.2 .section}
#### [4.2.2.](#section-4.2.2){.section-number .selfRef} [Forward Routed](#name-forward-routed){.section-name .selfRef} {#name-forward-routed}

A \"forward_routed()\" adjacency is an adjacency towards a BFR that uses
a (tunneling) encapsulation that will cause a packet to be forwarded by
the routing underlay towards the adjacent BFR indicated via the
l3-neighbor parameter of the forward_routed() adjacency. This can
leverage any feasible encapsulation, such as MPLS or tunneling over
IP/IPv6, as long as the BIER-TE packet can be identified as a payload.
This identification can rely on either the BIER/BIER-TE co-existence
mechanisms described in [Section 4.3](#encapsulation){.auto .internal
.xref} or explicit support for a BIER-TE payload type in the tunneling
encapsulation.[¶](#section-4.2.2-1){.pilcrow}

Forward_routed() adjacencies are necessary to pass BIER-TE traffic
across routers that are not BIER-TE capable or to minimize the number of
required BPs by tunneling over (BIER-TE-capable) routers on which
neither replication nor path steering is desired, or simply to leverage
the routing underlay\'s path redundancy and FRR towards the next BFR.
They may also be useful to a multi-subnet adjacent BFR for leveraging
the routing underlay ECMP independently of BIER-TE ECMP ([Section
4.2.3](#forward-ecmp){.auto .internal
.xref}).[¶](#section-4.2.2-2){.pilcrow}
:::
:::

::: {#forward-ecmp}
::: {#section-4.2.3 .section}
#### [4.2.3.](#section-4.2.3){.section-number .selfRef} [ECMP](#name-ecmp){.section-name .selfRef} {#name-ecmp}

(Non-TE) BIER ECMP is tied to the BIER BIFT processing semantic and is
therefore not directly usable with
BIER-TE.[¶](#section-4.2.3-1){.pilcrow}

A BIER-TE \"Equal-Cost Multipath\" (ECMP()) adjacency as shown in
[Figure 4](#adjacencies){.auto .internal .xref} for BIFT-index 7 has a
list of two or more non-ECMP() adjacencies as parameters and an optional
seed parameter. When a BIER-TE packet is copied onto such an ECMP()
adjacency, an implementation-specific so-called hash function will
select one out of the list\'s adjacencies to which the packet is
forwarded. If the packet\'s encapsulation contains an entropy field, the
entropy field [SHOULD]{.bcp14} be respected; two packets with the same
value of the entropy field [SHOULD]{.bcp14} be sent on the same
adjacency. The seed parameter permits the design of hash functions that
are easy to implement at high speed without running into polarization
issues across multiple consecutive ECMP hops. See [Section
5.1.7](#ecmp){.auto .internal .xref} for
details.[¶](#section-4.2.3-2){.pilcrow}
:::
:::

::: {#forward-local}
::: {#section-4.2.4 .section}
#### [4.2.4.](#section-4.2.4){.section-number .selfRef} [Local Decap(sulation)](#name-local-decapsulation){.section-name .selfRef} {#name-local-decapsulation}

A \"local_decap()\" adjacency passes a copy of the payload of the
BIER-TE packet to the protocol (\"NextProto\") within the BFR (IP/IPv6,
Ethernet,\...) responsible for that payload according to the packet
header fields. A local_decap() adjacency turns the BFR into a BFER for
matching packets. Local_decap() adjacencies require the BFER to support
routing or switching for NextProto to determine how to further process
the packets.[¶](#section-4.2.4-1){.pilcrow}
:::
:::
:::
:::

::: {#encapsulation}
::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [Encapsulation / Co-existence with BIER](#name-encapsulation-co-existence-){.section-name .selfRef} {#name-encapsulation-co-existence-}

Specifications for BIER-TE encapsulation are outside the scope of this
document. This section gives explanations and
guidelines.[¶](#section-4.3-1){.pilcrow}

The handling of \"Maximum Transmission Unit\" (MTU) limitations is
outside the scope of this document and is not discussed in
\[[RFC8279](#RFC8279){.cite .xref}\] either. Instead, this process is
part of the BIER-TE packet encapsulation and/or flow overlay; for
example, see \[[RFC8296](#RFC8296){.cite .xref}\], [Section
3](https://www.rfc-editor.org/rfc/rfc8296#section-3){.relref}. It
applies equally to BIER-TE and BIER.[¶](#section-4.3-2){.pilcrow}

Because a BFR needs to interpret the BitString of a BIER-TE packet
differently from a (non-TE) BIER packet, it is necessary to distinguish
BIER packets from BIER-TE packets. In BIER encapsulation
\[[RFC8296](#RFC8296){.cite .xref}\], the BIFT-id field of the packet
indicates the BIFT of the packet. BIER and BIER-TE can therefore be run
simultaneously, when the BIFT-id address space is shared across BIER
BIFTs and BIER-TE BIFTs. Partitioning the BIFT-id address space is
subject to BIER-TE/BIER control plane
procedures.[¶](#section-4.3-3){.pilcrow}

When \[[RFC8296](#RFC8296){.cite .xref}\] is used for BIER with MPLS,
BIFT-id address ranges can be dynamically allocated from MPLS label
space only for the set of actually used SD:BSL BIFTs. This also permits
the allocation of non-overlapping label ranges for BIFT-ids that are to
be used with BIER-TE BIFTs.[¶](#section-4.3-4){.pilcrow}

With MPLS, it is also possible to reuse the same SD space for both
BIER-TE and BIER, so that the same SD has both a BIER BIFT with a
corresponding range of BIFT-ids and disjoint BIER-TE BIFTs with a
non-overlapping range of BIFT-ids.[¶](#section-4.3-5){.pilcrow}

Assume that a fixed mapping from BSL, SD, and SI to a BIFT-id is used,
which does not explicitly partition the BIFT-id space between BIER and
BIER-TE \-- for example, as proposed for non-MPLS forwarding with BIER
encapsulation \[[RFC8296](#RFC8296){.cite .xref}\] in
\[[NON-MPLS-BIER-ENCODING](#NON-MPLS-BIER-ENCODING){.cite .xref}\],
[Section
5](https://datatracker.ietf.org/doc/html/draft-ietf-bier-non-mpls-bift-encoding-04#section-5){.relref}.
In this case, it is necessary to allocate disjoint SDs to BIER and
BIER-TE BIFTs so that both can be addressed by the BIFT-ids. The
encoding proposed in [Section
6](https://datatracker.ietf.org/doc/html/draft-ietf-bier-non-mpls-bift-encoding-04#section-6){.relref}
of \[[NON-MPLS-BIER-ENCODING](#NON-MPLS-BIER-ENCODING){.cite .xref}\]
does not statically encode the BSL or SD into the BIFT-id, but the
encoding permits a mapping and hence could provide the same freedom as
when MPLS is being used (the same SD, or different SDs for
BIER/BIER-TE).[¶](#section-4.3-6){.pilcrow}

Forward_routed() requires an encapsulation that permits directing
unicast encapsulated BIER-TE packets to a specific interface address on
a target BFR. With MPLS encapsulation, this can simply be done via a
label stack with that address\'s label as the top label, followed by the
label assigned to the (BSL,SD,SI) BitString. With non-MPLS
encapsulation, some form of IP encapsulation would be required (for
example, IP/GRE).[¶](#section-4.3-7){.pilcrow}

The encapsulation used for forward_routed() adjacencies can equally
support existing advanced adjacency information such as \"loose source
routes\" via, for example, MPLS label stacks or appropriate header
extensions (e.g., for IPv6).[¶](#section-4.3-8){.pilcrow}
:::
:::

::: {#pseudocode}
::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [BIER-TE Forwarding Pseudocode](#name-bier-te-forwarding-pseudoco){.section-name .selfRef} {#name-bier-te-forwarding-pseudoco}

The pseudocode for BIER-TE forwarding, as shown in [Figure
5](#simple-pseudocode-picture){.auto .internal .xref}, is based on the
(non-TE) BIER forwarding pseudocode provided in
\[[RFC8279](#RFC8279){.cite .xref}\], [Section
6.5](https://www.rfc-editor.org/rfc/rfc8279#section-6.5){.relref}, with
one modification.[¶](#section-4.4-1){.pilcrow}

[]{#name-bier-te-forwarding-pseudocod}

::: {#simple-pseudocode-picture}
::: {#section-4.4-2.1}
``` {.lang-pseudocode .sourcecode}
   void ForwardBitMaskPacket_withTE (Packet)
   {
       SI=GetPacketSI(Packet);
       Offset=SI*BitStringLength;
       for (Index = GetFirstBitPosition(Packet->BitString); Index ;
            Index = GetNextBitPosition(Packet->BitString, Index)) {
           F-BM = BIFT[Index+Offset]->F-BM;
           if (!F-BM) continue;                            [3]
           BFR-NBR = BIFT[Index+Offset]->BFR-NBR;
           PacketCopy = Copy(Packet);
           PacketCopy->BitString &= F-BM;                  [2]
           PacketSend(PacketCopy, BFR-NBR);
           // The following must not be done for BIER-TE:
           // Packet->BitString &= ~F-BM;                  [1]
       }
   }
```
:::

[Figure 5](#figure-5){.selfRef}: [BIER-TE Forwarding Pseudocode for
Required Functions, Based on BIER
Pseudocode](#name-bier-te-forwarding-pseudocod){.selfRef}
:::

In step \[2\], the F-BM is used to clear one or more bits in PacketCopy.
This step exists in both BIER and BIER-TE, but the F-BMs need to be
populated differently for BIER-TE than for BIER for the desired
clearing.[¶](#section-4.4-3){.pilcrow}

In BIER, multiple bits of a BitString can have the same BFR-NBR. When a
received packets BitString has more than one of those bits set, BIER\'s
replication logic has to prevent more than one PacketCopy from being
sent to that BFR-NBR (\[1\]). Likewise, the PacketCopy sent to a BFR-NBR
must clear all bits in its BitString that are not routed across a
BFR-NBR. This prevents BIER\'s replication logic from creating
duplicates on any possible further BFRs
(\[2\]).[¶](#section-4.4-4){.pilcrow}

To solve both \[1\] and \[2\] for BIER, the F-BM of each bit index needs
to have all bits set that this BFR wants to route across a BFR-NBR.
 \[2\] clears all other bits in PacketCopy-\>BitString, and \[1\] clears
those bits from Packet-\>BitString after the first
PacketCopy.[¶](#section-4.4-5){.pilcrow}

In BIER-TE, a BFR-NBR in this pseudocode is an adjacency \--
forward_connected(), forward_routed(), or local_decap(). There is no
need for \[2\] to suppress duplicates in the same way that BIER does,
because in general, different BPs would never have the same adjacency.
If a BIER-TE controller actually finds some optimization in which this
would be desirable, then the controller is also responsible for ensuring
that only one of those bits is set in any Packet-\>BitString, unless the
controller explicitly wants duplicates to be
created.[¶](#section-4.4-6){.pilcrow}

The following points describe how the F-BM for each BP is configured in
the BIFT and how this impacts the BitString of the packet being
processed with that BIFT:[¶](#section-4.4-7){.pilcrow}

1.  [The F-BMs of all BIFT BPs without an adjacency have all their bits
    clear. This will cause \[3\] to skip further processing of such a
    BP.[¶](#section-4.4-8.1){.pilcrow}]{#section-4.4-8.1}
2.  [All BIFT BPs with an adjacency (with the DNC flag clear) have an
    F-BM that has only those BPs set for which this BFR does not have an
    adjacency. This causes \[2\] to clear all bits from
    PacketCopy-\>BitString for which this BFR does have an
    adjacency.[¶](#section-4.4-8.2){.pilcrow}]{#section-4.4-8.2}
3.  [\[1\] is not performed for BIER-TE. All bit clearing required by
    BIER-TE is performed by
    \[2\].[¶](#section-4.4-8.3){.pilcrow}]{#section-4.4-8.3}

This forwarding pseudocode can support the required BIER-TE forwarding
functions (see [Section 4.5](#requirements){.auto .internal .xref}) \--
forward_connected(), forward_routed(), and local_decap() \-- but cannot
support the recommended functions (DNC flag and multiple adjacencies per
bit) or the optional function (i.e., ECMP() adjacencies). The DNC flag
cannot be supported when using only \[1\] to mask
bits.[¶](#section-4.4-9){.pilcrow}

The modified and expanded forwarding pseudocode in [Figure
6](#pseudocode-picture){.auto .internal .xref} specifies how to support
all BIER-TE forwarding functions (required, recommended, and
optional):[¶](#section-4.4-10){.pilcrow}

1.  ::: {#section-4.4-11.1}
    This pseudocode eliminates per-bit F-BMs, therefore reducing the
    size of BIFT state by SI\*BSL^2^ and eliminating the need for
    per-packet-copy BitString masking operations, except for adjacencies
    with the DNC flag set:[¶](#section-4.4-11.1.1){.pilcrow}

    []{.break}

    1.a
    :   AdjacentBits\[SI\] are bit positions with a non-empty list of
        adjacencies in this BFR BIFT. This can be computed whenever the
        BIER-TE controller updates (adds/removes) adjacencies in the
        BIFT.[¶](#section-4.4-11.1.2.1){.pilcrow}
    :   

    1.b
    :   The BFR needs to create packet copies for these adjacent bits
        when they are set in the packets BitString. This set of bits is
        calculated in
        PktAdjacentBits.[¶](#section-4.4-11.1.2.2){.pilcrow}
    :   

    1.c
    :   All bit positions for which the BFR creates copies have to be
        cleared in packet copies to avoid loops. This is done by masking
        the BitString of the packet with \~AdjacentBits\[SI\]. When an
        adjacency has DNC set, this bit position is set again only for
        the packet copy towards that bit
        position.[¶](#section-4.4-11.1.2.3){.pilcrow}
    :   
    :::

2.  [BIFT entries may contain more than one adjacency in support of
    specific configurations, such as a hub and multiple spokes ([Section
    5.1.5](#hubnspoke){.auto .internal .xref}). The code therefore
    includes a loop over these
    adjacencies.[¶](#section-4.4-11.2){.pilcrow}]{#section-4.4-11.2}

3.  [The ECMP() adjacency is also shown in the figure. Its parameters
    are a seed and \"ListOfAdjacencies\", from which one is
    picked.[¶](#section-4.4-11.3){.pilcrow}]{#section-4.4-11.3}

4.  [The forward_connected(), forward_routed(), and local_decap()
    adjacencies are shown with their
    parameters.[¶](#section-4.4-11.4){.pilcrow}]{#section-4.4-11.4}

[]{#name-complete-bier-te-forwarding}

::: {#pseudocode-picture}
::: {#section-4.4-12.1}
``` {.lang-pseudocode .sourcecode}
 void ForwardBitMaskPacket_withTE (Packet)
 {
     SI = GetPacketSI(Packet);
     Offset = SI * BitStringLength;
     // Determine adjacent bits in the packets BitString
     PktAdjacentBits = Packet->BitString & AdjacentBits[SI];

     // Clear adjacent bits in the packet header to avoid loops
     Packet->BitString &= ~AdjacentBits[SI];

     // Loop over PktAdjacentBits to create packet copies
     for (Index = GetFirstBitPosition(PktAdjacentBits); Index ;
          Index = GetNextBitPosition(PktAdjacentBits, Index)) {
         for adjacency in BIFT[Index+Offset]->Adjacencies {
             if(adjacency.type == ECMP(ListOfAdjacencies,seed) ) {
                 I = ECMP_hash(sizeof(ListOfAdjacencies),
                               Packet->Entropy,seed);
                 adjacency = ListOfAdjacencies[I];
             }
             PacketCopy = Copy(Packet);
             switch(adjacency.type) {
                 case forward_connected(interface,neighbor,DNC):
                     if(DNC)
                         PacketCopy->BitString |= 1<<(Index-1);
                     SendToL2Unicast(PacketCopy,interface,neighbor);

                 case forward_routed({VRF,}l3-neighbor):
                     SendToL3(PacketCopy,{VRF,}l3-neighbor);

                 case local_decap({VRF},neighbor):
                     DecapBierHeader(PacketCopy);
                     PassTo(PacketCopy,{VRF,}Packet->NextProto);
             }
         }
     }
 }
```
:::

[Figure 6](#figure-6){.selfRef}: [Complete BIER-TE Forwarding Pseudocode
for Required, Recommended, and Optional
Functions](#name-complete-bier-te-forwarding){.selfRef}
:::
:::
:::

::: {#requirements}
::: {#section-4.5 .section}
### [4.5.](#section-4.5){.section-number .selfRef} [BFR Requirements for BIER-TE Forwarding](#name-bfr-requirements-for-bier-t){.section-name .selfRef} {#name-bfr-requirements-for-bier-t}

BFRs that support BIER-TE and BIER [MUST]{.bcp14} support a
configuration that enables BIER-TE instead of (non-TE) BIER forwarding
rules for all BIFTs of one or more BIER subdomains. Every BP in a
BIER-TE BIFT [MUST]{.bcp14} support having zero or one adjacency.
BIER-TE forwarding [MUST]{.bcp14} support the adjacency types
forward_connected() with the DNC flag not set, forward_routed(), and
local_decap(). As explained in [Section 4.4](#pseudocode){.auto
.internal .xref}, these required BIER-TE forwarding functions can be
implemented via the same forwarding pseudocode as that used for BIER
forwarding, except for one modification (skipping one masking with an
F-BM).[¶](#section-4.5-1){.pilcrow}

BIER-TE forwarding [SHOULD]{.bcp14} support forward_connected()
adjacencies with the DNC flag set, as this is very useful for saving
bits in rings (see [Section 5.1.6](#rings){.auto .internal
.xref}).[¶](#section-4.5-2){.pilcrow}

BIER-TE forwarding [SHOULD]{.bcp14} support more than one adjacency on a
bit. This allows bits to be saved in hub-and-spoke scenarios (see
[Section 5.1.5](#hubnspoke){.auto .internal
.xref}).[¶](#section-4.5-3){.pilcrow}

BIER-TE forwarding [MAY]{.bcp14} support ECMP() adjacencies to save bits
in ECMP scenarios; see [Section 5.1.7](#ecmp){.auto .internal .xref} for
an example. This is an optional requirement, because for ECMP
deployments using BIER-TE one can also leverage the routing underlay
ECMP via forward_routed() adjacencies and/or might prefer to have more
explicit control of the path chosen via explicit BPs/adjacencies for
each ECMP path alternative.[¶](#section-4.5-4){.pilcrow}
:::
:::
:::
:::

::: {#controller-ops}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [BIER-TE Controller Operational Considerations](#name-bier-te-controller-operatio){.section-name .selfRef} {#name-bier-te-controller-operatio}

::: {#bitpositions}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Bit Position Assignments](#name-bit-position-assignments){.section-name .selfRef} {#name-bit-position-assignments}

This section describes how the BIER-TE controller can use the different
BIER-TE adjacency types to define the bit positions of a BIER-TE
domain.[¶](#section-5.1-1){.pilcrow}

Because the size of the BitString limits the size of the BIER-TE domain,
many of the options described here exist to support larger topologies
with fewer bit positions.[¶](#section-5.1-2){.pilcrow}

::: {#p2p-links}
::: {#section-5.1.1 .section}
#### [5.1.1.](#section-5.1.1){.section-number .selfRef} [P2P Links](#name-p2p-links){.section-name .selfRef} {#name-p2p-links}

On a \"point-to-point\" (P2P) link that connects two BFRs, the same bit
position can be used on both BFRs for the adjacency to the neighboring
BFR. A P2P link therefore requires only one bit
position.[¶](#section-5.1.1-1){.pilcrow}
:::
:::

::: {#bfer}
::: {#section-5.1.2 .section}
#### [5.1.2.](#section-5.1.2){.section-number .selfRef} [BFERs](#name-bfers){.section-name .selfRef} {#name-bfers}

Every non-leaf BFER is given a unique bit position with a local_decap()
adjacency.[¶](#section-5.1.2-1){.pilcrow}
:::
:::

::: {#leaf-bfer}
::: {#section-5.1.3 .section}
#### [5.1.3.](#section-5.1.3){.section-number .selfRef} [Leaf BFERs](#name-leaf-bfers){.section-name .selfRef} {#name-leaf-bfers}

A leaf BFER is one where incoming BIER-TE packets never need to be
forwarded to another BFR but are only sent to the BFER to exit the
BIER-TE domain. For example, in networks where \"Provider Edge\" (PE)
routers are spokes connected to Provider (P) routers, those PEs are leaf
BFERs, unless there is a U-turn between two
PEs.[¶](#section-5.1.3-1){.pilcrow}

Consider how redundant disjoint traffic can reach BFER1/BFER2 as shown
in [Figure 7](#leaf-bfer-picture){.auto .internal .xref}: when
BFER1/BFER2 are non-leaf BFERs as shown on the right-hand side, one
traffic copy would be forwarded to BFER1 from BFR1, but the other one
could only reach BFER1 via BFER2, which makes BFER2 a non-leaf BFER.
Likewise, BFER1 is a non-leaf BFER when forwarding traffic to BFER2.
Note that the BFERs on the left-hand side of the figure are only
guaranteed to be leaf BFERs by correctly applying a routing
configuration that prohibits transit traffic from passing through the
BFERs, which is commonly applied in these
topologies.[¶](#section-5.1.3-2){.pilcrow}

[]{#name-leaf-vs-non-leaf-bfer-examp}

::: {#leaf-bfer-picture}
::: {#section-5.1.3-3.1 .alignLeft .art-text .artwork}
            BFR1(P) BFR2(P)             BFR1(P)  BFR2(P)
              |  \ /  |                    |       |
              |   X   |                    |       |
              |  / \  |                    |       |
         BFER1(PE)  BFER2(PE)        BFER1(PE)----BFER2(PE)

                                               ^ U-turn link

             Leaf BFER /               Non-leaf BFER /
              PE router                  PE router
:::

[Figure 7](#figure-7){.selfRef}: [Leaf vs. Non-Leaf BFER
Example](#name-leaf-vs-non-leaf-bfer-examp){.selfRef}
:::

In most situations, leaf BFERs that are to be addressed via the same
BitString can share a single bit position for their local_decap()
adjacency in that BitString and therefore save bit positions. On a
non-leaf BFER, a received BIER-TE packet may only need to transit the
BFER, or it may also need to be decapsulated. Whether or not to
decapsulate the packet therefore needs to be indicated by a unique bit
position populated only on the BIFT of this BFER with a local_decap()
adjacency. On a leaf BFER, packets never need to pass through; any
packet received is therefore usually intended to be decapsulated. This
can be expressed by a single, shared bit position that is populated with
a local_decap() adjacency on all leaf BFERs addressed by the
BitString.[¶](#section-5.1.3-4){.pilcrow}

The possible exceptions to this leaf BFER bit position optimization
scenario can be cases where the bit position on the prior BIER-TE BFR
(which created the packet copy for the leaf BFER in question) is
populated with multiple adjacencies as an optimization \-- for example,
as described in Sections [5.1.4](#lans){.auto .internal .xref} and
[5.1.5](#hubnspoke){.auto .internal .xref}. With either of these two
optimizations, the sender of the packet could only control explicitly
whether the packet was to be decapsulated on the leaf BFER in question,
if the leaf BFER has a unique bit position for its local_decap()
adjacency.[¶](#section-5.1.3-5){.pilcrow}

However, if the bit position is shared across a leaf BFER and packets
are therefore decapsulated \-- potentially unnecessarily \-- this may
still be appropriate if the decapsulated payload of the BIER-TE packet
indicates whether or not the packets need to be further
processed/received. This is typically true, for example, if the payload
is IP multicast, because IP multicast on a BFER would know the
membership state of the IP multicast payload and be able to discard it
if the packets were delivered unnecessarily by the BIER-TE layer. If the
payload has no such membership indication and the BFIR wants to have
explicit control regarding which BFERs are to receive and decapsulate a
packet, then these two optimizations cannot be used together with shared
bit position optimization for a leaf
BFER.[¶](#section-5.1.3-6){.pilcrow}
:::
:::

::: {#lans}
::: {#section-5.1.4 .section}
#### [5.1.4.](#section-5.1.4){.section-number .selfRef} [LANs](#name-lans){.section-name .selfRef} {#name-lans}

In a LAN, the adjacency to each neighboring BFR is given a unique bit
position. The adjacency of this bit position is a forward_connected()
adjacency towards the BFR, and this bit position is populated into the
BIFT of all the other BFRs on that LAN.[¶](#section-5.1.4-1){.pilcrow}

[]{#name-lan-example}

::: {#lan-picture}
::: {#section-5.1.4-2.1 .alignLeft .art-text .artwork}
                                     BFR1
                                      |p1
                               LAN1-+-+---+-----+
                                  p3|   p4|   p2|
                                  BFR3  BFR4  BFR7
:::

[Figure 8](#figure-8){.selfRef}: [LAN
Example](#name-lan-example){.selfRef}
:::

If bandwidth on the LAN is not an issue and most BIER-TE traffic should
be copied to all neighbors on a LAN, then bit positions can be saved by
assigning just a single bit position to the LAN and populating the bit
position of the BIFTs of each BFR on the LAN with a list of
forward_connected() adjacencies to all other neighbors on the
LAN.[¶](#section-5.1.4-3){.pilcrow}

This optimization does not work in the case of BFRs redundantly
connected to more than one LAN with this optimization. These BFRs would
receive duplicates and forward those duplicates into the other LANs.
Such BFRs require separate bit positions for each LAN they connect
to.[¶](#section-5.1.4-4){.pilcrow}
:::
:::

::: {#hubnspoke}
::: {#section-5.1.5 .section}
#### [5.1.5.](#section-5.1.5){.section-number .selfRef} [Hub and Spoke](#name-hub-and-spoke){.section-name .selfRef} {#name-hub-and-spoke}

In a setup with a hub and multiple spokes connected via separate P2P
links to the hub, all P2P adjacencies from the hub to the spokes\' links
can share the same bit position. The bit position on the hub\'s BIFT is
set up with a list of forward_connected() adjacencies, one for each
spoke.[¶](#section-5.1.5-1){.pilcrow}

This option is similar to the bit position optimization in LANs:
redundantly connected spokes need their own bit positions, unless they
are themselves leaf BFERs.[¶](#section-5.1.5-2){.pilcrow}

This type of optimized BP could be used, for example, when all traffic
is \"broadcast\" traffic (very dense receiver sets), such as live TV or
many-to-many telemetry, including situational awareness. This BP
optimization can then be used to explicitly steer different traffic
flows across different ECMP paths in data-center or
broadband-aggregation networks with minimal use of
BPs.[¶](#section-5.1.5-3){.pilcrow}
:::
:::

::: {#rings}
::: {#section-5.1.6 .section}
#### [5.1.6.](#section-5.1.6){.section-number .selfRef} [Rings](#name-rings){.section-name .selfRef} {#name-rings}

In L3 rings, instead of assigning a single bit position for every P2P
link in the ring, it is possible to save bit positions by setting the
\"DoNotClear\" (DNC) flag on forward_connected()
adjacencies.[¶](#section-5.1.6-1){.pilcrow}

For the ring shown in [Figure 9](#ring-picture){.auto .internal .xref},
a single bit position will suffice to forward traffic entering the ring
at BFRa or BFRb all the way up to BFR1, as
follows.[¶](#section-5.1.6-2){.pilcrow}

On BFRa, BFRb, BFR30,\... BFR3, the bit position is populated with a
forward_connected() adjacency pointing to the clockwise neighbor on the
ring and with DNC set. On BFR2, the adjacency also points to the
clockwise neighbor BFR1, but without DNC
set.[¶](#section-5.1.6-3){.pilcrow}

Handling DNC this way ensures that copies forwarded from any BFRs in the
ring to a BFR outside the ring will not have the ring bit position set,
therefore minimizing the risk of creating
loops.[¶](#section-5.1.6-4){.pilcrow}

[]{#name-ring-example}

::: {#ring-picture}
::: {#section-5.1.6-5.1 .alignLeft .art-text .artwork}
                   v        v
                   |        |
            L1     |   L2   |   L3
        /-------- BFRa ---- BFRb --------------------\
        |                                            |
        \- BFR1 - BFR2 - BFR3 - ... - BFR29 - BFR30 -/
            |      |    L4               |      |
         p33|                         p15|
            BFRd                       BFRc
:::

[Figure 9](#figure-9){.selfRef}: [Ring
Example](#name-ring-example){.selfRef}
:::

Note that this example only permits packets intended to make it all the
way around the ring to enter it at BFRa and BFRb. Note also that packets
will always travel clockwise. If packets should be allowed to enter the
ring at any of the ring\'s BFRs, then one would have to use two ring bit
positions, one for each direction: clockwise and
counterclockwise.[¶](#section-5.1.6-6){.pilcrow}

Both would be set up to stop rotating on the same link, e.g., L1. When
the ring\'s BFIR creates the clockwise copy, it will clear the
counterclockwise bit position because the DNC bit only applies to the
bit for which the replication is done (likewise for the clockwise bit
position for the counterclockwise copy). As a result, the ring\'s BFIR
will send a copy in both directions, serving BFRs on either side of the
ring up to L1.[¶](#section-5.1.6-7){.pilcrow}
:::
:::

::: {#ecmp}
::: {#section-5.1.7 .section}
#### [5.1.7.](#section-5.1.7){.section-number .selfRef} [Equal-Cost Multipath (ECMP)](#name-equal-cost-multipath-ecmp){.section-name .selfRef} {#name-equal-cost-multipath-ecmp}

An ECMP() adjacency allows the use of just one BP to deliver packets to
one of N adjacencies instead of one BP for each adjacency. In the common
example case shown in [Figure 10](#ecmp-picture){.auto .internal .xref},
a link bundle of three links L1,L2,L3 connects BFR1 and BFR2, and only
one BP is used instead of three BPs to deliver packets from BFR1 to
BFR2.[¶](#section-5.1.7-1){.pilcrow}

[]{#name-ecmp-example}

::: {#ecmp-picture}
::: {#section-5.1.7-2.1 .alignLeft .art-text .artwork}
                 --L1-----
            BFR1 --L2----- BFR2
                 --L3-----

      BIFT entry in BFR1:
      ------------------------------------------------------------------
      | Index |  Adjacencies                                           |
      ==================================================================
      | 0:6   |  ECMP({forward_connected(L1, BFR2),                    |
      |       |        forward_connected(L2, BFR2),                    |
      |       |        forward_connected(L3, BFR2)}, seed)             |
      ------------------------------------------------------------------

      BIFT entry in BFR2:
      ------------------------------------------------------------------
      | Index |  Adjacencies                                           |
      ==================================================================
      | 0:6   |  ECMP({forward_connected(L1, BFR1),                    |
      |       |        forward_connected(L2, BFR1),                    |
      |       |        forward_connected(L3, BFR1)}, seed)             |
      ------------------------------------------------------------------
:::

[Figure 10](#figure-10){.selfRef}: [ECMP
Example](#name-ecmp-example){.selfRef}
:::

This document does not standardize any ECMP algorithm because it is
sufficient for implementations to document their freely chosen ECMP
algorithm. [Figure 11](#ecmp-algo-picture){.auto .internal .xref} shows
an example ECMP algorithm and would double as its documentation: a
BIER-TE controller could determine which adjacency is chosen based on
the seed and adjacencies parameters and on packet
entropy.[¶](#section-5.1.7-3){.pilcrow}

[]{#name-ecmp-algorithm-example}

::: {#ecmp-algo-picture}
::: {#section-5.1.7-4.1 .alignLeft .art-text .artwork}
       forward(packet, ECMP(adj(0), adj(1),... adj(N-1), seed)):
          i = (packet(bier-header-entropy) XOR seed) % N
          forward packet to adj(i)
:::

[Figure 11](#figure-11){.selfRef}: [ECMP Algorithm
Example](#name-ecmp-algorithm-example){.selfRef}
:::

In the example shown in [Figure 12](#polarization-picture){.auto
.internal .xref}, all traffic from BFR1 towards BFR10 is intended to be
ECMP load-split equally across the topology. This example is not meant
as a likely setup; rather, it illustrates that ECMP can be used to share
BPs not only across link bundles but also across alternative paths
across different transit BFRs, and it explains the use of the seed
parameter.[¶](#section-5.1.7-5){.pilcrow}

[]{#name-polarization-example}

::: {#polarization-picture}
::: {#section-5.1.7-6.1 .alignLeft .art-text .artwork}
                     BFR1         (BFIR)
                   /L11  \L12
                  /       \
              BFR2         BFR3
             /L21 \L22    /L31 \L32
            /      \     /      \
           BFR4  BFR5   BFR6  BFR7
            \      /     \      /
             \    /       \    /
              BFR8         BFR9
                  \       /
                   \     /
                    BFR10         (BFER)

      BIFT entry in BFR1:
      ------------------------------------------------------------------
      | 0:6   |  ECMP({forward_connected(L11, BFR2),                   |
      |       |        forward_connected(L12, BFR3)}, seed1)           |
      ------------------------------------------------------------------

      BIFT entry in BFR2:
      ------------------------------------------------------------------
      | 0:7   |  ECMP({forward_connected(L21, BFR4),                   |
      |       |        forward_connected(L22, BFR5)}, seed1)           |
      ------------------------------------------------------------------

      BIFT entry in BFR3:
      ------------------------------------------------------------------
      | 0:7   |  ECMP({forward_connected(L31, BFR6),                   |
      |       |        forward_connected(L32, BFR7)}, seed1)           |
      ------------------------------------------------------------------

      BIFT entry in BFR4, BFR5:
      ------------------------------------------------------------------
      | 0:8   |  forward_connected(Lxx, BFR8)  |xx differs on BFR4/BFR5|
      ------------------------------------------------------------------

      BIFT entry in BFR6, BFR7:
      ------------------------------------------------------------------
      | 0:8   |  forward_connected(Lxx, BFR9)  |xx differs on BFR6/BFR7|
      ------------------------------------------------------------------

      BIFT entry in BFR8, BFR9:
      ------------------------------------------------------------------
      | 0:9   |  forward_connected(Lxx, BFR10) |xx differs on BFR8/BFR9|
      ------------------------------------------------------------------
:::

[Figure 12](#figure-12){.selfRef}: [Polarization
Example](#name-polarization-example){.selfRef}
:::

Note that for the following discussion of ECMP, only the BIFT ECMP()
adjacencies on BFR1, BFR2, and BFR3 are relevant. The reuse of BPs
across BFRs in this example is further explained in [Section
5.1.9](#reuse){.auto .internal .xref}
below.[¶](#section-5.1.7-7){.pilcrow}

With the ECMP setup shown in the topology above, traffic would not be
equally load-split. Instead, links L22 and L31 would see no traffic at
all: BFR2 will only see traffic from BFR1, for which the ECMP hash in
BFR1 selected the first adjacency in the list of two adjacencies given
as parameters to the ECMP: link L11-to-BFR2. BFR2 again performs ECMP
with two adjacencies on that subset of traffic using the same seed1 and
will therefore again select the first of its two adjacencies:
L21-to-BFR4. Therefore, L22 and BFR5 see no traffic (likewise for L31
and BFR6).[¶](#section-5.1.7-8){.pilcrow}

This issue in BFR2/BFR3 is called \"polarization\". It results from the
reuse of the same hash function across multiple consecutive hops in
topologies like these. To resolve this issue, the ECMP() adjacency on
BFR1 can be set up with a different seed2 than the ECMP() adjacencies on
BFR2/BFR3. BFR2/BFR3 can use the same hash because packets will not
sequentially pass across both of them. Therefore, they can also use the
same BP (i.e., 0:7).[¶](#section-5.1.7-9){.pilcrow}

Note that ECMP solutions outside of BIER often hide the seed by
auto-selecting it from local entropy such as unique local or next-hop
identifiers. Allowing the BIER-TE controller to explicitly set the seed
gives the BIER-TE controller the ability to control the selection of the
same path or different paths across multiple consecutive ECMP
hops.[¶](#section-5.1.7-10){.pilcrow}
:::
:::

::: {#routed}
::: {#section-5.1.8 .section}
#### [5.1.8.](#section-5.1.8){.section-number .selfRef} [Forward Routed Adjacencies](#name-forward-routed-adjacencies){.section-name .selfRef} {#name-forward-routed-adjacencies}

::: {#reducing}
::: {#section-5.1.8.1 .section}
##### [5.1.8.1.](#section-5.1.8.1){.section-number .selfRef} [Reducing Bit Positions](#name-reducing-bit-positions){.section-name .selfRef} {#name-reducing-bit-positions}

Forward_routed() adjacencies can reduce the number of bit positions
required when the path steering requirement is not hop-by-hop explicit
path selection but rather is loose-hop selection. Forward_routed()
adjacencies can also permit BIER-TE operation across intermediate-hop
routers that do not support BIER-TE.[¶](#section-5.1.8.1-1){.pilcrow}

Assume that the requirement in [Figure 13](#routed-picture){.auto
.internal .xref} is to explicitly steer traffic flows that have arrived
at BFR1 or BFR4 via a path in the routing underlay \"Network Area 1\" to
one of the following next three segments: (1) BFR2 via link L1, (2) BFR2
via link L2, or (3) via BFR3 and then not caring whether the packet is
forwarded via L3 or L4.[¶](#section-5.1.8.1-2){.pilcrow}

[]{#name-forward-routed-adjacencies-}

::: {#routed-picture}
::: {#section-5.1.8.1-3.1 .alignLeft .art-text .artwork}
                       ...............
             ...BFR1--...           ...--L1-- BFR2...
                      ... .Routers. ...--L2--/
             ...BFR4--...           ...--L3-- BFR3...
                      ...           ...--L4--/ |
                       ...............         |
                                              LO
                        Network Area 1
:::

[Figure 13](#figure-13){.selfRef}: [Forward Routed Adjacencies
Example](#name-forward-routed-adjacencies-){.selfRef}
:::

To enable this, both BFR1 and BFR4 are set up with a forward_routed()
adjacency bit position towards an address of BFR2 on link L1, another
forward_routed() bit position towards an address of BFR2 on link L2, and
a third forward_routed() bit position towards a node address LO of
BFR3.[¶](#section-5.1.8.1-4){.pilcrow}
:::
:::

::: {#without}
::: {#section-5.1.8.2 .section}
##### [5.1.8.2.](#section-5.1.8.2){.section-number .selfRef} [Supporting Nodes without BIER-TE](#name-supporting-nodes-without-bi){.section-name .selfRef} {#name-supporting-nodes-without-bi}

Forward_routed() adjacencies also enable incremental deployment of
BIER-TE. Only the nodes through which BIER-TE traffic needs to be
steered \-- with or without replication \-- need to support BIER-TE.
Where they are not directly connected to each other, forward_routed()
adjacencies are used to pass over nodes that are not BIER-TE
enabled.[¶](#section-5.1.8.2-1){.pilcrow}
:::
:::
:::
:::

::: {#reuse}
::: {#section-5.1.9 .section}
#### [5.1.9.](#section-5.1.9){.section-number .selfRef} [Reuse of Bit Positions (without DNC)](#name-reuse-of-bit-positions-with){.section-name .selfRef} {#name-reuse-of-bit-positions-with}

BPs can be reused across multiple BFRs to minimize the number of BPs
needed. This happens when adjacencies on multiple BFRs use the DNC flag
as described above, but it can also be done for non-DNC adjacencies.
This section only discusses this non-DNC
case.[¶](#section-5.1.9-1){.pilcrow}

Because a given BP is cleared when passing a BFR with an adjacency for
that BP, reusing BPs across multiple BFRs does not introduce any
problems with duplicates or loops that do not also exist when every
adjacency has a unique BP. Instead, the challenge when reusing BPs is
whether the desired Tree Engineering goals can still be
achieved.[¶](#section-5.1.9-2){.pilcrow}

A BP cannot be reused across two BFRs that would need to be passed
sequentially for some path: the first BFR will clear the BP, so those
paths cannot be built. A BP can be set across BFRs that would only occur
across (A) different paths or (B) different branches of the same
tree.[¶](#section-5.1.9-3){.pilcrow}

An example of (A) was given in [Figure 12](#polarization-picture){.auto
.internal .xref}, where BP 0:7, BP 0:8, and BP 0:9 are each reused
across multiple BFRs because a single packet/path would never be able to
reach more than one BFR sharing the same
BP.[¶](#section-5.1.9-4){.pilcrow}

Assume that the example was changed: BFR1 has no ECMP() adjacency for BP
0:6 but instead has BP 0:5 with forward_connected() to BFR2 and BP 0:6
with forward_connected() to BFR3. Packets with both BP 0:5 and BP 0:6
would now be able to reach both BFR2 and BFR3, and the still-existing
reuse of BP 0:7 between BFR2 and BFR3 is a case of (B) where reusing a
BP is perfect because it does not limit the set of useful path choices,
as in the following example.[¶](#section-5.1.9-5){.pilcrow}

If instead of reusing BP 0:7 BFR3 used a separate BP 0:10 for its ECMP()
adjacency, no useful additional path steering options would be enabled.
If duplicates at BFR10 were undesirable, this would be done by not
setting BP 0:5 and BP 0:6 for the same packet. If the duplicates were
desirable (e.g., resilient transmission), the additional BP 0:10 would
also not render additional value.[¶](#section-5.1.9-6){.pilcrow}

Reuse may also save BPs in larger topologies. Consider the topology
shown in [Figure 14](#scaling-picture2){.auto .internal
.xref}.[¶](#section-5.1.9-7){.pilcrow}

[]{#name-reuse-of-bps}

::: {#scaling-picture2}
::: {#section-5.1.9-8.1 .alignLeft .art-text .artwork}
                           area1
                       BFR1a BFR1b
                         /    \
            ....................................
            .                Core              .
            ....................................
            |    /       \    /           \  |
          BFR2a BFR2b  BFR3a BFR3b      BFR6a BFR6b
           /-------\   /---------\      /--------\
           | area2 |   |  area3  | ...  | area6  |
           | ring  |   |  ring   |      | ring   |
           \-------/   \---------/      \--------/
           more BFRs    more BFRs        more BFRs
:::

[Figure 14](#figure-14){.selfRef}: [Reuse of
BPs](#name-reuse-of-bps){.selfRef}
:::

A BFIR/sender (e.g., video headend) is attached to area 1, and the five
areas 2\...6 contain receivers/BFERs. Assume that each area has a
distribution ring, each with two BPs to indicate the direction (as
explained before). These two BPs could be reused across the five areas.
Packets would be replicated through other BPs from the core to the
desired subset of areas, and once a packet copy reaches the ring of the
area, the two ring BPs come into play. This reuse is a case of (B), but
it limits the topology choices: packets can only flow around the same
direction in the rings of all areas. This may or may not be acceptable
based on the desired path steering options: if resilient transmission is
the path engineering goal, then it is likely a good optimization;
however, if the bandwidth of each ring were to be optimized separately,
it would not be a good limitation.[¶](#section-5.1.9-9){.pilcrow}
:::
:::

::: {#bits-summary}
::: {#section-5.1.10 .section}
#### [5.1.10.](#section-5.1.10){.section-number .selfRef} [Summary of BP Optimizations](#name-summary-of-bp-optimizations){.section-name .selfRef} {#name-summary-of-bp-optimizations}

In this section, we reviewed a range of techniques by which a BIER-TE
controller can create a BIER-TE topology in a way that minimizes the
number of necessary BPs.[¶](#section-5.1.10-1){.pilcrow}

Without any optimization, a BIER-TE controller would attempt to map the
network subnet topology 1:1 into the BIER-TE topology, every adjacent
neighbor in the subnet would require a forward_connected() BP, and every
BFER would require a local_decap() BP.[¶](#section-5.1.10-2){.pilcrow}

The optimizations described in this document are then as
follows:[¶](#section-5.1.10-3){.pilcrow}

1.  [P2P links require only one BP ([Section 5.1.1](#p2p-links){.auto
    .internal
    .xref}).[¶](#section-5.1.10-4.1){.pilcrow}]{#section-5.1.10-4.1}
2.  [All leaf BFERs can share a single local_decap() BP ([Section
    5.1.3](#leaf-bfer){.auto .internal
    .xref}).[¶](#section-5.1.10-4.2){.pilcrow}]{#section-5.1.10-4.2}
3.  [A LAN with N BFRs needs at most N BPs (one for each BFR). It only
    needs one BP for all those BFRs that are not redundantly connected
    to multiple LANs ([Section 5.1.4](#lans){.auto .internal
    .xref}).[¶](#section-5.1.10-4.3){.pilcrow}]{#section-5.1.10-4.3}
4.  [A hub with P2P connections to multiple non-leaf BFER spokes can
    share one BP with all of the spokes if traffic can be flooded to all
    of those spokes, e.g., because of no bandwidth concerns or dense
    receiver sets ([Section 5.1.5](#hubnspoke){.auto .internal
    .xref}).[¶](#section-5.1.10-4.4){.pilcrow}]{#section-5.1.10-4.4}
5.  [Rings of BFRs can be built with just two BPs (one for each
    direction), except for BFRs with multiple ring connections \--
    similar to LANs ([Section 5.1.6](#rings){.auto .internal
    .xref}).[¶](#section-5.1.10-4.5){.pilcrow}]{#section-5.1.10-4.5}
6.  [ECMP() adjacencies to N neighbors can replace N BPs with one BP.
    Multihop ECMP can avoid polarization through different seeds of the
    ECMP algorithm ([Section 5.1.7](#ecmp){.auto .internal
    .xref}).[¶](#section-5.1.10-4.6){.pilcrow}]{#section-5.1.10-4.6}
7.  [Forward_routed() adjacencies permit \"tunneling\" across routers
    that are either BIER-TE capable or not BIER-TE capable where no
    traffic steering or replications are required ([Section
    5.1.8](#routed){.auto .internal
    .xref}).[¶](#section-5.1.10-4.7){.pilcrow}]{#section-5.1.10-4.7}
8.  [A BP can generally be reused across a set of nodes where it can be
    guaranteed that no path will ever need to traverse more than one
    node of the set. Depending on the scenario, this may limit the
    feasible path steering options ([Section 5.1.9](#reuse){.auto
    .internal
    .xref}).[¶](#section-5.1.10-4.8){.pilcrow}]{#section-5.1.10-4.8}

Note that this list of optimizations is not exhaustive. Further
optimizations of BPs are possible, especially when both the set of
required path steering choices and the possible subsets of BFERs that
should be able to receive traffic are limited. The hub-and-spoke
optimization is a simple example of such traffic-pattern-dependent
optimizations.[¶](#section-5.1.10-5){.pilcrow}
:::
:::
:::
:::

::: {#avoiding}
::: {#section-5.2 .section}
### [5.2.](#section-5.2){.section-number .selfRef} [Avoiding Duplicates and Loops](#name-avoiding-duplicates-and-loo){.section-name .selfRef} {#name-avoiding-duplicates-and-loo}

::: {#loops}
::: {#section-5.2.1 .section}
#### [5.2.1.](#section-5.2.1){.section-number .selfRef} [Loops](#name-loops){.section-name .selfRef} {#name-loops}

Whenever BIER-TE creates a copy of a packet, the BitString of that copy
will have all bit positions cleared that are associated with adjacencies
on the BFR. This prevents packets from looping. The only exceptions are
adjacencies with DNC set.[¶](#section-5.2.1-1){.pilcrow}

With DNC set, looping can happen. Consider in [Figure
15](#ring-picture2){.auto .internal .xref} that link L4 from BFR3 is
(inadvertently) plugged into the L1 interface of BFRa (instead of BFR2).
This creates a loop where the ring\'s clockwise bit position is never
cleared for copies of the packets traveling clockwise around the
ring.[¶](#section-5.2.1-2){.pilcrow}

[]{#name-miswired-ring-example}

::: {#ring-picture2}
::: {#section-5.2.1-3.1 .alignLeft .art-text .artwork}
                   v        v
                   |        |
            L1     |   L2   |   L3
        /-------- BFRa ---- BFRb ---------------------\
        |        .                                    |
        |         ......  Wrong link wiring           |
        |               .                             |
        \- BFR1 - BFR2   BFR3 - ... - BFR29 - BFR30 -/
            |      |    L4               |      |
         p33|                         p15|
            BFRd                       BFRc
:::

[Figure 15](#figure-15){.selfRef}: [Miswired Ring
Example](#name-miswired-ring-example){.selfRef}
:::

To inhibit looping in the face of such physical misconfiguration, only
forward_connected() adjacencies are permitted to have DNC set, and the
link layer port unique unicast destination address of the adjacency
(e.g., \"Media Access Control\" (MAC) address) protects against closing
the loop. Link layers without port unique link layer addresses should
not be used with the DNC flag set.[¶](#section-5.2.1-4){.pilcrow}
:::
:::

::: {#duplicates}
::: {#section-5.2.2 .section}
#### [5.2.2.](#section-5.2.2){.section-number .selfRef} [Duplicates](#name-duplicates){.section-name .selfRef} {#name-duplicates}

Duplicates happen when the graph expressed by a BitString is not a tree
but is redundantly connecting BFRs with each other. In [Figure
16](#duplicates-picture){.auto .internal .xref}, a BitString of
p2,p3,p4,p5 would result in duplicate packets arriving on BFER4. The
BIER-TE controller must therefore ensure that only BitStrings that are
trees are created.[¶](#section-5.2.2-1){.pilcrow}

[]{#name-duplicates-example}

::: {#duplicates-picture}
::: {#section-5.2.2-2.1 .alignLeft .art-text .artwork}
                     BFIR1
                    /    \
                   / p2   \ p3
                  BFR2   BFR3
                   \ p4   / p5
                    \    /
                     BFER4
:::

[Figure 16](#figure-16){.selfRef}: [Duplicates
Example](#name-duplicates-example){.selfRef}
:::

When links are incorrectly physically reconnected before the BIER-TE
controller updates BitStrings in BFIRs, duplicates can happen. Like
loops, these can be inhibited by link layer addressing in
forward_connected() adjacencies.[¶](#section-5.2.2-3){.pilcrow}

If interface or loopback addresses used in forward_routed() adjacencies
are moved from one BFR to another, duplicates are equally likely to
happen. Such readdressing operations must be coordinated with the
BIER-TE controller.[¶](#section-5.2.2-4){.pilcrow}
:::
:::
:::
:::

::: {#mgmt-stuff}
::: {#section-5.3 .section}
### [5.3.](#section-5.3){.section-number .selfRef} [Managing SIs, Subdomains, and BFR-ids](#name-managing-sis-subdomains-and){.section-name .selfRef} {#name-managing-sis-subdomains-and}

When the number of bits required to represent the necessary hops in the
topology and BFERs exceeds the supported \"BitStringLength\" (BSL),
multiple SIs and/or subdomains must be used. This section discusses how
this is done.[¶](#section-5.3-1){.pilcrow}

BIER-TE forwarding does not require the concept of BFR-ids, but routing
underlay, flow overlay, and BIER headers may. This section also
discusses how BFR-ids can be assigned to BFIRs/BFERs for
BIER-TE.[¶](#section-5.3-2){.pilcrow}

::: {#why}
::: {#section-5.3.1 .section}
#### [5.3.1.](#section-5.3.1){.section-number .selfRef} [Why SIs and Subdomains?](#name-why-sis-and-subdomains){.section-name .selfRef} {#name-why-sis-and-subdomains}

For (non-TE) BIER and BIER-TE forwarding, the most important result of
using multiple SIs and/or subdomains is the same: multicast flow overlay
packets that need to be sent to BFERs in different SIs or subdomains
require multiple BIER packets, each one with a BitString for a different
(SI,subdomain) combination. Each such BitString uses one BSL-sized SI
block in the BIFT of the subdomain. We call this a BIFT:SI
(block).[¶](#section-5.3.1-1){.pilcrow}

SIs and subdomains have different purposes in the BIER architecture and
also the BIER-TE architecture. This impacts how operators manage them
and especially how flow overlays will likely use
them.[¶](#section-5.3.1-2){.pilcrow}

By default, every possible BFIR/BFER in a BIER network would likely be
given a BFR-id in subdomain 0 (unless there are \> 64k
BFIRs/BFERs).[¶](#section-5.3.1-3){.pilcrow}

If there are different flow services (or service instances) requiring
replication to different subsets of BFERs, then it will likely not be
possible to achieve the best replication efficiency for all of these
service instances via subdomain 0. Ideal replication efficiency for N
BFERs exists in a subdomain if they are split over no more than
ceiling(N/BitStringLength) SIs.[¶](#section-5.3.1-4){.pilcrow}

If service instances justify additional BIER:SI state in the network,
additional subdomains will be used: BFIRs/BFERs are assigned BFR-ids in
those subdomains, and each service instance is configured to use the
most appropriate subdomain. This results in improved replication
efficiency for different services.[¶](#section-5.3.1-5){.pilcrow}

Even if creation of subdomains and assignment of BFR-ids to BFIRs/BFERs
in those subdomains is automated, it is not expected that individual
service instances can deal with BFERs in different subdomains. A service
instance may only support configuration of a single subdomain it should
rely on.[¶](#section-5.3.1-6){.pilcrow}

To be able to easily reuse (and modify as little as possible) existing
BIER procedures (including flow overlay and routing underlay), when
BIER-TE forwarding is added, we therefore reuse SIs and subdomains
logically in the same way as they are used in BIER: all necessary
BFIRs/BFERs for a service use a single BIER-TE BIFT and are split across
as many SIs as necessary (see [Section 5.3.2](#bit-requirements){.auto
.internal .xref}). Different services may use different subdomains that
primarily exist to provide more efficient replication (and, for BIER-TE,
desirable path steering) for different subsets of
BFIRs/BFERs.[¶](#section-5.3.1-7){.pilcrow}
:::
:::

::: {#bit-requirements}
::: {#section-5.3.2 .section}
#### [5.3.2.](#section-5.3.2){.section-number .selfRef} [Assigning Bits for the BIER-TE Topology](#name-assigning-bits-for-the-bier){.section-name .selfRef} {#name-assigning-bits-for-the-bier}

In BIER, BitStrings only need to carry bits for BFERs; this leads to the
model where BFR-ids map 1:1 to each bit in a
BitString.[¶](#section-5.3.2-1){.pilcrow}

In BIER-TE, BitStrings need to carry bits to indicate not only the
receiving BFER but also the intermediate hops/links across which the
packet must be sent. The maximum number of BFERs that can be supported
in a single BitString or BIFT:SI depends on the number of bits necessary
to represent the desired topology between
them.[¶](#section-5.3.2-2){.pilcrow}

\"Desired\" topology means that it depends on the physical topology and
the operator\'s desire to[¶](#section-5.3.2-3){.pilcrow}

1.  [permit explicit path steering across every single hop (which
    requires more bits),
    or[¶](#section-5.3.2-4.1){.pilcrow}]{#section-5.3.2-4.1}
2.  [reduce the number of required bits by exploiting optimizations such
    as unicast (forward_routed()), ECMP(), or flood (DNC) over
    \"uninteresting\" sub-parts of the topology, e.g., parts where, for
    path steering reasons, different trees do not need to take different
    paths.[¶](#section-5.3.2-4.2){.pilcrow}]{#section-5.3.2-4.2}

The total number of bits to describe the topology vs. the number of
BFERs in a BIFT:SI can range widely based on the size of the topology
and the amount of alternative paths in it. In a BIER-TE topology crafted
by a BIER-TE expert, the higher the percentage of non-BFER bits, the
higher the likelihood that those topology bits are not just BIER-TE
overhead without additional benefit but instead will allow the
expression of desirable path steering
alternatives.[¶](#section-5.3.2-5){.pilcrow}
:::
:::

::: {#bfr-id}
::: {#section-5.3.3 .section}
#### [5.3.3.](#section-5.3.3){.section-number .selfRef} [Assigning BFR-ids with BIER-TE](#name-assigning-bfr-ids-with-bier){.section-name .selfRef} {#name-assigning-bfr-ids-with-bier}

BIER-TE forwarding does not use BFR-ids, nor does it require that the
BFIR-id field of the BIER header be set to a particular value. However,
other parts of a BIER-TE deployment may need a BFR-id \-- specifically,
multicast flow overlay signaling and multicast flow overlay packet
disposition; in that case, BFRs need to also have BFR-ids for BIER-TE
SDs.[¶](#section-5.3.3-1){.pilcrow}

For example, for BIER overlay signaling, BFIRs need to have a BFR-id,
because this BFIR BFR-id is carried in the BFIR-id field of the BIER
header to indicate to the overlay signaling on the receiving BFER which
BFIR originated the packet.[¶](#section-5.3.3-2){.pilcrow}

In BIER, BFR-id = SI \* BSL + BP, such that the SI and BP of a BFER can
be calculated from the BFR-id and vice versa. This also means that every
BFR with a BFR-id has a reserved BP in an SI, even if that is not
necessary for BIER forwarding, because the BFR may never be a BFER
(i.e., will only be a BFIR).[¶](#section-5.3.3-3){.pilcrow}

In BIER-TE, for a non-leaf BFER, there is usually a single BP for that
BFER with a local_decap() adjacency on the BFER. The BFR-id for such a
BFER can therefore be determined using the same procedure as that used
for (non-TE) BIER: BFR-id = SI \* BSL +
BP.[¶](#section-5.3.3-4){.pilcrow}

As explained in [Section 5.1.3](#leaf-bfer){.auto .internal .xref}, leaf
BFERs do not need such a unique local_decap() adjacency. Likewise, BFIRs
that are not also BFERs may not have a unique local_decap() adjacency
either. For all those BFIRs and (leaf) BFERs, the controller needs to
determine unique BFR-ids that do not collide with the BFR-ids derived
from the non-leaf BFER local_decap() BPs.[¶](#section-5.3.3-5){.pilcrow}

While this document defines no requirements on how to allocate such
BFR-ids, a simple option is to derive it from the (SI,BP) of an
adjacency that is unique to the BFR in question. For a BFIR, this can be
the first adjacency that is only populated on this BFIR; for a leaf
BFER, this could be the first BP with an adjacency towards that
BFER.[¶](#section-5.3.3-6){.pilcrow}
:::
:::

::: {#bitstring-mappings}
::: {#section-5.3.4 .section}
#### [5.3.4.](#section-5.3.4){.section-number .selfRef} [Mapping from BFRs to BitStrings with BIER-TE](#name-mapping-from-bfrs-to-bitstr){.section-name .selfRef} {#name-mapping-from-bfrs-to-bitstr}

In BIER, applications of the flow overlay on a BFIR can calculate the
(SI,BP) of a BFER from the BFR-id of the BFER and can therefore easily
determine the BitStrings for a BIER packet to a set of BFERs with known
BFR-ids.[¶](#section-5.3.4-1){.pilcrow}

In BIER-TE, this mapping needs to be equally supported for flow
overlays. This section outlines two core options, based on what type of
Tree Engineering the BIER-TE controller needs to perform for a
particular application.[¶](#section-5.3.4-2){.pilcrow}

[]{.break}

\"Independent branches\":
:   For a given flow overlay instance, the branches from a BFIR to every
    BFER are calculated by the BIER-TE controller to be independent of
    the branches to any other BFER. Shortest path trees are the most
    common examples of trees with independent
    branches.[¶](#section-5.3.4-3.2){.pilcrow}
:   

\"Interdependent branches\":
:   When a BFER is added to or deleted from a particular distribution
    tree, the BIER-TE controller has to recalculate the branches to
    other BFERs, because they may need to change. Steiner trees are
    examples of interdependent branch
    trees.[¶](#section-5.3.4-3.4){.pilcrow}
:   

If \"independent branches\" are used, the BIER-TE controller can signal
to the BFIR flow overlay for every BFER an SI:BitString that represents
the branch to that BFER. The flow overlay on the BFIR can then,
independently of the controller, calculate the SI:BitString for all
desired BFERs by ORing their BitStrings. This allows flow overlay
applications to operate independently of the controller whenever they
need to determine which subset of BFERs needs to receive a particular
packet.[¶](#section-5.3.4-4){.pilcrow}

If \"interdependent branches\" are required, an application would need
to query the SI:BitString for a given set of BFERs whenever the set
changes.[¶](#section-5.3.4-5){.pilcrow}

Note that in either case (unlike the scenario for BIER), the bits may
need to change upon link/node failure/recovery, network expansion, or
network resource consumption by other traffic as part of achieving
Traffic Engineering goals (e.g., reoptimization of lower-priority
traffic flows). Interactions between such BFIR applications and the
BIER-TE controller do therefore need to support dynamic updates to the
SIs:BitStrings.[¶](#section-5.3.4-6){.pilcrow}

Communications between the BFIR flow overlay and the BIER-TE controller
require some way to identify the BFERs. If BFR-ids are used in the
deployment, as outlined in [Section 5.3.3](#bfr-id){.auto .internal
.xref}, then those are the \"natural\" BFR-ids. If BFR-ids are not used,
then any other unique identifier, such as a BFR\'s BFR-prefix
\[[RFC8279](#RFC8279){.cite .xref}\], could be
used.[¶](#section-5.3.4-7){.pilcrow}
:::
:::

::: {#assigning}
::: {#section-5.3.5 .section}
#### [5.3.5.](#section-5.3.5){.section-number .selfRef} [Assigning BFR-ids for BIER-TE](#name-assigning-bfr-ids-for-bier-){.section-name .selfRef} {#name-assigning-bfr-ids-for-bier-}

It is not currently determined if a single subdomain could or should be
allowed to forward both (non-TE) BIER and BIER-TE packets. If this
should be supported, there are two
options:[¶](#section-5.3.5-1){.pilcrow}

A.  [BIER and BIER-TE have different BFR-ids in the same subdomain. This
    allows higher replication efficiency for BIER because the BIER
    BFR-ids can be assigned sequentially, while the BitStrings for
    BIER-TE will also have to assign the additional bits for the
    topology adjacencies. There is no relationship between a BFR BIER
    BFR-id and its BIER-TE
    BFR-id.[¶](#section-5.3.5-2.1){.pilcrow}]{#section-5.3.5-2.1}
B.  [BIER and BIER-TE share the same BFR-id. The BFR-ids are assigned as
    explained above for BIER-TE and simply reused for BIER. The
    replication efficiency for BIER will be as low as that for BIER-TE
    in this
    approach.[¶](#section-5.3.5-2.2){.pilcrow}]{#section-5.3.5-2.2}
:::
:::

::: {#allocation-example}
::: {#section-5.3.6 .section}
#### [5.3.6.](#section-5.3.6){.section-number .selfRef} [Example Bit Allocations](#name-example-bit-allocations){.section-name .selfRef} {#name-example-bit-allocations}

::: {#with-bier}
::: {#section-5.3.6.1 .section}
##### [5.3.6.1.](#section-5.3.6.1){.section-number .selfRef} [With BIER](#name-with-bier){.section-name .selfRef} {#name-with-bier}

Consider a network setup with a BSL of 256 for a network topology as
shown in [Figure 17](#scaling-picture){.auto .internal .xref}. The
network has six areas, each with 170 BFERs, connecting via a core with
four (core) BFRs. To address all BFERs with BIER, four SIs are required.
To send a BIER packet to all BFERs in the network, four copies need to
be sent by the BFIR. On the BFIR, it does not matter how the BFR-ids are
allocated to BFERs in the network, but it does matter for efficiency
further down in the network.[¶](#section-5.3.6.1-1){.pilcrow}

[]{#name-scaling-bier-te-bits-by-reu}

::: {#scaling-picture}
::: {#section-5.3.6.1-2.1 .alignLeft .art-text .artwork}
                 area1           area2        area3
                BFR1a BFR1b  BFR2a BFR2b   BFR3a BFR3b
                  |  \         /    \        /  |
                  ................................
                  .                Core          .
                  ................................
                  |    /       \    /        \  |
                BFR4a BFR4b  BFR5a BFR5b   BFR6a BFR6b
                 area4          area5        area6
:::

[Figure 17](#figure-17){.selfRef}: [Scaling BIER-TE Bits by
Reuse](#name-scaling-bier-te-bits-by-reu){.selfRef}
:::

With random allocation of BFR-ids to BFERs, each receiving area would
(most likely) have to receive all four copies of the BIER packet because
there would be BFR-ids for each of the four SIs in each of the areas.
Only further towards each BFER would this duplication subside \-- when
each of the four trees runs out of
branches.[¶](#section-5.3.6.1-3){.pilcrow}

If BFR-ids are allocated intelligently, then all the BFERs in an area
would be given BFR-ids with as few different SIs as possible. Each area
would only have to forward one or two packets instead of
four.[¶](#section-5.3.6.1-4){.pilcrow}

Given how networks can grow over time, replication efficiency in an area
will then also go down over time when BFR-ids are only allocated
sequentially, network wide. An area that initially only has BFR-ids in
one SI might end up with many SIs over a longer period of growth.
Allocating SIs to areas that initially have sufficiently many spare bits
for growth can help alleviate this issue. Alternatively, BFERs can be
renumbered after network expansion. In this example, one may consider
using six SIs and assigning one to each
area.[¶](#section-5.3.6.1-5){.pilcrow}

This example shows that intelligent BFR-id allocation within at least
subdomain 0 can be helpful or even necessary in
BIER.[¶](#section-5.3.6.1-6){.pilcrow}
:::
:::

::: {#with-bier-te}
::: {#section-5.3.6.2 .section}
##### [5.3.6.2.](#section-5.3.6.2){.section-number .selfRef} [With BIER-TE](#name-with-bier-te){.section-name .selfRef} {#name-with-bier-te}

In BIER-TE, one needs to determine a subset of the physical topology and
attached BFERs so that the \"desired\" representation of this topology
and the BFERs fit into a single BitString. This process needs to be
repeated until the whole topology is
covered.[¶](#section-5.3.6.2-1){.pilcrow}

Once bits/SIs are assigned to the topology and BFERs, BFR-ids are just a
derived set of identifiers from the operator / BIER-TE controller as
explained above.[¶](#section-5.3.6.2-2){.pilcrow}

Whenever different subtopologies have overlap, bits need to be repeated
across the BitStrings, increasing the overall amount of bits required
across all BitStrings/SIs. In the worst case, one assigns random subsets
of BFERs to different SIs. This will result in an outcome much worse
than in (non-TE) BIER: it maximizes the amount of unnecessary topology
overlap across SIs and therefore reduces the number of BFERs that can be
reached across each individual SI. Intelligent BFER-to-SI assignment and
selecting specific \"desired\" subtopologies can minimize this
problem.[¶](#section-5.3.6.2-3){.pilcrow}

To set up BIER-TE efficiently for the topology shown in [Figure
17](#scaling-picture){.auto .internal .xref}, the following bit
allocation method can be used. This method can easily be expanded to
other, similarly structured larger
topologies.[¶](#section-5.3.6.2-4){.pilcrow}

Each area is allocated one or more SIs, depending on the number of
future expected BFERs and the number of bits required for the topology
in the area. In this example, six SIs are used, one per
area.[¶](#section-5.3.6.2-5){.pilcrow}

In addition, we use four bits in each
SI:[¶](#section-5.3.6.2-6){.pilcrow}

[]{.break}

bia:
:   (b)it (i)ngress (a)[¶](#section-5.3.6.2-7.2){.pilcrow}
:   

bib:
:   (b)it (i)ngress (b)[¶](#section-5.3.6.2-7.4){.pilcrow}
:   

bea:
:   (b)it (e)gress (a)[¶](#section-5.3.6.2-7.6){.pilcrow}
:   

beb:
:   (b)it (e)gress (b)[¶](#section-5.3.6.2-7.8){.pilcrow}
:   

These bits will be used to pass BIER packets from any BFIR via any
combination of ingress area a/b BFRs and egress area a/b BFRs into a
specific target area. These bits are then set up with the right
forward_routed() adjacencies on the BFIRs and area edge BFRs as
follows.[¶](#section-5.3.6.2-8){.pilcrow}

On all BFIRs in an area, j\|j=1\...6, bia in each BIFT:SI is populated
with the same forward_routed(BFRja) and bib with forward_routed(BFRjb).
On all area edge BFRs, bea in BIFT:SI=k\|k=1\...6 is populated with
forward_routed(BFRka) and beb in BIFT:SI=k with
forward_routed(BFRkb).[¶](#section-5.3.6.2-9){.pilcrow}

For BIER-TE forwarding of a packet to a subset of BFERs across all
areas, a BFIR would create at most six copies, with SI=1\...SI=6. In
each packet, the BitString includes bits for one area and the BFERs in
that area, plus the four bits to indicate whether to pass this packet
via the ingress area a or b border BFR and the egress area a or b border
BFR, therefore allowing path steering for those two \"unicast\" legs: 1)
BFIR to ingress area edge and 2) core to egress area edge. Replication
only happens inside the egress areas. For BFERs that are in the same
area as the BFIR, these four bits are not
used.[¶](#section-5.3.6.2-10){.pilcrow}
:::
:::
:::
:::

::: {#summary}
::: {#section-5.3.7 .section}
#### [5.3.7.](#section-5.3.7){.section-number .selfRef} [Summary](#name-summary){.section-name .selfRef} {#name-summary}

BIER-TE can, like BIER, support multiple SIs within a subdomain. This
allows application of the mapping BFR-id = SI \* BSL + BP. This also
permits the reuse of the BIER architecture concept of BFR-ids and,
therefore, minimization of BIER-TE-specific functions in possible BIER
layer control plane mechanisms with BIER-TE, including flow overlay
methods and BIER header fields.[¶](#section-5.3.7-1){.pilcrow}

The number of BFIRs/BFERs possible in a subdomain is smaller than in
BIER because BIER-TE uses additional bits for the
topology.[¶](#section-5.3.7-2){.pilcrow}

Subdomains in BIER-TE can be used as they are in BIER to create more
efficient replication to known subsets of
BFERs.[¶](#section-5.3.7-3){.pilcrow}

Assigning bits for BFERs intelligently into the right SI is more
important in BIER-TE than in BIER because of replication efficiency and
the overall amount of bits required.[¶](#section-5.3.7-4){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#security}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

If \"[Encapsulation for Bit Index Explicit Replication (BIER) in MPLS
and Non-MPLS Networks](#RFC8296){.internal .xref}\"
\[[RFC8296](#RFC8296){.cite .xref}\] is used, its security
considerations also apply to BIER-TE.[¶](#section-6-1){.pilcrow}

The security considerations of \"[Multicast Using Bit Index Explicit
Replication (BIER)](#RFC8279){.internal .xref}\"
\[[RFC8279](#RFC8279){.cite .xref}\] also apply to BIER-TE, with the
following overriding or additional
considerations.[¶](#section-6-2){.pilcrow}

BIER-TE forwarding explicitly supports unicast \"tunneling\" of BIER
packets via forward_routed() adjacencies. The BIER domain security model
is based on a subset of interfaces on a BFR that connect to other BFRs
of the same BIER domain. For BIER-TE, this security model equally
applies to such unicast \"tunneled\" BIER packets. This not only
includes the need to filter received unicast \"tunneled\" BIER packets
to prohibit the injection of such \"tunneled\" BIER packets from outside
the BIER domain but also the need to prohibit forward_routed()
adjacencies from leaking BIER packets from the BIER domain. It
[SHOULD]{.bcp14} be possible to configure interfaces to be part of a
BIER domain solely for sending and receiving unicast \"tunneled\" BIER
packets even if the interface cannot send/receive BIER encapsulated
packets.[¶](#section-6-3){.pilcrow}

In BIER, the standardized methods for the routing underlays are IGPs
with extensions to distribute BFR-ids and BFR-prefixes.
\[[RFC8401](#RFC8401){.cite .xref}\] specifies the extensions for IS-IS,
and \[[RFC8444](#RFC8444){.cite .xref}\] specifies the extensions for
OSPF. Attacking the protocols for the BIER routing underlay or (non-TE)
BIER layer control plane, or the impairment of any BFRs in a domain, may
lead to successful attacks against the information that BIER-TE learns
from the routing protocol (routes, next hops, BFR-ids, \...), enabling
DoS attacks against paths or the addressing (BFR-ids, BFR-prefixes) used
by BIER.[¶](#section-6-4){.pilcrow}

The reference model for the BIER-TE layer control plane is a BIER-TE
controller. When such a controller is used, the impairment of an
individual BFR in a domain causes no impairment of the BIER-TE control
plane on other BFRs. If a routing protocol is used to support
forward_routed() adjacencies, then this is still an attack vector as in
BIER, but only for BIER-TE forward_routed() adjacencies and not other
adjacencies.[¶](#section-6-5){.pilcrow}

Whereas IGP routing protocols are most often not well secured through
cryptographic authentication and confidentiality, communications between
controllers and routers such as those to be considered for the BIER-TE
controller / control plane can be, and are, much more commonly secured
with those security properties \-- for example, by using \"Secure
Shell\" (SSH) \[[RFC4253](#RFC4253){.cite .xref}\] for NETCONF
\[[RFC6242](#RFC6242){.cite .xref}\]; or via \"Transport Layer
Security\" (TLS), such as \[[RFC8253](#RFC8253){.cite .xref}\] for PCEP
\[[RFC5440](#RFC5440){.cite .xref}\] or \[[RFC7589](#RFC7589){.cite
.xref}\] for NETCONF. BIER-TE controllers [SHOULD]{.bcp14} use security
equal to or better than these mechanisms.[¶](#section-6-6){.pilcrow}

When any of these security mechanisms/protocols are used for
communications between a BIER-TE controller and BFRs, their security
considerations apply to BIER-TE. In addition, the security
considerations of \"[A Path Computation Element (PCE)-Based
Architecture](#RFC4655){.internal .xref}\" \[[RFC4655](#RFC4655){.cite
.xref}\] apply.[¶](#section-6-7){.pilcrow}

The most important attack vector in BIER-TE is misconfiguration, either
on the BFRs themselves or via the BIER-TE controller. Forwarding entries
with DNC could be set up to create persistent loops, in which packets
only expire because of TTL. To minimize the impact of such attacks (or,
more likely, unintentional misconfiguration by operators and/or bad
BIER-TE controller software), the BIER-TE forwarding rules are defined
to be as strict in clearing bits as possible. The clearing of all bits
with an adjacency on a BFR prohibits a looping packet from creating
additional packet amplification through the misconfigured loop on the
packet\'s second time or subsequent times around the loop, because all
relevant adjacency bits would have been cleared on the first round
through the loop. As a result, looping packets can occur in BIER-TE to
the same degree as is possible with unintentional or malicious loops in
the routing underlay with BIER, or even with unicast
traffic.[¶](#section-6-8){.pilcrow}

Deployments where BIER-TE would likely be beneficial may include
operational models where actual configuration changes from the
controller are only required during non-production phases of the
network\'s life cycle, e.g., in embedded networks or in manufacturing
networks during such activities as plant reworking or repairs. In these
types of deployments, configuration changes could be locked out when the
network is in production state and could only be (re-)enabled through
reverting the network/installation to non-production state. Such
security designs would not only allow a deployment to provide additional
layers of protection against configuration attacks but would, first and
foremost, protect the active production process from such configuration
attacks.[¶](#section-6-9){.pilcrow}
:::
:::

::: {#iana}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This document has no IANA actions.[¶](#section-7-1){.pilcrow}
:::
:::

::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8279\]
:   [Wijnands, IJ., Ed.]{.refAuthor}, [Rosen, E., Ed.]{.refAuthor},
    [Dolganow, A.]{.refAuthor}, [Przygienda, T.]{.refAuthor}, and [S.
    Aldrin]{.refAuthor}, [\"Multicast Using Bit Index Explicit
    Replication (BIER)\"]{.refTitle}, [RFC 8279]{.seriesInfo}, [DOI
    10.17487/RFC8279]{.seriesInfo}, November 2017,
    \<<https://www.rfc-editor.org/info/rfc8279>\>.
:   

\[RFC8296\]
:   [Wijnands, IJ., Ed.]{.refAuthor}, [Rosen, E., Ed.]{.refAuthor},
    [Dolganow, A.]{.refAuthor}, [Tantsura, J.]{.refAuthor},
    [Aldrin, S.]{.refAuthor}, and [I. Meilik]{.refAuthor},
    [\"Encapsulation for Bit Index Explicit Replication (BIER) in MPLS
    and Non-MPLS Networks\"]{.refTitle}, [RFC 8296]{.seriesInfo}, [DOI
    10.17487/RFC8296]{.seriesInfo}, January 2018,
    \<<https://www.rfc-editor.org/info/rfc8296>\>.
:   
:::

::: {#section-8.2 .section}
### [8.2.](#section-8.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[BIER-MCAST-OVERLAY\]
:   [Trossen, D.]{.refAuthor}, [Rahman, A.]{.refAuthor},
    [Wang, C.]{.refAuthor}, and [T. Eckert]{.refAuthor},
    [\"Applicability of BIER Multicast Overlay for Adaptive Streaming
    Services\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft,
    draft-ietf-bier-multicast-http-response-06]{.seriesInfo}, 10 July
    2021,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-bier-multicast-http-response-06>\>.
:   

\[BIER-TE-PROTECTION\]
:   [Eckert, T.]{.refAuthor}, [Cauchie, G.]{.refAuthor},
    [Braun, W.]{.refAuthor}, and [M. Menth]{.refAuthor}, [\"Protection
    Methods for BIER-TE\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-eckert-bier-te-frr-03]{.seriesInfo}, 5 March
    2018,
    \<<https://datatracker.ietf.org/doc/html/draft-eckert-bier-te-frr-03>\>.
:   

\[BIER-TE-YANG\]
:   [Zhang, Z.]{.refAuthor}, [Wang, C.]{.refAuthor},
    [Chen, R.]{.refAuthor}, [Hu, F.]{.refAuthor},
    [Sivakumar, M.]{.refAuthor}, and [H. Chen]{.refAuthor}, [\"A YANG
    data model for Tree Engineering for Bit Index Explicit Replication
    (BIER-TE)\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft, draft-ietf-bier-te-yang-05]{.seriesInfo}, 1 May
    2022,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-bier-te-yang-05>\>.
:   

\[Bloom70\]
:   [Bloom, B. H.]{.refAuthor}, [\"Space/time trade-offs in hash coding
    with allowable errors\"]{.refTitle}, [Comm. ACM
    13(7):422-6]{.refContent}, [DOI 10.1145/362686.362692]{.seriesInfo},
    July 1970, \<<https://dl.acm.org/doi/10.1145/362686.362692>\>.
:   

\[CONSTRAINED-CAST\]
:   [Bergmann, O.]{.refAuthor}, [Bormann, C.]{.refAuthor},
    [Gerdes, S.]{.refAuthor}, and [H. Chen]{.refAuthor},
    [\"Constrained-Cast: Source-Routed Multicast for RPL\"]{.refTitle},
    [Work in Progress]{.refContent}, [Internet-Draft,
    draft-ietf-roll-ccast-01]{.seriesInfo}, 30 October 2017,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-roll-ccast-01>\>.
:   

\[ICC\]
:   [Reed, M. J.]{.refAuthor}, [Al-Naday, M.]{.refAuthor},
    [Thomos, N.]{.refAuthor}, [Trossen, D.]{.refAuthor},
    [Petropoulos, G.]{.refAuthor}, and [S. Spirou]{.refAuthor},
    [\"Stateless multicast switching in software defined
    networks\"]{.refTitle}, [IEEE International Conference on
    Communications (ICC), Kuala Lumpur, Malaysia]{.refContent}, [DOI
    10.1109/ICC.2016.7511036]{.seriesInfo}, May 2016,
    \<<https://ieeexplore.ieee.org/document/7511036>\>.
:   

\[NON-MPLS-BIER-ENCODING\]
:   [Wijnands, IJ.]{.refAuthor}, [Mishra, M.]{.refAuthor},
    [Xu, X.]{.refAuthor}, and [H. Bidgoli]{.refAuthor}, [\"An Optional
    Encoding of the BIFT-id Field in the non-MPLS BIER
    Encapsulation\"]{.refTitle}, [Work in Progress]{.refContent},
    [Internet-Draft,
    draft-ietf-bier-non-mpls-bift-encoding-04]{.seriesInfo}, 30 May
    2021,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-bier-non-mpls-bift-encoding-04>\>.
:   

\[RCSD94\]
:   [Zhang, H.]{.refAuthor} and [D. Ferrari]{.refAuthor},
    [\"Rate-Controlled Service Disciplines\"]{.refTitle}, [Journal of
    High Speed Networks, Volume 3, Issue 4, pp. 389-412]{.refContent},
    [DOI 10.3233/JHS-1994-3405]{.seriesInfo}, October 1994,
    \<<https://content.iospress.com/articles/journal-of-high-speed-networks/jhs3-4-05>\>.
:   

\[RFC4253\]
:   [Ylonen, T.]{.refAuthor} and [C. Lonvick, Ed.]{.refAuthor}, [\"The
    Secure Shell (SSH) Transport Layer Protocol\"]{.refTitle}, [RFC
    4253]{.seriesInfo}, [DOI 10.17487/RFC4253]{.seriesInfo}, January
    2006, \<<https://www.rfc-editor.org/info/rfc4253>\>.
:   

\[RFC4456\]
:   [Bates, T.]{.refAuthor}, [Chen, E.]{.refAuthor}, and [R.
    Chandra]{.refAuthor}, [\"BGP Route Reflection: An Alternative to
    Full Mesh Internal BGP (IBGP)\"]{.refTitle}, [RFC
    4456]{.seriesInfo}, [DOI 10.17487/RFC4456]{.seriesInfo}, April 2006,
    \<<https://www.rfc-editor.org/info/rfc4456>\>.
:   

\[RFC4655\]
:   [Farrel, A.]{.refAuthor}, [Vasseur, J.-P.]{.refAuthor}, and [J.
    Ash]{.refAuthor}, [\"A Path Computation Element (PCE)-Based
    Architecture\"]{.refTitle}, [RFC 4655]{.seriesInfo}, [DOI
    10.17487/RFC4655]{.seriesInfo}, August 2006,
    \<<https://www.rfc-editor.org/info/rfc4655>\>.
:   

\[RFC5440\]
:   [Vasseur, JP., Ed.]{.refAuthor} and [JL. Le Roux, Ed.]{.refAuthor},
    [\"Path Computation Element (PCE) Communication Protocol
    (PCEP)\"]{.refTitle}, [RFC 5440]{.seriesInfo}, [DOI
    10.17487/RFC5440]{.seriesInfo}, March 2009,
    \<<https://www.rfc-editor.org/info/rfc5440>\>.
:   

\[RFC6241\]
:   [Enns, R., Ed.]{.refAuthor}, [Bjorklund, M., Ed.]{.refAuthor},
    [Schoenwaelder, J., Ed.]{.refAuthor}, and [A. Bierman,
    Ed.]{.refAuthor}, [\"Network Configuration Protocol
    (NETCONF)\"]{.refTitle}, [RFC 6241]{.seriesInfo}, [DOI
    10.17487/RFC6241]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6241>\>.
:   

\[RFC6242\]
:   [Wasserman, M.]{.refAuthor}, [\"Using the NETCONF Protocol over
    Secure Shell (SSH)\"]{.refTitle}, [RFC 6242]{.seriesInfo}, [DOI
    10.17487/RFC6242]{.seriesInfo}, June 2011,
    \<<https://www.rfc-editor.org/info/rfc6242>\>.
:   

\[RFC7589\]
:   [Badra, M.]{.refAuthor}, [Luchuk, A.]{.refAuthor}, and [J.
    Schoenwaelder]{.refAuthor}, [\"Using the NETCONF Protocol over
    Transport Layer Security (TLS) with Mutual X.509
    Authentication\"]{.refTitle}, [RFC 7589]{.seriesInfo}, [DOI
    10.17487/RFC7589]{.seriesInfo}, June 2015,
    \<<https://www.rfc-editor.org/info/rfc7589>\>.
:   

\[RFC7752\]
:   [Gredler, H., Ed.]{.refAuthor}, [Medved, J.]{.refAuthor},
    [Previdi, S.]{.refAuthor}, [Farrel, A.]{.refAuthor}, and [S.
    Ray]{.refAuthor}, [\"North-Bound Distribution of Link-State and
    Traffic Engineering (TE) Information Using BGP\"]{.refTitle}, [RFC
    7752]{.seriesInfo}, [DOI 10.17487/RFC7752]{.seriesInfo}, March 2016,
    \<<https://www.rfc-editor.org/info/rfc7752>\>.
:   

\[RFC7950\]
:   [Bjorklund, M., Ed.]{.refAuthor}, [\"The YANG 1.1 Data Modeling
    Language\"]{.refTitle}, [RFC 7950]{.seriesInfo}, [DOI
    10.17487/RFC7950]{.seriesInfo}, August 2016,
    \<<https://www.rfc-editor.org/info/rfc7950>\>.
:   

\[RFC7988\]
:   [Rosen, E., Ed.]{.refAuthor}, [Subramanian, K.]{.refAuthor}, and [Z.
    Zhang]{.refAuthor}, [\"Ingress Replication Tunnels in Multicast
    VPN\"]{.refTitle}, [RFC 7988]{.seriesInfo}, [DOI
    10.17487/RFC7988]{.seriesInfo}, October 2016,
    \<<https://www.rfc-editor.org/info/rfc7988>\>.
:   

\[RFC8040\]
:   [Bierman, A.]{.refAuthor}, [Bjorklund, M.]{.refAuthor}, and [K.
    Watsen]{.refAuthor}, [\"RESTCONF Protocol\"]{.refTitle}, [RFC
    8040]{.seriesInfo}, [DOI 10.17487/RFC8040]{.seriesInfo}, January
    2017, \<<https://www.rfc-editor.org/info/rfc8040>\>.
:   

\[RFC8253\]
:   [Lopez, D.]{.refAuthor}, [Gonzalez de Dios, O.]{.refAuthor},
    [Wu, Q.]{.refAuthor}, and [D. Dhody]{.refAuthor}, [\"PCEPS: Usage of
    TLS to Provide a Secure Transport for the Path Computation Element
    Communication Protocol (PCEP)\"]{.refTitle}, [RFC
    8253]{.seriesInfo}, [DOI 10.17487/RFC8253]{.seriesInfo}, October
    2017, \<<https://www.rfc-editor.org/info/rfc8253>\>.
:   

\[RFC8345\]
:   [Clemm, A.]{.refAuthor}, [Medved, J.]{.refAuthor},
    [Varga, R.]{.refAuthor}, [Bahadur, N.]{.refAuthor},
    [Ananthakrishnan, H.]{.refAuthor}, and [X. Liu]{.refAuthor}, [\"A
    YANG Data Model for Network Topologies\"]{.refTitle}, [RFC
    8345]{.seriesInfo}, [DOI 10.17487/RFC8345]{.seriesInfo}, March 2018,
    \<<https://www.rfc-editor.org/info/rfc8345>\>.
:   

\[RFC8401\]
:   [Ginsberg, L., Ed.]{.refAuthor}, [Przygienda, T.]{.refAuthor},
    [Aldrin, S.]{.refAuthor}, and [Z. Zhang]{.refAuthor}, [\"Bit Index
    Explicit Replication (BIER) Support via IS-IS\"]{.refTitle}, [RFC
    8401]{.seriesInfo}, [DOI 10.17487/RFC8401]{.seriesInfo}, June 2018,
    \<<https://www.rfc-editor.org/info/rfc8401>\>.
:   

\[RFC8402\]
:   [Filsfils, C., Ed.]{.refAuthor}, [Previdi, S., Ed.]{.refAuthor},
    [Ginsberg, L.]{.refAuthor}, [Decraene, B.]{.refAuthor},
    [Litkowski, S.]{.refAuthor}, and [R. Shakir]{.refAuthor}, [\"Segment
    Routing Architecture\"]{.refTitle}, [RFC 8402]{.seriesInfo}, [DOI
    10.17487/RFC8402]{.seriesInfo}, July 2018,
    \<<https://www.rfc-editor.org/info/rfc8402>\>.
:   

\[RFC8444\]
:   [Psenak, P., Ed.]{.refAuthor}, [Kumar, N.]{.refAuthor}, [Wijnands,
    IJ.]{.refAuthor}, [Dolganow, A.]{.refAuthor},
    [Przygienda, T.]{.refAuthor}, [Zhang, J.]{.refAuthor}, and [S.
    Aldrin]{.refAuthor}, [\"OSPFv2 Extensions for Bit Index Explicit
    Replication (BIER)\"]{.refTitle}, [RFC 8444]{.seriesInfo}, [DOI
    10.17487/RFC8444]{.seriesInfo}, November 2018,
    \<<https://www.rfc-editor.org/info/rfc8444>\>.
:   

\[RFC8556\]
:   [Rosen, E., Ed.]{.refAuthor}, [Sivakumar, M.]{.refAuthor},
    [Przygienda, T.]{.refAuthor}, [Aldrin, S.]{.refAuthor}, and [A.
    Dolganow]{.refAuthor}, [\"Multicast VPN Using Bit Index Explicit
    Replication (BIER)\"]{.refTitle}, [RFC 8556]{.seriesInfo}, [DOI
    10.17487/RFC8556]{.seriesInfo}, April 2019,
    \<<https://www.rfc-editor.org/info/rfc8556>\>.
:   

\[TE-OVERVIEW\]
:   [Farrel, A., Ed.]{.refAuthor}, [\"Overview and Principles of
    Internet Traffic Engineering\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-teas-rfc3272bis-21]{.seriesInfo}, 11 September 2022,
    \<<https://datatracker.ietf.org/doc/html/draft-ietf-teas-rfc3272bis-21>\>.
:   
:::
:::

::: {#SR}
::: {#appendix-A .section}
## [Appendix A.](#appendix-A){.section-number .selfRef} [BIER-TE and Segment Routing (SR)](#name-bier-te-and-segment-routing){.section-name .selfRef} {#name-bier-te-and-segment-routing}

SR \[[RFC8402](#RFC8402){.cite .xref}\] aims to enable lightweight path
steering via loose source routing. For example, compared to its more
heavyweight predecessor, RSVP-TE, SR does not require per-path signaling
to each of these hops.[¶](#appendix-A-1){.pilcrow}

BIER-TE supports the same design philosophy for multicast. Like SR,
BIER-TE[¶](#appendix-A-2){.pilcrow}

-   [relies on source routing (via a BitString),
    and[¶](#appendix-A-3.1){.pilcrow}]{#appendix-A-3.1}
-   [only requires consideration of the \"hops\" either (1) on which
    replication has to happen or (2) across which the traffic should be
    steered (even without
    replication).[¶](#appendix-A-3.2){.pilcrow}]{#appendix-A-3.2}

Any other hops can be skipped via the use of routed
adjacencies.[¶](#appendix-A-4){.pilcrow}

BIER-TE \"bit positions\" (BPs) can be understood as the BIER-TE
equivalent of \"forwarding segments\" in SR, but they have a different
scope than do forwarding segments in SR. Whereas forwarding segments in
SR are global or local, BPs in BIER-TE have a scope that is comprised of
one or more BFRs that have adjacencies for the BPs in their BIFTs. These
segments can be called \"adjacency-scoped\" forwarding
segments.[¶](#appendix-A-5){.pilcrow}

Adjacency scope could be global, but then every BFR would need an
adjacency for a given BP \-- for example, a forward_routed() adjacency
with encapsulation to the global SR \"Segment Identifier\" (SID) of the
destination. Such a BP would always result in ingress replication,
though (as in \[[RFC7988](#RFC7988){.cite .xref}\]). The first BFR
encountering this BP would directly replicate traffic on it. Only by
using non-global adjacency scope for BPs can traffic be steered and
replicated on a non-BFIR.[¶](#appendix-A-6){.pilcrow}

SR can naturally be combined with BIER-TE and can help optimize it. For
example, instead of defining bit positions for non-replicating hops, it
is equally possible to use SR encapsulations (e.g., SR-MPLS label
stacks) for the encapsulation of \"forward_routed()\"
adjacencies.[¶](#appendix-A-7){.pilcrow}

Note that (non-TE) BIER itself can also be seen as being similar to SR.
BIER BPs act as global destination Node-SIDs, and the BIER BitString is
simply a highly optimized mechanism to indicate multiple such SIDs and
let the network take care of effectively replicating the packet hop by
hop to each destination Node-SID. BIER does not allow the indication of
intermediate hops or, in terms of SR, the ability to indicate a sequence
of SIDs to reach the destination. On the other hand, BIER-TE and its
adjacency-scoped BPs provide these
capabilities.[¶](#appendix-A-8){.pilcrow}
:::
:::

::: {#ack}
::: {#appendix-B .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

The authors would like to thank [Greg Shepherd]{.contact-name},
[IJsbrand Wijnands]{.contact-name}, [Neale Ranns]{.contact-name}, [Dirk
Trossen]{.contact-name}, [Sandy Zheng]{.contact-name}, [Lou
Berger]{.contact-name}, [Jeffrey Zhang]{.contact-name}, [Carsten
Bormann]{.contact-name}, and [Wolfgang Braun]{.contact-name} for their
reviews and suggestions.[¶](#appendix-B-1){.pilcrow}

Special thanks to [Xuesong Geng]{.contact-name} for shepherding this
document. Special thanks also for IESG review/suggestions by [Alvaro
Retana]{.contact-name} (responsible AD/RTG), [Benjamin
Kaduk]{.contact-name} (SEC), [Tommy Pauly]{.contact-name} (TSV),
[Zaheduzzaman Sarker]{.contact-name} (TSV), [Éric Vyncke]{.contact-name}
(INT), [Martin Vigoureux]{.contact-name} (RTG), [Robert
Wilton]{.contact-name} (OPS), [Erik Kline]{.contact-name} (INT), [Lars
Eggert]{.contact-name} (GEN), [Roman Danyliw]{.contact-name} (SEC),
[Ines Robles]{.contact-name} (RTGDIR), [Robert Sparks]{.contact-name}
(Gen-ART), [Yingzhen Qu]{.contact-name} (RTGDIR), and [Martin
Duke]{.contact-name} (TSV).[¶](#appendix-B-2){.pilcrow}
:::
:::

::: {#authors-addresses}
::: {#appendix-C .section}
## [Authors\' Addresses](#name-authors-addresses){.section-name .selfRef} {#name-authors-addresses}

::: {.left dir="auto"}
[Toerless Eckert ([editor]{.role})]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Futurewei Technologies Inc.]{.org}
:::

::: {.left dir="auto"}
[2330 Central Expy]{.street-address}
:::

::: {.left dir="auto"}
[Santa Clara]{.locality}, [CA]{.region} [95050]{.postal-code}
:::

::: {.left dir="auto"}
[United States of America]{.country-name}
:::

::: email
Email: <tte@cs.fau.de>
:::

::: {.left dir="auto"}
[Michael Menth]{.fn .nameRole}
:::

::: {.left dir="auto"}
[University of Tuebingen]{.org}
:::

::: {.left dir="auto"}
[Germany]{.country-name}
:::

::: email
Email: <menth@uni-tuebingen.de>
:::

::: {.left dir="auto"}
[Gregory Cauchie]{.fn .nameRole}
:::

::: {.left dir="auto"}
[KOEVOO]{.org}
:::

::: {.left dir="auto"}
[France]{.country-name}
:::

::: email
Email: <gregory@koevoo.tech>
:::
:::
:::
