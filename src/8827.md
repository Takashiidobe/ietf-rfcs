  RFC 8827   WebRTC Sec. Arch.   January 2021
  ---------- ------------------- --------------
  Rescorla   Standards Track     \[Page\]

::: {#external-metadata .document-information}
:::

::: {#internal-metadata .document-information}

Stream:
:   Internet Engineering Task Force (IETF)

RFC:
:   [8827](https://www.rfc-editor.org/rfc/rfc8827){.eref}

Category:
:   Standards Track

Published:
:   January 2021

ISSN:
:   2070-1721

Author:

:   ::: author
    ::: author-name
    E. Rescorla
    :::

    ::: org
    Mozilla
    :::
    :::
:::

# RFC 8827 {#rfcnum}

# WebRTC Security Architecture {#title}

::: {#section-abstract .section}
## [Abstract](#abstract){.selfRef}

This document defines the security architecture for WebRTC, a protocol
suite intended for use with real-time applications that can be deployed
in browsers \-- \"real-time communication on the
Web\".[¶](#section-abstract-1){.pilcrow}
:::

::: {#status-of-memo}
::: {#section-boilerplate.1 .section}
## [Status of This Memo](#name-status-of-this-memo){.section-name .selfRef} {#name-status-of-this-memo}

This is an Internet Standards Track
document.[¶](#section-boilerplate.1-1){.pilcrow}

This document is a product of the Internet Engineering Task Force
(IETF). It represents the consensus of the IETF community. It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG). Further information on
Internet Standards is available in Section 2 of RFC
7841.[¶](#section-boilerplate.1-2){.pilcrow}

Information about the current status of this document, any errata, and
how to provide feedback on it may be obtained at
<https://www.rfc-editor.org/info/rfc8827>.[¶](#section-boilerplate.1-3){.pilcrow}
:::
:::

::: {#copyright}
::: {#section-boilerplate.2 .section}
## [Copyright Notice](#name-copyright-notice){.section-name .selfRef} {#name-copyright-notice}

Copyright (c) 2021 IETF Trust and the persons identified as the document
authors. All rights reserved.[¶](#section-boilerplate.2-1){.pilcrow}

This document is subject to BCP 78 and the IETF Trust\'s Legal
Provisions Relating to IETF Documents
(<https://trustee.ietf.org/license-info>) in effect on the date of
publication of this document. Please review these documents carefully,
as they describe your rights and restrictions with respect to this
document. Code Components extracted from this document must include
Simplified BSD License text as described in Section 4.e of the Trust
Legal Provisions and are provided without warranty as described in the
Simplified BSD License.[¶](#section-boilerplate.2-2){.pilcrow}

This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November 10,
2008. The person(s) controlling the copyright in some of this material
may not have granted the IETF Trust the right to allow modifications of
such material outside the IETF Standards Process. Without obtaining an
adequate license from the person(s) controlling the copyright in such
materials, this document may not be modified outside the IETF Standards
Process, and derivative works of it may not be created outside the IETF
Standards Process, except to format it for publication as an RFC or to
translate it into languages other than
English.[¶](#section-boilerplate.2-3){.pilcrow}
:::
:::

::: {#toc}
::: {#section-toc.1 .section}
[▲](#){.toplink}

## [Table of Contents](#name-table-of-contents){.section-name .selfRef} {#name-table-of-contents}

-   ::: {#section-toc.1-1.1}
    [1](#section-1){.xref}.  [Introduction](#name-introduction){.xref}[¶](#section-toc.1-1.1.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.2}
    [2](#section-2){.xref}.  [Terminology](#name-terminology){.xref}[¶](#section-toc.1-1.2.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.3}
    [3](#section-3){.xref}.  [Trust
    Model](#name-trust-model){.xref}[¶](#section-toc.1-1.3.1){.pilcrow}

    -   ::: {#section-toc.1-1.3.2.1}
        [3.1](#section-3.1){.xref}.  [Authenticated
        Entities](#name-authenticated-entities){.xref}[¶](#section-toc.1-1.3.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.3.2.2}
        [3.2](#section-3.2){.xref}.  [Unauthenticated
        Entities](#name-unauthenticated-entities){.xref}[¶](#section-toc.1-1.3.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.4}
    [4](#section-4){.xref}.  [Overview](#name-overview){.xref}[¶](#section-toc.1-1.4.1){.pilcrow}

    -   ::: {#section-toc.1-1.4.2.1}
        [4.1](#section-4.1){.xref}.  [Initial
        Signaling](#name-initial-signaling){.xref}[¶](#section-toc.1-1.4.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.2}
        [4.2](#section-4.2){.xref}.  [Media Consent
        Verification](#name-media-consent-verification){.xref}[¶](#section-toc.1-1.4.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.3}
        [4.3](#section-4.3){.xref}.  [DTLS
        Handshake](#name-dtls-handshake){.xref}[¶](#section-toc.1-1.4.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.4.2.4}
        [4.4](#section-4.4){.xref}.  [Communications and Consent
        Freshness](#name-communications-and-consent-){.xref}[¶](#section-toc.1-1.4.2.4.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.5}
    [5](#section-5){.xref}.  [SDP Identity
    Attribute](#name-sdp-identity-attribute){.xref}[¶](#section-toc.1-1.5.1){.pilcrow}

    -   ::: {#section-toc.1-1.5.2.1}
        [5.1](#section-5.1){.xref}.  [Offer/Answer
        Considerations](#name-offer-answer-considerations){.xref}[¶](#section-toc.1-1.5.2.1.1){.pilcrow}

        -   ::: {#section-toc.1-1.5.2.1.2.1}
            [5.1.1](#section-5.1.1){.xref}.  [Generating the Initial SDP
            Offer](#name-generating-the-initial-sdp-){.xref}[¶](#section-toc.1-1.5.2.1.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.2}
            [5.1.2](#section-5.1.2){.xref}.  [Generating an SDP
            Answer](#name-generating-an-sdp-answer){.xref}[¶](#section-toc.1-1.5.2.1.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.3}
            [5.1.3](#section-5.1.3){.xref}.  [Processing an SDP Offer or
            Answer](#name-processing-an-sdp-offer-or-){.xref}[¶](#section-toc.1-1.5.2.1.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.5.2.1.2.4}
            [5.1.4](#section-5.1.4){.xref}.  [Modifying the
            Session](#name-modifying-the-session){.xref}[¶](#section-toc.1-1.5.2.1.2.4.1){.pilcrow}
            :::
        :::
    :::

-   ::: {#section-toc.1-1.6}
    [6](#section-6){.xref}.  [Detailed Technical
    Description](#name-detailed-technical-descript){.xref}[¶](#section-toc.1-1.6.1){.pilcrow}

    -   ::: {#section-toc.1-1.6.2.1}
        [6.1](#section-6.1){.xref}.  [Origin and Web Security
        Issues](#name-origin-and-web-security-iss){.xref}[¶](#section-toc.1-1.6.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.2}
        [6.2](#section-6.2){.xref}.  [Device Permissions
        Model](#name-device-permissions-model){.xref}[¶](#section-toc.1-1.6.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.3}
        [6.3](#section-6.3){.xref}.  [Communications
        Consent](#name-communications-consent){.xref}[¶](#section-toc.1-1.6.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.4}
        [6.4](#section-6.4){.xref}.  [IP Location
        Privacy](#name-ip-location-privacy){.xref}[¶](#section-toc.1-1.6.2.4.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.6.2.5}
        [6.5](#section-6.5){.xref}.  [Communications
        Security](#name-communications-security){.xref}[¶](#section-toc.1-1.6.2.5.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.7}
    [7](#section-7){.xref}.  [Web-Based Peer
    Authentication](#name-web-based-peer-authenticati){.xref}[¶](#section-toc.1-1.7.1){.pilcrow}

    -   ::: {#section-toc.1-1.7.2.1}
        [7.1](#section-7.1){.xref}.  [Trust Relationships: IdPs, APs,
        and
        RPs](#name-trust-relationships-idps-ap){.xref}[¶](#section-toc.1-1.7.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.2}
        [7.2](#section-7.2){.xref}.  [Overview of
        Operation](#name-overview-of-operation){.xref}[¶](#section-toc.1-1.7.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.3}
        [7.3](#section-7.3){.xref}.  [Items for
        Standardization](#name-items-for-standardization){.xref}[¶](#section-toc.1-1.7.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.4}
        [7.4](#section-7.4){.xref}.  [Binding Identity Assertions to
        JSEP Offer/Answer
        Transactions](#name-binding-identity-assertions){.xref}[¶](#section-toc.1-1.7.2.4.1){.pilcrow}

        -   ::: {#section-toc.1-1.7.2.4.2.1}
            [7.4.1](#section-7.4.1){.xref}.  [Carrying Identity
            Assertions](#name-carrying-identity-assertion){.xref}[¶](#section-toc.1-1.7.2.4.2.1.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.7.2.5}
        [7.5](#section-7.5){.xref}.  [Determining the IdP
        URI](#name-determining-the-idp-uri){.xref}[¶](#section-toc.1-1.7.2.5.1){.pilcrow}

        -   ::: {#section-toc.1-1.7.2.5.2.1}
            [7.5.1](#section-7.5.1){.xref}.  [Authenticating
            Party](#name-authenticating-party){.xref}[¶](#section-toc.1-1.7.2.5.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.7.2.5.2.2}
            [7.5.2](#section-7.5.2){.xref}.  [Relying
            Party](#name-relying-party){.xref}[¶](#section-toc.1-1.7.2.5.2.2.1){.pilcrow}
            :::
        :::

    -   ::: {#section-toc.1-1.7.2.6}
        [7.6](#section-7.6){.xref}.  [Requesting
        Assertions](#name-requesting-assertions){.xref}[¶](#section-toc.1-1.7.2.6.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.7.2.7}
        [7.7](#section-7.7){.xref}.  [Managing User
        Login](#name-managing-user-login){.xref}[¶](#section-toc.1-1.7.2.7.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.8}
    [8](#section-8){.xref}.  [Verifying
    Assertions](#name-verifying-assertions){.xref}[¶](#section-toc.1-1.8.1){.pilcrow}

    -   ::: {#section-toc.1-1.8.2.1}
        [8.1](#section-8.1){.xref}.  [Identity
        Formats](#name-identity-formats){.xref}[¶](#section-toc.1-1.8.2.1.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.9}
    [9](#section-9){.xref}.  [Security
    Considerations](#name-security-considerations){.xref}[¶](#section-toc.1-1.9.1){.pilcrow}

    -   ::: {#section-toc.1-1.9.2.1}
        [9.1](#section-9.1){.xref}.  [Communications
        Security](#name-communications-security-2){.xref}[¶](#section-toc.1-1.9.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.2}
        [9.2](#section-9.2){.xref}.  [Privacy](#name-privacy){.xref}[¶](#section-toc.1-1.9.2.2.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.3}
        [9.3](#section-9.3){.xref}.  [Denial of
        Service](#name-denial-of-service){.xref}[¶](#section-toc.1-1.9.2.3.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.9.2.4}
        [9.4](#section-9.4){.xref}.  [IdP Authentication
        Mechanism](#name-idp-authentication-mechanis){.xref}[¶](#section-toc.1-1.9.2.4.1){.pilcrow}

        -   ::: {#section-toc.1-1.9.2.4.2.1}
            [9.4.1](#section-9.4.1){.xref}.  [PeerConnection Origin
            Check](#name-peerconnection-origin-check){.xref}[¶](#section-toc.1-1.9.2.4.2.1.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.9.2.4.2.2}
            [9.4.2](#section-9.4.2){.xref}.  [IdP Well-Known
            URI](#name-idp-well-known-uri){.xref}[¶](#section-toc.1-1.9.2.4.2.2.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.9.2.4.2.3}
            [9.4.3](#section-9.4.3){.xref}.  [Privacy of IdP-Generated
            Identities and the Hosting
            Site](#name-privacy-of-idp-generated-id){.xref}[¶](#section-toc.1-1.9.2.4.2.3.1){.pilcrow}
            :::

        -   ::: {#section-toc.1-1.9.2.4.2.4}
            [9.4.4](#section-9.4.4){.xref}.  [Security of Third-Party
            IdPs](#name-security-of-third-party-idp){.xref}[¶](#section-toc.1-1.9.2.4.2.4.1){.pilcrow}

            -   ::: {#section-toc.1-1.9.2.4.2.4.2.1}
                [9.4.4.1](#section-9.4.4.1){.xref}.  [Confusable
                Characters](#name-confusable-characters){.xref}[¶](#section-toc.1-1.9.2.4.2.4.2.1.1){.pilcrow}
                :::
            :::

        -   ::: {#section-toc.1-1.9.2.4.2.5}
            [9.4.5](#section-9.4.5){.xref}.  [Web Security Feature
            Interactions](#name-web-security-feature-intera){.xref}[¶](#section-toc.1-1.9.2.4.2.5.1){.pilcrow}

            -   ::: {#section-toc.1-1.9.2.4.2.5.2.1}
                [9.4.5.1](#section-9.4.5.1){.xref}.  [Popup
                Blocking](#name-popup-blocking){.xref}[¶](#section-toc.1-1.9.2.4.2.5.2.1.1){.pilcrow}
                :::

            -   ::: {#section-toc.1-1.9.2.4.2.5.2.2}
                [9.4.5.2](#section-9.4.5.2){.xref}.  [Third Party
                Cookies](#name-third-party-cookies){.xref}[¶](#section-toc.1-1.9.2.4.2.5.2.2.1){.pilcrow}
                :::
            :::
        :::
    :::

-   ::: {#section-toc.1-1.10}
    [10](#section-10){.xref}. [IANA
    Considerations](#name-iana-considerations){.xref}[¶](#section-toc.1-1.10.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.11}
    [11](#section-11){.xref}. [References](#name-references){.xref}[¶](#section-toc.1-1.11.1){.pilcrow}

    -   ::: {#section-toc.1-1.11.2.1}
        [11.1](#section-11.1){.xref}.  [Normative
        References](#name-normative-references){.xref}[¶](#section-toc.1-1.11.2.1.1){.pilcrow}
        :::

    -   ::: {#section-toc.1-1.11.2.2}
        [11.2](#section-11.2){.xref}.  [Informative
        References](#name-informative-references){.xref}[¶](#section-toc.1-1.11.2.2.1){.pilcrow}
        :::
    :::

-   ::: {#section-toc.1-1.12}
    [](#section-appendix.a){.xref}[Acknowledgements](#name-acknowledgements){.xref}[¶](#section-toc.1-1.12.1){.pilcrow}
    :::

-   ::: {#section-toc.1-1.13}
    [](#section-appendix.b){.xref}[Author\'s
    Address](#name-authors-address){.xref}[¶](#section-toc.1-1.13.1){.pilcrow}
    :::
:::
:::

::: {#sec.introduction}
::: {#section-1 .section}
## [1.](#section-1){.section-number .selfRef} [Introduction](#name-introduction){.section-name .selfRef} {#name-introduction}

The Real-Time Communications on the Web (RTCWEB) Working Group
standardized protocols for real-time communications between Web
browsers, generally called \"WebRTC\" \[[RFC8825](#RFC8825){.xref}\].
The major use cases for WebRTC technology are real-time audio and/or
video calls, Web conferencing, and direct data transfer. Unlike most
conventional real-time systems (e.g., SIP-based
\[[RFC3261](#RFC3261){.xref}\] soft phones), WebRTC communications are
directly controlled by some Web server, via a JavaScript (JS) API as
shown in [Figure 1](#fig.simple){.xref}.[¶](#section-1-1){.pilcrow}

[]{#name-a-simple-webrtc-system}

::: {#fig.simple}
::: {#section-1-2.1 .artwork .art-text .alignLeft}
                             +----------------+
                             |                |
                             |   Web Server   |
                             |                |
                             +----------------+
                                 ^        ^
                                /          \
                        HTTP   /            \   HTTP
                              /              \
                             /                \
                            v                  v
                         JS API              JS API
                   +-----------+            +-----------+
                   |           |    Media   |           |
                   |  Browser  |<---------->|  Browser  |
                   |           |            |           |
                   +-----------+            +-----------+
:::

[Figure 1](#figure-1){.selfRef}: [A Simple WebRTC
System](#name-a-simple-webrtc-system){.selfRef}
:::

A more complicated system might allow for inter-domain calling, as shown
in [Figure 2](#fig.multidomain){.xref}. The protocol to be used between
the domains is not standardized by WebRTC, but given the installed base
and the form of the WebRTC API is likely to be something SDP-based like
SIP or something like the Extensible Messaging and Presence Protocol
(XMPP) \[[RFC6120](#RFC6120){.xref}\].[¶](#section-1-3){.pilcrow}

[]{#name-a-multidomain-webrtc-system}

::: {#fig.multidomain}
::: {#section-1-4.1 .artwork .art-text .alignLeft}
              +--------------+                +--------------+
              |              | SIP, XMPP, ... |              |
              |  Web Server  |<-------------->|  Web Server  |
              |              |                |              |
              +--------------+                +--------------+
                     ^                                ^
                     |                                |
               HTTP  |                                |  HTTP
                     |                                |
                     v                                v
                     JS API                       JS API
               +-----------+                     +-----------+
               |           |        Media        |           |
               |  Browser  |<------------------->|  Browser  |
               |           |                     |           |
               +-----------+                     +-----------+
:::

[Figure 2](#figure-2){.selfRef}: [A Multidomain WebRTC
System](#name-a-multidomain-webrtc-system){.selfRef}
:::

This system presents a number of new security challenges, which are
analyzed in \[[RFC8826](#RFC8826){.xref}\]. This document describes a
security architecture for WebRTC which addresses the threats and
requirements described in that document.[¶](#section-1-5){.pilcrow}
:::
:::

::: {#sec-term}
::: {#section-2 .section}
## [2.](#section-2){.section-number .selfRef} [Terminology](#name-terminology){.section-name .selfRef} {#name-terminology}

The key words \"[MUST]{.bcp14}\", \"[MUST NOT]{.bcp14}\",
\"[REQUIRED]{.bcp14}\", \"[SHALL]{.bcp14}\", \"[SHALL NOT]{.bcp14}\",
\"[SHOULD]{.bcp14}\", \"[SHOULD NOT]{.bcp14}\",
\"[RECOMMENDED]{.bcp14}\", \"[NOT RECOMMENDED]{.bcp14}\",
\"[MAY]{.bcp14}\", and \"[OPTIONAL]{.bcp14}\" in this document are to be
interpreted as described in BCP 14 \[[RFC2119](#RFC2119){.xref}\]
\[[RFC8174](#RFC8174){.xref}\] when, and only when, they appear in all
capitals, as shown here.[¶](#section-2-1){.pilcrow}
:::
:::

::: {#sec.proposal.trusthierarchy}
::: {#section-3 .section}
## [3.](#section-3){.section-number .selfRef} [Trust Model](#name-trust-model){.section-name .selfRef} {#name-trust-model}

The basic assumption of this architecture is that network resources
exist in a hierarchy of trust, rooted in the browser, which serves as
the user\'s Trusted Computing Base (TCB). Any security property which
the user wishes to have enforced must be ultimately guaranteed by the
browser (or transitively by some property the browser verifies).
Conversely, if the browser is compromised, then no security guarantees
are possible. Note that there are cases (e.g., Internet kiosks) where
the user can\'t really trust the browser that much. In these cases, the
level of security provided is limited by how much they trust the
browser.[¶](#section-3-1){.pilcrow}

Optimally, we would not rely on trust in any entities other than the
browser. However, this is unfortunately not possible if we wish to have
a functional system. Other network elements fall into two categories:
those which can be authenticated by the browser and thus can be granted
permissions to access sensitive resources, and those which cannot be
authenticated and thus are untrusted.[¶](#section-3-2){.pilcrow}

::: {#sec.proposal.authenticated}
::: {#section-3.1 .section}
### [3.1.](#section-3.1){.section-number .selfRef} [Authenticated Entities](#name-authenticated-entities){.section-name .selfRef} {#name-authenticated-entities}

There are two major classes of authenticated entities in the
system:[¶](#section-3.1-1){.pilcrow}

[]{.break}

Calling services:
:   Web sites whose origin we can verify (optimally via HTTPS, but in
    some cases because we are on a topologically restricted network,
    such as behind a firewall, and can infer authentication from
    firewall behavior).[¶](#section-3.1-2.2){.pilcrow}
:   

Other users:
:   WebRTC peers whose origin we can verify cryptographically (optimally
    via DTLS-SRTP).[¶](#section-3.1-2.4){.pilcrow}
:   

Note that merely being authenticated does not make these entities
trusted. For instance, just because we can verify that
\<https://www.example.org/> is owned by Dr. Evil does not mean that we
can trust Dr. Evil to access our camera and microphone. However, it
gives the user an opportunity to determine whether they wish to trust
Dr. Evil or not; after all, if they desire to contact Dr. Evil (perhaps
to arrange for ransom payment), it\'s safe to temporarily give them
access to the camera and microphone for the purpose of the call, but
they don\'t want Dr. Evil to be able to access their camera and
microphone other than during the call. The point here is that we must
first identify other elements before we can determine whether and how
much to trust them. Additionally, sometimes we need to identify the
communicating peer before we know what policies to
apply.[¶](#section-3.1-3){.pilcrow}
:::
:::

::: {#sec.proposal.unauthenticated}
::: {#section-3.2 .section}
### [3.2.](#section-3.2){.section-number .selfRef} [Unauthenticated Entities](#name-unauthenticated-entities){.section-name .selfRef} {#name-unauthenticated-entities}

Other than the above entities, we are not generally able to identify
other network elements; thus, we cannot trust them. This does not mean
that it is not possible to have any interaction with them, but it means
that we must assume that they will behave maliciously and design a
system which is secure even if they do so.[¶](#section-3.2-1){.pilcrow}
:::
:::
:::
:::

::: {#sec.proposal.overview}
::: {#section-4 .section}
## [4.](#section-4){.section-number .selfRef} [Overview](#name-overview){.section-name .selfRef} {#name-overview}

This section describes a typical WebRTC session and shows how the
various security elements interact and what guarantees are provided to
the user. The example in this section is a \"best case\" scenario in
which we provide the maximal amount of user authentication and media
privacy with the minimal level of trust in the calling service. Simpler
versions with lower levels of security are also possible and are noted
in the text where applicable. It\'s also important to recognize the
tension between security (or performance) and privacy. The example shown
here is aimed towards settings where we are more concerned about secure
calling than about privacy, but as we shall see, there are settings
where one might wish to make different tradeoffs \-- this architecture
is still compatible with those settings.[¶](#section-4-1){.pilcrow}

For the purposes of this example, we assume the topology shown in the
figures below. This topology is derived from the topology shown in
[Figure 1](#fig.simple){.xref}, but separates Alice\'s and Bob\'s
identities from the process of signaling. Specifically, Alice and Bob
have relationships with some Identity Provider (IdP) that supports a
protocol (such as OpenID Connect) that can be used to demonstrate their
identity to other parties. For instance, Alice might have an account
with a social network which she can then use to authenticate to other
Web sites without explicitly having an account with those sites; this is
a fairly conventional pattern on the Web. [Section
7.1](#sec.trust-relationships){.xref} provides an overview of IdPs and
the relevant terminology. Alice and Bob might have relationships with
different IdPs as well. Note: The IdP mechanism described here has not
seen wide adoption. See [Section 7](#sec.generic.idp){.xref} for more on
the status of IdP-based authentication.[¶](#section-4-2){.pilcrow}

This separation of identity provision and signaling isn\'t particularly
important in \"closed world\" cases where Alice and Bob are users on the
same social network and have identities based on that domain ([Figure
3](#fig.proposal.idp){.xref}). However, there are important settings
where that is not the case, such as federation (calls from one domain to
another; see [Figure 4](#fig.proposal-federated.idp){.xref}) and calling
on untrusted sites, such as where two users who have a relationship via
a given social network want to call each other on another, untrusted,
site, such as a poker site.[¶](#section-4-3){.pilcrow}

Note that the servers themselves are also authenticated by an external
identity service, the SSL/TLS certificate infrastructure (not shown). As
is conventional in the Web, all identities are ultimately rooted in that
system. For instance, when an IdP makes an identity assertion, the
Relying Party consuming that assertion is able to verify because it is
able to connect to the IdP via HTTPS.[¶](#section-4-4){.pilcrow}

[]{#name-a-call-with-idp-based-ident}

::: {#fig.proposal.idp}
::: {#section-4-5.1 .artwork .art-text .alignLeft}
                                +----------------+
                                |                |
                                |     Signaling  |
                                |     Server     |
                                |                |
                                +----------------+
                                    ^        ^
                                   /          \
                           HTTPS  /            \   HTTPS
                                 /              \
                                /                \
                               v                  v
                            JS API              JS API
                      +-----------+            +-----------+
                      |           |    Media   |           |
                Alice |  Browser  |<---------->|  Browser  | Bob
                      |           | (DTLS+SRTP)|           |
                      +-----------+            +-----------+
                            ^      ^--+     +--^     ^
                            |         |     |        |
                            v         |     |        v
                      +-----------+   |     |  +-----------+
                      |           |<--------+  |           |
                      |   IdP1    |   |        |    IdP2   |
                      |           |   +------->|           |
                      +-----------+            +-----------+
:::

[Figure 3](#figure-3){.selfRef}: [A Call with IdP-Based
Identity](#name-a-call-with-idp-based-ident){.selfRef}
:::

[Figure 4](#fig.proposal-federated.idp){.xref} shows essentially the
same calling scenario but with a call between two separate domains
(i.e., a federated case), as in [Figure 2](#fig.multidomain){.xref}. As
mentioned above, the domains communicate by some unspecified protocol,
and providing separate signaling and identity allows for calls to be
authenticated regardless of the details of the inter-domain
protocol.[¶](#section-4-6){.pilcrow}

[]{#name-a-federated-call-with-idp-b}

::: {#fig.proposal-federated.idp}
::: {#section-4-7.1 .artwork .art-text .alignLeft}
            +----------------+    Unspecified    +----------------+
            |                |      protocol     |                |
            |    Signaling   |<----------------->|    Signaling   |
            |    Server      |  (SIP, XMPP, ...) |    Server      |
            |                |                   |                |
            +----------------+                   +----------------+
                     ^                                   ^
                     |                                   |
               HTTPS |                                   | HTTPS
                     |                                   |
                     |                                   |
                     v                                   v
                  JS API                               JS API
            +-----------+                             +-----------+
            |           |             Media           |           |
      Alice |  Browser  |<--------------------------->|  Browser  | Bob
            |           |           DTLS+SRTP         |           |
            +-----------+                             +-----------+
                  ^      ^--+                      +--^     ^
                  |         |                      |        |
                  v         |                      |        v
            +-----------+   |                      |  +-----------+
            |           |<-------------------------+  |           |
            |   IdP1    |   |                         |    IdP2   |
            |           |   +------------------------>|           |
            +-----------+                             +-----------+
:::

[Figure 4](#figure-4){.selfRef}: [A Federated Call with IdP-Based
Identity](#name-a-federated-call-with-idp-b){.selfRef}
:::

::: {#section-4.1 .section}
### [4.1.](#section-4.1){.section-number .selfRef} [Initial Signaling](#name-initial-signaling){.section-name .selfRef} {#name-initial-signaling}

For simplicity, assume the topology in [Figure
3](#fig.proposal.idp){.xref}. Alice and Bob are both users of a common
calling service; they both have approved the calling service to make
calls (we defer the discussion of device access permissions until
later). They are both connected to the calling service via HTTPS and so
know the origin with some level of confidence. They also have accounts
with some IdP. This sort of identity service is becoming increasingly
common in the Web environment (with technologies such as Federated
Google Login, Facebook Connect, OAuth, OpenID, WebFinger), and is often
provided as a side effect service of a user\'s ordinary accounts with
some service. In this example, we show Alice and Bob using a separate
identity service, though the identity service may be the same entity as
the calling service or there may be no identity service at
all.[¶](#section-4.1-1){.pilcrow}

Alice is logged onto the calling service and decides to call Bob. She
can see from the calling service that he is online and the calling
service presents a JS UI in the form of a button next to Bob\'s name
which says \"Call\". Alice clicks the button, which initiates a JS
callback that instantiates a PeerConnection object. This does not
require a security check: JS from any origin is allowed to get this
far.[¶](#section-4.1-2){.pilcrow}

Once the PeerConnection is created, the calling service JS needs to set
up some media. Because this is an audio/video call, it creates a
MediaStream with two MediaStreamTracks, one connected to an audio input
and one connected to a video input. At this point, the first security
check is required: untrusted origins are not allowed to access the
camera and microphone, so the browser prompts Alice for
permission.[¶](#section-4.1-3){.pilcrow}

In the current W3C API, once some streams have been added, Alice\'s
browser + JS generates a signaling message
\[[RFC8829](#RFC8829){.xref}\] containing:[¶](#section-4.1-4){.pilcrow}

-   [Media channel
    information[¶](#section-4.1-5.1){.pilcrow}]{#section-4.1-5.1}
-   [Interactive Connectivity Establishment (ICE)
    \[[RFC8445](#RFC8445){.xref}\]
    candidates[¶](#section-4.1-5.2){.pilcrow}]{#section-4.1-5.2}
-   [A \"fingerprint\" attribute binding the communication to a key pair
    \[[RFC5763](#RFC5763){.xref}\]. Note that this key may simply be
    ephemerally generated for this call or specific to this domain, and
    Alice may have a large number of such
    keys.[¶](#section-4.1-5.3){.pilcrow}]{#section-4.1-5.3}

Prior to sending out the signaling message, the PeerConnection code
contacts the identity service and obtains an assertion binding Alice\'s
identity to her fingerprint. The exact details depend on the identity
service (though as discussed in [Section 7](#sec.generic.idp){.xref}
PeerConnection can be agnostic to them), but for now it\'s easiest to
think of as an OAuth token. The assertion may bind other information to
the identity besides the fingerprint, but at minimum it needs to bind
the fingerprint.[¶](#section-4.1-6){.pilcrow}

This message is sent to the signaling server, e.g., by fetch()
\[[fetch](#fetch){.xref}\] or by WebSockets
\[[RFC6455](#RFC6455){.xref}\], over TLS \[[RFC8446](#RFC8446){.xref}\].
The signaling server processes the message from Alice\'s browser,
determines that this is a call to Bob, and sends a signaling message to
Bob\'s browser (again, the format is currently undefined). The JS on
Bob\'s browser processes it, and alerts Bob to the incoming call and to
Alice\'s identity. In this case, Alice has provided an identity
assertion and so Bob\'s browser contacts Alice\'s IdP (again, this is
done in a generic way so the browser has no specific knowledge of the
IdP) to verify the assertion. It is also possible to have IdPs with
which the browser has a specific trust relationship, as described in
[Section 7.1](#sec.trust-relationships){.xref}. This allows the browser
to display a trusted element in the browser chrome indicating that a
call is coming in from Alice. If Alice is in Bob\'s address book, then
this interface might also include her real name, a picture, etc. The
calling site will also provide some user interface element (e.g., a
button) to allow Bob to answer the call, though this is most likely not
part of the trusted UI.[¶](#section-4.1-7){.pilcrow}

If Bob agrees, a PeerConnection is instantiated with the message from
Alice\'s side. Then, a similar process occurs as on Alice\'s browser:
Bob\'s browser prompts him for device permission, the media streams are
created, and a return signaling message containing media information,
ICE candidates, and a fingerprint is sent back to Alice via the
signaling service. If Bob has a relationship with an IdP, the message
will also come with an identity assertion.[¶](#section-4.1-8){.pilcrow}

At this point, Alice and Bob each know that the other party wants to
have a secure call with them. Based purely on the interface provided by
the signaling server, they know that the signaling server claims that
the call is from Alice to Bob. This level of security is provided merely
by having the fingerprint in the message and having that message
received securely from the signaling server. Because the far end sent an
identity assertion along with their message, they know that this is
verifiable from the IdP as well. Note that if the call is federated, as
shown in [Figure 4](#fig.proposal-federated.idp){.xref}, then Alice is
able to verify Bob\'s identity in a way that is not mediated by either
her signaling server or Bob\'s. Rather, she verifies it directly with
Bob\'s IdP.[¶](#section-4.1-9){.pilcrow}

Of course, the call works perfectly well if either Alice or Bob doesn\'t
have a relationship with an IdP; they just get a lower level of
assurance. I.e., they simply have whatever information their calling
site claims about the caller/callee\'s identity. Moreover, Alice might
wish to make an anonymous call through an anonymous calling site, in
which case she would of course just not provide any identity assertion
and the calling site would mask her identity from
Bob.[¶](#section-4.1-10){.pilcrow}
:::

::: {#section-4.2 .section}
### [4.2.](#section-4.2){.section-number .selfRef} [Media Consent Verification](#name-media-consent-verification){.section-name .selfRef} {#name-media-consent-verification}

As described in \[[RFC8826](#RFC8826){.xref}\], [Section
4.2](https://www.rfc-editor.org/rfc/rfc8826#section-4.2){.relref}, media
consent verification is provided via ICE. Thus, Alice and Bob perform
ICE checks with each other. At the completion of these checks, they are
ready to send non-ICE data.[¶](#section-4.2-1){.pilcrow}

At this point, Alice knows that (a) Bob (assuming he is verified via his
IdP) or someone else who the signaling service is claiming is Bob is
willing to exchange traffic with her and (b) either Bob is at the IP
address which she has verified via ICE or there is an attacker who is
on-path to that IP address detouring the traffic. Note that it is not
possible for an attacker who is on-path between Alice and Bob but not
attached to the signaling service to spoof these checks because they do
not have the ICE credentials. Bob has the same security guarantees with
respect to Alice.[¶](#section-4.2-2){.pilcrow}
:::

::: {#section-4.3 .section}
### [4.3.](#section-4.3){.section-number .selfRef} [DTLS Handshake](#name-dtls-handshake){.section-name .selfRef} {#name-dtls-handshake}

Once the requisite ICE checks have completed, Alice and Bob can set up a
secure channel or channels. This is performed via DTLS
\[[RFC6347](#RFC6347){.xref}\] and DTLS-SRTP
\[[RFC5763](#RFC5763){.xref}\] keying for SRTP
\[[RFC3711](#RFC3711){.xref}\] for the media channel and the Stream
Control Transmission Protocol (SCTP) over DTLS
\[[RFC8261](#RFC8261){.xref}\] for data channels. Specifically, Alice
and Bob perform a DTLS handshake on every component which has been
established by ICE. The total number of channels depends on the amount
of muxing; in the most likely case, we are using both RTP/RTCP mux and
muxing multiple media streams on the same channel, in which case there
is only one DTLS handshake. Once the DTLS handshake has completed, the
keys are exported \[[RFC5705](#RFC5705){.xref}\] and used to key SRTP
for the media channels.[¶](#section-4.3-1){.pilcrow}

At this point, Alice and Bob know that they share a set of secure data
and/or media channels with keys which are not known to any third-party
attacker. If Alice and Bob authenticated via their IdPs, then they also
know that the signaling service is not mounting a man-in-the-middle
attack on their traffic. Even if they do not use an IdP, as long as they
have minimal trust in the signaling service not to perform a
man-in-the-middle attack, they know that their communications are secure
against the signaling service as well (i.e., that the signaling service
cannot mount a passive attack on the
communications).[¶](#section-4.3-2){.pilcrow}
:::

::: {#section-4.4 .section}
### [4.4.](#section-4.4){.section-number .selfRef} [Communications and Consent Freshness](#name-communications-and-consent-){.section-name .selfRef} {#name-communications-and-consent-}

From a security perspective, everything from here on in is a little
anticlimactic: Alice and Bob exchange data protected by the keys
negotiated by DTLS. Because of the security guarantees discussed in the
previous sections, they know that the communications are encrypted and
authenticated.[¶](#section-4.4-1){.pilcrow}

The one remaining security property we need to establish is \"consent
freshness\", i.e., allowing Alice to verify that Bob is still prepared
to receive her communications so that Alice does not continue to send
large traffic volumes to entities which went abruptly offline. ICE
specifies periodic Session Traversal Utilities for NAT (STUN) keepalives
but only if media is not flowing. Because the consent issue is more
difficult here, we require WebRTC implementations to periodically send
keepalives using the consent freshness mechanism specified in
\[[RFC7675](#RFC7675){.xref}\]. If a keepalive fails and no new ICE
channels can be established, then the session is
terminated.[¶](#section-4.4-2){.pilcrow}
:::
:::
:::

::: {#sec.sdp-id-attr}
::: {#section-5 .section}
## [5.](#section-5){.section-number .selfRef} [SDP Identity Attribute](#name-sdp-identity-attribute){.section-name .selfRef} {#name-sdp-identity-attribute}

The SDP \"identity\" attribute is a session-level attribute that is used
by an endpoint to convey its identity assertion to its peer. The
identity-assertion value is encoded as base64, as described in [Section
4](https://www.rfc-editor.org/rfc/rfc4648#section-4){.relref} of
\[[RFC4648](#RFC4648){.xref}\].[¶](#section-5-1){.pilcrow}

The procedures in this section are based on the assumption that the
identity assertion of an endpoint is bound to the fingerprints of the
endpoint. This does not preclude the definition of alternative means of
binding an assertion to the endpoint, but such means are outside the
scope of this specification.[¶](#section-5-2){.pilcrow}

The semantics of multiple \"identity\" attributes within an offer or
answer are undefined. Implementations [SHOULD]{.bcp14} only include a
single \"identity\" attribute in an offer or answer, and Relying Parties
[MAY]{.bcp14} elect to ignore all but the first \"identity\"
attribute.[¶](#section-5-3){.pilcrow}

[]{.break}

Name:
:   identity[¶](#section-5-4.2){.pilcrow}
:   

Value:
:   identity-assertion[¶](#section-5-4.4){.pilcrow}
:   

Usage Level:
:   session[¶](#section-5-4.6){.pilcrow}
:   

Charset Dependent:
:   no[¶](#section-5-4.8){.pilcrow}
:   

Default Value:
:   N/A[¶](#section-5-4.10){.pilcrow}
:   

Syntax:[¶](#section-5-5){.pilcrow}

::: {#section-5-6}
``` {.sourcecode .lang-abnf}
 identity-assertion       = identity-assertion-value
                            *(SP identity-extension)
 identity-assertion-value = base64
 identity-extension       = extension-name [ "=" extension-value ]
 extension-name           = token
 extension-value          = 1*(%x01-09 / %x0b-0c / %x0e-3a / %x3c-ff)
                            ; byte-string from [RFC4566]

 <ALPHA and DIGIT as defined in [RFC4566]>
 <base64 as defined in [RFC4566]>
```

[¶](#section-5-6){.pilcrow}
:::

Example:[¶](#section-5-7){.pilcrow}

::: {#section-5-8}
``` {.sourcecode .lang-sdp}
 a=identity:\
   eyJpZHAiOnsiZG9tYWluIjoiZXhhbXBsZS5vcmciLCJwcm90b2NvbCI6ImJvZ3Vz\
   In0sImFzc2VydGlvbiI6IntcImlkZW50aXR5XCI6XCJib2JAZXhhbXBsZS5vcmdc\
   IixcImNvbnRlbnRzXCI6XCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3l6XCIsXCJz\
   aWduYXR1cmVcIjpcIjAxMDIwMzA0MDUwNlwifSJ9
```

[¶](#section-5-8){.pilcrow}
:::

Note that long lines in the example are folded to meet the column width
constraints of this document; the backslash (\"\\\") at the end of a
line, the carriage return that follows, and whitespace shall be
ignored.[¶](#section-5-9.1){.pilcrow}

This specification does not define any extensions for the
attribute.[¶](#section-5-10){.pilcrow}

The identity-assertion value is a JSON encoded string
\[[RFC8259](#RFC8259){.xref}\]. The JSON object contains two keys:
\"assertion\" and \"idp\". The \"assertion\" key value contains an
opaque string that is consumed by the IdP. The \"idp\" key value
contains a dictionary with one or two further values that identify the
IdP. See [Section 7.6](#sec.request-assert){.xref} for more
details.[¶](#section-5-11){.pilcrow}

::: {#sec.sdp-id-attr-oa}
::: {#section-5.1 .section}
### [5.1.](#section-5.1){.section-number .selfRef} [Offer/Answer Considerations](#name-offer-answer-considerations){.section-name .selfRef} {#name-offer-answer-considerations}

This section defines the SDP offer/answer \[[RFC3264](#RFC3264){.xref}\]
considerations for the SDP \"identity\"
attribute.[¶](#section-5.1-1){.pilcrow}

Within this section, \'initial offer\' refers to the first offer in the
SDP session that contains an SDP \"identity\"
attribute.[¶](#section-5.1-2){.pilcrow}

::: {#sec.sdp-id-attr-oa-inio}
::: {#section-5.1.1 .section}
#### [5.1.1.](#section-5.1.1){.section-number .selfRef} [Generating the Initial SDP Offer](#name-generating-the-initial-sdp-){.section-name .selfRef} {#name-generating-the-initial-sdp-}

When an offerer sends an offer, in order to provide its identity
assertion to the peer, it includes an \"identity\" attribute in the
offer. In addition, the offerer includes one or more SDP \"fingerprint\"
attributes. The \"identity\" attribute [MUST]{.bcp14} be bound to all
the \"fingerprint\" attributes in the session
description.[¶](#section-5.1.1-1){.pilcrow}
:::
:::

::: {#sec.sdp-id-attr-oa-ansa}
::: {#section-5.1.2 .section}
#### [5.1.2.](#section-5.1.2){.section-number .selfRef} [Generating an SDP Answer](#name-generating-an-sdp-answer){.section-name .selfRef} {#name-generating-an-sdp-answer}

If the answerer elects to include an \"identity\" attribute, it follows
the same steps as those in [Section
5.1.1](#sec.sdp-id-attr-oa-inio){.xref}. The answerer can choose to
include or omit an \"identity\" attribute independently, regardless of
whether the offerer did so.[¶](#section-5.1.2-1){.pilcrow}
:::
:::

::: {#sec.sdp-id-attr-oa-offa}
::: {#section-5.1.3 .section}
#### [5.1.3.](#section-5.1.3){.section-number .selfRef} [Processing an SDP Offer or Answer](#name-processing-an-sdp-offer-or-){.section-name .selfRef} {#name-processing-an-sdp-offer-or-}

When an endpoint receives an offer or answer that contains an
\"identity\" attribute, the answerer can use the attribute information
to contact the IdP and verify the identity of the peer. If the identity
requires a third-party IdP as described in [Section
7.1](#sec.trust-relationships){.xref}, then that IdP will need to have
been specifically configured. If the identity verification fails, the
answerer [MUST]{.bcp14} discard the offer or answer as
malformed.[¶](#section-5.1.3-1){.pilcrow}
:::
:::

::: {#sec.sdp-id-attr-oa-modi}
::: {#section-5.1.4 .section}
#### [5.1.4.](#section-5.1.4){.section-number .selfRef} [Modifying the Session](#name-modifying-the-session){.section-name .selfRef} {#name-modifying-the-session}

When modifying a session, if the set of fingerprints is unchanged, then
the sender [MAY]{.bcp14} send the same \"identity\" attribute. In this
case, the established identity [MUST]{.bcp14} be applied to existing
DTLS connections as well as new connections established using one of
those fingerprints. Note that \[[RFC8829](#RFC8829){.xref}\], [Section
5.2.1](https://www.rfc-editor.org/rfc/rfc8829#section-5.2.1){.relref}
requires that each media section use the same set of fingerprints. If a
new \"identity\" attribute is received, then the receiver [MUST]{.bcp14}
apply that identity to all existing
connections.[¶](#section-5.1.4-1){.pilcrow}

If the set of fingerprints changes, then the sender [MUST]{.bcp14}
either send a new \"identity\" attribute or none at all. Because a
change in fingerprints also causes a new DTLS connection to be
established, the receiver [MUST]{.bcp14} discard all previously
established identities.[¶](#section-5.1.4-2){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#sec.proposal.detailed}
::: {#section-6 .section}
## [6.](#section-6){.section-number .selfRef} [Detailed Technical Description](#name-detailed-technical-descript){.section-name .selfRef} {#name-detailed-technical-descript}

::: {#sec.proposal.origin}
::: {#section-6.1 .section}
### [6.1.](#section-6.1){.section-number .selfRef} [Origin and Web Security Issues](#name-origin-and-web-security-iss){.section-name .selfRef} {#name-origin-and-web-security-iss}

The basic unit of permissions for WebRTC is the origin
\[[RFC6454](#RFC6454){.xref}\]. Because the security of the origin
depends on being able to authenticate content from that origin, the
origin can only be securely established if data is transferred over
HTTPS \[[RFC2818](#RFC2818){.xref}\]. Thus, clients [MUST]{.bcp14} treat
HTTP and HTTPS origins as different permissions domains. Note: This
follows directly from the origin security model and is stated here
merely for clarity.[¶](#section-6.1-1){.pilcrow}

Many Web browsers currently forbid by default any active mixed content
on HTTPS pages. That is, when JavaScript is loaded from an HTTP origin
onto an HTTPS page, an error is displayed and the HTTP content is not
executed unless the user overrides the error. Any browser which enforces
such a policy will also not permit access to WebRTC functionality from
mixed content pages (because they never display mixed content). Browsers
which allow active mixed content [MUST]{.bcp14} nevertheless disable
WebRTC functionality in mixed content
settings.[¶](#section-6.1-2){.pilcrow}

Note that it is possible for a page which was not mixed content to
become mixed content during the duration of the call. The major risk
here is that the newly arrived insecure JS might redirect media to a
location controlled by the attacker. Implementations [MUST]{.bcp14}
either choose to terminate the call or display a warning at that
point.[¶](#section-6.1-3){.pilcrow}

Also note that the security architecture depends on the keying material
not being available to move between origins. However, it is assumed that
the identity assertion can be passed to anyone that the page cares
to.[¶](#section-6.1-4){.pilcrow}
:::
:::

::: {#sec.proposal.device.permissions}
::: {#section-6.2 .section}
### [6.2.](#section-6.2){.section-number .selfRef} [Device Permissions Model](#name-device-permissions-model){.section-name .selfRef} {#name-device-permissions-model}

Implementations [MUST]{.bcp14} obtain explicit user consent prior to
providing access to the camera and/or microphone. Implementations
[MUST]{.bcp14} at minimum support the following two permissions models
for HTTPS origins.[¶](#section-6.2-1){.pilcrow}

-   [Requests for one-time camera/microphone
    access.[¶](#section-6.2-2.1){.pilcrow}]{#section-6.2-2.1}
-   [Requests for permanent
    access.[¶](#section-6.2-2.2){.pilcrow}]{#section-6.2-2.2}

Because HTTP origins cannot be securely established against network
attackers, implementations [MUST]{.bcp14} refuse all permissions grants
for HTTP origins.[¶](#section-6.2-3){.pilcrow}

In addition, they [SHOULD]{.bcp14} support requests for access that
promise that media from this grant will be sent to a single
communicating peer (obviously there could be other requests for other
peers), e.g., \"Call customerservice\@example.org\". The semantics of
this request are that the media stream from the camera and microphone
will only be routed through a connection which has been
cryptographically verified (through the IdP mechanism or an X.509
certificate in the DTLS-SRTP handshake) as being associated with the
stated identity. Note that it is unlikely that browsers would have X.509
certificates, but servers might. Browsers servicing such requests
[SHOULD]{.bcp14} clearly indicate that identity to the user when asking
for permission. The idea behind this type of permissions is that a user
might have a fairly narrow list of peers they are willing to communicate
with, e.g., \"my mother\" rather than \"anyone on Facebook\". Narrow
permissions grants allow the browser to do that
enforcement.[¶](#section-6.2-4){.pilcrow}

[]{.break}

API Requirement:
:   The API [MUST]{.bcp14} provide a mechanism for the requesting JS to
    relinquish the ability to see or modify the media (e.g., via
    MediaStream.record()). Combined with secure authentication of the
    communicating peer, this allows a user to be sure that the calling
    site is not accessing or modifying their
    conversion.[¶](#section-6.2-5.2){.pilcrow}
:   

[]{.break}

UI Requirement:
:   The UI [MUST]{.bcp14} clearly indicate when the user\'s camera and
    microphone are in use. This indication [MUST NOT]{.bcp14} be
    suppressible by the JS and [MUST]{.bcp14} clearly indicate how to
    terminate device access, and provide a UI means to immediately stop
    camera/microphone input without the JS being able to prevent
    it.[¶](#section-6.2-6.2){.pilcrow}
:   

[]{.break}

UI Requirement:
:   If the UI indication of camera/microphone use is displayed in the
    browser such that minimizing the browser window would hide the
    indication, or the JS creating an overlapping window would hide the
    indication, then the browser [SHOULD]{.bcp14} stop camera and
    microphone input when the indication is hidden. (Note: This may not
    be necessary in systems that are non-windows-based but that have
    good notifications support, such as
    phones.)[¶](#section-6.2-7.2){.pilcrow}
:   

-   [Browsers [MUST NOT]{.bcp14} permit permanent screen or application
    sharing permissions to be installed as a response to a JS request
    for permissions. Instead, they must require some other user action
    such as a permissions setting or an application install experience
    to grant permission to a
    site.[¶](#section-6.2-8.1){.pilcrow}]{#section-6.2-8.1}
-   [Browsers [MUST]{.bcp14} provide a separate dialog request for
    screen/application sharing permissions even if the media request is
    made at the same time as the request for camera and microphone
    permissions.[¶](#section-6.2-8.2){.pilcrow}]{#section-6.2-8.2}
-   [The browser [MUST]{.bcp14} indicate any windows which are currently
    being shared in some unambiguous way. Windows which are not visible
    [MUST NOT]{.bcp14} be shared even if the application is being
    shared. If the screen is being shared, then that [MUST]{.bcp14} be
    indicated.[¶](#section-6.2-8.3){.pilcrow}]{#section-6.2-8.3}

Browsers [MAY]{.bcp14} permit the formation of data channels without any
direct user approval. Because sites can always tunnel data through the
server, further restrictions on the data channel do not provide any
additional security. (See [Section
6.3](#sec.proposal.communications.consent){.xref} for a related
issue.)[¶](#section-6.2-9){.pilcrow}

Implementations which support some form of direct user authentication
[SHOULD]{.bcp14} also provide a policy by which a user can authorize
calls only to specific communicating peers. Specifically, the
implementation [SHOULD]{.bcp14} provide the following
interfaces/controls:[¶](#section-6.2-10){.pilcrow}

-   [Allow future calls to this verified
    user.[¶](#section-6.2-11.1){.pilcrow}]{#section-6.2-11.1}
-   [Allow future calls to any verified user who is in my system address
    book (this only works with address book integration, of
    course).[¶](#section-6.2-11.2){.pilcrow}]{#section-6.2-11.2}

Implementations [SHOULD]{.bcp14} also provide a different user interface
indication when calls are in progress to users whose identities are
directly verifiable. [Section 6.5](#sec.proposal.comsec){.xref} provides
more on this.[¶](#section-6.2-12){.pilcrow}
:::
:::

::: {#sec.proposal.communications.consent}
::: {#section-6.3 .section}
### [6.3.](#section-6.3){.section-number .selfRef} [Communications Consent](#name-communications-consent){.section-name .selfRef} {#name-communications-consent}

Browser client implementations of WebRTC [MUST]{.bcp14} implement ICE.
Server gateway implementations which operate only at public IP addresses
[MUST]{.bcp14} implement either full ICE or ICE-Lite
\[[RFC8445](#RFC8445){.xref}\].[¶](#section-6.3-1){.pilcrow}

Browser implementations [MUST]{.bcp14} verify reachability via ICE prior
to sending any non-ICE packets to a given destination. Implementations
[MUST NOT]{.bcp14} provide the ICE transaction ID to JavaScript during
the lifetime of the transaction (i.e., during the period when the ICE
stack would accept a new response for that transaction). The JS [MUST
NOT]{.bcp14} be permitted to control the local ufrag and password,
though it of course knows it.[¶](#section-6.3-2){.pilcrow}

While continuing consent is required, the ICE
\[[RFC8445](#RFC8445){.xref}\], [Section
11](https://www.rfc-editor.org/rfc/rfc8445#section-11){.relref}
keepalives use STUN Binding Indications, which are one-way and therefore
not sufficient. The current WG consensus is to use ICE Binding Requests
for continuing consent freshness. ICE already requires that
implementations respond to such requests, so this approach is maximally
compatible. A separate document will profile the ICE timers to be used;
see \[[RFC7675](#RFC7675){.xref}\].[¶](#section-6.3-3){.pilcrow}
:::
:::

::: {#sec.proposal.ip.location.privacy}
::: {#section-6.4 .section}
### [6.4.](#section-6.4){.section-number .selfRef} [IP Location Privacy](#name-ip-location-privacy){.section-name .selfRef} {#name-ip-location-privacy}

A side effect of the default ICE behavior is that the peer learns one\'s
IP address, which leaks large amounts of location information. This has
negative privacy consequences in some circumstances. The API
requirements in this section are intended to mitigate this issue. Note
that these requirements are not intended to protect the user\'s IP
address from a malicious site. In general, the site will learn at least
a user\'s server-reflexive address from any HTTP transaction. Rather,
these requirements are intended to allow a site to cooperate with the
user to hide the user\'s IP address from the other side of the call.
Hiding the user\'s IP address from the server requires some sort of
explicit privacy-preserving mechanism on the client (e.g., Tor Browser
\<<https://www.torproject.org/projects/torbrowser.html.en>\>) and is out
of scope for this specification.[¶](#section-6.4-1){.pilcrow}

[]{.break}

API Requirement:
:   The API [MUST]{.bcp14} provide a mechanism to allow the JS to
    suppress ICE negotiation (though perhaps to allow candidate
    gathering) until the user has decided to answer the call. (Note:
    Determining when the call has been answered is a question for the
    JS.) This enables a user to prevent a peer from learning their IP
    address if they elect not to answer a call and also from learning
    whether the user is online.[¶](#section-6.4-2.2){.pilcrow}
:   

[]{.break}

API Requirement:
:   The API [MUST]{.bcp14} provide a mechanism for the calling
    application JS to indicate that only TURN candidates are to be used.
    This prevents the peer from learning one\'s IP address at all. This
    mechanism [MUST]{.bcp14} also permit suppression of the related
    address field, since that leaks local
    addresses.[¶](#section-6.4-3.2){.pilcrow}
:   

[]{.break}

API Requirement:
:   The API [MUST]{.bcp14} provide a mechanism for the calling
    application to reconfigure an existing call to add non-TURN
    candidates. Taken together, this and the previous requirement allow
    ICE negotiation to start immediately on incoming call notification,
    thus reducing post-dial delay, but also to avoid disclosing the
    user\'s IP address until they have decided to answer. They also
    allow users to completely hide their IP address for the duration of
    the call. Finally, they allow a mechanism for the user to optimize
    performance by reconfiguring to allow non-TURN candidates during an
    active call if the user decides they no longer need to hide their IP
    address.[¶](#section-6.4-4.2){.pilcrow}
:   

Note that some enterprises may operate proxies and/or NATs designed to
hide internal IP addresses from the outside world. WebRTC provides no
explicit mechanism to allow this function. Either such enterprises need
to proxy the HTTP/HTTPS and modify the SDP and/or the JS, or there needs
to be browser support to set the \"TURN-only\" policy regardless of the
site\'s preferences.[¶](#section-6.4-5){.pilcrow}

Note: These requirements are intended to allow sites to conceal the
user\'s IP address from the peer. For guidance on concealing the user\'s
IP address from the calling site see
\[[RFC8828](#RFC8828){.xref}\].[¶](#section-6.4-6){.pilcrow}
:::
:::

::: {#sec.proposal.comsec}
::: {#section-6.5 .section}
### [6.5.](#section-6.5){.section-number .selfRef} [Communications Security](#name-communications-security){.section-name .selfRef} {#name-communications-security}

Implementations [MUST]{.bcp14} support SRTP
\[[RFC3711](#RFC3711){.xref}\]. Implementations [MUST]{.bcp14} support
DTLS \[[RFC6347](#RFC6347){.xref}\] and DTLS-SRTP
\[[RFC5763](#RFC5763){.xref}\] \[[RFC5764](#RFC5764){.xref}\] for SRTP
keying. Implementations [MUST]{.bcp14} support SCTP over DTLS
\[[RFC8261](#RFC8261){.xref}\].[¶](#section-6.5-1){.pilcrow}

All media channels [MUST]{.bcp14} be secured via SRTP and the Secure
Real-time Transport Control Protocol (SRTCP). Media traffic [MUST
NOT]{.bcp14} be sent over plain (unencrypted) RTP or RTCP; that is,
implementations [MUST NOT]{.bcp14} negotiate cipher suites with NULL
encryption modes. DTLS-SRTP [MUST]{.bcp14} be offered for every media
channel. WebRTC implementations [MUST NOT]{.bcp14} offer SDP security
descriptions \[[RFC4568](#RFC4568){.xref}\] or select it if offered. An
SRTP Master Key Identifier (MKI) [MUST NOT]{.bcp14} be
used.[¶](#section-6.5-2){.pilcrow}

All data channels [MUST]{.bcp14} be secured via
DTLS.[¶](#section-6.5-3){.pilcrow}

All implementations [MUST]{.bcp14} support DTLS 1.2 with the
TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 cipher suite and the [P-256
curve](#FIPS186){.xref} \[[FIPS186](#FIPS186){.xref}\]. Earlier drafts
of this specification required DTLS 1.0 with the cipher suite
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, and at the time of this writing
some implementations do not support DTLS 1.2; endpoints which support
only DTLS 1.2 might encounter interoperability issues. The DTLS-SRTP
protection profile SRTP_AES128_CM_HMAC_SHA1_80 [MUST]{.bcp14} be
supported for SRTP. Implementations [MUST]{.bcp14} favor cipher suites
which support Forward Secrecy (FS) over non-FS cipher suites and
[SHOULD]{.bcp14} favor Authenticated Encryption with Associated Data
(AEAD) over non-AEAD cipher suites. Note: the IETF is in the process of
standardizing DTLS 1.3
\[[TLS-DTLS13](#I-D.ietf-tls-dtls13){.xref}\].[¶](#section-6.5-4){.pilcrow}

Implementations [MUST NOT]{.bcp14} implement DTLS renegotiation and
[MUST]{.bcp14} reject it with a \"no_renegotiation\" alert if
offered.[¶](#section-6.5-5){.pilcrow}

Endpoints [MUST NOT]{.bcp14} implement TLS False Start
\[[RFC7918](#RFC7918){.xref}\].[¶](#section-6.5-6){.pilcrow}

[]{.break}

API Requirement:
:   The API [MUST]{.bcp14} generate a new authentication key pair for
    every new call by default. This is intended to allow for
    unlinkability.[¶](#section-6.5-7.2){.pilcrow}
:   

API Requirement:
:   The API [MUST]{.bcp14} provide a means to reuse a key pair for
    calls. This can be used to enable key continuity-based
    authentication, and could be used to amortize key generation
    costs.[¶](#section-6.5-7.4){.pilcrow}
:   

API Requirement:
:   Unless the user specifically configures an external key pair,
    different key pairs [MUST]{.bcp14} be used for each origin. (This
    avoids creating a super-cookie.)[¶](#section-6.5-7.6){.pilcrow}
:   

API Requirement:
:   When DTLS-SRTP is used, the API [MUST NOT]{.bcp14} permit the JS to
    obtain the negotiated keying material. This requirement preserves
    the end-to-end security of the media.[¶](#section-6.5-7.8){.pilcrow}
:   

[]{.break}

UI Requirements:
:   A user-oriented client [MUST]{.bcp14} provide an \"inspector\"
    interface which allows the user to determine the \"security
    characteristics\" of the media.[¶](#section-6.5-8.2){.pilcrow}
:   

:   The following properties [SHOULD]{.bcp14} be displayed \"up-front\"
    in the browser chrome, i.e., without requiring the user to ask for
    them:[¶](#section-6.5-8.4){.pilcrow}
:   

:   -   [A client [MUST]{.bcp14} provide a user interface through which
        a user may determine the \"security characteristics\" for
        currently displayed audio and video
        stream(s).[¶](#section-6.5-8.6.1.1){.pilcrow}]{#section-6.5-8.6.1.1}
    -   [A client [MUST]{.bcp14} provide a user interface through which
        a user may determine the \"security characteristics\" for
        transmissions of their microphone audio and camera
        video.[¶](#section-6.5-8.6.1.2){.pilcrow}]{#section-6.5-8.6.1.2}
    -   [If the far endpoint was directly verified, either via a
        third-party verifiable X.509 certificate or via a Web IdP
        mechanism (see [Section 7](#sec.generic.idp){.xref}), the
        \"security characteristics\" [MUST]{.bcp14} include the verified
        information. X.509 identities and Web IdP identities have
        similar semantics and should be displayed in a similar
        way.[¶](#section-6.5-8.6.1.3){.pilcrow}]{#section-6.5-8.6.1.3}

:   

:   The following properties are more likely to require some
    \"drill-down\" from the user:[¶](#section-6.5-8.8){.pilcrow}
:   

:   -   [The \"security characteristics\" [MUST]{.bcp14} indicate the
        cryptographic algorithms in use (for example,
        \"AES-CBC\").[¶](#section-6.5-8.10.1.1){.pilcrow}]{#section-6.5-8.10.1.1}
    -   [The \"security characteristics\" [MUST]{.bcp14} indicate
        whether FS is
        provided.[¶](#section-6.5-8.10.1.2){.pilcrow}]{#section-6.5-8.10.1.2}
    -   [The \"security characteristics\" [MUST]{.bcp14} include some
        mechanism to allow an out-of-band verification of the peer, such
        as a certificate fingerprint or a Short Authentication String
        (SAS). These are compared by the peers to authenticate one
        another.[¶](#section-6.5-8.10.1.3){.pilcrow}]{#section-6.5-8.10.1.3}

:   
:::
:::
:::
:::

::: {#sec.generic.idp}
::: {#section-7 .section}
## [7.](#section-7){.section-number .selfRef} [Web-Based Peer Authentication](#name-web-based-peer-authenticati){.section-name .selfRef} {#name-web-based-peer-authenticati}

NOTE: The mechanism described in this section was designed relatively
early in the RTCWEB process. In retrospect, the WG was too optimistic
about the enthusiasm for this kind of mechanism. At the time of
publication, it has not been widely adopted or implemented. It appears
in this document as a description of the state of the art as of this
writing.[¶](#section-7-1){.pilcrow}

In a number of cases, it is desirable for the endpoint (i.e., the
browser) to be able to directly identify the endpoint on the other side
without trusting the signaling service to which they are connected. For
instance, users may be making a call via a federated system where they
wish to get direct authentication of the other side. Alternately, they
may be making a call on a site which they minimally trust (such as a
poker site) but to someone who has an identity on a site they do trust
(such as a social network).[¶](#section-7-2){.pilcrow}

Recently, a number of Web-based identity technologies (OAuth, Facebook
Connect, etc.) have been developed. While the details vary, what these
technologies share is that they have a Web-based (i.e., HTTP/HTTPS) IdP
which attests to Alice\'s identity. For instance, if Alice has an
account at example.org, Alice could use the example.org IdP to prove to
others that Alice is alice\@example.org. The development of these
technologies allows us to separate calling from identity provision:
Alice could call you on a poker site but identify herself as
alice\@example.org.[¶](#section-7-3){.pilcrow}

Whatever the underlying technology, the general principle is that the
party which is being authenticated is NOT the signaling site but rather
the user (and their browser). Similarly, the Relying Party is the
browser and not the signaling site. Thus, the browser [MUST]{.bcp14}
generate the input to the IdP assertion process and display the results
of the verification process to the user in a way which cannot be
imitated by the calling site.[¶](#section-7-4){.pilcrow}

The mechanisms defined in this document do not require the browser to
implement any particular identity protocol or to support any particular
IdP. Instead, this document provides a generic interface which any IdP
can implement. Thus, new IdPs and protocols can be introduced without
change to either the browser or the calling service. This avoids the
need to make a commitment to any particular identity protocol, although
browsers may opt to directly implement some identity protocols in order
to provide superior performance or UI
properties.[¶](#section-7-5){.pilcrow}

::: {#sec.trust-relationships}
::: {#section-7.1 .section}
### [7.1.](#section-7.1){.section-number .selfRef} [Trust Relationships: IdPs, APs, and RPs](#name-trust-relationships-idps-ap){.section-name .selfRef} {#name-trust-relationships-idps-ap}

Any federated identity protocol has three major
participants:[¶](#section-7.1-1){.pilcrow}

[]{.break}

Authenticating Party (AP):
:   The entity which is trying to establish its
    identity.[¶](#section-7.1-2.2){.pilcrow}
:   

Identity Provider (IdP):
:   The entity which is vouching for the AP\'s
    identity.[¶](#section-7.1-2.4){.pilcrow}
:   

Relying Party (RP):
:   The entity which is trying to verify the AP\'s
    identity.[¶](#section-7.1-2.6){.pilcrow}
:   

The AP and the IdP have an account relationship of some kind: the AP
registers with the IdP and is able to subsequently authenticate directly
to the IdP (e.g., with a password). This means that the browser must
somehow know which IdP(s) the user has an account relationship with.
This can either be something that the user configures into the browser
or that is configured at the calling site and then provided to the
PeerConnection by the Web application at the calling site. The use case
for having this information configured into the browser is that the user
may \"log into\" the browser to bind it to some identity. This is
becoming common in new browsers. However, it should also be possible for
the IdP information to simply be provided by the calling
application.[¶](#section-7.1-3){.pilcrow}

At a high level, there are two kinds of
IdPs:[¶](#section-7.1-4){.pilcrow}

[]{.break}

Authoritative:
:   IdPs which have verifiable control of some section of the identity
    space. For instance, in the realm of email, the operator of
    \"example.com\" has complete control of the namespace ending in
    \"\@example.com\". Thus, \"alice\@example.com\" is whoever the
    operator says it is. Examples of systems with authoritative IdPs
    include DNSSEC, an identity system for SIP (see
    \[[RFC8224](#RFC8224){.xref}\]), and Facebook Connect (Facebook
    identities only make sense within the context of the Facebook
    system).[¶](#section-7.1-5.2){.pilcrow}
:   

Third-Party:
:   IdPs which don\'t have control of their section of the identity
    space but instead verify users\' identities via some unspecified
    mechanism and then attest to it. Because the IdP doesn\'t actually
    control the namespace, RPs need to trust that the IdP is correctly
    verifying AP identities, and there can potentially be multiple IdPs
    attesting to the same section of the identity space. Probably the
    best-known example of a third-party IdP is SSL/TLS certificates,
    where there are a large number of certificate authorities (CAs) all
    of whom can attest to any domain
    name.[¶](#section-7.1-5.4){.pilcrow}
:   

If an AP is authenticating via an authoritative IdP, then the RP does
not need to explicitly configure trust in the IdP at all. The identity
mechanism can directly verify that the IdP indeed made the relevant
identity assertion (a function provided by the mechanisms in this
document), and any assertion it makes about an identity for which it is
authoritative is directly verifiable. Note that this does not mean that
the IdP might not lie, but that is a trustworthiness judgement that the
user can make at the time they look at the
identity.[¶](#section-7.1-6){.pilcrow}

By contrast, if an AP is authenticating via a third-party IdP, the RP
needs to explicitly trust that IdP (hence the need for an explicit trust
anchor list in PKI-based SSL/TLS clients). The list of trustable IdPs
needs to be configured directly into the browser, either by the user or
potentially by the browser manufacturer. This is a significant advantage
of authoritative IdPs and implies that if third-party IdPs are to be
supported, the potential number needs to be fairly
small.[¶](#section-7.1-7){.pilcrow}
:::
:::

::: {#sec.overview}
::: {#section-7.2 .section}
### [7.2.](#section-7.2){.section-number .selfRef} [Overview of Operation](#name-overview-of-operation){.section-name .selfRef} {#name-overview-of-operation}

In order to provide security without trusting the calling site, the
PeerConnection component of the browser must interact directly with the
IdP. The details of the mechanism are described in the W3C API
specification, but the general idea is that the PeerConnection component
downloads JS from a specific location on the IdP dictated by the IdP
domain name. That JS (the \"IdP proxy\") runs in an isolated security
context within the browser, and the PeerConnection talks to it via a
secure message passing channel.[¶](#section-7.2-1){.pilcrow}

Note that there are two logically separate functions
here:[¶](#section-7.2-2){.pilcrow}

-   [Identity assertion
    generation.[¶](#section-7.2-3.1){.pilcrow}]{#section-7.2-3.1}
-   [Identity assertion
    verification.[¶](#section-7.2-3.2){.pilcrow}]{#section-7.2-3.2}

The same IdP JS \"endpoint\" is used for both functions, but of course a
given IdP might behave differently and load new JS to perform one
function or the other.[¶](#section-7.2-4){.pilcrow}

::: {#section-7.2-5 .artwork .art-text .alignLeft}
         +--------------------------------------+
         | Browser                              |
         |                                      |
         | +----------------------------------+ |
         | | https://calling-site.example.com | |
         | |                                  | |
         | |        Calling JS Code           | |
         | |               ^                  | |
         | +---------------|------------------+ |
         |                 | API Calls          |
         |                 v                    |
         |          PeerConnection              |
         |                 ^                    |
         |                 | API Calls          |
         |     +-----------|-------------+      |   +---------------+
         |     |           v             |      |   |               |
         |     |       IdP Proxy         |<-------->|   Identity    |
         |     |                         |      |   |   Provider    |
         |     | https://idp.example.org |      |   |               |
         |     +-------------------------+      |   +---------------+
         |                                      |
         +--------------------------------------+

[¶](#section-7.2-5){.pilcrow}
:::

When the PeerConnection object wants to interact with the IdP, the
sequence of events is as follows:[¶](#section-7.2-6){.pilcrow}

1.  [The browser (the PeerConnection component) instantiates an IdP
    proxy. This allows the IdP to load whatever JS is necessary into the
    proxy. The resulting code runs in the IdP\'s security
    context.[¶](#section-7.2-7.1){.pilcrow}]{#section-7.2-7.1}
2.  [The IdP registers an object with the browser that conforms to the
    API defined in
    \[[webrtc-api](#webrtc-api){.xref}\].[¶](#section-7.2-7.2){.pilcrow}]{#section-7.2-7.2}
3.  [The browser invokes methods on the object registered by the IdP
    proxy to create or verify identity
    assertions.[¶](#section-7.2-7.3){.pilcrow}]{#section-7.2-7.3}

This approach allows us to decouple the browser from any particular IdP;
the browser need only know how to load the IdP\'s JavaScript \-- the
location of which is determined based on the IdP\'s identity \-- and to
call the generic API for requesting and verifying identity assertions.
The IdP provides whatever logic is necessary to bridge the generic
protocol to the IdP\'s specific requirements. Thus, a single browser can
support any number of identity protocols, including being forward
compatible with IdPs which did not exist at the time the browser was
written.[¶](#section-7.2-8){.pilcrow}
:::
:::

::: {#sec.standardized}
::: {#section-7.3 .section}
### [7.3.](#section-7.3){.section-number .selfRef} [Items for Standardization](#name-items-for-standardization){.section-name .selfRef} {#name-items-for-standardization}

There are two parts to this work:[¶](#section-7.3-1){.pilcrow}

-   [The precise information from the signaling message that must be
    cryptographically bound to the user\'s identity and a mechanism for
    carrying assertions in JavaScript Session Establishment Protocol
    (JSEP) messages. This is specified in [Section
    7.4](#sec.jsep-binding){.xref}.[¶](#section-7.3-2.1){.pilcrow}]{#section-7.3-2.1}
-   [The interface to the IdP, which is defined in the companion W3C
    WebRTC API specification
    \[[webrtc-api](#webrtc-api){.xref}\].[¶](#section-7.3-2.2){.pilcrow}]{#section-7.3-2.2}

The WebRTC API specification also defines JavaScript interfaces that the
calling application can use to specify which IdP to use. That API also
provides access to the assertion-generation capability and the status of
the validation process.[¶](#section-7.3-3){.pilcrow}
:::
:::

::: {#sec.jsep-binding}
::: {#section-7.4 .section}
### [7.4.](#section-7.4){.section-number .selfRef} [Binding Identity Assertions to JSEP Offer/Answer Transactions](#name-binding-identity-assertions){.section-name .selfRef} {#name-binding-identity-assertions}

An identity assertion binds the user\'s identity (as asserted by the
IdP) to the SDP offer/answer exchange and specifically to the media. In
order to achieve this, the PeerConnection must provide the DTLS-SRTP
fingerprint to be bound to the identity. This is provided as a
JavaScript object (also known as a dictionary or hash) with a single
\"fingerprint\" key, as shown below:[¶](#section-7.4-1){.pilcrow}

::: {#section-7.4-2}
``` {.sourcecode .lang-json}
{
  "fingerprint":
    [
      { "algorithm": "sha-256",
        "digest": "4A:AD:B9:B1:3F:...:E5:7C:AB" },
      { "algorithm": "sha-1",
        "digest": "74:E9:76:C8:19:...:F4:45:6B" }
    ]
}
```

[¶](#section-7.4-2){.pilcrow}
:::

The \"fingerprint\" value is an array of objects. Each object in the
array contains \"algorithm\" and \"digest\" values, which correspond
directly to the algorithm and digest values in the \"fingerprint\"
attribute of the SDP
\[[RFC8122](#RFC8122){.xref}\].[¶](#section-7.4-3){.pilcrow}

This object is encoded in a [JSON](#RFC8259){.xref}
\[[RFC8259](#RFC8259){.xref}\] string for passing to the IdP. The
identity assertion returned by the IdP, which is encoded in the
\"identity\" attribute, is a JSON object that is encoded as described in
[Section
7.4.1](#sec.carry-assertion){.xref}.[¶](#section-7.4-4){.pilcrow}

This structure does not need to be interpreted by the IdP or the IdP
proxy. It is consumed solely by the RP\'s browser. The IdP merely treats
it as an opaque value to be attested to. Thus, new parameters can be
added to the assertion without modifying the
IdP.[¶](#section-7.4-5){.pilcrow}

::: {#sec.carry-assertion}
::: {#section-7.4.1 .section}
#### [7.4.1.](#section-7.4.1){.section-number .selfRef} [Carrying Identity Assertions](#name-carrying-identity-assertion){.section-name .selfRef} {#name-carrying-identity-assertion}

Once an IdP has generated an assertion (see [Section
7.6](#sec.request-assert){.xref}), it is attached to the SDP
offer/answer message. This is done by adding a new \"identity\"
attribute to the SDP. The sole contents of this value is the identity
assertion. The identity assertion produced by the IdP is encoded into a
UTF-8 JSON text, then [base64-encoded](#RFC4648){.xref}
\[[RFC4648](#RFC4648){.xref}\] to produce this string. For
example:[¶](#section-7.4.1-1){.pilcrow}

::: {#section-7.4.1-2}
``` {.sourcecode .lang-sdp}
v=0
o=- 1181923068 1181923196 IN IP4 ua1.example.com
s=example1
c=IN IP4 ua1.example.com
a=fingerprint:sha-1 \
  4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB
a=identity:\
  eyJpZHAiOnsiZG9tYWluIjoiZXhhbXBsZS5vcmciLCJwcm90b2NvbCI6ImJvZ3Vz\
  In0sImFzc2VydGlvbiI6IntcImlkZW50aXR5XCI6XCJib2JAZXhhbXBsZS5vcmdc\
  IixcImNvbnRlbnRzXCI6XCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3l6XCIsXCJz\
  aWduYXR1cmVcIjpcIjAxMDIwMzA0MDUwNlwifSJ9
a=...
t=0 0
m=audio 6056 RTP/SAVP 0
a=sendrecv
...
```

[¶](#section-7.4.1-2){.pilcrow}
:::

Note that long lines in the example are folded to meet the column width
constraints of this document; the backslash (\"\\\") at the end of a
line, the carriage return that follows, and whitespace shall be
ignored.[¶](#section-7.4.1-3.1){.pilcrow}

The \"identity\" attribute attests to all \"fingerprint\" attributes in
the session description. It is therefore a session-level
attribute.[¶](#section-7.4.1-4){.pilcrow}

Multiple \"fingerprint\" values can be used to offer alternative
certificates for a peer. The \"identity\" attribute [MUST]{.bcp14}
include all \"fingerprint\" values that are included in \"fingerprint\"
attributes of the session description.[¶](#section-7.4.1-5){.pilcrow}

The RP browser [MUST]{.bcp14} verify that the in-use certificate for a
DTLS connection is in the set of fingerprints returned from the IdP when
verifying an assertion.[¶](#section-7.4.1-6){.pilcrow}
:::
:::
:::
:::

::: {#sec.idp-uri}
::: {#section-7.5 .section}
### [7.5.](#section-7.5){.section-number .selfRef} [Determining the IdP URI](#name-determining-the-idp-uri){.section-name .selfRef} {#name-determining-the-idp-uri}

In order to ensure that the IdP is under control of the domain owner
rather than someone who merely has an account on the domain owner\'s
server (e.g., in shared hosting scenarios), the IdP JavaScript is hosted
at a deterministic location based on the IdP\'s domain name. Each IdP
proxy instance is associated with two
values:[¶](#section-7.5-1){.pilcrow}

[]{.break}

authority:
:   The [authority](#RFC3986){.xref} \[[RFC3986](#RFC3986){.xref}\] at
    which the IdP\'s service is hosted.[¶](#section-7.5-2.2){.pilcrow}
:   

protocol:
:   The specific IdP protocol which the IdP is using. This is a
    completely opaque IdP-specific string, but allows an IdP to
    implement two protocols in parallel. This value may be the empty
    string. If no value for protocol is provided, a value of \"default\"
    is used.[¶](#section-7.5-2.4){.pilcrow}
:   

Each IdP [MUST]{.bcp14} serve its initial entry page (i.e., the one
loaded by the IdP proxy) from a [well-known URI](#RFC8615){.xref}
\[[RFC8615](#RFC8615){.xref}\]. The well-known URI for an IdP proxy is
formed from the following URI components:[¶](#section-7.5-3){.pilcrow}

1.  [The scheme, \"https:\". An IdP [MUST]{.bcp14} be loaded using
    [HTTPS](#RFC2818){.xref}
    \[[RFC2818](#RFC2818){.xref}\].[¶](#section-7.5-4.1){.pilcrow}]{#section-7.5-4.1}
2.  [The [authority](#RFC3986){.xref} \[[RFC3986](#RFC3986){.xref}\]. As
    noted above, the authority [MAY]{.bcp14} contain a non-default port
    number or userinfo sub-component. Both are removed when determining
    if an asserted identity matches the name of the
    IdP.[¶](#section-7.5-4.2){.pilcrow}]{#section-7.5-4.2}
3.  [The path, starting with \"/.well-known/idp-proxy/\" and appended
    with the IdP protocol. Note that the separator characters \'/\'
    (%2F) and \'\\\' (%5C) [MUST NOT]{.bcp14} be permitted in the
    protocol field, lest an attacker be able to direct requests outside
    of the controlled \"/.well-known/\" prefix. Query and fragment
    values [MAY]{.bcp14} be used by including \'?\' or \'#\'
    characters.[¶](#section-7.5-4.3){.pilcrow}]{#section-7.5-4.3}

For example, for the IdP \"identity.example.com\" and the protocol
\"example\", the URL would be:[¶](#section-7.5-5){.pilcrow}

::: {#section-7.5-6 .artwork .art-text .alignLeft}
    https://identity.example.com/.well-known/idp-proxy/example

[¶](#section-7.5-6){.pilcrow}
:::

The IdP [MAY]{.bcp14} redirect requests to this URL, but they
[MUST]{.bcp14} retain the \"https:\" scheme. This changes the effective
origin of the IdP, but not the domain of the identities that the IdP is
permitted to assert and validate. I.e., the IdP is still regarded as
authoritative for the original domain.[¶](#section-7.5-7){.pilcrow}

::: {#section-7.5.1 .section}
#### [7.5.1.](#section-7.5.1){.section-number .selfRef} [Authenticating Party](#name-authenticating-party){.section-name .selfRef} {#name-authenticating-party}

How an AP determines the appropriate IdP domain is out of scope of this
specification. In general, however, the AP has some actual account
relationship with the IdP, as this identity is what the IdP is attesting
to. Thus, the AP somehow supplies the IdP information to the browser.
Some potential mechanisms include:[¶](#section-7.5.1-1){.pilcrow}

-   [Provided by the user
    directly.[¶](#section-7.5.1-2.1){.pilcrow}]{#section-7.5.1-2.1}
-   [Selected from some set of IdPs known to the calling site (e.g., a
    button that shows \"Authenticate via Facebook
    Connect\").[¶](#section-7.5.1-2.2){.pilcrow}]{#section-7.5.1-2.2}
:::

::: {#section-7.5.2 .section}
#### [7.5.2.](#section-7.5.2){.section-number .selfRef} [Relying Party](#name-relying-party){.section-name .selfRef} {#name-relying-party}

Unlike the AP, the RP need not have any particular relationship with the
IdP. Rather, it needs to be able to process whatever assertion is
provided by the AP. As the assertion contains the IdP\'s identity in the
\"idp\" field of the JSON-encoded object (see [Section
7.6](#sec.request-assert){.xref}), the URI can be constructed directly
from the assertion, and thus the RP can directly verify the technical
validity of the assertion with no user interaction. Authoritative
assertions need only be verifiable. Third-party assertions also
[MUST]{.bcp14} be verified against local policy, as described in
[Section 8.1](#sec.id-format){.xref}.[¶](#section-7.5.2-1){.pilcrow}
:::
:::
:::

::: {#sec.request-assert}
::: {#section-7.6 .section}
### [7.6.](#section-7.6){.section-number .selfRef} [Requesting Assertions](#name-requesting-assertions){.section-name .selfRef} {#name-requesting-assertions}

The input to the identity assertion generation process is the
JSON-encoded object described in [Section 7.4](#sec.jsep-binding){.xref}
that contains the set of certificate fingerprints the browser intends to
use. This string is treated as opaque from the perspective of the
IdP.[¶](#section-7.6-1){.pilcrow}

The browser also identifies the origin that the PeerConnection is run
in, which allows the IdP to make decisions based on who is requesting
the assertion.[¶](#section-7.6-2){.pilcrow}

An application can optionally provide a user identifier hint when
specifying an IdP. This value is a hint that the IdP can use to select
amongst multiple identities, or to avoid providing assertions for
unwanted identities. The \"username\" is a string that has no meaning to
any entity other than the IdP; it can contain any data the IdP needs in
order to correctly generate an assertion.[¶](#section-7.6-3){.pilcrow}

An identity assertion that is successfully provided by the IdP consists
of the following information:[¶](#section-7.6-4){.pilcrow}

[]{.break}

idp:
:   The domain name of an IdP and the protocol string. This
    [MAY]{.bcp14} identify a different IdP or protocol from the one that
    generated the assertion.[¶](#section-7.6-5.2){.pilcrow}
:   

assertion:
:   An opaque value containing the assertion itself. This is only
    interpretable by the identified IdP or the IdP code running in the
    client.[¶](#section-7.6-5.4){.pilcrow}
:   

[Figure 5](#fig.assert-ex){.xref} shows an example assertion formatted
as JSON. In this case, the message has presumably been digitally
signed/MACed in some way that the IdP can later verify it, but this is
an implementation detail and out of scope of this
document.[¶](#section-7.6-6){.pilcrow}

[]{#name-example-assertion}

::: {#fig.assert-ex}
::: {#section-7.6-7.1}
``` {.sourcecode .lang-json}
{
  "idp":{
    "domain": "example.org",
    "protocol": "bogus"
  },
  "assertion": "{\"identity\":\"bob@example.org\",
                 \"contents\":\"abcdefghijklmnopqrstuvwyz\",
                 \"signature\":\"010203040506\"}"
}
```
:::

[Figure 5](#figure-5){.selfRef}: [Example
Assertion](#name-example-assertion){.selfRef}
:::

For use in signaling, the assertion is serialized into JSON,
[base64-encoded](#RFC4648){.xref} \[[RFC4648](#RFC4648){.xref}\], and
used as the value of the \"identity\" attribute. IdPs [SHOULD]{.bcp14}
ensure that any assertions they generate cannot be interpreted in a
different context. E.g., they should use a distinct format or have
separate cryptographic keys for assertion generation and other purposes.
Line breaks are inserted solely for
readability.[¶](#section-7.6-8){.pilcrow}
:::
:::

::: {#sec.user-login}
::: {#section-7.7 .section}
### [7.7.](#section-7.7){.section-number .selfRef} [Managing User Login](#name-managing-user-login){.section-name .selfRef} {#name-managing-user-login}

In order to generate an identity assertion, the IdP needs proof of the
user\'s identity. It is common practice to authenticate users (using
passwords or multi-factor authentication), then use
[cookies](#RFC6265){.xref} \[[RFC6265](#RFC6265){.xref}\] or [HTTP
authentication](#RFC7617){.xref} \[[RFC7617](#RFC7617){.xref}\] for
subsequent exchanges.[¶](#section-7.7-1){.pilcrow}

The IdP proxy is able to access cookies, HTTP authentication data, or
other persistent session data because it operates in the security
context of the IdP origin. Therefore, if a user is logged in, the IdP
could have all the information needed to generate an
assertion.[¶](#section-7.7-2){.pilcrow}

An IdP proxy is unable to generate an assertion if the user is not
logged in, or the IdP wants to interact with the user to acquire more
information before generating the assertion. If the IdP wants to
interact with the user before generating an assertion, the IdP proxy can
fail to generate an assertion and instead indicate a URL where login
should proceed.[¶](#section-7.7-3){.pilcrow}

The application can then load the provided URL to enable the user to
enter credentials. The communication between the application and the IdP
is described in
\[[webrtc-api](#webrtc-api){.xref}\].[¶](#section-7.7-4){.pilcrow}
:::
:::
:::
:::

::: {#sec.verify-assert}
::: {#section-8 .section}
## [8.](#section-8){.section-number .selfRef} [Verifying Assertions](#name-verifying-assertions){.section-name .selfRef} {#name-verifying-assertions}

The input to identity validation is the assertion string taken from a
decoded \"identity\" attribute.[¶](#section-8-1){.pilcrow}

The IdP proxy verifies the assertion. Depending on the identity
protocol, the proxy might contact the IdP server or other servers. For
instance, an OAuth-based protocol will likely require using the IdP as
an oracle, whereas with a signature-based scheme it might be able to
verify the assertion without contacting the IdP, provided that it has
cached the relevant public key.[¶](#section-8-2){.pilcrow}

Regardless of the mechanism, if verification succeeds, a successful
response from the IdP proxy consists of the following
information:[¶](#section-8-3){.pilcrow}

[]{.break}

identity:
:   The identity of the AP from the IdP\'s perspective. Details of this
    are provided in [Section
    8.1](#sec.id-format){.xref}.[¶](#section-8-4.2){.pilcrow}
:   

contents:
:   The original unmodified string provided by the AP as input to the
    assertion generation process.[¶](#section-8-4.4){.pilcrow}
:   

[Figure 6](#fig.verify-ex){.xref} shows an example response, which is
JSON-formatted.[¶](#section-8-5){.pilcrow}

[]{#name-example-verification-result}

::: {#fig.verify-ex}
::: {#section-8-6.1}
``` {.sourcecode .lang-json}
{
  "identity": "bob@example.org",
  "contents": "{\"fingerprint\":[ ... ]}"
}
```
:::

[Figure 6](#figure-6){.selfRef}: [Example Verification
Result](#name-example-verification-result){.selfRef}
:::

::: {#sec.id-format}
::: {#section-8.1 .section}
### [8.1.](#section-8.1){.section-number .selfRef} [Identity Formats](#name-identity-formats){.section-name .selfRef} {#name-identity-formats}

The identity provided from the IdP to the RP browser [MUST]{.bcp14}
consist of a string representing the user\'s identity. This string is in
the form \"\<user>@\<domain>\", where \"user\" consists of any
character, and domain is an internationalized domain name
\[[RFC5890](#RFC5890){.xref}\] encoded as a sequence of
U-labels.[¶](#section-8.1-1){.pilcrow}

The PeerConnection API [MUST]{.bcp14} check this string as
follows:[¶](#section-8.1-2){.pilcrow}

1.  [If the \"domain\" portion of the string is equal to the domain name
    of the IdP proxy, then the assertion is valid, as the IdP is
    authoritative for this domain. Comparison of domain names is done
    using the label equivalence rule defined in [Section
    2.3.2.4](https://www.rfc-editor.org/rfc/rfc5890#section-2.3.2.4){.relref}
    of
    \[[RFC5890](#RFC5890){.xref}\].[¶](#section-8.1-3.1){.pilcrow}]{#section-8.1-3.1}

2.  ::: {#section-8.1-3.2}
    If the \"domain\" portion of the string is not equal to the domain
    name of the IdP proxy, then the PeerConnection object [MUST]{.bcp14}
    reject the assertion unless both:[¶](#section-8.1-3.2.1){.pilcrow}

    1.  [the IdP domain is trusted as an acceptable third-party IdP;
        and[¶](#section-8.1-3.2.2.1){.pilcrow}]{#section-8.1-3.2.2.1}
    2.  [local policy is configured to trust this IdP domain for the
        domain portion of the identity
        string.[¶](#section-8.1-3.2.2.2){.pilcrow}]{#section-8.1-3.2.2.2}
    :::

Any \'@\' or \'%\' characters in the \"user\" portion of the identity
[MUST]{.bcp14} be escaped according to the \"percent-encoding\" rules
defined in [Section
2.1](https://www.rfc-editor.org/rfc/rfc3986#section-2.1){.relref} of
\[[RFC3986](#RFC3986){.xref}\]. Characters other than \'@\' and \'%\'
[MUST NOT]{.bcp14} be percent-encoded. For example, with a \"user\" of
\"user\@133\" and a \"domain\" of \"identity.example.com\", the
resulting string will be encoded as
\"user%40133\@identity.example.com\".[¶](#section-8.1-4){.pilcrow}

Implementations are cautioned to take care when displaying user
identities containing escaped \'@\' characters. If such characters are
unescaped prior to display, implementations [MUST]{.bcp14} distinguish
between the domain of the IdP proxy and any domain that might be implied
by the portion of the \"\<user>\" portion that appears after the escaped
\"@\" sign.[¶](#section-8.1-5){.pilcrow}
:::
:::
:::
:::

::: {#sec.sec-cons}
::: {#section-9 .section}
## [9.](#section-9){.section-number .selfRef} [Security Considerations](#name-security-considerations){.section-name .selfRef} {#name-security-considerations}

Much of the security analysis of RTCWEB is contained in
\[[RFC8826](#RFC8826){.xref}\] or in the discussion of the particular
issues above. In order to avoid repetition, this section focuses on (a)
residual threats that are not addressed by this document and (b) threats
produced by failure/misbehavior of one of the components in the
system.[¶](#section-9-1){.pilcrow}

::: {#section-9.1 .section}
### [9.1.](#section-9.1){.section-number .selfRef} [Communications Security](#name-communications-security-2){.section-name .selfRef} {#name-communications-security-2}

If HTTPS is not used to secure communications to the signaling server,
and the identity mechanism used in [Section 7](#sec.generic.idp){.xref}
is not used, then any on-path attacker can replace the DTLS-SRTP
fingerprints in the handshake and thus substitute its own identity for
that of either endpoint.[¶](#section-9.1-1){.pilcrow}

Even if HTTPS is used, the signaling server can potentially mount a
man-in-the-middle attack unless implementations have some mechanism for
independently verifying keys. The UI requirements in [Section
6.5](#sec.proposal.comsec){.xref} are designed to provide such a
mechanism for motivated/security conscious users, but are not suitable
for general use. The identity service mechanisms in [Section
7](#sec.generic.idp){.xref} are more suitable for general use. Note,
however, that a malicious signaling service can strip off any such
identity assertions, though it cannot forge new ones. Note that all of
the third-party security mechanisms available (whether X.509
certificates or a third-party IdP) rely on the security of the third
party \-- this is of course also true of the user\'s connection to the
Web site itself. Users who wish to assure themselves of security against
a malicious IdP can only do so by verifying peer credentials directly,
e.g., by checking the peer\'s fingerprint against a value delivered out
of band.[¶](#section-9.1-2){.pilcrow}

In order to protect against malicious content JavaScript, that
JavaScript [MUST NOT]{.bcp14} be allowed to have direct access to \-- or
perform computations with \-- DTLS keys. For instance, if content JS
were able to compute digital signatures, then it would be possible for
content JS to get an identity assertion for a browser\'s generated key
and then use that assertion plus a signature by the key to authenticate
a call protected under an ephemeral Diffie-Hellman (DH) key controlled
by the content JS, thus violating the security guarantees otherwise
provided by the IdP mechanism. Note that it is not sufficient merely to
deny the content JS direct access to the keys, as some have suggested
doing with the WebCrypto API \[[webcrypto](#webcrypto){.xref}\]. The JS
must also not be allowed to perform operations that would be valid for a
DTLS endpoint. By far the safest approach is simply to deny the ability
to perform any operations that depend on secret information associated
with the key. Operations that depend on public information, such as
exporting the public key, are of course
safe.[¶](#section-9.1-3){.pilcrow}
:::

::: {#section-9.2 .section}
### [9.2.](#section-9.2){.section-number .selfRef} [Privacy](#name-privacy){.section-name .selfRef} {#name-privacy}

The requirements in this document are intended to
allow:[¶](#section-9.2-1){.pilcrow}

-   [Users to participate in calls without revealing their
    location.[¶](#section-9.2-2.1){.pilcrow}]{#section-9.2-2.1}
-   [Potential callees to avoid revealing their location and even
    presence status prior to agreeing to answer a
    call.[¶](#section-9.2-2.2){.pilcrow}]{#section-9.2-2.2}

However, these privacy protections come at a performance cost in terms
of using TURN relays and, in the latter case, delaying ICE. Sites
[SHOULD]{.bcp14} make users aware of these
tradeoffs.[¶](#section-9.2-3){.pilcrow}

Note that the protections provided here assume a non-malicious calling
service. As the calling service always knows the user\'s status and
(absent the use of a technology like Tor) their IP address, they can
violate the user\'s privacy at will. Users who wish privacy against the
calling sites they are using must use separate privacy-enhancing
technologies such as Tor. Combined WebRTC/Tor implementations
[SHOULD]{.bcp14} arrange to route the media as well as the signaling
through Tor. Currently this will produce very suboptimal
performance.[¶](#section-9.2-4){.pilcrow}

Additionally, any identifier which persists across multiple calls is
potentially a problem for privacy, especially for anonymous calling
services. Such services [SHOULD]{.bcp14} instruct the browser to use
separate DTLS keys for each call and also to use TURN throughout the
call. Otherwise, the other side will learn linkable information that
would allow them to correlate the browser across multiple calls.
Additionally, browsers [SHOULD]{.bcp14} implement the privacy-preserving
CNAME generation mode of
\[[RFC7022](#RFC7022){.xref}\].[¶](#section-9.2-5){.pilcrow}
:::

::: {#section-9.3 .section}
### [9.3.](#section-9.3){.section-number .selfRef} [Denial of Service](#name-denial-of-service){.section-name .selfRef} {#name-denial-of-service}

The consent mechanisms described in this document are intended to
mitigate denial-of-service (DoS) attacks in which an attacker uses
clients to send large amounts of traffic to a victim without the consent
of the victim. While these mechanisms are sufficient to protect victims
who have not implemented WebRTC at all, WebRTC implementations need to
be more careful.[¶](#section-9.3-1){.pilcrow}

Consider the case of a call center which accepts calls via WebRTC. An
attacker proxies the call center\'s front-end and arranges for multiple
clients to initiate calls to the call center. Note that this requires
user consent in many cases, but because the data channel does not need
consent, they can use that directly. Since ICE will complete, browsers
can then be induced to send large amounts of data to the victim call
center if it supports the data channel at all. Preventing this attack
requires that automated WebRTC implementations implement sensible flow
control and have the ability to triage out (i.e., stop responding to ICE
probes on) calls which are behaving badly, and especially to be prepared
to remotely throttle the data channel in the absence of plausible audio
and video (which the attacker cannot
control).[¶](#section-9.3-2){.pilcrow}

Another related attack is for the signaling service to swap the ICE
candidates for the audio and video streams, thus forcing a browser to
send video to the sink that the other victim expects will contain audio
(perhaps it is only expecting audio!), potentially causing overload.
Muxing multiple media flows over a single transport makes it harder to
individually suppress a single flow by denying ICE keepalives. Either
media-level (RTCP) mechanisms must be used or the implementation must
deny responses entirely, thus terminating the
call.[¶](#section-9.3-3){.pilcrow}

Yet another attack, suggested by Magnus Westerlund, is for the attacker
to cross-connect offers and answers as follows. It induces the victim to
make a call and then uses its control of other users\' browsers to get
them to attempt a call to someone. It then translates their offers into
apparent answers to the victim, which looks like large-scale parallel
forking. The victim still responds to ICE responses, and now the
browsers all try to send media to the victim. Implementations can defend
themselves from this attack by only responding to ICE Binding Requests
for a limited number of remote ufrags (this is the reason for the
requirement that the JS not be able to control the ufrag and password).
\[[RFC8834](#RFC8834){.xref}\], [Section
13](https://www.rfc-editor.org/rfc/rfc8834#section-13){.relref}
documents a number of potential RTCP-based DoS attacks and
countermeasures.[¶](#section-9.3-4){.pilcrow}

Note that attacks based on confusing one end or the other about consent
are possible even in the face of the third-party identity mechanism as
long as major parts of the signaling messages are not signed. On the
other hand, signing the entire message severely restricts the
capabilities of the calling application, so there are difficult
tradeoffs here.[¶](#section-9.3-5){.pilcrow}
:::

::: {#section-9.4 .section}
### [9.4.](#section-9.4){.section-number .selfRef} [IdP Authentication Mechanism](#name-idp-authentication-mechanis){.section-name .selfRef} {#name-idp-authentication-mechanis}

This mechanism relies for its security on the IdP and on the
PeerConnection correctly enforcing the security invariants described
above. At a high level, the IdP is attesting that the user identified in
the assertion wishes to be associated with the assertion. Thus, it must
not be possible for arbitrary third parties to get assertions tied to a
user or to produce assertions that RPs will
accept.[¶](#section-9.4-1){.pilcrow}

::: {#sec.pc-origin}
::: {#section-9.4.1 .section}
#### [9.4.1.](#section-9.4.1){.section-number .selfRef} [PeerConnection Origin Check](#name-peerconnection-origin-check){.section-name .selfRef} {#name-peerconnection-origin-check}

Fundamentally, the IdP proxy is just a piece of HTML and JS loaded by
the browser, so nothing stops a Web attacker from creating their own
IFRAME, loading the IdP proxy HTML/JS, and requesting a signature over
their own keys rather than those generated in the browser. However, that
proxy would be in the attacker\'s origin, not the IdP\'s origin. Only
the browser itself can instantiate a context that (a) is in the IdP\'s
origin and (b) exposes the correct API surface. Thus, the IdP proxy on
the sender\'s side [MUST]{.bcp14} ensure that it is running in the
IdP\'s origin prior to issuing
assertions.[¶](#section-9.4.1-1){.pilcrow}

Note that this check only asserts that the browser (or some other entity
with access to the user\'s authentication data) attests to the request
and hence to the fingerprint. It does not demonstrate that the browser
has access to the associated private key, and therefore an attacker can
attach their own identity to another party\'s keying material, thus
making a call which comes from Alice appear to come from the attacker.
See \[[RFC8844](#RFC8844){.xref}\] for defenses against this form of
attack.[¶](#section-9.4.1-2){.pilcrow}
:::
:::

::: {#sec.sec-idp-uri}
::: {#section-9.4.2 .section}
#### [9.4.2.](#section-9.4.2){.section-number .selfRef} [IdP Well-Known URI](#name-idp-well-known-uri){.section-name .selfRef} {#name-idp-well-known-uri}

As described in [Section 7.5](#sec.idp-uri){.xref}, the IdP proxy
HTML/JS landing page is located at a well-known URI based on the IdP\'s
domain name. This requirement prevents an attacker who can write some
resources at the IdP (e.g., on one\'s Facebook wall) from being able to
impersonate the IdP.[¶](#section-9.4.2-1){.pilcrow}
:::
:::

::: {#section-9.4.3 .section}
#### [9.4.3.](#section-9.4.3){.section-number .selfRef} [Privacy of IdP-Generated Identities and the Hosting Site](#name-privacy-of-idp-generated-id){.section-name .selfRef} {#name-privacy-of-idp-generated-id}

Depending on the structure of the IdP\'s assertions, the calling site
may learn the user\'s identity from the perspective of the IdP. In many
cases, this is not an issue because the user is authenticating to the
site via the IdP in any case \-- for instance, when the user has logged
in with Facebook Connect and is then authenticating their call with a
Facebook identity. However, in other cases, the user may not have
already revealed their identity to the site. In general, IdPs
[SHOULD]{.bcp14} either verify that the user is willing to have their
identity revealed to the site (e.g., through the usual IdP permissions
dialog) or arrange that the identity information is only available to
known RPs (e.g., social graph adjacencies) but not to the calling site.
The \"domain\" field of the assertion request can be used to check that
the user has agreed to disclose their identity to the calling site;
because it is supplied by the PeerConnection it can be trusted to be
correct.[¶](#section-9.4.3-1){.pilcrow}
:::

::: {#sec.sec-third-party}
::: {#section-9.4.4 .section}
#### [9.4.4.](#section-9.4.4){.section-number .selfRef} [Security of Third-Party IdPs](#name-security-of-third-party-idp){.section-name .selfRef} {#name-security-of-third-party-idp}

As discussed above, each third-party IdP represents a new universal
trust point and therefore the number of these IdPs needs to be quite
limited. Most IdPs, even those which issue unqualified identities such
as Facebook, can be recast as authoritative IdPs (e.g.,
123456\@facebook.com). However, in such cases, the user interface
implications are not entirely desirable. One intermediate approach is to
have special (potentially user configurable) UI for large authoritative
IdPs, thus allowing the user to instantly grasp that the call is being
authenticated by Facebook, Google, etc.[¶](#section-9.4.4-1){.pilcrow}

::: {#section-9.4.4.1 .section}
##### [9.4.4.1.](#section-9.4.4.1){.section-number .selfRef} [Confusable Characters](#name-confusable-characters){.section-name .selfRef} {#name-confusable-characters}

Because a broad range of characters are permitted in identity strings,
it may be possible for attackers to craft identities which are
confusable with other identities (see \[[RFC6943](#RFC6943){.xref}\] for
more on this topic). This is a problem with any identifier space of this
type (e.g., email addresses). Those minting identifiers should avoid
mixed scripts and similar confusable characters. Those presenting these
identifiers to a user should consider highlighting cases of mixed script
usage (see \[[RFC5890](#RFC5890){.xref}\], [Section
4.4](https://www.rfc-editor.org/rfc/rfc5890#section-4.4){.relref}).
Other best practices are still in
development.[¶](#section-9.4.4.1-1){.pilcrow}
:::
:::
:::

::: {#section-9.4.5 .section}
#### [9.4.5.](#section-9.4.5){.section-number .selfRef} [Web Security Feature Interactions](#name-web-security-feature-intera){.section-name .selfRef} {#name-web-security-feature-intera}

A number of optional Web security features have the potential to cause
issues for this mechanism, as discussed
below.[¶](#section-9.4.5-1){.pilcrow}

::: {#sec.popup-blocking}
::: {#section-9.4.5.1 .section}
##### [9.4.5.1.](#section-9.4.5.1){.section-number .selfRef} [Popup Blocking](#name-popup-blocking){.section-name .selfRef} {#name-popup-blocking}

When popup blocking is in use, the IdP proxy is unable to generate popup
windows, dialogs, or any other form of user interactions. This prevents
the IdP proxy from being used to circumvent user interaction. The
\"LOGINNEEDED\" message allows the IdP proxy to inform the calling site
of a need for user login, providing the information necessary to satisfy
this requirement without resorting to direct user interaction from the
IdP proxy itself.[¶](#section-9.4.5.1-1){.pilcrow}
:::
:::

::: {#sec.3rd-party-cookies}
::: {#section-9.4.5.2 .section}
##### [9.4.5.2.](#section-9.4.5.2){.section-number .selfRef} [Third Party Cookies](#name-third-party-cookies){.section-name .selfRef} {#name-third-party-cookies}

Some browsers allow users to block third party cookies (cookies
associated with origins other than the top-level page) for privacy
reasons. Any IdP which uses cookies to persist logins will be broken by
third-party cookie blocking. One option is to accept this as a
limitation; another is to have the PeerConnection object disable
third-party cookie blocking for the IdP
proxy.[¶](#section-9.4.5.2-1){.pilcrow}
:::
:::
:::
:::
:::
:::

::: {#sec.iana-cons}
::: {#section-10 .section}
## [10.](#section-10){.section-number .selfRef} [IANA Considerations](#name-iana-considerations){.section-name .selfRef} {#name-iana-considerations}

This specification defines the \"identity\" SDP attribute per the
procedures of [Section
8.2.4](https://www.rfc-editor.org/rfc/rfc4566#section-8.2.4){.relref} of
\[[RFC4566](#RFC4566){.xref}\]. The required information for the
registration is included here:[¶](#section-10-1){.pilcrow}

[]{.break}

Contact Name:
:   IESG (iesg\@ietf.org)[¶](#section-10-2.2){.pilcrow}
:   

Attribute Name:
:   identity[¶](#section-10-2.4){.pilcrow}
:   

Long Form:
:   identity[¶](#section-10-2.6){.pilcrow}
:   

Type of Attribute:
:   session[¶](#section-10-2.8){.pilcrow}
:   

Charset Considerations:
:   This attribute is not subject to the charset
    attribute.[¶](#section-10-2.10){.pilcrow}
:   

Purpose:
:   This attribute carries an identity assertion, binding an identity to
    the transport-level security session.[¶](#section-10-2.12){.pilcrow}
:   

Appropriate Values:
:   See [Section 5](#sec.sdp-id-attr){.xref} of RFC
    8827.[¶](#section-10-2.14){.pilcrow}
:   

Mux Category:
:   NORMAL[¶](#section-10-2.16){.pilcrow}
:   

This section registers the \"idp-proxy\" well-known URI from
\[[RFC8615](#RFC8615){.xref}\].[¶](#section-10-3){.pilcrow}

[]{.break}

URI suffix:
:   idp-proxy[¶](#section-10-4.2){.pilcrow}
:   

Change controller:
:   IETF[¶](#section-10-4.4){.pilcrow}
:   
:::
:::

::: {#section-11 .section}
## [11.](#section-11){.section-number .selfRef} [References](#name-references){.section-name .selfRef} {#name-references}

::: {#section-11.1 .section}
### [11.1.](#section-11.1){.section-number .selfRef} [Normative References](#name-normative-references){.section-name .selfRef} {#name-normative-references}

\[FIPS186\]
:   [National Institute of Standards and Technology (NIST)]{.refAuthor},
    [\"Digital Signature Standard (DSS)\"]{.refTitle}, [NIST PUB
    186-4]{.seriesInfo}, [DOI 10.6028/NIST.FIPS.186-4]{.seriesInfo},
    July 2013, \<<https://doi.org/10.6028/NIST.FIPS.186-4>\>.
:   

\[RFC2119\]
:   [Bradner, S.]{.refAuthor}, [\"Key words for use in RFCs to Indicate
    Requirement Levels\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    2119]{.seriesInfo}, [DOI 10.17487/RFC2119]{.seriesInfo}, March 1997,
    \<<https://www.rfc-editor.org/info/rfc2119>\>.
:   

\[RFC2818\]
:   [Rescorla, E.]{.refAuthor}, [\"HTTP Over TLS\"]{.refTitle}, [RFC
    2818]{.seriesInfo}, [DOI 10.17487/RFC2818]{.seriesInfo}, May 2000,
    \<<https://www.rfc-editor.org/info/rfc2818>\>.
:   

\[RFC3264\]
:   [Rosenberg, J.]{.refAuthor}[ and H. Schulzrinne]{.refAuthor}, [\"An
    Offer/Answer Model with Session Description Protocol
    (SDP)\"]{.refTitle}, [RFC 3264]{.seriesInfo}, [DOI
    10.17487/RFC3264]{.seriesInfo}, June 2002,
    \<<https://www.rfc-editor.org/info/rfc3264>\>.
:   

\[RFC3711\]
:   [Baugher, M.]{.refAuthor}[, McGrew, D.]{.refAuthor}[,
    Naslund, M.]{.refAuthor}[, Carrara, E.]{.refAuthor}[, and K.
    Norrman]{.refAuthor}, [\"The Secure Real-time Transport Protocol
    (SRTP)\"]{.refTitle}, [RFC 3711]{.seriesInfo}, [DOI
    10.17487/RFC3711]{.seriesInfo}, March 2004,
    \<<https://www.rfc-editor.org/info/rfc3711>\>.
:   

\[RFC3986\]
:   [Berners-Lee, T.]{.refAuthor}[, Fielding, R.]{.refAuthor}[, and L.
    Masinter]{.refAuthor}, [\"Uniform Resource Identifier (URI): Generic
    Syntax\"]{.refTitle}, [STD 66]{.seriesInfo}, [RFC
    3986]{.seriesInfo}, [DOI 10.17487/RFC3986]{.seriesInfo}, January
    2005, \<<https://www.rfc-editor.org/info/rfc3986>\>.
:   

\[RFC4566\]
:   [Handley, M.]{.refAuthor}[, Jacobson, V.]{.refAuthor}[, and C.
    Perkins]{.refAuthor}, [\"SDP: Session Description
    Protocol\"]{.refTitle}, [RFC 4566]{.seriesInfo}, [DOI
    10.17487/RFC4566]{.seriesInfo}, July 2006,
    \<<https://www.rfc-editor.org/info/rfc4566>\>.
:   

\[RFC4568\]
:   [Andreasen, F.]{.refAuthor}[, Baugher, M.]{.refAuthor}[, and D.
    Wing]{.refAuthor}, [\"Session Description Protocol (SDP) Security
    Descriptions for Media Streams\"]{.refTitle}, [RFC
    4568]{.seriesInfo}, [DOI 10.17487/RFC4568]{.seriesInfo}, July 2006,
    \<<https://www.rfc-editor.org/info/rfc4568>\>.
:   

\[RFC4648\]
:   [Josefsson, S.]{.refAuthor}, [\"The Base16, Base32, and Base64 Data
    Encodings\"]{.refTitle}, [RFC 4648]{.seriesInfo}, [DOI
    10.17487/RFC4648]{.seriesInfo}, October 2006,
    \<<https://www.rfc-editor.org/info/rfc4648>\>.
:   

\[RFC5763\]
:   [Fischl, J.]{.refAuthor}[, Tschofenig, H.]{.refAuthor}[, and E.
    Rescorla]{.refAuthor}, [\"Framework for Establishing a Secure
    Real-time Transport Protocol (SRTP) Security Context Using Datagram
    Transport Layer Security (DTLS)\"]{.refTitle}, [RFC
    5763]{.seriesInfo}, [DOI 10.17487/RFC5763]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5763>\>.
:   

\[RFC5764\]
:   [McGrew, D.]{.refAuthor}[ and E. Rescorla]{.refAuthor}, [\"Datagram
    Transport Layer Security (DTLS) Extension to Establish Keys for the
    Secure Real-time Transport Protocol (SRTP)\"]{.refTitle}, [RFC
    5764]{.seriesInfo}, [DOI 10.17487/RFC5764]{.seriesInfo}, May 2010,
    \<<https://www.rfc-editor.org/info/rfc5764>\>.
:   

\[RFC5890\]
:   [Klensin, J.]{.refAuthor}, [\"Internationalized Domain Names for
    Applications (IDNA): Definitions and Document
    Framework\"]{.refTitle}, [RFC 5890]{.seriesInfo}, [DOI
    10.17487/RFC5890]{.seriesInfo}, August 2010,
    \<<https://www.rfc-editor.org/info/rfc5890>\>.
:   

\[RFC6347\]
:   [Rescorla, E.]{.refAuthor}[ and N. Modadugu]{.refAuthor},
    [\"Datagram Transport Layer Security Version 1.2\"]{.refTitle}, [RFC
    6347]{.seriesInfo}, [DOI 10.17487/RFC6347]{.seriesInfo}, January
    2012, \<<https://www.rfc-editor.org/info/rfc6347>\>.
:   

\[RFC6454\]
:   [Barth, A.]{.refAuthor}, [\"The Web Origin Concept\"]{.refTitle},
    [RFC 6454]{.seriesInfo}, [DOI 10.17487/RFC6454]{.seriesInfo},
    December 2011, \<<https://www.rfc-editor.org/info/rfc6454>\>.
:   

\[RFC7022\]
:   [Begen, A.]{.refAuthor}[, Perkins, C.]{.refAuthor}[,
    Wing, D.]{.refAuthor}[, and E. Rescorla]{.refAuthor}, [\"Guidelines
    for Choosing RTP Control Protocol (RTCP) Canonical Names
    (CNAMEs)\"]{.refTitle}, [RFC 7022]{.seriesInfo}, [DOI
    10.17487/RFC7022]{.seriesInfo}, September 2013,
    \<<https://www.rfc-editor.org/info/rfc7022>\>.
:   

\[RFC7675\]
:   [Perumal, M.]{.refAuthor}[, Wing, D.]{.refAuthor}[,
    Ravindranath, R.]{.refAuthor}[, Reddy, T.]{.refAuthor}[, and M.
    Thomson]{.refAuthor}, [\"Session Traversal Utilities for NAT (STUN)
    Usage for Consent Freshness\"]{.refTitle}, [RFC 7675]{.seriesInfo},
    [DOI 10.17487/RFC7675]{.seriesInfo}, October 2015,
    \<<https://www.rfc-editor.org/info/rfc7675>\>.
:   

\[RFC7918\]
:   [Langley, A.]{.refAuthor}[, Modadugu, N.]{.refAuthor}[, and B.
    Moeller]{.refAuthor}, [\"Transport Layer Security (TLS) False
    Start\"]{.refTitle}, [RFC 7918]{.seriesInfo}, [DOI
    10.17487/RFC7918]{.seriesInfo}, August 2016,
    \<<https://www.rfc-editor.org/info/rfc7918>\>.
:   

\[RFC8122\]
:   [Lennox, J.]{.refAuthor}[ and C. Holmberg]{.refAuthor},
    [\"Connection-Oriented Media Transport over the Transport Layer
    Security (TLS) Protocol in the Session Description Protocol
    (SDP)\"]{.refTitle}, [RFC 8122]{.seriesInfo}, [DOI
    10.17487/RFC8122]{.seriesInfo}, March 2017,
    \<<https://www.rfc-editor.org/info/rfc8122>\>.
:   

\[RFC8174\]
:   [Leiba, B.]{.refAuthor}, [\"Ambiguity of Uppercase vs Lowercase in
    RFC 2119 Key Words\"]{.refTitle}, [BCP 14]{.seriesInfo}, [RFC
    8174]{.seriesInfo}, [DOI 10.17487/RFC8174]{.seriesInfo}, May 2017,
    \<<https://www.rfc-editor.org/info/rfc8174>\>.
:   

\[RFC8259\]
:   [Bray, T., Ed.]{.refAuthor}, [\"The JavaScript Object Notation
    (JSON) Data Interchange Format\"]{.refTitle}, [STD 90]{.seriesInfo},
    [RFC 8259]{.seriesInfo}, [DOI 10.17487/RFC8259]{.seriesInfo},
    December 2017, \<<https://www.rfc-editor.org/info/rfc8259>\>.
:   

\[RFC8261\]
:   [Tuexen, M.]{.refAuthor}[, Stewart, R.]{.refAuthor}[,
    Jesup, R.]{.refAuthor}[, and S. Loreto]{.refAuthor}, [\"Datagram
    Transport Layer Security (DTLS) Encapsulation of SCTP
    Packets\"]{.refTitle}, [RFC 8261]{.seriesInfo}, [DOI
    10.17487/RFC8261]{.seriesInfo}, November 2017,
    \<<https://www.rfc-editor.org/info/rfc8261>\>.
:   

\[RFC8445\]
:   [Keranen, A.]{.refAuthor}[, Holmberg, C.]{.refAuthor}[, and J.
    Rosenberg]{.refAuthor}, [\"Interactive Connectivity Establishment
    (ICE): A Protocol for Network Address Translator (NAT)
    Traversal\"]{.refTitle}, [RFC 8445]{.seriesInfo}, [DOI
    10.17487/RFC8445]{.seriesInfo}, July 2018,
    \<<https://www.rfc-editor.org/info/rfc8445>\>.
:   

\[RFC8446\]
:   [Rescorla, E.]{.refAuthor}, [\"The Transport Layer Security (TLS)
    Protocol Version 1.3\"]{.refTitle}, [RFC 8446]{.seriesInfo}, [DOI
    10.17487/RFC8446]{.seriesInfo}, August 2018,
    \<<https://www.rfc-editor.org/info/rfc8446>\>.
:   

\[RFC8615\]
:   [Nottingham, M.]{.refAuthor}, [\"Well-Known Uniform Resource
    Identifiers (URIs)\"]{.refTitle}, [RFC 8615]{.seriesInfo}, [DOI
    10.17487/RFC8615]{.seriesInfo}, May 2019,
    \<<https://www.rfc-editor.org/info/rfc8615>\>.
:   

\[RFC8825\]
:   [Alvestrand, H.]{.refAuthor}, [\"Overview: Real-Time Protocols for
    Browser-Based Applications\"]{.refTitle}, [RFC 8825]{.seriesInfo},
    [DOI 10.17487/RFC8825]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8825>\>.
:   

\[RFC8826\]
:   [Rescorla, E.]{.refAuthor}, [\"Security Considerations for
    WebRTC\"]{.refTitle}, [RFC 8826]{.seriesInfo}, [DOI
    10.17487/RFC8826]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8826>\>.
:   

\[RFC8829\]
:   [Uberti, J.]{.refAuthor}[, Jennings, C.]{.refAuthor}[, and E.
    Rescorla, Ed.]{.refAuthor}, [\"JavaScript Session Establishment
    Protocol (JSEP)\"]{.refTitle}, [RFC 8829]{.seriesInfo}, [DOI
    10.17487/RFC8829]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8829>\>.
:   

\[RFC8834\]
:   [Perkins, C.]{.refAuthor}[, Westerlund, M.]{.refAuthor}[, and J.
    Ott]{.refAuthor}, [\"Media Transport and Use of RTP in
    WebRTC\"]{.refTitle}, [RFC 8834]{.seriesInfo}, [DOI
    10.17487/RFC8834]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8834>\>.
:   

\[RFC8844\]
:   [Thomson, M.]{.refAuthor}[ and E. Rescorla]{.refAuthor}, [\"Unknown
    Key-Share Attacks on Uses of TLS with the Session Description
    Protocol (SDP)\"]{.refTitle}, [RFC 8844]{.seriesInfo}, [DOI
    10.17487/RFC8844]{.seriesInfo}, January 2021,
    \<<https://www.rfc-editor.org/info/rfc8844>\>.
:   

\[webcrypto\]
:   [Watson, M.]{.refAuthor}, [\"Web Cryptography API\"]{.refTitle},
    [W3C Recommendation]{.refContent}, 26 January 2017,
    \<<https://www.w3.org/TR/2017/REC-WebCryptoAPI-20170126/>\>.
:   

\[webrtc-api\]
:   [Jennings, C.]{.refAuthor}[, Boström, H.]{.refAuthor}[, and J-I.
    Bruaroey]{.refAuthor}, [\"WebRTC 1.0: Real-time Communication
    Between Browsers\"]{.refTitle}, [W3C Proposed
    Recommendation]{.refContent}, \<<https://www.w3.org/TR/webrtc/>\>.
:   
:::

::: {#section-11.2 .section}
### [11.2.](#section-11.2){.section-number .selfRef} [Informative References](#name-informative-references){.section-name .selfRef} {#name-informative-references}

\[fetch\]
:   [van Kesteren, A.]{.refAuthor}, [\"Fetch\"]{.refTitle},
    \<<https://fetch.spec.whatwg.org/>\>.
:   

\[RFC3261\]
:   [Rosenberg, J.]{.refAuthor}[, Schulzrinne, H.]{.refAuthor}[,
    Camarillo, G.]{.refAuthor}[, Johnston, A.]{.refAuthor}[,
    Peterson, J.]{.refAuthor}[, Sparks, R.]{.refAuthor}[,
    Handley, M.]{.refAuthor}[, and E. Schooler]{.refAuthor}, [\"SIP:
    Session Initiation Protocol\"]{.refTitle}, [RFC 3261]{.seriesInfo},
    [DOI 10.17487/RFC3261]{.seriesInfo}, June 2002,
    \<<https://www.rfc-editor.org/info/rfc3261>\>.
:   

\[RFC5705\]
:   [Rescorla, E.]{.refAuthor}, [\"Keying Material Exporters for
    Transport Layer Security (TLS)\"]{.refTitle}, [RFC
    5705]{.seriesInfo}, [DOI 10.17487/RFC5705]{.seriesInfo}, March 2010,
    \<<https://www.rfc-editor.org/info/rfc5705>\>.
:   

\[RFC6120\]
:   [Saint-Andre, P.]{.refAuthor}, [\"Extensible Messaging and Presence
    Protocol (XMPP): Core\"]{.refTitle}, [RFC 6120]{.seriesInfo}, [DOI
    10.17487/RFC6120]{.seriesInfo}, March 2011,
    \<<https://www.rfc-editor.org/info/rfc6120>\>.
:   

\[RFC6265\]
:   [Barth, A.]{.refAuthor}, [\"HTTP State Management
    Mechanism\"]{.refTitle}, [RFC 6265]{.seriesInfo}, [DOI
    10.17487/RFC6265]{.seriesInfo}, April 2011,
    \<<https://www.rfc-editor.org/info/rfc6265>\>.
:   

\[RFC6455\]
:   [Fette, I.]{.refAuthor}[ and A. Melnikov]{.refAuthor}, [\"The
    WebSocket Protocol\"]{.refTitle}, [RFC 6455]{.seriesInfo}, [DOI
    10.17487/RFC6455]{.seriesInfo}, December 2011,
    \<<https://www.rfc-editor.org/info/rfc6455>\>.
:   

\[RFC6943\]
:   [Thaler, D., Ed.]{.refAuthor}, [\"Issues in Identifier Comparison
    for Security Purposes\"]{.refTitle}, [RFC 6943]{.seriesInfo}, [DOI
    10.17487/RFC6943]{.seriesInfo}, May 2013,
    \<<https://www.rfc-editor.org/info/rfc6943>\>.
:   

\[RFC7617\]
:   [Reschke, J.]{.refAuthor}, [\"The \'Basic\' HTTP Authentication
    Scheme\"]{.refTitle}, [RFC 7617]{.seriesInfo}, [DOI
    10.17487/RFC7617]{.seriesInfo}, September 2015,
    \<<https://www.rfc-editor.org/info/rfc7617>\>.
:   

\[RFC8224\]
:   [Peterson, J.]{.refAuthor}[, Jennings, C.]{.refAuthor}[,
    Rescorla, E.]{.refAuthor}[, and C. Wendt]{.refAuthor},
    [\"Authenticated Identity Management in the Session Initiation
    Protocol (SIP)\"]{.refTitle}, [RFC 8224]{.seriesInfo}, [DOI
    10.17487/RFC8224]{.seriesInfo}, February 2018,
    \<<https://www.rfc-editor.org/info/rfc8224>\>.
:   

\[RFC8828\]
:   [Uberti, J.]{.refAuthor}[ and G. Shieh]{.refAuthor}, [\"WebRTC IP
    Address Handling Requirements\"]{.refTitle}, [RFC
    8828]{.seriesInfo}, [DOI 10.17487/RFC8828]{.seriesInfo}, January
    2021, \<<https://www.rfc-editor.org/info/rfc8828>\>.
:   

\[TLS-DTLS13\]
:   [Rescorla, E.]{.refAuthor}[, Tschofenig, H.]{.refAuthor}[, and N.
    Modadugu]{.refAuthor}, [\"The Datagram Transport Layer Security
    (DTLS) Protocol Version 1.3\"]{.refTitle}, [Work in
    Progress]{.refContent}, [Internet-Draft,
    draft-ietf-tls-dtls13-39]{.seriesInfo}, 2 November 2020,
    \<<https://tools.ietf.org/html/draft-ietf-tls-dtls13-39>\>.
:   
:::
:::

::: {#section-appendix.a .section}
## [Acknowledgements](#name-acknowledgements){.section-name .selfRef} {#name-acknowledgements}

[Bernard Aboba]{.contact-name}, [Harald Alvestrand]{.contact-name},
[Richard Barnes]{.contact-name}, [Dan Druta]{.contact-name}, [Cullen
Jennings]{.contact-name}, [Hadriel Kaplan]{.contact-name}, [Matthew
Kaufman]{.contact-name}, [Jim McEachern]{.contact-name}, [Martin
Thomson]{.contact-name}, [Magnus Westerlund]{.contact-name}. [Matthew
Kaufman]{.contact-name} provided the UI material in [Section
6.5](#sec.proposal.comsec){.xref}. [Christer Holmberg]{.contact-name}
provided the initial version of [Section
5.1](#sec.sdp-id-attr-oa){.xref}.[¶](#section-appendix.a-1){.pilcrow}
:::

::: {#authors-addresses}
::: {#section-appendix.b .section}
## [Author\'s Address](#name-authors-address){.section-name .selfRef} {#name-authors-address}

::: {.left dir="auto"}
[Eric Rescorla]{.fn .nameRole}
:::

::: {.left dir="auto"}
[Mozilla]{.org}
:::

::: email
Email: <ekr@rtfm.com>
:::
:::
:::
